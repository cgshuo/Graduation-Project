 1. Introduction manner, such that the identities of the research participants should not be inferable from the shared records. records that satisfy the criteria), it cannot learn which records satisfied the criteria. a new protocol to achieve join queries.
 for applying k -anonymity to personal information for controlled information revelation when executing data joins. on the sensitive attribute distribution, such as l -diversity [25] and t -closeness [26]. ods. Furthermore, we give formal proofs of our security and privacy guarantees. Section 8 discusses some lessons learned, and Section 9 concludes the paper. a privacy respective manner. 2. Related work is [32].
 mentally added to the central data repository.
 given in [39], our protocols enable incremental record addition to a central data repository. need not be learned. So, the major concern is not accuracy but rather efficiency. 3. Secure architecture trast, KHS manages the keys that encrypt patient information and queries, as well as the keys to decrypt the query results.
 tion (e.g., medical diagnosis), and DNA records. The work-flow of the framework proceeds as follows: Step 4 (Query Processing): DS executes the requested query and sends the encrypted results to KHS. principle will be applied to support the security of the data integration protocols introduced in this paper.
The framework supports aggregation, or count queries, which are crucial to biomedical data mining tasks. In [8],we proved that DS and KHS can process the count queries of biomedical researchers without learning anything more than bound from violating the terms of data use. 4. Homomorphic cryptography cryptosystem [48]).
 one who can decipher the message from Bob.
 about a plaintext when in possession of the ciphertext and the corresponding public encryption key. isfies the following requirements:
Probabilistic Encryption: Given a message m ; c 1  X  E pk  X  m  X  and c
Additive Homomorphic: Given the encryptions E pk  X  m 1  X  and E of Paillier cryptosystems:
Adding Two Ciphertexts  X  X  h  X  : Given the encryption of m Ciphertext addition yields E pk  X  m 1  X  m 2 mod n  X  to as a consequence of the modular operation. Multiplying a Ciphertext with a Constant  X  k h E pk  X  m 1 5. Secure queries and the equijoin with independently encrypted attributes.

We adopt the following notation for this paper: h h  X f h h hospital h . h h ij represents the value of the j th attribute of the i th individual in h encryption and decryption functions with public key pk and private key pr generated by the KHS. h simple example.
 graphics. The Secure-Equijoin is initiated by a hospital to encrypt the tuples in its database, h receiving encrypted tuples from two hospitals, E pk  X  h h assume the join is performed using attributes j 1 ; ... ; j
E pk h h 2 i 2 match. Using the homomorphic properties of Paillier encryption, DS checks if h
E  X  M i 1 ; i 2  X  on encrypted data via evaluating: reason behind this observation is the fact that if all the attributes match then for each v ;  X  h
As proven below, if any of the attributes fails to match then it is highly unlikely that M Algorithm 1. DS-Equijoin
Require Encrypted datasets E pk  X  h h 1  X  and E pk  X  h h 2  X  ; j 1: for all E pk  X  h h 1 i 2: for all E pk  X  h h 2 i 3: for v  X  1to m do 5: end for 7: end for 8: end for 9: Send all permuted E pk  X  M i 1 ; i 2  X  values to KHS Algorithm 2. KHS-Equijoin
Require E pk  X  M i 1 ; i 2  X   X  X  from DS 1: for all E pk  X  M i 1 ; i 2  X  do 2: if D pr  X  M i 1 ; i 2  X  X  0 then 3:  X  i 1 ; i 2  X  matches 4: end if 5: end for 6: Send all matching  X  i 1 ; i 2  X  pairs to DS 5.1. Correctness of equijoin protocol probability of computing a 0 through homomorphic addition, when there is at least one non-zero value, is very low.
Lemma 1. Given fixed a 1 ; ... ; a m 2f 0 ; ... ; n 1 g with at least one non-zero a r ; ... ; r m 2f 1 ; ... ; n 1 g . Let S m  X 
Proof. Since all operations are modulo a large prime n , 3 inequality:
Using the above inequality, we have: Pr  X  S m  X  0  X  P n 1 x ; Pr  X  a j r j  X  x 6 1 n 1 , Eqs. (1) and (2) concludes our proof. h tion of 0, or a false non-match with very low probability. Fig. 3 summarizes the findings of Theorem 1 .
Theorem 1. Given two encrypted tuples E pk h h 1 i on the other hand, if M i 1 ; i 2  X  0 then h h 1 i
Proof. Due to the definition of M i 1 ; i 2 ,if h h 1 i consider the case where M i 1 ; i 2  X  0 but h h 1 i
P v  X  1  X  a v r v  X  X  0mod n for non-zero uniformly randomly chosen r such an event is less than 1 n 1 . This implies that if M 5.2. Security of the equijoin protocol crypted data. 5.3. Communication and computational cost
Assume Secure-Equijoin is performed using m attributes, and let j h
Protocol 1, for each tuple pair, we perform 2 m 1 homomorphic additions, m modulo inverses and m homomorphic mul-Equijoin protocol is bounded by O  X j h h 1 jj h h 2 j m  X  .
 bounded by O  X j h h 1 jj h h 2 j s  X  . 6. k -Anonymity for Secure-Equijoin sensitive data is not revealed.
 Definition 1. T  X  QI satisfies k -anonymity if and only if each record in it appears at least k times. according to the VGHs, we can derive dataset in Fig. 4 b  X  T  X  Q  X  , which satisfies 2-anonymity. 6.1. k-Anonymity as hash key abases. Moreover, by k -anonymizing the data, we ensure that every tuple in a bucket is linkable to no less than k patients. Thus, after joining encrypted values, DS is unable to link any tuple to less than k patients. pitals then k -anonymize the quasi-identifying values of their datasets.
 We prove these claims next.
 encrypted tuples.
 both buckets. However, if during the join process r joins with tuples from both buckets, DS learns that 23 49 6 r AGE &lt; 90. Obviously, 49 6 r AGE &lt; 50 and r AGE  X  49. The entire QI is disclosed to DS. h the join result.

Proof. Our proof is based on the following observations: (2) Since generalized values used for hashing are disjoint, any encrypted tuple t is mapped to only one bucket B . the anonymity of a tuple. h paper, we assume that the underlying anonymization method produces disjoint generalizations. 6.2. Joins with equivalent populations joined with data stored at DS.
 identifier.
 quasi-identifying values do not change. Thus, the resulting database is k -anonymous. h 6.3. Joins with overlapping populations k -anonymity.
 Algorithm 3. k -Equijoin
A ; ... ; A m 1: DS: Send T  X  Q to hospital h 2: Hospital h : (1)Compute C Get-Candidate  X  T h ; T  X  Q ; V 1 ; ... ; V m (2)Anonymize C based on T  X  Q and send C to DS (3)Compute C  X  T h C  X  (4) k -anonymize C and send it to DS 3: DS: Compute C 0 Equijoin  X  C ; T  X  send C 0 to hospital h Algorithm 4. Get-Candidate
Require T h ; T  X  Q ; V 1 ; ... ; V m 1: C ; 2: D T h 3: for all t 2 T  X  Q do 4: c  X  GetSpec  X  t  X  A 1 ; ... ; A m ; V 1 ; ... ; V m  X  5: for all d 2 D do 6: if j d \ c j X  m then 7: C C [f d g 8: D D f d g 9: end if 10: end for 11: end for 12: return C the quasi-identifying attributes in its database and encrypt the remaining attributes. Then, h will send T submitted. Thus, h generates and sends the generalized C  X  Q to DS.
 in Step 4, hk -anonymizes the remaining tuples with those in C follows: At the step 4 of Algorithm 4 , GetSpec  X  t  X  A 1 turns a set c of specific values (values at the bottom of VGHs: V
A
Claim 4. Given d and c  X  GetSpec  X  t  X  A 1 ; ... ; A m ; V identifying attributes A 1 ; ... ; A m and VGHs V 1 ; ... ; V
Proof. We prove this claim via a contrapositive argument. Assume j d \ c j X  m and d  X  A then 9 d  X  A i 2 d such that d  X  A i cannot be generalized to any value in f t  X  A the other hand, j d \ c j X  m implies that d # c and consequently, d  X  A of GetSpec  X  t  X  , we know that every value in c can be generalized to some value in f t  X  A the case that d  X  A i can be generalized to some value in f t  X  A we assume V 1 ; ... ; V u are disjoint, for any two d  X  A f t  X  A 1 ; ... ; t  X  A m g . This guarantees that for 1 6 i 6 m ; d  X  A analyze this security issue of k-Equijoin based on the following claim.
 identifier and its generalized values are disjoint.
 inductive hypothesis remains true.

Tuples that are joined successfully: Join operation over tuples t 2 T k -anonymous.
 jointness of the generalizations and k -anonymity will not be affected.
 not overlap with existing generalized values of T  X  Q . 7 T  X  Q do not violate k -anonymity of T  X  Q .
 anonymous. h experimentally investigate this hypothesis below. 7. Experiments ment-related attributes. 7.1. Secure-Equijoin operation that involves 10,000 tuple pair comparisons) across four attributes. endeavors. 7.2. k-Equijoin
To evaluate the effect of k -anonymous demographics on secure joins, we compared the number of homomorphic expo-Therefore, the number of exponentiations yields a good estimate of the overall costs of these two methods. of 99 % indicates k-Equijoin performs only  X  1  X  99 = 100  X  X  10 time, one would expect k-Equijoin to run around 100 times faster than Secure-Equijoin . q  X f Age ; MaritalStatus g .
 dataset is built by randomly partitioning the preprocessed Census dataset. determines the ratio of the join size (i.e., T h ffl T ) to the size of the input dataset, T
T will be in T h ffl T . Default values of all these parameters are provided in Table 1 . 7.2.1. k-Anonymity algorithms In our experiments, we compare three anonymization methods: (1) an algorithm of our own design, which we call tropy and Mondrian.
 Consequently, these methods are more flexible and their output is of higher-granularity in comparison. tribution. In this respect, MaxEntropy is limited to user-defined generalization hierarchies.
Finally we would like emphasize that these three anonymization methods produce disjoint generalizations. Most top-partitioned randomly across hospitals, this has never occurred and C was always empty. 7.2.2. Anonymity requirement (k) per bucket that k-Equijoin must compare.
 can be deeper than the user-defined hierarchy). 7.2.3. Quasi-identifier size ( j q j ) savings in cryptographic operations.
 better than Mondrian. However, as the QI grows to include a discrete attribute the savings decline quite sharply. 7.2.4. Dataset size ( j h j ) after preprocessing. Thus, j h j X  n = 10 implies j h j X  142 ; 521 = 10  X  14 ; 252. this algorithm yields higher-granularity buckets, even for considerably small datasets. 7.2.5. Number of datasets ( # h) fore # h has no significant effect on the savings. 7.2.6. Join selectivity (s) depicted in Fig. 10 .
 the same for k-Equijoin .

Given T h and s , we build the join set by randomly selecting % s of the tuples of T bution of the joined tuples will be similar to the distribution of T change with varying s . 8. Discussion based improvements.
 than a day. We leave the implementation of our algorithms using crypto accelerators as a future work. cost. 9. Conclusions experiments involving real-world medical data sets.

References
