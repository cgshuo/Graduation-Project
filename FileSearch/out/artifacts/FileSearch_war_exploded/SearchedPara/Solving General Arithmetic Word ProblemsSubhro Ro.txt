 In recent years there is growing interest in understand-ing natural language text for the purpose of answering science related questions from text as well as quanti-tative problems of various kinds. In this context, un-derstanding and solving arithmetic word problems is of specific interest. Word problems arise naturally when reading the financial section of a newspaper, following election coverage, or when studying elementary school arithmetic word problems. These problems pose an in-teresting challenge to the NLP community, due to its concise and relatively straightforward text, and seem-ingly simple semantics. Arithmetic word problems are usually directed towards elementary school students, and can be solved by combining the numbers men-tioned in text with basic operations (addition, subtrac-tion, multiplication, division). They are simpler than algebra word problems which require students to iden-tify variables, and form equations with these variables to solve the problem.

Initial methods to address arithmetic word problems have mostly focussed on subsets of problems, restrict-ing the number or the type of operations used (Roy et al., 2015; Hosseini et al., 2014) but could not deal with multi-step arithmetic problems involving all four basic operations. The template based method of (Kushman et al., 2014), on the other hand, can deal with all types of problems, but implicitly assumes that the solution is generated from a set of predefined equation templates.
In this paper, we present a novel approach which can solve a general class of arithmetic problems with-out predefined equation templates. In particular, it can handle multiple step arithmetic problems as shown in Example 1 .

The solution involves understanding that the number of shelves needs to be summed up, and that the total number of shelves needs to be multiplied by the num-ber of books each shelf can hold. In addition, one has to understand that the number  X 2 X  is not a direct part of the solution of the problem.

While a solution to these problems eventually re-quires composing multi-step numeric expressions from text, we believe that directly predicting this complex expression from text is not feasible.

At the heart of our technical approach is the novel notion of an Expression Tree . We show that the arith-metic expressions we are interested in can always be represented using an Expression Tree that has some unique decomposition properties. This allows us to de-compose the problem of mapping the text to the arith-metic expression to a collection of simple prediction problems, each determining the lowest common ances-tor operation between a pair of quantities mentioned in the problem. We then formulate the decision problem of composing the final expression tree as a joint infer-ence problem, via an objective function that consists of all these decomposed prediction problems, along with legitimacy and background knowledge constraints.
Learning to generate the simpler decomposed ex-pressions allows us to support generalization across problems types. In particular, our system could solve Example 1 even though it has never seen a problem that requires both addition and multiplication operations.
We also introduce a second concept, that of quantity schema , that allows us to focus on the information rel-evant to each quantity mentioned in the text. We show that features extracted from quantity schemas help rea-soning effectively about the solution. Moreover, quan-tity schemas help identify unnecessary text snippets in the problem text. For instance, in Example 2 , the in-formation that  X  X om washed cars over the weekend X  is irrelevant; he could have performed any activity to earn money. In order to solve the problem, we only need to know that he had $ 76 last week, and now he has $ 86 .
We combine the classifiers X  decisions using a con-strained inference framework that allows for incorpo-rating world knowledge as constraints. For example, we deliberatively incorporate the information that, if the problems asks about an  X  X mount X , the answer must be positive, and if the question starts with  X  X ow many X , the answer will most likely be an integer.

Our system is evaluated on two existing datasets of arithmetic word problems, achieving state of the art performance on both. We also create a new dataset of multistep arithmetic problems, and show that our sys-tem achieves competitive performance in this challeng-ing evaluation setting.

The next section describes the related work in the area of automated math word problem solving. We then present the theory of expression trees and our decom-position strategy that is based on it. Sec. 4 presents the overall computational approach, including the way we use quantity schemas to learn the mapping from text to expression tree components. Finally, we discuss our experimental study and conclude. Previous work in automated arithmetic problem solvers has focussed on a restricted subset of problems. The system described in (Hosseini et al., 2014) handles only addition and subtraction problems, and requires additional annotated data for verb categories. In con-trast, our system does not require any additional an-notations and can handle a more general category of problems. The approach in (Roy et al., 2015) sup-ports all four basic operations, and uses a pipeline of classifiers to predict different properties of the prob-lem. However, it makes assumptions on the number of quantities mentioned in the problem text, as well as the number of arithmetic steps required to solve the prob-lem. In contrast, our system does not have any such restrictions, effectively handling problems mentioning multiple quantities and requiring multiple steps. Kush-man X  X  approach to automatically solving algebra word problems (Kushman et al., 2014) might be the most re-lated to ours. It tries to map numbers from the prob-lem text to predefined equation templates. However, they implicitly assume that similar equation forms have been seen in the training data. In contrast, our system can perform competitively, even when it has never seen similar expressions in training.

There is a recent interest in understanding text for the purpose of solving scientific and quantitative prob-lems of various kinds. Our approach is related to work in understanding and solving elementary school stan-dardized tests (Clark, 2015). The system described in (Berant et al., 2014) attempts to automatically answer biology questions, by extracting the structure of bio-logical processes from text. There has also been efforts to solve geometry questions by jointly understanding diagrams and associated text (Seo et al., 2014). A re-cent work (Sadeghi et al., 2015) tries to answer science questions by visually verifying relations from images.
Our constrained inference module falls under the general framework of Constrained Conditional Mod-els (CCM) (Chang et al., 2012). In particular, we use the L + I scheme of CCMs, which predicts structured output by independently learning several simple com-ponents, combining them at inference time. This has been successfully used to incorporate world knowledge at inference time, as well as getting around the need for large amounts of jointly annotated data for struc-tured prediction (Roth and Yih, 2005; Punyakanok et al., 2005; Punyakanok et al., 2008; Clarke and Lapata, 2006; Barzilay and Lapata, 2006; Roy et al., 2015). We address the problem of automatically solving arith-metic word problems. The input to our system is the problem text P , which mentions n quantities q read-once arithmetic expression E that, when evalu-ated, provides the problem X  X  solution. We define a read-once arithmetic expression as one that makes use of each quantity at most once. We say that E is a valid expression, if it is such a Read-Once arithmetic expres-sion, and we only consider in this work problems that can be solved using valid expressions (it X  X  possible that they can be solved also with invalid expressions).
An expression tree T for a valid expression E is a binary tree whose leaves represent quantities, and each internal node represents one of the four basic opera-tions. For a non-leaf node n , we represent the operation associated with it as ( n ) , and its left and right child as lc ( n ) and rc ( n ) respectively. The numeric value of the quantity associated with a leaf node n is denoted as Q ( n ) . Each node n also has a value associated with it, represented as V AL ( n ) , which can be computed in a recursive way as follows:
V AL ( n ) = ( For any expression tree T for expression E with root node n root , the value of V AL ( n root ) is exactly equal to the numeric value of the expression E . Therefore, this gives a natural representation of numeric expres-sions, providing a natural parenthesization of the nu-meric expression. Fig 1 shows an example of an arith-metic problem with solution expression and an expres-sion tree for the solution expression.
 Figure 1: An arithmetic word problem, solution expression Definition An expression tree T for a valid expression E is called monotonic if it satisfies the following con-ditions: 1. If an addition node is connected to a subtraction 2. If a multiplication node is connected to a division
Fig 2 shows two different expression trees for the same expression. Fig 2b is monotonic whereas fig 2a is not. Figure 2: Two different expression trees for the numeric ex-
Our decomposition relies on the idea of monotonic expression trees. We try to predict for each pair of quantities q i , q j , the operation at the lowest common ancestor (LCA) node of the monotonic expression tree for the solution expression. We also predict for each quantity, whether it is relevant to the solution. Finally, an inference module combines all these predictions.
In the rest of the section, we show that for any pair of quantities q i , q j in the solution expression, any mono-tonic tree for the solution expression has the same LCA operation. Therefore, predicting the LCA operation be-comes a multiclass classification problem.

The reason that we consider the monotonic represen-tation of the expression tree is that different trees could otherwise give different LCA operation for a given pair of quantities. For example, in Fig 2, the LCA opera-tion for quantities 5 and 8 can be + or  X  , depending on which tree is considered.
 Definition We define an addition-subtraction chain of an expression tree to be the maximal connected set of nodes labeled with addition or subtraction.
The nodes of an addition-subtraction (AS) chain C represent a set of terms being added or subtracted. These terms are sub-expressions created by subtrees rooted at neighboring nodes of the chain. We call these terms the chain terms of C , and the whole expression, after node operations have been applied to the chain terms, the chain expression of C . For example, in fig 2, the shaded nodes form an addition-subtraction chain. The chain expression is (3  X  5)+7  X  8  X  9 , and the chain terms are 3  X  5 , 7 , 8 and 9 . We define a multiplication-division (MD) chain in a similar way.
 Theorem 3.1. Every valid expression can be repre-sented by a monotonic expression tree.
 Proof. The proof is procedural, that is, we provide a method to convert any expression tree to a monotonic expression tree for the same expression. Consider a non-monotonic expression tree E , and without loss of generality, assume that the first condition for mono-tonicity is not valid. Therefore, there exists an addi-tion node n i and a subtraction node n j , and n i is the parent of n j . Consider an addition-subtraction chain C which includes n i , n j . We now replace the nodes of C and its subtrees in the following way. We add a sin-gle subtraction node n  X  . The left subtree of n  X  has all the addition chain terms connected by addition nodes, and the right subtree of n  X  has all the subtraction chain terms connected by addition nodes. Both subtrees of n  X  only require addition nodes, hence monotonicity condition is satisfied. We can construct the monotonic tree in Fig 2b from the non-monotonic tree of Fig 2a us-ing this procedure. The addition chain terms are 3  X  5 and 7 , and the subtraction chain terms are 8 and 9 . As as was described above, we introduce the root subtrac-tion node in Fig 2b and attach the addition chain terms to the left and the subtraction chain terms to the right. The same line of reasoning can be used to handle the second condition with multiplication and division re-placing addition and subtraction, respectively. Theorem 3.2. Consider two valid expression trees T 1 and T 2 for the same expression E . Let C 1 , C 2 be the chain containing the root nodes of T 1 and T 2 re-spectively. The chain type (addition-subtraction or multiplication-division) as well as the the set of chain terms of C 1 and C 2 are identical.
 Proof. We first prove that the chains containing the roots are both AS or both MD, and then show that the chain terms are also identical.

We prove by contradiction that the chain type is same. Let C 1  X  X  type be  X  X ddition-subtraction X  and C 2  X  X  type be  X  X ultiplication-division X  (without loss of gen-erality). Since both C 1 and C 2 generate the same ex-pression E , we have that E can be represented as sum (or difference) of two expressions as well as product(or division) of two expressions. Transforming a sum (or difference) of expressions to a product (or division) requires taking common terms from the expressions, which imply that the sum (or difference) had dupli-cate quantities. The opposite transformation adds same term to various expressions leading to multiple uses of the same quantity. Therefore, this will force at least one of C 1 and C 2 to use the same quantity more than once, violating validity.

We now need to show that individual chain terms are also identical. Without loss of generality, let us assume that both C 1 and C 2 are  X  X ddition-subtraction X  chains. Suppose the chain terms of C 1 and C 2 are not identi-cal. The chain expression for both the chains will be the same (since they are root chains, the chain expressions has to be the same as E ). Let the chain expression for C terms and t 0 i are the subtraction chain terms. Similarly, let the chain expression for C 2 be know that of t i  X  X  and t 0 i  X  X  is not the same as the set of s i and s 0 However it should be possible to transform one form to the other using mathematical manipulations. This transformation will involve taking common terms, or multiplying two terms, or both. Following previous explanation, this will force one of the expressions to have duplicate quantities, violating validity. Hence, the chain terms of C 1 and C 2 are identical.

Consider an expression tree T for a valid expres-sion E . For a distinct pair of quantities q i , q ticipating in expression E , we denote by n i , n j the leaves of the expression tree T representing q i , q j , re-spectively. Let n LCA ( q i , q j ; T ) to be the lowest com-mon ancestor node of n i and n j . We also define subtree of n LCA ( q i , q j ; T ) and n j appears in the right subtree of n LCA ( q i , q j ; T ) and set order ( q i , q false otherwise. Finally we define LCA ( q i , q j ; T ) for a pair of quantities q i , q j as follows :  X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X  Definition Given two expression trees T 1 and T 2 for the same expression E , T 1 is LCA-equivalent to T 2 if for every pair quantities q i , q j in the expression E , we Theorem 3.3. All monotonic expression trees for an expression are LCA-equivalent to each other.
 Proof. We prove by induction on the number of quanti-ties used in an expression. For all expressions E with 2 quantities, there exists only one monotonic expression tree, and hence, the statement is trivially true. This sat-isfies our base case.

For the inductive case, we assume that for all expres-sions with k &lt; n quantities, the theorem is true. Now, we need to prove that any expression with n nodes will also satisfy the property.

Consider a valid (as in all cases) expression E , with monotonic expression trees T 1 and T 2 . From theorem 3.2, we know that the chains containing the roots of T 1 and T 2 have identical type and terms. Given two quantities q i , q j of E , the lowest common ancestor of both T 1 and T 2 will either both belong to the chain containing the root, or both belong to one of the chain terms. If the LCA node is part of the chain for both T 1 and T 2 , monotonic property ensures that the LCA operation will be identical. If the LCA node is part of a chain term (which is an expression tree of size less than n ), the property is satisfied by induction hypothesis.
The theory just presented suggests that it is possible to uniquely decompose the overall problem to simpler steps and this will be exploited in the next section. Given the uniqueness properties proved in Sec. 3, it is sufficient to identify the operation between any two rel-evant quantities in the text, in order to determine the unique valid expression. In fact, identifying the op-eration between any pair of quantities provides much needed redundancy given the uncertainty in identifying the operation from text, and we exploit it in our final joint inference.
Consequently, our overall method proceeds as fol-lows: given the problem text P , we detect quantities q , q 2 , . . . , q n . We then use two classifiers, one for rel-evance and other to predict the LCA operations for a monotonic expression tree of the solution. Our training makes use of the notion of quantity schemas, which we describe in Section 4.2. The distributional output of these classifiers is then used in a joint inference proce-dure that determines the final expression tree.
Our training data consists of problem text paired with a monotonic expression tree for the solution ex-pression. Both the relevance and LCA operation clas-sifiers are trained on gold annotations. 4.1 Global Inference for Expression Trees In this subsection, we define the scoring functions cor-responding to the decomposed problems, and show how we combine these scores to perform global infer-ence. For a problem P with quantities q 1 , q 2 , . . . , q we define the following scoring functions: 1. P AIR ( q i , q j , op ) : Scores the likelihood of 2. I RR ( q ) : Scores the likelihood of quantity q being
For an expression E , let I ( E ) be the set of all quanti-ties in P which are not used in expression E . Let T be a monotonic expression tree for E . We define Score( E ) of an expression E in terms of the above scoring func-tions and a scaling parameter w I RR as follows: Score( E ) = w I RR
Our final expression tree is an outcome of a con-strained optimization process, following (Roth and Yih, 2004; Chang et al., 2012). Our objective function makes use of the scores returned by I RR (  X  ) and P AIR (  X  ) to determine the expression tree and is constrained by legitimacy and background knowledge constraints, de-tailed below. 1. Positive Answer : Most arithmetic problems ask-2. Integral Answer : Problems with questions such
Let C be the set of valid expressions that can be formed using the quantities in a problem P , and which satisfy the above constraints. The inference algorithm now becomes the following:
The space of possible expressions is large, and we employ a beam search strategy to find the highest scoring constraint satisfying expression (Chang et al., 2012). We construct an expression tree using a bottom up approach, first enumerating all possible sets of irrel-evant quantities, and next over all possible expressions, keeping the top k at each step. We give details below. 1. Enumerating Irrelevant Quantities : We gener-2. Enumerating Expressions : For generating a next
Once we have a top k list of candidate expression trees, we choose the highest scoring tree which satisfies the constraints. However, there might not be any tree in the beam which satisfies the constraints, in which case, we choose the top candidate in the beam. We use k = 200 in our experiments.

In order to choose the value for the w I RR , we search choose the parameter setting which gives the highest accuracy on the training data. 4.2 Quantity Schema In order to generalize across problem types as well as over simple manipulations of the text, it is neces-sary to train our system only with relevant information from the problem text. E.g., for the problem in exam-ple 2 , we do not want to take decisions based on how Tom earned money. Therefore, there is a need to ex-tract the relevant information from the problem text. To this end, we introduce the concept of a quantity schema which we extract for each quantity in the prob-lem X  X  text. Along with the question asked, the quantity schemas provides all the information needed to solve most arithmetic problems.

A quantity schema for a quantity q in problem P consists of the following components. 1. Associated Verb For each quantity q , we detect 2. Subject of Associated Verb We detect the noun 3. Unit We use a shallow parser to detect the phrase 4. Related Noun Phrases We consider all noun 5. Rate We determine whether quantity q refers to a
In addition to extracting the quantity schemas for each quantity, we extract the surface form text which poses the question. For example, in the question sen-tence,  X  X ow much will John have to pay if he wants to buy 7 oranges? X , our extractor outputs  X  X ow much will John have to pay X  as the question. 4.3 Relevance Classifier We train a binary SVM classifier to determine, given problem text P and a quantity q in it, whether q is needed in the numeric expression generating the solu-tion. We train on gold annotations and use the score of the classifier as the scoring function I RR (  X  ) . 4.3.1 Features The features are extracted from the quantity schemas and can be broadly categorized into three groups: 1. Unit features : Most questions specifically men-2. Related NP features : Often units are not enough 3. Miscellaneous Features : When a problem men-
We include pairwise conjunction of the above fea-tures. 4.4 LCA Operation Classifier In order to predict LCA operations, we train a multi-class SVM classifier. Given problem text P and a pair of quantities p i and p j , the classifier predicts one of the six labels described in Eq. 2. We consider the confi-dence scores for each label supplied by the classifier as the scoring function P AIR (  X  ) . 4.4.1 Features We use the following categories of features: 1. Individual Quantity features : Dependent verbs 2. Quantity Pair features : For a pair ( q i , q j ) we add 3. Question Features : Finally, we add a few fea-
We include pairwise conjunction of the above fea-tures. For both classifiers, we use the Illinois-SL pack-In this section, we evaluate the proposed method on publicly available datasets of arithmetic word prob-lems. We evaluate separately the relevance and LCA operation classifiers, and show the contribution of var-ious features. Lastly, we evaluate the performance of the full system, and quantify the gains achieved by the constraints. 5.1 Datasets We evaluate our system on three datasets, each of which comprise a different category of arithmetic word problems. 1. AI2 Dataset : This is a collection of 395 addition 2. IL Dataset : This is a collection of arithmetic 3. Commoncore Dataset : In order to test our sys-5.2 Relevance Classifier Table 2 evaluates the performance of the relevance clas-sifier on the AI2 and IL datasets. We report two accu-racy values: Relax -fraction of quantities which the classifier got correct, and Strict -fraction of math prob-lems, for which all quantities were correctly classified. We report accuracy using all features and then remov-ing each feature group, one at a time. Table 2: Performance of Relevance classifier on the datasets
We see that features related to units of quantities play the most significant role in determining relevance of quantities. Also, the related NP features are not helpful for the AI2 dataset. 5.3 LCA Operation Classifier Table 1 evaluates the performance of the LCA Oper-ation classifier on the AI2, IL and CC datasets. As before, we report two accuracies -Relax -fraction of quantity pairs for which the classifier correctly pre-dicted the LCA operation, and Strict -fraction of math problems, for which all quantity pairs were correctly classified. We report accuracy using all features and then removing each feature group, one at a time.
The strict and relaxed accuracies for IL dataset are identical, since each problem in IL dataset only re-quires one operation. The features related to individual quantities are most significant; in particular, the accu-racy goes to 0 . 0 in the CC dataset, without using indi-vidual quantity features. The question features are not helpful for classification in the CC dataset. This can be attributed to the fact that all problems in CC dataset re-quire multiple operations, and questions in multi-step problems usually do not contain information for each of the required operations. 5.4 Global Inference Module Table 3 shows the performance of our system in cor-rectly solving arithmetic word problems. We show the impact of various contraints, and also compare against previously best known results on the AI2 and IL datasets. We also show results using each of the two constraints separately, and using no constraints at all. Table 3: Accuracy in correctly solving arithmetic problems.
The previously known best result in the AI2 dataset is reported in (Hosseini et al., 2014). Since we follow the exact same evaluation settings, our results are di-rectly comparable. We achieve state of the art results, without having access to any additional annotated data, unlike (Hosseini et al., 2014), who use labeled data for verb categorization. For the IL dataset, we acquired the system of (Roy et al., 2015) from the authors, and ran it with the same fold information. We outperform their system by an absolute gain of over 20% . We believe that the improvement was mainly due to the depen-dence of the system of (Roy et al., 2015) on lexical and neighborhood of quantity features. In contrast, features from quantity schemas help us generalize across prob-lem types. Finally, we also compare against the tem-plate based system of (Kushman et al., 2014). (Hos-seini et al., 2014) mentions the result of running the system of (Kushman et al., 2014) on AI2 dataset, and we report their result here. For IL and CC datasets, we used the system released by (Kushman et al., 2014).
The integrality constraint is particularly helpful when division is involved, since it can lead to fractional answers. It does not help in case of the AI2 dataset, which involves only addition and subtraction problems. The role of the constraints becomes more significant in case of multi-step problems and, in particular, they con-tribute an absolute improvement of over 15% over the system without constraints on the CC dataset. The tem-plate based system of (Kushman et al., 2014) performs on par with our system on the IL dataset. We believe that it is due to the small number of equation templates in the IL dataset. It performs poorly on the CC dataset, since we evaluate on unseen problem types, which do not ensure that equation templates in the test data will be seen in the training data. 5.5 Discussion The leading source of errors for the classifiers are er-roneous quantity schema extraction and lack of under-standing of unknown or rare verbs. For the relevance classifier on the AI2 dataset, 25% of the errors were due to mistakes in extracting the quantity schemas and 20% could be attributed to rare verbs. For the LCA operation classifier on the same dataset, 16% of the er-rors were due to unknown verbs and 15% were due to mistakes in extracting the schemas. The erroneous ex-traction of accurate quantity schemas is very significant for the IL dataset, contributing 57% of the errors for the relevance classifier and 39% of the errors for the LCA operation classifier. For the operation classifier on the CC dataset, 8% of the errors were due to verbs and 16% were due to faulty quantity schema extraction. Quan-tity Schema extraction is challenging due to parsing is-sues as well as some non-standard rate patterns, and it will be one of the future work targets. For example, in the sentence,  X  X ow many 4-dollar toys can he buy? X , we fail to extract the rate component of the quantity 4. This paper presents a novel method for understanding and solving a general class of arithmetic word prob-lems. Our approach can solve all problems whose so-lution can be expressed by a read-once arithmetic ex-pression, where each quantity from the problem text appears at most once in the expression. We develop a novel theoretical framework, centered around the no-tion of monotone expression trees, and showed how this representation can be used to get a unique decom-position of the problem. This theory naturally leads to a computational solution that we have shown to uniquely determine the solution -determine the arithmetic oper-ation between any two quantities identified in the text. This theory underlies our algorithmic solution -we de-velop classifiers and a constrained inference approach that exploits redundancy in the information, and show that this yields strong performance on several bench-mark collections. In particular, our approach achieves state of the art performance on two publicly available arithmetic problem datasets and can support natural generalizations. Specifically, our approach performs competitively on multistep problems, even when it has never observed the particular problem type before.
Although we develop and use the notion of expres-sion trees in the context of numerical expressions, the concept is more general. In particular, if we allow leaves of expression trees to represent variables, we can express algebraic expressions and equations in this framework. Hence a similar approach can be targeted towards algebra word problems, a direction we wish to investigate in the future.

The datasets used in the paper are available for This research was sponsored by DARPA (under agree-ment number FA8750-13-2-0008), and a grant from AI2. Any opinions, findings, conclusions or recom-mendations are those of the authors and do not nec-essarily reflect the view of the agencies.
 R. Barzilay and M. Lapata. 2006. Aggregation via Set Partitioning for Natural Language Generation. In Human Language Technologies -North American
Chapter of the Association for Computational Lin-guistics , June.
 J. Berant, V. Srikumar, P. Chen, A. V. Linden, B. Hard-ing, B. Huang, P. Clark, and C. D. Manning. 2014.
Modeling biological processes for reading compre-hension. In Proceedings of EMNLP .
 M. Chang, L. Ratinov, and D. Roth. 2012. Structured learning with constrained conditional models. Ma-chine Learning , 88(3):399 X 431, 6.
 P. Clark. 2015. Elementary School Science and Math Tests as a Driver for AI: Take the Aristo Challenge! In Proceedings of IAAI .
 J. Clarke and M. Lapata. 2006. Constraint-based sentence compression: An integer programming ap-proach. In Proceedings of the Annual Meeting of the
Association for Computational Linguistics (ACL) , pages 144 X 151, Sydney, Australia, July. ACL.
 Y. Goldberg and M. Elhadad. 2010. An efficient algo-rithm for easy-first non-directional dependency pars-ing. In Human Language Technologies: The 2010
Annual Conference of the North American Chap-ter of the Association for Computational Linguistics , pages 742 X 750, Los Angeles, California, June.
 M. J. Hosseini, H. Hajishirzi, O. Etzioni, and N. Kush-man. 2014. Learning to solve arithmetic word prob-lems with verb categorization. In Proceedings of the 2014 Conference on Empirical Methods in Natural
Language Processing, EMNLP 2014, October 25-29, 2014, Doha, Qatar , pages 523 X 533.
 N. Kushman, L. Zettlemoyer, R. Barzilay, and Y. Artzi. 2014. Learning to automatically solve algebra word problems. In ACL , pages 271 X 281.
 V. Punyakanok, D. Roth, and W. Yih. 2005. The ne-cessity of syntactic parsing for semantic role label-ing. In Proc. of the International Joint Conference on Artificial Intelligence (IJCAI) , pages 1117 X 1123. V. Punyakanok, D. Roth, and W. Yih. 2008. The im-portance of syntactic parsing and inference in se-mantic role labeling. Computational Linguistics , 34(2).
 D. Roth and W. Yih. 2004. A linear programming formulation for global inference in natural language tasks. In Hwee Tou Ng and Ellen Riloff, editors, Proc. of the Conference on Computational Natural
Language Learning (CoNLL) , pages 1 X 8. Associa-tion for Computational Linguistics.
 D. Roth and W. Yih. 2005. Integer linear programming inference for conditional random fields. In Proc. of the International Conference on Machine Learning (ICML) , pages 737 X 744.
 S. Roy, T. Vieira, and D. Roth. 2015. Reasoning about quantities in natural language. Transactions of the Association for Computational Linguistics , 3. F. Sadeghi, S. K. Divvala, and A. Farhadi. 2015.
Viske: Visual knowledge extraction and question an-swering by visual verification of relation phrases. In
The IEEE Conference on Computer Vision and Pat-tern Recognition (CVPR) , June.
 M. J. Seo, H. Hajishirzi, A. Farhadi, and O. Etzioni. 2014. Diagram understanding in geometry ques-tions. In Proceedings of the Twenty-Eighth AAAI
Conference on Artificial Intelligence, July 27 -31, 2014, Qu  X  ebec City, Qu  X  ebec, Canada. , pages 2831 X  2838.
