 Schema mapping plays a fundamental role in modern information systems. Mapping composition is an operator that combines a chain of successive schema mappi ngs into a single schema map-ping. By pre-computing the composed schema mapping , the sys-tem can achieve significant performance benefits. However, when a change occurs on any mapping in the chain, the composed schema mapping has to be mainta ined correspondingly. In this paper we consider a restricted form of the problem in the XML setting and propose an incrementa l maintenance approach. Spe-cifically, given a chain of successive mappings, we transform intermediately them into trees th at consist of atomic rules and then divide the composition into sub-compositions of the atomic rules. The dividing composition a pproach provides a fine-grained perspective of the composition relationships between the map-pings. We depict such information through an auxiliary data struc-ture called composition relationship graph (CRG). When changes occur on any mapping in the chain, the corresponding mainte-nance algorithms are developed based on the dividing approach and the CRG, which compute the changes on the composed map-ping and then repair it into the new version, such that the compu-tation involves only the atomic rules that are relevant with the maintenance. We evaluate our maintenance approach and report the first experiments results, whic h show that it is efficient. H.2.5 [ Database Management ]: Heterogeneous Databases .
 Algorithms, Design, Experimentation Schema mapping, Mapping Co mposition, XML, XQuery
Schema mapping plays a fundamental role in data sharing ar-chitectures such as data integra tion system, peer data management system, and data exchange system. Semantically, a schema map-ping is a specification that descri be data relationships between sources and target schemas, according to which the system can then reformulate queries over the target schema into queries over the source schema or transform data from the source into the tar-get. The extensive use of schema mappings has motivated the development of semi-automatica lly technologies for the creation and maintenance of these mappings in recent literatures [10, 12, 17, 19]. More generally, Bernstein [1, 2] introduces a framework called model management to ma nage the mappings and other related meta-data. However, desp ite this progress, as Bernstein pointed out in [1, 2], there are many challenges related with schema mappings that are remained to be explored. 
Mapping composition [1, 9, 5, 2] is an operator that combines a chain of successive schema mappings , i.e., the target of a schema mapping is also the source of a nother schema mapping, into a single schema mapping (, which we call the composed schema mapping of the chain of mappings). In a real world application, data often flows through a seri es of mapping steps. By pre-computing the compositions, the system can achieve significant performance benefits, since many in termediate computations have been done before the run-time. Ho wever, when a change occurs on any mapping in the chain, th e composed schema mapping has to be maintained correspondingly. Example 1.1 Consider an XML mapping M 1, 2 that transforms book information from a source (schema) S 1 to a target (schema) S . Further, S 2 serves also as the source of another mapping M 2, 3 that relates it with a new target schema S 3 . By applying the composition operator, M 1, 2 and M 2, 3 are combined into a single mapping M 1, 3 . Consequently, a system can now migrate data directly from the source S 1 to the target S 3 or reformulate queries over one schema into equivalent queries over the other schema. Suppose M 1, 2 is an XQuery query expressed as follows. It transforms the works with publication year after 2000. Now, for some reason, M 1, 2 is modified so that the works to be transformed *Supported by the National Natural Science Foundation of China under Grant No. 60703119, Jiangsu Provincial Natural Science Foundation of China under Grant No. BK2007584. having a rating greater than 3 also. A new mapping M' 1, 2 ated by replacing line 2 of M 1, 2 with the following expression. As a result, the original composed mapping M 1, 3 dated correspondingly. A straightforward solution is to re-compute completely the new com position, i.e., the composition of M' 1, 2 and M 2, 3 . We refer to this approach as a complete mainte-nance approach. Yet we notice that in most cases, especially when the schemas involved are complex, the mapping changes are often relatively local, and the updates propagating to the composed mapping might be small also. Hence, a partial maintenance strat-egy, if any, should be more efficient.
 In this paper we propose an incremental maintenance approach. Though many research efforts have concentrated on schema map-pings, to the best of our knowledge, our work is the first to study the problem of the maintenance of the composed mappings. We believe an efficient solution to this problem would be useful to the work on mapping management. First, a direct application of our work could improve the scalability of large-scale data sharing architectures like the peer data management systems, where pre-computing the compositi ons is one of the main optimization tech-niques for efficient query answering [9, 15]. In such systems, any mapping change can affect a large number of pre-computed com-posed mappings and then make expensive update workloads. Even worse, in dynamic environm ents like the Web, data sources often change their data, their sche mas, and their semantics, any of which can result in the modifications on the mappings [17, 19], and then lead to a requirement for frequent maintenance of the composed mappings. Problem Description. Let Q ( S ) denote a query over the schema S . A schema mapping M 1, 2 between a source schema S 1 and a target schema S 2 is an assertion Q ( S 1 )  X  Q ( S 2 ) [8], which defines a subset of D 1  X  D 2 where D 1 and D 2 are the sets of possible instances of the schemas S 1 and S 2 respectively. Given mappings M 1, 2 and S 2 and M 2, 3 between S 2 and S 3 , the composition M defined to be the set of all pairs of instances d such that there exists a d 2  X  D 2 such that &lt; d 1 , d &lt; d 2 , d 3 &gt; satisfies M 2, 3 [5, 2]. 
Given a chain of successive mappings M 1, 2 , ..., M i , j M n -1, n . The composed mapping M 1, n is computed as follows. When changes occur on any mapping in the chain, we study the problem of maintaining the composed mapping M 1, n intermediate composed mapping (e.g., M 1, i ) is provided, the main-tenance has to traversal all the mappings in the chain since the composition is determined by each of them. The complete main-tenance approach uses the above formula (1) to re-compute the new composition M' 1, n , even if the change itself is small. In con-trast, our incremental approach directly uses the mapping changes to compute M' 1, n . The main idea behind our approach is to repair M efficiency could be expected. Though attractive in principle, such an idea poses several challenges: (i) How to model  X  M i , j words, we should determine a gr anularity to compute the compo-sition, and then delimitate the  X  M i , j according to this granularity. (ii) How to compute  X  M 1, n efficiently. Though  X  M simple, the other mappings in form ula (2) can be very complex. (iii) How to repair M 1, n . After obtaining  X  M 1, n mine the correct part of M 1, n to replace it with  X  M Our Solution. This paper studies the pr oblem in the XML setting. Specifically, we consider restricted mappings of the form and the right-hand side can only apply projections on the target schema. Hence we can directly denote the mapping as the query over S 1 such that its answer conforms to S 2 (or a fragment of S An example has been shown in Example 1.1, where we use (a fragment of) XQuery to denote XML queries over the source schema. Though some high-level mapping languages have been proposed in the literature for studying semi-automatic mapping technologies [10, 12, 17], they can be applied to our approach, since our maintenance approach, as can be seen a bit later, is based on an intermediate model called mapping tree. Due to the challenges described above, we f ound that, even with the above restriction, it is not so easy to maintain the composed mapping efficiently. We believe that our work presented in this paper would be useful to study the general maintenance problem. 
Given a chain of successive XML mappings M 1, 2 , ..., M We transform intermediately every of them into a mapping tree that consists of atomic rules, and then divide the composition of the chain of mappings into sub-co mpositions of the atomic rules. The resulting composed mapping M 1, n is a tree also. The dividing approach makes a fine-grained composition relationship between the mappings. We capture such the relationship through a compo-sition route that relates together the atomic rules involved in a sub-composition, and in computing M 1, n , record such route in-formation through an auxiliary structure called composition route graph (CRG). Intuitively, the CRG states which atomic rules of each M i , j contribute to the corresponding rule in M able composition approach and th e CRG provide the premise for maintaining the composed mapping incrementally. Specifically, when changes occur on M i , j , we delimitate  X  M atomic rules (possibly with the assistance of some advanced map-ping editors) and reduce them into the insertion, deletion, and update of the rules of M i , j . Corresponding to each the basic change type, the maintenance algorithm is developed that com-putes  X  M 1, n , as shown in formula (2), by composing the change  X  M i , j with the other mapping trees in the chain. This process takes advantage of the information provide by the CRG obtained above to identify those atomic rules related with the maintenance, such that the other irrelevant rules ar e threw out and do not participate in the computation. Finally, we uses again the CRG to determine the part of M 1, n that needs to be repaired and then replace it with  X  M 1, n . Of course, the CRG is updated also at the same time. Paper Organization. The rest of the paper is organized as fol-lows. Section 2 first illustrates an overview of our approach using a running example. Next, after s howing the detailed intermediate mapping model and the dividing co mposition approach in Section 3 and 4, respectively, we present the maintenance algorithms in Section 5, and evaluate our appr oach and report the first experi-ment results in Section 6. Fina lly, Section 7 discusses related work and Section 8 concludes and introduces some ideas for fu-ture work. 
Using the scenario in Example 1.1, in this section we present an overview of our approach. First, we transform the XML mapping M 1, 2 into an intermediate tree as shown in Figure 1. In the map-ping tree, each node corresponds to an atomic rule and each edge states a nesting relationship or a conditional constraint. Due to the clear semantics, we denote the ru le using a simple XQuery query (see Section 3). When applied to data, the rule computes only single items, e.g., the empty XML elements that contain neither sub-elements nor text values. For example, rules r Figure 1 will return empty elements book and title , respectively, while the edge between r 2 and r 3 states a nesting relationship be-tween the returned elements. In the same way, the text values returned by rule r 4 will be nested within the corresponding title mapping, as specified by the where clause in line 2 of M our figures we use gray rectangles to denote such constraint rules (nodes). 
Like the XQuery query, the mapping tree allows also the rule to reuse the variables defined in the ancestor rules. In rule r ure 1, for example, the definition of the variable $n , i.e., the path $w/name/text() , reuses the variable $w defined in r 2 the computation of $n is determined by the bindings of the con-text variable, i.e., $w . In the work of [6], such a reuse relationship is also called a correlation between a pair of nesting mappings. Alternatively, rule r 4 can be defined independently [13], i.e., by introducing to r 4 a new variable, say $w1 , using the same path as defining $w , and then correlating r 2 and r 4 using an explicit corre-lation $w is $w1 . Yet we observe that in the process of trans-forming the XML mappings into th e intermediate trees, preserv-ing the reuse relationships will re sult in the reduction of the num-ber of composition routes in the CRG, and then improve the effi-ciency of the maintenance of the composed mapping. 
Suppose both M 1, 2 and M 2, 3 in Example 1.1 have been repre-sented intermediately as the mapping trees. In the following ex-amples, when no special statements are declared the symbol M refers to the mapping trees. We divide M 1, 2  X  M compositions of M 1, 2 and each atomic rule r contained in M the mapping M i , j . The resulting composed mapping M also. The dividing approach makes a look in depth of the compo-sition relationships between the mappings. We capture such the relationship through a composition route that relates together the atomic rules involved in a sub-composition. When computing the composition, we record such r oute information through an auxil-iary structure called composition route graph (CRG). In Section 4 we will present the example mapping tree M 2, 3 and the process of computing the composed mapping M 1, 3 . For the moment, we provide a preview of the example CRG in Figure 2, where each row consists of the atomic rules in the corresponding mapping (including the composed mapping) . The composition routes are depicted using arrow lines between the atomic rules of each pair of neighboring rows and the pointers attached to the constraint rules in the composed mapping. The composition routes record the atomic rules involved in the sub-compositions. For example, the following routes say that the sub-composition M 1, 2  X  M 2, 3 . r 3 involves only rules r and r 2 of M 1, 2 and the result is rule r 3 of M 1, 3 consider the constraint rule M 1, 3 . r 9 in the CRG. The pointer states that M 1, 3 . r 9 is derived from M 1, 2 . r 9 . Since M mapping chain, so no compositi on is involved here, i.e., M a direct copy of M 1, 2 . r 9 . 
The dividable composition approach and the CRG make it able to maintain the composed mappi ng incrementally. Consider our running example. For the change s hown in Example 1.1, we first of some advanced mapping editors ), which includes an update to rule r 2 and insertions of two new rules r 10 and r Then, for every the basic change (denoted by  X  m 1, 2 ) contained in Section 1) by taking advantage of the route information in Figure are presented briefly as follows, respectively, while more details can be found in Section 5. y  X  m 1, 2 ={UPDATE: ( r 2 , r 2 ' )}, where r 2 ' denotes the updated y  X  m 1, 2 ={INSERT: r 10 }. Notice that M 1, 2 . r 10 servers as a con-y  X  m 1, 2 ={INSERT: r 11 }. Similarly, M 1, 3 is maintained by in-
In this way we get the final updated composed mapping M ' Generally, when changes occur on M 2, 3 or both M 1, 2 and M composed mapping M 1, 3 can be maintained in the same way. As 
Figure 2. The composition route graph (CRG) built when composing M 1, 2 and M 2, 3 in our running example
Figure 1. The intermediate tree representation for the XML mapping M 1, 2 shown in Example 1.1 can be seen, our approach uses only the changes to maintain the composed mapping and avoid unnece ssary re-computations. Note that though our approach needs to create and maintain the CRG, this extra cost is much smaller when compared to the unnecessary cost made by the complete maintenance approach. 
In this section, we present the mapping tree, as have been seen, which is an intermediate model in our approach. Let X  X  begin with the atomic rule. Let sp denote a simple path expression with no branching predicates,  X  refer to the comparison operator, and the letter a correspond to an XML tag. We define the atomic mapping rule as follows. As can be seen, we define the atomic rule as an atomic item or a simple XQuery query. The atomic item can be an empty XML element &lt; a /&gt;, a variable $v , a literal , or an auxiliary (). The sim-one optional where clauses, where the path expressions are not permitted to be used in the where or return clauses, i.e., they can only be used in the for clause to define the variables. For representation our discussion re gards also the atomic item $v as a special query. We abuse the terminology and refer to the two types of rules as static and query rules, respectively. Sometimes we call also the atomic item () or the query that returns () an aux-iliary rule. Now we present the mapping tree, where every node corre-sponds to exactly an atomic rule and every edge denotes a nesting relationship or a conditional cons traint. Sometimes our discussion uses also the rule to refer dir ectly to the corresponding node in the tree. We say that a path sp depends on another path sp' , which means that sp starts with the variable defined using the path sp' . In the mapping tree, particularly, sp' can be included in an ancestor rules. When applied to data, as have be seen in Figure 1, some nodes in the mapping tree transform data from the source to the target, while the other nodes serve as conditions constraining the transformation. We refer to them as d -nodes and c -nodes, respec-tively. Note that within a c -node (say n ) can other nodes be nested to model complex conditional constr aints. In this case, the sub-tree rooted at n serves totally as a constraint. 
Semantically, the nesting relationship relates together the cor-responding pair of returned parent -child data nodes. Generally, a and  X  a conditional constraint. Currently we consider only the form count()&gt;0 , which imposes the constraint on the parent rule of r by taking as input the results of the sub-tree rooted at r . For brevity, the conditional constraint count()&gt;0 is not presented in our figures. When a node has several child c -nodes, the corre-sponding conditional constraints are concatenated through a logi-cal operator and , respectively. Note that the auxiliary rule can serve as a d -node and model a union sema ntics. When applied to data it returns  X  data nodes, which can be safely removed from the XML instances. 
The mapping tree can express arbitrary conjunctive and nested queries over the source schema. As have been studied in the set-tings of data integration and data exchange [11, 18], Skolem func-tion is a facility used to deal with missing information and object fusion. In current version we don X  X  consider this facility, though it can be regarded as an atomic item. More generally, our mapping model can be extended to permit th e atomic rule uses functions (e.g., distinct-values ) or intermediate rules in the for and where clauses. Such an extension is a future work. We believe that our work in this paper would pave the way for a general solution to the maintenance problem. In fact , the current mapping model can express the same fragment of XQuery query as presented in [15], where mapping composition is one of the main optimization tech-niques for efficiently answering que ries in the peer data manage-ment system Piazza [7]. 
The transformation of an XML mapping is trivial into the in-termediate model. For example, when parsing the where clause of line 2 in Example 1.1, the condition $b/year&gt; 2000 is sepa-rated from the current atomic rule that is being built (i.e., r Figure 1) so that no path expressions are contained in the where clause (in this example, the where clause is no more needed to an auxiliary rule (i.e., r 9 ) that serves a c -node in the mapping tree M 1, 2 . The transformation process always uses the auxiliary rules to simulate the separated condition expressions. 
Given a chain of successive XML mappings. Suppose they have been transformed into the mapping trees as shown above. In Section 4.1 we divide M 1, 2  X  M 2, 3 into sub-compositions of M and every atomic rule r contained in M 2, 3 , i.e., M We show that the mapping tree is closed under the composition, other mappings in the given mappi ng chain, we can further com-pose M 1, 3 with the next mapping in the chain, say M 3, 4 compose the resulting M 1, 4 and the next again, and so on. Notice that the composition can be started with any pair of neighboring mappings in the chain. The dividing composition approach pro-vides a fine-grained perspective of the composition relationships between the mappings. In Section 4. 2 we depict such information through a data structure called composition relationship graph (CRG). 
Let dn be a d -node of the mapping tree. (Note that dn also represents the corresponding atomic rule.) We abuse the notation dn . tag to refer to the data node types returned by the atomic rule, nodes (including their descendent s, if any) nested within dn . Ac-cording to the definition of the atomic rules, dn . tag can an ele-ment name,  X  , or a text value. Definition 4.1. Let sp be a simple path query over a mapping tree consists of d-nodes only. Under a given context, e.g., a d-node of M, if sp matches with (dn 1 .tag) . (dn 2 .tag) . ... . (dn the path mp is a match of sp. 
This is the same as sp matching to XML document except that a .  X  . a 2 are both matched to the path query / a 1 / a 2 . If sp starts from a document root, then the context is null and mp is an absolute path also. Otherwise, if sp depends on sp' , then the context is the tail node of the match of sp' . In other words, dn definition must be one of the children of the context node. M  X  r . Let r be a query rule given as follows, which contains path queries sp 1 , ..., and sp n . for $v 1 in sp 1 , ..., $v n in sp n where cond return atomic_item The composition begins with matching r and M . To simplify the discussion, we assume that every sp i ( i =1.. n ) has only one match-ing path mp i . Given the context nodes, we call the set of matching paths mp i a pattern match of r over M . According to the matching pattern, rule r is rewritten into a composed rule r symbols of M . At the same time, if needed, the process produces also a unifier for the matching path mp i , which will be applied to the where and return clauses of r to replace the variables. Fur-nodes) that derived from M . We denote the result of M  X  r by M which consists of r c and, if any, r c . cons . 
Specifically, the rule r c is produced by concatenating respec-tively the for and where clauses of all the query rules contained in the matching pattern. Let every mp i (1  X  i  X  n ) in the pattern con-sist of a series of d -nodes dn i , 1 , ..., and dn i , k corresponds to either a query rule or a static rule. Since the static rule has no significant effect on the rewriting, for expository rea-query rules and each of them has the following form. For brevity, we write a single clause  X  V in SP  X  instead of  X  $v sp , ..., $v n in sp n  X . The notations cond | $v  X  sub ( $v ) item | $v  X  sub ( $v ) below denote substitutions that replace each variable $v contained in cond and atomic_item of r with corresponding sub ( $v ), respectively. The rule r c is produced as follows: c = cond 1 , 1 and ... and cond n , k . 
When the rules contained in the pattern are all static, the result-ing r c is static also. Obviously, the above rule r format of the query rule given in Section 3. Further, since each node dn i , j in mp i can nest c -nodes, such constraints dn any) should be reflected in th e composition. Consequently, r c . cons = dn 1, 1 . cons and ... and dn n , k . cons . Example 4.1. Figure 4 shows the mapping tree M 2, 3 our running example. Cons ider the composition M 1, 2  X  M matching (the query path /S2/book contained in) the query rule M 2, 3 .r 3 with the mapping tree M 1, 2 (see Figure 1), we then use the rule, i.e., by concatenating respectively the for and where clauses in both of M 1, 2 .r 1 and M 1, 2 .r 2 . Since M the rewriting involves only M 1, 2 .r 2 . The composed rule is pro-duced as follows. The constant returning item of r, e.g., &lt;dbbook/&gt; , remains un-changed in the composition. Further, in the mapping tree M sulting rule, the composition produces also a nested c-node that contains the same rule as M 1, 2 .r 9 . 
As another example, consider the composition M 1, 2 By taking M 1, 2 .r 2 as the context node, the path r matches with $b/title/text() of M 2, 3 .r 5 . In the same way, the com-position produces the following atomic rule. The returning variable $t of M 2, 3 .r 5 will be replaced with a substi-tution sub($t) in the composition. Further, in this example, no constraints are posed on any node in the matching path r only the above rule is produced.
 the return clause, the compositions will rewrite it into symbols of M . Let the variable $v be defined by the path sp , i.e., $v in sp , and mp be the matching path that consists of a series of d -nodes dn returning item ( atomic_item k ) must be a variable or literal so that it always returns text values wh en applying to data. The composi-tion should make the variable $v bound to the values returned by dn , i.e., sub ( $v )= atomic_item k . Similarly, if dn rule then it must be a literal, which replaces the variable $v of rule r in the composition. Example 4.2 Consider again the composition M 1, 2  X  M shown in Example 4.1. The return clause of M 2, 3 variable $t. According to the matching match r 3 . r result of the compos ition is as follows. M M 1, 2  X  r , where r corresponds to every rule contained in M denote each the sub-composition result by M c . When r is static, the sub-composition remains it unchanged, i.e., M c query rule, the sub-composition proceeds in the same way as pre-sented above, and the resulting M c consists of a composed rule r and, if any, the constraints r c . cons . Let r correspond to node n of M 2, 3 . The final composed mapping M 1, 3 is derived from M replacing r with r c for each the node n and, if any, nesting r are determined by th e sub-compositions of M 1, 2 and the ancestor rules of r . The resulting M 1, 3 has the following characteristics: y M 1, 3 preserves the nesting (i.e., parent-child) relationships y If r serves as a d -node ( c -node) of M 2, 3 , then r
In this way, we compose the mappings M 1, 2 and M running example. Figure 5 shows the resulting composed mapping M 1, 3 . Notice that in M 1, 3 the constraint rules over r include both r 8 and r 9 , where the extra constraint r the sub-composition M 1, 2  X  M 2, 3 . r 3 (see Example 4.1), while r the result of the sub-composition M 1, 2  X  M 2, 3 . r the composed mapping is also a tree that has a similar structure as M 2, 3 . Specifically, we have the following conclusion. Theorem 4.1 Mapping tree is closed under the composition. 
Generally, given a chain of successive mappings, the composi-tion proceeds in pairs. The final composed mapping is a tree also. 
At the level of the atomic rule, we can look in depth at the rela-tionship of the composition of two neighboring mappings. For example, under the given contexts, the composition M  X  r involves only partial atomic rules contained in M , while the other rules are irrelevant and make no contribu tions to the composition result. We define such relationships as composition routes . Definition 4.2 For the composition M  X  r, where r is a query rule, if r i be one of the rules that make up of the pattern match, then we say that there is a co mposition route from r i to r. 
When r is static, the composition remains it unchanged, so there is no any composition route from M to r . In other words, the composition is irrelevant with M in this case. We extend such relationships between M and r to including the composition result so that when given a chain of schema mappings, we can also know which atomic rules in the ch ain are related with a certain rule contained in the resulting composed mapping. Definition 4.3 Let r be an atomic rule, and the composition M  X  r produce a resulting rule r c , possibly together with r refer to r as the composition derivation of r c , and for each rule r contained in the resulting r c . cons, the corresponding rule r' in the mapping tree M as the composition derivation of r c '. propositions. y In the composed mapping M 1, 3 , every rule, say r y If r c serves as a d-node of M 1, 3 , then the derivation must 
Given a chain of successive mappings M 1, 2 , M 2, 3 Let M 1, n be the composed mapping. We use a data structure called composition relationship graph ( CRG ) to depict such relation-ships between the atomic rules. Specifically, the CRG is a hierar-chical graph ( V , E , P ), where y The hierarchies correspond in sequence to M 1, 2 y V denotes the set of atomic rules (i.e., nodes) contained in y E denotes the set of edges between each pair of contiguous y P denotes a function that assigns every c -node of M
The CRG is built in the process of composition. Figure 2 has exemplified the CRG for our running example. In terms of it, it is convenient to know that, for example, rules r 1 and r 2 also the derivation of every rule in the composed mapping. Definition 4.4 Let M 1, 2  X  ...  X  M n-1, n = M 1, n . For an atomic rule r in the corresponding CRG, in the following we define a set of composition routes, denoted by scr(r). y If r belongs to M i, j (i  X  n-1, j=i+1), scr(r) = { r' | In the CRG y If r belongs to M 1, n , scr(r)=scr(r'), where r' is the derivation Example 4.3 Consider the CRG shown in Figure 2. As can be seen, for example, 
Let r be a rule contained in the given mapping chain, e.g., in the mapping M i , j . Scr ( r ) captures all the atomic rules related with rules that participate in the computation of the composed rule r . posed rule r involves no any computation, i.e., it is produced di-rectly by copying this single rule contained in scr ( r ). 
Since the CRG holds the inform ation of composing the map-ping chain, we can take advantage of it to re-compute M 1, 2
Figure 5. Composed mapping M 1, 3 in our running example M i -1, i  X  r . The detailed process is shown in the procedure Compo-sition_SCR , where line 5 obtains the composition routes from the CRG and selects directly from the corresponding route set scr ( r the matching pattern for each the composition M k , k+ 1 1..1), and then line 6 uses the pattern to compute the composition in the same way as shown in Sec tion 4.1. Since the matching rules are obtained directly in terms of the CRG, the re-computation is efficient, especially when the schemas involved are large. Example 4.4 Consider our running example again. According to scr(M 2, 3 .r 8 ), for example, the re-computation of M uses directly rules M 1, 2 .r 5 and M 1, 2 .r 6 to rewrite M composed rule, i.e. M 1, 3 .r 8 .
The above works provide the premise for maintaining the com-posed schema mappings incrementally. Given a chain of succes-sive mappings M 1, 2 , ..., M i , j ( j = i +1),..., M mapping M 1, n , and the corresponding CRG. When changes occur on any mapping (say M i , j ) in the chain, we model  X  M level of the atomic rules and reduce them into the insertion, dele-tion, and update of the nodes (atomic rules) of M ing to each the change type, the maintenance algorithm is devel-oped that takes advantage of the dividable composition approach and the information provided by the CRG. When needing to com-pose the change and the chain of the mappings, the algorithms call the procedure Composition_SCR to compute  X  M 1, n and then use it to update the original composed mapping M 1, n . 
Generally,  X  M i , j contains multiple rules that correspond to the insertion, deletion and update cha nges, respectively. The mainte-nance proceeds by taking the corresponding algorithm for each the change. Recall the dividing approach for the composition, where the matching pattern of the rule r determines the sub-compositions of the descendent ru les that reference the variables defined in r . So, if there is a change to the definition of a variable descendent rules that references the variable $v . The maintenance algorithms are developed based on the changes to a single map-ping in the given chain, which in cludes the insertion and deletion of a rule that serves as a c -node, and the update of a query rule (in either a d -node or c -node). For the other changes, the maintenance can proceed by applying such basic algorithms. Insert a c -node. Let X  X  begin with the change that inserts a c -node cated by the discussion in Section 4, the composition only possi-bly rewrites rule r into the c -nodes of the composed mapping, and this opportunity is completely dete rmined by its parent rule, i.e., r . Hence, according to r p and the information provided by the CRG, the maintenance process can determine how to repair the old composed mapping using  X  M 1, n , which is computed by com-M M 1, n and the corresponding CRG. 
It is not necessary that every atomic rule in the mapping chain contributes to the composed mappi ng, i.e., in the CRG such rules does not affect the composed mapping. To avoid unnecessary work, the algorithm (line 3) first checks if the parent rule of r turned directly. Otherwise, the algorithm matches the new in-serted rule r with the mapping M i -1, i and uses the pattern match to achieve the composition route set, i.e., scr ( r ). Then, line 8 com-putes the composition M 1, 2  X  ...  X  M i -1, i  X  r . As shown by the pro-cedure Composition_SCR , instead of each the whole mapping tree, only related atomic rules are involve d in the computation. Further, notice that the right sub-chain of mappings are skipped in this process, which means that, if the change occurs on M computation of composition is need ed in the maintenance process. Finally, the algorithm (lines 9-11) takes the resulting  X  M repair the composed mapping. Specifically, in the original com-posed mapping, once there is a rule r c whose composition routes, Algorithm 5.1  X  Insertion of a c -node Input: the given mapping chain, the composed mapping 
Output: updated composed mapping M 1, n and CRG 1. r  X  the rule in the inserted c -node of  X  M i , j 2. r p  X  the parent of r 3. If r p is useless for M 1, n , return M 1, n and the CRG 4. Matching r and M i -1, i 5. For each r i ( i =1.. k ) in the pattern match 6. In the CRG, add a composition route from r i to r 7. scr ( r )  X  { r }  X  scr ( r 1 )  X  ...  X  scr ( r k 9. For each atomic rule r c of M 1, n , if r p  X  scr ( r 10. Insert  X  M 1, n as a sub-tree into r c 11. Assign every node of  X  M 1, n a pointer to the 12. Return the updated M 1, n and CRG Proc. -Composition_SCR ( ( M 1, 2 , ..., M i -1, i ), r , CRG ) 
Input: successive mappings M 1, 2 , ..., and M i -1, i
Output: the composed mapping M c /* The procedure takes advantage of the CRG to compute the composition M 1, 2  X  ...  X  M i -1, i  X  r */ 1. M c  X  r 2. For each M k , k+ 1 ( k = i -1..1) 3. For each node n contained in M c 4. r c  X  the atomic rule contained in n 5. S  X  { r k | r k  X  scr ( r c ) and belongs to M k , k+ 1 6. M c '  X  M k , k+ 1  X  r c , using the set of rules in S 7. Replace r c with r new-c of M c ' and, 8. Return M c serted c -node. At the same time, the CRG is updated also in the process. Such extra cost, when compared to the unnecessary com-putation taken by the complete re-composition approach, is much smaller and can be ignored. Example 5.1 Consider our running example . Fig. 3 has shown the c-node into rule r 2 . According to the CRG shown in Fig. 2, r participates in the computati on of the composed rule r Such constraint should be reflected in M 1, 3 . In this special exam-ple, the maintenance needs no any computation and an extra constraint into M 1, 3 .r 3 . In the same way, the insertion of r is propagated into the composed mapping M 1, 3 . Delete a c -node. Inversely, a c -node can be removed from M with easily by removing the c -nodes (including their descendents) from M 1, n that have pointers to the deleted rule, see Algorithm 5.2. Update a rule. In the CRG, if there is a path from a rule (say r ) of M i , j to a rule (say r c ) of M 1, n , i.e., r  X  scr ( r pate in the computation of r c . When r changes, the original com-posed rule r c has to be re-computed. Our algorithms restrict the change to a single mapping, hence we pay attention to the case where r is a query rule that may change the path queries, the con-ditional expressions and the returned atomic item $ v . In other words, the update of r only possibly affects the composition routes between M i -1, i and r . 
Let r' be the updated version of r . The maintenance (see algo-rithm 5.3) proceeds by computing scr ( r' ) (line 3) and then using it exactly the atomic rules used to compute the new composed rule. Since in the CRG, rule r may have several path s to (the rules of) M 1, n , the algorithm needs to maintain every such composed rule r (lines 4-8). Specifically, for each r c , the algorithm updates scr ( r first (line 5) and then computes the corresponding  X  M 1, n i.e., the composition M 1, 2  X  ...  X  M k -1, k  X  r M k , k +1 is the composition derivation of r c . When r a d -node of M 1, n , the derivation is just some rule of M k = n -1; When r c serves as a c -node, rule r may be contained in a d -case, k = i , i.e., the derivation just refers to rule r . Finally, the algo-sponding rule r c , including the constraint rules whose derivations are contained in any one among M 1, 2 , ..., and M k -1, k Example 5.2 Consider the update of M 1, 2 .r 2 shown in Fig.3. According to the CRG shown in Fig. 2, M 1, 2 .r 2  X  scr ( M Algorithm 5.3 first updates th e composition routes of M 1, 3 and then calls Composition_CRS(( M 1, 2 ), M 2, 3 .r M 2, 3 .r 3 is the composition derivation of M 1, 3 .r 3 . By taking advan-tage of the information provid ed by the CRG, the procedure knows directly that the pattern match between M 1, 2 consists of rules r 1 and r 2 ' of M 1, 2 , which then are used to rewrite M 2, 3 .r 3 into the following rule r new-c : for $w in /S1/book, $r in /S1/review return &lt;dbbook/&gt; At the same time the procedure ge nerates also the constraint r new-c .cons, which consists of the ru les that are derived from r M 1, 2 and the new inserted rules r 10 and r 11 of M algorithm repairs the original composed mapping M 1, 3 (see Fig. 5) by replacing r 3 and the corresponding rules contained in r with r new-c and r new-c .cons, respectively. Note that in the process of the rule of M 2, 3 . 
As have been seen, the procedure Composition_SCR computes not only the new composed rule r new-c but also the constraint rules r new-c . cons . In fact, such procedure can be further optimized, since some resulting constraint rules ma y have been in the composed mapping M 1, n , and the update of r makes no affection on them. 
In the other cases, e.g., insertion of a d -node, or more generally, multiple changes on different mappings, the composed mapping can be maintained in the same way. As can be seen, our approach uses only the atomic rules related to the changes to compute the update to the composed mapping, while the other mapping parts of the chain are irrelevant with the maintenance. Algorithm 5.2  X  Deletion of a c -node Input: the given mapping chain, the composed mapping 
Output: updated composed mapping M 1, n and CRG 1. r  X  the rule in the deleted c -node of  X  M i , j 2. r p  X  the parent of r 3. If r p is useless for M 1, n , return M 1, n and the CRG 4. From the CRG, remove all the composition routes 5. For each atomic rule r c of M 1, n , if there is a pointer to r 6. Delete the sub-tree rooted at r c 7. Return M 1, n and the CRG Algorithm 5.3  X  Update of a rule r Input: the given mapping chain, the composed mapping 
Output: updated composed mapping M 1, n and CRG /*  X  M i, j contains both the old rule r and the updated rule r'. 
An example can be found in Fig. 3. */ 1. r  X  the old rule, r'  X  the updated rule 2. If r is useless for M 1, n , return M 1, n and the CRG 3. Update the composition routes and scr ( r' ) 4. For each atomic rule r c of M 1, n , if r  X  scr ( r 5. scr ( r c )  X  scr ( r c )  X  scr ( r )  X  scr ( r' ) 6. Let M k , k +1 . r c ' be the composition derivation of r 8. Replace r c of M 1, n (including related r c 9. Return M 1, n and the CRG Evaluation. There are several factors that can make influence on the efficiency of the incrementa l maintenance approach. The first factor is the size of the change. Extremely, when a mapping M changes dramatically, the com posed mapping may have to be maintained by a complete re-computation. In such an extreme case the complete re-computation is acceptable since it means a new setting of the mapping environm ent. Besides, the different chains of mappings and the change itself can also affect the effi-ciency of the maintenance algorithms presented in Section 5. Fig-ure 6 shows an example mapping chain M 1, 2 and M corresponding CRG, where rule M 1, 2 . r 3 is isolating in the CRG (Note that r 3 can be either static or query rule.), while rule M contributes to every rule in the composed mapping M updating M 1, 2 . r 3 , the maintenance of M 1, 3 needs no any computa-tion. Yet in the worst case, when M 1, 2 . r 1 changes, the incremental maintenance approach becomes closer to the complete mainte-nance approach. 
We define a parameter p called  X  X ffection rate X  to measure the degree of the affection caused by the different factors on the effi-ciency of our incremental maintenance algorithms. Given a chain of successive mappings M 1, 2 , ..., M n -1, n . M mapping. The parameter p is defined as  X  N / N , where N denotes the number of atomic rules invol ved in re-computing the composi-tion M' 1, n completely and  X  N corresponds to the number of rules involved in computing  X  M 1, n using the incremental approach. More precisely, 
 X  N = | scr ( r 1 )|+...+| scr ( r i )| for each r contained in  X  M
N = | scr ( r 1 )|+...+| scr ( r n )| for each r contained in M'
Consider the examples shown in Figure 6. In the best case  X  N =0 and p =0 also, while in the worst case both  X  N and N include 8 rules and then p =1. Intuitively, as p becomes smaller, the advan-tage of the incremental approach is more significant. On the flip side, if a change makes p close to 1, which means the number of rules used in the incremental appr oach is approximately the same as the complete approach, then the algorithms reduces to the com-plete maintenance. Experiments. We conduct a number of experiments under differ-ent changes to test the affection rate p defined above and the effi-ciency of our approach. We implement a general maintenance algorithm, which considers multiple matching patterns (see Sec-tion 4) and integrates the basic cases shown in Section 5. The prototype is developed in JDK 1.6 and the parser for XML map-pings is derived from XQEngine [ 16]. The experiments were per-formed on a PC machine with a single 2.0GHZ P4 CPU and 2GB RAM, running Windows Vista. 
Two scenarios were created based on XMark [14] and DBRe-search [15]. In the first scenario we derived 5 restructured varia-tions to produce 6 different XML schemas, and in the second we choose the collection of schemas used in Piazza [15]. For every scenario we built a mapping chain th at consists of five successive mappings expressed as XQuery queries. Then our prototype took them as input and transformed each into the corresponding map-ping tree. The prototype provides a GUI such that we can operate directly the tree nodes. We made five changes for every scenario. The following table describes the change sizes using n 1 n is the number of atomic rules in the change and n 2 denotes the number of rules of the corresponding mapping trees. DBReserach 6/266 10/266 26/266 18/266 21/266 
In our experiments, every cha nge simulated a modification on one part of a certain schema. In the scenario of XMark, for exam-ple, changes C1-C5 are derived fro m modifying different parts of schema S 4 , which corresponded to category , person , open_auction , closed_auction and mailbox , respectively. Hence C1-C5 were made up of related atomic rules of M 3, 4 and M above table every n 2 is the total number of the rules of M M 4, 5 . In the first experiments, the prototype executed the incre-mental maintenance algorithm for every the change and returned the affection rate p . We report the results as follows. 
As can be seen, the affection rate caused by every change keeps small still, which means that, in general, the maintenance caused by local mapping change is local also. This conclusion is con-firmed further through our sec ond experiments, where we com-pared the maintenance times for every change between the incre-mental and the complete approaches. Because of the limited space we report only the results for the scenario of XMark (see Figure 7). It can be noticed that the complete maintenance approach spent approximately the same tim es (about 2.3 seconds) for every change. Note that our experiment s were conducted directly on the intermediate mapping model and the results didn X  X  include the times for parse and transformation of the mappings. Compared with the complete approach, for changes C1-C4, the incremental approach improved significantly the maintenance efficiency. By examining change C5 and the chain of mappings, we found that in the composition there were multiple matching patterns related 
Figure 6. A special example showing how changes make different influence on the efficiency of the incremental maintenance algorithms Times (s) with mailbox , which increased the number of the atomic rules of participating in the maintenance. Despite so, the improvement of efficiency is obvious also for change C5. We conclude that our incremental maintenance approach is efficient in practice, where, as reported in [17], the schemas and then the mappings do not change radically. Schema mapping has been extensively studied in the literature. The related topics include mapping formalisms [8, 4, 6], mainte-nance [17, 19], composition [9, 5] and management framework [1, 2]. The Clio [3] project is a pioneer in mapping discovery [10, 12] and proposes high-level mapping languages like source-to-target tgds [4] and nested source-to-target tgds [6], which correspond to GLAV assertions [4]. Our work is based on intermediate tree that tends to model either user-orien ted or implement-oriented map-pings, and in current version of our work we consider LAV/GAV-style mappings. To some extent, in aspect of the facilities for modeling nesting mapping, our ma pping model is similar to the nested source-to-target tgds. The Clio project also studied map-ping maintenance against schema changes [17, 19]. In contrast, our work focuses on the maintenance of the composed mapping under mapping changes. Both works think that in practice the schemas and then the mappings do not change radically. The Piazza [7] project proposed the peer data management system (PDMS), where mapping co mposition is studied [9] and proposed to serve as one of its main optimization techniques for answering queries efficiently [15]. Further, Yu and Popa [19] applied mapping composition to maintain mappings under some schema evolution scenarios. Yet, to the best of knowledge, our work is the first to study the problem of the maintenance of the composed mappings. We believe the incremental maintenance approach proposed in this work would improve the scalability of large-scale data sharing systems like the PDMS, since in dynamic environment the mappings may cha nge frequently and any change can lead to a large number of requirements for maintaining the pre-computed composed mappings. We notice that the work in [15] considered peer mappi ngs following LAV/GAV paradigm also. In fact, mapping composition is a hard problem whose diffi-culty is quite sensitive to the expressiveness of the allowed map-pings [2]. The dividing compositi on approach proposed in this paper is based on the restricted mapping formulas. The work [5] provides a way to extend our approach to a general setting in fu-ture. In [5], Fagin et al. showed how the composition of two first order GLAV mappings can create a second order mapping. 
Bernstein et al. [1, 2] proposed a general framework of model management in whic h schemas and mappings between them are considered and manipulated as first-class citizens. Our work con-siders mappings as meta-data artifacts also and can be regarded as an extension of the management of the mappings. 
In this work we proposed the problem of maintaining the com-posed schema mapping and studied an incremental approach in the XML setting. An intermedia te mapping model was proposed first, which consists of simple at omic rules. Then we divided the composition of a chain of successi ve intermediate XML mappings into sub-compositions of atomic ru les, and employed a data struc-ture called composition relationshi p graph (CRG) to depict the composition relationships at the le vel of atomic rules. Next, for the basic mapping changes, we developed corresponding mainte-nance algorithms that take advant age of CRG and use only atomic rules related with the changes to maintain the composed mapping. Finally, we reported the first expe riment results, which show that the incremental approach is efficient in practice. 
Our work paves the way for a general solution to the mainte-nance problem. There are several avenues for future work. For instance, we have currently studied the maintenance problem for GLAV mappings. Other open probl ems include the composition and maintenance under schema cons traints [18] and the optimized composition scheme for a network of mappings. [1] P. A. Bernstein. Applying M odel Management to Classical [2] P. A. Bernstein and S. Melnik . Model Management 2.0: Ma-[3] Clio. http://www.cs.toronto.edu/db/clio/ [4] R. Fagin, P. G. Kolaitis, R. J. Miller, and L. Popa. Data Ex-[5] R. Fagin, P. Kolaitis, L. Popa, and W.-C. Tan. Composing [6] A. Fuxman, M.A. Hern X ndez, C.T.H. Ho, R.J. Miller, P. [7] A. Y. Halevy, Z. G. Ives, P. Mork, and I. Tatarinov. Piazza: [8] M. Lenzerini. Data Integration: A Theoretical Perspective. [9] J. Madhavan and A. Halevy . Composing mappings among [10] R. Miller, L. Haas, and M. Hern X ndez. Schema Mapping as [11] Y. Papakonstantinou, S. Abiteboul , and H. G. Molina. Object [12] L. Popa, Y. Velegrakis, R Mille r, M. A. Hernandez, and R. [13] G. Qian, Y. Dong. Construc ting Maintainable Semantic [14] A. Schmidt, F. Waas, M. Kersten, M. Carey, I. Manolescu, [15] I. Tatarinov, A. Halevy. Effi cient Query Reformulation in [16] XQEngine. http://www.fatdog.com [17] Y. Velegrakis, R. J. Miller, and L. Popa. Preserving mapping [18] C. Yu and L. Popa. Constrai nt-Based XML Query Rewriting [19] C. Yu and L. Popa. Semantic Adaptation of Schema Map-
