 Consistency maintenance (CM) techniques are a crucial part of many distributed systems, and are particularly important in net-worked games. In this paper we describe a framework of the human factors of CM, to help designers of networked games make better decisions about its use. The framework shows that there is wide variance in the CM requirements of different game situations, iden-tifies the types of requirements that can be considered, and analy-ses the effects of several consistency schemes on user experience factors. To further explore these issues, we carried out a simu-lation study that compared four CM algorithms. The experiment confirms many of the predictions of the framework, and reveals ad-ditional subtleties of the algorithms. Our work is the first to look comprehensively at the tradeoffs and costs of CM, and our results are a strong starting point that will help designers improve on the user X  X  quality of experience in distributed shared environments. H.5.3 [ Information Interfaces and Presentation ]: Group and Organization Interfaces X  X omputer-supported cooperative work. Human factors, Algorithms Consistency maintenance, game development, game usability Consistency maintenance (CM) is the process of establishing and preserving a shared and equivalent state across two or more nodes in a distributed system [26]. Consistent representations of a shared environment are a critical requirement for many situations in dis-tributed groupware and networked games: in a shared editor, dis-cussing a text document requires that people see the same repre-sentation of the text; in a multi-player game, all nodes must agree on issues such as whether an enemy was hit by the player X  X  attack, whether the player collided with an obstacle or not, and whether a trade was successfully completed. For these and many other situa-tions, CM is a necessary part of the software design for a distributed environment.

The need for consistency in these and other situations, however, does not mean that CM should be generically applied across all aspects of a distributed application. The main reasons for being selective are that not all situations in a distributed interaction have the same consistency requirements as the examples above, and that CM techniques are costly, both in terms of development complexity and in terms of reducing the users X  quality of experience. The sec-ond of these problems  X  the effects of CM on user experience  X  is the more important of the two, since it is possible for CM to cause as many new problems for user interaction as it solves. For exam-ple, CM techniques may add latency to the visual representation of another player X  X  actions, causing problems for communication and coordination; they may incorporate correction actions which can be visually jarring and difficult for people to understand; and they can prevent access to objects in the environment, which can cause frustration and confusion.

These costs imply that designers should apply CM judiciously, carefully choosing CM techniques to match to the user experience requirements of a particular situation. To do this, designers need to know both the consistency requirements for the scenarios that will occur in their applications, and the effects of different CM schemes on different aspects of user experience. However, there is currently very little information that can guide design decisions in this area.
In this paper, we provide this information: we present a three-part framework that explores the human factors of CM for multi-player games. The first part of the framework recognizes that dif-ferent scenarios within a game can have very different consistency requirements, and specifies the requirements for several canonical game situations. Second, the framework discusses how the require-ments can be met, details specific metrics for measuring user expe-rience, and outlines the main characteristics of several different CM approaches. Third, we identify four specific game CM algorithms and test them in a simulation study. The study puts the relationship between CM approaches and user experience on an empirical foot-ing, and confirms the analyses made possible by the framework  X  for example, that injecting local lag delay on processing user inputs reduces a game X  X  responsiveness, and that using client-side predic-tive algorithms improves animation smoothness. The study also reveals interesting additional behaviours of the CM algorithms: for example, that variance in latency has a bigger negative effect on consistency than the latency itself, and that when using local lag techniques, the reduction in responsiveness and propagation delay can actually be smaller than the added lag.

Our framework and evaluation make three important contribu-tions to the design of multi-user games and distributed collabora-tive systems: first, we establish that CM schemes must be care-fully matched both to the consistency requirements and the user-experience requirements of particular interactive scenarios; second, we provide a framework that specifies requirements, aspects of user experience, and the characteristics of several main CM approaches; and third, we provide the first empirical study comparing the effects of different CM algorithms on user-experience metrics. The under-standing and knowledge provided by this work can provide much-needed guidance to designers who must satisfy both the needs of the distributed system and the needs of the people who use it. Although there has been relatively little research into the hu-man factors of consistency management schemes, many other as-pects of user experience in distributed groupware and multiplayer games have been studied in previous literature. Researchers have looked at issues such as helping people maintain awareness of oth-ers (e.g., [18]), how multi-player game usability can be assessed (e.g., [22]), determiners of social presence in distributed work (e.g., [20]), and the effects of latency and other network problems on communication and coordination (e.g., [2, 10]). In addition, there has been a great deal of work on specific concurrency and CM algorithms (e.g., [26, 19]); further details of some of these techniques are reviewed later in the paper. Both streams of this work are vital to groupware design, and form a foundation for our investigation of experiential issues in the domain of consistency.
The intersection of these areas has not received a great deal of attention from CSCW or the game research community, but prior work in has considered three substantial issues in the human fac-tors of CM. First, an early analysis by Greenberg and Marwood [9] looked at consistency requirements for real-time distributed group-ware, and introduced the idea that not all actions in a shared editor necessarily need to be governed by CM. We build directly on this idea, and expand on it in the framework described below. Second, a few researchers have looked at how specific algorithms can be used to deal with particular user experience problems: for example, pre-venting the  X  X ead men shooting X  problem using Time Warp [15], or using local lag to support situations that require tightly-coupled coordination [6, 25]. Third, research has looked at the effects of prediction on player interpretation and the costs of correcting erro-neous predictions (e.g., [21]).

These few previous studies and analyses, however, do not pro-vide a comprehensive understanding of when CM is needed in groupware or networked games, how designers can determine re-quirements for different interaction scenarios, what are the user-experience factors that designers need to preserve, or how various CM techniques can affect those factors. In the next sections, we provide a framework that provides initial understanding in this area, particularly for designers of multi-player games. A consistency requirement for a particular situation implies that there are non-deterministic changes being made to some state that is both distributed and shared. To understand the consistency re-quirements for a particular interactive scenario, therefore, it is im-portant to understand three aspects of multi-player games: the types of entities that can be in the shared environment, the types of inter-actions that players can have with those entities, and the types of consistency that could be required for an interaction. At some level all entities in a multi-player game are equal  X  that is, they are all just entries in a database or objects in a model. How-ever, different types of entities often have different consistency re-quirements, and so it is useful to group entities into broad cate-gories. We have identified eight main groups that have proven to be useful in thinking about consistency.  X 
Local avatar. The local player X  X  avatar is a special entity, since it is the player X  X  embodiment in the world. Since the local avatar is the agent through which the player acts in the game, require-ments for consistency will often be tighter than for representa-tions of others X  actions. For example, it is important to show fast and accurate feedback as a player moves in the world.  X 
Other players X  avatars. The avatars belonging to other play-ers may have different consistency requirements depending upon their relationship with the local player. Opponents will typically have stricter requirements than those of players cooperating with the local player. For example, in a shooter game there would be a low tolerance for inconsistencies in the target player X  X  position.  X 
Player variables. Variables such as lives, health, and money are often critical to the objectives and outcome of the game, and so have stricter consistency requirements than other entities. For example, the simple understanding of whether a player is alive or not is of critical importance; failure of CM in this regard can have dramatic effects on the game [15].  X 
Inventory. There are often a large number of objects attached to a particular player, such as weapons or treasure obtained from previous interactions. These items are similar in many respects to those existing in the game world, but may have different re-quirements because their use is often restricted to a single player.  X 
Objects in the world. Games provide a wide variety of resources in the shared environment, from game pieces in chess, to move-able obstacles in a racing game, to treasure in an online RPG.
There are a wide variety of possible consistency requirements for these entities, given their wide range of possible uses, and requirements are determined by their intended use (see below).  X 
Terrain. The world itself is comprised of shared entities (trees, rocks, ground, buildings, etc.) that can be modified in some games, which may require that the changes be propagated to other nodes. Examples include one player destroying a bridge or digging a hole that others can fall into.  X 
Attack objects. Objects used in attacks  X  such as bullets, spells, or punching fists  X  are generally different from other world ob-jects, since they move (often quickly) and have important effects on other entities. Consistency requirements are often different (and stricter) for these objects. We note that in some games, bullets and fists are purely cosmetic since the hit decision is based on avatar positions at the start of the action; however, some games are moving towards modeling these attack objects (e.g., using the Wii MotionPlus for real-time control), and some games allow players to make use of ordinary objects in attacks (as with
Half-Life X  X  gravity gun).  X 
Chat. Written conversations are an important part of many games, and these statements, while not part of the game world itself, are also a set of data that must be shared across multiple nodes. Since chat is typically not editable, it has reduced con-sistency requirements compared with a traditional shared editor; but there could be requirements related to ordering of messages in the transcript. The ways in which entities can interact is a main determiner of consistency requirements  X  not in terms of the actual actions that occur, but in terms of the dependencies and effects of these actions on entities that are important to the game. We have identified five factors that are common in many games; these allow designers to reduce the number of situations where CM needs to be imposed.  X 
Is interaction possible with the entity. The most basic question in determining consistency requirements is whether anything in the game can affect or change the entity. If not, there is no need to track or maintain the shared state of the object: for example, objects such as clouds in the sky of the game world may be com-pletely independent from any actions, and so inconsistencies are unimportant.  X 
Is interaction possible by multiple people at once. It is also im-portant to consider whether entities can be manipulated by just one person (e.g., an item in a player X  X  inventory) or by multiple players (e.g., an item lying on the ground); interactions that can involve multiple people have stricter consistency requirements (e.g., ensuring that only one person can pick up the object).  X 
Ability to affect critical game variables. The degree to which interaction with an entity can affect important game variables (such as health or life) determines the need and type of CM.
For example, the action of defusing a bomb can have a major impact on player life and health, and so must be more consis-tently represented across the nodes of those affected. This factor makes important distinctions between situations that on the sur-face look similar. For example, consistency requirements for interactions with other players are not all equal, since interac-tions with teammates have less effect on critical variables such as health and life (assuming no friendly fire kills) compared to interactions with (i.e., attacks on) enemies.  X 
Timescale of future interactions. The amount of time that will elapse before another person or object could possibly interact with the entity is a limiting factor on consistency requirements.
For example, if a player wants to pick up an object from the en-vironment, and no other avatar is near enough to cause a conflict, there is no requirement to impose CM on the interaction. Note that this limitation is not the same as simple proximity, since some types of interactions have effects at a distance (e.g., beam weapons can shoot instantaneously across infinite distance).  X 
Probability of future interaction. Consistency requirements are also affected by the likelihood that an interaction with an entity will occur in a certain time period. In situations where interac-tions are unlikely, the requirements for consistency are reduced.
For example, if a player modifies the game world X  X  terrain, but does so in a location that is rarely travelled, there is less of a need to guarantee that the modifications are copied immediately to each node. Reducing consistency based on probabilities can lead to problems  X  e.g., if another player does take the rare path, a problem could result  X  but using likelihood as the basis for applying CM techniques is reasonable when computational and network resources are constrained. Consistency between two versions of a model can diverge in three main ways  X  in magnitude, in time, and in rate of change  X  and con-sistency requirements for a particular situation essentially translate to the allowable tolerance for each type of divergence. Specifically, requirements can be stated in terms of:  X 
State divergence , which specifies, for a given instant in time, how much two players X  view of a model differ. For example, a situation where a group of player avatars moves from one place to another can tolerate a higher degree of state divergence (i.e., players will not be affected by positional inaccuracies as the group moves) than a first-person shooter game where players target each other with sniper rifles (and where divergence in po-sitions can lead to incorrect kills).  X 
Propagation delay , which indicates how long it takes the game to bring all clients to a consistent state after a change on one client. Requirements for propagation delay indicate the amount of time that a situation can tolerate an inconsistency. In a first-person shooter, high propagation delay can lead to  X  X ead men shooting X  due to time to deliver a death decision. For game sit-uations such as an avatar changing socks or transmitting a chat message, players can accept longer propagation delay.  X 
Timeline divergence , which specifies the extent to which two players X  experiences of a phenomenon differ. For example, one player might view the casting of a  X  X ireball X  spell as three sec-onds of casting animation, followed by an explosion effect, fol-lowed by the deduction of hit points from the target. Another player on a slower connection might see a compressed timeline, where the casting animation lasts only one second. While both players see the same final effect, the timeline has diverged. If the length of the casting animation gives the player the opportunity to take counter-measures (such as trying to interrupt the caster), then such timeline divergence can have significant gameplay consequences. Another example of timeline divergence could be one player X  X  view of another player X  X  movement, where the exact path may diverge, possibly involving jarring corrections.
Some CM algorithms may also result in  X  X ollateral damage X , where meeting a requirement on one of the three attributes listed above may degrade other aspects of player experience. For exam-ple, the popular local lag algorithm [25] reduces a game X  X  respon-siveness, while locking or serialization algorithms may reduce the smoothness of animation. Consistency requirements must therefore be considered in the context of broader player experience.
Poor choices about CM techniques can have significant impact on game usability. For example, a study of problems reported in 108 game reviews showed that 29 were reported as being insuffi-ciently responsive to user input, and 42 reported unpredictable re-sponse to user X  X  actions (e.g., as a result of poor hit detection) [22]. While these did not necessarily result from consistency mainte-nance problems, this data shows that the sorts of problems that arise from poor CM are considered to be serious flaws in games.
Finally, we note that there are interface and game-design strate-gies that can reduce these requirements, which we do not detail here. For example, one technique that reduces consistency require-ments is the idea of object pointing, in which a player selects an-other player as the target of an action (e.g., a spell) rather than moving a cross-hair target; this selection-based targeting dramati-cally increases the tolerance for state divergence. Here we characterize several canonical game situations in terms of the concepts introduced above, in order to show how this part of the framework can be used to analyze and discuss the requirements of different game scenarios.  X 
FPS death decisions. First-person-shooter games have strong consistency requirements for making decisions about whether one player has killed another. This decision must be the same on all clients, and has a low tolerance for propagation delay, since the decision has important consequences for some players X  fu-ture actions (i.e., games do not want situations where dead men are allowed to keep shooting).  X 
Trade. Many games allow players to buy, sell, or barter items; these transactions must be consistent across all clients, but in most cases there is a larger tolerance for propagation delay (i.e., it is not a problem if the transaction is not propagated to all clients for a few seconds).  X 
Feedback for a moving player. Responsiveness is a critical part of a user X  X  experience in a networked game, and so providing fast feedback about a local player X  X  movements in the world is critical.  X 
Other players X  positions. As introduced above, there are sub-stantial differences in consistency requirements for representing others X  positions, depending on their relationship to the local player. If the other player is an enemy in a shooter game, then there is low tolerance for state divergence (so that aiming and shooting can be carried out successfully). If the other player is not likely to be targeted (e.g., is on the local player X  X  team) po-sitional consistency is less important.  X 
Clothing choice. An avatar X  X  clothes are generally not objects that other entities in the world can interact with, and so the consistency requirements for showing a change of clothing are low (but not non-existent, since the change should eventually be propagated to all clients). There are nonetheless game situations where these types of decorative changes could be important for the game (e.g., waving a red glove could be the signal to start a coordinated attack); in these special cases, the tighter consis-tency requirements will have to be recognized by the designer.  X 
Physics effects. Many games have physics engines that create realistic effects for in-game events (e.g., falling rocks, spinning cars, shattering glass or explosions). However, the particles and objects used in these visual effects generally do not inter-act with players (i.e., a shard of glass from a shattering window in F.E.A.R. will not harm or kill a player). As a result, the parti-cles X  locations need not be consistent across different clients.  X 
Avatar animations. Avatar-based games provide standard an-imations for actions such as walking, waving, or pointing. For example, a walking animation may use a looping track that plays the next frame every iteration of the frame loop. Since the posi-tions of hands and feet often do not affect critical game variables (e.g., the hit-box for an avatar might be a rectangular box that ig-nores arms and legs, and so the position of limbs does not affect gameplay), there is high tolerance for state divergence in these models (e.g., one client might have an avatar in the middle of a stride animation, whereas another client has it at the end, but the location of the avatar is the same in both cases). The previous sections have outlined the kinds of problems that arise due to difficulties in maintaining consistency, and have illustrated that different gameplay situations may have very different consis-tency requirements. In this section, we first introduce the techni-cal side of the CM problem, indicating why no single algorithm is sufficient for balancing all CM requirements. We then introduce operational metrics that can be used to characterize the effects of specific CM algorithms on user experience, and finally introduce the core elements of CM algorithms typically used in games. The difficulty of achieving consistency in multiplayer games is in-fluenced by how games are architected. Games are almost univer-sally built as client-server applications with partial replication. The problem is then to maintain consistency between the partial replicas -in the terms introduced above, state divergence is a consequence of inconsistent replicas, and propagation delay results from the time required to send data over the network.

Games are typically based on a frame loop , consisting of the three steps of polling input devices, updating game state, and ren-dering the frame. This loop is executed as quickly as possible: for example, to achieve a frame rate of 60 Hz, less than 17 ms is avail-able for each iteration. This means that any complex calculations (e.g., complex simulations of physics or artificial intelligence) can-not be performed inside the frame loop.

In most games, the client implements the frame loop and the server implements the game logic and maintains the canonical game state. Since any network communication with the server takes milliseconds to resolve, server requests cannot be performed within the frame loop. Therefore, any shared data required to com-pute the next frame must be available on the client (via partial repli-cation) and any communication with the server must be carried out asynchronously.

A primary reason why this architecture is widely used (over, for example, peer-to-peer architectures) is security. Game players have proven willing to devote extraordinary efforts to cheating [11], to the point of cracking encrypted client-server protocols and hand-modifying the compiled binary of the client. This means that clients cannot make decisions that affect the game state. For example, in a first-person shooter game, the client is not allowed to decide whether a shot has hit an opponent. Similarly, the client is not al-lowed to store  X  X ecret X  information that the player should not have access to, such as the location of objects or players behind a wall. These restrictions naturally lead to an architecture where the client implements the user interface and performs actions that do not af-fect game state, while the server makes game-critical decisions (or audits decisions made by the client).

There are three main ways in which this architecture affects con-sistency maintenance:  X 
Execution speed: the required speed of execution of the frame loop implies that some data must be replicated to the client. This leads to state divergence when replicas fail to have the same value.  X 
Update frequency: updates are transmitted between client and server asynchronously, normally at a rate far slower than the frame loop X  X  frequency. In general, this leads to higher propa-gation delay. For game objects changing their state in real time, this may lead to stuttering animation. Game architectures fre-quently use predictive algorithms to attempt to guess the current state of remote game objects (described further below).  X 
Security: Clients may not store any  X  X ecret X  game-affecting data. This restricts the use of potentially helpful CM algorithms; e.g., the client cannot pre-fetch  X  X ecret X  data that might be useful in the near future, and cannot reduce propagation delay by simu-lating the server X  X  AI algorithms or carrying out game-affecting physics calculations. The architecture described above both causes consistency problems and constrains the space of solutions. Consistency problems can be addressed through CM algorithms (as will be discussed in sec-tion 4.3), and through game design decisions that reduce the need for consistency.

Algorithms necessarily trade off qualities of the player X  X  experi-ence. For example, the local lag algorithm [25] reduces state di-vergence at the cost of reduced local responsiveness. Predictive algorithms such as dead reckoning [21] improve smoothness of an-imation and may reduce state divergence, but at the cost of timeline divergence when the predictive algorithm fails (e.g., exhibited as jarring warps of player positions.) It is important to note that to fix one set of usability problems due to poor consistency, we frequently need to make other aspects of the player X  X  experience worse.
To allow us to more precisely assess how the choice of CM al-gorithm can affect user experience, we identify five performance metrics. The metrics are based on two factors: they correspond to commonly-seen measures of the performance of groupware sys-tems and games, and they can be observed and computed in real games as they execute. Underlying the choice of these metrics is the hypothesis that each value, if allowed to become large, will in some circumstances negatively affect the player X  X  quality of expe-rience in the game. These metrics allow us (and others) to develop clear guidelines about the consequences of a particular CM choice. The metrics are:  X 
Magnitude of state divergence captures the degree of consistency between two players X  views of part of the game state at a given time. For example, the state divergence of two players X  views of a single avatar could be measured as the distance between the avatar X  X  position on each client. An appropriate distance metric is required to measure how far the states diverge; for example,
Euclidean distance might be used for positional information.  X 
Magnitude of propagation delay is the time from a player per-forming an action to other players X  seeing the propagation of that action. In a first-person shooter, this could be the time be-tween one player pushing  X  X  X  and others seeing that player X  X  avatar move.  X 
Corrections counts the number and magnitude of modifications required to repair an incorrectly divergent state. This metric is associated with the timeline divergence requirement, as it mea-sures the work needed to regain consistency in divergent time-lines. For example, when dead reckoning [21] is used to estimate the position of moving objects, a correction (or warp ) may be re-quired to move the object to its correct location. As with state divergence, a distance metric is required to measure the magni-tude of a correction.  X 
Response time represents the delay from a player performing an action to his seeing the result of that action. In a first-person shooter game, this might be the time between pushing the  X  X  X  button to seeing the avatar move forward.  X 
Animation delay measures the delay between on-screen updates of a particular game object X  X  state. E.g., this might represent the time between positional updates of another player X  X  avatar.
These measures are not independent of one another. For ex-ample, high animation delay increases response time [27], poor feedthrough time may lead to increased state divergence, and high state divergence may in turn lead to more severe corrections. Our simulation experiment (reported below) helps tease out the nature of these subtle relationships.

Ideally, each of these metrics has small values. The question of how small they have to be depends on the requirements of that in-teractive scenario, but there are general results that indicate when problems may arise. According to Schneiderman, in highly inter-active tasks, response times become noticeable once they exceed 50 X 150 ms, while with less interactive tasks, delays of up to one second are tolerable [23]. According to Jay et al., propagation de-lay is noticeable starting at 50 ms, and differences in propagation delay become evident in 50 ms increments [12]. Based on analysis with the model human processor, Card et al. suggest that animation rates must be in the range of 10 X 20 frames per second (or 50 X 100 ms animation delay) for animation to be smooth [5]. Far higher ani-mation rates are required for fast-moving images, unless additional effects are used (e.g., motion blur). Requirements for magnitude of state divergence and corrections are specific to the task being performed, as motivated by our examples from section 3. Consistency maintenance in games draws on concepts from dis-tributed databases and groupware, but also introduces several new ideas. Consistency approaches used in traditional groupware fall into four broad categories: locking, optimistic locking and trans-formation, serialization, and  X  X ocial protocols X .  X 
Locking. Locking and transaction-based approaches require a node to obtain a  X  X ock X  before carrying out changes to shared context. To obtain transaction-level serializability, algorithms such as two-phase locking are required [8]. Locking is used in game situations where transactional atomicity is required, for example, in a player trade consisting of a withdrawal and deposit operation pair.  X 
Optimistic locking. Optimistic approaches allow operations to be enacted locally on the assumption that conflicts between con-current operations are rare. Optimistic algorithms are widely used in games to reduce response time: for example, player movement in first-person shooter games is generally performed optimistically. Optimistic algorithms differ in how they re-spond to conflicts: rollback schemes (such as TimeWarp [16] and ORESTE [13]) undo conflicting operations to an earlier cor-rect state and then reapply operations in a canonical order; op-erational transform avoids rollbacks by transforming incoming operations so that the state converges [26]. Both approaches can lead to jarring corrections, and are inappropriate in some cases (e.g., where a death decision might be reversed retroac-tively.) Operational transform is rarely (if ever) used in games, as it favours fully-replicated architectures, and because the situ-ations where optimistic algorithms are used in games rarely re-quire OT X  X  complex generality.  X 
Message-level serialization. A third approach commonly used in groupware is serialization [1, 7], in which messages are sent to a centralized serializer which broadcasts the messages to all clients in a consistent order. Serialization results in poor re-sponse time, as operations cannot be enacted locally until they have travelled to the server and back again. Serialization is also a poor choice in cases where the timing of messages is as impor-tant as the order [3, 28]. Serialization is widely used in online games, however, to determine a canonical order of actions for example, to determine which player shot first in a gunfight.  X 
Social protocols. The final traditional approach is to use no al-gorithm at all, relying instead on people X  X  awareness of each oth-ers X  activities and their willingness to avoid conflicts [9]. Social protocols are rarely (if ever) used for CM in games, however, because games are often competitive, and because the risk of cheating is ubiquitous [11].

In addition to these approaches, games have developed addi-tional techniques that are less commonly found in traditional group-ware: prediction, local lag, and remote lag.  X 
Prediction. Predictive strategies attempt to determine the posi-tion of an object in the game world, based on a model of the object X  X  movement. A commonly-used method for prediction is dead-reckoning, where the recent locations of the object are used to determine the likely next location. Dead-reckoning assumes that objects will continue to move in their previous heading and Figure 1: The four CM algorithms: CS=Centralized Serializa-tion; EQ=EverQuest; LL=Local Lag; HL=Half-Life. Assum-ing that player position is a 1D value changing over time, la-tency is a constant 50 ms, LL adds 100 ms of lag time, and the HL algorithm adds 150 ms of lag on the remote client, shows how each algorithm would represent a given positional trace on the player X  X  computer and on a remote player X  X  computer. velocity, which is often true for objects with inertia. Predic-tive algorithms can reduce state divergence (when predictions are correct), or increase it when incorrect. In addition, predic-tion can improve animation smoothness, but can lead to jarring corrections when errors are made.  X 
Local lag. State divergence is caused by the time it takes for updates to be sent across the network. This delay cannot be re-duced, but the divergence can be eliminated by adding delay to the local input. For example, if a user presses the  X  X  X  key to move forward, they will not see their avatar move until after the delay period. Local lag makes it possible to synchronize the local and remote views of the world. When using local lag, de-velopers must choose between a lag constant that balances the penalty to responsiveness versus the possibility of messages ar-riving late (i.e., after the lag period has expired.) A variant on local lag is bucket synchronization [3], which is used in games such as the popular Age of Empires series. In bucket synchro-nization, inputs performed in a given frame are collected and applied at the beginning of a subsequent frame.  X 
Remote lag. This strategy is a buffering approach designed to allow more updates to arrive at the remote client before they are used. This approach is widely used in streaming-media appli-cations such as voice over IP, but is also used in a few multi-player games. By allowing two positional updates to arrive be-fore the first position is displayed, the client can accurately cal-culate a smooth animation (using interpolation between the two updates). This reduces jarring corrections, but at the cost of in-creasing state divergence. The specific algorithms used in games are often a combination of the conceptual approaches introduced above. Here we identify four typical algorithms that we will use in the study described below. Three of the algorithms are derived from actual games, and one is a simple baseline approach. Figure 1 gives a simplified view of the operation of each of the algorithms.

In section 6, we evaluate these algorithms in the context of player movement, a canonical game situation that was described earlier in the framework. In this scenario, the CM problem is that of ensuring that the positions of different players X  avatars are consistent on all clients. This is a central problem, since player position is crucial to navigation, aiming, and coordination of player actions. It is also a technically demanding problem  X  the designers of the game Lin-eage 2 claim that player movement accounts for upwards of 70% of all network traffic in online role playing games [14]. Player movement is a strong example of a situation where traditional CM algorithms are not applicable. Our first algorithm follows the serialization approach described above. By itself, this approach is rarely used in production games, but we include it here to provide a baseline comparison. In this algorithm, movement updates are sent to the server, where they are validated and then broadcast to all clients. On each client, the player X  X  position is reported as the last positional update received from the server. As can be seen in Figure 1, this algorithm ex-hibits a low update rate, due to the step function representing the last value received from the server. Centralized serialization might work reasonably over a local-area network, but gives unacceptable responsiveness and animation delay in a wide-area context. This algorithm, used by the popular massively-multiplayer online game EverQuest (as well as many other games), introduces opti-mistic local updates and prediction using dead reckoning [21]. The EverQuest algorithm has not been published, but has been reverse-engineered by the open-source ShowEQ project [24].

In this algorithm, updates to the player X  X  own position are op-timistically committed locally, allowing smooth and timely local feedback (see Figure 1); these optimistic updates can be overruled through post-hoc server validation. On the remote client, position updates are received from the server, and therefore appear later than on the local client (i.e., increased state divergence). To avoid the step-function effect of centralized serialization, dead-reckoning is used to predict the position of remote avatars by assuming that they will continue to move in their previous heading and velocity. Fig-ure 1 shows that although dead-reckoning provides smoother an-imation updates, it can lead to jarring corrections when an avatar abruptly changes direction (i.e., the spikes in the figure). This algorithm is one of a family of variants of local lag, and ad-dresses the large state divergence and corrections of the EverQuest algorithm. Local input is delayed so that, despite delay from net-work latency, the local and remote clients see the same action at the same time. In addition, the remote client uses prediction to smooth avatar movement between updates. Figure 1 shows how local and remote movement are synchronized, lagging behind ac-tual movement. Due to variance in packet delivery times, messages will sometimes fail to arrive within the bound of message delivery times. In such cases, standard repairs can be applied; for example, Mauve shows how TimeWarp can be combined with local lag [16].
Local lag (and its bucket synchronization variant) are a good choice for real-time strategy games where a delay in applying in-puts is not easily noticed; it is a poor choice for first-person shooters where poor response time is more visible. Figure 2: In Snagger , two players each control a ship, and co-operatively drag a net to catch aliens. Snagger was used to gen-erate example input data used to compare the four CM algo-rithms of section 5. The algorithm used in the Half-Life series of first-person shooter games addresses the problem of timeline divergence of predictive algorithms, at the cost of state divergence [2]. The key elements of this approach are remote lag and interpolation .

Local inputs are applied immediately to optimize responsive-ness. Remote inputs are delayed long enough for two positional updates to arrive. Prediction is not required, since the algorithm interpolates between the two pending updates. Players thus view remote avatar movement exactly as it occurred (within the limits of interpolation), but offset in time.

To avoid the problems of increased state divergence, the server resolves hit decisions based on the shooting player X  X  view of the remote avatar. This means that a player may be killed despite hav-ing just moved behind cover (if another player saw them clearly on their local machine).
 We now turn to the study that we carried out to test these four CM algorithms in actual game situations, and how they affected our five metrics of user experience. In order to test these different CM approaches in terms of the user-experience metrics defined in the framework (section 4.2), we car-ried out a simulation experiment. The experiment helps illustrate that user experience tradeoffs between CM algorithms can be mea-sured empirically through our metrics, and it serves as a first step towards our goal of cataloguing such tradeoffs to help game design-ers. As we shall see, our experiment confirmed expected properties of the algorithms, as well as revealing some surprising properties. The experiment consisted of ten simulation trials of each of the four algorithms under three different latency conditions. The algorithms introduced above were fully implemented, and were tested using recorded game traces and recorded latency values. The five metrics of section 4.2 were measured under each condition. To collect game data for the simulations, we used Snagger , a sim-ple network game shown in figure 2. Snagger is an example of a game requiring close coordination between two players. The game consists of two clients and a server which passes messages between the two clients. Each player has a spaceship avatar, which is moved forward using the up arrow key and rotated using the left and right arrow keys. The objective of the game is for the players to move their ships around the screen and capture aliens in a net that is strung between the two ships. To capture an alien, the players must manoeuvre their ships so that an alien is inside the loop formed by the net and then press the space bar. Snagger was developed using C# and XNA Studio 3.1.

To provide consistency between trials with the four algorithms, we instrumented Snagger to run using user input read from a data file. The data file contains a sequence of keyboard states, which Snagger reads as if the inputs were coming from a real keyboard. Prior to the experiment, input data was collected from live play of the game (by players unassociated with this paper), over a local area network. During the game play, their inputs were captured by recording which keys were being pressed each time the input was polled. Ten sets of data were collected, each consisting of 1,500 inputs. Each data set corresponded to approximately 25 seconds of play. The experiment simulated three network conditions: zero latency, low latency and high latency. The latency conditions attempted to approximate the conditions one might experience when playing a game on real game servers, where zero latency is similar to LAN play, low latency is similar to a server on one X  X  own continent, and high latency corresponds to a server on another continent. (Al-though the same input was played back for all simulated network latencies, it is quite likely that players would adjust their behaviour as the latency increases, and that the inputs may not correspond exactly to what one would experience in a high-delay situation). The protocol used by most network games (including Age of Empires, EverQuest and Half-Life) is UDP [17]. In the experiment, we simulated UDP X  X  latency and packet loss rate. CAIDA, the Co-operative Association for Internet Data Analysis, has reported that  X  X ing X  round trip time data matches well with the round trip time for UDP [4]. Based on this, we used  X  X ing X  round trip time data to approximate UDP latency. The servers yahoo.com and yahoo.cn were selected as representative of a server on the same continent and of a server on another continent (based on our North American location.)  X  X ing X  data was recorded for a three hour period for each server. Analysis of the data for round trip times showed that it was distributed according to a Poisson distribution with median values of 33 ms and 323 ms for yahoo.com and yahoo.cn respectively.
The  X  X ing X  file was split into 10 parts, each long enough to be usable for one simulation trial. In each trial, the system loaded files for the game data and network latency; as each message was sent from the client to the server and back to the other client, the message was delayed by a time equal to the next round trip time from the file. The four algorithms were implemented as described in section 5. In the Half-Life game, a message containing the player X  X  position is sent to the server every 50 ms [2]. For consistency, we adopted the same frequency for the other algorithms.

The local lag and Half-Life algorithms required us to choose val-ues for their remote and local lag parameters.

The choice of a local lag constant should strike a balance be-tween the negative effects of the lag itself on responsiveness of the user interface versus the state divergence and corrections resulting from late messages [16]. We chose a lag constant of 100 ms, based on Stuckel and Gutwin X  X  findings that this is the largest tolerable lag in highly interactive tasks [25].

For Half-Life, the remote lag value should ensure that at least one future position is available at all times, allowing the position of the remote avatar to always be interpolated. In practice, it is impossible to set an upper bound on the time it may take for a message to arrive. We therefore set remote lag equal to twice the Alg.
 CS 0/0 0 0.14 29 6.4 18 49 EQ 0/0 0 0.08 29 0.4 1.5 17 HL 0/100 0 0.68 78 0.0 1.5 17 CS 0/0 33 0.33 63 6.5 58 50 EQ 0/0 33 0.10 64 0.7 1.5 17 HL 0/166 33 1.09 145 0.0 1.5 17 CS 0/0 323 2.10 346 8.3 342 66 EQ 0/0 323 0.50 345 3.8 1.5 17 HL 0/746 323 4.55 725 0.0 1.5 17 Figure 3: Results summary. CS=Centralized Serialization; EQ=EverQuest; LL=Local Lag; HL=Half-Life. Times in ms.
 Within each latency condition, all differences in the table are significant at the  X  =0 . 05 level, except propagation delay for the CS and EQ algorithms under the medium and high latency conditions. median network latency (as described above), plus (to allow for occasional lost messages) twice the time between message sends (2 * 50 ms in our case). The remote player lags used in the experiment were therefore set at 100, 166 and 746 ms for zero, low and high latency respectively.

For the EverQuest and Centralized Serialization algorithms, no additional lag was used. The five metrics were calculated as follows:
Response time is calculated by storing the time each input is polled and then determining the first time at which that input has an impact on the displayed position of the local avatar. Our mea-sure does not include operating system time (the time that elapses between when a key is pressed and when the input is polled) or the time between invocation of screen update operations and the appearance of new information on the physical display.

Propagation delay is calculated by storing the time associated with each input by the remote player and then determining the first time each input has an impact on the displayed position of the re-mote avatar on the local computer. As with response time, it does not include operating system time.

Corrections are calculated each time the local player receives a message containing an updated position for the remote player X  X  avatar. The estimated position of the remote player X  X  avatar is cal-culated just before the new position message is processed. A sec-ond position is then calculated just after the new position message has been processed. The distance warped is calculated as the dis-tance between these two positions and is expressed as a percentage of the screen size.

State divergence is calculated as the difference between the po-sitions of the remote avatar on the local and remote client. State divergence is also expressed as a percentage of the screen size.
Animation delay is the time between changes in the position of the remote avatar. Whenever a screen update is invoked, if the po-sition of the remote avatar has changed, then the elapsed time since the last position update is recorded. Each of the four algorithms was tested under each of the three la-tency conditions, for a total of 12 conditions. Each condition was tested ten times, and each condition used the same ten input game-data files and latency files, as described above.

For each trial, two instances of the Snagger client and the Snag-ger server were run on a single computer (2.66 GHz Intel i5 proces-sor, 3 GB RAM). Each trial used different input and latency files. The computer was rebooted between each trial. Values for the met-rics over each trial were determined and their values recorded. The results from the experimental runs are summarized in figure 3. All the metrics have been designed such that a small value is good and a larger value indicates poorer performance.

As shown in Figure 3, centralized serialization has the highest animation delay, since it does not extrapolate or interpolate avatar positions between updates coming from the network. The Ev-erQuest and Half-Life algorithms had the lowest response times, since they perform immediate optimistic updates. Local lag has the highest response times (because of the injected local lag), and the lowest state divergence (as updates are synchronized on all clients.) Half-Life has the lowest corrections value (as it uses interpolation rather than predictive extrapolation); it also has the highest state di-vergence, due to the injection of remote lag without corresponding local lag.

The results allow us to summarize the strengths and weakness of the four algorithms as applied to the avatar movement problem:  X 
Centralized serialization has, as expected, no obvious benefits, performing poorly under all metrics. The performance of this algorithm clearly shows the hazards of applying generic CM strategies for specific game situations.  X 
The EverQuest algorithm provides a balance between all of the metrics -one of the main advantages of this algorithm is that it has no significant weaknesses. It is an appropriate choice for games (such as EverQuest itself) where modest state divergence and occasional corrections are considered acceptable. It would not be appropriate, however, for first-person shooter games.  X 
Local lag is a good choice in situations where it is important to have low state divergence and few corrections, and where a com-mensurate penalty in response time is acceptable. For example, local lag is a good match with the indirect control of real-time strategy games (where target positions of game entities are spec-ified via  X  X lick to move X  input).  X 
The Half-Life algorithm sacrifices state divergence for correc-tions. This algorithm is a good choice in cases where fast re-sponse time is required, and where it is important that all players see the same thing (although displaced in time.) The experiment provides several lessons for developers of consis-tency maintenance algorithms.
 Combining different approaches can improve user experience. The example of the centralized serialized algorithm shows that us-ing a single CM strategy can lead to flaws in the representation of motion (e.g., a very low update rate for avatar animation). How-ever, these weaknesses can be reduced by adding prediction to the scheme (as is done in the EverQuest algorithm). Prediction is po-tentially a valuable adjunct to several other types of CM techniques, but we note that prediction approaches only work well when play-ers move in a predictable fashion  X  for example, prediction is used for EverQuest, in which player movement is primarily used to travel from one location to another. Prediction is not used in most shooter games, however, because players generally try to move in ways that make them difficult to hit, which is also much less pre-dictable  X  the result would be large corrections in player locations, something that would not be acceptable in this type of game.
All approaches break down at a certain level of latency. The experiment shows that all the algorithms have at least one major weakness when round-trip latency grows above about a third of a second. These results reinforce that CM techniques do not com-pensate for latency, they only try to protect certain user or system requirements from latency X  X  effects. However, game design can make up for some of these limitations, such as by increasing the time scale of interaction, by reducing the precision of the weapons (no sniper rifles, only shotguns), or by slowing down movement.
Variance in latency can be worse than latency itself. As latency increases, so does the variance in message delivery times. This results in negative consequences for each of the algorithms. Un-der centralized serialization, all clients are sent the same updates at the same time; however, messages arrive at the clients at differ-ent times, causing significant state divergence. Variance in latency increases the difficulty of setting local and remote lag parameters (these tradeoffs are discussed below.) A further effect is that ani-mation delay under centralized serialization increases with latency. This is surprising, as messages are sent at a constant 50 ms rate, and so one might expect (as seen in the zero latency case) that an-imation delay would be close to 50 ms. However, due to variance in latency, it is possible for two position updates to arrive within the same interval between frame loop updates, causing the first up-date to be effectively lost. As the variance in latency increases, this occurs more frequently, leading to increased animation delay.
Propagation delay comes from more sources than network la-tency. When building games as distributed systems, it is easy to focus on network latency as the primary source of propagation de-lay. However, as seen from the results for centralized serialization and EverQuest in the zero latency case, other sources can result in significant delay. These include (1) message send delay: since positions are sent periodically (e.g., every 50 ms) and not as they occur, there can be a delay between a change being made and a change message being sent; (2) frame-loop delay: if the frame loop executes once per 17 ms, there is a delay of up to 17 ms from a message X  X  arrival to its being processed by the game; and (3) oper-ating system delay: such as the time for messages to be processed through the TCP/IP stack, and time for the network reading thread to be scheduled.
 Adjusting algorithm parameters can enable helpful tradeoffs. Our experiment used particular fixed values for each algorithm X  X  parameters, but adjustments to these parameters can change the tradeoffs inherent in each approach. For example, the local lag algorithm in our experiment added a constant 100 ms lag. How-ever, any amount of lag can be used in this scheme, which gives the designer a tradeoff between state divergence and local responsive-ness. More local lag reduces divergence, and less improves respon-siveness. It is therefore possible to use local lag to reduce some of the divergence, without sacrificing all of the local player X  X  ability to control their character. The appropriate settings for each algorithm depend (once again) on the human factors of the interaction: for example, adding 50ms of local lag might not be noticed by play-ers, but might bring the state divergence within the tolerance that is needed for a game situation. It is interesting to note than when interpolation is used, response time and propagation delay can ac-tually be less than the injected lag. This is because the effect of a queued positional update influences interpolation. Consistency maintenance is a filter through which all player-to-player interactions are mediated. The framework we have pre-sented in this paper helps to capture the costs that different CM choices impose on the player X  X  experience. We now reflect on lessons for game developers from these results, and present avenues for future research. Although this work only provides a small part of a comprehensive treatment of how CM can affect user experience in games, there are still a number of lessons that we can suggest to game designers. The specific strengths and weaknesses of the four algorithms that we tested have already been summarized, and designers can use these guidelines when designing for avatar movement. The con-ceptual framework and our experiences using it also suggest four general lessons for game designers:  X 
First, game designers must recognize that CM techniques have real effects on a user X  X  quality of experience, that different game situations have different consistency requirements, and that analysing these requirements is a critical part of designing the game experience , not just part of designing the distributed system.  X 
Second, game designers should understand that there are a wide variety of CM techniques and approaches, and that the require-ments of many situations can often be satisfied with lightweight techniques or small changes to the design of the game. The key principle is that the choice of CM technique (or techniques) should be appropriately matched to both the consistency require-ments and the user-experience requirements of the situation.  X 
Third, games can be designed around the limitations of CM al-gorithms. The disadvantages of a CM algorithm can in many cases be minimized through careful design of the interaction in the game. For example, the Half-Life algorithm is tuned for realistic and smooth movement of remote avatars, rather than for minimizing spatial divergence: this means that other players will move naturally with few corrections, but will appear behind their true position. This strategy can cause severe problems for hit detection, but the game designers avoid the problems by cal-culating hits based on what the shooter can see, not on the target avatars X  true positions This game-design strategy preserves the shooter X  X  user experience, but allows targets to be killed even when they were not really in the line of fire. One reason for favouring shooters over targets is that shooters have unequivocal feedback about aiming (i.e., the crosshair), and there is therefore much more frustration for shots that should hit but don X  X , than there is for shots that do hit but shouldn X  X  have.  X 
Fourth, designers should be aware that there is still much to know in this area, and that there are still few guidelines for sce-narios other than avatar movement. For these situations, design-ers must still carry out their own investigations (and adaptations) based on their understanding of the different CM approaches, and test the effects in their own iterative playtesting. There are a number of areas where further work is needed in un-derstanding the human factors of consistency maintenance. First, our work here has examined four CM algorithms in one typical game situation -but much more is needed before designers will have a full set of guidelines that they can draw on when devel-oping games. Therefore, we plan to expand our investigation to cover additional game scenarios, different CM approaches derived from other existing games and whether a single game could take advantage of multiple CM strategies based on different observable network properties or the intensity of interaction at a given point in time.

Second, we plan to replicate the results seen here with other games, to deepen our understanding of the material that is already in the framework, and to help determine if the guidelines are gen-eral across different genres.

Third, we plan to refine and expand the conceptual understand-ing of CM requirements and user experience metrics, through addi-tional studies and surveys of game players, and additional analysis of game mechanics, types, and genres. We believe that there is room in the framework for additional kinds of requirements (e.g., synchronization between action and speech) and additional metrics for assessing algorithms.

Fourth, we will continue experiments in the style of Stuckel [25] to help quantify metric values which represent tipping points in user experience. Designers have had little guidance in choosing appropriate consis-tency maintenance techniques for distributed multi-player games. To help address this problem, we presented a framework of the hu-man factors of CM: we identified requirements for distributed in-teraction, established metrics that can be used to quantify user ex-perience effects, and analysed the effects of several CM approaches on these metrics. We conducted a study to test the predictions made by the framework, and gathered empirical evidence about the trade-offs inherent in four real-world CM techniques. The framework and the empirical evidence for the tradeoffs is a strong start to-wards the goal of providing a comprehensive understanding of dif-ferent CM techniques for a wide variety of game situations. Much more remains to be done, but our work shows that CM schemes can be successfully analysed and tested, and shows that we can es-tablish guidelines that will help designers make informed decisions when consistency requirements and user-experience requirements collide.
 We gratefully acknowledge the funding of the NSERC Strategic Project Grant on Technology for Rich Group Interaction in Net-worked Games and the GRAND Research Network. [1] J. Begole, C. Struble, C. Shaffer, and R. Smith. Transparent [2] Y. W. Bernier. Latency compensating methods in [3] P. Bettner and M. Terrano. 1500 archers on a 28.8: Network [4] CAIDA. Packet matching for NeTraMet distributions. [5] S. Card, T. Moran, and A. Newell. The model human [6] L. Chen, G. Chen, H. Chen, J. M. S. Benford, and Z. Pan. An [7] G. Chung and P. Dewan. A mechanism for supporting client [8] K. Eswaran, J. Gray, R. Lorie, and I. Traiger. The notions of [9] S. Greenberg and D. Marwood. Real time groupware as a [10] C. Gutwin. The effects of network delays on group work in [11] G. Hoglund and G. McGraw. Exploiting online games: [12] C. Jay, M. Glencross, and R. Hubbold. Modeling the effects [13] A. Karsenty and M. Beaudouin-Lafon. An algorithm for [14] J. Lee. Considerations for movement and physics in MMP [15] M. Mauve. How to Keep a Dead Man from Shooting. In [16] M. Mauve, J. Vogel, V. Hilt, and W. Effelsberg. Local-lag [17] S. McCreary and K. Claffy. Trends in wide area IP traffic [18] R. J. Moore, E. C. H. Gathman, N. Ducheneaut, and [19] J. Munson and P. Dewan. A flexible object merging [20] K. Nowak and F. Biocca. The effect of the agency and [21] L. Pantel and L. C. Wolf. On the suitability of dead reckoning [22] D. Pinelle, N. Wong, and T. Stach. Heuristic evaluation for [23] B. Shneiderman. Designing the user interface: strategies for [24] ShowEQ project. http://www.showeq.net . [25] D. Stuckel and C. Gutwin. The effects of local lag on [26] C. Sun and D. Chen. Consistency maintenance in real-time [27] C. Ware and R. Balakrishnan. Reaching for objects in VR [28] S. Zhao, D. Li, H. Gu, B. Shao, and N. Gu. An Approach to
