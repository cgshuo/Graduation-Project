 The Netflix Prize put the spotlight on the use of data min-ing and machine learning methods for predicting user pref-erences. Many lessons came out of the competition. But since then, Recommender Systems have evolved. This evo-lution has been driven by the greater availability of different kinds of user data in industry and the interest that the area has drawn among the research community. The goal of this paper is to give an up-to-date overview of the use of data mining approaches for personalization and recommendation. Using Netflix personalization as a motivating use case, I will describe the use of different kinds of data and machine learn-ing techniques.
 After introducing the traditional approaches to recommen-dation, I highlight some of the main lessons learned from the Netflix Prize. I then describe the use of recommenda-tion and personalization techniques at Netflix. Finally, I pinpoint the most promising current research avenues and unsolved problems that deserve attention in this domain. Recommender Systems (RS) are a prime example of the mainstream applicability of large scale data mining. Ap-plications such as e-commerce, search, Internet music and video, gaming or even online dating make use of similar techniques to mine large volumes of data to better match their users X  needs in a personalized fashion.
 There is more to a good recommender system than the data mining technique. Issues such as the user interaction design, outside the scope of this paper, may have a deep impact on the effectiveness of an approach. But given an existing application, an improvement in the algorithm can have a value of millions of dollars, and can even be the factor that determines the success or failure of a business. On the other hand, given an existing method or algorithm, adding more features coming from different data sources can also result in a significant improvement. I will describe the use of data, models, and other personalization techniques at Netflix in section 3. I will also discuss whether we should focus on more data or better models in section 4.
 Another important issue is how to measure the success of a given personalization technique. Root mean squared er-ror (RMSE) was the offline evaluation metric of choice in the Netflix Prize (see Section 2). But there are many other relevant metrics that, if optimized, would lead to different solutions -think, for example, of ranking metrics such as Normalized Discounted Cumulative Gain (NDCG) or other information retrieval ones such as recall or area under the curve (AUC). Beyond the optimization of a given offline met-ric, what we are really pursuing is the impact of a method on the business. Is there a way to relate the goodness of an algo-rithm to more customer-facing metrics such as click-through rate (CTR) or retention? I will describe our approach to in-novation called  X  X onsumer Data Science X  in section 3.1. But before we understand the reasons for all these effects, and before we are ready to embrace the open research ques-tions in the area of personalization described in Section 5, we need to understand some of the basic techniques that enable the different approaches. I will briefly describe them in the following paragraphs. The most common approach to build a Recommender Sys-tem is to use one of the many available Collaborative Fil-tering (CF) algorithms [1]. The underlying assumption of these methods is captured by the principle of like minded-ness : users who are measurably similar in their historical preferences are likely to also share similar tastes in the fu-ture. In other words, CF algorithms assume that, in order to recommend content of any kind to users, information can be drawn from what they and other similar users have liked in the past. Historically, the k -Nearest Neighbor ( k NN) algorithm was the most favored approach to CF, since it transparently captured this assumption of like-mindedness: it operates by finding, for each user (or item), a number of similar users (items) whose profiles can then be used to directly compute recommendations [55].
 The main alternative to CF is the so-called content-based approach [46], which identifies similarities between items based on the features inherent in the items themselves. These recommender systems require a way to extract content de-scriptions and a similarity measure between items. Auto-matic content description is still only available for some kinds of content, and under some constraints. That is why some systems need to rely on experts to manually input and categorize the content [56]. On the other hand, content-based approaches can deal with some of the shortcomings of CF such as item cold-start -i.e. the initialization of new items that the system has no previous user preference data for.
 CF and content-based methods can be combined in different ways using hybrid approaches [15]. Hybrid RS can combine several different methods in a way that one method provides support whenever the other methods are lacking. In prac-tice, most of the advanced recommendation systems used in the industry are based on some sort of hybridation, and are rarely purely CF or content-based. No matter which of the previous approaches is used, a rec-ommender system X  X  engine can be seen as a particular in-stantiation of a traditional data mining task [4]. A data min-ing task typically consists of 3 steps, carried out in succes-sion: Data Preprocessing , Data Modeling , and Result Anal-ysis . Traditional machine learning techniques such as di-mensionality reduction, classification, or clustering, can be applied to the recommendation problem. In the following paragraphs, I will describe some of the models that, beyond the classical k NN, can be used to build a recommender sys-tem.
 Although current trends seem to indicate that other matrix factorization techniques are preferred (see Section 2.1), ear-lier works used Principal Component Analysis (PCA) [24] . Decision Trees may be used in a content-based ap-proach for a RS. One possibility is to use content features to build a decision tree that models the variables involved in the user preferences [13]. Bayesian classifiers have been used to derive a model for content-based RS [23]. Artifi-cial Neural Networks (ANN) can be used in a similar way as Bayesian Networks to construct content-based RS X  X  [47]. ANN can also be used to combine (or hybridize) the input from several recommendation modules or data sources [20]. Support Vector Machines (SVM) have also shown promising recent results [30].
 Clustering approaches such as k -means can be used as a pre-processing step to help in neighborhood formation [65]. Finally, association rules [3] can also be used[38]. In 2006, Netflix announced the Netflix Prize, a machine learning and data mining competition for movie rating pre-diction. We offered $1 million to whoever improved the ac-curacy of our existing system called Cinematch by 10%. We conducted this competition to find new ways to improve the recommendations we provide to our members, which is a key part of our business. However, we had to come up with a proxy question that was easier to evaluate and quantify: the root mean squared error (RMSE) of the predicted rating. The Netflix Prize put the spotlight on Recommender Sys-tems and the value of user data to generate personalized recommendations. It did so by providing a crisp problem definition that enabled thousands of teams to focus on im-proving a metric. While this was a simplification of the recommendation problem, there were many lessons learned. A year into the competition, the Korbell team won the first Progress Prize with an 8.43% improvement. They reported more than 2000 hours of work in order to come up with the final combination of 107 algorithms that gave them this prize. And they gave us the source code. We looked at the two underlying algorithms with the best performance in the ensemble: Matrix Factorization (MF) [35] 1 and Restricted Boltzmann Machines (RBM) [54]. Matrix Factorization by itself provided a 0.8914 RMSE, while RBM alone provided a competitive but slightly worse 0.8990 RMSE. A linear blend of these two reduced the error to 0.88. To put these algo-rithms to use, we had to work to overcome some limitations, for instance that they were built to handle 100 million rat-ings, instead of the more than 5 billion that we have, and that they were not built to adapt as members added more ratings. But once we overcame those challenges, we put the two algorithms into production, where they are still used as part of our recommendation engine.
 The standard matrix factorization decomposition provides user factor vectors U u  X  R f and item-factors vector V R . In order to predict a rating, we first estimate a baseline b uv =  X  + b u + b v as the user and item deviation from average. The prediction can then be obtained by adding the product of user and item factors to the baseline as r 0 uv = b uv One of the most interesting findings during the Netflix Prize came out of a blog post. Simon Funk introduced an incre-mental, iterative, and approximate way to compute the SVD using gradient descent [22]. This provided a practical way to scale matrix factorization methods to large datasets. Another enhancement to matrix factorization methods was Koren et. al  X  X  SVD++ [33]. This asymmetric variation enables adding both implicit and explicit feedback, and re-moves the need for parameterizing the users.
 The second model that proved successful in the Netflix Prize was the Restricted Boltzmann Machine (RBM). RBM X  X  can be understood as the fourth generation of Artificial Neural Networks -the first being the Perceptron popularized in the 60s; the second being the backpropagation algorithm in the 80s; and the third being Belief Networks (BNs) from the 90s. RBMs are BNs that restrict the connectivity to make learning easier. RBMs can be stacked to form Deep Belief Nets (DBN). For the Netflix Prize, Salakhutditnov et al. proposed an RBM structure with binary hidden units and softmax visible units with 5 biases only for the movies the user rated [54].
 Many other learnings came out of the Prize. For exam-ple, the matrix factorization methods mentioned above were combined with the traditional neighborhood approaches [33]. Also, early in the prize, it became clear that it was impor-tant to take into account temporal dynamics in the user feedback [34].
 Another finding of the Netflix Prize was the realization that user explicit ratings are noisy. This was already known in the literature. Herlocker et al. [27] coined the term  X  X agic barrier X  to refer to the limit in accuracy in a recommender system due to the natural variability in the ratings. This limit was in fact relatively close to the actual Prize threshold [6], and might have played a role in why it took so much effort to squeeze the last fractions of RMSE.
 The final Grand Prize ensemble that won the $1M two years later was a truly impressive compilation and culmination of years of work, blending hundreds of predictive models to finally cross the finish line [11]. The way that the final
The application of Matrix Factorization to the task of rat-ing prediction closely resembles the technique known as Sin-gular Value Decomposition used, for example, to identify la-tent factors in Information Retrieval. Therefore, it is com-mon to see people referring to this MF solution as SVD. solution was accomplished by combining many independent models also highlighted the power of using ensembles. At Netflix, we evaluated some of the new methods included in the final solution. The additional accuracy gains that we measured did not seem to justify the engineering effort needed to bring them into a production environment. Also, our focus on improving Netflix personalization had by then shifted from pure rating prediction to the next level. In the next section, I will explain the different methods and com-ponents that make up a complete personalization approach such as the one used by Netflix. Netflix has discovered through the years that there is tremen-dous value in incorporating recommendations to personal-ize as much of the experience as possible. This realization pushed us to propose the Netflix Prize described in the pre-vious section. In this section, we will go over the main com-ponents of Netflix personalization. But first let us take a look at how we manage innovation in this space. The abundance of source data, measurements and associated experiments allow Netflix not only to improve our personal-ization algorithms but also to operate as a data-driven orga-nization. We have embedded this approach into our culture since the company was founded, and we have come to call it Consumer (Data) Science. Broadly speaking, the main goal of our Consumer Science approach is to innovate for members effectively. We strive for an innovation that allows us to evaluate ideas rapidly, inexpensively, and objectively. And once we test something, we want to understand why it failed or succeeded. This lets us focus on the central goal of improving our service for our members.
 So, how does this work in practice? It is a slight variation on the traditional scientific process called A/B testing (or bucket testing): 1. Start with a hypothesis : Algorithm/feature/design 2. Design a test : Develop a solution or prototype. Think 3. Execute the test : Assign users to the different buck-4. Let data speak for itself : Analyze significant changes When we execute A/B tests, we track many different met-rics. But we ultimately trust member engagement (e.g. viewing hours) and retention. Tests usually have thousands of members and anywhere from 2 to 20 cells exploring vari-ations of a base idea. We typically have scores of A/B tests running in parallel. A/B tests let us try radical ideas or test many approaches at the same time, but the key advantage is that they allow our decisions to be data-driven. An interesting follow-up question that we have faced is how to integrate our machine learning approaches into this data-driven A/B test culture at Netflix. We have done this with an offline-online testing process that tries to combine the best of both worlds (see Figure 1). The offline testing cycle is a step where we test and optimize our algorithms prior to performing online A/B testing. To measure model per-formance offline we track multiple metrics: from ranking measures such as normalized discounted cumulative gain, to classification metrics such as precision, and recall. We also composition. use the famous RMSE from the Netflix Prize or other more exotic metrics to track different aspects like diversity. We keep track of how well those metrics correlate to measurable online gains in our A/B tests. However, since the mapping is not perfect, offline performance is used only as an indication to make informed decisions on follow up tests.
 Once offline testing has validated a hypothesis, we are ready to design and launch the A/B test that will prove the new feature valid from a member perspective. If it does, we will be ready to roll out in our continuous pursuit of the better product for our members. That is in fact how we came about to having the personalization experience I will describe in the next section. Personalization starts on our homepage in any device. This page consists of groups of videos arranged in horizontal rows. Each row has a title that conveys the intended meaningful connection between the videos in that group. Most of our personalization is based on the way we select rows, how we determine what items to include in them, and in what order to place those items.
 Take as a first example the Top 10 row (see Figure 2). This row is our best guess at the ten titles you are most likely to enjoy. Of course, when we say  X  X ou X , we really mean every-one in your household. It is important to keep in mind that Netflix personalization is intended to handle a household that is likely to have different people with different tastes. That is why when you see your Top 10, you are likely to discover items for dad, mom, the kids, or the whole fam-ily. Even for a single person household we want to appeal to your range of interests and moods. To achieve this, in many parts of our system we are not only optimizing for accuracy , but also for diversity .
 Another important element in Netflix personalization is aware-ness . We want members to be aware of how we are adapting to their tastes. This not only promotes trust in the system, but encourages members to give feedback that will result in better recommendations. A different way of promoting trust with the personalization component is to provide explana-tions as to why we decide to recommend a given movie or show (see Figure 3). We are not recommending it because it suits our business needs, but because it matches the in-formation we have from you: your explicit taste preferences and ratings, your viewing history, or even your friends rec-ommendations.
 On the topic of friends, we recently released our Facebook connect feature. Knowing about your friends not only gives Figure 3: Adding explanation and support for recommen-dations contributes to user satisfaction and requires specific algorithms. Support in Netflix can include your predicted rating, related shows you have watched, or even friends who have interacted with the title. us another signal to use in our personalization algorithms, but it also allows for different rows that rely mostly on your social circle to generate recommendations.
 Some of the most recognizable personalization in our ser-vice is the collection of  X  X enre X  rows. These range from fa-miliar high-level categories like  X  X omedies X  and  X  X ramas X  to highly tailored slices such as  X  X maginative Time Travel Movies from the 1980s X . Each row represents 3 layers of personalization: the choice of genre itself, the subset of ti-tles selected within that genre, and the ranking of those titles. Rows are generated using a member X  X  implicit genre preferences recent plays, ratings, and other interactions  X , or explicit feedback provided through our taste preferences survey (see Figure 4) . As with other personalization ele-ments, freshness and diversity is taken into account when deciding what genres to show from the thousands possible. Similarity is also an important source of personalization. We think of similarity in a very broad sense; it can be be-tween movies or between members, and can be in multi-ple dimensions such as metadata, ratings, or viewing data. Furthermore, these similarities can be blended and used as features in other models. Similarity is used in multiple con-texts, for example in response to generate rows of  X  X dhoc genres X  based on similarity to titles that a member has in-teracted with recently.
 In most of the previous contexts, the goal of the recom-mender systems is still to present a number of attractive items for a person to choose from. This is usually accom-plished by selecting some items and sorting them in the order of expected enjoyment (or utility ). Since the most common way of presenting recommended items is in some form of list, we need an appropriate ranking model that can use a wide variety of information to come up with an optimal sorting of the items. In the next section, we will go into some of the details of how to design such a ranking model. The goal of a ranking system is to find the best possible ordering of a set of items for a user, within a specific context, in real-time. We optimize ranking algorithms to give the highest scores to titles that a member is most likely to play and enjoy.
 If you are looking for a ranking function that optimizes con-sumption, an obvious baseline is item popularity. The rea-son is clear: on average, a member is most likely to watch what most others are watching. However, popularity is the opposite of personalization: it will produce the same order-ing of items for every member. Thus, the goal becomes to find a personalized ranking function that is better than item popularity, so we can better satisfy members with varying tastes.
 Recall that our goal is to recommend the titles that each member is most likely to play and enjoy. One obvious way to approach this is to use the member X  X  predicted rating of each item as an adjunct to item popularity. Using predicted ratings on their own as a ranking function can lead to items that are too niche or unfamiliar, and can exclude items that the member would want to watch even though they may not rate them highly. To compensate for this, rather than using either popularity or predicted rating on their own, we would like to produce rankings that balance both of these aspects. At this point, we are ready to build a ranking prediction model using these two features.
 Let us start with a very simple scoring approach by choosing our ranking function to be a linear combination of popularity and predicted rating. This gives an equation of the form score ( u,v ) = w 1 p ( v ) + w 2 r ( u,v ) + b , where u =user, v =video item, p =popularity and r =predicted rating. This equation defines a two-dimensional space (see Figure 5).
 Once we have such a function, we can pass a set of videos through our function and sort them in descending order ac-cording to the score. First, though, we need to determine the weights w 1 and w 2 in our model (the bias b is constant and thus ends up not affecting the final ordering). We can formulate this as a machine learning problem: select pos-itive and negative examples from your historical data and let a machine learning algorithm learn the weights that op-timize our goal. This family of machine learning problems is known as  X  X earning to Rank X  and is central to application scenarios such as search engines or ad targeting. A cru-cial difference in the case of ranked recommendations is the importance of personalization: we do not expect a global notion of relevance, but rather look for ways of optimizing a personalized model.
 As you might guess, the previous two-dimensional model is a very basic baseline. Apart from popularity and rating pre-diction, we have tried many other features at Netflix. Some have shown no positive effect while others have improved our ranking accuracy tremendously. Figure 6 shows the ranking improvement we have obtained by adding different features Figure 5: Constructing a basic personalized two-dimensional ranking function based on popularity and predicted rating Figure 6: Performance of Netflix ranking system when adding features and optimizing the machine learning algorithm.
 Many supervised classification methods can be used for rank-ing. In section 5.2, we will explore some of the latest ap-proaches to the learning to rank problem. The previous discussion on the ranking algorithms highlights the importance of both data and models in creating an op-timal personalized experience. The availability of high vol-umes of high quality user data allows for some approaches that would have been unthinkable just a few years back. As an example, here are some of the data sources we can use at Netflix to optimize our recommendations: So, what about the models? As we described in Section 1.2, many different modeling approaches have been used for building personalization engines. One thing we have found at Netflix is that with the great availability of data, both in quantity and types, a thoughtful approach is re-quired to model selection, training, and testing. We use all sorts of machine learning approaches: From unsuper-vised methods such as clustering algorithms to a number of supervised classifiers that have shown optimal results in various contexts. This is an incomplete list of methods you should probably know about if you are working in machine learning for personalization: Linear regression , Logis-tic regression , Elastic nets , Singular Value Decom-position , Restricted Boltzmann Machines , Markov Chains , Latent Dirichlet Allocation , Association Rules , Matrix factorization , Gradient Boosted Decision Trees , Random Forests , and Clustering techniques from the sim-ple k-means to graphical approaches such as Affinity Prop-agation .
 There is no easy answer to how to choose which model will perform best in a given problem. The simpler your feature space is, the simpler your model can be. But it is easy to get trapped in a situation where a new feature does not show value because the model cannot learn it. Or, the other way around, to conclude that a more powerful model is not useful simply because you don X  X  have the feature space that exploits its benefits. The previous discussion on models vs. data has recently become a favorite -and controversial -topic. The improve-ments enabled thanks to the availability of large volumes of data together with a certain Big Data  X  X ype X  have driven many people to conclude that it is  X  X ll about the data X . But in most cases, data by itself does not help in making our predictive models better.
 Figure 7: In some cases, accuracy does not depend so much on the model used, but on the amount of data used to train the model. (From  X  X caling to Very Very Large Corpora for Natural Language Disambiguation X  [Banko And Brill, 2001]) Probably one of the most famous quotes defending the power of data is that of Peter Norvig claiming that  X  X e don X  X  have better algorithms. We just have more data. X . He is even misquoted as saying that  X  X ll models are wrong, and you don X  X  need them anyway X  (You can read Norvig X  X  rebuttal and clarifications in his own webpage 2 ). Norvig did co-author a paper entitled  X  X he Unreasonable Effectiveness of Data X  [26] in which the authors discuss the power of data over models. The effect that the authors were referring to had already been described years before in a now famous paper by Banko and Brill [9] where the authors included the plot in Figure 7. Both Norvig, and Banko and Brill are of course right... in a context. The problem is that they are now and again misquoted in contexts that are completely different from the original ones.
 In order to understand why, we need to clarify the differ-ence between models with high variance or high bias . The basic idea is that there are two possible (and almost oppo-site) reasons why a model might not perform well. In the first case, we might have a model that is too complicated for the amount of data we have. This situation, known as high variance, leads to model overfitting. We know that we are facing a high variance issue when the training error is much lower than the test error. High variance problems can be addressed by reducing the number of features, and by in-creasing the number of data points. Both Banko &amp; Brill and Norvig were dealing with high variance models since they were working on language models in which roughly every word in the vocabulary makes a feature. These are models with many features as compared to the training examples. Therefore, they are likely to overfit. And yes, in this case adding more examples will help. In the opposite case, we might have a model that is too simple to explain the data http://norvig.com/fact-check.html Figure 8: Adding more data to high bias models will not help. This plot illustrates a real case from a production system at Netflix we have. In that case, known as high bias, adding more data will not help. See figure 8 illustrating the performance of a real production system at Netflix as we add more training examples.
 So, no, more data does not always help. As we have just seen, there can be many cases in which adding more exam-ples to our training set will not improve the model perfor-mance.
 On the other hand, high bias models will not benefit from more training examples, but they might very well benefit from more features. Or will they? Well, again, it depends. Let X  X  take the Netflix Prize, for example. Pretty early on, there was a blog post commenting on the use of extra fea-tures to solve the problem 3 . The post explains how a team of students got an improvement on the prediction accuracy by adding content features from IMDB. In retrospect, it is easy to criticize the post for making a gross over-generalization from a single data point. Many teams showed later that adding content features from IMDB or the like to an opti-mized algorithm had little to no improvement. Some of the members of the Gravity team, one of the top contenders for the Prize, published a detailed paper in which they showed how those content-based features would add no improve-ment to the highly optimized collaborative filtering matrix factorization approach [48]. Again: More data, even in the form of different features, does not always help.
 So, is the Big Data revolution only hype? No way. Having more data, both in terms of more examples or more fea-tures, is a blessing. The availability of data enables more and better insights and applications. More data indeed en-ables better approaches. More than that: it requires better approaches! In other words, data is important. But data without a sound approach becomes noise. As I mentioned before, even though there were a lot of re-search advances in the context of the Netflix Prize, the prize was a simplification. In section 3, I illustrated the broader scope of the recommendation problem by presenting Net-flix X  comprehensive approach. In this section, I will describe some of the latest advances in Recommender Systems by highlighting some of the most promising research directions. http://anand.typepad.com/datawocky/2008/03/more-data-usual.html Most of these directions are enabled thanks to the availabil-ity of larger amounts of different data such as implicit user feedback, contextual information, or social network interac-tion data. Explicit ratings are not the only or even the best kind of feedback we can get from our users. As already mentioned, explicit feedback is noisy. Another issue with ratings is that they do not represent a linear but rather an ordinal scale. Most traditional methods wrongly interpret ratings as be-ing linear, for example by computing averages. This issue, however, has been addressed by some recent methods such as OrdRec [70] deal with this issue.
 In any case, in most real-world situations, implicit and bi-nary feedback is much more readily available and requires no extra effort on the user side. For instance, in a web page you will have users visiting a URL, or clicking on an ad as a positive feedback. In a music service, a user will decide to listen to a song. Or in a movie service, like Netflix, you will have users deciding to watch a title as an indication that the user liked the movie. That is why, besides trying to address some of the issues with explicit ratings, there have been many recent approaches that focus on the use of the more reliable and readily available implicit feedback . Bayesian Personalized Ranking (BPR) [51], for example, uses implicit feedback to compute a personalized ranking. Implicit and explicit feedback can be combined in different ways [44]. Even the SVD++ approach explained in Sec-tion 2.1 and used during the prize can combine explicit and implicit feedback. Another way is to use logistic ordinal regression [45]. Matchbox, a Bayesian approach [62], also offers a framework to integrate different kinds of feedback such as ordinal ratings or implicit like/don X  X  like preferences. The traditional pointwise approach to learning to rank de-scribed in Section 3.3 treats ranking as a simple binary clas-sification problem where the only input are positive and neg-ative examples. Typical models used in this context include Logistic Regression, Support Vector Machines, or Gradient Boosted Decision Trees.
 There is a growing research effort in finding better approaches to ranking. The pairwise approach to ranking, for instance, optimizes a loss function defined on pairwise preferences from the user. The goal is to minimize the number of inver-sions in the resulting ranking. Once we have reformulated the problem this way, we can transform it back into the pre-vious binary classification problem. Examples of such an approach are RankSVM [17], RankBoost [21], or RankNet [14].
 We can also try to directly optimize the ranking of the whole list by using a listwise approach. RankCosine [66], for example, uses similarity between the ranking list and the ground truth as a loss function. ListNet [16] uses KL-divergence as loss function by defining a probability distri-bution. RankALS [63] is a recent approach that defines an objective function that directly includes the ranking opti-mization and then uses Alternating Least Squares (ALS) for optimizing.
 Whatever ranking approach we use, we need to use rank-specific information retrieval metrics to measure the perfor-mance of the model. Some of those metrics include Mean Average Precision (MAP), Normalized Discounted Cumula-tive Gain (NDCG), Mean Reciprocal Rank (MRR), or Frac-tion of Concordant Pairs (FCP). What we would ideally like to do is to directly optimize those same metrics. However, it is hard to optimize machine-learned models directly on these measures since they are not differentiable and stan-dard methods such as gradient descent or ALS cannot be directly applied.
 In order to optimize those metrics, some methods find a smoothed version of the objective function to run Gradient Descent. CLiMF optimizes MRR [60], and TFMAP [59], optimizes MAP in a similar way. AdaRank [68] uses boost-ing to optimize NDCG. Another method to optimize NDCG is NDCG-Boost [64], which optimizes expectation of NDCG over all possible permutations. SVM-MAP [69] relaxes the MAP metric by adding it to the SVM constraints. It is even possible to directly optimize the non-diferentiable IR metrics by using techniques such as Genetic Programming, Simulated Annealing [32], or even Particle Swarming [18]. Most of the work on recommender systems has traditionally focused on the two-dimensional user/item problem. But we know that in practice many other dimensions might be af-fecting the user X  X  preference. All of those other dimensions (e.g. location, or time) are referred to as context. Using con-textual variables represents having to deal with more data, and a higher dimensionality problem. However, this might prove effective for businesses [25].
 Adomavicius and Tuzhilin [2] do a thorough review of ap-proaches to contextual recommendations and categorize context-aware recommender systems (CARS) into three types: con-textual pre-filtering, where context drives data selection; contextual post-filtering, where context is used to filter rec-ommendations once they have been computed using a tra-ditional approach; and contextual modeling, where context is integrated directly into the model. An example of con-textual pre-filtering is the so-called user micro-profile, in which a single user is represented by a hierarchy of possibly overlapping contextual profiles [8]. Post-filtering methods can use traditional approaches and then apply filtering or weighting. In their experimental evaluation, Panniello et al. [43] found that the choice of a pre-filtering or post-filtering strategy depends on the particular method and sometimes a simple post-filter can outperform an elaborate pre-filtering approach.
 Although some standard approaches to recommendation could theoretically accept more dimensions, the only models to re-port results in this category are Oku et al. X  X  Context-aware Support Vector Machines (SVM) [42]. Xiong et al. present a Bayesian Probabilistic Tensor Factorization model to cap-ture the temporal evolution of online shopping preferences [67]. The authors show in their experiments that results using this third dimension in the form of a tensor does im-prove accuracy when compared to the non-temporal case. Multiverse is another multidimensional tensor factorization approach to contextual recommendations that has proved effective in different situations [31].
 Factorization Machines [50] is a novel general-purpose re-gression model that models interactions between pairs of variables and the target by using factors. Factorization Ma-chines have proved to be useful in different tasks and do-mains [52]. In particular, they can be efficiently used to model the interaction with contextual variables [53]. An-other novel approach to contextual recommendations worth mentioning is the one based on the use of Sparse Linear Method (SLIM) [39]. In the traditional formulation of the  X  X ecommender Prob-lem X , we have pairs of items and users and user feedback values for very few of those dyads. The problem is formu-lated as the finding of a utility function or model to estimate the missing values. But in cases where we have implicit feedback, the recommendation problem becomes the predic-tion of the probability a user will interact with a given item. There is a big shortcoming in using the standard recommen-dation formulation in such a setting: we don X  X  have negative feedback. All the data we have is either positive or missing. And the missing data includes both items that the user ex-plicitly chose to ignore because they were not appealing and items that would have been perfect recommendations but were never presented to the user [61].
 A way that this unbalanced class problem has been ad-dressed is to convert unlabeled examples into both a pos-itive and a negative example, each with a different weight related to the probability that a random exemplar is posi-tive or negative [19]. Another solution is to binarize the im-plicit feedback values: any feedback value greater than zero means positive preference, while any value equal to zero is converted to no preference [28]. A greater value in the im-plicit feedback value is used to measure the  X  X onfidence X  in the fact the user liked the item.
 In many practical situations, though, we have more informa-tion than the simple binary implicit feedback from the user. In particular, we might be able to know whether items not selected by the user were actually shown. This adds very valuable information, but slightly complicates the formula-tion of our recommendation problem. We now have three different kinds of values for items: positive, presented but not chosen, and not presented. This issue has been recently addressed by the so-called Collaborative Competitive Filter-ing (CCF) approach [71]. The goal of CCF is to model not only the collaboration between similar users and items, but also the competition of items for user attention.
 Another important issue related to how items are presented is the so-called position bias: An item that is presented in the first position of a list has many more possibilities to be chosen than one that is further down [49]. One of the factors that has contributed the most to the re-cent availability of large streams of data is the explosion of social networks. Recommender systems have also jumped onto this new source of data [37]. Most of the initial ap-proaches to social recommendation 4 relied on the so-called trust-based model in which the trust (or influence) of oth-ers is transmitted through the social network connections [41; 7]. It is still unclear whether users prefer recommen-dations from friends to those coming from other users. In a recent study [12], the authors found that the selection of
It is important to note that the term  X  X ocial recommenda-tion X  was originally used to describe collaborative filtering approaches [10; 58] users where the recommendation came from did not make much difference, except if the recipients of the recommenda-tion were made aware of it. In any case, it seems clear that at the very least social trust can be used as a way to gen-erate explanations and support that have a positive impact on the user.
 There are other uses of social information. For instance, so-cial network data can be an efficient way to deal with user or item cold-start. Social information can, for instance, be used to select the most informative and relevant users or items [36]. And speaking of selecting users, some recent meth-ods propose using social information to select experts [57] in a similar way as they can also be selected in collaborative filtering settings [5].
 Social-based recommendations can also be combined with the more traditional content-based or collaborative filtering approaches [29]. As a matter of fact, social network infor-mation can be efficiently included in a pure collaborative filtering setting by, for example, including it in the matrix factorization objective function [40; 72]. The Netflix Prize abstracted the recommendation problem to a proxy and simplified question of predicting ratings. But it is clear that the Netflix Prize objective, accurate predic-tion of a movie X  X  rating, is just one of the many components of an effective recommendation system. We also need to take into account factors such as context, popularity, inter-est, evidence, novelty, diversity, or freshness. Supporting all the different contexts in which we want to make recommen-dations requires a range of algorithms and different kinds of data.
 Recommender systems need to optimize the probability a member chooses an item and enjoys it enough to come back to the service. In order to do so, we should employ all the data that is available: from user ratings and interactions, to content metadata. More data availability enables bet-ter results. But in order to get those results, we need to have optimized approaches, appropriate metrics and rapid experimentation.
 This availability of more and different sources of data has opened up new research avenues. As personalization algo-rithms keep improving, so does the experience of the users that use these systems. But the recommendation problem is far from solved. There are still many unexplored opportuni-ties and lessons to be learned. Our team of researchers and engineers at Netflix do so every day. Make sure to visit our jobs page 5 if you are interested in joining us on this pursuit. [1] G. Adomavicius and A. Tuzhilin. Toward the next http://jobs.netflix.com [2] G. Adomavicius and A. Tuzhilin. Recommender Sys-[3] R. Agrawal and R. Srikant. Fast algorithms for mining [4] X. Amatriain, A. Jaimes, N. Oliver, and J. M. Pu-[5] X. Amatriain, N. Lathia, J. M. Pujol, H. Kwak, and [6] X. Amatriain, J. M. Pujol, and N. Oliver. I Like It... I [7] R. Andersen, C. Borgs, J. Chayes, U. Feige, A. Flax-[8] L. Baltrunas and X. Amatriain. Towards time-[9] M. Banko and E. Brill. Scaling to very very large cor-[10] C. Basu, H. Hirsh, and W. Cohen. Recommendation as [11] R. M. Bell and Y. Koren. Lessons from the Netflix [12] S. Bourke, K. McCarthy, and B. Smyth. Power to the [13] A Bouza, G Reif, A Bernstein, and H. Gall. Semtree: [14] C. Burges, T. Shaked, E. Renshaw, A. Lazier, [15] R. Burke. The adaptive web. chapter Hybrid Web Rec-[16] Z. Cao and T. Liu. Learning to rank: From pairwise [17] O. Chapelle and S. S. Keerthi. Efficient algorithms for [18] E. Diaz-Aviles, M. Georgescu, and W. Nejdl. Swarming [19] C. Elkan and K. Noto. Learning classifiers from only [20] S. Hsu et al. AIMED-A Personalized TV Recommen-[21] Y. Freund, R. Iyer, R. E. Schapire, and Y. Singer. An [22] S. Funk. Netflix update: Try this at home. [23] R. Ghani and A. Fano. Building recommender systems [24] K. Goldberg, T. Roeder, D. Gupta, and C. Perkins. [25] M. Gorgoglione, U. Panniello, and A. Tuzhilin. The [26] A. Halevy, P. Norvig, and F. Pereira. The Unreason-[27] J. L. Herlocker, J. A. Konstan, L. G. Terveen, and J. T. [28] Yifan Hu, Y. Koren, and C. Volinsky. Collaborative [29] M. Jamali and M. Ester. Trustwalker: a random walk [30] H. Kang and S. Yoo. SVM and Collaborative Filtering-[31] A. Karatzoglou, X. Amatriain, L. Baltrunas, and [32] M. Karimzadehgan, W. Li, R. Zhang, and J. Mao. A [33] Y. Koren. Factorization meets the neighborhood: a [34] Y. Koren. Collaborative filtering with temporal dynam-[35] Y. Koren, R. Bell, and C. Volinsky. Matrix Factoriza-[36] N. N. Liu, X. Meng, C. Liu, and Q. Yang. Wisdom of [37] H. Ma, H. Yang, M.R. Lyu, and I. King. Sorec: so-[38] B. Mobasher, H. Dai, T. Luo, and M. Nakagawa. Effec-[39] X. Ning and G. Karypis. Sparse linear methods with [40] J. Noel, S. Sanner, K. Tran, P. Christen, L. Xie, E. V. [41] J. O X  X onovan and B. Smyth. Trust in recommender [42] K. Oku, S. Nakajima, J. Miyazaki, and S. Uemura. [43] U. Panniello, A. Tuzhilin, M. Gorgoglione, [44] D. Parra and X. Amatriain. Walk the Talk: Analyzing [45] D. Parra, A. Karatzoglou, X. Amatriain, and I. Yavuz. [46] M. Pazzani and D. Billsus. Content-based recommen-[47] M. J. Pazzani and D. Billsus. Learning and revising [48] I. Pil  X aszy and D. Tikk. Recommending new movies: [49] F. Radlinski, M. Kurup, and T. Joachims. How does [50] S. Rendle. Factorization Machines. In Proc. of 2010 [51] S. Rendle, C. Freudenthaler, Z. Gantner, and L. S. [52] S. Rendle, C. Freudenthaler, and L. S. Thieme. Factor-[53] S. Rendle, Z. Gantner, C. Freudenthaler, and [54] R. Salakhutdinov, A. Mnih, and G. E. Hinton. Re-[55] B. Sarwar, G. Karypis, J. Konstan, and J. Riedl. [56] Science. Rockin X  to the Music Genome. Science , [57] X. Sha, D. Quercia, P. Michiardi, and M. Dell X  X mico. [58] U. Shardanand and P. Maes. Social information filter-[59] Y. Shi, A. Karatzoglou, L. Baltrunas, M. Larson, [60] Y. Shi, A. Karatzoglou, L. Baltrunas, M. Larson, [61] H. Steck. Training and testing of recommender systems [62] D. H. Stern, R. Herbrich, and T. Graepel. Matchbox: [63] G. Tak  X acs and D. Tikk. Alternating least squares for [64] H. Valizadegan, R. Jin, R. Zhang, and J. Mao. Learning [65] Gui-Rong X., Chenxi L., Qiang Y., WenSi X., Hua-[66] F. Xia, T. Y. Liu, W. Wang, J.and Zhang, and H. Li. [67] L. Xiong, X. Chen, T. Huang, and J. G. Carbonell [68] J. Xu and H. Li. AdaRank: a boosting algorithm for [69] J. Xu, T. Y. Liu, M. Lu, H. Li, and W. Y. Ma. Directly [70] Koren Y and J. Sill. OrdRec: an ordinal model for pre-[71] S.H. Yang, B. Long, A.J. Smola, H. Zha, and Z. Zheng. [72] X. Yang, H. Steck, Y. Guo, and Y. Liu. On top-k rec-
