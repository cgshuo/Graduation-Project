 1. Introduction
Sequential pattern mining is an important data mining technique that can be used to help make decisions in a variety of rience. Sequential patterns can be helpful in making crucial decisions and used to predict future events.
Since sequential pattern mining is so valuable, it has been studied by many researchers. Recent studies include: (1) sequential pattern mining [36,45,26,8,41] ; (4) mining variants of sequential patterns, including maximum sequential sequential patterns [21,19,24,7] ; (5) mining sequential pattern from different sources [46]; (6) storage and querying terns from sequences with point-and interval-based events [12,11] and this work; and many others.
The seven types of researches mentioned above can be further divided into three categories: (1) mining patterns from event sequences (sequences consisting of point-and interval-based events). The point-based category includes types (1) that occur at specific time points.

The second category, the interval-based category, includes type (7). In this category, the patterns are discovered from and the starting and ending times of these interval-based events are known and stored in databases. Temporal patterns , toms occur when they catch the flu.

Hoppner [20] for once worked on interval-based event sequences, aimed at discovering temporal pattern rules rather given sequence if pattern A has already occurred. This method has been shown to be useful in time series problems. val-based; there may include both kinds of events in data sequences, for example, meteorological phenomena. Thunder and by either point-based methods or interval-based methods alone.

There has been some previous research on hybrid event sequences. For example Amo et al. proposed a constraint-based imposed. Further comparisons between MILPRIT * and our method are discussed in Section 2.3.1. 1.1. Applications of hybrid temporal patterns
Hybrid temporal patterns have many applications. In meteorology, we can use the discovered hybrid temporal patterns to most diseases are interval-based, while treatments are often point-based. Medical hybrid temporal patterns describe the relations between diseases and treatments. Without hybrid temporal pattern mining, we can only find the relations among point-based events or among interval-based events, which may lead to incorrect decisions due to incomplete knowledge.
Clearly, hybrid temporal pattern mining is useful and necessary in diverse applications. 1.2. Paper organization
Although mining hybrid temporal patterns is a significant problem, to the best of our knowledge, very few researches ral pattern mining problem are explained. In Section 3, we formally define the hybrid temporal pattern mining problem. 2. Related works
The sequential pattern mining (point-based), temporal pattern mining (interval-based), and hybrid temporal pattern to resolve them and point out the differences among them. 2.1. Sequential pattern mining introduced in this subsection. 2.1.1. GSP candidate patterns with length k , are generated by combining two promising large ( k 1)-patterns in L atively until no further patterns can be generated. 2.1.2. Prefixspan
PrefixSpan [31] uses a divide-and-conquer strategy to solve the sequential pattern mining problem. First, the database is scanned to find the frequent 1-patterns  X  L 1  X  . Second, suppose there are j L obtained. 2.1.3. SPADE
In the above-mentioned sequential pattern mining methods a horizontal database is used to store event sequences. The SPADE to check support via simple id-list joins, which is similar to set intersections.
The main steps of SPADE include: (1) generating frequent 1-patterns  X  L of h a,b,c i or h a,c,b i , it has to check if the time order of h a,b i and that of h a,b i are of the right order.
The lattice-based method is not suitable for dealing with temporal pattern mining or hybrid temporal pattern mining mining. Adopting the lattice-based approach to resolve temporal or hybrid temporal pattern mining problems will lead to bad performance. 2.2. Temporal pattern mining three possible relations between two point-based events. Possible relations among more than two events are much more complicated in temporal pattern mining than in sequential pattern mining.

To the best of our knowledge, there have been only two studies on temporal pattern mining problem: Kam and Fu X  X  meth-od (designated KF method) [22] and TPrefixSpan [38]. 2.2.1. Kam and Fu X  X  method
The KF method is an Apriori -based algorithm. Similar to Apriori and GSP , patterns are generated length by length. The phase is adjusted to handle the more complicated relations among interval-based events. The major drawback of the KF method is its ambiguity problem of pattern representations, which is discussed in detail in [38]. 2.2.2. TPrefixspan
TPrefixSpan [38] is a PrefixSpan -based approach to tackle the temporal pattern mining problem. In addition to handling has multiple possibilities when appending to the prefix. Handling the complicated relations among interval-based events makes the performance of TPrefixSpan worse than that of PrefixSpan . 2.3. Hybrid temporal pattern mining Hybrid temporal pattern mining is a method for discovering patterns in both point-and interval-based event sequences.
The relations between two hybrid temporal patterns are even more complicated than those discussed in Section 3.2, which terns or temporal patterns.
MILPRIT* [12], [11] is a constraint-based hybrid temporal pattern mining method. It allows users to specify pattern constraints with the defined regular expression. For example, in medical domain, users can discover patterns such as please refer to [12,11] .
 between them. Table 1 summarizes the comparisons.

The first difference between the two methods is that MILPRIT * allows users to specify pattern constraint but HTPM does would be a better choice than MILPRIT * . The second difference lies in that HTPM employs an embedding store technique, which makes it need only one database scan. However, the embedding store technique would lead to more memory require-tern are given in Table 1 . 2.5. Hybrid temporal pattern mining cannot be resolved by point-and interval-based methods
The hybrid temporal pattern mining problem cannot be resolved by any of the existing point-or interval-based methods pattern mining problem. Second, the hybrid temporal pattern mining problem cannot be reduced to a temporal pattern min-ing problem.

The temporal pattern mining problem cannot be reduced to a sequential pattern mining problem, even if each interval-based methods discover patterns without considering the pair-wise relation between two events transformed from the same useless patterns will be generated. For example, point-based methods may generate the following patterns: h X  a  X   X  ;  X  b  X i ; h X  b  X  ;  X  a  X   X  ;  X  b  X   X i ; h X  a  X  ; b h a  X  ; b  X  ; a ; b i X  s y  X  and h a  X  1 ; b  X  ; a 1 ; b i (the right part of s patterns will be lost.

Hybrid temporal pattern mining problems cannot be reduced to temporal pattern mining problems. Although a point-problems will occur. First, this may degrade the efficiency of the mining hybrid patterns because sequences will become some difficulties when making crucial decisions. 3. Problem definition 3.1. Notations problem.
 events.
 hybrid temporal pattern (defined in Definition 5 ).
 of et , respectively. In a hybrid temporal pattern, an inE consists of two event nodes et sented as (a + &lt;a ) and (b + &lt;b ); and event c should be simply represented as c. an event is defined and explained in Definition 4 and Example 2 .
 events. Thus, a hybrid event sequence can be represented as s the sequence id of s i and e i j  X  0 6 j 6 n i  X  is either poE or inE.

Definition 4 ( Occurrence of event). In a hybrid event sequence with ID  X  s occur  X  e i ; s j  X  X f Tp 1 ; Tp 2 ; ... g ,if e i is a poE; occur  X  e all occurrence time values for the given event in a certain hybrid event sequence. ID = 3; therefore, occur (a,2) = {[8,11]} and occur (a,3) = {[4,10],[9,2]}.

In Definitions 1 and 2, point-based events or end points of interval-based events are called event nodes. A hybrid temporal pattern is composed of n event nodes (poE, inE + regulated (in Definition 6 ) to ensure that each pattern has a unique expression.
Definition 5 ( Hybrid temporal pattern). A hybrid temporal pattern htp is represented as htp  X  X  N where N i 2f poE ; inE  X  ; inE g X  0 6 i 6 n  X  , and i 2f &lt;;  X g ;  X  0 may be multiple occurrences of an inE in a hybrid pattern, it is necessary to distinguish which two event nodes, an inE has only one occurrence in this pattern.

Definition 6 ( Arrangement of event nodes in htp ). An event node N pattern if the following conditions are satisfied: (1) Timing: if time  X  N x  X  &lt; time  X  N y  X  , where time ( N ) is the occurrence time of N . (2) Alphabet: if time  X  N x  X  X  time  X  N y  X  , but the event name of N (3) Event node type: if criteria 1 and 2 are tied, but one of the following holds: (a) N (4) Occurrence mark: if the above criteria are tied, but num  X  N in detail.

Example 3 ( Hybrid temporalpatterns). A hybrid temporal pattern htp during [3,5]; (b) at time 3; (a + &lt;a ) during [3,9]; and (a htp 1 =(a +0 =a +1 =b + =b&lt;a +2 &lt;b &lt;a 0 &lt;a 1 =a 2
In htp 1 , we determine this part b &lt; a +2 &lt;b &lt;a
Furthermore, by rule 3 we assign b + = b. Finally, according to rule 4, we derive a in Fig. 2 is 5, not 9.

Now that we understand the formal expression of a hybrid temporal pattern, we explain how to recognize a hybrid tem-
Definition 7 ( Occurrence of pattern). The occurrence of a hybrid temporal pattern htp denoted as occur  X  htp i ; s j  X  X f ot 1 ; ot 2 ; ... g , where each ot k event nodes of htp i in s j . occur  X  htp i ; s j  X  returns all occurrences of htp support htp i , otherwise, we say that s j supports htp i
Example 4 ( Occurrence of pattern ). Suppose we are given four hybrid temporal patterns: htp htp 4  X  X  a  X  &lt; b  X  &lt; a &lt; b  X  ; htp 5  X  X  a  X   X  b  X  &lt; a &lt; b  X  . s database D in Table 2 . According to Definition 7 , occur  X  htp  X  htp 4 ; s 1  X  X f X  5 ; 6 ; 10 ; 12  X g , occur  X  htp 5 ; s 1  X  X  / . Therefore, s as htp 2 INs 1 ; htp 3 INs 1 ; htp 4 INs 1 , and htp 5 INs Eq. (1).
 where j D j is the number of sequences in D .

Given a threshold, min _ sup , and a database D , a hybrid temporal pattern htp than min _ sup . 3.2. Temporal relations in hybrid domain
Since hybrid temporal pattern mining model can handle not only purely interval-based events and purely point-based or interval-based) in hybrid event sequences. Using the proposed hybrid model, we can not only handle the two existing in pure point-or pure interval-based model.
 fined in this paper are also different: they are  X  X  X  + &lt;X &lt;Y in order to distinguish them from temporal relations among interval-based events. In hybrid temporal pattern mining, 16 temporal relations, previously handled by temporal pattern mining and sequential pattern mining methods, are handled. based event B. 4. Mining hybrid temporal patterns 4.1. Algorithm HTPM
We design a new algorithm, HTPM (Hybrid Temporal Pattern Mining), to address the problem of hybrid temporal pattern mining. HTPM discovers patterns of point-based events, interval-based events, or both. The entire HTPM process requires  X  k P 2  X  . Before stepping into HTPM , we give some definitions related to this mining method.
Definition 9 ( Subpattern ). Given two hybrid temporal patterns a  X  X  N
N 2 0  X  n 1  X  N 0 n  X  , where n &gt; m ; a is called a subpattern of b iff we can find m node indexes (the subscripts) 0 6 w 1 &lt; w 2 &lt; &lt; w m 6 n for m event nodes in b such that the following conditions are satisfied. (1) N i and N 0 w (2) N i and N 0 w (3) If N x and N y are inE + and inE in a , respectively, and the occurrence mark of N (4) i  X  Small  X  0 w last occurring event of b is a poE or an inE in b with the maximum index among all poEs and inE The prefix ( k 2)-subpattern of b can be obtained from deleting the last two occurring events. Method: Call HTPM ( D , min _ sup ) Input: D : Hybrid event sequence database; min _ sup : Support threshold given by the user Output: FPS : The set of all frequent hybrid temporal patterns Procedure HTPM ( D, min _ sup){ } scans database D once, and obtains L 1  X f X  a  X  &lt; a  X  ;  X  b
The occurrence record of p i in D consists of occur  X  p i occurrence records for patterns with length P 2 are listed in Figs. 3 and 4 .

After generating L 1 , GenLk joins the ORs of two ( k 1)-events hybrid temporal patterns to obtain one or more patterns with length k . When generating L 2 ; GenLk joins all pairs of patterns (including self-join) in L the following pairs:  X  X  a  X  &lt; a  X  ;  X  a  X  &lt; a  X  X  ;  X  X  a  X  &lt; a  X  ;  X  b ((c), (c)) from Table 6 . When generating L k  X  k &gt; 2  X  , GenLk joins the ORs of two patterns in L of subroutine GenLk is shown below.

Subroutine: Call GenLk ( L ( k 1) , OR ( k 1) , min _ sup Input: L ( k 1) :( k 1)-event hybrid temporal pattern set; patterns in L ( k 1) ; min _ sup : Support threshold given by the user
Output: L k : k -event hybrid temporal pattern set; OR k : Occurrence records for all Procedure GenLk ( L ( k 1) , OR ( k 1) , min _ sup ) { }
Example 5 ( Generate L 2 from L 1 ). In Table 6 , if we join  X  a  X  &lt; a  X  and (c), we obtain the following patterns:  X  a  X   X  c &lt; a  X  are frequent.

Table 2 . GenLk joins only the pair  X  b  X   X  c &lt; a  X  &lt; a  X  b  X  and  X  b terns are  X  b  X  &lt; b  X  and (c), and the prefix 2-events subpattern of these patterns is  X  b share the same prefix 2-events subpattern. GenLk then joins  X  b pattern  X  b  X   X  c &lt; a  X   X  c &lt; a  X  b  X  .
 in Fig. 5 .

In GenLk , before calling the subroutine JoinOR to join ORs of patterns p event nodes for the common prefix part in patterns p a and p sequence alignment is that in ORAlign three additional things need to be considered: (1) the comparing event nodes must be of the common prefix part; (2) the time order in ORs p inition 6 for patterns p a and p b . The pseudo code for ORAlign () is shown below. Subroutine: Call ORAlign (p a , t a ,p b , t b )
Input: p a ,p b : two ( k 1)-patterns; t a : one occurrence record for a certain sid in p rence record for the same sid to t a in p b . OR .

Output: p c : a candidate k -pattern joined from p a and p from t a and t b .

Procedure ORAlign (p a , t a ,p b , t b ) { } as follows: 4.2. The correctness and completeness of HTPM The time complexity and memory usage for HTPM can be referred to Appendix B. The correctness and completeness of HTPM are proven below: Lemma 1 (Correctness of HTPM ). The hybrid temporal patterns obtained by the HTPM algorithm are frequent. Proof. The algorithm outputs a pattern only after its support has been examined and found satisfactory. h Lemma 2 (Completeness of HTPM ). The HTPM algorithm can find every frequent hybrid temporal k-pattern. that htp can be found from L k . Since htp is frequent, all its subpatterns are frequent. Thus, we can find a pair p patterns of htp )in L k that shares the same prefix ( k 1)-events subpattern. After joining p that it is frequent. h 4.3. Discussion of HTPM
Similar to sequential mining methods such as GSP , PrefixSpan , and SPADE , HTPM generates patterns based on the up the mining process.

The major difference between HTPM and GSP is that HTPM generates patterns by maintaining an OR set for each frequent subpatterns from a hybrid temporal pattern with four events  X  a  X  &lt; b the pruning phase is to avoid support computations for non-necessary candidate patterns. Since the pattern supports are counted in the OR joining process, there is no need to add a pruning phase to HTPM . two ( k 1)-patterns. For example, joining (a + &lt;a &lt;b terns, e.g., (a + &lt;a &lt;d + &lt;d &lt;b + &lt;b ), (a (a &lt;a &lt;d + &lt;b + &lt;b &lt;d ), and (a + &lt;a &lt;b erates candidate patterns by joining ORs instead of joining patterns.

The pattern generation process in HTPM is greatly different from the one adopted in PrefixSpan and TPrefixSpan . HTPM
Span , the pattern generation process is not so easy. For example, appending event (d obtain 13 candidate k -patterns. Appending event (d + &lt;d ) to pattern (a only the promising candidate patterns, which really occur in the sequence database. 5. Experiments uate the effectiveness of hybrid temporal pattern mining. 5.1. Performance evaluation
In our comparison of the HTPM performance with the existing methods of mining sequential patterns (point-based), Pre-guage and tested on a Pentium IV 3.0GHz Windows XP system with 2GB of main memory and JVM (J2RE 1.4.2) as the Java execution environment.

The performance evaluation experiments were conducted using synthetic data sets, which were generated separately for sequential pattern mining methods and temporal pattern mining methods. Note that since the two mining methods have non-constraint-based hybrid temporal pattern mining methods, we could not compare HTPM  X  X  performance with other algo-rithms for hybrid event sequences.
 5.1.1. Data generation The synthetic data sets in the experiments were generated using the synthetic data generator designed by Agrawal and part, the data generator had to be modified to generate interval-based event sequences. ator needs some modifications. We modified the data generator as follows: i.e., the number of events in a sequence, is determined by drawing a value from a Poisson distribution with mean CT . each event, we first randomly determine its type, and then determine its length by drawing a value from a Normal distribution.
 for interval-based event sequence database is the same as that in [38]. 5.1.2. Discovering patterns from point-based event sequences First, we examined the execution times of the above-mentioned algorithms, and then tested their scalabilities. Some parameters in the execution time experiments were fixed: j T j X  2 : 5 ; N data, too many patterns are generated with a small minimum support. The results are summarized in Fig. 7 .
PrefixSpan ) for pattern generation in sequences of pure point-based events, especially when sequence length or pattern is satisfactory in terms of discovering traditional point-based sequential patterns.
The second part of this experiment was an examination of HTPM  X  X  scalability on sequences of point-based events. Again, the flatness of the slopes of these lines in Fig. 8 . 5.1.3. Discovering patterns from interval-based event sequences Besides point-based event sequences, HTPM can also discover frequent patterns from sequences of interval-based events.
We compare this process with that of a temporal pattern mining algorithm TPrefixSpan [38]. The execution times and sca-experimental results are shown in Figs. 9 and 10 .
 methods generated frequent k -patterns from frequent patterns with length ( k 1), they differed when growing patterns.
HTPM generates frequent k -patterns directly by joining the occurrence records of L to generate a large candidate set in each phase, it performs better than TPrefixSpan. projection step takes much longer time, especially when patterns are long. On the contrary, HTPM generates patterns by min _ sup is low. 5.2. Real case analyses events, we can say that stock price data sequences are hybrid event sequences. For a stock price mining scenario, we data downloaded from Yahoo-Finance (http://www.finance.yahoo.com/).
 (AAPL); Adobe Systems Inc. (ADBE); Internal Business Machines Corp. (IBM); Microsoft Corp. (MSFT); NEC Corp. (NIPNY); and the Nasdaq Composite Index (NASDAQ). Mr. King wants to know when a stock price will continue to increase, when ing to the stock event types listed in Table 11 . There are 23 event types all listed in Table 12 .
We drew four attributes: firm, period, day, and price, from the raw data downloaded from Yahoo-Finance ( http://finan-2007. Both data sets were preprocessed into the aforementioned four columns. Based upon the different period lengths, quences, to obtain four preprocessed data sets: DS m train sets into twelve sets: hDS m train ; hDS m test ; hDS s train "" , ;; , and " ; . The last four data sets consist of only 6 point-based event types, type . Let R Train be the set of patterns discovered from the training set, R Then, we define the average predicting power ( Avg _ PP )of R
G set. Avg _ PP  X  R Train  X  is computed by averaging the predictive accuracy of each group, Avg _ PA  X  G based on the ( k 1)-prefix of p. Avg _ PA  X  G i  X  is computed by averaging the PA (p) for each p in G terns has a higher Avg _ PP than another set, this pattern set could provide a higher predicting power. in some Avg _ PA  X  G i  X  s of 0, and makes Avg _ PP low. the comparison results for hybrid temporal patterns and temporal patterns.
 temporal patterns. The improvement, however, does not seem very significant. This may be because there were too few an even greater degree if the data set contained more point-based events. 6. Conclusion
Therefore, we develop a new algorithm, HTPM , for discovering hybrid temporal patterns from hybrid event sequences. To in real cases show that the predicting power of the hybrid temporal patterns is better than that of previous patterns. poral patterns. Second, we extend the problem of mining hybrid temporal patterns to other types of computational models multiple-level hybrid patterns can be discovered from hybrid event data.
 Appendix A. Running HTPM in D
L 1 , as shown in Table 6 , is obtained by scanning D (Table 2 ) once. From L ( X  X &lt; X  or  X  X = X ). From L 2 , GenLk joins the pairs with the same prefix 1-event subpattern. For example, in L the following pairs should be joined: ((a +0 &lt;a +1 &lt;a ((a + =c&lt;a ), (a + =c&lt;a )), ((b + &lt;a + &lt;a =b ), (b (b + &lt;c&lt;b )), ((b + =c&lt;b ), (b + =c&lt;b )), ((b + =c&lt;b ), (b pair. The results from joining the above-mentioned pairs are as follows: (b (c &lt; a + =c&lt;a ), and (b + =c&lt;c&lt;b ), as shown in Fig. 4 . From L (b
L +0 &lt;a +1 &lt;a -0 &lt;a -1 ) (b + &lt;a + &lt;a -=b -) (a + =c&lt;a -) (c&lt;a + &lt;a -) (b + =c&lt;b -) + &lt;c&lt;b -) Appendix B. Time complexity of HTPM sequence; and K the length of the longest pattern. The following is an informal description about the time complexity analysis.
 hybrid patterns along with their ORs. In iteration k of the second part, where 1 cords generated in the entire process.
 most O ( n s ). Therefore, the time needed to find L 1 and build ORs is O ( n s ).
In iteration k in the second part, we build L k by joining the ORs of L terns, we only join the ORs in the same sequence. In other words, if we want to join the ORs of two patterns (a obtained by inserting the ORs of 1-pattern into the ORs of ( k 1)-patterns.
 quence is no more than s . To generate L 2 , we have to join the ORs of L
References
