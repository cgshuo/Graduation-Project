 Partitioning large graphs is difficult, especially when performed in the limited models of computation afforded to modern large scale computing systems. In this work we introduce restreaming graph partitioning and develop algorithms that scale similarly to stream-ing partitioning algorithms yet empirically perform as well as fully offline algorithms. In streaming partitioning, graphs are partitioned serially in a single pass. Restreaming partitioning is motivated by scenarios where approximately the same dataset is routinely streamed, making it possible to transform streaming partitioning algorithms into an iterative procedure.

This combination of simplicity and powerful performance allows restreaming algorithms to be easily adapted to efficiently tackle more challenging partitioning objectives. In particular, we consider the problem of stratified graph partitioning , where each of many node attribute strata are balanced simultaneously. As such, strati-fied partitioning is well suited for the study of network effects on social networks, where it is desirable to isolate disjoint dense sub-graphs with representative user demographics. To demonstrate, we partition a large social network such that each partition exhibits the same degree distribution in the original graph  X  a novel achieve-ment for non-regular graphs.

As part of our results, we also observe a fundamental difference in the ease with which social graphs are partitioned when com-pared to web graphs. Namely, the modular structure of web graphs appears to motivate full offline optimization, whereas the locally dense structure of social graphs precludes significant gains from global manipulations.
 Categories and Subject Descriptors: G.2.2 [ Mathematics of Com-puting ]: Discrete Mathematics X  Graph Theory, Graph Algorithms Keywords: Graph clustering, social networks, balanced partition-ing, stratified partitioning, multi-constraint balance.
The tremendous scale of modern graph datasets has rapidly in-creased the demand for efficient algorithms for graph analysis. With the World Wide Web featuring over a trillion URLs and online so-cial networks such as Facebook featuring more than a billion active users, it is becoming increasingly difficult to perform even the sim-plest graph computations.

The tractability of large-scale graph computations often hinges upon the ability to efficiently partition a graph for distributed com-putation. The scale of this partitioning varies depending on the domain, but the lesson is the same: partitioning massive graphs for distributed computation can greatly decrease both network commu-nication and runtime [24], while even in-memory computations can benefit from partitioned graph arrangements [14].

But partitioning large graphs is difficult, especially within mod-ern limited models of large-scale computation. Responding to this, the goal of streaming graph partitioning is to partition the node set of a graph into k balanced disjoint subsets by serially examining only individual nodes and their local adjacency list. Importantly, a streaming graph partition algorithm is forced to make a perma-nent partition assignment the very first (and only) time it examines each node, as opposed to allowing the partitioning to come from post-processing, as in the semi-streaming model of computation [2]. The motivation for streaming graph partitioning is that often times the distributed systems performing graph computations are  X  X nyways X  required to load a graph from a datastore, and one might as well execute this loading process  X  streaming the graph to the computation system  X  in an intelligent manner.

We introduce restreaming graph partitioning , which is motivated by situations where the same graph  X  or approximately the same graph  X  can be expected to be repeatedly streamed on a regular basis. After all, if a graph is going to be reloaded from a datas-tore with any regularity, streaming graph partitioning is making it unnecessarily difficult for itself by starting over from scratch with each stream. Instead, restreaming graph partitioning retains node assignments across streams, allowing subsequent streams to pro-duce partitionings with fewer cut edges.

In fact restreaming can produce partitions of such quality and with such modest memory requirement that restreaming graph par-titioning merits serious consideration as an efficient iterative stream-ing algorithm well outside the motivating  X  X ata loading X  context. Surprisingly, we find that after only a handful of restreams, our restreaming graph partition algorithms converge upon graph parti-tions competitive with or even superior to a fully offline partitioning algorithms, METIS [11], in a number of important instances.
In particular, restreaming graph partition algorithms cut fewer edges than METIS in social graphs, though they cut more edges in web graphs. Indeed, it is well understood that social graphs and web graphs are quite different in structure [26, 6]. We posit that there is also a fundamental difference in the partitioning of web and social graphs. While the local dense structure of social graphs pre-cludes very high quality partitionings, it rewards the local greedy moves of restreaming graph partitioning. Meanwhile, the fully of-fline optimization of METIS is able to discover the extremely high quality partitions of web graphs through multi-level coarsening and non-greedy Kernighan-Lin refinement [13]. Given the increasing size and importance of social graphs, it is important to develop new lightweight algorithms specially designed with these in mind.
Towards this goal, we construct restreaming versions of the stream-ing partitioning algorithms Linear Deterministic Greedy (LDG) and FENNEL , algorithms developed in [22] and [23] respectively, both greedy heuristic approaches to partitioning. Where Linear Deter-ministic Greedy uses multiplicative weights to guarantee balance, FENNEL mimics modularity maximization [4, 19] by using regu-larization to direct a greedy assignment strategy towards balance. This regularization approach does not itself guarantee balanced par-titions, and as part of this work, we show how one can  X  X emper X  such a regularization over the course of restreams to obtain a re-streaming variation on FENNEL that can ultimately guarantee bal-ance in a way that ordinary modularity maximization can not.
Given that restreaming these highly scalable algorithms can bring them into competition with fully offline methods, we show how their scalability makes it possible to adapt towards much more so-phisticated objectives. Indeed, for certain types of distributed graph computation it can be desirable to obtain more sophisticated no-tions of balance than just the number of nodes [11]. It is straight forward to modify any of the streaming and restreaming algorithms we consider to balance any cumulative node attribute, for example the total degree of each partition, (or as in [23], the number of in-ternal edges on each partition).

But beyond simply balancing one attribute, we show that sig-nificantly more sophisticated notions of balance, similar to multi-constraint balance from high-performance computing [11], are ob-tainable. First, we show how the multiplicative weights in LDG can be modified to balance both node count and edge count at once. Moreover, we show how restreaming LDG and FENNEL can be adapted to efficiently perform stratified graph partitioning , a con-strained graph partitioning problem we introduce that aims not just to balance nodes across partitions, but also ensure that each parti-tion of the graph exhibits a balanced proportion of nodes from an arbitrary number of strata. This offers an important contribution for the study of social networks, making it possible to create dense bal-anced clusters, where each cluster contains an equal proportion of users from several age strata, countries, activity levels, and friend counts. As an important demonstration, we study degree-stratified graph partitioning , where each balanced cluster is required to ex-hibit the same degree distribution.

The social network example above addresses an important prob-lem in online social network experimentation [8]. In such experi-ments, one wishes to select treatment and control groups that are structurally isolated from each other in order to minimize spillover effects. Without stratified balance constraints, it is natural to par-tition a social graph either geographically or according to some other basis of assortativity. As a result, ordinary graph partitioning, without stratified balance, risks producing graph partitions that are highly heterogenous, none of the partitions being representative. In introducing stratified graph partitioning, we hope to contribute a highly scalable partitioning methodology useful as a stratification technique for variance reduction in network experimentation [25], and also cross validation on graphs [18].

Lastly, we discuss parallelization. A notable drawback of single-shot streaming partitioning is that it is fundamentally serial, mak-ing parallelization difficult without continuous communication be-tween parallel workers [23]. These algorithms are specifically in-tended for partitioning extremely large graphs, and we show how restreamed graph partitioning can be easily parallelized  X  commu-nicating only between stream iterations  X  at only a small cost in the final partition quality. Multi-way graph partitioning is a classical NP-hard problem. Even the two-way partitioning problem, minimum graph bisection is NP-hard [9], with the best known polynomial time approxima-tion algorithmachieving only a O ( p n log( n )) -factor approxima-tion [7] for general graphs. Similarly, semi-streaming algorithms, can guarantee weak approximation bounds for graph cuts while utilizing only O ( n polylog( n )) memory [2]. Meanwhile, a robust community of research has emerged to develop efficient algorithms that achieve good performance on real world graphs. Among ex-isting offline algorithms, we focus on the METIS package [11] for graph partitioning, and use METIS as our running basis for com-parison when comparing online to offline methods.

In this section, we review streaming graph partitioning and in-troduce restreaming graph partitioning. We show how FENNEL, a streaming algorithm previously without balance guarantees, can be  X  X empered X  to guarantee balance. We then discuss how our re-streaming framework is capable of both managing dynamic graph partitioning and efficient parallelization.
We now review the basic details of the streaming partitioning model. Let P t = { P t 1 ,...,P t k } denote a k -way partitioning of the node set at time t , where P t i is the set of nodes in partition t and P t ( u ) denotes the partition that contains node u . A stream-ing algorithm is sequentially presented a node u and its neighbors N ( u ) , and it must assign u to a partition i utilizing no more in-formation than contained in the current partitioning P t . Over the course of a stream, the time counter advances by one for each node it examines.

Since streaming graph partition algorithms make decisions based on an incomplete but increasing amount of information, the order in which data is streamed can affect performance, and worst-case orders can easily undermine the streaming approach [22, 23]. How-ever, it has generally been observed that presenting the data in ei-ther a breadth first, depth first, or in a random order does not greatly alter performance [22, 23]. Of these orders, a random ordering is the simplest to guarantee in large-scale streaming data scenarios, and so we restrict our analysis to only consider random node or-ders for simplicity. When considering restreams later on, we focus on persistent random orders.

Finding partitions that are strictly balanced, where | P i for all i and j , is rarely necessary. As a result, many partitioning al-gorithms [12, 23] include a  X  X lackness X  parameter, explicitly or im-plicitly allowing deviations from exact balance, often in exchange for superior cuts. As part of this work, we present algorithms for exact balance and also modifications for  X  X lacked X  balance.
Stanton and Kliot [22] considered a broad range of heuristics for performing streaming node assignment. Of these heuristics, the method with the best performance was  X  X inear Deterministic Greedy X  (LDG), where each node u is assigned to the partition where C i is the maximum capacity of partition i . Notice that since this examines each node but once, | P t i \ N ( u ) | will be exactly for many nodes at the start of the stream, and | P t i \ N ( u ) | likely to reflect the actual number of neighbors a node shares with a partition near the end of the stream. Single shot LDG exhibits impressive performance despite this handicap. While the original investigation of LDG was merely heuristic, subsequent work has shown that an algorithm inspired by LDG is capable of recovering a planted partitioning from a basic infinite random graph model, and also that no streaming algorithm can obtain an o ( n ) approximation with a worst-case or random stream ordering on an arbitrary graph [21].

Meanwhile, FENNEL [23], a streaming generalization of modu-larity maximization, attempts to maximize the following objective function: Notice that when =2 , the regularization becomes functionally equivalent to  X  P imization with an Erd  X  os-R X nyi baseline with probability streaming greedy maximization, maximizing this objective func-tion corresponds to assigning u to the partition that maximizes the change H t i ( u )= | P t i \ N ( u ) |  X  order, this corresponds to maximizing | P t i \ N ( u ) |  X  where the first order approximation is exact for =2 . Thus the FENNEL assignment rule is: In this work we focus our analysis of FENNEL on the special case of =2 , namely streaming modularity maximization.

While the multiplicative weights of LDG enforce exact balance, the additive regularization used by FENNEL only ensures approx-imate balance. While it is straightforward to show that this assign-ment mechanism must produce exact balance for  X  &gt; d n a large  X  focuses almost entirely on balancing and leads to a very poor partitioning. Nonetheless, when run at appropriately chosen values of  X  , FENNEL performs very well on a number of real world networks, producing very nearly balanced partitions [23].
The first phase of many common multiphase modularity maxi-mization algorithms, including the Louvain method [4] and modularity-specialized label propagation [16], bear a clear similarity to FEN-NEL. The connection between regularizing label propagation and modularity maximization was also outlined by Barber and Clark [3]. By restreaming FENNEL, we show how modularity maximiza-tion also fits well within a restreaming framework.
For the distribution of very large graphs, the utility of streaming graph partitioning derives from the routine need to stream graph datasets, and when performing this streaming it can be worthwhile to attempt to partition the dataset with some intelligent assignment mechanism. It is equally routine, however, that the streaming pro-cess is repeated periodically, and often frequently.

For example, a social networking service might be interested in a streaming partitioning algorithm because it loads a graph from memory to dedicated ranking servers on a daily basis [24]. How-ever, if a streaming algorithm sees nearly the same data routinely, it is clearly worth considering what information can be retained be-tween streams so as to improve performance.

We thus introduce the concept of restreaming graph partition-ing, and in particular we present restreaming versions of LDG and FENNEL, the two single-shot streaming graph partitioning algo-rithms presented earlier. In our restreaming framework, subsequent streams of LDG and FENNEL have access to the result of previous streams. We consider a graph as being streamed in a random but persistent order each time it is restreamed, and we use persistent (de-randomized) tie breaking across restreams.
In the case of restreaming LDG, P t i records the most recent par-tition assignment, either from the previous stream or, when present, from the current stream. Additionally, let x t i record the number of nodes assigned to i during the current stream. The assignment rule for restreaming LDG remains functionally similar to (1), Since each x t i increases over each stream from 0 to C i titioning achieves exact balance at the end of each stream. Con-ceptually, restreaming LDG resembles a repeated shooting method, where each time the partitions are built up anew, with the benefit of the probable assignments for nodes not yet seen in the current stream. Since LDG matches the constraints C i after each restream, it is ideal for applications with hard constraints, otherwise these hard constraints can be loosened by setting  X  i C i &gt;n
FENNEL can be restreamed without any change to its objective function. Whereas restreaming LDG rebuilds the partitioning each time, and thus involves implicit notions of the beginning and end of a stream, FENNEL X  X  objective function can be computed without knowing its location in the stream. On the other hand, this property of FENNEL prevents it from reaching exact balance after a single stream. In the restreaming scenario, however, we show that it is possible to achieve exact balance using FENNEL by  X  X empering X  the solution towards increasingly balanced partitions over repeated restreams. Namely, with each restream we run FENNEL with a larger value of parameter  X  , denoting the value of  X  during stream s as  X  s . In this way tempering increasingly emphasizes balance, while granting time in the earlier streams to finding high quality partitions. Alternatively, had FENNEL been run with too high an initial  X  , the algorithm would have resorted to placing nodes in par-titions based solely on balance and without regard to the quality of the partitions. As noted earlier, once each node is reconsidered by a stream of FENNEL for which  X  s &gt; d n nism will necessarily return a balanced partition. We formalize this observation through the following proposition.
 stream s , | P t i | 2 { b n
P ROOF . Suppose not: then at some time  X   X  t a node u was assigned to a partition i where | P  X  i | | P  X  j | 1 for smallest partition. Since | P  X  i \ N ( u ) |  X  | P  X  i | Then: As P  X  j is the smallest partition, | P  X  j |  X  X  n
H  X  i ( u ) H  X  j ( u ) &lt; 0  X  a contradiction as u would have then been assigned to partition j .

When the maximum degree d&lt; d n quirement is relaxed to  X  s &gt;d . It X  X  also clear that if restreaming FENNEL finds a balanced partition for some  X  &lt; d n tempering will not change that partition.

P ROPOSITION 2. If at some time t 0 , P t 0 + j = P t 0 for all 1 ,...,n (one complete stream), | P t 0 i | 2 { b n k c , d n  X  s +1  X  s for all s then P t = P t 0 for all t&gt;t 0 .

P ROOF . We prove this by induction. Suppose no node has moved from time t 0 to some t&gt;t 0 + n , and node u in partition next node in the stream at time t +1 . Since no nodes have moved for time n , | P t +1 n Since  X  is increasing and | P t +1 at time t +1 n , and ties are broken consistently, u will also be assigned to j at time t +1 .

As we discuss later, when using tempered FENNEL to partition real world graphs we observe that the quality of the final partition-ing is relatively insensitive to the initial value of  X  0 what surprising observation that has the added benefit of removing the  X  0 selection problem present in single stream FENNEL. Mean-while, there remains a trade off between computation and perfor-mance in choosing how fast to temper, though our empirical results suggest that moderate numbers of restreams are typically sufficient.
Every node allocation/relocation in FENNEL increases its objec-tive function. As there are only a finite number of different possi-ble partitions, FENNEL will converge to a final partitioning at any fixed  X  given enough restreams, even if  X  is not tempered all the way to the bound established in Proposition 1. But since  X  theory a continuous parameter, we may be concerned that the so-lutions differ at exponentially different values of  X  . While it is not of practical importance  X  since it is always possible to make large changes in  X  when tempering  X  we establish a resolution limit of  X  , the granularity below which the partitioning solution can not change. We show that there are only polynomially many unique values of  X  for which any changes in partitioning can occur. We emphasize that this resolution limit is much finer than the amount that we choose to increase  X  by in practice, but this investigation illustrates important structures of the tempering framework.
P ROPOSITION 3. For some  X  s &gt; 0 , and a partitioning P then for any increasing sequence of L values  X  s &lt;  X  s +1  X  s + L  X   X  s + 1 n 2 on which FENNEL is repeatedly restreamed to convergence, there is at most one value of  X  s + ` , 0  X  `  X  L that the converged partitioning at  X  s + ` is different from the con-verged partitioning at  X  s + ` +1 .

P ROOF . Suppose there are two distinct pivotal  X  s + ` , denoted,  X  a and  X  b &gt;  X  a , such that at  X  a +1 and  X  b +1 FENNEL con-verges to a different partition than at  X  a and  X  b . Let a | P i \ N ( u ) | | P then be that there are partitions i , j , p and q and nodes such that for these different  X  values, nodes would switch between partitions implying a change in sign of H t a of H t b p ( v ) H t b q ( v ) giving: Notice that it must be that x a ij 6 =0 and x b pq 6 =0 . Without loss of generality assume that each x a ij &gt; 0 and x b pq &gt; 0 to be assigned to i and p respectively, it must be that a and b pq ( v ) 0 as well. Thus it can be shown that: (  X  b +1  X   X 
Note that this convergence is in theory incredibly slow. In prac-tice it is vastly more efficient to increase  X  in larger steps, and without waiting for convergence at each value of  X  . Indeed, the tempering results we present later correspond to increasing an exponential rate, from an initial  X  0 to the critical  X  FENNEL is guaranteed to be balanced.

When restreaming FENNEL, tempered or untempered, it ulti-mately converges only to one of many local maxima of its modularity-like objective function. As discussed in [10], modularity typically has many high quality local maxima, which is of great practicality if one merely needs to find high quality partitions, but also of grave concern when using modularity to discern  X  X ommunity structure X , something we are not attempting.

LDG does not have any of the same convergence guarantees. In-deed, restreaming LDG does not necessarily converge. Further-more, should it converge, the resulting partitioning would depend upon the specific node ordering: if the graph was restreamed in a different order then nodes would be very likely to move. By comparison, the convergence of FENNEL and tempered FENNEL outlined above do not depend on any persistence in the node or-der. Despite the lack of convergence guarantees, LDG performs well, returning a balanced set after each restream. This lack of con-vergence guarantee is also one of LDG X  X  strengths, enabling it to handle dynamic graphs very well.
In real world settings, large empirical graph datasets are typically not static graphs, but rather they are slowly varying in time, with their edges sets evolving gradually relative to their immense size. In such cases, the graph may be expected to change slightly between streams, and it is important to consider the ability of both restream-ing algorithms to accommodate dynamic graphs. One advantage of restreaming LDG is that it doesn X  X  require any modification: since LDG rebuilds the graph each stream there aren X  X  any restrictions on how the graph changes each time.

On the other hand, restreaming FENNEL is able to accommo-date dynamic graphs only when  X  is held fixed in a manner similar to ordinary single stream FENNEL. When FENNEL is tempered across restreams, the resulting partitioning becomes increasingly rigid, unable to adjust to dynamic changes in a graph. In this way, FENNEL is only appropriate for dynamic graphs in its untempered form, precluding situations where exact balance is important.
Despite the simple computations and manageable memory foot-print involved in LDG and FENNEL, in some settings the sheer size of the dataset being streamed may make parallelization highly desirable. Indeed, parallelizing single stream LDG and FENNEL is possible, but requires that a list of size O ( n ) on each parallel thread is kept concurrent. In contrast, restreaming LDG and FENNEL can be parallelized without any communication during a stream, in-stead relying purely on inter-stream communication; thus speeding the streaming process by a factor equal to the number of machines used. Namely, for W workers, each of which will see a unique ran-FENNEL in the following way. Each worker partitions their own nodes in their stream. Between restreams, each worker reports on their share of the partitioning and this compiled list is distributed to all workers for the next restream. For the first stream, we can ini-tialize the partitioning utilizing a hash function applied to the node indices. Notice that this puts the first stream of LDG and FENNEL at significant performance disadvantage, but interestingly, this is largely overcome by additional restream iterations.

Thus these algorithms can be parallelized without communica-tion for only a small partition quality tradeoff. Note that the paral-lelized implementation of the offline partitioning package METIS [12] also requires a similarly small quality tradeoff.
In many situations the true objective function may depend not on balancing nodes, but on balancing edges, a combination of nodes and edges or some other more complicated function. In this section, we show how our restreaming algorithms can be modified to guar-antee more general types of balance. In particular, we present a new balancing objective we call stratified graph partitioning , where an arbitrary number of node strata are each required to be balanced.
The simplicity and directness of LDG and modularity maximiza-tion allow for straightforward generalizations. Indeed, notice that we can modify restreaming LDG X  X  objective function, Equation 4, to balance the sum of the degrees of each partition. The object function can be modified as: is set to be d m tive node weights c u , and each C i = 1 possible sum split k ways. In this framework c u =1 corresponds to node balance, c u = | N ( u ) | corresponds to balancing degrees, and c u =1+ n equally important. Here c u can in fact be any arbitrary positive at-tribute calculated for each u a priori, such as the number of friends of friends on a social network, or the number of log records each node produced in the past month.

Note that when running this more general version of LDG, exact balance of the node attribute is no longer precisely guaranteed due to granularity. For example, when balancing degree and assigning a very high degree node late in a stream, that node will invariably push the sum x t i in Equation 8 over the threshold C i . Thus LDG will only balance partitions to within the maximum value of
Similarly to LDG, FENNEL can be reinterpreted as a function on the total weights of each partition, rather than just the number of nodes. The general assignment rule can then be stated simply as
The above modifications make it possible to address alternative notions of balance, which raises the important question of whether multiple balancing objectives can be obtained simultaneously. For LDG, we note that it is possible to adjust the multiplicative weights to attempt to balance multiple objectives simultaneously. Consider adjusting LDG such that u is assigned to: argmax where  X  y ` is the average value of objective ` on G ,  X  y value of ` in P t i at time t , y ` ,u is the value of ` at positive increasing functions. For example, if the argument of is ( d i 2 m n )( 2 m n d u ) where d i is the average degree of nodes in
P t i , and d u is the degree of u , then notice that the quantity is positive if and only if adding u to P t i moves the average degree of P i towards the average degree of the graph. Thus, the strict LDG multiplicative forcing term forces this assignment rule to exactly balance nodes, while the second multiplicative forcing term biases the algorithm towards edge balance. While this algorithm does not guarantee strict balance on both edges and nodes simultaneously, it does balance these well empirically.
Optimizing against multiple constraints rapidly increases the dif-ficulty of the partitioning problem. In contrast, we introduce a re-stricted problem whose goal is to balance the counts of nodes from several distinct strata. This problem arises when it is important that each individual partition resembles the demographics of a full graph. For example, in social network experiments it can be im-portant that test groups have an equal number of men and women, or have similar levels of educational attainment. If the network is assortative under these demographic traits then a good partition-ing algorithm risks producing slices that are very different demo-graphically. A particularly interesting instance of this problem is creating graph partitions that share the same degree distributions (up to integer divisibility). A node X  X  degree in the full graph is always available to the partitioning algorithm, and it commonly relates to important demographic node attributes such as age or ge-ography, making balancing degree distributions a good proxy for demographic balance.

While in many situations producing miniaturized, representative partitions is a natural goal, it is quite different from the goal, or out-put, of many graph partitioning algorithms. For example, spectral partitioning tends to produce bisections with very different degree distributions, usually with one dense connected partition containing nodes of high degree and the other with low degree nodes that were successively  X  X rimmed X  away from the first partition [20]. Colloqui-ally this tendency of spectral partitioning can be described as par-titioning a graph into a  X  X airball X  and  X  X hiskers X  [15]. For graphs that have a pronounced core-periphery structure [5], algorithms that minimize the edge cut of a partition frequently (and rightfully so) split the graph between the core and the periphery. This results in a high quality cut between partitions with very different degree distributions, and typically, very different types of nodes.
Similarly, algorithms that aim to perform community detection are frequently tested for their ability to take graphs and produce communities whose nodes are fundamentally different. Indeed, community detection algorithms frequently demonstrate their ef-fectiveness by revealing hidden node information utilizing only net-work information. In this way, community detection algorithms are frequently calibrated to create the worst possible test groups, and the partitions that least resemble the graph as a whole.
In contrast, the goal of stratified graph partitioning is to produce partitions where a node X  X  membership in a partition reveals no in-formation of that node X  X  strata. We formalize the problem as: G =( V, E ) , where nodes belong to L disjoint strata V i [ i =1 V i = V , partition the graph into k disjoint partitions such that [ k j =1 P j = V , maximizing the number of uncut edges
P C ij for all i, j , and constraints C ij .
 Setting each C ij = d | V j | ally represent the distribution of the strata in the original graph.
Despite the daunting increase in constraints, it is easy to adjust both of our simple restreaming algorithms to address this problem. For LDG this simply requires keeping additional indexing, such that a node u 2 V ` is assigned to: Likewise, one can adjust FENNEL X  X  additive regularization, Equa-tion 6, so that when assigning node u 2 V ` , each x i is also depen-dent on ` , becoming x i, ` .
 Stratified graph partitioning has an interesting intersection with METIS in the high performance computing literature. Namely, in multi-constraint graph partitioning each node has an associ-ated weight vector w u , and the partitioning aims to balance the sum of these weights for each partition [12]. The primary aim of multi-constraint graph partitioning in the context of high per-formance computing is to enable efficient parallelization of large computations by dividing meshes into partitions with similar num-ber of nodes and other attributes that affect either memory or com-putational requirements. The multi-constraint graph partitioning approach can apply to the stratified graph partitioning problem as well: simply consider a vertex of strata j as having weight 1 and w u [ i ]=0 otherwise.

However, the added generality of multi-constraint partitioning leads the METIS implementation to have a memory footprint of  X  O ( m + Ln ) , as it stores each node X  X  weight vector in memory. Meanwhile, the modified restreaming version of LDG requires only memory  X  O ( n + Lk ) . While in the high performance computing lit-erature, it may not be necessary to have large L , if the goal is to match degree distributions it is frequently desirable to have the order of  X  ( m time of METIS. For example, whereas METIS was able to partition the LiveJournal graph with 9GB of RAM, when doing 100 degree strata the memory footprint rises to 23GB. Meanwhile, the mem-ory footprint of LDG barely changes as the number of strata are increased.

Finally, there is an important difference in emphasis between multi-constraint graph partitioning and stratified graph partition-ing. While multi-constraint graph partitioning can perform strati-fied graph partitioning, it does so by balancing marginalized traits and not joint constraints. One must be careful of this distinction lest one may balance gender and degree by stacking one partition with high degree women and low degree men, and the other with high degree men and low degree women. This would not produce slices with comparable composition. Instead, one should make a Carte-sian product of the features so that each combination of features belongs to a distinct strata.

When it is important to do streaming or restreaming multi-constraint partitioning instead of stratified partitioning, we note that the frame-work of Equation 7 in Section 4.1 can be adjusted to allow multiple constraints, though we do not examine this in our results. Figure 1: Iterating the restreaming partitioning process for static LiveJournal and Orkut graphs. The left column reports results for restreaming LDG, the right column for restream-ing FENNEL. Dashed lines are METIS. Iteration zero corre-sponds to single-shot streaming implementations, though note that FENNEL does not guarantee balance until its final itera-tion due to ongoing tempering.
We now examine the performance of our restreaming partition-ing algorithms on ten empirical graphs: six social graphs and four web graphs, listed in Table 1. All our graphs were obtained from the SNAP repository [1] except for the Orkut graph [17]. Graphs were made undirected by reciprocating all arcs. Self-loops and nodes with degree zero were removed in order to aid the inter-pretability of the fraction of edges cut by a partitioning algorithm.
The densest graph we analyze here was the Orkut graph, with 3.1 million nodes and 117 million edges. The algorithms we dis-cuss scale effortlessly beyond this size, but we are not able to ana-lyze graphs larger than this in comparison to METIS  X  performing ordinary node balanced graph partitioning on Orkut in METIS al-ready requires 18 GB of RAM, making larger graphs intractable. For the Orkut graph our restreaming LDG algorithm utilizes just 200 MB of RAM for the same graph. Since the average degree of the Orkut graph is 76 , this is very nearly the expected factor of times smaller. In order to compare our results to METIS we focus our analysis on graphs up to this size.
We begin by discussing our performance for the standard node balanced partitioning problem. When evaluating single-shot stream-ing graph partitioning algorithms, it is unclear if the gap in quality between streaming and offline algorithms should be attributed to the limitations of the single-shot view of the graph or attributed to the limited local means of the algorithm. After examining the per-formance of our restreaming algorithms, it is clear that much of the gap can be attributed to the limits of the single-shot view, not to a fundamental limitation of local algorithms.

Both restreaming LDG and tempered FENNEL were effective on all the graphs. However, in examining our results, it is im-portant to distinguish between  X  X eb X  graphs, whose structure de-rives from the structure of hyperlinks on the internet, and  X  X ocial X  wikivote 7115 100762 28.32 0.867 0.775 0.685 0.775 0.822 0.764 astro-ph 18771 198050 21.10 0.623 0.439 0.413 0.438 0.535 0.372 enron 36692 183831 10.02 0.664 0.490 0.471 0.482 0.855 0.411 slashdot 77360 469180 12.12 0.821 0.730 0.673 0.686 0.711 0.693 livejournal 4846609 42851237 17.68 0.561 0.390 0.328 0.351 0.309 0.301 orkut 3072441 117185083 76.28 0.645 0.428 0.421 0.585 0.376 0.353 web-nd 325729 1090108 6.69 0.313 0.128 0.121 0.181 0.036 0.036 web-stanford 281903 1992636 14.13 0.378 0.207 0.176 0.237 0.123 0.114 web-berkstan 685230 6649470 19.41 0.341 0.203 0.188 0.283 0.117 0.111 web-google 875713 8644106 19.74 0.290 0.163 0.160 0.206 0.009 0.008 graphs, whose structures represent relationships people create be-tween each other. Indeed, there are well known differences between the structure of web and social graphs, both in their degree distri-bution, effective diameter, their clustering coefficients [26] and in their compressibility [6]. Social graphs are known to have signif-icantly higher average local clustering coefficient, indicating that the structure around individual nodes is far from divisible, while web graphs are known to compress much better than social graphs.
Consistent with these observations, web graphs have extremely high quality cuts, as seen in Table 1, with METIS dividing web-google into 40 partitions cutting fewer than 1% of the edges. In-deed, the multiple stages of METIS are very well suited to discover-ing the extremely high quality cuts of such modular graphs. Mean-while, the highly local nature of the restreaming graphs prevents them from discovering the same high quality partitioning on web graphs that METIS is able to find. On the other hand, the dense lo-cal structure of social graphs coupled with the apparent lack of the same modular organization inherent in the web is better suited to the restreaming graphs. As such, all the restreaming algorithms are competitive with METIS on the social graphs, see Figure 1. In par-ticular, restreaming FENNEL performs the best of the restreaming algorithms, out-competing METIS with 0 . 1% slack on four graphs and even METIS with 3% slack on two graphs. We emphasize that restreaming tempered FENNEL is finding exactly balanced parti-tions and using only O ( n ) memory.

Furthermore, over the course of iterating restreams, we observe that both restreaming LDG and FENNEL converge rapidly, and at times exponentially, as seen in Figure 1. This provides an advanta-geous tradeoff between computational work and the quality of the cut. An exponential convergence rate towards the local optima is consistent with the view that during each streaming pass of the al-gorithm, nodes are placed permanently in their final position with independent probability p and in a transient position with probabil-ity (1 p ) . Thus, after r restreams only (1 p ) r edges remain in a transient assignment. The details of this view are not reflected in the actual microstructure of any of the resteaming results we observe, but we believe that this observation provides a helpful in-tuition for how restreaming algorithms attempt to correct mistakes from previous iterations.

Note that all the results for FENNEL in this section are for tem-pered FENNEL, and as such, node balance is only guaranteed at the end of the final iteration, so the flat performance of tempered FENNEL over the course of the many iterations in Figure 1 hides the fact that the algorithm is maintaining the quality of the parti-tioning while moving towards balance. Indeed, for some graphs, in Figure 2: The quality of partitions as a function of the number of nodes per shard, for the LiveJournal and Orkut graphs. No-tice how the restreamed algorithms essentially match METIS. order to achieve balance, restreaming FENNEL must decrease the quality of the partitioning during the tempering process.
As a last look at node balance, we report the results of parti-tioning two large graphs, LiveJournal and Orkut, into many many partitions. In Figure 2 we observe that our restreaming algorithms match METIS in performance across the full range of partition counts. In fact, when METIS is run with 0 . 1% slack and k 200 the quality of the partitioning deteriorates rapidly, making it signif-icantly worse than the quality of LDG and FENNEL. Since tight slack was not the intended use case for METIS, we report our re-sults for METIS using 1% slack. Still, we see in Figure 2 that when Orkut is divided into 4000 partitions (of roughly 1000 nodes each), the quality decreases markedly. This deterioration in quality does not occur at 4000 partitions if the slack setting for METIS is further increased.
The FENNEL algorithm is only able to achieve high quality cuts with exact balance because restreaming allows for tempering. Fig-ure 3 displays the effect that the initial choice of  X  0 has when tem-pering FENNEL over 20 restreams to the critically stable  X  discussed in Proposition 1. Figure 3 shows that when tempering FENNEL, the final quality of the ultimate tempered partitioning is only sensitive to the choice of the initial  X  0 when it is very large, but almost entirely insensitive to the choice as long as  X  enough. Note that during a single stream, the choice of  X  have a very large impact on both the quality of the partition and the departure from balance, but this importance disappears when Figure 3: The effect of varying  X  0 when tempering, where is the initial value of  X  and  X  is increased to the critical over 20 restreams. For k =2 , 4 , 20 , 40 shards, we see that for sufficiently small  X  0 the quality of the edge cut does not depend much on the initial  X  0 from which the tempering begins. tempering. Notice also that this observation appears to apply in-dependently over the number of partitions being sought. This for-tunately removes some of the parameter complexity inherent in a single stream of FENNEL while also allowing FENNEL to achieve exact balance.
In Section 4 we developed a range of different balance con-straints that restreaming partitioning could be adopted towards. Here we report on the quality of the graph cuts obtained when restream-ing algorithms are applied towards balance constraints other than node count. A discussion of stratified graph partitioning follows.
In Figure 4, we observe the differences in edge balance and de-gree counts when running LWD under different constraints: bal-ancing nodes, balancing edges, balancing a sum of the two, or bal-ancing both via the multi-balance multiplicative weights developed in Section 4.1. When either the degree counts or the node counts are left unconstrained, the algorithms clearly utilize the unconstrained flexibility. Thus, in situations where balancing degrees is impor-tant, using a method designed to balance nodes would be a poor proxy for the original problem. Indeed, even balancing based on a linear function of nodes and degree fails to balance both. Alterna-tively, when LDG (and FENNEL, though the results are not shown) are altered to handle multiple constraints, they are able to balance both nodes and degrees for only a small cost in partition quality. The quality of the partitions is seen in Figure 4. It is clear from this figure that stronger notions of balance than just node balance are within reach using simple restreaming algorithms. We now turn our attention to stratified partitioning.
The primary goal in stratified balance is to produce partitions representative of the original degree distribution, such that the nodes of degree d i in the original graph are split equally between all the partitions. As seen in Figure 5, stratified LDG is able to produce partitions of increasing similarity at a small cost in quality. Since the strata in Figure 5 correspond to separately balancing separate contiguous degree strata, stratified graph partitioning requires that the cumulative degree distributions (CDFs) for all partitions inter-sect at all strata boundaries. While exactly matching the degree distributions of a graph would require as many strata as there are unique degrees, using only 100 strata produces very similar degree distributions, and even only 10 strata corrects for the majority of the difference. Figure 4: The tradeoffs between node balance and degree bal-ance when LiveJournal is partitioned into 40 different parti-tions utilizing several different objectives. We see that stronger notions of balance cost very little in partition quality.
Increasing the number of constraints reduces the quality of the partitioning slightly, in a manner similar to multi-constraint METIS. For a large number of strata, multi-constraint METIS and LDG pro-duce partitionings of increasingly similar quality, such that by strata on LiveJournal, METIS and LDG produce edge cuts within 1 . 5% of each other. Meanwhile, multi-constraints trials executed in METIS required significantly more memory than the corresponding single constraint trials, while stratified LDG only required mildly more time and memory than unstratified LDG. Finally we consider the results of parallelizing LDG and FEN-NEL as discussed in Section 3.5. Figure 6 shows the effect of paral-lelizing LDG and FENNEL on the LiveJournal graph, partitioning it into 40 different partitions. Note that the first stream of the par-allelized version cuts a large percentage of the graph X  X  edges, and it takes longer for these parallelized versions to approach their final quality. However, within less than 20 restreams both algorithms, whether run on 2 , 10 and 100 workers, produce partitions of qual-ity comparable to the single thread versions of LDG and FENNEL each worker respectively. Thus, for a small price in partition quality and an increase in the number of restreams, LDG and FENNEL can be effectively parallelized to many machines. The poor partition quality after the first stream shows that this parallelization strategy can not be applied to single shot streaming partitioning, and that restreaming plays an important role in enabling parallelization.
Given the enormous sizes of social and web graphs it is increas-ingly important to carefully navigate the fundamental tradeoff be-tween the quality of a graph partition and the memory and compu-tational requirements to compute it. To address this tradeoff, we in-troduce the problem of restreaming graph partitioning and develop two algorithms that iteratively partition graphs using only the same O ( n ) memory required in single pass streaming graph partition-ing. Surprisingly, our results demonstrate that these restreaming algorithms are able to close much of the distance between stream-ing graph partition algorithms and full offline graph partitioning optimization suites X  X t times even outperforming them. The com-petitiveness of these streaming graph partitions is particularly no-Figure 6: The percentage of edges cut for parallelized versions of FENNEL and LDG when partitioning LiveJournal into 40 partitions while parallelized across 2, 10 and 100 machines. No-tice that while there is a small cost associated with increasing the number of machines , it is small compared to the gains of restreaming. ticeable on social graphs. Furthermore, while restreaming graph partitioning preserves the same small memory footprint as single shot streaming algorithms, restreaming allows for true paralleliza-tion, with communication between workers only between streams.
The simplicity and effectiveness of these algorithms allows for their easy modification to a number of more complex objectives. In particular we introduce the problem of stratified graph partitioning as a way of creating partitionings where the composition of each partition resembles the composition of the graph as a whole. De-spite the significant increase in constraints in stratified graph par-titioning, simple modifications to a restreaming algorithm allows for the partitioning of a large social graph such that each parti-tion has the same degree distribution. This particular application addresses a fundamental question in the design of test groups on social graphs.
 Acknowledgements . We thank Jon Kleinberg, Isabel Kloumann, and Justin Vincent for helpful comments. This work was supported in part by NSF grants IIS-0910664 and IIS-1016099.
