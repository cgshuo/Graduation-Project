 The widely use of XML [3] in different business applications results in large vol-ume of heterogeneous data: XML documents conforming to different schemata. How to transform an XML document such that it conforms to a schema is not only theoretically interesting, but critical to a lot of applications like document classification, document integration, and information extraction.

Much work has been done to classify XML documents based on their struc-tural similarity. In [12], tree edit dist ance has been used to classify XML docu-ments for further information extraction.

Various algorithms have been proposed to compute the edit distance between two trees [13, 4, 14]. These algorithms have considered unrestricted edit opera-tions, top-down edit operations, and restricted top-down operations. Variants of these algorithms have been used in document categorization [16], approximate query of XML documents [17], XML schema extraction [15], and information extraction [12].

The work in literature that is closest to ours is [1], in which they have consid-ered the problem of finding an optimum edit script between an XML document and a DTD. Our previous work [2] can achieve the same result, but runs faster. In this paper, we present a practical algorithm that uses top-down edit opera-of the schema(grammar) and n is the size of the XML document(tree). The remainder of this paper is organized as follows. Tree representation of an XML document, normalized regular hedge grammar(NRHG) and how to convert a DTD to NRHG, and tree edit operatio ns are studied in section 2. Our main for calculating the minimum cost is shown first, and then the pseudo-code and heuristics for implementation of this algorithm are presented. The experimental results of matching algorithm are discussed in section 4, and the conclusion and future work are presented in section 5. 2.1 Tree Representation of an XML Document An XML document can be represente d as a node labeled ordered tree. Ordered means that the order among the siblings is significant, while labeled means that each node in the tree is labeled with a symbol from a predefined alphabet. For the following segment of data, the corresponding tree is illustrated as in Fig. 1.
To identify the nodes in a tree, the nodes are numbered based on post order traversal. For a tree T , and an integer i :  X  t [ i ] represents the node of T whose post-order is i ;  X  t [ i ] refers to the label of the node t [ i ] when there is no confusion;  X  T [ i ] represents the sub-tree rooted at node t [ i ];  X  F [ i ] represents the sub-forest obtained by deleting node t [ i ]fromthetree  X  p ( i ) refers to the order of the parent node of t [ i ];  X  ( i ) refers to the order of the left most child node of t [ i ];  X  n ( i ) refers to the order of the right sibling of t [ i ]; Post-order labeling of a tree and the above notations can be illustrated by Fig. 2.
 2.2 Schema, DTD and Normalized Regular Hedge Grammar DTD has been widely used to specify the schemata of XML documents. It pro-vides a simple way to specify the structure of an XML document. An XML document conforms to a DTD if it ca n be generated by the DTD. We use DTD instead of XML Schema (XSD) to specify the schema of an XML doc-ument in this paper, as DTD is simpler to handle and easier to understand than XSD.

DTD can also be viewed as a tree, with th e edges labeled with the cardinality of the elements. But a DTD may be recursive, some nodes may lead to a infinite path (it is a DAG instead of a tree in this case). Therefore, instead of working on a DTD directly, we convert it to a normalized regular hedge grammar. The notion of hedge was first proposed by Bruno Courcelle [7] to mean an ordered labeled forest. Regular hedge grammars were introduced by Murata in [8] for schema representation of XML data.

Based on the definition of regular hedge grammar in [8], a normalized regular hedge grammar (NRHG) is defined as follows: Definition 1. A NRHG is a 5-tuple (  X , V T ,V F ,P,s ) ,where: 1.  X  is a finite set of terminals, 2. V T is a finite set of tree variables, 3. V F is a finite set of forest variables, 4. P is a finite set of production rules, each of which takes one of the five forms 5. s  X  V T is the starting symbol, which defines the tree pattern that can be
The terminals are used to label the nod es (both leaf and internal) in a tree; the tree variables are grammar symbols to generate trees; and the forest variables are used to generate forests (string of tree variables).

In the above definition, normalized means that there are at most two symbols on the right hand side of each production rule, the same as the normalized in Chomsky Normal (normalized) Form. 2.3 Tree Editing Zhang proposed three types of elementary editing operations for ordered labeled 3. A cost is assigned to each of these operations and we assume that each edit operation is of unit cost in this paper.
For two trees T s and T t , the traditional tree edit distance problem is to de-termine the sequence of operations with minimum cost, which is represented as equivalent to finding a mapping from T s to T t satisfying the following properties: 1. i 1 = i 2  X  X  X  j 1 = j 2 ; 2. t s [ i 1 ]istotheleftof t s [ i 2 ]  X  X  X  t t [ j 1 ]istotheleftof t t [ j 2 ];
In certain applications, the restrict ed edit operations [12] may be more ap-propriate. For example, deleting an i nternal node may be unacceptable when the relation between the parent-child re lation must be preserved in some appli-cations. Several variants of edit operations have been studied: tree alignment, top-down distance, and recently r estricted top-down distance.

When top-down edit distance is consider ed, the insert and delete operations are restricted to the leaf level. Reflected in the mapping, a mapping between atree S and T is a top-down mapping if for each ( i 1 ,i 2 )  X  M ,thereisalso respectively. In this section, we present t he recurrence to calculate the distance between each sub-forest(tree) and each forest(tree) variable. We follow the same idea and no-tations as presented in [2]: v t  X   X  t : means that the tree t can be derived from the tree variable v t . v f  X   X  f : means that the forest f can be derived from the forest variable v f .  X  ( T t ,T s ): is the minimum cost to transform the source tree T s to the target tree T t .  X  ( v t , X  ): is the minimum cost to construct a tree t such that v t  X   X  t .  X  ( F t ,F s ): is the minimum cost to transform the source forest F s to the target forest F t .  X  ( v f , X  ): is the minimum cost to construct a forest f such that v f  X   X  f . For v t  X  V T in a NRHG, and a tree t , define: Similarly, for v f  X  V F in a NRHG, and a forest f , define: 3.1 Main Theorem We state our main theorem as: Theorem 1. For each v t  X  V T , and each sub-tree T [ i ] : [ n ( i )] ): Proof. We first show that LHS  X  RHS ,andthen RHS  X  LHS .
 LHS  X  RHS
To transform a tree T [ i ]toconformtoatreevariable v t , based on different types of rules, there are three possibilities: 1. If v t  X  x : The only tree that can be derived from the v t is x . This means that 2. If v t  X  a v f : In order to transform tree T [ i ]to v t , we can simply delete
To transform a tree F s [ i ] to conform to a tree variable v f , based on different types of rules, we have the following five possibilities: RHS  X  LHS and v t  X   X  t .

As there must be a first step in the derivation, it would be either: 1. v t  X  x  X   X  t or 2. v t  X  a v f  X   X  a f = t.
 by rule (1).

If the derivation is v t  X  a v f  X   X  a f = t . Based on the mapping M traversed, and the order for the root of t is m . There are three possibilities: 1. If there is no such j such that ( m, j )  X  M : a should be inserted as the 2. If there is no k such that ( k, i )  X  M , this means that all the nodes in T [ i ] 3. If both ( m, k 1 )and( k 2 ,i )arein M ,weknow k 2 = m and k 1 = i based on production rules, there must be a first step. It would be either: 1. v f  X  v t = t = f , 2. v f  X  v t v f  X   X  tf = f ,or 3. v f  X  v f  X   X  f.
 For the mapping from F s [ i ]to t : 1. If the root of T [ i ] appears in the mapping, it must be mapped to t (as t is 2. If the root of T [ i ] does not appear in the mapping: we have  X  ( t, F s [ i ]) =
Suppose the derivation is v f  X  v t v f  X   X  tf = f ,wehave C [ v f ,F s [ i ]] = 1. If none of the nodes in T [ i ] appears in the mapping, this means that all nodes 2. If there exists one node in T [ i ] mapped to some node in t ,then t [ i ]mustbe 3. If none of the nodes in t appears in the mapping, it means that all nodes which is covered by rule (8).

As the LHS  X  RHS and LHS  X  RHS , we conclude the proof. 3.2 Computing C [ v f ,F s [ i ]] The above recursion can be implemented using straight forward dynamic pro-gramming except that C [ v f ,F s [ i ]] may depend on itself based on rule (7) and (8). In this section, we present how to use dynamic programming to compute C [ v f ,F s [ i ]], for each v f  X  V F and each suffix forest F s [ i ]. on itself. This precludes a direct use of dynamic programming. We may use the same modification given in [9] to circumvent this problem.

The three cases that lea d to smaller cases of the problem are computed by the following formula:
The dependency graph is constructed as follows: 2. The edges are added based on one of the following rules:
There are at most O ( | V F | ) number of vertices and O ( | V F | ) number of edges in the graph. As there is no negative weight edge in this graph, we could use length from the source vertex  X  to all other vertices in the graph. We know the time needed to complete Dijkstra X  X  shortest path algorithm is O ( V log V + E ), 3.3 Algorithm Implementation Implementation of the above algorithm using dynamic programming is straight-forward, which can be illustrated by the following procedure.
 3.4 Complexity Analysis The above recursion can be completed in O ( p  X  log p  X  n ) time, where p is the size of the grammar and n is the size of the document.

To analyze the algorithm, we use t to specify the number of tree variables, f to specify the number of forest variables, and p to specify the number of production rules.

It is easy to see that the two for loops of lines 6 to 11 runs in O ( n  X  ( t + f )) times.

Consider the for loop from line 12 to line 26, there are two blocks: for loop from line 13 to line 15, and the loop from line 16 to line 26. As there are n number of nodes in the tree, we need to compute C [ v t ,T [ i ]] n  X  t times. The from line 13 to line 15 is O ( n  X  t ).

For the block from line 16 to line 26, there are n iterations of two sub-blocks: for loop from line 17 to line 18, and the while loop from line 20 to line 26. The block from line 17 to line 18 takes O ( f  X  n ) time in the worst case, but as there are at most n sub-trees, so the overall time for the block from line 17 to line 18 is O ( f  X  n ) within the for 1 loop starting from line 12. The block from line 20 to line 26 takes O ( f log f + p ) time. So the overall time for this part is O ( f  X  log f ).

As f = O ( p )and t = O ( p ) (normalized regular hedge grammar), the algorithm runs in O ( n  X  p  X  log p )time. 4.1 Prototype System Implementation A prototype system has been implemente d to compute the operations that are needed to transform an XML document with minimum cost such that it conforms to a DTD. There are four parts in our program: 1. Convert the schema to normalized regular hedge grammar: Schema in DTD 2. Convert an XML document to an orde red labeled tree: XML file is parsed 3. Use dynamic programming to calculate the distance between the leaf forests 4. The edit operations are comput ed by tracing the cost matrices. 4.2 Experimental Results Several experiments have been carried ou t to assess the correctness and efficiency of the algorithm. We have used small known XML and DTD files to show the validity of our algorithm. To test the effici ency of the algorithm, we have tested our algorithm on three sets of data.

From Fig. 4, the algorithm is relatively efficient when we compare the running time of the algorithm with the running time of parsing an XML document.
From Fig. 5, it takes linear time w.r.t the size of the XML document(the number of nodes in an XML document). The complexity of the DTD affects the performance of the algorithm: the algorithm becomes slower when the DTD has more rules and elements. In this paper, we studied the problem of approximate matching between an XML document and a schema. Three edit operations are considered: insert as a leaf, delete a leaf and replace, and each operation is of unit cost. We gave a solution to this problem by studying how an ordered labeled tree could be transformed so that it conforms to a normalized regular hedge grammar with minimum cost.
Experimental studies showed that our approach is practical as the running time is linear w.r.t the size of the XML file. It is suitable for XML document clustering and integration when schema information is available or combined with schema extraction algorithm [15].
 This work was partially supported by a Research Incentive Fund from Western Kentucky University and a RDE fund from Kentucky Science and Engineering Foundation under contract KSEF-559-RDE-006.

