 Zhaohui Wu  X  Shuiguang Deng  X  Ying Li  X  Jian Wu Abstract Dynamically composing services requires mechanisms to ensure component services compatible with each other both at all of the syntax, semantic and behavioral level. This paper focuses on the issue of behavioral compatibility in a service composition. It adopts the  X  -calculus to model service behaviors and interactions in a formal way. Based on the formalization, it proposes a method to automatically check the behavioral compatibility in a qualitative way. Furthermore, it presents an algorithm to compute the compatibility degree in a quantitative way. The algorithm is implemented in a prototype and its performance analysis is also carried out to show that it can help composing services on the fly and ensure the services compatible with each other to provide functions with newly-added values. Keywords Web service  X  Service composition  X  Behavioral compatibility  X   X  -calculus 1 Introduction A Web service is a software application that is network distributed and identified by a Uniform Resource Identifier (URI) and can be programmatically accessed through the Web. Due to Web services X  good interoperability, which stems from the use of XML-based standards and protocols to overcome platform and language dependence, Web services have been widely regarded as the next-generation distributed computing model [ 22 ]. As the standards and tools for developing, testing and deploying Web services evolve to maturity, a growing number of enterprises are rushing to encapsulate system functions, logics and processes into standard Web services. They adopt Web service technologies to design loosely-coupled and interoperable systems in a rapid and low-cost way to accelerate their response to the changeful environment [ 15 , 16 , 24 ].

In general, in order to perform a complex task or deal with a large business across enter-prises, a number of Web services are required to properly work together. For example, to accomplish a purchase in the environment of supply chain management, different services including as a seller service, a shipping service, a bank service, etc. should cooperate well with each other. Therefore, the full potential of Web services as a means to develop dynamic e-business solutions can only be realized when applications and business processes are able to integrate their complex interactions into composite services. This requirement has trig-gered the issue of Web service composition. As Web service composition has the ability to provide value-added services through composition of basic Web services, possibly offered by different enterprises, a considerable research effort has been made to promote it in both academia and industry [ 10 ].

Dynamic service composition is the process of creating new services on demand from a set of service components at run-time. It supports business agility, flexibility, and availability which are the features of critical importance in the modern business world and e-business software systems. However, the problem of dynamic service composition is a highly com-plex task. One important issue must be considered is to select proper participant services and guarantee them correctly work together, hence to avoid unexpected failure at runtime. Although many service composition methods as well as several proposals such as WS-CDL 1 and BPEL 2 have been brought forward to construct and describe the interactions among services, they concern only with the syntax or semantic compatibility among services. For example, they emphasize the number of messages and message types transferred between services should be compatible. However, the behavioral compatibility as a very important involved factor is ignored. As agreed by many researchers and practitioners, Web services should include not only the static properties, such as interfaces, message numbers and types, but also the dynamic behavior information, i.e., the specification of which message exchange sequences are supported by the service [ 1 , 4 , 5 ]. The static compatibility including the syn-tax and semantic compatibility is essential to be checked, however, to check the dynamic compatibility of service behavior brings forward a much more challenging task. Consider two services, one for online shopping and the other for customers. Suppose that they are syntactically and semantically compatible in interfaces, but improperly negotiate well in the message exchange protocol. The online shopping waits for payment before sending the product whereas the customer sticks to Cash-on-Delivery. It is obvious that the collaboration between them leads to a deadlock even they are syntactically and semantically compatible very well. Thus, the dynamic behavior of services must be taken into account in dynamic ser-vice composition. The manual checking of service compatibility would clearly be error-prone and time consuming, which in consequence cries for an approach to realize automatic and transparent checking. Moreover, in order to select a best matched service from several candi-dates to be assembled at building-time or to substitute a broken-down service in a composite service at running-time, a method is in great urgent to quantitatively measure candidates with degree of compatibility.

At present, there is some work providing significant contributions to the analysis of service behavior. However, little work has been done in the quantitative evaluation of the behavioral compatibility. Most of the work adopts a formal method such as Petri Nets, Automata and Finite State Machines to express service behavior and then utilize its theories and tools to accomplish the automatic verification. Although the methods of Petri Nets, Automata and Finite State Machines have the advantage of an intuitive illustration of service behavior, they require a much higher computational and space complexity when service behavior and interactions become complex. This paper focuses not only on automatically reasoning about the behavioral compatibility of Web services, but also on measuring the compatibility in a quantitative way. In order to automate the compatibility checking, it proposes a formal way to model the service behavior and the service interaction using  X  -calculus [ 21 ]. The main benefit of adopting  X  -calculus to formalize the behaviors and interactions of services is its expressiveness, which is competent to specify service compositions due to its compo-sitionality property. Moreover, its text mode of formalization is of advantages to describe real-size problems. Based on the formalization, the paper introduces an automatic method to check whether two services are compatible with each other. Furthermore, in order to help to select proper participant services from a set of candidates for a composition, it also proposed a method to measure the compatibility degree in a quantitative way. Using this method, a participant with best degree of compatibility can be selected to be assembled in the composi-tion. Even if some participant services become unavailable when the composition is running, the checking and computation method can guide us to dynamically select proper substitutes to guarantee the execution be successful. Thus, the work presented in this paper can help composing services on the fly and ensure the services compatible with each other to provide functions with newly-added values. Compared with the related work which is still  X  X lack or white X , the work realizes the quantitative analysis of service compatibility; and moreover, it supports automatic check of compatibility in a dynamic and context-aware way.
 The remainder of this paper is organized as follows. Section 2 introduces our motivation. Section 3 reviews related work. Section 4 provides a brief introduction to  X  -calculus and then discusses how to model the service behavior and the interaction using  X  -calculus. Section 5 presents how to automatically check whether two services are compatible with each other and then proposes an algorithm to compute the compatibility degree between two services. Section 6 describes the implementation and evaluation of the proposed approach. Finally, Sect. 7 draws the conclusion and outlines some future research activities. 2 Motivation A specific scenario of dynamic service composition is encountered when a traveler asks a travel agency for a trip arrangement. Suppose Tom wants to go abroad to attend a conference. In order to get rid of the tiresome affairs such as booking airline tickets, reserving a hotel and renting a car, Tom asks a travel agency for the whole arrangement. Once the travel agency receives Tom X  X  request, it dynamically selects related service components, such as a flight booking service, a hotel reservation service, a car rent service, an express delivery service and a credit-card payment service, according to Tom X  X  schedule and preference, and then composes these services into a composite service.

However, to accomplish the dynamic service composition for Tom is a highly complex task for the travel agency. Here, we underline only the following two sources of its complexity. Firstly, there are more than one service to provide the same functions which were developed by different organizations and use different syntaxes, semantics and behaviors with service providers X  characteristics. It requires the travel agency to understand the intended meaning of the parameters, interfaces and dynamic behaviors, to know how to establish data connections between different data structures and class hierarchies of the interface parameters, and to assemble them in such a way that they can interact well with each other. Thus, when a new service component is to be assembled, it is important for the travel agency to ensure that the new one cooperates well with others in the composition. For example, one credit-card payment service is selected from several candidates if and only if it can cooperate well with the flight booking service. Secondly, as services can be updated and disabled on the fly, it is no guarantee that a composite service can always be executed correctly. For example, the credit-card payment service selected beforehand in the composite service for Tom X  X  trip arrangement may become unavailable from time to time. In this case, the travel agency should dynamically replace the broken-down service with an available one in order to ensure that the composite service can fulfill Tom X  X  request. However, the dynamic replacement should ensure that the new one not only provides the required function but also can cooperate well with other service components in the composite service.

The above sources of complexity for dynamic service composition are attributed to one key issue, i.e., to ensure service components be compatible with each other in a service composition. This issue can be considered at three levels: syntactic, semantic and behavioral levels. The syntax level concerns message numbers, data structures and their operation mode while the semantic level concerns message content, data meaning, the operation purpose and so on. Due to the fact that there is already some significant work on service compatibility checking at the syntax and semantic levels [ 20 ], this paper focuses on the issue at the behav-ioral level that concerns service behavior, i.e., the message exchange sequences supported by services. Even if two services are compatible both at the syntax and semantic level, they still can not be assembled together due to the behavioral conflicts between them. Thus, when the travel agency assembles a new service component for the trip arrangement dynamically, it needs a mechanism to check whether the new service components are behavior-compatible with those others that are already in the composition. Furthermore, when more than one service provides the same function, the travel agency needs a method to evaluate the com-patibility quantitatively and then selects the one with the highest degree of compatibility to be assembled. 3 Related work At present, there are some existing efforts devoted to service behavioral compatibility check-ing and verification. In general, they make use of a formal method, such as a Petri-Net, Automata or a Process Algebra, to formalize service behavior and then utilize its theories and assistant tools to accomplish automatic checking and verification. In this section, we give a review on the major techniques that are most closely related to our work. (1) Petri-Net based methods
Petri-Nets, as one of several mathematical representations of discrete distributed systems, have been used in the analysis of service behavior. Martens [ 17 ] represented a Web service as a workflow module composed of a local process and a serial of interfaces, and then used Petri Nets to model workflow modules and their compositions. Based on this formalization, the behavioral compatibility between workflow modules was checked by the verification of the soundness property for the composed system. Later on, Martens et al. [ 18 ] adopted this approach to analyze behavioral compatibility between BPEL processes and implemented a tool named WOMBAT to implement automatic analysis [ 19 ]. Similar work based on Petri-Nets can be referred in [ 25 , 31 ]. These efforts made great contributions to well reasoning about service composition. However, using Petri Nets to model processes requires much higher computational and space complexities. Moreover, Petri Nets are non-polynomial for reachability and liveness problems. (2) Automata or state machines based methods
Automata and state machines are also used in the analysis of service behavior. Fu et al. [ 13 ] proposed a top-down approach based on guarded mealy automata to analyze the compo-sition of Web services. They applied model-checking techniques to verify the conversation between two services and implemented a tool for the analysis of Web service conversation [ 14 ]. This approach could effectively guarantee the correctness of Web services composition, but assumed that service links among peers were established before the interaction started. As a consequence, this approach could not be used in dynamic service composition conve-niently. Wombacher et al. [ 27 ] considered behavioral compatibility in service matchmaking. They extended finite state automata by annotations of logical expressions to model message sequences supported by a Web service, and then carried out matchmaking based on non-empty intersection of finite state automata. A tool named IPSI-PF was implemented based on UDDI to realize the automatic matchmaking approach [ 28 ]. However, this work focused on service matchmaking with service behavior not on service compatibility; and it lacked a quantitative analysis on business matchmaking. Foster et al. [ 11 ] adopted finite state machines to model Web service composition and assigned semantics to process interactions. They also implemented a tool to automatically verify Web service composition and choreography [ 12 ]. But the behaviors of services were not taken into account. (3) Process algebra based methods
A process algebra is a formal language that has notations for describing and reasoning about reactive systems. It is usually modeled by means of Labeled Transition Systems (LTS). There are several kinds of process algebras such as CCS (Calculus of Communicating Sys-tems), CSP (Communication Sequential Processes) and  X  -calculus. Bordeaux and Sala X n [ 2 ] presented an overview of the applicability of process algebras in the context of Web services. They used LTS to formalize the behavior of Web services and gave several definitions of com-patibility at different levels [ 23 ]. Thus, the compatibility checking could be automated to a large extent. However, the compatibility checking was too strict that the service substitutabil-ity was not context-aware. Brogi et al. [ 3 ] used CCS to formalize Web Service Choreography Interfaces (WSCI) and reasoned service compatibility and replaceability. For the cases that services were incompatible, they further checked whether an adaptor that mediated between them could be automatically generated. Similar work can be found in [ 30 ], but it dealt with a Web Service Choreography Description Language (WS-CDL) not WSCI. However, they both focused on a very specific choreography language and discussed the verification of compatibility in an informal way. 4 Behavior and interaction formalization The  X  -calculus is proposed by Robin [ 21 ] to describe and analyze a concurrent mobile system. In the  X  -calculus, each component of a mobile system is modeled as a process. A whole system is abstracted as a set of processes among which interactions are carried out. Processes interact with each other by sending and receiving messages over a channel that is an abstraction of the communication link between two processes. A service composition is actually a concurrent system composed of several distributed and autonomous basic services, where services interact with others by sending and receiving messages. Thus, the  X  -calculus is proper to model service behaviors and interactions. Moreover, the  X  -calculus has a series of algebraic theories such as bi-similarity and congruence, and a lot of related tools provided by many researchers to help analyzing service behavior and interaction. To introduce the  X  -calculus in detail is beyond the scope of this paper. Here some necessary parts of the  X  -calculus are introduced. Further details can be found in [ 21 ]. 4.1 The  X  -calculus: a brief introduction There are two core concepts in the  X  -calculus: processes and names. A  X  -calculus process is an entity which communicates with other processes by the use of names. A name is a collective term for existing concepts like channels, pointers, and identifiers. Each name has a scope and can be unbound (global) or bound to a specific process. The scope of a bound name can be dynamically expanded or reduced during the lifetime of the system by communicating names between processes.

Syntax: The  X  -calculus consists of an infinite set of names ranged over by a , b ,..., z , which will function as all of communication channels, variables and data values. A  X  -calculus process can be defined as one of the following forms: (1) 0-The Nil-process: an empty process, which cannot perform any action. (2) a x . P -Output prefix: the process sends out x over the channel a and then behaves like (3) a x . P -Input prefix: the process waits to read a value from the channel a ,andafter (4)  X . P -Silent prefix: the process can evolve to P without any actions. (5) P + Q -Sum: the process can enact either P or Q . (6) P | Q -Parallel composition: the process represents the combined behavior of P and Q (7) (v a ) P -Restriction: the process behaves like P but the name a is local, meaning that (8) if x = ythen P -Match: the process behaves as P if x and y are the same name,
Operational Semantics: it is used to describe the possible evolutions of a process; more precisely, it defines a transition relation P P in one step through action  X   X (where  X  is the emission of a message, the reception of a message or a  X  action). It is defined by a set of rules below, which give a precise meaning to each operator. (1) PREFIX :  X  (2) SUM : P (3) PA R : P (4) COM : P The PREFIX rule indicates that  X . P can evolve to P after performing the action  X  .The SUM and PA R rules indicate that if the condition P can evolve to P and P | Q by the action  X  , respectively. But the condition bn ( X )  X  fn ( Q ) = X  must be hold for the PA R rule, which means that the bound names in  X  must not be the free names of Q .The COM rule states that if P can evolve to P by receiving a message from the channel a while Q can evolve to Q by sending a message from the same channel, P | Q can evolve to P { u / x }| Q after an inner synchronization action (denoted as  X  ). Note that a process involving a choice can evolve following one of the processes of the choice.
Let us consider an example as shown in Fig. 1 . Suppose a server controls access to a printer and that a client wishes to use it. In the original state shown at the left in Fig. 1 only the server itself has access to the printer, represented by a channel a shared between the server and the printer; and the client has access to the server through the channel b .

The system composed by the three components, the server, client and printer, can be modeled as the following parallel composition process.
The server that sends a along b is denoted as b a . S ; the client that receives some channel along b and then uses the received channel to send data is denoted as b c . c y . C ; the printer getting data along a is denoted as a z . P . After the interactions, the whole system evolves into the state at the right in Fig. 1 . According to the COM rule, the evolvement can be formulated as follows:
The result shows that the client gets the access from the server to the printer and then uses the channel a to communicate with the printer after the interaction.

Structure congruence: it is used to identify the processes that obviously represent the same thing. (1) P | 0  X  p (2) P | Q  X  Q | P (3) P | ( Q | R )  X  ( P | Q ) | R (4) P + 0  X  p (5) P + Q  X  Q + P (6) P + ( Q + R )  X  ( P + Q ) + R 4.2 Modeling service behavior and interaction The service behavior refers to the dynamic properties of a service, which includes the actions the service can take, the states the service has and the message exchange sequence supported by the service. Before modeling service behavior and interaction with  X  -calculus, we give a service example. Notice that, here we concern only the behavior of the service while ignoring other syntax and semantic aspects. Figure 2 illustrates a vendor service with five operations Op1 , Op2 , Op3 , Op4 and Op5 . Op1 , Op4 and Op5 are one-way-type operations which get input messages named purchase order ( PO ), cash pay ( CP ) and bank transfer pay ( BTP ), respectively. The incoming message PO triggers the service to start. Op2 and Op3 are the notification-type operations, each of which sends out a message named delivery ( DEL )andRefusal( REF ), respectively. The logic of the service is described as follows: it expects to receive a PO message at the initial state. On a message PO coming, it sends out the delivery if the stock is enough; otherwise, it sends back a refusal message and ends the interaction. In the former case, it waits for receiving either a cash pay or a bank transfer message after sending out the delivery. After that, the service terminates. The behavior of the vendor service includes two aspects. From the outside of the service, it refers to the actions of receiving messages and sending messages through operations. From the inside of the service, it refers to the state transitions. The behavior of a service can be formalized as an automata A = ( S , s o , s f , T ) ,where S is the set of states, s o p is the operation triggered which is either receiving a message or emitting a message, and m is the received or emitted message on p . According to the formalization, the behavior of the vendor service can be formalized as follows.

T ={ ( A , B , Op 1 , PO ), ( B , C , Op 2 , DEL ), ( B , D , Op 3 , REF ), ( C , D , Op 4 , CP ),
Using  X  -calculus to model the behavior of a service, we can define the whole service as a  X  -calculus process, in which the operations are channels used to communicate with other processes. In the de-factor standard service description language WSDL (Web Service Definition Language), there are four types of operations, i.e., one-way, request-response, solicit-response and notification.

Figure 3 shows that each type of operation can be modeled as a process expression. Notice that, an operation of the request-response type or solicit-response type can be represented by the combination of a one-way type operation and a notification type operation. Thus, we only refer two types of operations, i.e. the one-way type and the notification type, in service behavior formalization latter. According to Fig. 3 , we can model the vendor service as the following  X  -calculus process which uses the channels Op1-5 to communicate with other processes.

Given a formalization of service behavior, the following algorithm Service2Process ,which recursively invokes the method Exp ( r ) to generate the process expression, returns its corre-sponding  X  -calculus process. Its time complexity is o ( m  X  n ) where m is the total number of transitions in A and n is the number of transitions in the longest path from the initial state to the final state.

After formalizing services as  X  -calculus processes, we can model the interaction between two services as a parallel combination of these two processes. Figure 4 illustrates a scenario where one customer service interacts with the vendor service. The client service sends out a purchasing order to start the conversation with the vendor service. If a refusal message is returned, the client service terminates; otherwise, it sends out a cash pay message to the vendor service and goes to an end. Using Service2Process , we get the following  X  -calculus process for the customer service.

The interaction between the two services can be modeled as a parallel composition of the processes ( 1 )and( 2 ), which means that the interaction between the two services is the result of the communication carried out between the two processes.
 5 Compatibility checking and computing Dynamic service composition involves a building phase, i.e., assembling service components into a composite service automatically, and a running phase, i.e., executing the composite service to achieve business goals. In the first phase, it needs a mechanism to check whether a new service component to be assembled is compatible with others already in the composition. In the second phase, in order to select a service component from several candidates to replace a broken-down one in a composition dynamically, it requires an approach to measure which candidate has the best compatibility. Once the service behavior and interaction are formalized with  X  -calculus, it is possible for us to check and compute compatibility between services automatically. 5.1 Compatibility checking Considering the aforementioned scenario, the customer service is intuitively completely compatible with the vendor service. There are two different message exchange sequences between them and each of the sequences can eventually lead to an end of the communication. For the first case, after receiving a purchase order from the customer service, the vendor service emits a refusal message due to the shortage of stock and comes to an end. The customer receives the refusal message and also terminates. For the second case, after receiving a purchase order, the vendor service sends a delivery message to the customer because of enough stock and waits for a payment message before continuing. On receiving the delivery message, the customer service sends a cash-pay message, which will be accepted by the vendor service. After that, the communication terminates and leads to a successful business. Both of the two message exchange sequences indicate that each service has the ability to accept all the messages emitted by another and the communication between them can always terminate. Thus, the vendor service and the customer service are completely compatible with each other.

When we say two services are compatible, it means that there is at least one message exchange sequence, with which the communication of the two services can eventually come to an end. After both the vendor and customer services are formalized with  X  -calculus processes, the compatibility checking can be carried out formally and automatically. According to the operational semantics of  X  -calculus, we get two possible transitions of the process ( 3 ). Notice that, we label each transition step with the message transferred between the two processes.
The transition sequence ( 4 ) is in accordance with the first message exchange sequence ( PO.REF ) mentioned above, while sequence ( 5 ) is in accordance with the second one ( PO.DEL.CP ). As each transition sequence terminates at a Nil-process, it indicates that both processes can come to an end after some message receiving and sending actions. Thus, the two services are completely compatible with each other.

Consider another scenario in Fig. 5 , where a new customer service interacts with the aforementioned vendor service. The new customer service sends a purchase order and then Ven d or waits for a delivery from the vendor service. On receiving a delivery, it sends a cash pay message or a bank transfer message. The behavior of the new customer service is modeled as the  X  -calculus process ( 6 ).

In fact, the new custom service is partially compatible with the vendor service. Consider the case that the stock is not enough. In this case, the vendor sends out a refusal message to the customer. However, the customer service can only accept a delivery message at the time and is incapable of accepting the refusal message. Thus, the interaction between the two services goes to a deadlock in this case. However, the interaction between the two services can terminate normally if the stock is enough. This indicates that the two services are partially compatible. Formally, we check whether the parallel composition of the two  X  -calculus processes ( 1 )and( 6 ) can go to the Nil-process after finite communicating actions. As the transition sequence ( 7 ) shows, the parallel composition can lead to an end with two different message exchange sequences ( PO.DEL.CP and PO.DEL.BTP ). But sequence ( 8 ) leads the communication to a deadlock.

The above two scenarios show that, for two services that are compatible, there is always at least one transition sequence between them, with which both of them can terminate. Thus, we reach the following conclusion.
 Theorem 1 Let P A and P B be the  X  -calculus processes for two services A and B, respec-tively. A and B are compatible in collaboration iff: Proof (I): If two services A and B are compatible, there is at least one message exchange sequence s , with which the communication between them can eventually come to an end. Thus the parallel composition of the two  X  -calculus processes P A | P B can evolve to the Nil-process under such a transition sequence which is in accordance with the s . (II): if the condition ( 9 ) is to be held, it indicates that there is at least one transition sequence with which the communication between P A and P B can terminate. Due to the fact that a transition sequence represents a message exchange sequence, the two services end with a successful interaction under this message exchange sequence. Thus, the two services are compatible.
The theorem implies that we only need to check whether condition ( 9 ) is satisfied in order to check whether two services are compatible,. In fact, it can be done automatically using MWB (Mobility Workbench), an automated tool for manipulating and analyzing mobile concurrent systems described in  X  -calculus [ 26 ]. Figure 6 illustrates the compatibility checking for the vendor and customer services in MWB. We input the processes for the two services, and then use the command step to finish the compatibility checking automatically.

When building a composite service dynamically, service components are assembled one by one and the composite service grows gradually until the target is achieved. When a new service component is to be added, the compatibility checking method can be auto-matically invoked to determine whether it can be assembled. First, we formalize the new service component and the composition into  X  -calculus processes. Then we utilize MWB to infer whether they can evolve into a Nil-process under some transition sequence. If they can, the new service component can be assembled; otherwise, the new service should be excluded. 5.2 Compatibility computing Although the proposed compatibility checking method can help building a composite service correctly on the fly and ensure its service components compatible with each other, a compos-ite service may still fail to achieve its goal in execution as service components may become unavailable due to the inherent characteristics of the Internet such as dynamism, uncertainty and complexity. Thus, in order to enable the execution of a composition service to be suc-cessful, to find a candidate service to replace the unavailable one is important. Among the candidates that all provide the target function, the one with the highest compatibility is pre-ferred. Consider the two scenarios mentioned before. Although both the customer and new customer services are compatible with the vendor service, the first one is preferred than the other because it is more compatible with the vendor. Due to that the compatibility checking method can only determine whether services are compatible with each other in a qualita-tive way, a method to measure the compatibility degree quantitatively between services is required.

Let P A and P B be the  X  -calculus processes for two services A and B , respectively. The compatibility degree can be computed through computing the ratio of the successful transition sequences to all the transition sequences in P A | P B . A successful transition sequence is such a transition sequence that leads the parallel composition to a Nil-process. We import two that of successful transition sequences, respectively. The compatibility degree, denoted as  X ( A , B ) , between the two services A and B is calculated according to the following formula. The formula implies that 0  X   X ( A , B )  X  1.
In order to compute the compatibility degree between two services automatically, we number of ways, under which two services can interact with each other. If we can change the parallel composition P A | P B into the combination of several sub-processes using the the  X  -calculus can help us to do that. It can change a parallel-process into a sum-process equivalently. And each of the sub-processes in the sum-process represents a possible transition sequence.
 in the set L are restricted names and f i is a renaming function. Then
Considering the parallel composition in the first scenario, according to the expansion law, we transform P V | P C as follows. Note that we label each  X  transition with the message transferred between the two processes. The channels Op1 , Op2 , Op3 and Op4 are restricted channels, i.e., L ={ Op 1 , Op 2 , Op 3 , Op 4 } , because they are only used to communicate between P v and P C .
 The result of the transformation ( 11 ) has two Nil-processes and one non-Nil-process at last. Note that we must omit such a sub-process that starts with an input prefix while counting the number of transition sequences in the last sum-process. The reason is that the input prefix is a passive action, which can not trigger the sub-process to start. So the transition represented by the sub-process does not exist indeed and the sub-process  X  PO . X  DEL . Op 5 BT P . Op 4 CP should be ignored. From the messages flow labeled on each  X  transition, we get two transition sequences PO.DEL.CP and PO.REF , and both of them are successful transition sequences. Thus, we have  X ( S , C ) = 2 / 2 = 1.
 For the second scenario, we get the transformation ( 12 ), where L ={ Op 1 , Op 2 , Op 4 , Op 5 } . The last sum-process has two Nil-processes and a non-Nil-process. Thus, we get  X ( S , NC ) = 2 / 3. The non-Nil-process in ( 12 ) represents such a transition sequence, in which a REF message is sent out on channel Op3 but not accepted. This can help us to judge when the two services cannot interact successfully.
 For another example, for two  X  -calculus processes: P M = Op 1 M 1 + Op 2 M 2 and P
N = Op 1 M 1 + Op 3 M 3 , P M | P N = ( Op 1 M 1 + Op 2 M 2 ) | ( Op 1 M 1 + Op 3 M 3 ) and the transformation is as ( 13 ) shows, where L ={ Op 1 } .

In transformation ( 13 ), there are three sub-processes in the last sum-process. However, the last two sub-processes both start with an input prefix. There is only one possible transition sequence in the composition. Thus, we get  X ( M , N ) = 1 / 1 = 1.

According to the above analysis, we propose the following algorithm CDC to compute the compatibility degree between two services represented by  X  -calculus processes. From the third to the eighth lines, it checks the set of restricted names for the parallel composition of two processes. In fact, L = CN A  X  CN B . From the 9th to the 16th lines, it calculates  X ( from  X ( P A | P B ) . Transforming the parallel process into the sum-process with the expansion law is the key of the algorithm. For two processes P A and P B , if the number of total paths from the initial state to the final state is k and q , respectively, the time consumption on this transformation is o ( k  X  q ) . Thus the total time complexity is o ( 2  X  k  X  q ) .
Using this algorithm, we can not only get the value of compatibility degree between two services, but also know when two services are not compatible with each other if the value is less than 1. For the aforementioned second scenario, for an example, the compatibility degree returned from CDC is 0.5 and the application of CDC indicates the interaction between the vendor and the new customer service comes to a failure when the REF message occurs. If the vendor service does not emit the REF message in the execution, the new customer service can cooperate well with it although they are partially compatible with each other. Thus, the ability to find out when two services are not compatible with each other according to run-time information is very helpful in the execution of a service composition.

During the execution of a composite service, in order to select a candidate service com-ponent to replace an unavailable one dynamically, the proposed compatibility computing method can be used as follows. First, we formalize the candidate service components and the composition into  X  -calculus processes. Secondly, we invoke CDC to automatically compute the compatibility degree between each candidate service and the composition; and then select the one with the max value of compatibility degree. If the compatibility degree of the selected candidate equals to 1, the candidate can replace the unavailable one without doubt. If the value is less than 1, we check whether the interaction between the candidate and the compo-sition is correct under the current running message exchange sequence. If it is, the candidate can be used as a substitute; otherwise, it is excluded and we check the next candidate with the second maximum value in the same way. 6 Implementation and evaluation In this section, we first introduce the implementation of the proposed approach in our service composition prototype X  X artFlow; and then show the efficacy of the approach through a set of experiments. 6.1 Implementation The proposed verification and computation methods have been implemented in DartFlow [ 7 ] a sub-project of DartGrid [ 29 ]. DartFlow is a framework for service management in a grid environment and it can be divided into three sub-systems for service registration, service discovery and service composition. Its goal is to provide a convenient and efficient way to model and execute collaborative processes based on Web services across enterprises. This section introduces in brief the implementation of the proposed verification and computation methods in DartFlow.

Figure 7 illustrates the architecture of service composition in DartFlow that includes four main components: User Portal, Service Composition Composer, Service Composition Executor and Service Compatibility Checker. (1) We implement the User Portal by developing components in the Plug-in Development Environment (PDE) of Eclipse, a java-based, extensible open source development platform. Through this portal, the users can submit their requests for service composition and execution. The portal utilizes the Graphical Editor Framework (GEF) to illustrate a service composition for the users. (2) The Service Composition Composer (SCC) is responsible for composing services dynamically on receiving a user request for composition from the User Portal. It implements an automatic service composition method [ 6 ] and a service discovery method [ 8 , 9 ] based on Java JDK 1.5 and adopts the Business Process Execution Language (BPEL) as the output composition specification. (3) The Service Composition Executor (SCE) is responsible for the execution of a service composition. It is implemented based on the Web Services Invocation Framework (WSIF). (4) The Service Compatibility Checker (SCCH) is the focus of this paper which can be used by both SCC and SCE. It includes three parts: a syntax-compatibility checker, a semantic-compatibility checker and a behavioral compatibility checker. Presently, we make use of the approach proposed in [ 20 ] to realize the first two parts. The third one is based on the verification and computation methods proposed in this paper. It involves a Service-Process Translator which implements the algorithm Service2Process, a Compatibility Verifier which integrates MWB, and a Compatibility Calculator which implements the algorithm CDC. 6.2 Evaluation In order to show the efficacy of the proposed approach for service behavioral compatibility checking and computing, we carry out three sets of experiments in DartFlow. The first set is to show the time consumption of the approach. A good approach should not be too time-consuming, as the behavioral compatibility checking and computing is an additional step during dynamic service composition and execution; and so it should not affect the whole time consumption much. The second set of experiments is to find out how the parameters in the proposed algorithms influence on the time consumption. The third set is to show the usefulness of the approach for dynamic service composition and execution.

We build a simulation environment to run the experiments in DartFlow that has the advan-tage of allowing the generation of a large number of services using various settings. In order to prepare the test set for experiments, we developed a tool based on IBM XML Generator to generate a set of service description files in accordance with the OWL-S 3 process model. We run the experiments on an IBM x260 server with a 2.0-GHz Intel Xeon MP processor and 2-GB of RAM, running a RedHat Linux operating system.

In the first set of experiments, we vary the number of services registered in the service registry from 100 to 1,500 with a 100 interval. For each group of services, we keep p = 3 and t = 5, where p represents the average number of paths in a service from its initial state to its final state; and t is the average number of transitions in a path. For each experiment, we randomly select a service from the registry and carry out the behavioral compatibility computing between this service and the others left. This involves two steps: (1) to transform service behavioral models into  X  -calculus processes; and (2) to compute the compatibility ( a ) (b) degree. We evaluate the time for these two steps during the compatibility checking. Figure 8 illustrates the time consumption on transformation, computation and the sum of the two steps in each experiment. It shows that the overall time for service behavioral compatibility checking increases approximately linearly with the number of services in the service registry. This result is in accordance with our expectation, which is due to the reason that the time consumption of the algorithms Service2Process and CDC nearly equals to a constant when both the average number of paths in a service and the average number of transitions in a path are kept as constants. Thus, the time consumption in both of these two steps is only influenced by the number of services in the registry, i.e. it increases linearly with the number of services. Based on the above judgment, we draw a conclusion that even when the registry has a large number of services, the proposed approach for service behavioral compatibility computing can always finish in a short time; and thus, the additional use of the approach will not affect the whole process of dynamic service composition.

In the second set of experiments, we maintain the number of services in the registry as 500. We vary p from 3 to 15, but keep t = 5first;andthenvary t from 5 to 15, but keep p = 3. Figure 9 illustrates the impact of parameters p and t on the time consumption for behavioral compatibility computation. Figure 9 a shows that the time consumption on the computation increases more distinctly with p than that on the transformation. This is because the time complexity of the algorithm DCD is related to p 2 while that of the algorithm Service2Process is related to p . On the other hand, Figure 9 b shows the time consumption on the transformation increases with t while that on the computation keeps nearly stable. This is because the complexity of the algorithm DCD does not relate to the number of transitions while that of the algorithm Service2Process increases linearly with p .

In the third set of experiments, we measure the usefulness of the proposed approach in dynamic service composition with 1,000 services in a service registry. Given n service com-positions generated from a service composition approach, we define the usability ratio of the approach by the expression = m n  X  100%, where m is the number of service compositions that succeed in execution. In order to evaluate the usefulness of the proposed behavioral compatibility checking method, we randomly generate 100 requests for service composition on the service registry. For these requests, we carry out two groups of experiments. For the first group, the Service Composition Composer and Service Composition Executor do not interact with the behavioral compatibility checker. On the contrary, for the second group, they do. We vary the value of  X  from 0.1 to 1 with a 0.1 interval, which is the threshold value for the Behavioral Compatibility Checker (BCC) to determine whether a new service can be assembled when composing services and whether a candidate service can be selected to replace an unavailable one when a composition is running.

Figure 10 illustrates the usability ratio for the two groups of service composition. The first bar represents the usability ratio from the first group of experiments that does not make use of the BCC; and the second bar represents the usability ratio from the second group of exper-iments that utilizes BCC. It shows that the proposed behavioral compatibility checking and computing method adopted in the second group of experiment can improve the usability ratio evidently. Especially, with the threshold value growing, the improvement degree increases. If the threshold value is set to 1, the usability ratio increases by about 50% and attains to more than 90%. This is because we carry out service behavioral compatibility checking in dynamic service composition and service replacement. During the phase of building a com-position dynamically, service behavioral compatibility checking can reduce such cases much that service interactions may lead to a deadlock and result in a failed execution; and during the execution phase, it can replace the broken-down services with a compatible one so that it enables the execution continuing to a success. If the threshold value is set 1, the behavioral compatibility checking requires that two services interacted are completely compatible, i.e., they can interact well under any conditions. In this case, the execution leads to a success to a great extent. As a consequence, the usability ratio of the second group is much higher than that of the first group. To summarize, the proposed service behavioral compatibility checking and commutating approach has a great efficacy in dynamic service composition and execution. 7 Conclusion and future work Determining the compatibility between Web services plays a critical role in supporting dynamic service composition in the inherently heterogeneous Web environment. It is becom-ing well-admitted that the use of formal methods is worthy as an abstract way to deal with this issue. As a step toward the vision of dynamic composition of services on the fly, this paper has proposed a formal approach to unambiguously model service behavior and interaction in service compositions using the  X  -calculus. The resulting formal and unambiguous char-acterization of the  X  -calculus processes is of great importance for a precise understanding of services and interactions, as well as enables further research on automated verification of compatibility. Based on the formalizations, this paper has proposed a method to check service compatibility. Many existing tools can help us to do the verification automatically. After that, this paper has also given an algorithm to compute the compatibility degree. To the best of our knowledge, this is the first attempt to compute behavioral compatibility degree in quantity. Using this approach, we can not only get the value of compatibility degree, but also know when services can not interact well with each other. This is very helpful for us to dynamically compose services and bind services according to the run-time information without introduc-ing flaws into the service composition. Our implementation and evaluation have shown that the proposed approach has a good scalability and efficacy for dynamic service composition. We believe that this is a significant contribution due to the fact that the number of available services increases and the need of dynamic service composition becomes a necessity. Our future work will focus on the service behavioral adaptation in service composition through the use of the  X  -calculus.
 References Author biographies
