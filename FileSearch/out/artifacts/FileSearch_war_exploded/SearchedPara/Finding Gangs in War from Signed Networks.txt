 Given a signed network where edges are weighted in real n umber, and positive weights indicate cohesion between ver-tices and negative weights indicate opposition, we are in-terested in finding k -Oppositive Cohesive Groups ( k -OCG). Each k -OCG is a group of k subgraphs such that (1) the edges within each subgraph are dense and cohesive; and (2) the edges crossing different subgraphs are dense and opposi-tive. Finding k -OCGs is challenging since the subgraphs are often small, there are multiple k -OCGs in a large signed net-work, and many existing dense subgraph extraction methods cannot handle edges of two signs. We model k -OCG find-ing task as a quadratic optimization problem. However, the classical Proximal Gradient method is very costly since it has to use the entire adjacency matrix, which is huge on large networks. Thus, we develop FOCG, an algorithm that is two orders of magnitudes faster than the Proximal Gra-dient method. The main idea is to only search in small subgraphs and thus avoids using a major portion of the ad-jacency matrix. Our experimental results on synthetic and real data sets as well as a case study clearly demonstrate the effectiveness and efficiency of our method.
The US presidential primaries and then the US presiden-t ial election of 2016 are foreordained a hot topic in social media this year. In the process of social media analysis, to zoom in, it is interesting to find several groups of individuals in an active social network, such as Facebook and Twitter, so that within each group the individuals are of the same mind while different groups have very different opinions. We call such a data mining problem finding gangs in war .  X 
This research is supported in part by an NSERC Discovery grant, the Canada Research Chair program, and a spon-sored research grant from Huawei Technologies Co. Ltd. All opinions, findings, conclusions and recommendations in this paper are those of the authors and do not necessarily reflect the views of the funding agencies.

Technically, we assume a signed network where edges be-tween vertices are either cohesive or oppositive. A real num-ber as the weight can be associated with each edge to model the strength of the cohesion (a positive weight) or opposi-tion (a negative weight) [23]. Given a signed network, find-ing gangs in war tries to find a set of subgraphs such that within each subgraph edges are dense and cohesive, and the edges crossing different subgraphs are dense and oppositive.
Finding gangs in war is a useful exercise that enjoys many interesting application scenarios. For example, the interna-tional relationships between countries can be modeled as a signed network [1], where each vertex represents a country. Friendly countries are connected by cohesive edges and hos-tile countries are connected by oppositive edges. Finding gangs in war in this network reveals hostile groups of al-lied forces, such as the Allied and Axis power during World War II. Social opinion networks with cohesive and oppositive relationships are well studied [9], where each vertex repre-sents a user, a cohesive edge indicates a cohesive relationship and an oppositive edge represents an oppositive relationship. Finding gangs in war from such signed networks discovers multiple groups of friends with strong inter-group enmity, such as the rival groups of voters that support different po-litical leaders. Interestingly, finding gangs in war can be used in applications well beyond social networks. For exam-ple, the network of adjectives in the WordNet database [16] is also a signed network, where each vertex represents an ad-jective, the synonyms are connected by cohesive edges and the antonyms are connected by oppositive edges. From this signed network, finding gangs in war can identify groups of synonyms that are antonymous with each other, which will be further demonstrated in Section 5.6.

As to be reviewed in Section 2, there are established meth-ods for signed network partitioning, antagonistic community mining and dense subgraph finding. Can we adapt the ex-isting methods to tackle the problem of finding gangs in war from signed networks? Unfortunately, the answer is no due to the following unique challenges.

First, the  X  X angs in war X  are typically small groups and are hard to be located. Most vertices and edges in a network may not even participate in a  X  X ang in war X . Although there are many existing methods on partitioning signed networks so that each partition is relatively cohesive [3, 11], those methods cannot find needles from a haystack  X  they cannot find small groups of dense cohesive subgraphs effectively.
Second, there often exist multiple groups of  X  X angs X  in war, such as multiple groups of synonym adjectives that are antonymous group-wise. Existing signed network partition-ing methods are not able to find alternative partitionings.
Third, there may be more than two  X  X angs in war X , such as the multiple groups of voters supporting different pres-idential candidates. The existing antagonistic community mining methods are not able to detect the community con-taining more than two  X  X angs X .

Last but not least, the signed edge weights create a huge challenge for the existing dense subgraph detection methods. To the best of our knowledge, the existing dense subgraph extraction methods only consider edges of the same sign and cannot distinguish edges of two signs. The well defined concepts and algorithms for dense subgraph detection on unsigned networks [23] no longer hold in signed networks.
In this paper, we tackle the novel problem of finding gangs in war from signed networks. We make several contributions.
First, we formulate the problem of finding gangs in war as finding k -Oppositive Cohesive Groups ( k -OCG). A k -OCG is a set of k subgraphs such that each subgraph is cohesive, that is, having high intra-subgraph cohesion, and the subgraphs are oppositive to each other, that is, among the subgraphs there is a high inter-subgraph opposition. We model the problem as a constrained quadratic optimization problem.
Second, we show that the classical Proximal Gradient method (PG) [18] is very costly in finding k -OCGs on large signed networks, since it has to use the entire adjacency ma-trix. We develop a two-phase iterative method FOCG that is experimentally two orders of magnitudes faster than PG on average. The key idea is that FOCG confines the search in small subgraphs instead of the whole graph so that it only uses small sub-matrices of the adjacency matrix. Specifi-cally, FOCG iteratively conducts a locate phase and an up-date phase. The locate phase increases the intra-subgraph cohesion and inter-subgraph opposition of a subgraph by re-moving weak vertices that contribute little to the cohesion and opposition. The update phase further increases the co-hesion and opposition of the small subgraph by adding new vertices that contribute more to the objective.

Third, we report an extensive experimental study on both synthetic and real-world data sets. The results clearly show that our method is accurate, efficient and scalable in finding k -OCGs. We also conduct a case study on the adjective network sampled from the WordNet database [16], where the detected k -OCGs accurately identify significant groups of synonyms that are antonymous with each other.
To the best of our knowledge, finding k -OCGs in general is a new problem that has not been touched in literature. It is related to the problems of signed network partitioning, antagonistic community mining, and dense subgraph extrac-tion on unsigned networks.
The signed network partitioning methods partition a s igned network into several cohesive subgraphs. The parti-tioning problem is often transformed into a traditional data clustering problem and solved with classic techniques.
Spectral clustering is one of the most widely adopted techniques. Kunegis et al. [10] proposed the signed Lapla-cian matrix for signed networks. Performing classic spec-tral clustering algorithms [26] with such signed Laplacian matrix results in subgraphs with only cohesive edges. How-ever, Kunegis X  X  Laplacian matrix [10] tends to separate ver-tices connected by oppositive edges rather than group ver-tices connected by cohesive edges. To solve this problem, Zheng et al. [31] proposed the balanced normalized signed Laplacian matrix.

As an alternative approach, Doreian et al. [6] first defined the objective function for signed network partitioning as E =  X N n + (1  X   X  ) N p , where N p is the number of cohesive edges b etween subgraphs and N n is the number of oppositive edges w ithin subgraphs. Many methods attempt to partition a signed network by minimizing Doreian X  X  objective function E . For example, Traag et al. [24] used simulated annealing, and Liu et al. [11] applied the k -balanced social theory to solve a similar optimization problem.

All the signed network partitioning methods partition the entire signed network. However, in real applications, signif-icant k -OCGs always exist in small local regions of a large and sparse signed network. Such local regions are not known beforehand. Thus, partitioning the entire signed network cannot effectively find significant k -OCGs.
The antagonistic community mining methods [29, 15, 14, 3 0, 7] aim to find two cohesive communities that are antag-onistic against each other. This can be regarded as a special case where there are two  X  X angs X  in war.

There are generally two categories of such methods. The direct methods [15, 14, 7] mine antagonistic communities di-rectly from signed networks. The indirect methods [29, 30] take a transaction database of user ratings as the input and detect antagonistic communities using frequent patterns. Both the direct and indirect methods cannot be straight-forwardly extended to find more than two communities that are antagonistic against each other.
The dense subgraph finding problem on unsigned network ha s been well investigated [25, 5]. Motzkin et al. [17] formu-lated the dense subgraph seeking problem on an un-weighted graph as a quadratic optimization problem on the simplex. Pavan et al. [19] extended the method by Motzkin et al. to weighted graphs by reformulating the dense subgraph detection problem as a standard quadratic optimization (StQP) problem and solved it using the Dominant Set (DS) method [19]. According to Bul`o et al. [2], the time complex-ity of DS is O ( n 2 ) for a graph of n v ertices. Bul`o et al. [2] also proposed a more efficient method, Infection Immuniza-tion Dynamics (IID), to solve the StQP problem [19]. Both DS and IID search an entire weighted graph.
 Liu et al. [13, 12] discovered that most dense subgraphs ex-ist in local regions. By leveraging such locality property of dense subgraphs, Liu et al. [13, 12] efficiently solved the StQP problem by searching only small subgraphs.

All these methods find dense subgraphs on unsigned graphs by seeking the local maximums of the StQP prob-lem [19]. However, due to the existence of oppositive edges, the StQP problem [19] becomes undefined on signed net-works. As a result, existing dense subgraph detection meth-ods cannot be straightforwardly extended to solve the k -OCG detection problem on signed networks.
In this paper, we use bold lower case characters (e.g., x , y , e ) and upper case characters with subscript (e.g., X X ) to represent column vectors. Upper case characters (e.g., X , M , E ) are used to represent matrices, sets or graphs. Some frequently used notations are summarized in Table 1.
A signed graph is a triple G = ( V,E,A ), where V = { v is a set of edges, and A is an n -by-n signed adjacency matrix that describes the relationship between vertices. The entry A i,j at the i -th row and the j -th column of A is positive if ( v ,v j ) is a cohesive edge, negative if ( v i ,v j ) is an oppositive e dge, and 0 otherwise. The absolute value | A i,j | m easures the strength of the cohesion or opposition.

The signed network adjacency matrix A can be rewritten into A = A +  X  A  X  . A + is the c ohesion network and is com-posed of all cohesive edges in A , that is, A + i ,j = max ( A A  X  is the o pposition network , where A  X 
Let U = { 1 ,...,n } be the universal index set of all vertices in the set of vertices V . From any index subset S  X  U , we can induce a subgraph G S = { V S ,E S ,A S } , where V { v i | i  X  S } , E S = { ( v i ,v j ) | i ,j  X  S } , and A i ,j  X  S ] is the signed adjacency matrix that describes the relationship between each pair of vertices in V S .
A common way to represent a subgraph G S is to associate i t with a non-negatively-valued n -dimensional column vector x = [ x 1 ,x 2 ,...,x n ] in the standard simplex  X  n , where the i -th dimension x i indicates the participation of vertex v in G S , that is, the weight of vertex v i in G S , and simplex  X  n = { x | P n i = 1 x i = 1 , x i  X  0 } . Particularly, if x v ertex v i does not belong to G S . If x i &gt; 0 , v i n G S . Given G S and its vector representation x , we can immediately have the set of indexes of the vertices in G S S = { i  X  U | x i &gt; 0 } . In the rest of the paper, we refer to a subgraph by the vector representation x and the set of indexes of vertices S interchangeably.

We are interested in finding k -oppositive cohesive groups ( k -OCG), where each cohesive group is a dense subgraph dominated by cohesive edges and thus has high intra-subgraph cohesion. At the same time, among the groups there are dense oppositive edges and thus the k -OCG as a set has high inter-subgraph opposition.

To model a k -OCG, we introduce the notion of k -subgraph set , denoted by S = { S 1 ,S 2 ,...,S k } , which is a set of k subgraphs. We represent each subgraph S j  X  S ( 1  X  j  X  k ) by an n -dimensional column vector X j  X   X  n . Consequently, w e represent S by an n -by-k dimensional matrix X where the j -th column X j  X   X  n represents subgraph S j . Obviously, w e have S j = { i  X  U | X i,j &gt; 0 } , where X i,j is the entry at t he i -th row and the j -th column of matrix X .

Pavan et al. [19] proposed a widely used measure for intra-subgraph cohesion. For subgraph x  X   X  n , define Si nce P n i = 1 x i = 1 as x  X   X  n , Equation 1 is the weighted a verage of cohesive edge weights in subgraph x .

Similarly, we can measure the weighted average of oppos-itive edge weights between two subgraphs x and y by We can further define the intra-subgraph cohesion of a k -O CG S as the sum of all intra-subgraph cohesion of each S j  X  S , that is, w here tr (  X  ) is the trace operator .

We can further define the inter-subgraph opposition of S as the sum of the inter-subgraph opposition for each pair of subgraphs in S , that is, w here tr ( M ) is the complementary trace that sums up all non-diagonal entries of matrix M , that is, tr ( M ) = P i 6 = j M i,j . It can be verified that tr ( M 1 )  X  tr ( M tr ( M 1  X  M 2 ).

A k -oppositive cohesive groups ( k -OCG ) is a k -subgraph set that has a large intra-subgraph cohesion g + ( S ) and a large inter-subgraph opposition g  X  ( S ) . Accordingly, we de-fine the k -OCG detection problem as where H = (  X A  X   X   X  I ), I is the identify matrix, parameter  X  &gt; 0 controls the tradeoff between intra-subgraph cohesion and inter-subgraph opposition, and the term  X  tr ( X  X  X ) pe-nalizes the overlap between different cohesive subgraphs.
Every local maximum of F ( X ) corresponds to a k -OCG in graph G . However, not all local maximums are of the same significance. More often than not, in real applications we want to find the significant k -OCGs of large intra-subgraph cohesion and inter-subgraph opposition. Such significant k -OCGs are induced by the local maximums with large val-ues of F ( X ). Since every local maximum of F ( X ) satisfies the Karush-Kuhn-Tucker (KKT) conditions [8], every KKT point X  X  of F ( X ) is a potential local maximum of F ( X ). In the rest of the paper, we focus on detecting significant k -OCGs by seeking the KKT points with large F ( X  X  ) values.
T he problem in Equation 2 is a constrained optimization problem that can be solved by classic numerical optimiza-tion methods, such as Proximal Gradient method (PG) [18]. However, the classic numerical optimization methods gener-ally operate with the entire adjacency matrix A and often involves the computationally expensive gradient calculation. Therefore, when graph G is large, A is large. The classic nu-merical optimization methods are not efficient in solving the problem in Equation 2 on large graphs.

Since k -OCGs usually exist in small local regions of a signed network, a lot of information carried by A is redun-dant and we can accurately and efficiently find a k -OCG using only small submatrices of A without calculating the gradient. Next, we propose the FOCG algorithm that solves the problem in Equation 2 by iteratively seeking the KKT points [8] of F ( X ), and achieves high efficiency by confining all iterations on small subgraphs. We first re-organize Equation 2. For any j  X  [ 1 ,k ], t he terms in F ( X ) that are related with X j .

A ccording to Equation 3, when the other columns of X (i.e., { X h | h 6 = j ,h  X  [1 ,k ] } ) are fixed, we can monoton-ically increase the value of F ( X ) by maximizing f ( X j v ariable X j . Thus, we can find the KKT points of F ( X ) by optimizing f ( X j ) on each column of X ( i.e., { X j  X   X  n | j  X  [ 1 ,k ] } ). The corresponding optimization problem is where f ( X j ) = X  X  j A + X j + 2 X  X  j M j and M j = P is an n -dimensional column vector.

The first term X  X  j A + X j of f ( X j ) in Equation 4 is the i ntra-subgraph cohesion of subgraph S j . This term is exactly t he objective function of the dense subgraph seeking meth-ods [19, 13, 12]. To understand the second term in Equa-tion 4, we notice the following. First, since H = (  X A  X   X   X  I ), sents the opposition between vertices v i and v l . Second, we re write the i -th entry of HX h to ( H X h ) i = P l  X  S Si nce X l,h is the weight of vertex v l in subgraph S h , ( H X represents the average opposition between vertex v i and all t he vertices in subgraph S h . Then, since M j = P h 6 = j t he i -th entry of M j can be written as M i,j = P h 6 = j w hich is the sum of the average opposition between ver-tex v i and all the ( k  X  1 ) subgraphs in S \ S j = { S h S | h 6 = j } . By expanding the second term of f ( X j ) w eighted average opposition between all the vertices of sub-graph S j and all the other subgraphs in S \ S j .
N ext, we illustrate how to efficiently find a k -OCG by seeking a KKT point X  X  of F ( X ) . In Section 4.1, we prove that we can find X  X  by seeking the KKT points X  X  j for a ll j  X  [1 ,k ]. Section 4.2 introduces the LUA method that efficiently finds X  X  j of f ( X j ) by searches in small subgraphs. Se ction 4.3 summarizes the FOCG method, which finds a KKT point X  X  of F ( X ) by seeking X  X  j for all j  X  [ 1 ,k ] with LUA. We also introduce the initialization method IOCG and illustrate how to select significant k -OCGs. The following result establishes the relation between a K KT point of F ( X ) and the KKT points of f ( X j ) , j  X  [1 ,k ]. Therefore, finding the KKT points of f ( X j ) for all j  X  [ 1 ,k ] can be used to find KKT points of F ( X ).

Theorem 1. X  X   X   X  n  X  k is a KKT point of F ( X ) i f and only if  X  j  X  [1 ,k ] , X  X  j is a KKT point of f ( X j ) .
P roof sketch. We prove here only the biconditional logical connectivity with respect to the stationarity condi-tion of KKT conditions. The proof on the biconditional log-ical connectivity with respect to the primal feasibility, dural feasibility and complementary slackness is straightforward and thus is omitted for the interest of space.

For X and X j , since X  X   X  n  X  k = { X | X j  X   X  n ,j  X  [ 1 ,k ] } and X j  X   X  n = { X j | P n i = 1 X i,j = 1 , X Lagrange functions of F ( X ) and f ( X j ) can be written to E quations 5 and 6, respectively.  X   X   X   X   X   X   X   X   X   X   X   X  where  X  ,  X  ,  X  j and  X  j are Lagrangian multipliers,  X  j j -th column of the n -by-k dimensional matrix  X  , and  X  t he j -th element of the k -dimensional vector  X  . Apparently, R ( X ) = P k j = 1 r ( X j ).

De note by  X  X L F the gradient of L F ( X ,  X  ,  X  ), which is an n -by-k dimensional matrix. (  X  X L F ) j is the j -th column of  X  X L F . We have where  X  X j is the gradient operator over variable X j .
A ccording to Equation 3, we have  X  X j F ( X ) =  X 
X j f ( X j ). Since R ( X ) = P k j = 1 r ( X j ), we have  X 
X j R ( X ) =  X  X j r ( X j ). By substituting the above two e quations into Equation 7, we have w here  X  X j L f is the gradient of L f ( X j ,  X  j , X  j ). S ufficiency. If X  X  is a KKT point, then  X  X  X  L F = 0. A ccording to Equation 8, we have  X  X  X  thus the stationarity condition holds for each f ( X  X  j ).
N ecessity. If  X  j  X  [1 ,k ], X  X  j is a KKT point of f ( X t hen we have  X  X  X  0 . Therefore, the stationarity condition holds for F ( X
Theorem 2. X  X  j  X   X  n is a KKT point of f ( X j ) i f and only if X j , R i ( X  X  j ) = ( A + X  X  j ) i + M i,j , Q ( X  X  j ) = ( X a nd ( A + X  X  j ) i is the i -th entry of A + X  X  j .
P roof. A KKT point X  X  j of f ( X j ) must satisfy the KKT c onditions: (1) Stationarity: 2( A + X  X  j ) i +2 M i,j +  X  0 ,  X  i  X  [ 1 ,n ]; (2) Complementary slackness: ( 3) Dual feasibility:  X  i,j  X  0 ,  X  i  X  [ 1 ,n ]; and (4) Primal feasibility: X  X  i ,j  X  0 ,  X  i  X  [ 1 ,n ] and t he primal feasibility trivially holds, since X  X  j  X   X  n .
S ufficiency. If X  X  j is a KKT point, then X  X  j satisfies all t he above KKT conditions. Considering X i,j and  X  i,j are no n-negative for all i  X  [1 ,n ], the complementary slackness condition can be rewritten as
B y doing simple calculations on both Equation 11 and the stationary condition, we can rewrite the KKT conditions as w hich indicates R i ( X  X  j ) =  X  j 2 , for all i  X  S  X  j P w e have Equation 9.

Necessity. If Eqnation 9 holds, then there always exists a set of Lagrangian multipliers  X  i,j ,i  X  [ 1 ,n ] and  X  j t hat make the KKT conditions hold. where  X  j = 2 Q ( X  X  j ). This means that X  X  j satisfies the KKT c onditions and thus is a KTT point of f ( X j ).

For R i ( X  X  j ) in Equation 9, the first term ( A + X  X  a verage cohesion between vertex v i and all vertices in sub-g raph S  X  j , and captures the contribution from vertex v t he intra-subgraph cohesion of S  X  j . The second term M is the average opposition between v i and the vertices of the o ther ( k  X  1) subgraphs in S \ S  X  j , and captures the con-t ribution from v i to the inter-subgraph opposition between S j and the other subgraphs in S \ S  X  j . Thus, R i ( X  X  j s ures the contribution from v i to both the intra-subgraph c ohesion and inter-subgraph opposition of S  X  j . For Q ( X i n the same equation, since Q ( X  X  j ) = ( X  X  j )  X  R ( X P a verage contribution from all vertices in S  X  j .
T heorem 2 indicates that, for a KKT point X  X  j , the con-t ribution R i ( X  X  j ) by each vertex v i inside subgraph S e qual to the average contribution Q ( X  X  j ) by S  X  j . Moreover, t he contribution R i ( X  X  j ) by each vertex v i outside subgraph S j is not larger than the average contribution Q ( X  X  j ) by S
A ccording to Theorem 2, any point X  X  j satisfying the KKT c onditions in Equation 9 is a KKT point of f ( X j ) in graph G . Thus, any  X  X j  X   X  n is a KKT point in subgraph S j if w here  X  S j = { i  X  U |  X  X i,j &gt; 0 } i s a subset of S
A pparently, a KKT point  X  X j on S j induces a subgraph  X  S j  X  S j , where no vertex v i in S j \  X  S j has a larger contribu-t ion R i (  X  X j ) than the average contribution Q (  X  X s ince S j \  X  S j is not equal to U \ S  X  j , a KKT point in subgraph S j is not necessarily a KKT point in graph G . Therefore, we further explore the relationship between a KKT point in subgraph S j and a KKT point in graph G a s follows.
Corollary 2.1. If  X  X j is a KKT point of f ( X j ) i n sub-graph S j , then  X  X j is a KKT point of f ( X j ) i n graph G if and only if  X  j = { i  X  U \  X  S j | R i (  X  X j ) &gt; Q (
P roof. ( Sufficiency. ) If  X  j =  X  , then  X  X j also satisfies t he KKT conditions in graph G (i.e., Equation 9), thus  X  is also a KKT point in graph G . ( N ecessity. )  X  j 6 =  X  i ndicates the KKT conditions in graph G do not hold for  X  X j , which means  X  X j is not a KKT p oint in graph G .
  X  j contains all the vertices that are outside subgraph  X  and contribute more cohesion and opposition to  X  S j than the a verage contribution Q (  X  X j ). Adding the vertices in  X  s ubgraph  X  S j can further increase the average cohesion and o pposition of  X  S j , thus can increase the value of f (
In summary, a KKT point of f ( X j ) corresponds to a po-t ential dense subgraph S  X  j that possesses both large intra-s ubgraph cohesion within itself and large inter-subgraph op-position with the other subgraphs in S \ S  X  j . Since a dense s ubgraph usually consists of small subsets of vertices [13], the size of S  X  j is usually small if X  X  j is a KKT point of G . B ased on this insight, we propose the Locate and Update Algorithm next, which finds KKT points of graph G by con-straining searches in small subgraphs.
In this section, we introduce the Locate and Update Al-g orithm (LUA) that efficiently finds a KKT point of f ( X i n graph G . The key to the efficiency of LUA is that it al-ways works on a small subgraph S j and iteratively updates S j until a KKT point in graph G i s found.

We first transform the problem in Equation 4 into the following standard form of dense subgraph seeking problem where f ( X j ) = X  X  j B j X j and B j = A + + e M  X  j + M a n n -by-n dimensional matrix. e is a column vector with all entries equal to 1.

When matrix B j is given, there are many existing dense s ubgraph seeking algorithms [19, 2, 13] that can be used to solve the problem in Equation 14. However, since matrix B is not sparse, it is hard to calculate and store B j when graph G i s large. Without materializing B j , we cannot solve the pro blem in Equation 14 by a simple extension of the existing dense subgraph seeking algorithms [19, 2, 13].

To tackle this problem, we design the LUA algorithm, which effectively avoids computing the entire matrix B j by c onfining computation in small subgraphs. LUA iteratively conducts a locate phase and an update phase. The locate phase locates a KKT point  X  X j in subgraph S j and reduces S into its subgraph  X  S j . The u pdate phase updates subgraph  X  S j by taking more vertices in  X  j whose contribution R i ( t o the intra-subgraph cohesion and inter-subgraph opposi-tion of subgraph  X  S j is larger than the average contribution Q (  X  X j ). The iteration continues until  X  j =  X  . According to Corollary 2.1,  X  X j is also a KKT point in graph G . Next, we discuss the details of LUA.
The locate phase locates a KKT point  X  X j in subgraph S j and reduces S j into its subgraph  X  S j = { i  X  U |  X  X i,j
G iven an initialization of X j (0) that is obtained by a he uristic method to be discussed in Algorithm 3, the locate phase finds a KKT point  X  X j in subgraph S j by the Replica-t or Dynamics (RD) iteration [27]. At the t -th iteration, tor B j X j ( t ) . According to [27], the iterations converge to  X  X . The resulting subgraph is  X  S j .

A nice property of Equation 15 is that, if X i,j ( t ) = 0, then X i,j ( t + 1) = 0. Thus, we can confine all computation of Equation 15 within subgraph S j by initializing X j (0) as X (0) = { X i,j &gt; 0 | i  X  S j } . Since  X  i 6 X  S j ,X only need to calculate and store a sub-matrix B S j of B j c orresponds to the edge set E S j of subgraph S j .
T he locate phase efficiently finds a KKT point  X  X j of sub-g raph S j and reduces S j into its subgraph  X  S j . However, ac-c ording to Corollary 2.1,  X  X j may not necessarily be a KKT p oint in graph G . Thus, we use an update phase to fur-ther increase the value of f (  X  X j ) and make sure that LUA c onverges to a KKT point in graph G .
According to Corollary 2.1, if  X  j =  X  , then  X  X j is already a KKT point in graph G , thus the LUA iteration converges. However, if  X  j 6 =  X  , then  X  X j is not a KKT point in graph G . In this case, we update  X  X j with a carefully designed n -di mensional vector b and a step size  X  , such that f (  X  t b ) &gt; f (  X  X j ) under the constraint (  X  X j +  X  b )  X   X 
T he i -th entry of b = [ b 1 ,...,b n ] is defined as A ccording to Corollary 2.1, if i  X   X  j , then the c ontribution R (  X  X j ) of vertex v i is larger than the average c ontribution Q (  X 
X j ) of all vertices in subgraph  X  S j . Adding v i into sub-g raph  X  S j further increases the intra-subgraph cohesion and i nter-subgraph opposition of  X  S j , thus increases the value of f (  X  b assigns a positive weight to the i -th entry of (  X  X j +  X  b ) , which is equivalent to adding v i into the updated subgraph.
A nother useful property of b i is that the constraint (  X 
X j +  X  b )  X   X  n always holds for all  X   X  [ 0 , 1 s ] due t o the following. First, since P i  X   X  S P P optimal step size by maximizing f (  X  X j +  X  b )  X  f (  X  f (  X  X j +  X  b )  X  f (  X  X j ) = b  X  A + b  X  2 + 2 b  X  ( A
When  X  j 6 =  X  , we have P i  X   X  step size  X   X  is which guarantees f (  X  X j +  X   X  b )  X  f (  X  X j ) &gt; 0 .
To sum up, when  X  j 6 =  X  , the update phase updates sub-graph  X  S j by taking some vertices in  X  j and further increases t he value of f (  X  X j ).
 Algorithm 1: The Locate and Update Iteration Input : X j (0)  X   X  n .

O utput : A KKT point X  X  j of f ( X j ) in graph G . 1 0: return A KKT point X  X  j of f ( X j ) in graph G . Algorithm 2: The FOCG Algorithm Input : X (0)  X   X  n  X  k .

O utput : A KKT point X  X  of F ( X ) in graph G . Algorithm 1 gives the pseudocode of the LUA algorithm. T he main computational cost of LUA lies in the locate phase, whose efficiency is largely affected by the size of subgraph S . In real world applications, the graph G i s usually very sparse, thus the size of both  X  j and S j are usually small, w hich leads to the high efficiency of locate phase. As a result, LUA converges pretty fast on sparse graphs. We prove the convergence of LUA as follows.

Theorem 3. The LUA iteration in Algorithm 1 con-verges to a KKT point X  X  j in graph G .

P roof. By setting all entries of B j to the maximum v alue in B j , we can easily obtain a trivial upper bound o f f ( X j ). In both the locate phase and the update phase, f ( X j ) monotonously increases, therefore, the LUA iteration c onverges in the perspective of numeric optimization. Algorithm 1 converges only when  X  j =  X  . According to Corollary 2.1, when LUA converges (i.e.,  X  j =  X  ) , the KKT point  X  X j found in subgraph S j is a KKT point X  X  j in G .
Algorithm 2 gives the pseudocode of the FOCG algorithm, w hich finds a KKT point of F ( X ) (Equation 3) by alterna-tively optimizing f ( X j ) over each column X j of X .
T heorem 4. The FOCG algorithm converges to a KKT point X  X  of graph G .

P roof. We first prove that FOCG converges. Accord-ing to Equation 3, increasing f ( X j ) equivalently increases Algorithm 3: The IOCG Algorithm Input : Adjacency matrices of A + and A  X  .

O utput : An initialization X (0) for FOCG algorithm. 10: Set X  X  j , j = 1, where  X  j is the j -th seed index in  X  . 11: end for 12: return X (0)  X  X .
 F ( X ). Since for each iteration in FOCG, the LUA algo-rithm monotonously increases f ( X j ), the value of F ( X ) is monotonously increased as well. Due to the fact that F ( X ) has an upper bound, the FOCG algorithm converges.
 The FOCG algorithm does not terminate until X  X  j is a K KT point of f ( X j ) for all j  X  [ 1 ,k ]. The reason is that, if there exist an X  X  j that is not a KKT point of f ( X j t hen F ( X ) can be further increased by LUA. Since FOCG converges when all X  X  j ( j  X  [ 1 ,k ]) are KKT points of f ( X a ccording to Theorem 1, X  X  is a KKT point of graph G .
For Algorithm 2, a proper initialization of X (0) usually improves the possibility of getting a KKT point X  X  with l arge value of F ( X  X  ). Here, we propose an initialization m ethod IOCG (Algorithm 3) for the initialization of X (0).
IOCG randomly selects k seed vertices as the initializa-tions for the k subgraphs S i (1  X  i  X  k ) in S . The first seed is selected according to the degree of each vertex on network A + . The r oulette wheel selection method [20] h = Roul ( d ra ndomly selects a vertex v h with probability d h P n t he vertices with larger degrees are more likely to be selected. Heuristically, a vertex with a large degree in network A + m ore likely to be a member of a dense subgraph. The other ( k  X  1) seed vertices are selected under the criterion that the opposition between seed vertices should be large. Such seed vertices are more likely to belong to different dense sub-graphs such that the group of subgraphs in whole possesses a large inter-subgraph opposition. As a result, IOCG pro-vides a good start point for FOCG to detect a KKT point X  X  with large value of F ( X  X  ). Such a KKT point often c orresponds to a significant k -OCG S  X  = { S  X  j | j  X  [ 1 ,k ] } , where S  X  j is the subgraph induced by X  X  j .

L et  X  be the set of all KKT points of F ( X ). The size of  X  is often very large and it is impractical to compute the entire set. However, in real applications, more often than not we are interested in only the significant k -OCGs of large value of F ( X ). Similar to most dense subgraph detection methods, we adopt the  X  X eeling-off X  method [19, 13, 5]. Due to its simplicity and robustness, such a  X  X eeling-off X  method is widely used in the task of dense subgraph detection to enumerate the set of KKT points.

Specifically in our case, when a KKT point X  X  is obtained, i t is first added into the answer set. Then, we remove the ver-tices and edges that belong to the corresponding k -subgraph set S  X  from graph G a nd find another KKT point using a new initialization of X (0). Such a process iterates until all vertices in graph G are removed and a set of KKT points  X   X  is obtained. Then, we can search  X   X  for the significant k -OCGs of large value of F ( X  X  ).
In this section, we evaluate the performance of the pro-p osed FOCG algorithm and compare it with the state-of-the-art related signed network partitioning methods includ-ing (1) Simple Normalized Signed Graph Laplacian method (SNS) [31], (2) Signed Normalized Laplacian method (SNL) [10], (3) Balance Normalized Cut method (BNC) [4], and (4) Ratio Associate method (RA) [4]. Both the SNS and SNL methods are incorporated in the standard spectral clustering framework [26] to perform the partitioning task on signed network. The codes for BNC and RA were pro-vided by Chiang et al. [4]. We also compare the scalability of FOCG and the Proximal Gradient method (PG) [18]. We use the default parameters for all compared methods. For FOCG and PG, we set  X  = 0 . 9,  X  = 50 and k = 10 by de-fault. All experiments are performed using MATLAB. We use a PC with Core-i7-3370 CPU (3.40GHz), 16GB mem-ory, and a 5400 rpm hard drive running Ubuntu 15.04. The source code of FOCG is available on GitHub [21].

The following five data sets are used. For the directed net-works, we symmetrize the adjacency matrix by A = A + A  X  2
S ynthetic Data Set. The synthetic data set is generated by the data generation method proposed by Chiang et al. [4]. We generate four networks with different sparsity. Each net-work contains 10,000 vertices that form 20 subgraphs. Slashdot Data Set. The public Slashdot data set is from SNAP [22]. We use the version  X  X oc-sign-Slashdot081106 X , which contains 77,357 vertices and 516,575 edges.

Epinions Data Set. The Epinions data set is a pub-lic data set on SNAP [22]. It is a directed signed network containing 131,828 vertices and 841,372 edges.

Douban Data set. The Douban data set [28] contains a social network of users and the movie ratings of each user. We build the signed network in three steps. First, we induce a cohesive network G + = { V ,E + } b y treating each user as a vertex in vertex set V and their friendships as cohesive edges in edge set E + . Second, we build an oppositive net-w ork G  X  = { V ,E  X  } b y calculating the average movie rat-ing difference between each pair of users. If the difference is greater than 1, we build an oppositive edge between them. Last, we obtain the signed network G = { V,E } by merging G + and G  X  . Since the set of vertices V i n G + and G  X  are t he same, we only merge the set of edges E = E +  X  E  X  . If t here are both cohesive edge and oppositive edge between a pair of users, we keep the oppositive edge in G . The network contains 1.59 million vertices and 19.67 million edges.
WordNetAdj Data Set. The WordNetAdj data set is a subset of adjectives sampled from the adjective network of the WordNet database [16]. It contains 12,883 vertices and 39,460 edges, where each vertex represents an adjective. The edge between a pair of synonyms is cohesive and the edge between a pair of antonyms is oppositive. where S  X  i = { S  X  i ,j | j = 1 ,...,k } is a k -OCG and S a cohesive subgraph in S  X  i . Let n p be the total number of v ertices contained by the set of k -OCGs S . Apparently, we have n p  X  n , where n is the number of vertices in G .
The intra-subgraph cohesion of a single subgraph S  X  i ,j where | S  X  i ,j | i s the number of vertices in subgraph S C ohe ( S  X  i ,j ) is the average cohesive edge weight of S i s widely used to measure intra-subgraph cohesion [25]. The inter-subgraph opposition between two subgraphs S
We define the M ean Average Cohesion (MAC) as the mean of the average intra-subgraph cohesion for all k -OCGs in S , that is,
Mo reover, the Mean Average Opposition (MAO) is the mean of the average inter-subgraph opposition for all k -OCGs in S , that is,
MAO = 1 F inally, we define Harmonic Mean (HAM) as
Mean Average Precision (MAP) is only used on the synthetic data set, where the vertex index set for each of the 20 subgraphs is known and used as ground truth. Denote such vertex index set of the j -th subgraph as S gt j ,j  X  [ 1 , 20], we measure the average precision of a single k -OCG S  X  i a nd further evaluate MAP by Si nce all the signed network partitioning methods (i.e., SNS, SNL, BNC and RA) partition the entire graph G into a single k -OCG, the size of S is p = 1 for those methods. For FOCG, the k -OCGs in S are obtained by selecting the top-p KKT points with large value of F ( X  X  ) from the set of K KT points  X   X  . Thus, the size of S for FOCG is p &gt; 1.
Using a small value of p (e.g., p = 10) FOCG returns an answer S that contains the top ten k -OCGs, which usually achieve very high MAC, MAO and HAM performance. How-ever, for the fairness of the comparison, we set p to a large value so that n p = 0 . 5  X  n , which forces FOCG to produce k -OCGs covering 50% of the vertices in graph G . Figure 1: Ranked HAM performances on real world data sets. n is the number of vertices in G .
We analyze the effect of parameters n p and  X  ( Equation 2) of FOCG. To analyze the effect of n p , we sort all the KKT p oints X  X  in  X   X  i n descending order of F ( X  X  ), then evaluate t he HAM value for each KKT point X  X  by regarding it as t he only k -OCG in S . Figure 1 shows the results on the two real data sets with respect to the percentage of vertices in G that are covered by the top-p KKT points.

The KKT points ranked on the top (i.e., n p n &lt; 0 . 0 1) achieve very high HAM on both data sets. The HAM de-creases and approaches zero when n p n  X  0 . 4 5. This indicates that about 45% of the vertices in graph G can form signifi-cant k -OCGs. Therefore, for the fairness of experiment, we evaluate the performance of FOCG by the average perfor-mance of all k -OCGs that cover 50% of the vertices of G , that is, setting n p = 0 . 5  X  n .

F igure 2 shows the effect of parameter  X  on the perfor-mances of FOCG. In Equation 2,  X  controls the tradeoff between intra-subgraph cohesion and inter-subgraph opposi-tion. A larger  X  results in a smaller intra-subgraph cohesion thus a lower MAC, and a larger inter-subgraph opposition thus a higher MAO. As shown in Figure 2, the larger  X  , the smaller MAC and larger MAO. However, when  X  &gt; 1, MAC, MAO and HAM all become stable. This indicates that the second term  X g  X  ( S ) of Equation 2 dominates F ( X ) when  X  &gt; 1, thus the detected k -OCGs favor MAO most and do not change much when  X  increases further. HAM on both data sets becomes stable when  X  = 0 . 9, thus we set  X  = 0 . 9 as default in our experiments.
We analyze the effect of network sparsity using the syn-t hetic data set. The sparsity of the signed network is defined as the percentage of zero entries in the adjacency matrix A .
A higher sparsity weakens both the cohesive and opposi-tive connections between graph vertices, thus decreases both the intra-subgraph cohesion and inter-subgraph opposition. Thus, in Figure 3(a)-(c), MAC, MAO and HAM all decrease when the sparsity increases. However, in Figure 3(d), MAP of all graph partitioning methods is not sensitive to sparsity. This is because the connectivity of the cohesive network and oppositive network is not affected too much by the sparsity. Thus, the partitioning methods can still accurately find the 20 subgraphs in the ground truth. FOCG achieves the same good performance in MAP as the graph partitioning meth-ods, which means the k -OCGs detected by FOCG are also consistent with the ground truth.
 In Figure 3(a)-(c), when the sparsity is 0 . 2, SNS, SNL, BNC and RA achieve equivalently good performance as FOCG. This is because when the sparsity is small, the 20 subgraphs of the synthetic data set form a single 20-OCG. Thus, partitioning the entire graph into 20 subgraphs leads to the perfect result. However, when the sparsity increases, the original single k -OCG will be scattered into many small k -OCGs. In this case, partitioning the entire graph does not effectively obtain such small significant k -OCGs, thus the performance of the graph partitioning methods degrades quickly. Nevertheless, FOCG is able to accurately detect such small k -OCGs, thus achieves better performance under high sparsity. It is worth noting that real word signed net-work are often sparse. For example, the network sparsity of Slashdot and Epinions are both larger than 0.99.
We compare the performance of all methods on Slash-do t and Epinions. In such real world networks, a k -OCG represents k groups of people with strong intra-group co-hesion and strong inter-group opposition. Apparently, the chance of finding k = 50 groups of people with strong inter-group opposition is much smaller than finding k = 2 groups of such people. Thus, it is more difficult to achieve good performance in MAO when k is large. As a result, in Fig-ure 4(c)-(d), the MAO of FOCG decreases when k increases.
Since the real world networks are highly sparse, the entire network cannot form a single significant k -OCG. Instead, there are many small sized k -OCGs in different local regions. Since FOCG is designed to detect such small significant k -OCGs, it achieves much better HAM in Figure 4(e)-(f). In Figure 4(a)-(b), FOCG is not always the best in MAC. In Figure 4(c)-(d), BNC outperforms FOCG in MAO when k = 7 and k = 5, respectively. The reason is that the k -OCGs in S of FOCG are selected according to the value of F ( X  X  ), which leads to a high HAM and a balanced per-fo rmance of MAC and MAO. Since we are most interested in finding the significant k -OCG with both strong intra-subgraph cohesion and strong inter-subgraph opposition,
Figure 4: Performances on Slashdot and Epinions.
Figure 5: Scalability analysis on Douban data set. a good HAM performance with balanced MAC and MAO guides the objective. Although FOCG may not achieve the best in MAC or MAO, its advantage on HAM is significant in Figure 4(e)-(f). We compare the scalability of FOCG and the Proximal G radient method (PG) [18] on the Douban data set. We obtain four sub-networks from the Douban data set as fol-lows. First, we start a breadth first search (BFS) from a randomly picked vertex on the cohesive network G + until t he desired number of vertices are visited. Let S be the set of all vertices visited by the BFS. We use S to induce a co-hesive sub-network G + S and an oppositive sub-network G  X  L ast, we obtain the signed sub-network G S by merging the e dge sets of G + S and G  X  S . The number of vertices and that o f edges of the 5 networks are listed in Table 2, where the 5-th network is simply the entire Douban data set.
On each of the 5 data sets, we run FOCG and PG 10 times and report the average results. In each run, we randomly initialize X (0) by the same initialization method of PG, then run FOCG and PG using the same initialization.

Figure 5(a) shows the objective value F ( X  X  ) of the KKT p oint X  X  detected by FOCG and PG. The objective values o f FOCG and PG are close. Both FOCG and PG perform well in solving the optimization problem of Equation 2. Figure 5(b) shows the running time of FOCG and PG. The running time increases as the number of edges increases. FOCG is two orders of magnitudes faster. PG is a generic solution for constrained optimization problems, and is not specifically designed for k -OCG detection. It calculates the gradient of F ( X ) in each iteration. The computational cost in calculating such gradients is very expensive when the number of edges is large. On the contrary, all FOCG iterations are efficiently performed on small subgraphs.
We conduct a case study on the WordNetAdj data set, w here each vertex represents an adjective, a cohesive edge indicates synonymous relationship and an opposite edge in-dicates antonymous relationship. In this network, a cohe-sive subgraph consists of a group of synonyms and a k -OCG is k groups of synonyms such that the adjectives in differ-ent groups are mostly antonymous with each other. Since the antonymous relationship between adjectives are usually bipolar, it is reasonable to set k = 2.

Table 3 shows the top-10 k -OCGs detected. Each row shows the two adjective groups of a detected k -OCG. This case study verifies that significant k -OCGs reveal interesting patterns in WordNetAdj.
In this paper, we tackled the novel problem of finding k -oppositive cohesive groups from signed networks. We formulated the k -OCG detection problem as a constrained quadratic optimization problem and designed FOCG, an ef-fective and efficient algorithm. Our extensive experiments showed that FOCG can find interesting  X  X angs in war X , and is two orders of magnitudes faster than the traditional proxi-mal gradient method. As future work, we will extend FOCG to automatically estimate the best value of k and effectively control the size of detected subgraphs.
