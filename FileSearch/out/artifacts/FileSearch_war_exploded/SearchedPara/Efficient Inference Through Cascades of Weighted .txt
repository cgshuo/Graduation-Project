 1 Motivation Weighted finite-state transducers have found re-cent favor as models of natural language (Mohri, 1997). In order to make actual use of systems built with these formalisms we must first calculate the set of possible weighted outputs allowed by the transducer given some input, which we call for-ward application , or the set of possible weighted inputs given some output, which we call backward application . After application we can do some in-ference on this result, such as determining its k highest weighted elements.

We may also want to divide up our problems into manageable chunks, each represented by a transducer. As noted by Woods (1980), it is eas-ier for designers to write several small transduc-ers where each performs a simple transformation, rather than painstakingly construct a single com-plicated device. We would like to know, then, the result of transformation of input or output by a cascade of transducers, one operating after the other. As we will see, there are various strate-gies for approaching this problem. We will con-sider offline composition , bucket brigade applica-tion , and on-the-fly application .

Application of cascades of weighted string transducers ( WST s) has been well-studied (Mohri, 1997). Less well-studied but of more recent in-terest is application of cascades of weighted tree transducers ( WTT s). We tackle application of WTT cascades in this work, presenting:  X  explicit algorithms for application of WTT cas-cades  X  novel algorithms for on-the-fly application of
WTT cascades, and  X  experiments comparing the performance of these algorithms. 2 Strategies for the string case Before we discuss application of WTT s, it is help-ful to recall the solution to this problem in the WST domain. We recall previous formal presentations of WST s (Mohri, 1997) and note informally that they may be represented as directed graphs with designated start and end states and edges labeled with input symbols, output symbols, and weights. 1 Fortunately, the solution for WST s is practically trivial X  X e achieve application through a series of embedding , composition , and projection oper-ations. Embedding is simply the act of represent-ing a string or regular string language as an iden-tity WST . Composition of WST s, that is, generat-ing a single WST that captures the transformations of two input WST s used in sequence, is not at all trivial, but has been well covered in, e.g., (Mohri, 2009), where directly implementable algorithms can be found. Finally, projection is another triv-ial operation X  X he domain or range language can be obtained from a WST by ignoring the output or input symbols, respectively, on its arcs, and sum-ming weights on otherwise identical arcs. By em-bedding an input, composing the result with the given WST , and projecting the result, forward ap-plication is accomplished. 2 We are then left with a weighted string acceptor ( WSA ), essentially a weighted, labeled graph, which can be traversed by well-known algorithms to efficiently find the k-best paths.

Because WST s can be freely composed, extend-ing application to operate on a cascade of WST s is fairly trivial. The only question is one of com-position order: whether to initially compose the cascade into a single transducer (an approach we call offline composition ) or to compose the initial embedding with the first transducer, trim useless states, compose the result with the second, and so on (an approach we call bucket brigade ). The ap-propriate strategy generally depends on the struc-ture of the individual transducers.

A third approach builds the result incrementally, as dictated by some algorithm that requests in-formation about it. Such an approach, which we call on-the-fly , was described in (Pereira and Ri-ley, 1997; Mohri, 2009; Mohri et al., 2000). If we can efficiently calculate the outgoing edges of a state of the result WSA on demand, without cal-culating all edges in the entire machine, we can maintain a stand-in for the result structure, a ma-chine consisting at first of only the start state of the true result. As a calling algorithm (e.g., an im-plementation of Dijkstra X  X  algorithm) requests in-formation about the result graph, such as the set of outgoing edges from a state, we replace the current stand-in with a richer version by adding the result of the request. The on-the-fly approach has a dis-tinct advantage over the other two methods in that the entire result graph need not be built. A graphi-cal representation of all three methods is presented in Figure 1. 3 Application of tree transducers Now let us revisit these strategies in the setting of trees and tree transducers. Imagine we have a tree or set of trees as input that can be represented as a weighted regular tree grammar 3 ( WRTG ) and a
WTT that can transform that input with some weight. We would like to know the k-best trees the WTT can produce as output for that input, along with their weights. We already know of several methods for acquiring k-best trees from a WRTG (Huang and Chiang, 2005; Pauls and Klein, 2009), so we then must ask if, analogously to the string case, WTT s preserve recognizability 4 and we can form an application WRTG . Before we begin, how-ever, we must define WTT s and WRTG s. 3.1 Preliminaries 5 A ranked alphabet is a finite set  X  such that ev-ery member  X   X   X  has a rank rk (  X  )  X  N . We call  X  ( k )  X   X  ,k  X  N the set of those  X   X   X  such that rk (  X  ) = k . The set of variables is de-noted X = { x 1 ,x 2 ,... } and is assumed to be dis-joint from any ranked alphabet used in this paper. We use  X  to denote a symbol of rank 0 that is not in any ranked alphabet used in this paper. A tree t  X  T  X  is denoted  X  ( t 1 ,...,t k ) where k  X  0 ,  X   X   X  ( k ) , and t 1 ,...,t k  X  T  X  . For  X   X   X  (0) we write  X   X  T  X  as shorthand for  X  () . For every set S disjoint from  X  , let T  X  ( S ) = T  X   X  S , where, for all s  X  S , rk ( s ) = 0 .

We define the positions of a tree t =  X  ( t 1 ,...,t k ) , for k  X  0 ,  X   X   X  ( k ) , t ,...,t k  X  T  X  , as a set pos ( t )  X  N  X  such that pos ( t ) = {  X  } X  X  iv | 1  X  i  X  k,v  X  pos ( t i ) } . The set of leaf positions lv ( t )  X  pos ( t ) are those positions v  X  pos ( t ) such that for no i  X  N , vi  X  pos ( t ) . We presume standard lexicographic orderings &lt; and  X  on pos .

Let t,s  X  T  X  and v  X  pos ( t ) . The label of t at position v , denoted by t ( v ) , the subtree of t at v , denoted by t | v , and the replacement at v by s , denoted by t [ s ] v , are defined as follows: 1. For every  X   X   X  (0) ,  X  (  X  ) =  X  ,  X  |  X  =  X  , and 2. For every t =  X  ( t 1 ,...,t k ) such that
The size of a tree t , size ( t ) is | pos ( t ) | , the car-dinality of its position set. The yield set of a tree is the set of labels of its leaves: for a tree t , yd ( t ) = { t ( v ) | v  X  lv ( t ) } .

Let A and B be sets. Let  X  : A  X  T  X  ( B ) be a mapping. We extend  X  to the mapping  X  : T
 X  ( A )  X  T  X  ( B ) such that for a  X  A ,  X  ( a ) =  X  ( a ) and for k  X  0 ,  X   X   X  ( k ) , and t 1 ,...,t k  X  T  X  ( A ) , cate such extensions by describing  X  as a substi-tution mapping and then using  X  without further comment.

We use R + to denote the set { w  X  R | w  X  0 } and R  X  + to denote R +  X  X  +  X  X  .
 Definition 3.1 ( cf. (Alexandrakis and Bozapa-lidis, 1987) ) A weighted regular tree grammar (
WRTG ) is a 4-tuple G = ( N,  X  ,P,n 0 ) where: 1. N is a finite set of nonterminals , with n 0  X  N 2.  X  is a ranked alphabet of input symbols, where 3. P is a tuple ( P 0 , X  ) , where P 0 is a finite set
A production p is a chain production if it is of the form n i w  X  X  X  n j , where n i ,n j  X  N . 6 A WRTG G is in normal form if each produc-tion is either a chain production or is of the form n w  X  X  X   X  ( n 1 ,...,n k ) where  X   X   X  ( k ) and n ,...,n k  X  N .

For WRTG G = ( N,  X  ,P,n 0 ) , s , t , u  X  T  X  ( N ) , n  X  N , and p  X  P of the form n w  X  X  X  u , we obtain a derivation step from s to t by replacing some leaf nonterminal in s labeled n with u . For-mally, s  X  p G t if there exists some v  X  lv ( s ) such that s ( v ) = n and s [ u ] v = t . We say this derivation step is leftmost if, for all v 0  X  lv ( s ) where v 0 &lt; v , s ( v 0 )  X   X  . We henceforth as-sume all derivation steps are leftmost. If, for some m  X  N , p i  X  P , and t i  X  T  X  ( N ) for all 1  X  i  X  m , n 0  X  p 1 t 1 ...  X  p m t m , we say the sequence d = ( p 1 ,...,p m ) is a derivation of t m in G and that n 0  X   X  t m ; the weight of d is wt ( d ) =  X  ( p 1 )  X  ...  X   X  ( p m ) . The weighted tree language recognized by G is the mapping L
G : T  X   X  R is the sum of the weights of all (possibly infinitely many) derivations of t in G . A weighted tree lan-guage f : T  X   X  R  X  + is recognizable if there is a WRTG G such that f = L G .

We define a partial ordering on WRTG s such that for WRTG s G 1 = ( N 1 ,  X  ,P 1 ,n 0 ) and G 2 = ( N 2 ,  X  ,P 2 ,n 0 ) , we say G 1 G 2 iff N 1  X  N 2 and P 1  X  P 2 , where the weights are preserved.
 Definition 3.2 (cf. Def. 1 of (Maletti, 2008)) A weighted extended top-down tree transducer (
WXTT ) is a 5-tuple M = ( Q,  X  ,  X  ,R,q 0 ) where: 1. Q is a finite set of states. 2.  X  and  X  are the ranked alphabets of in-3. R is a tuple ( R 0 , X  ) , where R 0 is a finite set
A WXTT is linear (respectively, nondeleting ) if, for each rule r of the form q.y w  X  X  X  u , each x  X  yd ( y )  X  X appears at most once (respec-tively, at least once) in u . We denote the class of all WXTT s as wxT and add the letters L and N to signify the subclasses of linear and nondeleting WTT , respectively. Additionally, if y is of the form  X  ( x 1 ,...,x k ) , we remove the letter  X  X  X  to signify the transducer is not extended (i.e., it is a  X  X radi-tional X  WTT (F  X  ul  X  op and Vogler, 2009)).
For WXTT M = ( Q,  X  ,  X  ,R,q 0 ) , s , t  X  T  X  ( Q  X  T  X  ) , and r  X  R of the form q.y w  X  X  X  u , we obtain a derivation step from s to t by replacing some leaf of s labeled with q and a tree matching y by a transformation of u , where each instance of a vari-able has been replaced by a corresponding subtree of the y -matching tree. Formally, s  X  r M t if there is a position v  X  pos ( s ) , a substitution mapping  X  : X  X  T  X  , and a rule q.y w  X  X  X  u  X  R such that s ( v ) = ( q,  X  ( y )) and t = s [  X  0 ( u )] v , where  X  a substitution mapping Q  X  X  X  T  X  ( Q  X  T  X  ) defined such that  X  0 ( q 0 ,x ) = ( q 0 , X  ( x )) for all q 0  X  Q and x  X  X . We say this derivation step is leftmost if, for all v 0  X  lv ( s ) where v 0 &lt; v , s ( v 0 )  X   X  . We henceforth assume all derivation steps are leftmost. If, for some s  X  T  X  , m  X  N , r  X  R , and t i  X  T  X  ( Q  X  T  X  ) for all 1  X  i  X  m , ( q 0 ,s )  X  r 1 t 1 ...  X  r m t m , we say the sequence d = ( r 1 ,...,r m ) is a derivation of ( s,t m ) in M ; the weight of d is wt ( d ) =  X  ( r 1 )  X  ...  X   X  ( r m ) . The weighted tree transformation recognized by M is the mapping  X  M : T  X   X  T  X   X  R  X  + , such that for every s  X  T  X  and t  X  T  X  ,  X  M ( s,t ) is the sum of the weights of all (possibly infinitely many) derivations of ( s,t ) in M . The composition of two weighted tree transformations  X  : T  X   X  T  X   X  R  X  + and  X  : T  X   X  T  X   X  R  X  + is the weighted tree trans-formation (  X  ;  X  ) : T  X   X  T  X   X  R  X  + where for every s  X  T  X  and u  X  T  X  , (  X  ;  X  )( s,u ) = P t  X  T  X   X  ( t,u ) . 3.2 Applicable classes We now consider transducer classes where recog-nizability is preserved under application. Table 1 presents known results for the top-down tree trans-ducer classes described in Section 3.1. Unlike the string case, preservation of recognizability is not universal or symmetric. This is important for us, because we can only construct an application WRTG , i.e., a WRTG representing the result of ap-plication, if we can ensure that the language gen-erated by application is in fact recognizable. Of the types under consideration, only wxLNT and wLNT preserve forward recognizability. The two classes marked as open questions and the other classes, which are superclasses of wNT, do not or are presumed not to. All subclasses of wxLT pre-serve backward recognizability. 7 We do not con-sider cases where recognizability is not preserved in the remainder of this paper. If a transducer M of a class that preserves forward recognizability is applied to a WRTG G , we can call the forward ap-plication WRTG M ( G ) . and if M preserves back-ward recognizability, we can call the backward ap-plication WRTG M ( G ) / .

Now that we have explained the application problem in the context of weighted tree transduc-ers and determined the classes for which applica-tion is possible, let us consider how to build for-ward and backward application WRTG s. Our ba-sic approach mimics that taken for WST s by us-ing an embed-compose-project strategy. As in string world, if we can embed the input in a trans-ducer, compose with the given transducer, and project the result, we can obtain the application WRTG . Embedding a WRTG in a wLNT is a triv-ial operation X  X f the WRTG is in normal form and chain production-free, 8 for every production of the form n w  X  X  X   X  ( n 1 ,...,n k ) , create a rule of the form n. X  ( x 1 ,...,x k ) w  X  X  X   X  ( n 1 .x 1 ,...,n k .x k ) . Range projection of a wxLNT is also trivial X  X or every q  X  Q and u  X  T  X  ( Q  X  X ) create a production of the form q w  X  X  X  u 0 where u 0 is formed from u by replacing all leaves of the form q.x with the leaf q , i.e., removing references to variables, and w is the sum of the weights of all rules of the form q.y  X  X  X  u in R . 9 Domain projection for wxLT is best explained by way of example. The left side of a rule is preserved, with variables leaves replaced by their associated states from the right side. So, the rule q 1 . X  (  X  ( x 1 ) ,x 2 ) w  X  X  X   X  ( q 2 .x 2 , X  (  X ,q would yield the production q 1 w  X  X  X   X  (  X  ( q 3 ) ,q 2 ) in the domain projection. However, a deleting rule introduction of a new nonterminal  X  that can gen-erate all of T  X  with weight 1.

The only missing piece in our embed-compose-project strategy is composition. Algorithm 1, which is based on the declarative construction of Maletti (2006), generates the syntactic composi-tion of a wxLT and a wLNT, a generalization of the basic composition construction of Baker (1979). It calls Algorithm 2, which determines the sequences of rules in the second transducer that match the right side of a single rule in the first transducer. Since the embedded WRTG is of type wLNT, it may be either the first or second argument provided to Algorithm 1, depending on whether the application is forward or backward. We can thus use the embed-compose-project strat-egy for forward application of wLNT and back-ward application of wxLT and wxLNT. Note that we cannot use this strategy for forward applica-tion of wxLNT, even though that class preserves recognizability.
 Algorithm 1 COMPOSE 4 Application of tree transducer cascades What about the case of an input WRTG and a cas-cade of tree transducers? We will revisit the three strategies for accomplishing application discussed above for the string case.

In order for offline composition to be a viable strategy, the transducers in the cascade must be closed under composition. Unfortunately, of the classes that preserve recognizability, only wLNT is closed under composition (G  X  ecseg and Steinby, 1984; Baker, 1979; Maletti et al., 2009; F  X  ul  X  op and Vogler, 2009).

However, the general lack of composability of tree transducers does not preclude us from con-ducting forward application of a cascade. We re-visit the bucket brigade approach, which in Sec-tion 2 appeared to be little more than a choice of composition order. As discussed previously, ap-plication of a single transducer involves an embed-ding, a composition, and a projection. The embed-ded WRTG is in the class wLNT, and the projection forms another WRTG . As long as every transducer in the cascade can be composed with a wLNT to its left or right, depending on the application type, application of a cascade is possible. Note that this embed-compose-project process is some-what more burdensome than in the string case. For strings, application is obtained by a single embed-ding, a series of compositions, and a single projec-Algorithm 2 COVER tion, whereas application for trees is obtained by a series of (embed, compose, project) operations. 4.1 On-the-fly algorithms We next consider on-the-fly algorithms for ap-plication. Similar to the string case, an on-the-fly approach is driven by a calling algorithm that periodically needs to know the productions in a WRTG with a common left side nonterminal. The embed-compose-project approach produces an en-tire application WRTG before any inference al-gorithm is run. In order to admit an on-the-fly approach we describe algorithms that only gen-erate those productions in a WRTG that have a given left nonterminal. In this section we ex-tend Definition 3.1 as follows: a WRTG is a 6-tuple G = ( N,  X  ,P,n 0 , M, G ) where N,  X  ,P, and n 0 are defined as in Definition 3.1, and either M = G =  X  , 10 or M is a wxLNT and G is a nor-mal form, chain production-free WRTG such that w[x]LT OQ (Maletti, 2009) w[x]NT No (G  X  ecseg and Steinby, 1984) wxLNT Yes (F  X  ul  X  op et al., 2010) wLNT Yes (Kuich, 1999) example, w[x]T signifies both wxT and wT.
 Algorithm 3 PRODUCE G M ( G ) . . In the latter case, G is a stand-in for M ( G ) . , analogous to the stand-ins for WSA s and WST s described in Section 2.
 Algorithm 3, PRODUCE, takes as input a WRTG G in = ( N in ,  X  ,P in ,n 0 , M, G ) and a de-sired nonterminal n in and returns another WRTG , G out that is different from G in in that it has more productions, specifically those beginning with n in that are in M ( G ) . . Algorithms using stand-ins should call PRODUCE to ensure the stand-in they are using has the desired productions beginning with the specific nonterminal. Note, then, that PRODUCE obtains the effect of forward applica-Algorithm 4 REPLACE Algorithm 5 MAKE-EXPLICIT Figure 2: Forward application through a cascade of tree transducers using an on-the-fly method. tion in an on-the-fly manner. 11 It makes calls to REPLACE, which is presented in Algorithm 4, as well as to a NORM algorithm that ensures normal form by replacing a single production not in nor-mal form with several normal-form productions that can be combined together (Alexandrakis and Bozapalidis, 1987) and a CHAIN-REM algorithm that replaces a WRTG containing chain productions with an equivalent WRTG that does not (Mohri, 2009).

As an example of stand-in construction, con-sider the invocation PRODUCE( G 1 , g 0 a 0 ), where G 1 = ( { g 0 a 0 } , {  X , X , X , X  } ,  X  , g 0 a 0 , M A , G ), G is in Figure 2a, 12 and M A is in 2b. The stand-in WRTG that is output contains the first three of the four productions in Figure 2d.

To demonstrate the use of on-the-fly application in a cascade, we next show the effect of PRO-DUCE when used with the cascade G  X  M A  X  M B , where M B is in Figure 2c. Our driving al-gorithm in this case is Algorithm 5, MAKE-Figure 3: Example rules from transducers used in decoding experiment. j1 and j2 are Japanese words.
 EXPLICIT, which simply generates the full ap-plication WRTG using calls to PRODUCE. The input to MAKE-EXPLICIT is G 2 = ( { g 0 a 0 b 0 } , {  X , X  } ,  X  , g 0 a 0 b 0 , M B , G 1 ). 13 MAKE-EXPLICIT calls PRODUCE( G 2 , g 0 a 0 b 0 ). PRODUCE then seeks to cover b 0 . X  ( x 1 ,x 2 ) w 9  X  X  X   X  ( b 0 .x 1 ,b with productions from G 1 , which is a stand-in for M
A ( G ) . . At line 14 of REPLACE, G 1 is im-proved so that it has the appropriate productions. The productions of M A ( G ) . that must be built to form the complete M B ( M A ( G ) . ) . are shown in Figure 2d. The complete M B ( M A ( G ) . ) . is shown in Figure 2e. Note that because we used this on-the-fly approach, we were able to avoid building all the productions in M A ( G ) . ; in par-ticular we did not build g 0 a 2 w 2  X  w 8  X  X  X  X  X  X  X   X  , while a bucket brigade approach would have built this pro-duction. We have also designed an analogous on-the-fly PRODUCE algorithm for backward appli-cation on linear WTT .

We have now defined several on-the-fly and bucket brigade algorithms, and also discussed the possibility of embed-compose-project and offline composition strategies to application of cascades of tree transducers. Tables 2a and 2b summa-rize the available methods of forward and back-ward application of cascades for recognizability-preserving tree transducer classes. 5 Decoding Experiments The main purpose of this paper has been to present novel algorithms for performing applica-tion. However, it is important to demonstrate these algorithms on real data. We thus demonstrate bucket-brigade and on-the-fly backward applica-tion on a typical NLP task cast as a cascade of wLNT. We adapt the Japanese-to-English transla-
WST wxLT wLT wxLNT wLNT tion model of Yamada and Knight (2001) by trans-forming it from an English-tree-to-Japanese-string model to an English-tree-to-Japanese-tree model. The Japanese trees are unlabeled, meaning they have syntactic structure but all nodes are labeled  X  X  X . We then cast this modified model as a cas-cade of LNT tree transducers. Space does not per-mit a detailed description, but some example rules are in Figure 3. The rotation transducer R , a sam-ple of which is in Figure 3a, has 6,453 rules, the insertion transducer I , Figure 3b, has 8,122 rules, and the translation transducer, T , Figure 3c, has 37,311 rules.

We add an English syntax language model L to the cascade of transducers just described to bet-ter simulate an actual machine translation decod-ing task. The language model is cast as an iden-tity WTT and thus fits naturally into the experimen-tal framework. In our experiments we try several different language models to demonstrate varying performance of the application algorithms. The most realistic language model is a PCFG. Each rule captures the probability of a particular se-quence of child labels given a parent label. This model has 7,765 rules.

To demonstrate more extreme cases of the use-fulness of the on-the-fly approach, we build a lan-guage model that recognizes exactly the 2,087 trees in the training corpus, each with equal weight. It has 39,455 rules. Finally, to be ultra-specific, we include a form of the  X  X pecific X  lan-guage model just described, but only allow the English counterpart of the particular Japanese sen-tence being decoded in the language.

The goal in our experiments is to apply a single tree t backward through the cascade L X R X I X T X  t and find the 1-best path in the application WRTG . We evaluate the speed of each approach: bucket brigade and on-the-fly. The algorithm we use to obtain the 1-best path is a modification of the k-best algorithm of Pauls and Klein (2009). Our al-gorithm finds the 1-best path in a WRTG and ad-mits an on-the-fly approach.
 The results of the experiments are shown in Table 3. As can be seen, on-the-fly application is generally faster than the bucket brigade, about double the speed per sentence in the traditional Table 3: Timing results to obtain 1-best from ap-plication through a weighted tree transducer cas-cade, using on-the-fly vs. bucket brigade back-ward application techniques. pcfg = model rec-ognizes any tree licensed by a pcfg built from observed data, exact = model recognizes each of 2,000+ trees with equal weight, 1-sent = model recognizes exactly one tree. experiment that uses an English PCFG language model. The results for the other two language models demonstrate more keenly the potential ad-vantage that an on-the-fly approach provides X  X he simultaneous incorporation of information from all models allows application to be done more ef-fectively than if each information source is consid-ered in sequence. In the  X  X xact X  case, where a very large language model that simply recognizes each of the 2,087 trees in the training corpus is used, the final application is so large that it overwhelms the resources of a 4gb MacBook Pro, while the on-the-fly approach does not suffer from this prob-lem. The  X 1-sent X  case is presented to demonstrate the ripple effect caused by using on-the fly. In the other two cases, a very large language model gen-erally overwhelms the timing statistics, regardless of the method being used. But a language model that represents exactly one sentence is very small, and thus the effects of simultaneous inference are readily apparent X  X he time to retrieve the 1-best sentence is reduced by two orders of magnitude in this experiment. 6 Conclusion We have presented algorithms for forward and backward application of weighted tree trans-ducer cascades, including on-the-fly variants, and demonstrated the benefit of an on-the-fly approach to application. We note that a more formal ap-proach to application of WTT s is being developed, independent from these efforts, by F  X  ul  X  op et al. (2010).
 Acknowledgments We are grateful for extensive discussions with Andreas Maletti. We also appreciate the in-sights and advice of David Chiang, Steve De-Neefe, and others at ISI in the preparation of this work. Jonathan May and Kevin Knight were supported by NSF grants IIS-0428020 and IIS-0904684. Heiko Vogler was supported by DFG VO 1011/5-1.
 References
