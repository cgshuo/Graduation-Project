 A rooted labeled tree is a fairly general data struct ure that models a wide vari-ety of hierarchical data including parse trees for natural language texts, semi-structured data such as HTML/XML, and biological data such as RNA sec-ondary structures and glycans.

In this paper, we concentrate on a binary classification problem based on kernel methods with support vector machines (SVMs). Let X be the input space (e.g. a set of rooted labeled uno rdered trees in this paper), and Y = { +1 ,  X  1 } be the output domain. A training set is a finite set of training data, denoted by D = { ( x 1 ,y 1 ) ,..., ( x m ,y m ) } X  X  Y . The purpose of the learning procedure in SVMs is to give a decision function f d (  X  ) from a training set D . The learning procedure outputs a decision function f d : X  X  Y so that y i = f d ( x i ) approximates the probabilistic relation between inputs and outputs.

A number of tree structure classificat ion problems have been successfully ad-dressed by kernel methods with SVMs in the past decade. In order to apply kernel methods to a specific domain, the most important task is to design similarity functions, so called kernel functions , between two objects. One of the earliest work on tree kernels was by Collins and Duffy [4], who presented a parse tree kernel as a counting function of common subt rees between two parse trees. In-spired by the parse tree kernel, Kashima and Koyanagi [9] extended it to general rooted labeled ordered trees and propo sed a quadratic-time algorithm. These kernels employ the convolution kernel [ 5] as their design framework by counting all the common subtrees between two trees.

On the other hand, in our previous work [12,13,14,15,16], we introduced an or-dered tree q -gram as a rooted ordered labeled tree isomorphic to a path. We further proposed a spectrum tree kernel [14] and a gram distribution kernel [13] based on the frequencies of all common q -grams embedded in a given tree, which are more efficient and representative than the tre e kernels by Kashima and Koyanagi [9].
In contrast to ordered trees, Kashima , Sakamoto, and Koy anagi [10] recently showed that their approach to design kernel functions inherently for unordered trees , in which the order of sibling nodes is arbitrary, leads to #P-completeness. It is also known that the problem of computing the similarity of trees based on tree edit distance [20] and alignment of trees [7] is intractable. On the other hand, Vishwanathan first presented a fast kernel for unordered trees [17] based on a string kernel using suffix trees. Kailing et al. also proposed a tractable algorithm for computing the structural dissimilarity between unordered trees [8]. The effectiveness of these methods, however, has yet to be proven.

In this paper, we aim at developing an expressive and efficient kernel for rooted labeled unordered trees by circumventing the issues in the previous work. In fact, our kernel counts all the common subtrees with q nodes and at most two leaves, as an extension of all the common paths with q nodes ( q -grams) [12,13,14,15,16] and restricting to all the common subtr ees between two trees [9]. We call such a subtree a bifoliate q -gram .

Our contributions are as follows: (1) we introduce a bifoliate q -gram profile as a sequence of the frequencies of all bifoliate q -gramsembeddedinagiven tree; (2) we design an efficient algorithm for computing a bifoliate tree kernel as an inner product of the bifoliate q -gram profiles of two trees; (3) we apply the bifoliate tree kernel to classifying glycan structures in bioinformatics and compare the performance of the bifoliate tree kernel with the kernel based on the structural similarity of unordered trees proposed by Kailing et al. [8].
This paper is organized as follows: in Section 2, we introduce a bifoliate q -gram and a bifoliate q -gram profile . We also formulate the bifoliate tree kernel of two given trees as an inner product of their bifoliate q -gram profiles. In Section 3, we design an efficient algorithm Bifoliate Profile to compute a bifoliate q -gram profile of a given tree, which runs correctly in O ( qd min( q, d ) ln ) time, where n , d and l are the number of nodes, the depth, and the number of leaves, respec-tively. This implies that we can also compute bifoliate tree kernels efficiently. In Section 4, we apply the bifoliate tree kernel to classifying glycan structures. Our experimental results illustrate the effectiveness of our kernel. Section 5 concludes the paper by summarizing our contributions. We first introduce the basic notions used in this paper. A tree is a connected graph without cycles. For a tree T =( V, E ), we sometimes denote v  X  T instead of v  X  V ,and | T | instead of | V | .A rooted tree is a tree with one node r chosen as its root . For each node v and u in T ,let UP v ( u ) be the unique path from v to u in T .
 Foraroot r of T , we call the number of edges in UP r ( v )the depth of v (in T ) and denote it by dep ( v ). In particular, since UP r ( r ) has no edges, we set dep ( r )=0.Foratree T ,wecallmax { dep ( v ) | v  X  T } the depth of T and denote it by dep ( T ).

The parent of v ( = r ) is the node adjacent to v on the path UP r ( v ). We say that u is a child of v if v is the parent of u .A leaf is a node having no children, and a branch is a node having just two children. We denote the number of all leaves in T by lvs ( T ).

Arootedtreeis ordered if a left-to-right order for the children of each node is given, and it is unordered otherwise. A rooted tree T =( V, E )is labeled (by an alphabet  X  of labels) if there exists an onto function l : V  X   X  such that l ( v )= a ( v  X  V, a  X   X  ). In the remainder of this paper, we simply call a rooted unordered labeled tree and a r ooted ordered labeled tree a tree and an ordered tree , respectively.
 Let T be an ordered tree with the root v and the children v 1 ,...,v m of v . The postorder traversal ( postorder , for short) of T is obtained by visiting v i (1  X  i  X  m ) in order, recursively, and then visiting v .

Let T be an ordered tree with n nodes and suppose that the sequence v 1  X  X  X  v n is the postorder of T .Alsolet p ( v i ) be the index j such that v j is a parent of v i for every 1  X  i  X  n  X  1. Then, we formulate the depth sequence D ( T ), the label sequence L ( T )andthe parent sequence PS ( T )of T as follows.
 For the depth sequence D of T ,wedenotemax { d | d  X  D } by max D .Itis obvious that dep ( T )=max D .
 Example 1. Consider the tree T in shown at the top of Figure 1. The depth sequence D ( T ), the label sequence L ( T ), and the parent sequence PS ( T )of T are given below the tree in the figure.
 In this paper, as an extension of tree q -grams [12,13,14,15,16], we introduce the concept of bifoliate q -grams . Note that we are here only concerned with their structures. Thus, thei r labels are omitted.
 Definition 1. A bifoliate q -gram is a tree with at most two leaves and exactly q nodes, denoted by P q k,b for q/ 2  X  k  X  q  X  2and0  X  b  X  k  X  1and P q q  X  1 , 0 , where k is the depth of a leaf located relative ly far from the root (hereafter called a deeper leaf )and b is the depth of a branch.
 Note that the range of the depth b of the branch varies depending on the depth k of the deeper leaf.
 Proposition 1. The number of bifoliate q -grams is q/ 2 ( q  X  q/ 2  X  1) + 1. Proof. Let p = q/ 2 . Note that the depth k of a deeper leaf varies from p to q  X  2. If k = q  X  i (2  X  i  X  q  X  p ), then the number of bifoliate q -grams is q  X  2( i  X  1). Since i = q  X  k , the number of bifoliate q -grams for k ( p  X  k  X  q  X  2) is 2 k +2  X  q . Hence, the number of bifoliate q -grams is q  X  2 k = p (2 k +2  X  q )+1. We denote the number q/ 2 ( q  X  q/ 2  X  1) + 1 in Proposition 1 by  X  q . Proposition 2. Let be a lexicographic order on depth sequences, where a deeper leaf is regarded as the left-most leaf in ordered trees. Then, the bifoliate q -gram P q k,b is the ( k ( q  X  k  X  1)  X  b +1) -th element under .
 Proof. It is obvious that the first element of a bifoliate q -gram under is P q q  X  1 , 0 . Let j be an integer such that 2  X  j  X   X  q . By Proposition 1, in the case that th element from the first element P q k,k  X  i +1 under for k = q  X  i , P q k,b is the 1+ replacing i with q  X  k , we obtain the statement in Proposition 2.
 Hence, we also denote the j -th bifoliate q -gram under by Q q j (1  X  j  X   X  q ). Example 2. All of the bifoliate 5-grams with their depth sequences are described in Figure 2. Here, the deeper leaf is set to the left.
 Definition 2 ( cf. Zhang &amp; Shasha [19]). Let T and P be trees. Then, we say that P matches T at a node v if there exists a bijection f from the nodes of P into the nodes of T satisfying the following conditions. 1. f maps the root of P to v . 2. Suppose that f maps x to y and x has children x 1 ,...,x l . Then, y has chil-3. l ( x )= l ( f ( x )) for each x  X  P .
 Definition 3. Let T be a tree and ( Q q j ,w ) be a bifoliate q -gram for 1  X  j  X   X  q and w  X   X  q . Then, we say that ( Q q j ,w ) is embedded into T if there exists a node v in T such that ( Q q j ,w )matches T at v . Furthermore, we denote the number of ( Q q j ,w ) embedded into T by L q ( T )[ Q q j ,w ].
 We order all of the strings in  X  q by w 1 ,...,w |  X  | q .For1  X  j  X   X  q ,wedenotethe Definition 4. For a tree T , the following sequence L q ( T ) of the number of every embedded bifoliate q -gram into T is a bifoliate q -gram profile of T . We are now ready to formulate the bifoliate tree kernel of two trees T 1 and T 2 as an inner product of their bifoliate q -gram profiles as follows.
 Definition 5 (Bifoliate Tree Kernel). For rooted labeled unordered trees T 1 and T 2 and a fixed integer q  X  2, the bifoliate tree kernel K q ( T 1 ,T 2 ) is defined as For q = 1, we assume that K q ( T 1 ,T 2 ) denotes the inner product of the label frequency vectors of T 1 and T 2 . In this section, we design the algorithm to compute a bifoliate q -gram profile. First, we prepare subroutines as given in Algorithm 1, where D , L and PS denote the depth sequence, the label sequence an d the parent sequence, respectively, of an ordered tree.

The algorithm pseq ( D ) constructs the parent se quence from a given depth sequence D . The algorithm labels ( i, k, PS ,L ) concatenates the labels from the node indexed by i with length k by selecting nodes and labels according to a parent sequence PS and a label sequence L . X   X   X  X nd  X  denote the concatena-tion of two strings and an empty string, respectively. The algorithm shift table constructs the table shift ( cf. , [12,13,14,15,16]).

Using these subroutines, we can design the algorithm Bifoliate Profile to com-pute a bifoliate q -gram profile of a given tree described as in Algorithm 2. Here, we use an ordered q -gram [12,13,14,15,16], which is an ordered tree with q nodes isomorphic to a path whose depth of the left leaf is k , and we denote it by P q k . We also denote  X  as a lexicographic order on  X  q . Furthermore, the algorithm adopts the table id [ j ][ k ] in order to store the indices of the left leaf of P p k for some p&lt;q . We will show below that p = D [ i ]+2 k +1  X  j for a current depth D [ i ].
 Example 3. Consider the tree T in Example 1 (Figure 1) and let q be 5. Note first that the result applying the algorithm shift table to the depth sequence D ( T ) is given in Figure 3.

Figure 4 describes the t ransition of the table id in the algorithm Bifoli-ate Profile . Here, the first and second lines are the depth sequence D ( T )of T and index i , respectively. The numbers in bold in the i -th column satisfies the condition of line 7 at the ( i + 1)-th iteration of the main loop.
Consider the indices 1, 2 and 3 in the third column for index 4. They denote the left leaves of ordered 5-grams whose index of the right leaf is 4.
For index 1  X  id [3][2], the algorithm Bifoliate Profile constructs the label w 3 = D [4]+2 = 5. Since p =3+2  X  2+1  X  3=5= q , the algorithm Bifoliate Profile constructs w 3 =  X  and increments the frequency of bifoliate 5-gram ( P 5 2 , 0 , bbbab ), where | w 1 | =2.

Moreover, for index 2  X  id [3][2], the algorithm Bifoliate Profile constructs the and w r = l ( v 4 )= b , w is set to baabb by replacing w 1 with w 2 . Similarly to the case for index 1, the algorithm Bifoliate Profile increments the frequency of bifoliate 5-gram ( P 5 2 , 0 , baabb ).

On the other hand, for index 3  X  id [2][1], the algorithm Bifoliate Profile constructs the label sequences w 1 = l ( v 3 )= b and w 2 = ba .Since | w 1 | &lt; | w 2 | and w r = l ( v 4 )= b , w is set to babb by replacing w 1 with w 2 .Furthermore,it holds that 3 = D [4] + 2 = 5. Since p =3+2  X  1+2  X  3=4and q  X  p =1, the algorithm Bifoliate Profile constructs w 3 = l ( v 6 )= a and increments the frequency of bifoliate 5-gram ( P 5 3 , 1 , bbbab ), where | w 1 | + q  X  p =2+5  X  4=3.
As a result, we obtain the frequencies of bifoliate 5-grams in T that are non-negative for every P q k,b as in Figure 5.
 Theorem 1. For a tree T ,let D = D ( T ) , L = L ( T ) , n = | T | , d = dep ( T ) and l = lvs ( T ) . Then, the algorithm Bifoliate Profile ( q, D, L ) described in Algo-rithm 2 is correct and runs in O ( qd min( q, d ) ln ) time.
 Proof. First, we discuss the correctness of the algorithm Bifoliate Profile .
Consider an ordered p -gram P p k with left leaf v and right leaf u ,where j = dep ( v )and d = dep ( u ). Also let s be j  X  k . Then, it holds that p = d +2 k +1  X  j , and s is the depth of root r of P p k (Figure 6(a)). This corresponds to lines 5 X 6 in the algorithm Bifoliate Profile .

Let k be the depth of a deeper leaf of P p k .If q  X  p&gt;s , then there exists no bifoliate q -gram P q k + q  X  p,q  X  p .Otherwise,if q  X  p  X  s (line 7), then the algorithm Bifoliate Profile finds the label sequences w 1 on the path from v to the child of r on UP r ( v )and w 2 on the path from u to the child of r on UP r ( u ) (lines 9 X 10) using the subroutine labels . By comparing the length of w 1 with that of w 2 ,the algorithm Bifoliate Profile determines which of v and u is a deeper leaf, and it then constructs the label sequence w 12 r = w 1  X  w 2  X  w r (where w r = l ( r )) of a bifoliate q -gram P p | w 1 | , 0 by setting v (corresponding to w 1 ) to a deeper leaf (lines 11 X 12).
Furthermore, if j = d + k , then it holds that p = q , so the algorithm Bifoli-ate Profile finds a path from r to r in Figure 6(b) that is the root of a given tree P (line16).Otherwise,if j = d + k and p = q ,thatis, u is the root of an or-dered q -gram P q q  X  1 , then the algorithm Bifoliate Profile increments the bifoliate q -gram ( P q q  X  1 , 0 ,w 12 r )intable P (line 17).
The algorithm Bifoliate Profile maintains the indices already searched in a for every ( j, k )  X  shift [ D [ i ]], the algorithm Bifoliate Profile shifts the indices in and the left leaf of P q k , respectively. In this case, the algorithm Bifoliate Profile finishes searching for P q k and begins searching for P q k +1 .

Next, we consider the running time of the algorithm Bifoliate Profile .Since | id [ j ][ k ] | X  l and labels ( i, k, PS ,D ) runs in O ( k ) time, the running time of the routine from lines 8 to 17 is O ( ql ). Here, in lines 16 and 17, we use the hash function to increment the element of P [  X  ][  X  ][ w ] (by encoding a string w as a numeral), so the running time is assumed to be constant. Furthermore, the al-gorithms pseq ( D )and shift table ( q, D ) (line 1) run in O ( n )and O ( qd )time, respectively. Since | shift [ D [ i ]] | X  q for every i , the algorithm Bifoliate Profile runs in O ( n +( d  X  min( q, d )  X  ql + ql ) n )= O ( qd min( q, d ) ln )time. In this section, we evaluate the effectiven ess of our kernel by empirically compar-ing its predictive performance in glycan structure classification problems with two other kernels for unordered trees. G lycans are defined as the third major class of biomolecules next to DNA and proteins and play important roles in various fundamental biological processes such as cell-cell interactions. Glycan structures are modeled as ei ther ordered or unordered trees according to its con-text since the level of appropriate abstractions in modeling the structures depend on the problem to be addressed (cf. [1] ). In this paper, we focus on unordered tree modeling of glycans.

We consider the following two competitors to the bifoliate tree kernel. One is the tree kernel by Vishwanathan [17] based on a string kernel, and the other, denoted by K H ( T 1 ,T 2 ), is defined based on three simple vectors used in the dissimilarity measure proposed by Kailing et al. [8], which are the vectors of the degree histogram V d ( T ), the height histogram V h ( T ), and the label histogram V ( T ) for an unordered tree T . We define the kernel K H ( T 1 ,T 2 ) for two trees T 1 and T 2 as the sum of the inner products of each pair of vectors.

These kernels were implemented in Ruby and executed on a Windows XP ma-chine with a Pentium M processor running at 1.50 GHz and 750 MB of memory. We used LIBSVM [3] as the SVM implementation, and we computed the area under the ROC curve (AUC) for measuring performance. AUC is the prevailing perfor-mance measure for a decision function with a kernel that separates positive exam-ples from negative ones. The AUC values range from 0.5 to 1.0, where the value 0.5 indicates a random separation and the value 1.0 indicates a perfect separation.
The glycan data that we used in the first experiment basically follows Hizukuri et al. [6]; we retrieved the glycan structures from the KEGG/GLYCAN database [11] and used the annotations from the CarbBank/CCSD database [2]. Based on these annotations, we extracted those structures annotated with blood com-ponents, labeled as leukemic cells , and other non-leukemic blood components ( erythrocyte , serum ,and plasma ). Leukemia is a cancer of the blood induced by an abnormal proliferation of blood components (usually white blood cells). In the second experiment, we employ two data sets from colon, i.e. glycans related to colon cancer, and others not related to cancer but related to the colon. We retrieved 29 distinct node labels. We have summarized the data used in our experiments in Table 1.

Figure 7 shows the comparison of the results by the proposed method while vary-ing the parameter q . The kernel by Vishwanathan [17] is indicated by  X  X S X , and the kernel based on dissimilarity proposed by Kailing et al. [8] is indicated by  X  X ail-ing. X  All of the performance measures were calculated with 5-fold cross validation.
Our tree kernel achieves the best performances at q =5and q =3forthe leukemia and colon data sets, respectiv ely. The tree kernel due to Vishwanathan also achieves relatively good performance in spite of its restricted expressive power. Since the nodes near the leaves tend to determine the functionalities of glycans, this data set seems to be well-suited to this tree kernel.

Also, it is interesting to see that the value of q achieving the highest predictive performance varies between the two ex periments, which indicates that the q size of the most characteristic feature s varies according to the data set. This corresponds with previous knowledge that structure of glycan biomarkers are varied depending on the cell population being studied. We have presented a novel kernel functi on for rooted labeled unordered trees. Given two trees, our tree kernel counts the number of common bifoliate q -grams between them, which are trees with at most two leaves and a fixed number of nodes q . We conducted comparative experiments to illustrate the efficiency of our kernel by applying it to the classification problem of glycan structures. Our kernel outperformed the existing kerne ls for unordered trees in its predictive performance. The experiments also su ggested that the performance depends on the fixed number q , and the optimal value q to give the best performance depends on the data set.

In the future, we plan to design a new tree kernel based on the bifoliate tree kernel so that we can select an appropriate parameter q to achieve better average performance regardless of the data set.

