 Graph is widely used to model complex and schemaless data, ranging from XML, proteins, to chemical compounds. The key problem for many graph-related applica-tions is how to efficiently process graph query and retrieve corresponding sub-graphs. For achieving the best query performance in graph-structured data, effective and ac-cially needed by determining the optimal query-execution plan. Accurate selectivity estimation becomes challenging as it relies on exact graph statistics information which always can X  X  be afforded in real-life system for time and space constraints.. 
As the standard for data exchange and integration nowadays, XML is a kind of di-rected labeled graph, which is self-describing and cycle-enabled in nature. The under-lying labeled graph model of XML consists of element nodes, which can be simple/complex type value node or composite reference node (i.e. id/idref node[2]). For all the query languages on graph, pattern-based query description is a common and essential feature. This kind of query is more complex than SQL in RDBMS be-cyclic query pattern. However, similar to RDBMS, accurate selectivity estimation for cost evaluations for different search and traversing plans. The following example is expressed in XQuery[3]. Figure 1 is a query expression and its corresponding structure. 
The purpose of this complex graph query is to find the names of all professors who gave  X  X atabase X  class in 2000. For efficient execution of this query, we need to know //Prof/name. As an assumption, selectivities of path //Prof/Class= X  X atabase X  and //Prof/Year = X 2000 X  are 20 and 400 respectively, which means totally 20  X  X atabase X  //Prof/Year= X 2000 X  secondly. On the other hand, with selectivity estimations, opti-mizer in RDBMS also becomes powerful to determine the best Join execution order. In both scenarios, query optimization highly depends upon efficient and accurate selectivity estimation. 
As a summary, our contributions are listed as follows: presents SMT refining approach for selectivity estimation. Section 5 gives three use-ful compressing techniques. Section 6 contains selectivity estimation methods on SMT. Section 7 is performance evaluation. Section 8 presents our conclusion. Various selectivity estimation approaches have been proposed for path query on semi-structured data, such as Path Tree and Markov Table presented in [1], which illustrate selectivity estimation methods for single path query in large-scale web data. Markov Table [1] adopts a set of pruning and aggregation techniques on the statistics informa-tion. The approach for twig query estimations is discussed in [5], which presents CST with value constraints on leaf nodes. It is a general selectivity estimation method for twig query so far. 
Besides, A(k)[7] and D(k)[4] give new index techniques on XML data, which also can be treated as graph-structured data statistics collection methods. The concept of k-bisimilarity is introduced in A(k) index, which use a parameter k to adjust index struc-For long path, a big k is suitable; oppositely, a small k is fit for short path. Each ele-ment in D(k) index always contains two attributes: one is the supported k, the other is the data nodes contained by this element. However, index is the presentation for data element and path are key characteristics people concern. Another aspect different from index technique is the more strict memory constraint, which is affected by real-life system X  X  resource restriction. 
XPathLearner [8] is an on-line method for refining statistics information by gather-value distribution information with a self-tuning mechanism. However, when the system is running under heavy workload, the on-line tuning method poses extra bur-den which sometimes can X  X  be compensated by the benefits it gives. Besides, once false feedback is taken effect, it lacks the ability of withdrawing and recovering. In general, a common graph statistics collection model can be described as follow: An corresponding to v X  in S. 
Figure 2 gives the sample graph-structured data which is expressed in XML by in-volving ID/IDREF elements [2]. The concepts of  X  X isimilarity X  and  X  X -bisimilarity X  were proposed by 1-index [10] and A(K)-index[7] respectively. For the concern of different statistics collection granularity,  X  X -bisimilarity X  can be used as the aggrega-same and unique node in S, which we call S(0) , the base statistics collection status in S(0) X  X  coarseness, some false and cyclic paths may be introduced during its genera-reason why it can X  X  achieve satisfied selectivity estimation results.. 
In Markov Table [1], the selectivity estimations of paths with length m depend only process is modeled as a Markov process of order m-1, so this approach is called proach, we extend it to complex twig query in graph-structured data with new features structured data, we propose Theorem 1 . all the edges leads to v, can be denoted as follows: The computation for the frequency of edge (u i , v) mainly considers two factors. to v. Freq(v) is the frequency of the node v in S. Thus, the product of these two fac-tors is the approximation for frequency of edge (u i , v). This idea is also addressed in assumption. 
Applying Theorem 1 on the S(0) in Figure 3(a), we can obtain the Markov Table with path length m=2 in Figure 3(b), which is the initial statistics collection for graph-structured data in Figure 2. Actually, in Figure 3(b), we can see the frequencies of path  X  X R/D X ,  X  X R/C X  are 2*(19/20) and 5*(19/20) respectively which are computed by Theorem 1. Since the that can X  X  supply more exact information about correlations and distributions for them. Because of the accuracy limitation of S(0), we need to investigate optimization exploit the local bi-directional reachability about edges in graph statistics collection S. Two definitions are proposed to describe the types of edges in S, which consider the forward and backward inclusions on the edges. Definition 1. Forward-Inclusion (FI): For each edge (u, v) in graph statistics collec-tion S, if u can reach no nodes except v, then the type of (u, v) is FI. lection S, if v can only be reached by u, then the type of (u, v) is BI. Therefore, all the edges in S can be classified into 4 types: FI, BI, FI theorems as evidences supporting accurate selectivity estimations. all edges (t i /t i+1 ) in P are BI, then Freq ( t n ) is an accurate estimation for path P. reaching some node in extent(t n ). As an example for twig query in sample graph data, the query P = /Tsinghua[Cs/C /DR/IR]/Ds/D has the purpose to find all the D nodes having the pattern matched with the structure Figure 4(a) describes. Because Cs/C, C/DR and DR/IR have types of FI in common, as Theorem 3 defined, Freq (P) = Freq (/Tsinghua[Cs]/Ds/D) which is simplified by pruning Cs/C, C/DR and DR/IR. The intrinsic sense of this simplification is based on a fact that the existent prob-ability of sub path Cs/C/DR/IR is a hundred percent which is concluded from Theorem 3 . So the Figure 4(b) shows the simplified structure for selectivity estimation. with goals to depict the graph statistics collection containing more BI and FI type edges. Optimization Rule 1: Given an edge (u, v) with FI  X  type in graph statistics collection and (u 2 , v) are FI * T and T respectively. Optimization Rule 2: Given an edge (u, v) with BI  X  type in graph statistics collection and (u, v 2 ) are BI * T and T respectively.
 Optimization Rule 3: Given n edges with FI  X  types which start from node u in graph tion, the average frequency of these n edges is a , which is computed by the formula of Avg(u, v i )= connected by u 1 and Freq(u 2 , v j )  X  a with v j connected by u 2 . Optimization Rule 4: Given n edges with BI  X  types which start from node u in graph tion, the average frequency of these n edges is a , which is also computed by the for-mula of Avg(u i , v)= with ui leads to v 1 and Freq(u j , v 2 )  X  a with u j leads to v 2 .
 Clearly, dynamic combination of optimization rules offers a flexible and satisfied solution to produce more precise graph statistics collections and selectivity estima-varied data is an important advantage of our approach which also will be illustrated in following part. Basing on the optimization rule s, we give a concrete demonstration on the SMT construction algorithm: SMTBuilder. show the statistics collection and SMT by applying RuleSet {1} on IR/D of S(0). tion and optimized SMT Note that SMT represents an accurate approximation of graph-structured data, which may not be fit in the available memory for its large size. This problem is also bewared in our former work [6]. An efficient and natural idea to compress SMT is discarding and grouping the paths with the lowest frequencies in SMT. With respect to compen-represented in the deleted paths by adding them into groups of deleted paths. Though with coarser granularity, high scalability can be achieved by appropriate size of statis-tical information. The precision under compressed SMT turns out to be somehow the same or quite close to accurate approximation, which will be demonstrated by our experiments in real life data. Na X ve Method : The first method for compressing SMT, which we call it Na X ve method, uses the strategy of  X  X imply discarding X . Low-frequency paths in SMT are simply discarded without further grouping. When using SMT to estimate selectivity by Na X ve compressing, if any of the required paths is not found, we estimate a selec-tivity of zero. In Na X ve compressing, it is appropriately assumed that paths, which do not exist in the compressed SMT, neither exist in the original SMT. Forward Grouping Method : The second method for compressing SMT, which we */*/* for all the deleted paths with length 3. We develop the algorithm SMTFor-wardGrouping as follow:. length 3, say A/B/C from original SMT, we look up DS for the paths with same start tag with A. If A/B/D exists in DS, we remove A/B/D from DS as well as A/B/C from original SMT, add A/B/* to SMT to represent these two deleted paths with frequency of summing freq(A/B/C) and freq(A/B/D). If no such prefix-A path exists in DS, we just remove path A/B/C from original SMT and add it to DS. At the end of compress-ing, paths remaining in DS are compressed to complete * paths, such as */*, */*/* etc. The average frequency of these remained paths is the frequency for their correspond-quentially. Backward Grouping Method : The third method for compressing SMT, which we call backward grouping, adopts an opposite direction to group low frequency paths con-ally qualify for deletion, then they are comb ined into */B. With SMT compressed by backward grouping method, selectivity also needs estimating reversely. It is inevitable that backward grouping may delete fewer paths to compress SMT, but it has advan-tages in estimating complex queries with wildcard  X // X  and  X * X . racy enhancement in selectivity estimation by real case. 
Theorem 1 in section 3 defines a universal method to calculate the frequency of computed by the following formula based on SMT with path length up to m: 
Equation (2) can be inferred from Theorem 1 extending from length 1 to m. Essen-formation needed in estimations. Given a complex twig path query having two sub /t with length k. According to the statistical model for twig query selectivity estimation in [11], we can use following equation to compute the selectivity of P: in which r(P1) denotes occurrence probability of P1, also posterior beliefs with r(P2|P1) and r(P3|P1). Because of the path independence assumption in [11], we have r(P2|P1)
As a detail example, the complex path query is P=/Tsinghua/Ss/S[DR/IR/D]/CR for P can be decomposed into following parts according to equation (3). which derivate from the formulas in [11]. 
If without SMT approach, we look up original Markov Table in Figure 4 to esti-mate the selectivity of P. r(Tsinghua/Ss/S)= r(S/DR/IR/D)= [4 DR/IR, IR/C, IR/D are converted to CR/IR2, DR/IR1, IR2/C, IR1/D respectively. Therefore, r(Tsinghua/Ss/S)= r(S/DR/IR/D)=
So, Freq(P1[P2]/P3) = [4 totally 88 percentages decrease. In this section, we report our experiments that validate the efficiency and flexibility of SMT. The experiments mainly focus on three parts: efficiency of SMT by comparing with CST[5], the benefits of flexible combination about Optimization Rules, and different compressing methods on SMT . Experiment Data and Query Set. We use three kinds of standard XML testing data-sets in our experiments: Shakespeare[12], XMark[13] and DBLP[9]. Table.1 records the major features of these three datasets with the terms of element number, document Rules applied once for each S(0). 
We choose 1000 complex path queries for each dataset. These queries are obtained tion in SMTBuilder. Evaluation Criterion AER and Experiment Results. We use AER, Average Error brought by different methods, queries, memory sizes, and graph data. CST[5] both do well in trading off the accuracy and memory space, in which Correlated Suffix Trees KB in our experiments. Experiment 1: Comparison between SMT and CST. 
In Figure 6, with the change in memory space constraints, the results of compari-sons between SMT and CST show the advantages of SMT in AER. Optimization Rules 1 to 4 are repeatedly applied until reaching the memory size constraint. Experiment 2: AER with different Rule Sets. 
Figure 7 shows results by different choosing and combination strategies of optimization rules named ORs. Experiment 3: Experiments on different compressing methods. 
There are three sub conclusions we can draw from three-step experiments. First, with the comparisons between SMT and CST on three standard datasets, we believe that SMT has advantages in accuracy of selectivity estimations. Second, different usage of optimization rules fits for different features of real-life data. From the results above and real data features considered, optimization rules 1, 2 are more suitable for graph data with less tags and more long paths. Oppositely, optimization rules 3, 4 are good at graph data with more tags and instances for each tag. Third, Figure 8 gives us evidences to believe our compressing methods on SMT bring advantages in estima-tions of complex path queries under rigorous memory constraints. In this paper we presented SMT, a precise and adaptive approach for selectivity esti-mation of complex graph query. Our approach has been validated to be precise and scalable for estimating the selectivities of complex graph queries. With the trading off between memory space constraints and accuracy, we exploit the important features of local forward/backward inclusions and propose 4 Optimization Rules for SMT con-namic characteristics on optimization rules choosing and combination. Three affective and practical techniques: Na X ve, Forward Grouping and Backward Grouping are pro-posed for compressing SMT to meet rigorous memory constraints. Our experiments show that SMT performs better for selectivity estimations, especially for complex graph queries. This work also can be extended to cyclic graph queries based on SMT X  X  capabilities of collecting statistics and refining. [1] A. Aboulnaga, A. R. Alameldeen, and J. F. Naughton. Estimating the selectivity 
