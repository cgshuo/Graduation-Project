 Recent works in network analysis have revealed the existence of network motifs in biological networks such as the protein-protein interaction (PPI) networks. However, existing motif mining algorithms are not sufficiently scalable to find meso-scale network motifs. Also, there has been little or no work to systematically exploit the extracted network motifs for dissecting the vast interactomes.

We describe an efficient network motif discovery algo-rithm, NeMoFinder, that can mine meso-scale network mo-tifs that are repeated and unique in large PPI networks. Using NeMoFinder, we successfully discovered, for the first time, up to size-12 network motifs in a large whole-genome S. cerevisiae (Yeast) PPI network. We also show that such network motifs can be systematically exploited for indexing the reliability of PPI data that were generated via highly erroneous high-throughput experimental methods.
 H.2.8 [ Information Systems ]: DATABASE MANAGE-MENT X  Database Applications, Data Mining Algorithms, Experimentation, Performance Network motif, Graph mining, Protein-protein interaction network
Recent works in network analysis [15] have revealed that the topology of complex natural networks such as protein- X  Contact author.
 Copyright 2006 ACM 1-59593-339-5/06/0008 ... $ 5.00. protein interaction (PPI) networks are far from random. Many of these networks have been shown to exhibit such common global topological features as the  X  X mall world X  and  X  X cale free X  properties. It turns out that in addition to these global topological characteristics, many local topo-logical patterns can also be detected in the large complex natural networks. For example, Milo et al. [15] discovered various significant patterns of local connections that oc-curred more frequently in complex networks than in ran-domized networks. They called these recurring local topo-logical substructures as  X  X etwork motifs X . While relatively less widely studied than the global topological features, such network motifs can lead to better understanding about var-ious classes of complex networks, as some network motifs may be particular to specific classes of networks. For ex-ample, certain triad or tetrad motifs are specific topologi-cal patterns that are found to appear in biological networks rather than in other networks [15]. The presence of such net-work motifs also reveals the basic structural elements that underlie the hierarchical and modular architecture of such complex natural networks as PPI networks.

Researchers have only recently begun to employ network motifs in exploring the interactomes; for example, Saito et al. [17, 16] used manually derived network motifs to detect false positives in highly erroneous PPI networks, while Al-bert et al. [1] used them to predict PPIs. These pioneering works have achieved promising results even though the net-work motifs used in these works were rather limited X  X aito et al. had used only 5 predefined network motifs of size 3 in their latest work on false positive detection [16], while Albert et al. had used only 4 predefined small network mo-tifs for predicting interactions. This shows that the network motifs can provide a framework for the effective dissection of the complex PPI network based on the underlying structural principles.

As many of the relevant processes in biological networks have been shown to correspond to the meso-scale (5-25 genes or proteins) [19], it would be interesting to investigate if it is advantageous to use network motifs that are of equivalent sizes. However, existing network motif discovery algorithms [15, 9] are not applicable as they are mostly enumeration-based and limited to extracting smaller network motifs (up to size 8) for the following reasons: 1. The number of network motifs candidates increases ex-2. Interesting network motifs are typically repeated and 3. The graph isomorphism problem, which is the essential
Such limitations impact the applicability of motif discov-ery approach for biological applications, as meso-scale net-work motifs are beyond the reach of existing exhaustive enu-meration algorithms.

In this paper, we present an efficient graph mining al-gorithm called NeMoFinder to discover meso-scale repeated and unique network motifs in a large, genome-scale PPI net-work for biological applications. The proposed algorithm utilizes repeated trees to partition a network into a set of graphs. We introduce the notion of graph cousins to facil-itate the candidate generation and frequency counting pro-cesses. Experiment results indicate that NeMoFinder is scal-able and outperforms existing network motif discovery meth-ods. We also use the network motifs that are mined from the real-life biological networks to detect false positives in the highly erroneous PPI network obtained from biological experimental methods. The experimental results demon-strate that the actual meso-scale network motifs extracted from the biological interaction networks can achieve better performance than using small, predefined ones for assessing the reliability of PPIs from conventional high-throughput experiments.

The rest of this paper is organized as follows. Section 2 introduces the basic concepts. Section 3 describes the re-lated work in network motif algorithms. In Section 4, we describe the proposed NeMoFinder algorithm. Section 5 presents the comparative results of using NeMoFinder for discovering network motifs for S. cerevisiae PPI networks. In Section 6, we show how the extracted network motifs can be used to validate the interactions in a PPI network. Finally, we conclude in Section 7.
In this work, we model a PPI network as an undirected graph G =( V, E ) where each vertex in V represents a unique protein, and each edge in E between two vertices v A and v indicates that there is an interaction detected between the corresponding proteins A and B . We exclude self-loops from G here, as we are only interested to see the effectiveness of graph topology between proteins (see section 6).

By definition, a network motif is a frequently occurring subgraph pattern in a network (in this case, a large genome-wide PPI network such as the Yeast PPI network that con-sists of 4341 vertices and 10199 edges). The class of network motifs that we are interested in extracting from the inter-actomes are unique non-random subgraphs [15] that occur repeatedly in the underlying biological network.
 Let f g be the number of occurrences of a subgraph g in a PPI network G .Wesaythat g is repeated if f g is more than some user-specified value F .

Let f g rand i be the frequency of g in a randomized net-work G rand i ,for1  X  i  X  N ,where N is the number of the randomized networks. Let s g be the number of times f g is equal or greater than f g rand i ,1  X  i  X  N , over the total number of randomized networks N .Wesaythat g is unique if its s g is more than some user specified value S .
Definition 2.1. Network Motif. Anetworkmotif g in a PPI network G is a connected, unlabelled and undirected topological pattern of inter-connections that is repeated and unique in G .

Note that it is common for proteins and their interac-tions in complex biological networks such as PPI networks to participate in multiple biological functional modules. It is therefore perfectly possible for multiple vertex-or edge-overlapping subgraphs to be simultaneously active at any time. Hence, during the subgraph counting process, we must consider patterns with arb itrary overlaps of vertices and edges. This results in a computationally more complex problem as the frequency of network motifs does not have the downward-closed property in this case.

In addition, the uniqueness property of a network motif is also not downward-closed as a result of allowing vertex-and edge-overlap in the network motifs. When a motif g extends (or reduces) to its supergraph (or subgraph), the decrease (or increase) of f g and f g rand is non-deterministic. This means that given a network motif g , we cannot directly in-fer whether the supergraphs and subgraphs of g are unique. In fact, even when we have found a non-unique motif, we still have to generate its supergraphs and check for their frequencies and uniqueness. This implies that determining the uniqueness value of a motif is also computationally ex-pensive.
In terms of biological network motif mining, the pioneer-ing work by Milo et al. employed an exhaustive search algo-rithm that counts all the subgraphs of a given number of ver-tices. As such, they could only discover small network motifs in the form of 3-vertex and 4-vertex subgraphs. Kashtan et al. [9] developed a more efficient sampling method to esti-mate the relative frequencies of subgraphs. Their method was useful for analyzing very large networks and for detect-ing high-order motifs since the runtime is independent of the network size. However, the sampling approach cannot be guaranteed to discover the complete set of network mo-tifs. It also does not scale for large-size network motifs (the algorithm takes about 2 hours to find a size-8 motif in the network of transcriptional regulation of E. coli with 423 ver-tices and 519 edges).

On the other hand, the computationally savvy graph min-ing community has also been diligent in developing various algorithms to efficiently discover frequent subgraphs. The initial algorithms, notably the AGM [8] and FSG [10], were devised to find all the frequent subgraphs in a large graph database efficiently through the extension of the market bas-ket analysis. The algorithms utilize the Apriori property to discover frequent subgraphs level by level. The gSpan [21] algorithm discovers frequent substructures by using a DFS-based canonical representation of graphs and enumer-ated the search space in a depth-first order. The FFSM [6] method improves the performance of gSpan by reducing redundant subgraph candidates through a vertical search scheme with join and extension operations. Finally, the SPIN [7] algorithm overcomes the problem of cycles in graph by generating the frequent substructures hierarchically in two steps: starting from trees, and then extending the fre-quent trees to graphs.

All the above works have focused on mining subgraphs from a collection of graphs, and considered only the fre-quency but not the uniqueness property of subgraphs. Fur-thermore, in these works, the frequency of a subgraph is determined by the number of global graphs that the sub-graph occurs in, regardless of whether the subgraph occurs many times within a particular graph. This is computation-ally easier than the network motif discovery problem where the frequency of a motif is determined by the number of oc-currences, including vertex-and edge-sharing ones, within one large and complex graph.

Kuramochi et al. [11] designed two methods hSigGram and vSigGram to look for frequent subgraphs in a sparse graph. These methods first determine the number of edge-disjoint occurrences of a subgraph based on approximate and exact maximum independent set computations and then use it to prune infrequent subgraphs. However, the methods are not suitable for biological applications where a protein or an in-teraction can participate in multiple functional modules, in other words, the occurrences of a motif can overlap arbi-trarily in a graph, which is a much more computationally challenging counting problem.
 The FPF method by Schreiber et al. [18] extends hSig-Gram and vSigGram to find frequent subgraphs with arbi-trary overlap. FPF uses the concepts of pattern tree and generating parent to prune redundant subgraph candidate generation. However, the method is expensive as it has to perform subgraph isomorphism test for all candidates. Fur-thermore, it is unable to prune the non-promising subgraphs as the frequency counting does not satisfy the downward closed property.
In this work, we propose a network motif discovery algo-rithm called NeMoFinder to discover repeated and unique meso-scale network motifs in a large PPI network (Algo-rithm 1).

The input to the algorithm is a PPI network G ,auser defined frequency threshold F , a user defined uniqueness threshold S , and a user defined maximal network motif size K . The output of the algorithm is a set U of repeated and unique motifs from size 3 to size K . Note that a subgraph with k vertices is said to be a size-k subgraph. The pro-posed algorithm consists of three main steps. First, we find repeated subgraphs in the PPI network (Lines 4-15). Then we check the frequency of the repeated subgraphs in the randomized networks (Lines 16-21). Finally, we determine the uniqueness values of the the repeated subgraphs (Lines 22-28).
 We illustrate the algorithm using the example graph G in Figure 1. Suppose we want to find all the motifs up to size 5 ( i.e., K =5)from G . We let the frequency threshold F =2, and the uniqueness threshold S =0 . 95.
 Algorithm 1 NeMoFinder 1: Input : G -PPI network; 2: Output : U -Repeated and unique network motif set; 3: D  X  X  X  ; 4: for motif-size k from 3 to K do 7: D  X  D  X  T ; 8: D  X  T ; 9: i  X  k ; 10: while D =  X  and i  X  k  X  ( k  X  1) / 2 do 12: D  X  D  X  D ; 13: i  X  i +1; 14: end while 15: end for 16: for counter i from 1 to N do 18: for each g  X  D do 20: end for 21: end for 22: U  X  X  X  ; 23: for each g  X  D do 25: if s  X  S then 26: U  X  U  X  X  g } ; 27: end if 28: end for 29: return U ; Step 1. Discover Repeated Subgraphs.

The discovery of repeated size-k subgraphs in a PPI net-work, 2 &lt;k  X  K , involves the following three steps: Step 1.1 Find Repeated Size-k Trees.

Algorithm NeMoFinder starts by finding the size-2 tree t 2 in G . Then the algorithm extends t 2 to a size-3 tree, size-4 trees, etc., until size-K trees are obtained. Figure 2 shows all the size-2 to size-5 trees. Note that we have two size-4 trees ( t 4 1 , t 4 2 ) and three size-5 trees ( t 5 1 , t
When a size-k tree t k is formed, NeMoFinder counts its occurrences in G . If the occurrences of tree t k is more than the user given threshold, then t k is a repeated tree, and it is added to the set T k .

In our example, the occurrences/frequencies of the various size trees are as follows: f t 2 =7, f t 3 = 13, f t 4 1 =6, f except for the frequency of t 5 1 are more than the user given threshold of 2. Thus we have T 2 = { t 2 } , T 3 = { t 3 { t Step 1.2 Use Repeated Size-k Trees to Partition Graph.
Next, we use the size-k trees in T k to partition the graph G into a set of graphs GD k such that each graph G k j in GD embeds a size-k tree in T k ,2  X  k  X  K and 1  X  j  X | GD k
Consider the trees t 4 1 and t 4 2 in Figure 2. Figure 3 and 4 shows the occurrences of t 4 1 and t 4 2 in G .Weuse t 4 1 and t 4 2 to partition the PPI network G to obtain the set of graphs GD 4 = { G 4 1 ,G 4 2 ,G 4 3 ,G 4 4 G 4 5 } (Figure 5). Note that each graph in GD 4 embeds the tree t 4 1 and/or t 4 2 Step 1.3 Perform graph join operation to find repeated size-k graphs.

For each tree t in T k , we generate size-k subgraphs with k  X  1 edges (the rules for generating the subgraphs are given in Section 4.1). Then we join t with each of these subgraphs to generate size-k subgraphs with k edges. The latter are added to the candidate set C k .

Figure 6 shows the 4-vertex 3-edge subgraphs, h 1 ,...,h 5 generated from the two size-4 trees t 4 1 and t 4 2 in T 4 join t 4 1 with h 1 and h 2 ,andjoin t 4 1 with h 3 , h 4 to generate 4-vertex 4-edge subgraphs. Figure 7 shows the subgraphs obtained after joining t 4 1 with h 1 ,and t 4 2 h . The non-redundant subgraphs g 1 1 and g 1 2 are added into the candidate set C 4 .

For each subgraph g  X  C k , we check its occurrences in GD k . If the occurrences of g is more than the threshold F ,weadd g to the set D k . In our example, f g 1 1 =2and f g 1 2 =5. Thus, g 1 2 is a repeated subgraph and is added to the set of frequent subgraphs D .

Next, we use the repeated subgraphs obtained to gener-ate all the possible k -vertex and k -edge subgraphs. These repeated subgraphs are joined with the newly generated sub-graphs to get ( k + 1)-edge subgraphs. The repeated ( k +1)-edge subgraphs are added to D . This process continues until a complete graph of k  X  ( k  X  1) / 2 edges is obtained, or no repeated subgraph can be found.

Figure 8 shows the 4-vertex and 4-edge subgraphs, h 6 and h , generated from the repeated subgraph g 1 2 .Wejoin g 1 2 with h 6 and h 7 to get a 4-vertex and 5-edge subgraph g 2 Figure 9). Since the frequency of g 2 in GD 4 is not more than 2, it is not a repeated subgraph and the algorithm stops.
At the end of Step 1, the algorithm outputs the set D which contains all the repeated trees and subgraphs from size-2 to size-K .
 Step 2. Determine Subgraph Frequency in Random-ized Networks.

Next, we use the Markov-chain algorithm [12] to gener-ate randomized networks G rand i (1  X  i  X  N ) by swapping randomly selected interactions, as was done in [15]. This ensures that the randomized networks have the same single-vertex characteristics as the PPI network, i.e., each vertex in the randomized networks has the same number of neigh-Figure 6: Generate 3-edge subgraphs from size-4 trees. bors as the corresponding vertex in the PPI network. We check the frequency of the subgraphs in D in each of the randomized networks G rand i (1  X  i  X  N ). Theprocedureis similar to Step 1.
 Step 3. Compute Uniqueness of Subgraphs.

Finally, we compute the uniqueness value for each sub-graph in D based on its frequencies in the input PPI network and the randomized networks.

NeMoFinder is scalable because the repeated trees natu-rally partitions the network into a set of graphs GD .Hence, the problem of counting the frequency of a size-k subgraph g in the network is reduced to the problem of finding the num-ber of graphs in GD that contain the subgraph g ,whichis naturally downward closed.

In order to reduce the computational complexity, NeMoFinder adopts the idea in SPIN [7] to search for repeated trees and Figure 7: Examples of graph join operations for 3-edge Figure 8: Generate 4-edge subgraphs from repeated 4-Figure 9: Examples of graph join operations for 4-edge then extend them to subgraphs. However, NeMoFinder dif-fers from SPIN in the following: 1. The notion of frequency in SPIN is different from our 2. SPIN uses equivalence classes to find maximal labelled
Finding repeated subgraphs involves generating candidate subgraphs and frequency counting (see Algorithm 2). The standard method to generate a subgraph candidate g k from atree t k is to add a new edge to t k and check whether the resulting graph is already in the candidate set C k .How-ever, C k can become very large for meso-scale subgraphs, and checking whether a graph exists in C k requires graph isomorphism test which is a NP problem.

Given that the network motifs are meso-scale, we use adja-cency matrices to represent the subgraphs so as to facilitate the graph join operation to generate candidate subgraphs. Agraph g with n vertices can be modelled using a n  X  n matrix M .Anentry m i,j in an adjacency matrix is set to 1 if there is an edge from vertex i to j ,and0otherwise. Thecodeof M , denoted as code ( M ), is a sequence formed by linking the lower triangular entries of M in the follow-ing order: m 1 , 1 m 2 , 1 m 2 , 2 ...m ( i, j ) ...m n, (0 &lt;j  X  i  X  n ).

We can transform any adjacency matrix into a unique representation called canonical adjacency matrix (CAM) [4]. Then two subgraphs that are isomorphic to each other have the same CAM, and vice versa. The canonical adjacency matrix (CAM) of a subgraph g , denoted as CAM ( g ), is the adjacency matrix of g with the maximal code. The last edge entry of CAM ( g ) is the rightmost non-zero edge entry in code ( CAM ( g )). By removing the edge which corresponds to the last edge entry of CAM ( g ), we obtain a subgraph of g . We call the adjacency matrix of such a subgraph as subCAM ( g ) defined as follows:
Definition 4.1. subCAM of a graph. Let CAM ( g ) be canonical adjacency matrix of a graph g .Then subCAM ( g ) is a matrix obtained by setting the last edge entry in CAM ( g ) to 0.

Given two subgraphs g and h ,if subCAM ( g )= subCAM ( h ), then we say that h is a cousin of g . There are three types of cousin relationship between g and h :
Figure 10 shows the adjacency matrices for the size-4 trees t 4 1 and t 4 2 and the generated subgraphs h 1 ,...,h 5 in Fig-ure 6. From the above definitions, we see that h 1 is a Type Idirectcousinof t 4 1 since it is isomorphic to t 4 2 ; h a Type III distant cousin of t 4 1 since it is a disconnected subgraph; h 3 isaTypeIItwincousinof t 4 2 since it is iso-morphic to t 4 2 ; h 4 is a Type I direct cousin of t 4 2 is isomorphic to t 4 1 ; h 5 is a Type III direct cousin of t since it is a disconnected subgraph. Figure 10: Adjacency matrices for the graphs in Fig-
We now show how the subgraph generation and frequency counting are efficiently carried out based on the cousins of a graph.

Given a repeated subgraph g of size k , we first find its set of cousins, H .Thenwejoin g with each graph h  X  H to form new subgraphs of size k that have one more edge than g .Let CAM ( g )beCAMof g and CAM ( h )beCAMof h , then the adjacency matrix M of the new subgraph candidate is a k  X  k matrix and m i,j = 1if CAM ( g ) i,j =1or CAM ( h ) i,j =1 0otherwise
Algorithm 3 gives the pseudo code for the candidate gen-eration procedure.

The following theorem proves that the join operation gen-erates the complete set of candidate subgraphs.
 Algorithm 2 FindRepeatedGraphs( k, i, D ) 1: Input : D -Set of repeated subgraphs with k vertices and 2: Output : D -Set of repeated subgraphs with k vertices and 5: return D ; Algorithm 3 CandidateGeneration( k, i, D ) 1: Input : D -Set of repeated subgraphs with k vertices and 2: Output : C -Set of candidates with k vertices and i edges; 3: C  X  X  X  ; 4: for each g  X  D do 5: H  X  GetCousin ( g ); 6: for each h  X  H do 7: g  X  join ( g, h ); 8: C  X  Can  X  X  g } ; 9: end for 10: end for 11: return C ;
Theorem 4.1. Given all the subgraphs g  X  C k which has k vertices and l edges ( l  X  k  X  1 ), the join operation generates the complete set of subgraphs C k ,whereeach g  X  C k has k vertices and l +1 edges.
 Proof: Let M be an adjacency matrix of a subgraph g  X  C k and e 1 be the last edge entry in M , such that matrix M 1 = M  X  X  e 1 } is a CAM of a subgraph g 1 .Let e 2 be the last edge entry in M 1 .Since M 1 is a connected graph, its corresponding subgraph g 1 must be in C k .

Let M 2 = M 1  X  X  e 2 } + { e 1 } and M 2 be an adjacency matrix of a subgraph g 2 ,wehave g 1 g 2  X  g . Based on the definition of graph cousins, if g 2 is isomorphic to g is a Type II twin cousin of g 1 ;if g 2 is connected but not isomorphic to g 1 ,then g 2 is a Type I direct cousin of g g is disconnected, g 2 is a Type III distant cousin of g 1 .
Since the join operation joins g 1 with all its cousins, each g  X  C
A straightforward method to count the frequency of a size-k subgraph g in a graph G is to check all the graph in GD k . However, this is an NP-complete subgraph iso-morphism problem. Given that the discovery of network motifs requires checking the frequency of the candidate sub-graphs in both the PPI network as well as the large number of randomized networks, it is critical for us to reduce the computational time of the frequency counting process. This can be achieved by leveraging the properties of the different types of cousins.

Theorem 4.2. Let L x denote the set of graphs in GD k such that each graph in L x embeds x .Let h be a Type I direct cousin of a size-k subgraph g and g be the subgraph obtained by joining g and h . Then we have L g = L g  X  L h and the frequency of g is given by | L g  X  L h | . Proof: Each graph in L g must embed g and h since g contains all the edges of both g and h .Thus,wehave L g  X  L Algorithm 4 FrequencyCounting( k, i, C ) 2: Output : D -Set of repeated subgraphs with k vertices and 3: D  X  X  X  ; 4: for each g  X  C do 5: Get the join parameter of g : g and h ; 10: else if type of h = Type I direct cousin then 12: else if type of h = Type III remote cousin then 14: else if type of h =TypeIItwincousin then 16: end if 18: D  X  D  X  X  g } ; 19: end if 20: end for 21: return D ;
On the other hand, each graph in L g  X  L h embeds both g and h . Hence, the graph must embed g , since each edge in g is in either g or h .Thus,wehave L g  X  L g  X  L h .
Therefore, we have L g = L g  X  L h and the frequency of g is given by | L g  X  L h | .

Let us consider t 4 1 and h 2 in Figure 7. We have L t 4 1 {
G (see Figure 5). Then, for subgraph g 1 2 which is generated by joining t 4 1 and h 2 , the graphs in GD 4 that embed g the frequency value of g 1 2 is 4.

Similarly, we can prove that if h is a Type III distinct cousin of a size-k subgraph g , the frequency of g (the sub-graph obtained by joining g and h ) is also given by | L g
However, if h isaTypeIItwincousinofasize-k sub-graph g ,then h is isomorphic to g . In order to determine the frequency of the subgraph obtained by joining g and h , we have to check all the graphs in GD k that embeds g .This frequency counting involves the NP-complete subgraph iso-morphism test. Hence, given that the same subgraph can be generated by joining g with its various types of cousins, we choose to join g with its Type I or Type III cousin when-ever possible to avoid the subgraph isomorphism test. Al-gorithm 4 gives the pseudo-codes for the frequency counting process.

For the complexity analysis of NeMoFinder, please refer to our technical report TRC6/06 (June 2006) [2].
We have implemented our NeMoFinder algorithm in C++ and carried out experiments to compare NeMoFinder with existing network motif discovery algorithms such as the enu-meration method [15], sampling method [9], and FPF [18].
We use two real-life datasets, the Uetz dataset and the original MIPS CYGD dataset. The Uetz dataset [20] con-tains 957 PPIs and 1004 proteins of S. cerevisiae and can be downloaded from the BRITE website. The MIPS CYGD dataset [14] is the whole-genome PPI network of S. cere-visiae from the Munich Information Center for Protein Se-quences. After removing redundancy and orphan links, this dataset contains 10199 PPIs involving 4341 proteins that have been detected with high-throughout genome-wide bio-logical experimental methods.

First, we evaluate the runtime of the four network motif discovery methods (enumeration, sampling, FPF, NeMoFinder) in finding network motifs of varying sizes in the Uetz dataset. We set the frequency threshold to 50, the uniqueness thresh-old to 0.95, and the number of randomized networks to 100. Figure 11 shows that NeMoFinder consistently gives the best performance, with 20-to 100-fold speed up. We also observe that only NeMoFinder manages to find all the motifs within a reasonable amount of time. Figure 11: Comparison of computational times to find Figure 12: Comparison of computational times to find
Next, we evaluate the performance of NeMoFinder under varying frequency thresholds. We set the uniqueness thresh-old to 0.95, the number of randomized networks to 100, and the maximal size of network motif to 9. The enumeration method and sampling method have been excluded from this experiment because they could not scale up to size-9 motifs. Figure 12 indicate that NeMoFinder is able to achieve up to 100-fold speedup over FPF.

We also compare the maximal motif size and the total number of identified motifs by the four algorithms to find network motifs of varying sizes in the MIPS dataset, which is much larger than the Uetz dataset. We set the frequency threshold to 50, the uniqueness threshold to 0.95, the num-ber of randomized networks is set to 1000. Figure 13 shows that NeMoFinder was able to extract network motifs up to size 12, while the maximum sizes of the motifs discov-ered by FPF, sampling method and enumeration method are 9, 8 and 5 respectively. In addition, NeMoFinder was able to find a total of 11140 motifs, while FPF, sampling method and the enumeration method discovered only 1112, 848 and 21 network motifs respectively. The limited number of network motifs found by FPF, sampling and enumeration methods was due to the limitation of the motif size that these algorithms could handle.
 Figure 13: Comparison in size and number of network
Previous works in biological network motifs have focused mostly on motif discovery; there has been little or no work in showing how the network motifs can be systematically exploited. In this section, we describe how we can exploit the extracted network motifs in PPI validation. Our results show that the inclusion of the larger meso-scale network motifs indeed leads to better results.

Technological developments in high-throughput PPI de-tection methods such as yeast-two-hybrid and protein chips have enabled biologists to experimentally detect PPIs at the whole genome level for many organisms. For example, cur-rently more than 15000 PPIs have already been detected and deposited in biological databases for S. cerevisiae .The abundant number of PPIs enables scientists to analyze these organisms at the genome level. However, a significant pro-portion of the PPI networks obtained from high throughput biological experiments has been found to contain false posi-tives. Recent surveys have revealed that the reliability of the popular high-throughput yeast-two-hybrid assay can be as low as 50% [13]. These errors in the experimental data may lead to spurious discoveries that can be potentially costly, e.g., wrong drug targets for diseases.

In a first attempt to validate detected interaction can-didates, Saito et al. [17] develop an interaction reliability index called interaction generaility (IG1). The IG1 measure is based on the notion that the neighbors of the interact-ing partners are likely to also interact with each other. In other words, it uses a very simple network motif to detect false positives by noting that interactions between partners that are involved in lone star-like motifs are probably spu-rious. Positive results from t he various experiments con-ducted by Saito et al. suggest that the use of even such a seemingly primitive network motif in dissecting genome-wide PPI networks is helpful in increasing the reliability of currently erroneous experimental interaction data. In fact, the authors subsequently developed a second reliability in-dex called IG2 [16] that was based on 5 possible network motifs that involved a third protein C together with the candidate interacting protein pair ( A, B ). Their experimen-tal results showed that IG2 outperformed IG1, suggesting the advantage of using more sophisticated network motifs in dissecting the experimentally derived PPI networks.
In this section, we investigate whether using the actual network motifs can indeed give better performance than us-ing the simple, predefined ones such as those employed in IG1 and IG2.
We have seen how NeMoFinder is able to discover a much more comprehensive set of network motifs as compared to the other methods (Section 5). For it to be useful in practice, it is important that the set of network motifs can provide sufficient coverage of the vast interactome. We found that 96% of PPIs in the MIPS dataset was indeed covered by at least one network motif discovered by NeMoFinder.
First, we rank the network moti fs in terms of their contri-bution to the PPI network with respect to their individual sizes, frequencies and uniqueness. For simplicity, we assume that the motifs are independent here. We define the strength MS k ( g )foreachmotif g as:
Definition 6.1. MotifStrength. The strength of a size-k motif g , denoted as MS k ( g ) , is the frequency value of the motif times its uniqueness value over max k ,where max k is the maximal value of s ( g )  X  f ( g ) of all size-k motifs.
Having defined the MotifStrength, we score each interac-tion in the PPI network by combining the strengths of the network motifs that contain the interaction (edge).
Definition 6.2. Reliability Index of PPI The relia-bility index of a PPI ( A, B ) , denoted as I ( A, B ) ,isthesum of the MotifStrength of all the motifs that contain the edge ( A, B ) .
 where g i , 1  X  i  X  n are the motifs where edge ( A, B ) occurs and k is the size of g i .
 We apply our method, as well as IG1 and IG2, on the MIPS CYGD dataset described in Section 5 to compute reli-ability indices for the 10199 S. cerevisiae PPIs in the dataset. We then compare the quality of the various reliability indices in the following three different aspects: 1. Function Homogeneity. The cellular functions of 2. Localization Coherence. With the exception of the 3. Gene Expression Correlation. Studies have shown
Figure 14 shows that as the reliability index value is in-creased, the proportion of interacting pairs with common cellular functions also increases, indicating an increase in the number of true positives in the filtered interaction data. The reliability indices generated using the NeMoFinder X  X  network motifs show significant increases (from 61% to 87% and 81%) than those using IG1 and IG2 (from 61% to only 68% and 73% respectively).

Figure 15 shows the relative performance in terms of cel-lular localization coherence. Using the reliability indices computed by the network motifs, the proportion of interact-ing pairs with common cellular localization increases from Figure 14: Proportion of interacting proteins with com-85.3% to 94.0% and 91.7% for the NeMoFinder network mo-tifs, again outperforming IG1 and IG2 (from 85.3% to 87.0% and 90.1%). Figure 15: Proportion of interacting proteins with com-
The results based on gene expression correlation, shown in Figure 16, exhibit a similar trend. Again, the increase in the average gene expression correlation between the protein partners in the sorted PPIs is much more significant when using reliability indices computed with NeMoFinder X  X  net-work motifs (from 26.4% to 33.5% and 30.8%) than those generated by using IG1 and IG2 (from 26.4% to 27.6% and 29%).

These results show that the PPI reliability indices com-puted using the NeMoFinder network motifs are more reli-able than those computed using IG1 and IG2, demonstrat-ing the positive effect of using a more comprehensive set of actual network motifs against a small number of simple, predefined motifs. Additionally, we also compared the per-formance of using motifs of different sizes. In all three eval-uation experiments, the reliability indexes computed using NeMoFinder network motifs of sizes up to 12 consistently Figure 16: Overall correlation of gene expression for in-show superior performance over that computed with motifs of sizes only up to 8. This indicates that it is advantageous to include the larger motifs, justifying the need for discov-ering meso-scale network motifs.
Existing network motif discovery algorithms are limited to extracting smaller network motifs and cannot be employed to mine meso-scale level network motifs in large biological networks. In this paper, we have presented an efficient net-work motif discovery algorithm called NeMoFinder to dis-cover larger-sized repeated and unique network motifs in PPI networks. The algorithm utilizes repeated trees to par-tition a network into a set of graphs. We have introduced the notion of graph cousins for efficient candidate generation and frequency counting. We use NeMoFinder to successfully extract, for the first time, up to size-12 network motifs from the whole S. cerevisiae PPI network. The network motifs discovered by NeMoFinder provided a good coverage of the PPIs in the vast interactome.

In this work, we also showed an example of how the net-work motifs can be systematically applied in the validation of the PPIs in an interactome. Our results confirmed that employing the larger actual network motifs derived from bi-ological networks instead of predefined small-sized network motifs can indeed achieve better results. Future work will include directed network motif discovery and network motif labelling. [1] I. Albert and R. Albert. Conserved network motifs [2] J. Chen, W. Hsu, ML. Lee, and SK. Ng. Discovering [3] M.B. Eisen, P.T. Spellman, P.O. Brown, and [4] S. Fortin. The graph isomorphism problem. Technical [5] A. Grigoriev. A relationship between gene expression [6] J. Huan, W. Wang, and J. Prins. Efficient mining of [7] J. Huan, W. Wang, J. Prins, and J. Yang. Spin: [8] A. Inokuchi, T. Washio, and H. Motoda. An [9] N.Kashtan,S.Itzkovitz,R.Milo,andU.Alon.
 [10] M. Kuramochi and G. Karypis. An efficient algorithm [11] M. Kuramochi and G. Karypis. Finding frequent [12] S. Maslov and K. Sneppen. Specificity and stability in [13] C.V. Mering, R. Krause, B. Snel, et al. Comparative [14] H.W. Mewes, D. Frishman, U. Guldener, et al. Mips: [15] R. Milo, S. Shen-Orr, S. Itzkovitz, N. Kashtan, [16] R. Saito, H. Suzuki, and Y. Hayashizaki. Construction [17] R. Saito, H. Suzuki, and Y. Hayashizaki. Interaction [18] F. Schreiber and H. Schwobbermeyer. Frequency [19] V. Spirin and L.A. Mirny. Protein complexes and [20] P. Uetz, L. Giot, G. Cagney, et al. A comprehensive [21] X. Yan and J. Han. gspan: Graph-based substructure
