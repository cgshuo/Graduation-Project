 1. Introduction new applications have been emerging for smart home implementa-tion. Usually, such applications are based on diverse sensors such as image, sound, temperature, and light sensors. These sensors generate continuous data stream in a variety of environments such as temperature and light sensing networks, RFID networks, GPS systems and weather networks. One fundamental operation in these applica-tions is to find out semantically meaningful events or activities from sensor data stream. In many cases, such event or activity is repre-sented by a salient sequence pattern. Among the tremendous number of research issues and applications finding such salient sequence pattern from sensor data stream, analyzing human motions and detecting their abnormalities have received much attention for security and surveillance purposes.
 deployed for security purposes, it would be too labor intensive and time consuming for humans to monitor all the devices and their data directly. In many cases, automatic detection of abnormal movements alone could cut these costs. So far, many different approaches have been proposed for automated human abnormality detection. Two representative methods are the model-based approach that detects human motion abnormalities by using a predefined model of human the vision-based approach that visually analyzes visual sensor data to detect human motion ( Petrosino and Staiano, 2007 ; Dean and Kanazawa, 1988 ). However, these methods have some drawbacks.
The former needs a large amount of computation time and the latter utilizes the variation of visual characteristics only and ignores the duration of base motions of any mean ingful motion. Hence, instead of predefined models, whole motion sequences should be used with their durations for simple but accurate human abnormality detection. Typical human motions are composed of several base actions.
Most studies for sequence-based humanmotiondetectioncanbe classified into two categories depending on their assumption: (i) semantically same motions have same motion time even though their base action time might be slightly different. (ii) Semantically same motions might have different motion time. In the former case, one main concern was how to compensate for shifting of values within the sequence and well-known technique such as Dynamic
Time Warping was used for such purpose. However, for more accurate motion detection in the re al applications, the latter should be considered together. One brute-force method for that is to generate multiple queries based on possible query range and execute them. However, this requires huge amount of computation and hence it might result in unacceptable performance. Another method is to use various lengths of query sequences. ( Tak et al., 2012 )Compared to the brute-force method, this method might take less computation time. However, it could give incorrect result when length of the query In this paper, we propose a new method for detecting human motions efficiently and effectively by genera ting dynamic queries for possible range of query sequence and execu ting them in a hierarchical way.
Fig. 1 shows the necessity of dynamic query generation for human motion recognition. To determine if input data stream contains a human motion in database, we need to identify the portion of the input stream that corresponds to the motion and use it for matching. In this figure, for a motion H in the database, Q1 represents the sequence portion of semantically same motion even though its motion time is shorter than the motion H. On the other hand, Q2 represents a possible query sequence with same motion time. Clearly, Q2 contains unnecessary motion in the sequence and hence might give incorrect result. For accurate motion detection we need to formulate correct queries for the motions in database from image sensor data stream.
 The novel features for our proposed scheme are as follows:
We present a new hierarchical querying scheme for sequence-based human motion detection. Our querying scheme con-siders different size of sequence groups from candidate queries and expands promising queries only hierarchically depending on the similarity.

We revise existing sequence (time-series) based indexing and matching schemes to handle hierarchically formulated motion query.

Since motions in the input stream data are represented by different size of groups, we use Dynamic Group Warping ( DGW ) for matching purpose, which is basically same as Dynamic
Time Warping. DGW turns out to be effective for filtering out unnecessary human motions.

The outline of this paper is as follows. In Section 2 ,weintroduce some related works on querying and answering scheme for sensor data stream. In Section 3 , we explain the basi c concept of our matching scheme for motions in image sensor data. In Section 4 ,we describe our indexing scheme and K -NN algorithm to efficiently retrieve similar human motions with the given query. In Section 5 , we describe some of the experiments that we performed on our prototype system for abnormal human abnormality detection through continuous image sensor data stream. Finally in Section 6 , we conclude this paper. 2. Related work
In this section, we introduce some related works for sensor data stream management. In Section 2.1 , we first introduce studies for detecting semantically meaningful motifs from the sensor data stream in diverse areas. And then, in Section 2.2 , we describe several worksonthehumanmotiondetectionfromimagesensordata stream. And in Section 2.3 , we review some related works for sequence based indexing and matching schemes for numerical data streams. 2.1. Sensor data stream management
So far, many different strategies have been proposed for data stream management. For instance, in ( Cheng et al., Vitter ), they proposed an indexing scheme for range queries over uncertain data.
And in ( Cheng R ), solutions for aggregate queries such as nearest-neighbor queries were proposed. In ( Kargupta et al., 2002 ), they proposed a distributed data stream mining system called MobiMine for stock market with the mining component at the server side.
Traffic management and healthcare monitoring are two pop-ular applications based on sensor data stream management. In ( Kargupta et al., 2004 ), they introduced Vehicle Data Stream
Mining System (VEDAS) in which the PDA onboard the moving vehicle can analyze and detect the driver behavior. And in ( Galan et al., 2005 ), they proposed a real-time mining method from in-vehicle sensors to minimize driver distraction through adaptation of the instance selection process based on changes to the data distribution. Even though they recognized the implicit need for adaptation, they hardly considered resource availability but just focused on intelligent sampling. In ( Leijdekkers and Gay 2006 ), a personalized heart monitoring system was proposed based on smart phones and wireless (bio) sensors for monitoring the wellbeing of high risk cardiac patients. 2.2. Motion detection Schemes for image sensor data
Automatic human motion detection and recognition have been done for diverse purposes. For instance, human abnormality detection focuses on detecting predefined abnormal human motions from image sensor data stream. Approaches for human motion detection can be classified into two types: model-based approach and vision-based approach.
 analyzes motion sequences. Most previous works in this category have concentrated on the visional differences and ignored the inevitable difference in the properties of constituent actions of motions. And even when the duration was considered using dynamic programming on motion sequence images, their main concern was to compare motion clips for identifying the motion type. In order to overcome this limitation, we present a new scheme which can detect pre-defined semantically meaningful events or activities in the streamed videos from camera sensors. 2.3. Sequence-based indexing and matching scheme streamed numerical data processing. Since DTW considers shiftings of values in sequence, many studies used DTW to correctly match 2007 ), they found subsequences that are similar to a given query sequence using DTW distance.

However, sequence data are usually extensive. If the whole sequences are directly indexed, matching performance could degrade rapidly due to their high dimensionality. To avoid this curse of dimensionality , the whole sequences are not directly indexed, but rather transformed into low-dimensional feature space ( Keogh and
Ratanamahatana, 2005 ; Faloutsos and Lin 1995 ; Faloutsos et al., 1993 ). Popular dimension reduction algorithms for sequence index-ing include fast Fourier transform (FFT) ( Faloutsos and Lin, 1995 ;
Faloutsos et al., 1993 ), discrete wavelet transform (DWT) ( Struzik and Siebes, 1999 ), adaptive piecewise constant approximation (APCA) ( Keogh et al., 2001 ), piecewise aggregate approximation (PAA) ( Keogh et al., Vlachos ; Keogh and Ratanamahatana, 2005 ), and enhanced PAA ( Zhu and Shasha, 2003 ).

To speed up sequence matching, we need an efficient matching framework. For sequence matching, the GEMINI framework ( Faloutsos and Lin, 1995 ; Keogh and Ratanamahatana, 2005 ;
Ding et al., 2008 ) has been widely used since it virtually guarantees no false dismissal. Under this framework, the only requirement is to choose some high level representation of the data and define a lower bounding function. This technique is simple, intuitive, and competitive compared with other complex approaches. Keogh et al. proposed an efficient sequence matching and indexing scheme using the GEMINI framework ( Faloutsos and
Lin, 1995 ). Also, in ( Han et al., 2007 ), Han et al. suggested a subsequence matching method based on the GEMINI framework. 3. Human motion sequence matching scheme 3.1. Feature extraction from Human motion Sequences
Since a motion sequence is basically a sequence of image sensor data, sequence-based similarity could give more accurate result in the comparison of motion sequences than its feature-based similar-ity. And since each image sensor data consists of several values, we use multiple feature values to re present each image sensor data in the motion sequence. For the human motion abnormality detection, we need feature data that imply human motions. For this purpose, we extract the contour information of the actor/actress in the image and then transform into the feature values by the following steps and
Fig. 2 shows the overall flow for motion feature extraction. (1) For each camera image in the motion sequence, human beings (2) From the detected human body, we first extract its contour (3) Based on the distances between the center point and all the (4) Normalize all the distance curves so that they have same (5) From the normalized distance curves, we extract a set of first (6) From (1) to (5), the motion sequence is represented a
Based on these sequence of values from motion sequences, we index human motions and detect abnormal motions from the image sensor data stream. 3.2. Dynamic data Warping
Dynamic Time Warping (DTW) is a well-known algorithm for measuring the similarity between sequences. Based on the DTW, in this paper, we present a motion sequence matching scheme called Dynamic Data Warping (DDW). Our DDW considers adja-cent sensor data for the noisy or missing data. In addition, since the length of semantically same motifs could be different, DDW stretch some part of the sequences to compensate it. The detailed description of matching steps in our DDW could be represented similar with DTW algorithm ( Keogh and Ratanamahatana 2005 ) as follows:
Assume that two motion sequences S and Q of length n and m are represented by sentence (2). d
S  X  S 1 , S 2 , S 3 , S 4 , ... , S n d Q  X  Q 1 , Q 2 , Q 3 , Q 4 , ... , Q m  X  2  X 
In (2), S i ( Q i ) denotes i th image sensor data in the motion sequence S (Q). Since image sensor data at each time instance could consist of multiple information, we consider each S have R values. For instance, image sensor could generate an image at each time instance and this image can be represented by multiple feature values. Hence, each S i and Q i could be repre-sented by sentence (3). d
S i  X  S 1 i , S 2 i , S 3 i , S 4 i , ... , S R i d Q i  X  Q 1 i , Q 2 i , Q 3 i , Q 4 i , ... , Q R i  X  3  X 
The basic operation of DDW is to find the path P which has the minimum distance among all the paths from ( S 1 , Q 1 )to( S This path can be found using the dynamic programming. The simple sentence to find the path is using the sentences (4) X (6). DDW  X  S i , Q j  X  X  min  X  dist  X  S i , Q j  X  , where , 1 r i r n and 1 r j r m  X  4  X  dist  X  S i , Q j  X  X 
D  X  S , Q j  X  X 
Inthesentence(6), D ( S i , Q j ) denotes the distance between i j image sensor data in S and Q each of which is represented by R values. Since significant portion of a motion sequence could be matched with small portion of ano ther motif sequence, in (5), we restrict the matching reach at each image sensor data stream pair to k , which is known as warping constraint. Fig. 3 illustrates the matching pairs for the motion sequences S and Q using our DDW. 3.3. Dynamic group Warping
In the previous subsection, we explained our DDW scheme for matching motion sequences. This scheme is very powerful in the accuracy perspective since it can compensate the uncertainty and inherent difference of semantically same motion sequences due to various factors such as actor or surrounding environment.
However, for the motion sequence of length n, our DDW matching scheme takes about O(n 2 ) computational time. Hence, if the motion sequences in the dataset are very long and the volume of the dataset is huge, then matching all the motion sequences sequentially and directly with the given query might not be acceptable in terms of performance. To overcome this, we propose a low-bound algorithm, Dynamic Group Warping (DGW), for the filtering purpose in the DDW matching. The concept of DGW is (i) first to group sensor data in the motif according to predefined grouping factor g and then (ii) to measure their distance using the
DDW distance of the grouped motif sequences. For example, when g is 2, two consecutive sensor data in motifs are grouped. Fig. 4 illustrates the differences of warping paths of DDW and
DGW when g is 2. The major advantage of DGW is that matching time is reduced by the squared factor of g compared to the DDW.
Hence, if the distance of DGW is applied before DDW as its low bound, then plenty of computational time can be saved. Like
DDw, our DGW can be represented using notations used in ( Keogh and Ratanamahatana 2005 ). The detailed description of matching steps using our DGW is as follows: grouping factor is g , then their grouped motion sequences SG and
QG can be defines as follows: d SG  X  SG 1 , SG 2 , ::: , SG s , where s  X d n = g e d QG  X  QG 1 , QG 2 , ::: , QG t , where t  X d m = g e motion sequence S ( Q ). Since S i ( Q i ) is represented by R feature values, SG i ( QG i ) can be represented by R sequences of those feature values. For each feature value sequence, we can define its high and low boundaries for the matching using the maximum and minimum values of the sequence. This is described by the sentence (8). for SG i where 1 r i r d n = g e , 1 r l r R which has the minimum distance among all the paths from ( SG , QG 1 )to( SG s , QG t ). The simple sentence to find the path P sentence (9) and (10).
 DGW  X  SG i , QG j  X  X  min dist _ g  X  SG i , QG j  X  X  distance between ith and jth sensor data group in the SG and
QG , respectively. The detailed description to calculate D is in the sentence (11).

D  X  SG i , QG j  X  X  4. Human motion detection from image sensor data stream
In the previous section, we explained our motion sequence matching algorithms DDW and DGW that can efficiently calculate the similarity distance between motion sequences of image sensor data streams. In this section, we describe our motion sequence detection scheme for continuous image sensor data stream based on our DDW and DGW.

First, we explain the overall flow of our motion sequence detection scheme. Then, we describe our mot ion sequence indexing scheme to speed up the search. Since these DDW and DGW algorithms are designed for sequence data, our scheme is based on sequence based indexing and matching schemes. Like Keogh et al. X  X  algorithm ( Keogh and Ratanamahatana, 2005 ), we construct a multidimensional index using low dimensional features. Finally, we present revised K -NN search algorithm to find out K closest motion sequences for image sensor data stream using our indexing and matching schemes. 4.1. Overall flow for motif detection
Fig. 5 illustrates the overall flow of our motif detection scheme. It consists of four major parts: Motion Sequence Dataset, Real Time Query Generation, Motion Sequence Index and Motion Sequence Detection. Detailed explanation about each part is as follows:
Motion Sequence Dataset : Motion sequence dataset contains all the motion sequences of interest for target application. In the human motion abnormality detection for security pur-poses, the dataset contains a set of abnormal human motions that have to be monitored. Since they could have different sizes, we normalize their size by their average length for indexing purpose. We refer to this normal size as Standard_Size in this paper.

Real Time Query Generator : In order to find motion sequences from the input image sensor data stream, we use flexible sliding windows to the sensor data stream in a hierarchical way. Based on the original motion sequence dataset, we define two parameters for determining the minimum and maximum size of the sliding window. Then, we generate all possible queries from the max-imum size sliding window to the minimum size sliding window.
For all generated queries, we first group data stream using biggest grouping factor g and perform DGW to calculate their similarity distance. For the most similar query, we apply smaller grouping factor to perform more accurate similarity estimation. Intuitively, larger grouping factor would give better matching time since it gives smaller number of sensor data groups. So, in the matching, we start with the largest grouping factor g and then apply smaller g for the appropriate data stream to get more accurate estimation.
This is how we perform DGW hierarchically. Detailed description for this will appear in Section 4.2 .

Motion Sequence Index : In order to support fast motion sequence search, we construct an index for the motion sequence dataset. Since the dimensionality of motion sequence itself is too high to directly index, we first reduce the dimensionality of the motion sequence dataset. We will give detailed description for that in Section 4.3 .

Motion Sequence Detector : In the motion sequence detection, we find similar motion sequences for the query from the dataset using the motion sequence index. To detect similar motion sequences quickly, we perform hierarchical query evaluation using different grouping size. As search method, we use priority queue-based K -NN search algorithm for fast search. 4.2. Hierarchical query generation
As we mentioned before, noises or data missing in the stream due to some environmental factors could make it difficult to find similar motion sequences. Even worse, semantically same motion sequences as such as specific human motion could have different stream pattern since its constituent actions might have different length and duration depending on the actor or circumstances.
Hence, fixed size of sliding window which was used in the most previous works to find motifs may not be appropriate. For instance, in fig. 6 , if we use a sliding window of fixed size, the stream data in the sliding window cannot be well matched with the semantically meaningful motif in the figure. This fixed size could be chosen such as Standard_Size or 3/2 Standard_Size and
Standard_Size denotes the normalized size for human motions to efficiently index or match them. To solve this problem, we propose a new query generation scheme based on the flexible sliding window.

The basic concept of our query generation scheme is to generate hierarchically grouped queries called HQ using different grouping factor for the query stream in the flexible sliding window. To generate HQ, we first need to determine two para-meters V F and V E to define the minimum and maximum sizes of the sliding window, respectively. This actually defines the valid query range for the input stream. For example, if V F is 1/2 and V is 3/2, the size of the sliding window is from  X * Standard_Size to 3/ 2 * Standard_Size .

For the stream in the valid query range, we generate hier-archical query by grouping the stream based on the grouping factor. Since the number of groups in the generated queries could be different with that of the index, we reconfigure those queries to have same number of groups with the index. Fig. 7 illustrates an example where a hierarchical query is generated and expanded according to the different grouping factor for the valid motif range of Standard_Size to 3/2 Standard_Size . Formal 3/2 Standard_Size description of the hierarchical query HQ for the grouped query QG is shown in sentence (11). where , d X  i 1  X  n NoG = Sg e X  1 r L r d i n NoG = Sg e expanded with different grouping factors according to the simi-larity with motion sequences in the dataset. In practice, queries on the red line are expanded for the motion sequence matching.
That is, depending on the similarity distance of queries, our hierarchical query scheme expands promising queries only, hence avoid naive query expansion. The detailed description for the similarity calculation between the hierarchical query and motion sequences in the dataset is explained following subsections. 4.3. Motif indexing
In this subsection, we first show our index structure and then describe how to construct the index from the sensor data motifs.
Since motifs are a decent size of sequence data, direct indexing of motifs is not appropriate due to the performance degradation.
Hence, we reduce the dimensionality of motion sequences and construct an index on the low-dimensional values. For a motif S of length n, the dimensionality of each feature l of the sensor data is reduced to N dimensional values using the sentence (13). In this denotes lth feature value at the ith dimension.
  X 
Our index structure is based on the R-tree that is one of the most popular spatial indexing structures. The index tree for the motif dataset is constructed as follows:
Leaf node: Each leaf node in the tree contains N dimensionally reduced motif sequences and keeps the high and low boundary of their values. For instance, if a leaf node L contains P motif sequences S p (1 r p r P ), then its boundary is calculated using the sentence (14).

L l i : Low  X  min  X  S 0 l pi  X  where 1 r i r N , 1 r l r R  X  14  X 
Non-leaf node: Non-leaf node contains leaf nodes and other non-leaf nodes for its child nodes. Each non-leaf node keeps the boundaries of its child nodes. When a non-leaf node contains child nodes L p (1 r p r P ), its boundaries are calcu-lated using the sentence (15).
 where 1 r i r N , 1 r l r R  X  15  X 
In order to reduce the dimensionality from the hierarchical query HQ, we make N groups from HQ and recalculate boundaries for each value l from HQ using the sentence (16). In this sentence, HQ 0 represents sets of boundaries for N dimensional values from HQ and HQ X  i l .High and HQ 0 i l .Low denote high and low boundary for l value at the i th dimension. for i is 1 to N ,
Now, to find out matched motif for the query, we need to measure the similarity distance between motif index and query sequence. This similarity measurement can be done as follows: lated distance of their N dimensional values. For each dimeni-sion, the distance is the gap between the average value of S X  and the high or low boundaries of HQ 0 in (13) and (16), the detailed description for the distance is in the sentence (17) Dist _ P  X  HQ 0 , S 0  X  X 
Distance of HQ 0 and Node: To measure the similarity between the nodes (including leaf and non-leaf nodes) and HQ 0 ,we calculate the accumulated distance of their N dimensional values. For each dimenision, their distance is the gap between the node and the high or low boundaries of HQ 0 in (14) to (16), respectively. We represent the distance of HQ X  and the bound-aries of each node L as Dist_Node(HQ 0 , L) and the detailed description for the distance is in the sentence (18).
Dist _ Node  X  H Q 0 , L  X  X  4.4. K-NN search for motion sequence detection in sensor data
In this subsection, we describe revised K -NN search algorithm to find out K similar motion sequences for the image sensor data stream using the hierarchical query scheme. Similarly to Keogh et al. X  X  matching framework ( Keogh and Ratanamahatana, 2005 )for sequence data, our revised K -NN subsequently performs search over the constructed index using a prior ity queue. Algorithm 1 shows the revised K -NN search algorithm. In the algorithm, a minimum priority queue is used to visit nodes/object s in the increasing order of their distances to the query Q in the indexed space. Our K -NN algorithm begins with the following parameters: (i) Query Q from the sliding window, (ii) constructed index I, (iii) K forthenumberofmotifstobe found, (iv) d for the threshold of the similarity limit in the motif matching, (v) g for the grouping factor and (vi) V F and V valid range of the sliding window. The brief description for our K -NN search algorithm is as follows: Algorithm 1. K -NN Search (Q, I, K , d , g , V F , V E ) Variable queue : MinPriorityQueue;
Variable List: Result; 1. Result  X  {}; 2. for each N dimensionally reduced hierarchical query HQ X  3. queue.push(root, Dist_Node(HQ X , root), g ); 4. while not queue.IsEmpty() do 5. to  X  queue.Pop(); 6. if top .dist 4 d 7. exit the search; 8. if top is a full motion sequence 9. add top to Result ; 10. if 9 Result 9  X  K , y 11. return Result ; 12. else if top is a non-leaf node 13. for each child node C in top 14. queue.push(C, Dist_Node(HQ 0 ,C), g ); 15. else if top is a leaf node 16. for each Point C in top 17. retrieve a GMS of C using top.g ; 18. queue.push(C, Dist_P(HQ 0 ,C)); 19. else if top is a GMS C 20. if top .g 4 2 21. retrieve GMS of C with the factor of 22. for each partial Q i from Q in the range 23. queue.push 24. else 25. retrieve full motion sequence of C 26. queue.push(C, DDW(Q,C), 1); // GMS denotes Group of Motion Sequence // MS denotes Motion Sequence // V denotes ( Standard_Size * V F to Standard_Size * V E // D_DGW(Q,C,g) returns DGW distance of Q and C for g (1) For the given query Q, make N dim ensionally reduced hierarch-ical queries HQ X  X  whose size is in the range V of Standard_Size * V to Standard_Size * V E . For each HQ, calculate the distance from the root of the index and insert it into the queue. (2) Pop a node from the queue and execute one of the following actions depending on the node type until the queue is empty. (3) If current sliding window of Q finds motifs in the dataset whose distances are bigger than some predefined threshold, then stop the search and exit. (4) If top contains a full motion sequence, add it to the result .If the result contains K motifs, return it. (5) If top contains a non-leaf node, then for each child node, calculate its distance to the query and insert it into the queue. (6) If top contains a leaf node, then for each motif sequence point in the node, calculate its distance to the query and insert it into the queue. (7) If top contains a grouped motif sequence C of grouping factor g , there are two cases: (i) if g is bigger than 2, retrieve the GMS C with the factor of g -1. And for each possible partial (8) Since the length of the motion s equence in the streamed video 5. Experimental Results sensor data stream, we developed a prototype system and tested its performance for human motion abnormality detection. The system is running on the Intel Linfield i5 CPU with 4 GB of RAM. The algorithms were implemented in C#.
 which is one of the popular standard datasets in human motion detection area. KTH dataset contains video clips which consist of several human motions. All the motion sequences were taken over homogeneous backgrounds with a static camera with 25 fps frame rate. Hence, when the image sensor data stream has a similar sequence pattern with predefined human motions in the dataset, we consider an abnormal motion is detected. 5.1. Accuracy comparison scheme, we first tested the retrieval accuracy. Since we performed sensor data grouping for the matching efficiency, we need to see whether our hierarchical DGW sacrifices the accuracy. For this purpose, we varied grouping factor g from 1 to 5. At the same time, to find the appropriate ranges for the hierarchical query, we tested 4 different size of sliding windows.

And we use Nearest-Neighbor (1-NN) and the tolerance ( d )is 50. Table 1 shows the accuracy result. The figure implies the following: (1) Among 4 different size of sl iding windows, Type 4 (1/2 Stan-(2) In the table, all the query types show same retrieval accuracy regardless of the grouping factor and its accuracy is same with the sequencial DDW. This means that our hierarchical
DGW and indexing scheme does not sacrifice the retrieval accuracy. In terms of accuracy aspect, we could use any grouping size. However, if we use appropriate grouping size, then we can reduce the searching time.

Fig. 9 shows the effect of the tolerance ( d ) on the retrieval accuracy. Appropriate tolerance is important in the matching since higher tolerance value gives longer searching time and lower tolerance gives poor accuracy. In the figure, we can see that tolerance values above 50 give best accuracy. Hence, for the accuracy aspect, we can use any tolerance value above 50. search time at the cost of retrieval accuracy. In order to see the effect of grouping size on the retrieval accuracy, we used DGW alone with different grouping size as matching method. Table 2 shows the result. In the table, with the grouping factor 1 (sequential DDW), we have the best accuracy. However, as shown in the next section, it requires longest search time. Similarly, for the grouping factor 2 and 3, we got acceptable performance in terms of accuracy and searching time. For the grouping factor 4 and 5, we got worse retrieval accuracy even though its search time is shorter. Hence, with the K -NN search in the mobile platform, DGW matching with 2 or 3 as grouping factor could be a good alternative instead of the DDW matching. 5.2. Searching time comparison Next, we tested the execution time when we use K -Nearest-
Neighbor ( K -NN) and the tolerance ( d ) is 50. In order to show the effect of our hierarchical query and DGW in our K -NN, we measured the searching time for different grouping factors and  X  K  X  in our K -NN search. Fig. 10 shows the result for the query of Standard_Size . By using dynamic sliding windows, we generate multiple queries according to the grouping size within the valid query range defined by V F and V E . Among multiple queries, promising queries can be selectively expanded by the hierarchical query scheme to reduce the searching time. Fig. 11 shows the searching time when we generate multiple queries and execute them all to find similar motifs. Fig. 12 shows the searching time when we consider multiple queries but expand promising ones only. The figures imply the followings: (1) Regardless of the grouping factor, our K -NN algorithm gave better (2) With too big grouping factor, our DGW cannot work as (3) Figs. 11 and 12 show that regardless of groupig size, multiple 6. Conclusion
In this paper, we propose a hierarchical matching scheme for the continuous image sensor data stream and tested its performance on the human motion detection, which is a critical operation in many applications for smart home implementation. In order to manage the characteristics of human motion sequences, we first presented the concept of motion sequence matching called  X  X  X ynamic Data Warp-ing X  X . Then, we proposed its low-bound algorithm called  X  X  X ynamic Group Warping X  X  for filtering purpose to speed up matching in our Dynamic Data Warping. And finally, we proposed an indexing scheme for the motif dataset and K -NN search algorithm to find similar motifs in the sensor data stream. Through experiments, we showed that our proposed motion sequence detection scheme achieves outstanding performance.
 Acknowledgment
This research was supported by Basic Science Research Program through the National Research Foundation of Korea (NRF) funded by the Ministry of Education, Scien ce and Technology (2011-0026448) and the MKE, Korea, under the IT RC (Information Technology Research Center) support program (NIPA-2012-H0301-12-3006) supervised by the NIPA (National IT Industry Promotion Agency) References
