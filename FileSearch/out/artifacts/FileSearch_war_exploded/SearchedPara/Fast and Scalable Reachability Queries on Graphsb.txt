 Answering reachability queries on directed graphs is ubiqui-tous in many applications involved with graph-shaped data as one of the most fundamental and important operations. However, it is still highly challenging to efficiently process them on large-scale graphs. Transitive-closure-based meth-ods consume prohibitively large index space, and online-search-based methods answer queries too slowly. Labeling-based methods attain both small index size and query time, but previous indexing algorithms are not scalable at all for processing large graphs of the day. In this paper, we pro-pose new labeling-based methods for reachability queries, referred to as pruned landmark labeling and pruned path la-beling . They follow the frameworks of 2-hop cover and 3-hop cover , but their indexing algorithms are based on the recent notion of pruned labeling and improve the indexing time by several orders of magnitude, resulting in applica-bility to large graphs with tens of millions of vertices and edges. Our experimental results show that they attain re-markable trade-offs between fast query time, small index size and scalability, which previous methods have never been able to achieve. Furthermore, we also discuss the ingredi-ents of the efficiency of our methods by a novel theoretical analysis based on the graph minor theory.
 E.1 [ Data ]: Data Structures| Graphs and networks Graphs; reachability; query processing
Answering reachability queries , determining whether there is a directed path from a vertex s to a vertex t on a given directed graph G = ( V; E ), is ubiquitous as one of the most basic and important operations on graphs. For ex-ample, in query engines such as SPARQL and XQuery, it is one of the fundamental building blocks for answering user queries [11, 2]. In computational biology, it is employed for representing and analyzing molecular and cellular func-tions [17]. In program analysis, it enables precise interpro-cedural data ow analysis [13,12].

Due to its importance and recent emergence of large graph-shaped data, many indexing schemes have been proposed in the recent database community [18,8,3,19,20,5,15,4,7]. Nev-ertheless, efficiently processing reachability queries on large graphs is still a highly challenging task since current state-of-the-art methods suffer from drawback of either scalability or large query time.

One of the most classical approaches is to compress transi-tive closure [16,18]. However, even with compression, space complexity is still essentially quadratic, and thus this ap-proach is not promising with regard to scalability. In con-trast, methods that conduct a graph search guided by pre-computed indices for answering each query achieve better scalability due to small indexing time and index size [3,19, 20]. However, their query time is several orders of magni-tude slower than other methods, which is critical for certain applications such as SPARQL engines and XQuery engines, as sometimes answers to thousands or millions of reachabil-ity queries are necessary to process one user query [19].
Methods based on labeling to vertices have also been stud-ied for a long time [5,15,4,7]. They precompute a label for each vertex so that a reachability query can be answered from the labels of two endpoints. This approach is promis-ing since, after obtaining small labels, they attain both fast query time and small index size. However, computing such labels has been challenging and highly expensive, thus lim-iting the scalability of this approach.
To address these issues, in this paper, we propose new labeling-based methods for reachability queries, referred to as pruned landmark labeling and pruned path labeling . Since they are labeling-based methods, they achieve fast query time and small index size, but their indexing algorithms are signi cantly more efficient than previous algorithms. As a result, they overcome the drawback of the scalability of labeling-based methods and attain remarkable trade-offs be-tween query time, index size and scalability, which previous methods have never been able to achieve.

As the labeling framework (i.e., index data structure and query algorithm), our pruned landmark labeling follows 2-hop cover [5], which stores sets of vertices L OUT ( v ) and L
IN ( v ) as the label for each vertex v so that a reachability query ( u; v ) can be answered by testing whether L OUT ( u ) a nd L IN ( v ) have non-empty intersection (see Section 3). By contrast, our pruned path labeling follows 3-hop cover [7], which is a generalization of 2-hop cover and stores intervals of paths as labels (see Section 4.1). For both frameworks, while it is conjectured that small labels exist for real-world networks [5], previous indexing algorithms are too slow and cannot be applied to large graphs of the day.

Our key contributions are the new indexing algorithms of pruned landmark labeling and pruned path labeling. They are based on a recent shortest-path querying method [1]. To compute labels, in contrast to previous methods that solve indirect optimization problems with approximate algo-rithms, our algorithms conduct pruned graph searches and directly add label entries to labels of visited vertices. Note that our application of the shortest-path querying method [1] involves several non-trivial challenges. For example, while the shortest-path querying method is tailored to networks such as social networks and web graphs, we design the pro-posed methods for real-world directed acyclic graphs with different structures. Moreover, the indexing algorithm of pruned path labeling is an essentially new algorithm, which computes label entries from all the vertices in a path by just one pruned search.

Our experimental results in Section 6 show that (1) they have good scalability and can be applied to graphs with tens of millions of vertices and edges, (2) their query time is the fastest among the methods and two orders of magnitude faster than online-search-based methods, and (3) their index size is an order of magnitude smaller than transitive-closure-based methods.

Furthermore, we also theoretically discuss why our meth-ods are efficient on real-world graphs in Section 5. In addi-tion to the fact that both proposed methods can exploit tree-like structures of small treewidth, we present a novel analysis based on the graph minor theory proving that our pruned path labeling method can exploit a minor-closed property, which leads to efficiency in various kinds of structures. Independence from arXiv:1305.0502 [6]. We have re-cently noticed that an approach similar to our pruned land-mark labeling method is independently proposed by Jin and Wang [6]. Notations: Let G = ( V; E ) be a directed graph. We de-note the number of vertices j V j and the number of edges j
E j by n and m , respectively. For two vertices s; t 2 V , we de ne reach( s; t ) as true if there is a path from s to t and false otherwise. A reachability query ( s; t ) asks whether reach( s; t ) is true or not. We denote the children of v by children( v ) and the parents of v by parents( v ). We denote the indegree and outdegree of v by d IN ( v ) and d OUT ( v ). Strongly Connected Components: We can safely as-sume that the input graph is always a directed acyclic graph (DAG). Note that all vertices in a strongly connected com-ponent (SCC) of G is equivalent in terms of reachability since they are reachable each other. Thus, G can be con-verted into a DAG by SCCs, preserving the information of reachability among vertices.
 Problem De nition: The problem is to precompute some index for a given DAG G = ( V; E ), and to answer reach-ability queries quickly by using the index, and the DAG if necessary. We assume that all reachability queries are given after indexing. That is, we cannot create an index special-ized for a particular set of queries.
Given a DAG G = ( V; E ), we create two types of la-bels L OUT ( v ) ; L IN ( v ) V for each vertex v . Upon a query ( s; t ), we return Query ( s; t; L OUT ; L IN ) de ned as follows. Query ( s; t; L OUT ; L IN ) is true if L OUT ( s ) and L non-empty intersection. Otherwise, Query ( s; t; L OUT ; L is false . We will construct L OUT and L IN so that, for every s; t 2 V , Query ( s; t; L OUT ; L IN ) = reach( s; t ) holds. Naive calculation of Query ( s; t; L OUT ; L IN ) needs O ( l s l = j L OUT ( s ) j and l t = j L IN ( t ) j . However, if L L
IN ( t ) are sorted, it can be done in O ( l s + l t ) time by scan-ning both labels from their heads to tails simultaneously.
For simplicity, we rst describe a naive algorithm to con-struct L OUT and L IN without pruning, and then proceed to an algorithm with pruning.
Let V = f v 1 ; : : : ; v n g be the vertex set. We incremen-Though the choice of this ordering has a large impact on the performance, we just let it arbitrary at this moment. To make exposition easier, we de ne L k OUT and L k IN as L
OUT and L IN , respectively, right after processing v k . In the beginning, we start with L 0 OUT ( v ) = L 0 IN ( v ) =  X  v 2 V . Suppose that we have constructed L k 1 Then, we construct L k OUT and L k IN by processing v k . First we describe how to construct L k IN . We conduct a BFS from v , and add v k to the labels of vertices that are visited during the BFS. Speci cally, we set L k IN ( v ) to L k 1 IN ( v ) is visited during the BFS, otherwise set L k IN ( v ) to L Similarly, to construct L k OUT , we conduct a reversed BFS from v k , for which we traverse edges backwards. That is, reversed BFS, otherwise set L k OUT ( v ) to L k 1 OUT ( v ).
We use L n OUT and L n IN to answer reachability queries. Ob-viously, they satisfy that Query ( s; t; L n OUT ; L n IN since every vertex has all information about which vertices it can reach and it can be reached from. We also note that from s to t passing through one of v 1 ; : : : ; v k . The proof is similar to [1], and we omit.
The naive algorithm costs too much time and space since we conduct BFSs 2 n times, which results in O ( nm ) time. In pruned landmark labeling, we stop BFSs by pruning vertices whose reachability can be answered correctly from the labels constructed so far.

Suppose that we are visiting a vertex v during the BFS from a vertex v k , and that v can be shown to be reachable from v k by existing labels, that is, Query ( v k ; v; L k 1 is true . Then, we prune the vertex v and do not search descendants of v . Similarly, when we visit v during the re-versed BFS from v k and Query ( v; v k ; L k 1 OUT ; L k 1 then we prune the vertex v .

Though we have pruned vertices, L k OUT and L k IN still sat-only if there is a path from s to t passing through one of v ; : : : ; v k . The correctness of the pruning is proved in [1].
The performance of pruned landmark labeling for short-est path queries depends heavily on the vertex ordering, as Akiba et al. have shown by experimental comparisons [1]. Thus, to prune more vertices, we want to nd a vertex or-isfy that s can reach t via an early vertex in the ordering. We adopt the strategy InOut where we sort vertices by ( d
IN ( v ) + 1) ( d OUT ( v ) + 1) in decreasing order, since it performed well in preliminary experiments.
In this section, we rst propose the pruned path label-ing method, which is based on pruned landmark labeling in Section 3. Then we discuss heuristics to select such paths in Section 4.2.
The idea of pruned path labeling is iteratively selecting paths and conducting BFSs from these paths. The main dif-ference from pruned landmark labeling is that we use paths instead of vertices to start BFSs with. Then, we store which vertices can reach these paths or can be reached from these paths. If a query ( s; t ) is given, we nd a path we have se-lected with two vertices u; v such that there is a path of the form s u v t . In this sense, our method can be seen as a 3-hop cover [7]. The detail is given in the following.
For a given DAG G = ( V; E ), we take l paths P 1 ; P 2 ; : : : ; P such that the sequence of vertices that forms the path P k , where p j
P k j . We construct two types of labels L OUT ( v ) ; L IN N N . It is supposed that, if ( i; j ) 2 L OUT ( v ) for some vertex v 2 V , then v can reach v i;j . Similarly, it is supposed that, if ( i; j ) 2 L IN ( v ) for a vertex v 2 V , then v can be reached from v i;j .

We note that, for any vertex v 2 V and i , we only have to store at most one pair ( i; j ) in L OUT ( v ) to answer reach-ability. To see this, suppose that v can reach v i;j for some i and j . Then, v can reach every v i;j  X  for j j  X  p i since v i;j can reach v i;j  X  through the path P i . Thus, we can choose an integer j min such that v can reach v i;j if and only if j min j p i . Therefore, we only have to store the pair P i from v . Conversely, for each v 2 V and i , we only have to store one pair ( i; j ) in L IN ( v ).

Upon a query ( s; t ), we return Query ( s; t; L OUT ; L IN ned as follows.
 Query ( s; t; L OUT ; L IN ) = In words, Query ( s; t; L OUT ; L IN ) is true if and only if there are a path P i and two integers j; j  X  with j j  X  such that s can reach v i;j and t can be reached from v i;j  X  . We emphasize again that v i;j can reach v i;j  X  through P i . We can compute Query ( s; t; L OUT ; L IN ) in O ( j L OUT ( s ) j + j L merge-sort-like algorithm if L OUT ( s ) and L IN ( t ) are sorted by path index. Now we describe how to construct labels L OUT and L IN . Again, we start with a naive algorithm. We basically con-Al gorithm 1 Conduct pruned BFSs from P k 1 : procedure PrunedBFS ( G; P k ; L k 1 OUT ; L k 1 IN ) 2: p the number of vertices in P k 4: Q an empty queue 5: U  X  6: for i p : : : 1 do 7: s P k [ i ] 8: Enqueue s onto Q 9: while Q is not empty do 10: Dequeue v from Q 11: U U [f v g 12: if Query ( s; v; L k 1 OUT ; L k 1 IN ) is false then 13: L k IN [ v ] L k IN [ v ] [f ( k; i ) g 14: for all u 2 children( v ) do 15: if u = 2 U then 16: Enqueue u onto Q 17: U  X  18: for i 1 : : : p do 19: s P k [ i ] 20: Enqueue s onto Q 21: while Q is not empty do 22: Dequeue v from Q 23: U U [f v g 24: if Query ( s; v; L k 1 OUT ; L k 1 IN ) is false then 25: L k OUT [ v ] L k OUT [ v ] [f ( k; i ) g 26: for all u 2 parents( v ) do 27: if u = 2 U then 28: Enqueue u onto Q 29: return ( L k OUT ; L k IN ) bels L OUT and L IN grow gradually during the algorithm, we de ne L i OUT and L i IN as L OUT and L IN obtained right after processing the i -th path P i . In particular, we de ne L and L 0 IN ( v ) as  X  for all v 2 V , and the pair L l OUT L
IN ( v ) is the label nally output by the algorithm. Suppose that we have already constructed L k 1 OUT and L k 1 IN . Then, we construct L k OUT and L k IN as follows.

First, we conduct BFSs from vertices in P k in descending order, that is, from v k;p k to v k; 1 . In the BFS from the vertex v Otherwise, we set L k IN to L k 1 IN ( v ). When performing a BFS from v k;j , we do not have to visit vertices that are already visited in previous BFSs since they already have a pair ( k; j for some j  X  j .

After BFSs to construct L k IN are nished, we conduct re-versed BFSs by traversing edges backwards from vertices in P k in ascending order, that is, from v k; 1 to v k;p k the reversed BFS from the vertex v k;j , we update L k OUT L L
OUT ( v ). As in the previous case, we do not have to visit vertices that are previously visited by reversed BFSs.
Now we improve the naive algorithm by introducing prun-ing. The idea is the same as pruned landmark labeling. Suppose that we are processing a vertex v in the BFS from a vertex v k;j for some k and j . Then, we issue a query v , that is, we stop the BFS at v . When we are processing a vertex v in the reversed BFS from a vertex v k;j for some ( a) a BFS from P 1 ( d) a reversed BFS from P 2 k and j , we issue a query Query ( v; v k;j ; L k 1 OUT ; L stead. If the answer is true , we prune v . A pseudocode for constructing L OUT and L IN is shown in Algorithm 1.
Figure 1 shows an example of pruned path labeling. Three P ure 1a) to obtain L 1 IN . We add a pair (1 ; 2) to L 1 IN L
IN ( v 2 ; 3 ), and L 1 IN ( v 3 ; 3 ). Also, we add (1 ; 1) to L No pruning occurs during BFSs from P 1 . Then similarly, reversed BFSs are conducted from v 1 ; 1 , v 1 ; 2 , v 1 ; 3 in this order (Figure 1b) to obtain L 1 OUT . For example, L
OUT ( v 2 ; 3 ) obtains a pair (1 ; 3). Next, we conduct BFSs from vertices in P 2 in an appropriate order. When v 1 ; 3 is visited during the BFS from v 2 ; 3 , we issue the query 2 pruned and we no longer continue the search from v 1 ; 3 (Fig-ure 1c). We continue this process until we nish performing BFSs from all the paths (Figure 1d,1e,1f).

A potential drawback of adopting paths instead of vertices is that it may increase the index size. This is because that each element in a label is a pair of integers (a path index and an index of a vertex in the path) instead of one integer (a vertex number) as opposed to pruned landmark labeling. Therefore, we do not have any bene t if we cannot nd long paths. Also, it is practically difficult to cover all the vertices by long paths. To address these issues, we combine the two methods. That is, for some constant a 0, we perform pruned path labeling from a paths and then perform pruned landmark labeling from remaining vertices. Furthermore, we stop taking paths if the length of the path is shorter than b . From preliminary experiment, we decided to choose a = 50 and b = 10 in experiments in Section 6.
As we already mentioned in Section 3, vertex ordering strategies largely in uence the performance of pruned land-mark labeling. Correspondingly, effectiveness of pruning should depend on how to select paths in pruned path label-ing. We empirically compared a few path selection strategies and found that the strategy DPInOut performed the best among them.

In DPInOut , we rst assign a value to each vertex. The value assigned to a vertex v is ( d IN ( v )+1) ( d OUT ( v )+1) if v is not selected as a part of a path before, and 0 otherwise. Then, we select the path in which the sum of the value of vertices is maximized, by dynamic programming on the DAG. After selecting 50 paths, we order remaining vertices by InOut . The idea behind DPInOut is to select paths that contain important vertices as many as possible.
In this section, we give theoretical evidence that our meth-ods perform well on real-world networks. Due to the space limitation, we only show two main theorems and omit the proofs. See [14] for the de nitions of terms.

Akiba et al. [1] showed that their method works efficiently on bounded-treewidth graphs. Since pruned landmark label-ing for reachability is similar to their method, we can use the same proof and we obtain the following.

Theorem 1. Let G be a digraph whose underlying graph has bounded treewidth. Then, there is a strategy of selecting vertices for which pruned landmark labeling on G outputs a label of size O (log n ) for each vertex. Furthermore, we can nd the strategy in O ( n + m ) time. (Constants depending on treewidth are hidden in the O ( ) notations.)
The theorem implies that index size is O ( n log n ) and query time is O (log n ). We note that a complex network is known to have a core and fringes attached to it [9]. Since fringes are supposed to have small treewidth, this theo-rem implies that pruned landmark labeling performs well on complex networks.

Furthermore, we show that pruned path labeling can effi-ciently process graphs satisfying a minor-closed property.
Theorem 2. Let P be a minor-closed property and G be a digraph whose underlying graph satis es P . Then, there is a strategy of choosing paths for which pruned path labeling on G outputs a label of size O (log n ) for each vertex. (Constants depending on P are hidden in the O ( ) notations.)
Again, the theorem implies that index size is O ( n log n ) and query time is O (log n ). We note that examples of minor-closed properties include having bounded treewidth, pla-narity and bounded genus. Thus, pruned path labeling is not only practically but also theoretically stronger than pruned landmark labeling.
We show experimental results in this section. We com-pared our two proposed methods with state-of-the-art ex-isting methods on both real and synthetic graphs. These methods are evaluated in terms of query time, index size, and indexing time. As query time, we report the average time over one million random queries. We conducted all the experiments on Linux server with Intel Xeon X5675 3.07GHz and 288GB memory. We only used one core on all the experiments. Pruned landmark la-beling (PLL) and pruned path labeling (PPL) are compared with three state-of-the-art existing methods, GRAIL [19], interval list (IL) [10] and PWAH [18]. GRAIL is a graph traversal method exploiting labels created by random DFSs, and one of the most memory efficient methods for reacha-bility queries. IL and PWAH are methods that construct compressed transitive closure and they were shown to be the fastest methods for answering reachability queries on large graphs. The implementations of GRAIL and PWAH are by their authors, and the implementation of IL is by the authors of PWAH. We set a parameter k for GRAIL to 2. All algorithms are implemented in C++ using standard template library (STL).

We used real-world networks with more than a million vertices that have been used in the literature [18, 19]. The numbers of vertices and edges (after contracting SCCs) are shown in Table 1. ff/successors: This is a graph used for source code analysis of Firefox [18]. citeseerx, cit-patents: These are citation networks from CiteSeerX 1 and US patents 2 [19]. go-uniprot: This is the joint graph of Gene Ontology terms and annotation les from UniProt 3 [19]. uniprot22m, uniprot100m, and uniprot150m: These are RDF graphs from UniProt database [19]. We note that underlying graphs of these graphs are very close to trees.
We also conducted experiments on even larger synthetic graphs to show the scalability of our methods. These graphs are created as follows. We rst randomly determine the topological order of 10 million vertices. Then we randomly connect two non-adjacent vertices j E j times, where j E j chosen as a parameter. Note that the direction of each edge is uniquely determined by the topological order. ht tp://citeseer.ist.psu.edu/ http://snap.stanford.edu/data/ http://www.uniprot.org/
First, we compared PLL and PPL with existing methods on real-world networks. Tables 2, 3, and 4 show the sum-mary of our experiments.

Table 2 shows the query time on real-world networks. PLL and PPL outperform all the other methods in general. IL also performs quite well especially on citeseerx, but in many cases, PLL is about twice faster than IL. This is possibly because of compactness of labels and simplicity of the query processing procedure of PLL. PPL is slightly slower than PLL since answering queries by PPL is a little more compli-cated than PLL. PWAH and GRAIL are comparable on very sparse graphs, but they get very slow on the other graphs.
Table 3 suggests that the index size of PLL and PPL are reasonable, though there is no doubt that GRAIL is the most memory-efficient method. On uniprot22m, uniprot100m, and uniprot150m, PLL and PPL perform the best, but the difference on these datasets is not very signi cant. This may be due to the sparseness of these graphs, which makes it easier to compress the transitive closure by using IL or PWAH. IL and PWAH perform better than PLL and PPL on ff/successors. On the other hand, PLL and PPL outper-form IL and PWAH on citeseerx and cit-patents. The index size of PLL and PPL is about 3% of IL and 12% of PWAH on cit-patents. We can say that PLL and PPL are robust in the sense that it only takes moderate space, less than 1GB, on all graphs in the experiments. As for the difference between PLL and PPL, PLL is slightly more space-efficient than PPL in most cases since we need two integers to repre-sent each element in a label PPL whereas we only need one integers in PLL. However, the result on ff/successors shows that PLL has a potential to represent reachability in a more efficient way than PPL in some cases.

Then we look at Table 4, which shows indexing time on real-world networks. GRAIL constantly shows great per-formance in indexing time since the number of elements in labels is linear in the number of vertices. Still, indexing time of PLL and PPL is acceptable, while they are rela-tively slow. They are even faster than IL and PWAH on cit-patents. This suggests that PLL and PPL work well on large and mildly dense graphs. IL performs quite well ex-cept on cit-patents, and PWAH needs approximately 1.5 to 2.5 times longer time than IL.
Second, we compared PLL and PPL with existing meth-ods on synthetic graphs. Query time, index size, and index-ing time on synthetic graphs are shown in Figure 2. These synthetic graphs have ten million vertices and number of edges ranges from twenty million to fty million. Note that these gures are drawn with logarithmic-scale y-axis.
Figure 2a shows that PLL and PPL achieve very fast query time. The query time of PLL, PPL and IL increase very slowly as the number of edges becomes larger, within a mi-crosecond even on the graph with 50 million edges. On the other hand, the query time of GRAIL and PWAH grows fast and exceeds 10 microseconds on that graph.

In Figure 2b, the index size of IL and PWAH become larger drastically as the graph becomes dense. The index size of PLL and PPL grow relatively slowly, and that of GRAIL does not change by the number of edges.

Figure 2c shows that GRAIL outperforms other methods in indexing time, especially on relatively dense graphs. PLL and PPL are relatively slow on very sparse graphs. However, these two methods overtake IL and PWAH as the graph becomes dense.

As a whole, we can say that PLL and PPL outperform other methods on relatively dense graphs, achieving very fast query time and moderate index size. The index size of IL and PWAH becomes very large on dense graphs, and the query time of GRAIL and PWAH becomes very slow on these graphs. These experimental results show that PLL and PPL has a potential to handle real-world networks larger than those we used in the experiments. Yosuke Yano and Yuichi Yoshida are supported by JST, ERATO, Kawarabayashi Large Graph Project. Takuya Ak-iba and Yoichi Iwata are supported by Grant-in-Aid for JSPS Fellows (256563 and 256487). Yuichi Yoshida is sup-ported by JSPS Grant-in-Aid for Research Activity Start-up (24800082) and MEXT Grant-in-Aid for Scienti c Research on Innovative Areas (24106001).
