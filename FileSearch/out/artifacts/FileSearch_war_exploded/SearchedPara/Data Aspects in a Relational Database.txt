 Data has cross-cutting concerns such as versioning, privacy, and reliability. In this paper we sketch support such concerns by adapting the aspect-oriented programming (AOP) paradigm to data. Our goal, shared by AOP, is to re-engineer applications to support cross-cutting concerns without directly modifying the application X  X  data or queries . We propose modeling a cross-cutting data concern as a data aspect . A data aspect weaves metadata around an application X  X  data and queries, imbuing them with additional semantics for c onstraint and query processing. H.2.4 [ Database Management ]: Systems---relati onal databases, metadata. D.1.5 [ Programming Techniques ]: Object-oriented Programming---aspect-oriented programming Management, Languages. Aspect-oriented, relational algebra, cross-cutting concerns. A cross-cutting concern is a universal program behavior, one that is potentially needed in many disparate parts of a program, but is often developed and modeled se parately. Common cross-cutting concerns in programming include object versioning, event log-ging, and memory management: such functionality is used to enhance, instrument, or debug an application, making it more robust, portable, and reliable. Cross-cutting concerns can be quickly and easily added to an application using a new program-ming paradigm called aspect-oriented programming (AOP). In AOP each concern is modeled as an aspect . An aspect couples advice , which is code from the implementation of a cross-cutting concern, with a point cut , which specifies where and when in the execution of the application the advice is woven or placed. Figure 1 gives an overview of AOP. In the figure an aspect weaver , e.g., AspectJ, weaves a program ( Program.java ) with two cross-cutting concerns, one th at implements object persist-ence ( Persist.java ) and another that implements event log-ging ( Log.java ). Each aspect combines advice from a concern with a point cut. The aspect w eaver injects the advice into the program X  X  behavior, at the mode l-level (e.g., in the UML), the code-level (e.g., in Java), or at a low-level (e.g., in the JVM). AOP supports the separation of concerns in program design and development, modularizes implementation of cross-cutting con-cerns, and promotes code reuse. AOP promotes aspect independ-ence which is the principle that a cross-cutting concern is inde-pendent of an application and can be added ex post facto to en-hance an application without repr ogramming the application, e.g., in Figure 1 without modifying Program.java . Data, like code, also has important cross-cutting concerns. Data can be annotated with descriptions of where it came from, who inserted or changed it, and what its quality is [4],[16]. The provenance of the data, what manipulations were performed on it accuracy and lineage of the data can be captured [5],[26]. Security and privacy introduce additional cross-cutting concerns, such as who has access to the data and to whom information has been released. Reliability and performance requirements are also potential cross-cutting concerns. But current DBMSs offer little support for cross-cutting data concerns, though research has a ddressed using aspect-oriented techniques to program database s [22], and using a relational database to support AOP [21]. In this paper we propose adapting the AOP paradigm to relational data, creating aspect-oriented relations and queries . (We do not consider aspect-oriented schemas in this paper [10].) The AOP paradigm modifies dynamic program behavior, so has to be adapted to include data, which is (largely) static . Figure 2 gives an overview of the process of creating aspect-oriented relations and queries. In the figure a temporal concern ( temporal.rel ) and a privacy concern ( privacy.rel ) are woven into the data ( data.rel ) and to a query ( query.sql ). The advice in each concern is a relation of metadata , that is, the advice is data about data. The advice could describe who has access to the data, how the data was measured, and when the data is current, among other things. For a temporal cross-cutting con-cern, the advice will be a relation of timestamps, where each time-stamp describes (part of) the data X  X  lifetime. For a privacy concern it could be a relation of privacy groups or privileges. The advice is bound to data (or a query) at a data cut , which specifies where the advice should be woven. The data cut together with the advice forms a data aspect . A data aspect weaver weaves the advice into the data yielding an aspect-oriented relation or around a query yielding an aspect-oriented query. The three key notions that we borrow from AOP for aspect-orient-ed relations are 1) that aspects can be developed independent of applications, 2) that aspects can be woven into already existing applications, and 3) that there needs to be some system (DBMS) support for implementing aspects. Assume that a company records information about its employees in a relational database. The data base is designed well and has an extensive set of integrity constraint s. Many applications, such as a payroll application, have been built to query, update, and manage the database. A portion of the database, the Employees relation, is shown in Table 1. Each tuple in Employees records a name ( Name ), department where employed ( Dept ), salary ( Sal ), and a key ( ID ) (note that we adopt a very simple key only for expository purposes, any key will suffice). Companies continually evolve, over time new database require-ments arise. A new tax law makes it mandatory to retain the salary history of each employee, so that auditors can ascertain the pay-roll at any given time. A nother requirement comes from applica-tion coders who need to test their code with the  X  X ive X  system, mixing live data with  X  X est X  data, that is, data that should be used only for testing. A thir d requirement emerges out of a new privacy policy adopted by the company. The policy establishes a hierarchy (complete partial order) of privacy groups, with the most privi-leged, super user at the top and the general public at the base. Data for each group will be available only to users of that group (or to users in groups above that group in the hierarchy). To accommodate the new requirements, all cross-cutting con-cerns, the designers need to add new data and functionality to their existing database and its a pplications. Ideally, the designers will be able to add the new data and functionality without chang-ing a line of application code, database query code, or integrity constraint code. In an aspect-oriented approach, the database designers  X  X ag X  data in the database with advice, cr eating aspects. Figure 3 shows the employee data in Table 1 together with several aspects. There are three kinds of aspects in the figure: temporal aspects, test aspects, and privacy aspects. Each aspect binds advice to data. A temporal aspect binds a timestamp(s) to data to signify when an employee is employed, i.e., the valid time lifetime of the employee. Test advice is a number identifying a test suite, and a test aspect identifies the test suite to which the data belongs. Finally, privacy advice is the name of a group esta blished by the privacy policy. Aspects are developed and app lied independently, but several aspects can be simultaneously woven to data to act in concert. For instance, in Figure 3 the privacy and temporal advice woven to the fact that Joe worked in Admin earning 100K means that he was employed from 2007 to now and that only people in at least the administrators group can see this fact. We will call the com-bined aspects a perspective [9]. Alternatively, the aspects can be treated independently, in which case each aspect forms its own perspective. Aspects can also be applied to intensional data, i.e., queries. Consider a query to retrieve the salary of each employee named Joe. In the relational algebra this query can be expressed as follows: data cuts data aspects The query can be aspected to retrieve different aspects of Joe X  X  salary. For instance, if the query were  X  X spected X  with the temporal advice  X ( 2002 , 2002 ) X , then its evaluation would produce the salaries of employees named Joe who worked during 2002. If it were instead aspected with the test advice  X  test suite 20  X , then data in that test suite would be used to compute a result (test data is excluded by default). We implemented (part of) an SQL-to-SQL translator that takes an SQL query (written in the MySQL dialect of SQL) and translates it to an aspected SQL query, i.e., a layered approach to imple-mentation of aspected-oriented re lations and queries. We used the translator to translate four simple queries, listed below, on a scaled-down version of the Internet Movie Database. The database has only two tables, an Actor table with information about actors and a Casting table, wh ich relates an actor to a movie in which the actor was cast. Both tables are approximately 0.5GB in size, and there are indexes for the keys of each table. We experimented with the aspected queries as follows. We varied the percentage of aspected da ta, from 0% to 100%. The 0% case is the  X  X naspected X  case, i.e., the queries are the original SQL queries. In the 100% case, every t uple was aspected with a single aspect. In the 100% case, the advi ce and data cuts added 0.8GB. We also created indexes for the data cuts and advice tables. We then evaluated the four queries and measured the logical block I/O (which is a much bette r measure of the actual cost of the query than time since it factors out caching effects, a query that logically reads half as many blocks as another query often runs in the same time since the time is driven by the number of physical vs. logical reads, in other words, we are using the  X  X orst-case X  measure for showing the cost of aspect-oriented data). The raw results are given in Table 2, and a chart of the results in Figure 4. The  X  X lowdown X  is the ratio of the block I/O in the aspected case vs. the unaspected case. So a slowdown of 25 represents twenty-five times more block I/O. The slowdown is reasonable for the selection and the join, but the cost blows out for projection. Th e culprit is duplicate elimination in the projection. MySQL lacks a difference operator, so a difference has to be implemen ted using a subquery, and the subquery involves the Cartesian product of two joins. The indexed-based selection is also expensive, but mostly because a point query using an index is extr emely fast; observe that the raw cost of an aspected-indexed select is still very low. There is a little previous research on support for manifold kinds of metadata in database management systems. Most closely related to this paper is the AUCQL langua ge for querying different kinds of metadata in a semi-structured data model [9], which was later developed into a query language, MetaXQuery [15], for XML data. This paper in contrast focuses on the relational model. The database research community has researched models and support for specific kinds of metadata, or in our terminology, specific kinds of aspects. One of the most important and most widely researched kinds is tem poral. Temporal extensions of every data model exist, for instance, relational [23], object-oriented [24], and XML [11]. This paper generalizes the work in relational temporal databases by proposing an infrastructure that supports many kinds of advice, not just temporal advice. More specifically we extend tuple-timestamped models [14], whereby the temporal metadata modifies the entire tuple. Other tuple-level, relational model extensions to support security, privacy, proba-bilities, uncertainty, and reliability have been researched, but no general framework or infrastructure exists which can support all the disparate varieties. There are several systems that have aspect-like support for combining different kinds of me tadata. Mihaila et al. suggest annotating data with quality and reliability metadata and discuss how to query the data and metadata in combination [19]. The SPARCE system wraps or superimpos es a data model with a layer of metadata [20]. The metadata is active during queries to direct and constrain the search for desired information. Systems that provide mappings between metadata (schema) models are also becoming popular [3],[18]. Our approach differs from these systems by focusing on the relati onal data model and relational algebra extensions to support AOP, and by building a framework whereby the behavior of individual data aspects can be specified as  X  X lug-in X  components. The information retrieval community has been very active in researching descriptive metadata, in particular metadata that is used to classify knowledge [25]. The Dublin Core is a commonly used classification standard [8]. Commercial [1] and research projection 1550 21814 41949 89505 systems [2] to manage (descriptive) metadata collections have been developed. Methods to auto matically extract content-related metadata have also been researched [13],[17]. The focus of the information retrieval research is on how to best use, manage, and collect metadata to describe data to improve search [12]. In contrast, our focus is on modeling data aspects which impose a semantics on the use of the data, i.e., they go beyond the simple, descriptive tagging of data with metadata. This paper proposes adapting a popular software engineering technique to database management. Aspect -oriented programming is used to add cross-cutting concerns to an already existing application, without having to re program the application. Cross-cutting concerns are also present in data management. We sketched a design for aspect-oriented relations and queries, which allow a database to be re-engineered with cross-cutting data concerns. We proposed annotating da ta using data aspects, which binds advice (metadata) to data. The advice also has semantics that must be observed when th e data is used in a query. [1] Amaxus CMS,  X  X n Overview of the Amaxus XML Content [2] Michelle Baldonado, Chen-Chuan K. Chang, Luis Gravano, [3] Phil A. Bernstein,  X  X pplyi ng Model Management to [4] Deepavali Bhagwat, Laura Chiticariu, Wang Chiew Tan, and [5] Rajendra Bose and James Frew. Lineage Retrieval for [6] Peter Buneman, Adriane Chapman, and James Cheney, [7] Peter Buneman, Sanjeev Kha nna, Keishi Tajima, and Wang [8] Dublin Core Metadata Initiative.  X  X ublin Core Metadata [9] Curtis E. Dyreson, Michael H. B X hlen, and Christian S. [10] Curtis Dyreson, Richard T. Snodgrass, Faiz Currim, Sabah [11] Dengfeng Gao and Richard T. Snodgrass.  X  X emporal Slicing [12] Hector Garcia-Molina, Diane Hillmann, Carl Lagoze, [13] Luis Gravano and Panagiotis G. Ipeirotis and Mehran [14] Christian S. Jensen, Michael D. Soo, and Richard T. [15] Hao Jin and Curtis E. Dyreson,  X  X rouping in MetaXQuery X , [16] Anastasios Kementsietsidis, Floris Geerts, and Diego [17] Dongwon Lee and Yousub Hwang, Extracting Semantic [18] Sergey Melnik, E. Rahm, E., and Phil A. Bernstein.  X  X ondo: [19] George A. Mihaila, Louiqa Ra schid, Maria-Esther Vidal. [20] Sudarshan Murthy, David Maier, Lois M. L. Delcambre, [21] Awais Rashid and N. Loughran,  X  X elational Data-base [22] Awais Rashid,  X  X spect-Oriente d Programming for Database [23] Richard T. Snodgrass (Ed.). The TSQL2 Temporal Query [24] Richard T. Snodgrass,  X  X emporal Object-oriented Databases: [25] Adrienne Tannenbaum. Metadata Solutions: Using [26] Jennifer Widom,  X  X rio: A System for Integrated 
