 Frequent episode mining (FEM) is an interesting research topic in data mining with wide range of applications. However, the traditional framework of FEM treats all events as having the same importance/utility and assumes that a same type of event appears at most once at any time point. These simplifying assumptions do not reflect the characteristics of scenarios in real applications and thus the useful information of episodes in terms of utilities such as profits is lost. Furthermore, most studies on FEM focused on mining episodes in simple event sequences and few considered the scenario of complex event sequences, where different events can occur simultaneously. To address these issues, in this paper, we incorporate the concept of utility into episode mining and address a new problem of mining high utility episodes from complex event sequences , which has not been explored so far. In the proposed framework, the importance/utility of different events is considered and multiple events can appear simultaneously. Several novel features are incorporated into th e proposed framework to resolve the challenges raised by this new problem, such as the absence of anti-monotone property and the huge set of candidate episodes. Moreover, an efficient algorithm named UP-Span ( Utility ePisodes mining by Spanning prefixes ) is proposed for mining high utility episodes with several strategies in corporated for pruning the search space to achieve high efficiency. Experimental results on real and synthetic datasets show that UP-Span has excellent performance and serves as an effective solution to the new problem of mining high utility episodes from complex event sequences. H.2.8 [ Database Management ]: Database Applications  X  Data Mining Keywords : Utility mining, episode mining, high utility episodes, complex event sequences is a fundamental research topic in data mining, which refers to discovering patterns that appear in a dataset with frequency no less than a user-specified minimum support threshold . Many studies have been dedicated to this research, including frequent itemset mining [3, 12], sequential pattern mining [1, 4, 24] and frequent episode mining [2, 9, 11, 16, 19, 20, 21, 22, 23, 30, 31]. However, the classical framework of FPM may discover a large amount of frequent but low revenue pattern s and lose the information on valuable patterns having low se lling frequencies. Hence, the traditional framework of FPM cannot satisfy the requirement of users who desire to discover patte rns with high utilities such as high profits. To address these issues, utility pattern mining (abbreviated as UPM) [5, 6, 7, 8, 13, 14, 15, 17, 18, 25, 26, 27, 28, 29, 32] emerges as an important topic in data mining. In utility pattern mining, each item in the database has a weight (e.g. unit profit) and can appear more than once during a time period (e.g. purchase quantity). The utility of a pattern represents its importance, which can be measured in terms of weight, profit, cost, quantity or other information depending on the user preference. Mining high utility patterns refers to discovering patterns that appear in a dataset with utility no less than a user-specified minimum utility threshold . Utility pattern mining is an important task and ha s a wide range of applications such as website click stream analysis [5, 13, 6], cross-marketing in retail stores [15, 17, 25, 28] and biomedical applications [8]. 
Although high utility pattern mining is essential to many applications, it is not an easy task because the downward closure property [1, 3, 4, 12, 24] in FPM does not hold in UPM. To facilitate the task of high utility pattern mining, most studies [5, 13, 14, 18, 26, 27, 28, 29] incorporate the concept of TWU ( Transaction Weighted Utilization ). In the TWU model, a pattern is considered as a candidate or potential high utility pattern (abbreviated as PHUI) if its TWU is no less than the minimum utility threshold, where the TWU of a pattern represents th e upper bound of its utility. A general TWU model consists of phase I a nd phase II. In phase I, all the potential high utility patterns are found. In phase II, high utility patterns are identified from the set of PHUIs by calculating the exact utilities of PHUPs. 
Although many studies have been devoted to utility pattern mining, most of them focus on mining high utility itemsets from transactional databases [5, 13, 14, 15, 17, 18, 26, 27, 28, 29] or mining high utility sequential patterns from sequence databases [6, 7, 25, 33] . The topic of discovering high utility episodes in complex event sequences has not been explored so far. An event sequence is a long sequence of events. Each event is described by its type and a time of occurrence. An episode is a set of partially ordered events. The traditional framework of frequent episode mining (abbreviated as FEM) [2, 9, 11, 16, 19, 20, 21, 22, 23, 30, 31] is to find episodes that frequently occur in an event sequence. However, the traditional framework of FEM treats all events as having the same weight/utility and assumes that events can only occur at most once at any time point. These simplifying assumptions do not reflect the characteristics of real-life app lications. This may result in discovering episodes having low utility (e.g. low profit). Furthermore, most studies on FE M focused on mining episodes in simple event sequences and few considered the scenario of complex event sequences, where different events can occur simultaneously at the same time point. 
However, sequences containing such information are often encountered in real-life applica tions. For instance, in customer behavior analysis, a complex event sequence represents the purchase behavior of a customer. Each time point represents the items bought in a transaction (within a time period) by the customer. Each purchased item can be regard ed as an event having a quantity (internal utility) and a purchase price (external utility). Mining high utility episodes from such sequences can find sequential relationships between sets of items that contribute high profits, which is very valuable for business. Although mining high utility episodes from complex event sequences is desirable for many applications, it is not an easy task to incorporate the concept of utility mining with episode mining. It may pose the following challenges. 
First, the utility of an episode is neither monotone nor anti-monotone [22]. In other words, the utility of an episode may be equal to, higher or lower than that of its supersets and subsets. Therefore, many techniques [2, 4, 12, 16, 22, 24, 31] developed in FEM that rely on anti-monotonicity to prune the search space cannot be directly applied to high utility episode mining. 
Second, mining episodes from complex event sequences is not a trivial task. In the complex even t sequences, different events can occur simultaneously at the same time point. This is substantially different and much more cha llenging than mining episodes from simple event sequences. episode mining with the TWU model [5, 13, 14, 18, 26, 27, 28, 29] to facilitate the mining task. Although the TWU model is widely used in utility pattern mining, it is difficult to adapt this model to high utility episode mining because the dataset to be mined is a single, very long event sequence, which is very different from the transactional database [3, 12, 26] and sequence database [24, 32]. produced in phase I as much as possible if the TWU model can be applied to the high utility episode mining. A large number of candidates produced in phased I may degrade the performance of the mining task in terms of execution time and memory consumption. Therefore, it is important to develop effective strategies to prune the candidates and the search space. proposing a new framework for mining high utility episodes in complex event sequences. The major contributions of this work are summarized as follows: and formalize the problem of high utility episode mining. An efficient algorithm named UP-Span ( Utility ePisodes mining by Spanning prefixes ) is proposed for mining the complete set of high utility episodes from complex event sequences. utility episode mining and propose EWU model ( Episode-Weighted Utilization model ) to efficiently find high utility episodes. Several strategies are proposed to prune the search space and reduce the number of candidates in the mi ning processes. The proposed strategies improve the overall perfo rmance of the mining task. In the experiment, the number of candidates produced by the proposed algorithm is much smaller than that of the baseline algorithm. and real datasets. The results show that the proposed framework and the UP-Span algorithm can efficiently discover high utility episodes from large scale data. In particul ar, the proposed UP-Span algorithm outperforms the baseline algorithm substantially (over two orders of magnitude) and serves as an effective solution to the new problem of mining high utility episodes from complex event sequences. introduces the background for episode mining and utility mining. Section 3 gives the formal definition of high utility episodes and presents the proposed algorithms. E xperiments are shown in Section 4. Conclusions and future work are given in Section 5. mining and high utility pattern mining. mining. For more details about epis ode mining, readers can refer to [2, 9, 11, 16, 19, 20, 21, 22, 23, 30, 31]. Definition 1 (Simple event sequence). Let  X  = { E 1 , E sequence SS = &lt;( E 1 , T 1 ), ( E 2 , T 2 ),..., ( E sequence of events, where each event E i  X   X  is associated with a time shows a simple event sequence SS = &lt;(( A ), T 1 (( A ), T 5 ), (( D ), T 6 ), (( C ), T 7 )&gt;. Definition 2 (Simple episode). A simple episode  X  is a non-empty totally ordered set of events of the form &lt;( E 1 ), ( E example, &lt;( A ), ( C )&gt; is a simple episode. Definition 3 (Simultaneous event set) . A simultaneous event set The length of a SE is denoted by | SE | and is equal to the number of events in SE . Given two simultaneous event sets SE 1 = ( E and SE 2 = ( E 1  X , E 2  X ,..., E m  X ), where m  X  n , SE and SE 1 is the superset of SE 2 iff SE 2  X  SE 1 . Definition 4 (Complex event sequence). A complex event sequence CS = &lt;( SE 1 , T 1 ), ( SE 2 , T 2 ),..., ( SE sequence of simultaneous event sets, where each simultaneous event set SE i is associated with a time point T i  X  N + and T &lt; j  X  n . For example, Figure 2 shows a complex event sequence CS = &lt;(( AB ), T 1 ), (( BC ), T 2 ), (( C ), T 3 ), (( AB ), T Definition 5 (Episode contai ning simultaneous events). An episode  X  is a non-empty totally ordered set of simultaneous events of the form &lt;( SE 1 ), ( SE 2 ),..., ( SE k )&gt;, where SE containing the simultaneous event set ( AB ). Definition 6 (Length and Size). The length of an episode  X  = &lt;( SE 1 ), ( SE 2 ),..., ( SE k )&gt; is defined as |  X  | =  X  episode. The size of  X  is defined as the number of simultaneous event sets in  X  . For example, &lt;( AB ), ( C )&gt; is a 3-episode of size 2. Definition 7 (Occurrence). Given an episode  X  = &lt;( SE occurs in [ T s , T e ], (2) the first simultaneous event set SE at time T s and the last simultaneous event set SE k of  X  occurs at time T . The set of all occurrences of  X  is denoted as occSet (  X  ). For example, the set of all the occurrences of &lt;( AB ), ( C )&gt; in Figure 2 is occSet (&lt;( AB ), C &gt;) = {[1, 2], [1, 3], [1, 6], [1, 7], [5, 6], [5, 7]}. Definition 8 (Minimal occurrence). Given two time intervals [ T T ] and [ T s  X , T e  X  X  of occurrences of episode  X  , [ T time interval of [ T s , T e ] if T s  X  T s  X  and T e T ] is called a minimal occurrence of episode  X  if (1) [ T occurrence of episode  X  and (2) there is no alternative occurrence [ T  X , T e  X  X  of  X  such that [ T s  X , T e  X  X  is the sub-time interval of [ T A minimal occurrences of  X  is denoted as mo (  X  ). The complete set of minimal occurrences of  X  is denoted as moSet (  X  ). For example, moSet (&lt;( AB ), C &gt;) = {[1, 2], [5, 6]}. Definition 9 (Support of an episode). The support count of an episode  X  is defined as the number of minimal occurrences in ratio of SC (  X  ) to the number of time points in CS . Definition 10 (Frequent episode). An episode is called frequent , iff its support is no less than a user-specified minimum support threshold min_sup . Otherwise, the episode is infrequent . Definition 11 (Frequent episode mining). Given an event sequence CS and a user-specified minimum support threshold min_sup , the problem of frequent episode mining is to extract all the episodes having a support no less than min_sup . Definition 12 (Sub-episode and super-episode). Given two episodes  X  = &lt; SE 1 , SE 2 , ..., SE n &gt; and  X  = &lt; SE integers 1  X  i 1 &lt; i 2 &lt;...&lt; i m  X  n such that SE n . In addition, episode  X  is the super-episode of  X  . Property 1 (Downward closure property for frequent episode mining). The downward closure property states that: (1) For any frequent episode, all its sub-episodes are frequent. (2) For any infrequent episode, all is super-episodes are infrequent. Proof. The reader is referred to [22] for the proof. with wide range of applications. The topic of mining frequent episodes in simple event sequences was first introduced by Mannila et al. [22]. They proposed two algorithms named WINEPI and MINEPI to find episodes that frequently occur in a simple event sequence. Although WINEPI and MINEPI algorithms are the pioneers in episode mining and perfo rm well in some cases, they are Apriori-based approaches and employee candidate-generation-and-test mechanisms to find frequent episodes. Therefore, they often generate a large number of candida tes during the mining processes, which may degrade the performance of the mining task in terms of execution time and memory cons umption. To improve the performance of MINEPI algorithm, Ma et al. proposed the PPS (Position pairs set) algorithm [31], which efficiently finds frequent episodes without generating any candidate during the mining processes. Based on [22], several studies were proposed for mining various types of significant episodes or episode rules. In addition, episode mining is essential to ma ny applications such as event detection in sensor network [30], occurrences of recurrent illnesses [21, 23] and financial data [2]. most studies on frequent episode mining focused on mining simple episodes in simple event sequences and few considered the scenario of complex event sequences, where different events can occur simultaneously at the same time point. By considering complex event sequences, the episode contai ning simultaneous events can be discovered, which provides add itional information about the relationships between events. Besi des, the traditional framework of frequent episode mining treats a ll events as having the same importance/utility and assumes that an event appears at most once at any time point. These assumptions do not reflect the characteristics in real scenario of several real-life applications and thus the useful information of episodes with high u tilities such as high profits is lost. Although discovering episodes with high utility is desirable for many applications, the topic of high utility episode mining has not been addressed so far. In the next subsection, we study the related works about utility mining. itemset mining, high utility sequential pattern mining and high utility episode mining. For a recent overview of research on utility mining, readers can refer to [5, 6, 7, 8, 13, 14, 15, 17, 18, 25, 26, 27, 28, 29, 32]. utility pattern mining, each item in a database is associated with an additional value, called its external utility , which can be used to indicate the importance/weight/unit profit of the item. Each item appearing in a record of the database is attached with its internal utility , which indicates the quality/appearance/quantity of the item in the record. The utility of an itemset (a set of items) can be measured by considering its extern al utility and internal utility. An utility threshold . Otherwise, the itemset is called low utility . Mining high utility itemsets is much more challenging than mining frequent itemsets, because the downward closure property [3, 12] in frequent itemset mining does not hold in utility mining. including IHUP [5], Two-Phase , IIDS [18], TWU-Mining [27], and UP-Growth [26]. Most of them utilize the TWDC ( Transaction-Weighted Downward Closure ) property and adopt the TWU ( Transaction-Weighted Utilization ) model to find high utility itemsets. In general, the general TWU model consists of two phases. In phase I, potential high utility itemsets are found from the database. In phase II, the exact utilities of the potential high utility itemsets are computed by scanning the database and high utility itemsets are identified from the set of potential high utility itemsets. they can only handle itemsets and do not consider the sequential data and the ordering relations hips between items. Mining high utility patterns from sequential data is a more challenging task. The integration of utility and sequen tial pattern mining has taken place very recently. We only found four papers [5, 6, 27, 34] on this topic. Ahmed et al. integrated the concept of utility mining with sequential pattern mining and proposed US and UI algorithms for mining high utility sequential patterns [7]. Shie et al. proposed the UMSP algorithm [25] for mining high utility mobile sequential patterns in mobile environment. Ahmed et al. designed an algorithm for mining high utility access sequence s from web log data [6]. Recently, Yin et al. argued that the problem definition in [6] is rather specific and they proposed a generic framework for high utility sequence analysis and an efficient algorithm named USpan [32] for mining high utility sequential patterns. From the above related works, we can observe that only very preliminary works have been done on mining high utility patterns from sequential data. For the topic of high utility episode mining , we found that there is only one related paper in the literature [10]. But it only considers the external utility of the event (e.g. importance/weigh t/unit profit). It did not consider the case of complex event sequence and the internal utility of the event (e.g. quality/quantity/ appearance count). concept of utility mining into episode mining and propose a new framework for high utility episode mining . Then we present an efficient algorithm named UP-Span ( Utility ePisodes mining by SPANning prefixes ) and effective strategies for mining the complete set of high utility episodes in complex event sequences. T ),..., ( tSE n , T n )&gt; be a complex event sequence with n time points, where each simultaneous event set tSE i is associated with a time mining, each event E i  X   X  is associated with a positive number p ( E CS ), called its external utility . Each event E j in a simultaneous event set tSE i at the time point T i is associated with a positive number q ( E T ), called its internal utility . For example, Figure 3 shows a complex event sequence with intern al utility and Table 1 shows the external utilities of events. Definition 13 (Utility of an event at a time point). The utility of an event E j at a time point T i is defined as u ( E j , T T ). For example, the utility of the event ( A ) at the time point T u (( A ), T 1 ) = p (( A ), CS )  X  q (( A ), T 1 ) = (1 X 2) = 2. Definition 14 (Utility of a simultan eous event set at a time point). The utility of a simultaneous event set SE = ( E 1 , E point T i is defined as u ( SE , T i ) =  X  ),( utility of the simultaneous event set ( AB ) at the time point T u (( AB ), T 1 ) = u (( A ), T 1 )+ u (( B ), T 1 ) = (2+2) =4. Definition 15 (Total utility of database complex event sequence). The total utility of a complex event sequence CS is defined as u ( CS ) =  X  ),( in Figure 3 is u ( CS ) = u (( AB ), T 1 ) + u (( BC ), T T )+ u (( CD ), T 6 )+ u (( C ), T 7 ) = (4 + 8 + 3 + 4 + 18 + 3) = 40. Definition 16 (Utility value of an episode w.r.t its minimal event set SE i  X   X  is associated with a time point T i episode  X  w.r.t mo (  X  ) is defined as u (  X  , mo (  X  )) =  X  ),( [1, 2] is (4 + 6) = 10. Definition 17 (Utility of an epis ode in a complex event sequence). occurrences of the episode  X  , where TI i is a minimal occurrence of  X  sequence CS is defined as uv (  X  , CS ) =  X  ),  X  (  X  is defined as u (  X  ) = ( uv (  X  )/ u ( CS )). For example, the utility of the (20/40) = 50%. Definition 18 (High Utility Episode; HUE). An episode is a high user-specified minimum utility threshold min_utility . Otherwise, the episode is a low utility episode . Problem statement. Given a user-specified minimum utility threshold min_utility and a complex event sequence CS with external utility and internal utility of events, the problem of high utility episode mining is to discover all the episodes having a utility no less than min_utility . Definition 19 (Maximum time duration). Let MTD be a user-specified maximum time duration and mo (  X  ) = [ T s , T occurrence of the episode  X  . The minimal occurrence mo (  X  ) is said to satisfy the maximum time duration constraint iff ( T MTD. Definition 20 (Simultaneous and serial concatenations). Let  X  = &lt;( SE 1 ), ( SE 2 ),..., ( SE x )&gt; and  X  = &lt;( SE episodes. The simultaneous concatenation of  X  and  X  is defined as simul-concat (  X  ,  X  ) = &lt;( SE 1 ), ( SE 2 ),..., ( SE concat (  X  ,  X  ) = &lt;( SE 1 ), ( SE 2 ),..., ( SE x ), ( SE Definition 21 (Episode-Weighted Ut ilization of an episode w.r.t a minimal occurrence). Let mo (  X  ) = [ T s , T e ] be a minimal occurrence of the episode  X  = &lt;( SE 1 ), ( SE 2 ),..., ( SE simultaneous event set SE i  X   X  is associated with a time point T i  X  k ) and mo (  X  ) satisfies MTD . The episode-weighted utilization of =[  X  ),( +  X  ),( )1-+( simultaneous event set at the time point T i in CS . [ u (( C ), T 3 )] + [ u (( AB ), T 5 )) + u (( CD ), T Definition 22 (Episode-Weighte d Utilization of an episode). Let occurrences of  X  , where each minimal occurrence TI satisfies MTD for 1  X  i  X  k . The episode-weighted utilization of  X  in a complex event sequence CS is defined as EWU (  X  ) = ((  X  ),  X  ( &lt;( A ),( C )&gt; is EWU (&lt;( A ),( C )&gt;) = [ u (( AB ), T T )] + [ u (( AB ), T 5 ) + u (( CD ), T 6 ) + u (( C ), T Definition 23 (High Weighted Utilization Episode; HWUE). An episode is called High Weighted Utilization Episode (abbreviated as HWUE ) iff its EWU is no less than the minimum utility threshold min_utility . Theorem 1 (Episode-Weighted Downward Closure property). Let  X  and  X  be episodes, and  X  = simult-concat (  X  ,  X  ) or serial-concat (  X  ,  X  ). The Episode-Weighted Downward Closure (abbreviated as EWDC ) property states that if EWU (  X  ) &lt; min_utility ,  X  is a low utility episode. Proof. Let moSet (  X  ) = [ TI 1 , TI 2 , ... , TI TI  X  X . Because  X  = simult-concat (  X  ,  X  ) or serial-concat (  X  ,  X  ), | moSet (  X  )|  X  |moSet (  X  )| [21, 31]. According to the Definition 22, EWU (  X  ) = ((  X  ),  X  ( ((  X  ),(( &lt; min_utility , which yields that  X  is low utility (Definition 18). ( Utility ePisodes mining by Spanning prefixes ) for efficiently discover high utility episodes in a complex event sequence. The proposed algorithm adopts the prefix-growth paradigm [12, 24]. Following that, two efficient strategies that greatly enhance the performance are introduced. algorithm. The inputs of the UP-Span algorithm are: (1) a complex event sequence CS , (2) minimum utility threshold min_utility and (3) maximum time duration MTD . The algorithm scans the complex event sequence once to find 1-episodes and catching their associated minimal occurrences (Line 1-2). The EWUs and exact utilities of 1-episodes can be calculated according to the Definition 17 and 22. For example, Table 2 shows the minimal occurrences, EWUs and utilities of all 1-episodes in Figure 3 when MTD = 3.
 no less than min_utility ,  X  is identified as a HWUE of length one (Definition 23). Then, the algorithm explores the search space of high utility episodes containing  X  as prefix. The prefix  X  is spanned by executing the MiningHUE procedure (Line 3-5) . There are two sub-procedures MiningSimultHUE and MiningSerialHE in the procedure MiningHUE . The sub-procedure MiningSimultHUE aims at finding the simultaneous events that are related to  X  . The sub-procedure MiningSerialHUE aims at finding the serial events related to  X  (Line 7-9). which is performed as follows. For each minimal occurrence mo (  X  ) = [ T s , T e ] in moSet (  X  ), the algorithm collects all events that occur at the time point T e into the set SES ( S imultaneous E vents S et) (Line 1-2). For each event e in the set SES , the algorithm performs the simultaneous concatenation of  X  and e to form an episode  X  (Line 4). Then, the variable occ (  X  ) is set to [ T (Line 5). If occ (  X  ) is a minimal occurrence in the set of current minimal occurrences, occ (  X  ) is added into the set of minimal occurrence of  X  (Line 6-7) . After that, events that s imultaneously occur with  X  , their minimal occurrences are stored in the projected database of  X  (abbreviated as  X  -PB ). For each simultaneous event e in  X  -PB , we perform simultaneous concatenation operation on  X  and e to form the episode  X  (Line 11). For each such episode  X  , the function Repair_moSet is called to find the complete set of minimal occurrences of  X  since the current moSet (  X  ) does not capture the complete set of minimal occurrences of  X  . After that, all the minimal occurrences of  X  are collected into moSet (  X  ) . Given the information contained in moSet (  X  ), the utility and EWU of  X  can be calculated according to Definitions 17 and 21. For exampl e, Table 3 shows the minimal occurrences, EWU values and utility values of local 1-episodes in the &lt;( A )&gt;-projected database when MTD = 3. The events in the first row of Table 3 are simultaneous events of the episode &lt;(A)&gt;. After the calculation, if the utility of  X  is no less than min_utility ,  X  is high utility and it is collected into the set HUE_Set . If EWU (  X  ) is no less than min_utility , the procedure MiningHUE is called to find high utility episodes w.r.t. the prefix  X  .
 which is performed as follows. For each minimal occurrence between the time interval [ T e +1, T s + MTD -1] into the set NES ( N ext E vents S et) (Line 1-3). For each event e in the set NES , we perform serial concatenation operation on  X  and e to form an episode  X  = simult-concat (  X  , e ) (Line 5). Then, the variable occ (  X  ) [ T +1, T s + MTD -1] (Line 7). If occ (  X  ) is a minimal occurrence in the set of current minimal occurrences, occ (  X  ) is added into the set of minimal occurrences of  X  (Line 7-8) . After that, events that serially occur after  X  , and their current minimal occurrences are stored in the  X  -PB . For each serial event e in the  X  -PB , the algorithm performs serial concatenation of  X  and e to form an episode  X  . For each such episode  X  , the algorithm calls the function Repair_moSet to finds the complete set of minimal occurrences of  X  . After that, all the minimal occurrences of  X  are collected into the variable moSet (  X  ) . With the information of moSet (  X  ), the utility and EWU of  X  can be calculated according to the Definitions 17 and 22. For example, the last three rows of Table 3 shows minimal occurrences, EWUs and utilities of the three serial events of the episode &lt;(A)&gt;. After the calculation, if episode and it is collected into the set HUE_Set . If the EWU (  X  ) is no less than the min_utility , the procedure MiningHUE is called to find the high utility episodes w.r.t. the prefix  X  . ( D iscarding G lobal unpromising E vents) and DLE ( D iscarding L ocal unpromising E vents), which are based on the following definitions. Definition 24 (Promising event) . An event e is a pr omising event iff EWU ( e )  X  min_utility . Otherwise it is an unpromising event . Property 2. Let  X  be an unpromising event and  X  be an episode, Any super-episode  X  of  X  such that  X  =simult-concat (  X  ,  X  ) or  X  = serial-concat (  X  ,  X  ) is low utility. Rationale. The property holds by EWDC property (Theorem 1). Strategy 1 (Discarding Global unpromising Events; DGE).
 Discard global unpromising events and their exact utilities from the complex event sequence and related EWUs. Rationale. By the Theorem 1, unpromising events play no role in high utility episodes. Therefore, global unpromising events can be removed from the complex event sequence and their utilities can be ignored in the calculation of th e estimated utilities of episodes. Strategy 2 (Discarding Local unpromising Events; DLE). Discard local unpromising events and their exact utilities from the projected database and related EWUs. Rationale. By the Theorem 1, local unpromising events play no role in high utility episodes. Ther efore, local unpromising events can be removed from the projected database and their utilities can be ignored in the calculation of the estimated utilities of episodes. algorithms. Experiments were performed on a computer with a 3.40 GHz Intel Core 2 Processor with 4 gigabytes of memory, running on Windows 7. All of the algorithms are implemented in Java. Both synthetic and real datasets are used to evaluate the performance of the algorithms. Synt hetic datasets were generated by using the IBM data generator [3]. The parameters of the generator are described as follows: D is the total number of time points; T is the average size of a simultaneous event set at a time point; N is the number of distinct events; I is the average size of maximal potential episodes. The internal utility and external utility values are generated using th e settings used in [26, 28, 29]. Different types of real world datasets were used in the experiments. Foodmart , a small sparse dataset, was acquired from Microsoft foodmart 2000 database [35]; Retail was obtained from FIMI Repository [34]. ChainStore , a large dataset, was obtained from NU-MineBench 2.0 [36]. Note that these three datasets are sometimes viewed as transaction databases but they can be considered as a single complex sequence by regarding each item as an event and each transaction as a simultaneous event set. The Foodmart and ChainStore already contain unit profits (external utility) and purchased quantities (internal utility). For the Retail dataset, unit profits for items are generated between 1 and 1,000 by using a log-normal distribution and quantities of items are generated randomly between 1 and 5, as in [26, 28, 29]. Table 4 shows the characteristics of the da tasets in the experiments. To evaluate the performance of the proposed algorithms, we compare four versions of the algorithm named as follows. The baseline algorithm without strategies DGE and DLE is denoted as UP-Span(Baseline). The algorithm only applying the strategy DGE is denoted as UP-Span(DGE). The algorithm only applying the strategy DLE is denoted as UP-Span(DLE). Lastly, the algorithm UP-Span(DGE+DLE) uses both DGE and DLE strategies. We first discuss the performance of the algorithms on the synthetic dataset T12I8N1KQ5D10K. Figure 4 shows the number of candidates and high utility episodes on T12I8N1KQ5D10K under varied minimum utility thresholds when the maximum time duration is set to eight. In Figure 4, there is no high utility episode produced when the minimum utility threshold is lower than 30%. 
Figure 4. The number of ca ndidates on T12I8N1KQ5D10K Figure 6. Number of candidates and high utility episodes on T12I8N1KQ5D10K under varied maximum time durations
Figure 7. The execution time on T12I8N1KQ5D10K dataset As shown in Figure 4, UP-Span( DGE+DLE) generates much fewer candidates than UP-Span(Baseline). The reason is that strategy DGE effectively reduces the number of candidates by removing global unpromising events and their utilities from the complex event sequence. Although both strategies reduce the number of candidates, the effectiveness of the strategy DGE is better than that of the strategy DLE on this dataset. In the Figure 4, when the minimum utility threshold is less than 1%, the number of candidates generated by UP-Span(DGE+DLE) is about 100 times smaller than the number of candidates generated by UP-Span(Baseline). under varied minimum utility thresholds when the maximum time duration is set to eight. As shown in Figure 5, UP-Span(Baseline) is the worst and UP-Span(DGE+DLE) has the best performance. In Figure 5, UP-Span(DLE) runs fast er than UP-Span(Baseline) over 100 times when the minimum utility threshold is higher than 50%. UP-Span(DLE) and UP-Span(Baseline) follow a similar trend when the threshold is less than 10%. It is because the UP-Span(DLE) performs additional processing to decrease the overestimated utilities of the episodes but the there are few local unpromising events in the projected databases. When the threshold is lower than 5%, UP-Span(DGE+DLE) runs faster than UP-Span(baseline) about 10 times. By the above observati on, we show that the overall performance of UP-Span(DGE+DLE) outperforms UP-Span(Baseline). episodes of the algorithms on T12I8N1KQ5D10K under varied maximum time durations. In this expe riment, the threshold is set to 1%. As shown in Figure 6, the number of candidates grows rapidly when the maximum time duration increases. In Figure 6, we can see that UP-Span(DGE+DLE) generate s much fewer candidates than UP-Span(Baseline). When the maximum time duration is set to ten, UP-Span(DGE+DLE) generates about 10 times less candidates than UP-Span(Baseline). Figure 7 s hows the execution time of the algorithms on T12I8N1KQ5D10K under various maximum time durations. As shown in Figure 7, UP-Span(DGE+DLE) and UP-Span(DGE) run about 15 times faster than UP-Span(Baseline) and UP-Span(DLE) because the form er two algorithms produce much fewer candidates than the later two algorithms. lengths of complex event sequences. In this experiment, the maximum time duration and the minimum utility threshold are set to four and 10%. The number of time points in the complex event sequence is varied from 20K to 100K. Figure 8 shows the execution time for this experiment. As show n in Figure 8, UP-Span(DGE) and UP-Span(DGE+DLE) have be tter scalability than UP-Span(Baseline) and UP-Span(DLE) when the number of time points increases. When the number of time points is 100K, UP-Span(DGE) and UP-Span(DGE+DLE) run about 5 times faster than the UP-Span(Baseline) and UP-Span(DLE). on real datasets. We first show th e evaluation on Foodmart, which is a small dataset with 1,559 distin ct events. Figure 9 shows the execution time on the Foodmart da taset under different minimum utility thresholds. As shown in Fi gure 9, all the algorithms have good performance but UP-Span(Baselin e) is the slowest and the winner is UP-Span(DLE). On this dataset, the strategy DLE performs better than the strategy DGE. The strategy DLE effectively reduces the number of candidates by removing local unpromising events and their utilities from the projected databases. The execution time of UP-Span(DGE+DLE) is affected by the extra operations performed by the strate gy DGE, and thus it runs slower than UP-Span(DLE). When the minimum utility threshold is set to 10%, the execution time of UP-Span( DGE) is close to that of UP-Span(Baseline) since there are fe w global unpromising events that can be discarded from the complex event sequence. Figure 9. Execution time on Foodmart dataset under different 
Figure 10. Execution time on Retail dataset under different Retail dataset. There are 16,470 distinct events in the dataset and the average length of the transactions is longer than that of the Foodmart dataset. Figure 10 s hows the execution time of the algorithms on the Retail dataset under different minimum utility thresholds. The results show that UP-Span(DGE+DLE) and UP-Span(DGE) follow a similar trend and they run faster than the UP-Span(Baseline) and UP-Span(DLE). ChainStore dataset under different minimum utility thresholds. In this experiment, the maximum time duration is set to four. As shown in Figure 11, UP-Span(DGE +DLE) is the winner and UP-Span(Baseline) has the worst performance. When the threshold is higher than 20%, UP-Span(DGE+DLE) runs faster than UP-Span(Baseline) over 100 times. When the minimum utility threshold is set to 10%, UP-Span incorporated with strategies run faster than UP-Span(Baseline) over 10 times. Figure 11 also shows that UP-Span incorporated with strategies has good scalability even for large database with large number of events. The overall performance of UP-Span with strategies is be tter than UP-Span(Baseline). Foodmart and Retail datasets. Figure 12(a) shows the memory consumption of the algorithms on Foodmart dataset under different minimum utility thresholds. We can observe that UP-Span with strategies uses less memory than UP-Span(Baseline) since the proposed strategies effectively reduce the number of candidates and the number of projected databases. Figure 12(b) shows the memory consumption of the algorithms on the Retail dataset under different minimum utility thresholds. Overall, results show that the best algorithm is UP-Span(DGE+DLE) and the worst one is UP-Span(Baseline). characteristics of different algorithms. The experimental results show that our approach outperforms the baseline approach on both real and synthetic datasets. For example, UP-Span(DGE+DLE) runs over 100 times faster than the base line approach on the ChainStore dataset when the minimum utility threshold is higher than 20%. Depending upon the characteristics of the datasets, the most effective pruning strategy can be different. For example, for the Foodmart dataset, the pruning of lo cal unpromising events (strategy DLE) gives the best performance, wh ile for Retail dataset, it is the pruning of global unpromising events (strategy DGE). UP-Span(DGE+DLE) provides the most consistent and robust performance as it takes both types of pruning strategies into considerations, while UP-Span( DGE) and UP-Span(DLE) perform well only on one of the datasets as it incorporates just one type of pruning strategies. UP-Span(Base line) always has the worst performance as it does not utilize the DGE and DLE pruning strategies. and high performance on large database s. First, our approach is not Apriori-based. It discovers pattern s by recursively growing patterns one item/event at a time. This avoids well-known drawbacks of Apriori-like approaches: (1) generating too many unnecessary database. Second, our approach finds ( k +1)-episodes and their occurrences by using minimal occurrences of related k -episodes instead of all the occurrences, which leads to faster calculation and less memory consumption. Third, our approach finds high utility episodes in only one phase, as opposed to most high utility pattern mining algorithms [5, 7, 26, 33], wh ich require collecting candidates and performing an additional database scan to calculate their exact utilities. This facilitates the performance of the mining task in terms of time and space. episode mining and propose a nove l framework for mining high utility episodes in complex event sequences, which has not been explored so far. In the proposed framework, we consider the external utility and internal utility of events to measure the utility of episodes. We take the scenario of the complex event sequences into consideration for mining high utility episodes containing simultaneous events, which not only provides users with episodes with high utilities (e.g. high profits) but also more information about the relationships between episode s. We proposed a new algorithm named UP-Span ( Utility ePisodes mining by Spanning prefixes ) for efficiently mining the complete set of the high utility episodes. We successfully extend the TWU model to episode mining and propose the EWU ( Episode-Weighted Utilization ) model to facilitate the mining task of high utility episode mining. Two effective strategies, namely DGE ( Discarding Global unpromising Events ) and DLE ( Discarding Local unpromising Events ), are also proposed and incorporated with the UP-Span al gorithm, which not only reduce the number of candidates produced in the mining processes but also enhance the performance of them mining task in terms of execution time and memory consumption. E xperimental results on both real and synthetic datasets show that UP-Span has good scalability and outperforms the baseline approach substantially, especially under higher minimum utility threshold (e.g. UP-Span runs faster than the baseline approach over 100 times on ChainStore dataset when the minimum utility threshold is higher than 20%). with episode mining and address the problem of high utility episode mining in this work, it still leaves ampl e room for exploration in the future work. For example, in this paper, we only consider serial episodes containing simultaneous ev ents and do not consider other types of episode such as injective episodes [22], parallel episodes [22], closed episode s [19] and so on. In addition, there are many different ways to calculate the occurrence of episode, such as window-based occurrence [11, 22], non-overlapped/overlapped minimal occurrence ect., which can be addressed in the future work. Mining high utility episodes from event sequences is a novel and challenging problem. Related resear ch topics ranging from problem definition to algorithm improvement and applications are worthwhile to be explored in the future. This work is supported in part by National Science Council, Taiwan, R.O.C. under grant no. NSC101-2221-E-006-255-MY3 and NSF through grants IIS-0905215, CNS-1115234, IIS-0914934, DBI-0960443, and OISE-1129076, and US Department of Army through grant W911NF-12-1-0066. 
