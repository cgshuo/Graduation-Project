 Semantic data is becoming increasingly important as the number of triples increase. W ith the explosion of information over the web (New York Times, LOD and Best Buy) and the common use of relational databases for RDF data , it poses a formidable challenge to improve RDF data management approach es. A challenge is to store large -scale RDF triples efficiently . Unfortunately, most existing RDF storage solutions do not achieve a high level performance or are still suffering from scalability problems . To this end, we attempt in this paper to bridge the gap s of the current RDF storage methods in RDBMS by combing the strengths and most sophisticated database physical models with the inferencing techniques that ontology and Formal Concept Analysis (FCA) support . We, thus, aim at analyzing and narrowing the gap between a state -of -the -art method by developing a n RDF storage model based on ontologies with the help of FCA clustering solution s for speed and high scalability. Hence, we have proposed a new framework, TripleFCA, to maximize the inform ation retrieval benefits and improve the query response time of RDF triple storages. Our evaluation shows that TripleFCA decreases major bottlenecks of property -table, one of the state -of -the -art RDF storage methods into RDBMS, and yields a much better per formance thanks to the benefits of combining ontology and FCA over RDF storage. Our results also demonstrate the weaknesses of property -table and how they can be mitigated .
 Semantic Web, RDF data management, Triple Store, Ontology, FCA, Relational Database
The World Wide Web has become indispensable to people X  X  daily lives. It is therefore important to look into a new web to be able to improve on the way information is expressed to make more intelligent choices and obtain a bette r meaning of the information over the Internet. Hence, Semantic Web is the standard that promotes a common framework on the Internet, which allows sharing of data and reuse across many platforms. For more than a decade S emantic W eb has been used widely and is still growing in government , health, business, academia, industry and the public. This technology helps machines to understand the contents of the web rather than just reading it. To achieve this, Resource Description Framewo rk is a flexible s emantic data model for representing information about resources or objects across the web . Hence, the web has long been developing towards this vision by embedding huge quantities of machine -processable metadata and structure in the form of ontologies in order to give the machines tools to find, interpret and exchange information.
 of the Semantic Web. It is a formal specification of shared conceptualization utilized to structure a set of objects with their predicates conceptually , and it is currently used mostly for sharing knowledge. With the increasing number of ontologies, sometimes concepts in single domain ontology or in multiple ontologies are expected to be similar and more likely to be overlapping. This is because concepts are not always made straight forward, but sometimes embedded implicitly within documents. However, sharing information into ontology to derive all implicit knowledge, then cluster them in one conceptual com ponent is considered as a major problem [1] .
 concepts within a specific domain, we need more expressive reasoning in ontology engineering. Formal Concept Analysis (FCA) is one of the ontology techniques that identifies groups of concepts from a given o ntology that share common predicates. Therefore, a common structure can be created with a robust conceptual hierarchy  X  lattice -, relating each predicate with the most specific subset of common concepts. This robust and conceptual lattice enables users to n avigate, derive and cluster collections of implicit relations and concepts in a given ontology. In light of this, FCA algorithms can be used to analyze an ontology X  X  concepts and then organize them in a hierarchy that supports their inherent structures , im plications and dependencies .
RDF acts as a data model used to manage, structure, and reason about the data found on the web. With the increasing number of RDF triples, they significantly facilitated the growth of the Semantic Web and ultimately led to the generation of a wealth of data. The handling of a large -capacity of structured, semi -structured and unstructured data requires modern frameworks and storages. As a result, RDF repositories are cores in the Semantic Web since they are a database purposefull y built for the storage and retrieval of RDF triples. They represent a huge number of challenges like query performance and efficiency, the expected number of requests, and the suitable response times. So to enhance scalability of the storage with efficien t response times, considerable attention must be given to these semantic storages. In light of this, several methods to overcome these limitations while adopt to this growing of huge data volumes have had to be integrated to be more efficient and effective .

These storages methods are either based on the type of data used to partition RDF triples or on modifying the number of indexes. It is important to note however, that s everal triple storages methods have been developed and are generally divided into thre e categories based on the execution of their structural design as can be seen in Fig 1.1 . The first category includes Native t riple stores which create a database engine from scratch and offer new methods for storing and accessing RDF data. These methods c losely reflect the RDF data model in order to eliminate the need to do any mapping to a Database Management System (DBMS). Some frameworks for native trip le stores are, for example, Jena , Redland, AllegroGraph, 4Store, dipLODocus, OWLIM, Yan et al [2] RDF -3X [3] , Hexastore [4] , TripleBit [5] , TripleT [6] , TripleProv [7] , BitMat [8] , and Sakr et al [9] . The second category involves Relational Databases t riple stores which are constructed on top of existing relational database engines and typically require mapping onto an RDB. In general, t he RDBMS triplestore, which is based on DBMS solutions, can be classified into two techniques: one is schema -dependent and a nother is not (e.g., 3store [10] , RDF -3X [3] , Hexastore [4] , RDFJoin [11] , and SWIM [12] ) . Some relational databases based solutions that use partitioning techniques and guided by the entity (e.g., [13] [14] [15] ) or concept (e.g., Jena2 [16] , RDFBroker [17] , Oracle [18] , data -centric storag e [19] , DB2RDF [13] , and ohStore [20] ) . The most popular techniques of the other storage named property -based triple stores include, for example, Vertical Partitioning [21] , Beckmann et al. [22] , and Sidirourgos et al [23] . Between the two above triple stores, there are hybrid triple stores that are combined between the two architectures Native and Relational databases triple stores. Some proposals for a hybrid of those two storages include, for example, Sesame [24] and Virtuoso [25] . The third and final category involves Non -Relational t riple stores (or NoSQL t riple stores ), which are an important kind of RDF stores that are good for large sets of distributed data. In addition, this type of triple storage deals well with scalability and performance issues that occur with big data [26] . Example techniques of this sto rage include: [27] [28] . However, t he above three storage categories are the common storage systems to manage and store RDF triples. However, arguably, managing RDF data can rely on other storage systems [29] [30] either storing RDF data in matrix [31] with bit -vector compression to improve query response time , or storing RDF data in XML [32] by converting triples to XML and then apply XML techniques such as: XPath, XQuery, and even store triples into an XML Database.
 In actuality, most of these types of storages are mainly based on RDF to store and man age triple data but that is not the right solution since it is just a data model. Therefore, i t is essential to put more emphasis on the expressive ontology techniques to improve the performance and scalability of storing and managing the S emantic W eb data . Thus, in our approach, we develop a storage model where FCA and ontologies can be combined to contribute as an approach to store RDF data over Relational Database s . This storage model should be established by clustering similar set of concepts using thei r relation al semantically in order to get the association between them within the conceptual hierarchy.

It is important to note the limitation s of s emantic triple storages. Therefore, a DBMS -based technique will be used as a solution for our approach since it gives better performance and query optimization as a result of the large quantity of work acquired to induce relational quer ies efficient ly . For large amounts of data, the use of DBMS is more reasonable than native -store. NoSQL has just simple data mod els that are neither interoperable nor standardized in comparison to DBMS, and does not offer any high -level declarative query language equivalent of SPARQL .
 Fig ure . 1 .1 Taxonomy to RDF triple repositories .

The primary contributions of our paper may be summarized as follows:  X  To propose a new systematic taxonomy of RDF triple  X  To compare the three data models (RDB, Ontology and  X  Building an RDF storage model to present how the state -of - X  Partitioning the dataset and analy zing of its concept  X  To show  X  X ripleFCA X  as an alternative approach for 
Organization . Section 2 briefly reviews the foundation concepts of Formal Concept Analysis. In section 3, we provide the related work and state -of -the -art of storing RDF data into rational databases, followed by the discussion of the benefit of using FCA in the s emantic world. The approach is sketched in section 4. The experimental design, evaluation and results are shown in section 5. Finally, we conclude the paper in section 6 with an outlook on future work.
A comprehensive information abo ut Formal Concept Analysis (FCA, for short) is given in [33], [34] , so that w e just recall the basic notion s of FCA as far as they are required to this work. FCA is an ontology techniq ue that clusters a similar set of concepts to capture the real conceptual structure of a given ontology. The solution of applying on tology over RDB that we propose utilizes the algorithms of FCA . In general, FCA is a technique of analyzing and clustering data with robust mathematical foundations in order to identify a n intrinsic conceptual hierarchy of a given dataset. It has attracted attention in various areas of ontology (e.g. ontology design [35] and mapping [36] ) that can unfold seman tic data in a concept lattice, making this conceptual lattice graphically displayed to process knowledge and extract generalized patterns in the form of sets of objects and sets of attributes. 
The description of a concept in FCA is a collection of objects or extent related with a specific collection of attributes or intent , as shown in F igure 2.1.
 Fig ure . 2 .1 Formal concept in FCA .

More formally, FCA is based on the notion of formal context (matrix ), as shown in Table 2.1, that is expressed as a triple M = (O, A, R) , where O is a collection of objects, A is a collection of attributes and R is a binary relation R  X  O  X  A. Now it is much easier to describe the concept. For X  X  O and Y  X  A . Then, X {a  X   X  |  X   X  X  X   X  : oR  X  } and Y  X  = {o  X  O |  X   X  X  X  Y : oR  X  } . A formal concept C is a pair X and Y that satisfy the condition X=Y Y=X  X  .

The hierarchy of all concepts that relies on the subconcept relation is formalized by: (X 1 , Y 1 )  X  (X 2 , Y 2 )  X  X  X  Y 2 . The concept lattice of a context M is the set of all its concepts with the partial order  X  .

In fact, ontology can benefit from FCA by generating two types of outputs: analyzing a set of concepts to provide a conceptual lattice that cluster all similar concepts and offering a dependency in data (attribute implication) to identify a common relation between attributes and those concepts . Thus, FCA provides specific binary relations identify which objects can be linked with common attributes . huge quantity of RDF data is challenging. It is important to deal with these challenges since RDF repositories play a significant role in achieving the vision of the Semantic Web. Relational databases have improved the efficiency of storing and retrieving triples, which has prompted the Semantic Web community to develop various methods to help scale out and enhance the performance of a tripl e store .
 RDF data management techniques, approaches, and tools. Besides, the limitations of the current state of the art of managing data on the web will be discussed with respect to speed and vario us characteristics of scalability using RDBMS, as well as analyzing other problems that provided much inspiration. empowering d ata to be effectively applied in the present computer filed. Comparing the three schemas of data model: relational databases (RDB), Semantic W eb (ontological) and Formal Concept Analysis (FCA), they go to model concept though they design for diverse purposes. First , in relational databases, information is typically structured in a relational model, in which relations are used to manage data. This data lives in a closed world assumption as a fixed schema, so that there is no way to share or re use this schema data [37] . As a consequence, relational database keys, such as primary keys and foreign keys are local to that database schema. Second , the s emantic ontology schema is used to model concepts with more specific predicates on a domain of interest. As such, concepts in domain ontology are more possible to be related; this is because they are not always made straightforward, but sometimes embedding implicitly within documents. Another, significant factor i n ontology is that it is an open world assumption schema that provides meaningful facts about a domain. This means that in the ontology, the data can be both shared and reused. For this purpose, Semantic Web technologies use the URIs to identify a unique l ocation for each resource, and those URIs are global which are essential universal keys for the ontology schema. This will help the Semantic Web to integrate data over the web more easily than the database world [38] . Third and the final data model is the FCA. The essential objective of FCA is to disco ver data or concepts from a domain of interest in order to generate knowledge and identify a conceptual hierarchy of those concepts. In light of this, concepts in a given dataset are expected to be similar and more likely to be overlapping which is becomin g critical . With this in mind, clustering similarity relations together is getting to be key in the performance of RDF repositories in order to enhance information retrieval to retrieve more related answers of queries with a reliable time [39] [40] .

When using a conventional database, it is possible to store concepts in tables with no information stored in the system to define the meaning of the concepts, or to describe the ways that they link to each other. Ontologies solve this issue . T hey explain what data means , and they allow inference to generate needed information . This provides a rich description of concepts to generate new implicit facts that lead to new meanings and that make it easier to combine various explicit/implicit information that is semantically related, where this is not the ca se for most plain databases [21]. FCA is an ontology technique that can be used to analyze and cluster a similar set of concepts based on a robus t conceptual lattice that relates any predicate with specific common concept s .

Having considered the above analysis, it is reasonable to combine both ontology and FCA which may be the best way to describe our schema, owing to our need to share information rather than data. Accordingly, we attempt in this paper to bridge the gap of the Current RDF storage methods in RDBMS by combing the strengths of sophisticated database physical models with the inferencing technique s that ontology and FCA support . I. A giant Triple Table storage model : One of the easiest methods that aimed at integrating RDF data into relational databases. This solution focuses on a non -partitioning technique that has a long RDF triple table with one statement (three col umns schema &lt; S,P,O &gt; ) for each row. Table 3.2.1 presents a single table of RDF triples for a small dataset. In this technique, each column must be carefully indexed to lessen the number of joins; columns with indexes require more operations, such as updati ng, than columns with minimal indexes. Storing all triples in a single table creates serious scalability issues, because queries will instigate a search of the entire table. Also, with a large quantity of RDF data, it raises the potential for the table to exceed the memory capacity and creates subsequent obstacles to pick any specific piece of data. Due to these issues, storing numerous triples in a single table does not scale well and further most complex queries require multiple self -joins between statements, as mentioned in [4] [16] . Nevertheless, in order to mange huge triple stores, some efforts have been made like RDF -3x [41] and Hexastore [4] , which rely on the notion of indexing RDF data in different indexing schema . simple query processor that controls fast merge joins to largest possible extent and generic solution for indexing RDF triples -sextuple indexing -that eliminate completely the need for any physical design tuning for the storage. There is also query optimizer that is used in choosing optimal join orders by employing a cost model depending on the statistical synopses for all the join paths [42] .
 Hexastore. It stores the triples in a native disk that uses vector indices. Hexastore organ izes triples for indexing it in six ways, one for every permutation of the three RDF triples. Each index is divided into three levels representing the components of the RDF triple &lt; S,P,O &gt;, and all levels are stored in vectors. For each query, this method w ill perform a fast merge -join for any pair of two triple patterns [43] . As such, a constant -time lookup is offered by Hexastore for any given RDF triple. Hexastore does have a significant disadvantage due to its inability to support incremental operation of updating and inser ting; this is because all six possible indices have to be resorted and therefore reducing down the level of performance.
 Table. 3 .2 .1 RDB -based RDF Storage techniques
Atre et al. [8] proposed an approach called BitMat that rely on a matrix index. The main idea of this technique is t o compress storage for RDF triples for storing big RDF data in memory. For example, BitMat compresses the RDF storage by avoiding index sharing as Hexastore does (SPO and PSO share the  X  X  X  index). In actuality, triples in BitMat are stored as a three tripl e dimensional bit -cube. Each cell in the bit -cube states a single RDF triple with all SO, OS, PS, PO in order to store them in a single file. Notably, BitMat uses bit vectors data structure to assists in performing the lookups.

TripleBit [5] is another similar storage layout to store RDF triples with two auxiliary index forms. Likewise to BitMat, TripleBit presents a storage model for indexing that provide compression schema to a ccommodate large -scale triple s. In TripleBit, each column represents a single predicate and rows represent subjects and objects. Each cell has either 0 or 1 so that every column must contain at most two 1 X  X  representing the relationship between subject and object. However, in contrast to BitMat, TripleBit can handle large RDF triples than BitMat thanks to its efficient index and join processing. Furthermore, TripleBit presents a more compact design in storage and index as compared to BitMat and other indexing storages. Lastly, a dictio nary data structure that map strings to IDs and vice versa is not offered by BitMat, so that TripleBit has many advantages in this case.
 II. One -Table -Per -Concept storage model : It is an alternative storage model for storing and representing semantic data horizontally. The most popular methods used this technique are proposed by [16] [18] [19] in order to minimize the number of self -joins and hence speeds up the overall perf ormance of queries over triple tables. Property -tables (PT) storage model or one -table -per -class alters the schema of the giant Triple -store to lessen the large number of self -joins. This approach partitions the large table of Triple -store into a significa nt number of tables which include related properties as shown in the schema of Figure 5. 2. 1 . To that end, Jena RDF framewor k [16] is one of the popular technique used in PT that groups related subjects by using the property  X  rdf:type  X  of subjects that are usually identified with the same set of properties. The triples left over that do not reside in property tables are placed in a non -class table. The PT approach does produce mul tiple null values, which happens when some of the properties in a single table are not identified for all the clustered subjects. In the PT method, a single subject does not have the ability to store multi -valued attributes, which is another limitation of this approach. Finally, the biggest obstacle in the property -table method is the number of union clauses and joins that can be created. This occurs because queries are not restricted to one property -table, so querying numerous tables end up with complex jo ins and unions, which consequently can create a complex query translation [21] .

To maximize efficiency, OhStore (Ontology Hierarchy Store) technique [20] improves upon the state of the art of property -table storage mode l. It proposes a framework that improves state -of -the -art scaling methods by developing a storage model based on the ontology hierarchy and by clustering classes with the help of their semantic relatedness. In practice, after obtaining the ontology class f rom a large triples table or a given ontology, ohStore extracts all concepts that are semantically connected based on its own algorithm that relies on the concept hierarchy, the levels in the ontology, and common predicates to cluster similar sets of conce pts. Hence, ohStore can now store the semantically similar concepts together. As related concepts merge in conceptual units, ohStore, thus, reduces the number of joins among relations and increases search efficiency and thus improve the performance of runn ing queries and the scalability of ohStore.
III. One -Table -Per -Entity storage model : A slightly different storage model to the previous one, which is property table storage model, is to group multiple predicates into the same tuple based on a common subject entity.

More recently, Bornea et al. [13] propose a hybrid approach named DB2RDF that based on entity clustering. To clarify, it aims to group all triples that related to a subject in a single row by combining each predicate into the same column and a single wide table named Direct Primary Hash (DPH). Thence, if a subject has multiple -valued predicate, then the predicate X  values can be stored in a successive tuple in a separate binary table called Direct Secondary Hash (DSH). Notably, DB2RDF indexes RDF triples in two ways, once rel y on the subject and the other rely on object. However, similar to property table triple stores, this technique has the disadvantage of too many null values which can be produced due to all predicates are not associated for the same entity. Additionally, t he size of DB2RDF X  X  triple store is increased due to redundancy of the same data.
 IV. One -Table -Per -Property storage model : It is another storage layout for managing RDF data vertically. It was presented in Abadi et al. [2 1] as an optional schema used for storing RDF data. It was motivated by the scalability problem regarding the storage of RDF data in relational databases. The giant triple table ( t riple store in the schema Table 3. 2.1) was redesigned in order to create N two -columns tables for each individual predicate (N is the number of unique predicates). The first column holds subjects and the second holds objects as shown in Table 3. 2. 1 . A specialized database architecture colu mn -store DBMS [23] [44] is utilized to store RDF triples in the VP method. This type of architecture is used in order to prevent the need to access whole rows into memory if just relevant columns should be retrieved for a given query. Despite this, the VP approach lends support to multiple -value attributes. In this method, only the properties that are directly related to a given query will be read from the related column, with no need to read any of the other tables. In this way, search queries that include bounded properties achieve better performance. However, the VP method is limited in its ability to scale well with unbounded properties because it must scan the entire table, and it requires num erous joins within the tables. This can negatively impact system performance [45] . Further, queries that need to make joins on objects are not able to use the linear -merge join because data is not clustered on the objects. Obviously, the technique of Vertical Partition could be a particular case of Hexastore in which the index is placed either on subjects or objects. Also, the performance of Hexastore is better than that of the Vertical Partitioning.
Recently, significant studies have figured out how to store RDF data in native triple store s . But the partitioning of a dataset is still a relatively young research field. In light of this and based on current research on the partitioning of triple stores, we plan to focus on how triple stores may be partitioned in to relations to improve the efficiency and performance of relational database Triple stores. In the design of the Semantic Web, the most influential semantic factor is the ontologies, and hence the major factor in the defining of our partitions and relatio ns will be the ontologies. Additionally, we combine FCA with the ontology to help us discover a set of implicit relations in effective way s rather than just positioning th em in the taxonomical hierarchy . 
In an ontology or any schema som e concepts are exp ected to be similar and more likely to be overlapping. As a consequence, we are looking to cluster similar set s of concepts that satisfy given constraints. In our approach, thus, we propose TripleFCA as a solution that clusters concepts (ontology classes) based on their meaning so that all classes that are semantically connected can be stored together in one table as conceptual components. TripleFCA classifies and group s related concepts based on their predicates using Formal concept analysis. As shown in f igure 4.1 , we firstly partition the entire set of the triple store and then build a concept hierarchy by extracting a unique concept with their predicates from a given ontology (step 1) . Next, based on those concepts with all their predicates , we then can build a formal context or matrix (step 2) that will help us further to construct a concept lattice out of the matrix (step 3) . Accordingly, we can now identify similar concept in order to cluster them as a meaningful unit as shown in Figure 5.2 . In other words, based on this concept lattice further generate a hierarchy of concepts as well as meaningful ly abstracting the concepts from which concepts can be clustered together as conceptual components iff they belong to the same extent, i.e., the same set of related properties (step 4) .
 The reason behind integrating FCA and ontologies to apply them over RDB has two purposes: 
First , the ontology as a backbone of the Semantic Web has been used widely and still growing, so that the number of concepts in a unique ontology or in multiple ontologies it may rapidly boom in the size. This means that dealing with a concept as a distinct uni t without using any clustering technique when it comes to store them in triple stores, it may scale poorly and exacerbate bad performance behavior for querying and retrieving RDF triples. Moreover , it is natural for concepts in a domain ontology to be very similar so that clustering technique such as: FCA aims at modeling and clustering concepts. 
Second , it will classify a set of ontological concepts from a source ontology that share common predicates or properties. For this purpose, these sets of concepts are structured in a lattice, relating any concept with specific predicates to form meaningful units. This strong hierarchy allows one to browse the set of implicit relations and concepts for a given ontology. In light of this, we can cluster several relat ed concepts and predicates together in a conceptual way in order to store them as (one table per concept). However, FCA concept lattices are commonly subclasses, so that we can retrieve employee data directly instead of using 13 sub -queries and 12 unions. Thus, we increase search efficiency and, hence, improve the performance of running queries with TripleFCA. 
The Lehigh University Benchmark (LUBM) [19] has been used to generate datasets for our experiments and evaluation. Figure 5.2.1 represents a partial set of the hierarchal ontology for this benchmark. This dataset is made up of an academic dom ain (e.g., professor, department, student, and course) , as well as millions of instances for enormous scalability. LUBM is made up of concepts that have the ability to be polynomially generated, which is a significant consideration in this evaluation, beca use LUBM queries will be carried out on all datasets for the purpose of offering information on scalability issues. Synopsis Size . OWL lite is the ontology language expressed in LUBM which contains 43 classes, 25 object properties, and 7 data properties. We generate 6 various LUBM datasets from 1.3M to around 14M triples (as shown in Table 5.2.1) to test our scalability. More specifically, w e show in Table 5.2.1 the number of triples held by each dataset, the number of instances that belong to concepts and properties as well as their size on disk and number of OWL files with the total size. The ontology is available online at LUBM website 1 Queries . The experiment is implemented with 1 1 queries on the LUBM benchmark under different aspects of datasets. These queries are translated to SQL to meet the storage layout s following the [29] technique. We, firstly, convert SPARQ L -to -SQL queries to create one relational triple table for each triple pattern. Then, make joins among similar variables in triple patterns . Secondly, query optimization are made over SQL queries that takes into consideration different facets and strategie s: triple store schema, join between them, number of retrieved attributes, selection and join algorithms and effective indexes used . Now, when the queries are done, we compare the performance of TripleFCA and property -table techniques on top of row -store ( Postgres) and column -store (MonetDB) databases. Each individual query was run 10 times, and then the average query time was found in order to provide reliable times. Note that our test used cold runs (query execution for the first run) and hot runs (query execution after warm up). http://swat.cse.lehigh.edu/onto/univ -bench.owl DB systems . PostgreSQL (v9.3.4) was chosen for the row -store database system because it is extremely reliable, and the integrity of data is unimpeachable. It performs better than MySQL and other types of row -oriented databases when tasked with data analysis and runn ing complex queries [50] . On the other hand, Monet DB (5 server v11.15.19) [51] [52] was selected as the column -oriented DBMS because it broke new ground for high performance with big data [53] . And it has favorable performance when compared to other column -oriented solutions. Also, it scales well vertically with faster queries.
 Indexing structure . The experiment uses indexing for TripleFCA and p roperty -table approaches. In the row -s tore database (PostgreSQL), a clustered B+ -tree index [53] i s creat ed on the subject column. Also, an unclustered B+ -tree index for each predicate column for both approaches TripleFCA and PT is created . On the other store architecture, which is a column -store database (MonetDB), the index data structure is ignored [23] . This led us to order the RDF triples by subject for the two approaches . The aim of this evaluation is to examine how to optimize the partitioning of tables, and to cluster the concepts in a meaningful way to gain better query performance and scalability. In this section, we display and discuss our experiment results. Results are generated with each execution of the 11 LUBM queries . Overall, the performance of TripleFCA outperforms the state -of -the -art property -table on cold time (for all 11 queries) and has significantly better query performance on hot time for most cases (10 out of the 11 benchmark queries). Each table represents the TripleFCA and property -table approaches in terms of the row -stores (TripleFCA_R and Prop_Table_R) and the column -stores (TripleFCA_C and Prop_Table_C) .
 Query 1 . This query has to find all information for the class ( GraduateStudent ) who takes the course ( GraduateCourse0 ). It does not assume any reasoning or hierarchy clustering over the relevant information s ince a unique class and predicate are involved. However, TripleFCA performs better than property -table in both row and column stores because in the property -table case information is retrieved from two wide tables combined with union. While TripleFCA query retrieves data directly from one narrow table with no null. As such, transferring a single relation to the memory instead of two relations improves the time and complexity of the query. Furthermore, since this query retrieves a single column, the column -o riented DBMS has an advantage over row -oriented DBMS, allow MonetDB to achieve a much better search performance than PostgreSQL .
 Query 2 . A more complex query process was used with query 2 . It requires retrieving a graduateStudent who is a member of a given department and this department is suborganizationOf a University . Moreover, that student had to get his undergraduate degree from the same university. The results in the tables below show that property -table has gained advantage over TripleFCA due to the property -table pe rforming joins on three relations instead of four which is the case with our approach. Since this query returns a single column from each relation, the column -oriented storage achieves higher performance than row -oriented in all dataset se quences . Query 3 . This query displays all publication of ( AssistantProfessor0 ). It has similar structure as query 1 but involves a wide concept hierarchy of the class Publication. Therefore, it is significantly affected by using (TripleFCA and property -table) clustering approaches. According to the results, TripleFCA excelled over property -table due to the grouping of all related information in a single table instead of implementing multiple join over three wide tables. Also, the column -oriented has an advantage over row -oriented due to retrieving a single column plus the query filter s the results based on the pa rticular object or column value .
 Query 4 . This query aims to extract names , emails , and telephones of professors for a given department . This query requires hierarchical information associated with the class professor. The results of query 4 confirm the efficiency of our approach over the property -table because in TripleFCA all professors are in one relation with si milar predicates. Therefore, there is no need to run several queries to extract professor information from four relations which is the case with the property -table. Accordingly, this reduces the number of sub queries, and thus, minimizes the time and effor t in order to make the performance of the query extremely fast. Since the query requires retrieving multiple columns and combining multiple union clauses and join operations, the row -oriented approach is better able to scale with an increasing number of tr iples as ca n be seen in the results .
 Query 6 . This query has to display a variety of students either explicit data (e.g., undergraduateStudent ) or implicit data ( graduateStudent ). The results show the efficiency of TripleFCA over property -table although th e join is performed on two similar tables. This is because of the advantage of avoiding null values with TripleFCA . Also, the column -oriented approach has an advantage over row -oriented due to retrieving a single column plus the query filter s the results b ased on the particular subject .
 Query 7 . This query retrieves all students who take course with the ( AssociateProfessor0 ). Here we can test the performance and scalability of our approach since ontology concept relationships are taken into consideration for the professor concept. So the result of TripleFCA achieves high performance and scalability due to the professor hierarchy being in single relation avoiding the need to query multiple relations corresponding to each professor class. However, we observed that the column -storage improves when the number of RDF triples is increased for both TripleFCA and property -table because of the efficiency of I/O of column -storage with large -scale triples transferred to the memory as can be s een in the results.
 Query 8 . This query has to generate inferences to retrieve all required information. Therefore, it is significantly affected by clustering approaches. The query 8 aims to find all information of students with their emails and departmen ts . Besides, t his department has to belong to the University0 . The results show that TripleFCA is performing joins on three relations avoiding the need to run multiple queries to extract the required information from different relations which is the case w ith the property -table. Hence, the TripleFCA approach achieves better performance than property -table. Again we see that the column -oriented approach is better able to scale with an increasing num ber of triples owing to retrieving an individual column for each sub -query .
 Query 9 . This query aims to extract all students who take courses taught by their advisors . T he class faculty has wide hierarchical information associated with it to be applicable for clustering. Markedly, the results present the advantage of our approach since the query requires a subclass relationship of the faculty concept. To clarify, TripleFCA is performing joins on four relations avoiding the need to perform joins on eight relations to retrieve the desired data, which is the case with the property -table. On the other side, the performance of row -storage is doing much better than column -storage owing to retrieving several columns plus doing several union and join operations to derive the required triples .
 Query 10 . This query aims to ex tract a subclass relationship of the student concept that is only related to entailed triples of the graduateStudent . Although both approaches work in a single relation to extract related data, TripleFCA obtains the best performance in all dataset sequence s thanks to a combination of various explicit/implicit predicates that are semantically related which is not the case for the property -table. The performance of column -oriented performs much better than row -oriented due to work ing on a unique column .
 Quer y 11 . This query aims to find all instances of research group of a given department which is a sub -organization of a specific University . The two approaches seem quite similar with some advantages to TripleFCA in both row and column stores. The performance of column -oriented is far better than row -oriented DBMS owing to retrieving a unique column . Query 14 . This query is not presupposing any subclass hierarchy. It has to find all explicit information about undergraduate students . In TripleFCA, all require d information belongs to a single relation contains all correlated predicates instead of querying and performing joins on multiple relations in the property -table case . It is not surprising for DBMS types that column -storage has an advantage over row -orien ted due to retrieving a single column, as shown in the results below .
 Observations . Four observations consistent with our hypothesis can be made from the evaluation results. First, we observe that when the number of triples scale the performances of Tripl eFCA improved , signifying scalability. This means that our approach will work better than property -table in many cases in both small chunks of triples or big data (e.g., Queries: 1,3,4,6,7,8,9,10,11 and 14). Second, in our study whenever the query assumes hierarchical information associated with it or is suppose d to do inferences (e.g., Professor class), TripleFCA achieves better performance and high scalability thanks to the significant of clustering technique implemented by FCA and guided via ontology, ac cordance with our hypothesis. To illustrate, clustering all concepts with their semantic predicates lead s to storage of all relevant data in one table as conceptual components. Therefore, we avoid storing null values as well as avoiding the need to run mul tiple queries to extract required information from several relations which is t he case with the property -table. This reduces Table 5.4.1. LUBM10 query execution time (in milliseconds) Table 5.4. 2 . LUBM 2 0 query execution time (in milliseconds) Table 5.4. 3 . LUBM 3 0 query execution time (in milliseconds) Table 5.4. 4 . LUBM 5 0 query execution time (in milliseconds) Table 5.4. 5 . LUBM 7 0 query execution time (in milliseconds) Table 5.4. 6 . LUBM10 0 query execution time (in milliseconds) the number of sub -queries and then reduces the time and effort needed by our storage model. Notably, tables that do not contain constraints on predicate values may require searching most of the tables in the property -table technique that end up with complex joins and unions. Three, if the query does not take i nto account a subclass relationship (e.g., university or department) as well as combining a few union and join operations over tables, the results show the efficiency of property -table in both row and column stores such as with query 2. Additionally, when the number of predicates scale, we observe that the performance of property -table decreased steadily. Forth, queries that retrieve multiple columns or contain several sub -queries will lead to better performance of row -storages. Otherwise, column -storages a re outperforming row -storages in most cases due to retrieving a single column or the query filters the results based on the particular column. According to the results, MonetDB is far better than PostgreSQL. Ontologies can be use d to explain what data and documents mean, regardless if the schema is defined explicitly ( e.g., relational database) or implicitly (e.g., NoSQL document). FCA is an ontology technique that can be used to analyze and cluster a similar set of concepts based on a robust conceptual lattice, relating any predicate with specific common concept s . Thus ontologies are v aluable since they share knowledge , and FCA is valuable because of promotes clustering analysis to cluster concepts that share common predicates. Hence, using ontologies with FCA over triple store s can create robust solution s due to ontolog ies formalizing semantics and infer ring new facts and to FCA  X  X  creating a robust conceptual lattice by deriving and clustering collection s of implicit relations and concepts from the given ontology. We found that the combination of ontologies and FCA is a promising direct ion and produces important advantages and values to Semantic Web efforts, which agree with our hypothesis . Accordingly, we attempt in this chapter to bridge the gap of the current RDF storage methods in RDBMS by combing the strengths of sophisticated datab ase physical models with the inferencing techniques that ontolog ies and FCA support . Consequently, we take the benefits of the property -table method and expand them with a new approach that we designate TripleFCA, to store RDF data into relational databas e triple stores based on the ontology and FCA. Our hypothesis, which FCA for a given ontology means able to organize and improve the triple store, appears correct that is supported by experimental evaluation and interpretation of results. Moreover, we stud y the e ffect s of the two database architectures: row -stores and column -stores on six different LUBM datasets to test the performance and scalability on the one hand, and analysis of the limitations and issues related for both the performance and scalabilit y of the two databa ses architectures, on the other .

Since we aim at analyzing ontology to cluster group of data in a meaningful units , our further research plans to extend the proposed approach to build a new schema and taxonomy of semantically collections of data from different ontologies using more ontology techniques such as: ontology matching and learning. [1] A. Delteil, C. Faron -Zucker, and R. Dieng,  X  X earning [2] Y. Yan, C. Wang, A. Zhou, W. Qian, L. Ma, and Y. Pan, [3] T. Neumann and G. Weikum,  X  X he RDF -3X engine for [4] C. Weiss and A. Bernstein,  X  X exastore : Sextuple Indexing [5] P . Yuan, P. Liu, B. Wu, H. Jin, W. Zhang, and L. Liu, [6] G. H. L. Fletcher and P. W. Beck,  X  X calable indexing of [7] M. Wylot, P. Cudr X  -Mauroux, and P. Groth,  X  X ripleProv: [8] M. Atre, V. Chaoji, J. Weaver, and G. T. Williams,  X  X itMat : [9] Y. Sakr, S., Elnikety, S., &amp; He,  X  X  -SPARQL: a hybrid [10] S. Harris and N. Gibbi ns,  X 3store : Efficient Bulk RDF [11] J. McGlothlin and L. Khan,  X  X DFJoin: A scalable data [12] X. Huang, H., Liu, C., &amp; Zhou,  X  X pproximating query [13] B. Bornea, M. A., Dolby, J., Kementsietsidis, A., Srinivas, [14] G. Weikum and M. Theobald,  X  X rom information to [15] G. H. L. Fletcher, J. Van Den Bussche, D. Van Gucht, and S. [16] D. Wilkinson, K., Sayers, C., Kuno, H. A., &amp; Reynolds, [17] M. Sintek and M. Kiesel,  X  X DFBroker: A signature -based [18] E. I. Chong and G. Eadon,  X  X n Efficient SQL -based RDF [19] J. Levandoski and M. Mokbel,  X  X DF data -centric storage, X  [20] S. Albahli and A. Melton,  X  X hStore : Ontology hierarchy [21] D. J. Abadi, S. R. Madden, and K. Hollenbach,  X  X calable [22] J. F. Beckmann, J. L., Halverson, A., Krishnamurthy, R., &amp; [23] L. Sidirourgos, M. Kersten, N. Nes, and S. Manegold, [24] J. Broekstra,  X  X esame : A generic Architecture for Storing [25] OpenLink Software,  X  X erver, Virtuoso Universal. X  2010. [26] J. Sequeda and D. Miranker,  X  X ltrawrap: Sparql execution [27] A. Ladwig, G., &amp; Harth,  X  X umulusRDF : Linked Data [28] J. Huang, D. J. Abadi, and K. Ren,  X  X calable SPARQL [29] K. Hose and R. Schenkel,  X  X atabase foundations for scalable [30] A. Harth, K. Hose, and R. Schenkel,  X  X atabase Techniques [31] M. Atre, V. Chaoji, M. J. Zaki, and J. a. Hendler,  X  X atrix Bit [32] M. Zhou and Y. Wu,  X  X ML -based RDF data manag ement [33] R. Ganter, B., Wille,  X  X ormal concept analysis, X  Berlin: [34] R. Ganter, B., Stumme, G., &amp; Wille, Fo rmal Concept [35] F. Concept,  X  X ntology Design with Formal Formal Concept [36] G. Stumme and A. Maedche,  X  X CA -MERGE : Bottom -Up [37] R. Delbru,  X  X anipulation and Exploration of Semantic Web [38] C. Martinez -Cruz, I. J. Blanco, and M. A. Vila,  X  X ntolog ies [39] M. Rouane -Hacene, M. Huchard, A. Napoli, and P. Valtchev, [40] A. Formica,  X  X ntology -based concept similarity in Formal [41] T. Neumann and G. Weikum,  X  X DF -3X : a RISC -style [42] S. Sakr and G. Al -Naymat,  X  X elational processing of RDF [43] Z. Wang, X., Wang, S., Du, P., &amp; Feng,  X  X toring and [44] M. Stonebraker, D. J. Abadi, A. Batkin, X. Chen, M. [45] H. Chen, Y. Wang, H. Wang, and Y. Mao,  X  X owards a [46] A. D. J,  X  X olumn Stores for Wide and Sparse Data, X  CIDR , [47] A. Andurkar,  X  X olumn -Oriented Database Implementation in [48] Rudolph, S and B. Sertkaya,  X  X nhancing OWL Ontologies [49] S. A. Yevtushenko,  X  X ystem of data analysis  X  X oncept [50] J. Worsley and J. D. Drake, Practical PostgreSQL , vol. 1. [51] P. Boncz, M. Zukowski, and N. Nes,  X  X onetDB/X100: [52] P. Boncz and M. Kersten,  X  X IL primitives for querying a [53] D. J. Abadi and S. R. Madden,  X  X olumn -Stores vs . Row -
