 With the speedy development of computer and Internet, more and more information is popular on-line service besides E-mails. 
The working process of general search engine can be described as follows: Firstly the pages and the information contained in the pages; the spider stores the information into the index database; then the search utility sets up the Web page of a list of links to URLs which the search engine can find in its index matched the site visitor X  X  search keywords. 
But there is so much irrelevant information in the result pages. So people pay more and more attention to vertical search in a certain area. 
Business information is just a small part of the network information. If we want to search business information, it will take much more time and energy to download all the information the general spider program found and to judge whether it is business information or not. So the study of implementing an efficient commerce-oriented spi-commerce-oriented search engine will be introduced. goes through all the pages it can find. So firstly the spider analyzes the HTML code of a web page, seeks the hyperlinks in the page, and then skims through all the linking pages using recursion or non-recursion algorithm. Recursion is an algorithm that can shift the technique. Therefore it can X  X  be adopted in an efficient spider program. Using queue instead of transferring to it. When the spider program has finished scanning the current web page, it will link the next URL in the queue according to the algorithm. commerce or not before it is added to the queue. The way to achieve it is as follows: 1. Collect some typical commerce-related documents and transform them to text files as exercise texts originally; model, a text set can be denoted as r*m entry matrix D.  X  X  X  means the quantity of texts in the text set , while  X  X  X  represents the number of different entries in the text set. That is, each different entry corresponds to a row of the matrix D; and each text file corre-text j. As is known to all, there are many formulas to calculate weight in the traditional vector representations. Following is a very familiar formula to calculate weight: 
In formula (1), frequency of entry t in the text d, N means the number of exercise texts, t n means the quantity of texts which include entry t, and the denominator is a normalized factor. In practice, we noticed that the position where the entry appears is very important. For example, the entries which appear in th e headline, beginning or ending parts are often keywords of the file. So we modified the weight calculation formula, it can be described as formula (2): 
When entry t appears in the headline, beginning or ending parts, zero if entry t appears in other parts. 
After matrix D is calculated, we begin to calculate the K rank approximate matrix 
D of matrix D based on SVD (singular value decomposition). After the singular value decomposition , matrix D can be denoted as: T DUV = X  . Here, U represents the left singular matrix according to th e singular value of matrix D and V represents the right. is the Diagonal Matrix that insists of D X  X  singular values in descending order. Then the K rank approximate matrix k D can be formed with the front  X  X  X  columns in U and vector respectively. 3. When the Spider is carrying out search ing progress, it draws out the circumfer-the modified weight calculation formula (2). Project X into the space of k D and come out XX: 1 T kk XX X U  X  = X  . Now we are to compute the similarity between XX and k V  X  X  row vectors. Suppose that is
V vv = ... , the formula to calculate similarity is: given value. If the sum is higher than the given value, we can consider the hyperlink as commerce-oriented. 3.1 Filtration of the Entries in the Text large. Otherwise, it will take more time to judge whether the hyperlink is com-merce-oriented or not. Therefore, we us ually decompose the text by using the de-composing program and sign the attribute of an entry while catching it. Delete those verbs, adjectives and adverbs. Classify th e verbs into three groups: connection verbs, state verbs and action verbs. And then dele te connection verbs and state verbs. Calcu-late the weight of the remained entries, array them in descending order and then pick up the top  X  X  X  entries to use. 3.2 Using Thread Pool As experiments showed, multi-thread mechan ism can improve the spider X  X  efficiency. quest. But it costs a lot in building a new th read for each request. When there are many requests, it will cost much more time and system resource to build and destroy threads than to deal with pages. So we use the thread pool to solve this problem. In the thread reduce the Spider X  X  efficiency. Tasks are distributed to each thread by the thread pool. When a thread finishes a task, the thread pool will assign the next task to it. Because the number of thread is certain, additional threads can X  X  be built. We can use an available thread pool program instead of programming it ourselves. Jeff Heaton provided a thread pool class in his paper  X  X reating a Thread Pool with Java  X  which is published in www.informit.com or www.jeffheaton.com. Doug Lea has programmed an excellent open source set of concurrent utility programs: util.concurrent. In the open source set, the PooledExecutor class which is very effective and widely used is the right realization based on working queue. The thread pool used in our experiments is programmed by Jeff Heaton. 
Now, the algorithm using thread pool can be described as follows: Since the spider is aimed at catching business information, the initial URLs should be connected with commerce. If not, there w ill be probably no commerce-oriented hy-termination of the spider program. So it would be better not to run the spider program over the education network because most of the business information is from com-mercial network instead of educational website. Different computers, different network and different time will leads to different download speeds. For example: The same Spider program running on a computer in the campus network can download only several documents from non-educational networks per second, but it can download even up to 100 documents from the educational network. Following experiments are held in campus network using the same computer. Since the exterior environment is almost the same, the experiment results are comparable. 1. No judgment on commerce is done to the hyperlinks and the initial URLs are 
This experiment shows that more threads do not mean higher efficiency. So using thread pool can improve working efficiency. 2. No judgment on commerce is done to the hyperlinks and the initial URLs are 
From table 1 and table 2 we can come to a co nclusion that the speed of Spider differs widely when it is used to search informatio n from different origin URLs. So in reality, different origin. For example, some spiders are running over the CERNET to deal with  X .edu X  websites, while other spiders focus on  X .com X  X r  X .net X  websites. 3. Judgment on commerce is done to the hyperlinks and the initial URLs are a set 
From table 2 and table 3 we can conclude that when the initial URLs are from busi-have little influence on processing speed. 4. Relevant degree in obtained documents to business affairs 
In the experiment, URLs is 10-600 words. We obtained 500 documents in the result. 
Analyzing the result documents, we can get a general conclusion. There are some irrelevant documents: 2 flashes, 30 picture documents, 4 javascript documents, 1 ap-plications and 10 irrelevant HTML documents. The quantity of relevant documents is 453 and the relevant degree is 90.6%. The pictures are surrounded by business infor-mation, which causes lots of the picture documents were downloaded. Most of the 10 irrelevant HTML documents are blank in body. From the source code, we can find that the head and title of the documents is relevant to business while the body has nothing to do with it. 
To conclude, using word-filtering and thread pool technology to retrieve business information in the Internet is practicable and effective. 
