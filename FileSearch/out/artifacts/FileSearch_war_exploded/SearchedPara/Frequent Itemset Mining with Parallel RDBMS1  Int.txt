 Mining frequent pattern in transaction databases has been studied popularly in data mining research. Most of the algorithms used today typically employ sophisticated in-memory data structures, where the data is stored into and re-trieved from flat files. The integration of data mining with database systems is an emergent trend in database research and development area. This is particu-larly driven by explosion of the data amount stored in databases such as Data Warehouses during recent years, and database systems provide powerful mecha-nisms for accessing, filtering, and indexing data, as well as SQL parallelization. In addition, SQL-aware data mining systems have ability to support ad-hoc min-ing, ie. allowing to mine arbitrary query results from multiple abstract layers of database systems or Data Warehouses.
 implemented with the help of SQL are usually considered inferior to algorithms that process data outside the database systems. On the other hand recently most major database systems have included capabilities to support parallelization. This fact motivated us to develop a new parallel SQL-based algorithm which avoids making multiple passes over the large original input table and complex joins between the tables, and to examine how efficiently SQL based frequent itemset mining can be parallelized and speed up using parallel database system. discuss frequent pattern mining algorithms that employ SQL queries. Ppropad algorithm is explained in section 3. Section 4 presents several experiments that assess the performance of the algorithms based on synthetic datasets. We con-clude the paper in section 5 and give a brief outlook on future work. 2.1 The Problem of Frequent Pattern Mining The frequent Pattern mining problem can be formally defined as follows. Let I = { i 1 ,i 2 , ..., i m } be a set of items, and DB be a transaction database, where each transaction T is a set of items and T  X  I . An unique identifer, called TID , is assigned with each transaction. A transaction T contains a pattern P ,asetof items in I ,if P  X  T . The support of a pattern P is the number of transactions containing P in DB . We say that P is a frequent pattern if P  X  X  support is not less than a predefined minimum support threshold  X  .
 and-test approach [2, 4, 5], which is based on an anti-monotone Apriori heuristic: if any length k pattern is not frequent in the database, its super-pattern of length ( k +1) can never be frequent. Recently, an FP-tree based frequent pattern mining method [3], called FP-growth, developed by Han et al. achieves high efficiency, compared with Apriori -like approach. Pramudiono et al. reported parallel execution of FP -growth on shared nothing environment [6]. 2.2 Frequent Pattern Mining Based on SQL Before data can be mined with SQL, it has to be made available as relational tables. Transaction data, as the input, is transformed into the first normal form table T with two column attributes: transaction identifier ( tid ) and item iden-tifier ( item ). The support counters of frequent items can be kept in a separate table F ( item , count ).
 of steps proceeding in a bottom-up manner. The result of the k th step is the set of frequent itemsets, denoted as F k . The first step computes frequent 1-itemsets F 1 . The candidate generation phase computes a set of potential frequent k-itemsets C k from F k  X  1 . The support counting phase filters out those itemsets from C k that appear more frequently in the given set of transactions than the minimum support and stores them in F k . We proposed a SQL-based algorithm, called PROjection PAttern Discovery, or Propad for short [7]. Like the FP-growth method it adopts the divide-and-conquer strategy and successively transforms the original transaction table into a set of frequent item-related projected tables. Then we separately mine each one of the tables as soon as they are built. Let us give an example with five transactions in Table 1. The support threshold is set to 3.
 Definition 1. In order to avoid repetitiousness and to ensure each frequent item is projected to at most one projected table, we suppose items in alphabetical or-der. Let i be a frequent item. A i -related projected transaction table, is denoted as PT i , that collects all frequent items (larger than i ) in the transactions con-taining i and the support of these items satisfies the minimum support threshold. which is facilitated by projecting transaction tables in a top-down fashion. In our approach, we are trying to find all frequent patterns with the respect to one frequent item, which is the base item of the tested projected table. For each frequent item i we traverse the transaction table to find all frequent items that occur with i . All items that are locally frequent with i will participate in building the i projected table. To describe the process of projecting, let X  X  first examine the example in Table 1 as follows.  X  At the first level we simply gather the count of each item and items that  X  At the second level, for each frequent 1-item i (except the last one) in the ta- X  At the next level, to each frequent item j in the projected transaction table 3.1 Parallel Propad Approach The Parallel Propad Approach, Ppropad for short, we proposed consists of two main stages.
 includes all frequent 1-items. In order to enumerate the frequent items effi-ciently, the transaction data is partitioned uniformly correspond to transaction tid among the available processors. In a partitioned database, this can be done automatically.
 approach, the projecting process is facilitated by depth first approach. Since the processing of the projection of one frequent itemsets is independent from those of others, it is natural to consider it as the execution unit for the parallel processing. We divide the frequent items of the table TF among the available nodes in a round-robin fashion. Each node is given an approximately equal number of items to read and analyze. As a result, the items is spilt in p equal size. Each node locally constructs the projected transaction tables associated with the items in hand until the the search for frequent patterns associated with the items terminates. In our experiment we built a parallel RDBMS: IBM DB2 UDB EEE version 8.1 on multiple nodes. We configure DB2 EEE to execute in a shared-nothing architecture that each node has exclusive access to its own disk and memory. Four nodes were employed in our experiments. Each node runs the Linux operation system on Intel Xeon 2.80Ghz. 4.1 Datasets We use synthetic transaction data generation with program described in Apriori algorithm paper [1] for experiments. The nomenclature of these data sets is of the form TxxIyyDzzzK, Where xx denotes the average number of items present per transaction, yy denotes the average support of each item in the data set and zzzK denotes the total number of transactions in K (1000 X  X ). We report experimental results on four data sets, they are respectively T25I20D100K that are relatively dense, T10I4D100K that is very sparse. (Here we have chosen the dataset T10I4D100K, because for this dataset, the experiment runs for 10 passes and we want to see how these approaches perform when mining long pattern.) Transaction data is partitioned uniformly by hashing algorithm corresponds to transaction ID among processing nodes. 4.2 Performance Comparison In this subsection, we describe our algorithm performance compared with K-Way join. Figure 1 (a) shows the execution time for T10I4D100 with the minimum support of 0.1% and 0.06% on each degree of parallelization. We can drive that Propad is faster than K-Way join as the minimum support threshold decreases. This is because for datasets with long patterns, joining k-copies of input table for support counting at higher passes is quite significant though the cardinality of the C k decreases with the increase in the number of passes. The speedup ration is shown in Figure 1 (b). Figure 1 (c) shows the execution time and speedup ration for T25I20D100K with the minimum support of 0.2% and 0.1% on each degree of parallelization. The speedup ratio shown in Figure 1 (d) seems to decrease with 4 processing nodes. It might be caused by the communication overhead. lelization than K-Way join. This is because for K-Way join approach with many large tables and a wide variety of tables and columns involved in joins, it can be difficult or impossible to choose the table X  X  partitioning key such that all sig-nificant queries can be executed without heavy inter-partition communication. While, Ppropad approach avoids complex joins between tables. In this paper, we implemented the parallelization of SQL based algorithm, Ppropad , to mine frequent itemsets from databases. Rather than Apriori -like method it adopts the divide-and-conquer strategy and projects the transaction table into a set of frequent item-related projected tables. Experimental study shows that the Ppropad algorithm can get better speedup ratio than K-Way join based on Apriori -like on all data sets, that means it is parallelized well. frequent items partition among the nodes, the load balancing is a problem when the extreme skew exists in data. We would like to examine how to absorb such skew. We also plan to check our parallel SQL based frequent pattern mining approach on more nodes. In addition, we X  X  like to investigate the effect of intra parallelism under SMP environment.

