 XML query languages use directional path expressions to locate data in an XML data collection. They are tightly coupled to the structure of a data collection, and can fail when evaluated on the same data in a different structure . This paper extends path ex-pressions with a new non-directional axis called the rank-distance axis. Given a context node and two positive integers  X  and  X  , the rank-distance axis returns those nodes that are ranked between  X  and  X  in terms of closeness from the context node in any direc-tion. This paper shows how to evaluate the rank-distance axis in a tree-unaware XML database. A tree-unaware implementation does not invade the database kernel to support XML stead it uses an existing RDBMS such as Microsoft X  X  SQL server as a back-end and provides a front-end layer to translate XML to
SQL . This paper presents an overview of an algorithm that trans-lates queries with a rank-distance axis to SQL .
 Categories and Subject Descriptors: H.2.4 [Database Manage-ment]: Systems  X  Relational databases .
 General Terms: Algorithms, Design, Experimentation.
 Keywords: XML , non-directional axis, XPath, rank distance, tree-unaware RDBMS .
A wealth of existing literature has extensively studied evaluation of various navigational axes in XPath expressions in a relational environment [5]. These well-studied axes are all directional since they locate nodes in a fixed direction relative to a context node ( e.g., the descendent axis corresponds to the  X  X own X  direction). Unfor-tunately, queries that rely on directional axes become dependent on the data being in the specified direction, even though data has no  X  X atural X  direction and can be organized in different hierarchies. Users who are unfamiliar with a document structure or are knowl-edgeable about a structure which subsequently changes will some-times formulate unsatisfiable queries , which are queries that fail to produce desired results. In contrast to incorrect queries , which result in a compilation error, unsatisfiable queries are difficult to debug since they run to completion and produce a result, though not the intended or desired result.

As an example of the directional nature of XPath queries, con-sider the XML document in Figure 1(a) containing league infor-mation organized by teams. Each team consists of a set of play-ers. Suppose that a user, Sally, wishes to find the names of teams in the southwest division founded prior to 1970 . Sally can issue the following XPath query to retrieve desired information: Q //team[division= X  X outhwest X  and founded &lt; 1970] /name . Suppose now that Sally wishes to also find the names of the players for the teams, she can issue another query Q //team[division= X  X outhwest X  and founded &lt; 1970] //player/name , to retrieve this information. Finally, the name of the league the teams play for can be retrieved by issuing the fol-lowing query Q 3 : /league/name . Note that these three XPath fragments can be combined into a single XPath query using the union operator ( Q 1 | Q 2 | Q 3 ), or combined in a single XQuery query.

To properly formulate these queries, Sally has to know some-thing about the hierarchical structure of the XML data. For instance, she must know that the player elements are descendants of a team element and information related to the name of a team is available in some part of the team subtree. Furthermore, the name of a league is available in the league subtree. This subtree also includes information related to teams and players. But if Sally mis-understands the structure or if the structure changes over time then this partial knowledge may not be useful anymore for formulating satisfiable queries as demonstrated below.
Assume that the XML document in Figure 1(a) is now reorga-nized to the structure depicted in Figure 1(b). Now the league in-formation is organized according to players instead of teams. Both documents contain the same data and same element labels but they have different hierarchical relationships. These documents may re-flect the scenario where (a) the structure of a document has evolved into another or (b) two different sources represent similar data in different hierarchies. Due to the lack of non-directional axes in XPath, for some queries different path expressions are needed to query each hierarchy. Consequently, some of the above XPath frag-ments may become unsatisfiable on the document in Figure 1(b). Sally has to formulate a different set of XPath fragments to retrieve relevant information. For instance, Q 2 needs to be replaced now with the following query Q 0 2 : //player[team/division=  X  X outhwest X  and team/founded &lt; 1970]/name .

At first glance, it may seem that the above structural heterogene-ity can be addressed by simply appending Q 0 2 to the XPath query over the document in Figure 1(a) using the union operator. While this approach surely works, it is not a practical solution as it re-quires a user to be familiar with the structural heterogeneities of different XML documents. This is unrealistic to expect from users as such  X  X tructure-awareness" does not scale with increasing struc-tural heterogeneity. Is it possible to retrieve the above information using a single query without being aware of the underlying struc-tural heterogeneities of elements? Ideally, such a query technique should work even if the document structure is reorganized. In or-der to answer this question affirmatively, in this paper we propose a new XPath axis called rank-distance axis, which enables us to locate all elements around the context node within a specified distance in any direction.
Reconsider the XPath queries in Section 1 over the XML docu-ments in Figure 1. To retrieve players X  information in Figure 1(a), a query has to navigate down from the team node. On the other hand, in Figure 1(b), the direction of navigation is reversed. Con-sequently, a key reason for the brittleness of these queries is the directional nature of classical XPath axes. We address this issue in this paper by extending XPath language with a non-directional axis called rank-distance .

Informally, given a context node c and two positive integers  X  and  X  where  X   X   X  , the rank-distance axis returns those nodes that are ranked between  X  and  X  from the context node based on their  X  X loseness" from c . Here  X  X loseness X  is measured by the distance from the context node in any direction in the XML Informally, the distance between nodes u and v is the number of edges in the unique, simple undirected path between u and v . For example, assume that the team and name nodes in Figure 1(a) are the context and test nodes, respectively. Observe that the name of a team is closest to the team node (at distance one). The sec-ond most closest node is the name of the league (at distance two). Lastly, the name node(s) that are furthest from the context node are the names of the players (at distance three). Hence, if  X  = 1 and  X  = 3 for a rank-distance query Q involving these context and test nodes, then all the above name nodes are part of the an-swer set. Observe that Q will retrieve the same information when it is evaluated over Figure 1(b) as well. More importantly, a user does not need to be aware of the structural relationship between the context and test nodes. By arbitrarily manipulating  X  and  X  , he/she can retrieve relevant information from a collection of struc-turally heterogeneous XML documents. The formal definition of the rank-distance axis is given in [7].

The syntax for expressing rank-distance nodes is of the form rank-distance::NodeTest[  X  to  X  ] . We refer to  X  and  X  as lower and upper rank, respectively. For example, consider the query Q 4 : //team [founded &lt;  X 1970 X  X /rank-distance ::name[1, 3] on the document in Figure 1(a). It returns the nodes e 1 , e 8 , e 11 , and e 14 . These nodes contain information related to the name of the league, the names of teams which were founded before 1970 , and their players X  names. Similar to traditional XPath axes, the results of rank-distance axis are in document or-der. Hence, the output of the above example will be [ name : NBA , name : Rockets , name : Mutombo , name : Wells , . . . ]. At first glance it may seem that sorting the results by distance instead of docu-ment order is a more appropriate choice. However, introducing a distance-based ordering would impact evaluation of subsequent lo-cation steps. Hence we decided to use document order.

Note that Q 4 will also return the name element of each of the remaining team s (denoted as e 0 ) as its distance from the context node c 1 is also three. However, this may not be desirable for cer-tain applications. Fortunately, we can easily filter out e processing the result set using node type information. Specifically, both e 1 and e 0 have same node type ( league.team.name ) but different ranks with respect to c 1 (1 and 3, respectively). Hence, for nodes with identical types we can filter out irrelevant nodes by selecting the one with lowest rank ( e 1 ) as part of the result set.
Now consider the XML document in Figure 1(b). Although the document structure of Figure 1(b) is different, Q 4 returns the above information when evaluated on this document. Specifically, in this case the first team element is the context node and it will return the name elements of team , league and player s ( e.g., Mutombo ) as they are ranked 1 , 3 , and 2 , respectively, based on the distance from the context node. Hence, the output in document order will be [ name : NBA , name : Mutombo , name : Rockets , . . . , name : NBA , name : Wells , name : Rockets , . . . ]. Note that in this case there is no need to post-process the result set based on node types.
Remark. Reconsider the XPath queries in Section 1 over the documents in Figure 1. In order to ensure Q 2 is satisfiable on the document in Figure 1(b), Sally needs to modify the axis of one or more steps in Q 2 or rearrange the labels to satisfy document hi-erarchy. As mentioned earlier, this requires partial knowledge of the underlying document(s). In contrast, in a rank-distance query a user does not need to undertake such modifications. He/she can explore different results of the query by setting different values for  X  and  X  . Intuitively, this has lesser cognitive overhead as a user does not need to have knowledge of the underlying document struc-ture. In the next section, we shall see that our proposed evaluation strategy supports such exploratory querying by exploiting the pre-viously computed answer set whenever a user modifies  X  or  X  .
Our proposed algorithm for evaluation of a rank-distance axis is built on top of the S UCXENT ++ system [3, 11], a tree-unaware relational approach designed primarily for read-mostly workloads. Different from other encoding schemes, namely pre-post encoding and Dewey numbering [5], S UCXENT ++ uses a novel numbering scheme that only explicitly encodes the leaf nodes and the levels of the XML tree. Internal nodes are encoded implicitly. Also, this scheme does not require a relational back-end to support SQL / XML standard or XML data type. It can be effectively used, without any further extension, to evaluate the rank-distance axis. This feature is important as queries with non-directional axis should seamlessly blend with conventional XPath processing.
In S UCXENT ++ , each level ` of an XML tree is associated with an attribute called RValue . Each leaf node n is associated with four attributes, namely LeafOrder , BranchOrder , DeweyOrderSum , and SiblingSum . The LeafOrder captures the document order of a leaf node. The BranchOrder of n is the level of the nearest com-mon ancestor ( NCA ) of this node and the preceding leaf node. The DeweyOrderSum is used to encode a node X  X  order information to-gether with its ancestors X  order information using a single value. Each non-leaf node n 0 is implicitly assigned the DeweyOrderSum of the first descendant leaf node. The SiblingSum attribute is intro-duced to evaluate position predicates with name test. The reader may refer to [3, 11] for detailed description of these attributes and the role they play in XPath evaluation. This encoding information is captured by the schema of S UCXENT ++ as shown below. Fig-ure 2 depicts an example of storage of XML representation of league data (Figure 1(a)) in S UCXENT ++ .
Algorithm 1 depicts the algorithm for SQL query translation. For simplicity, in the sequel we assume that an XPath expression has a single rank-distance axis and parent-child directional axis. Note that our strategy can be extended to expressions containing multiple rank-distance axes and we plan to explore this ex-haustively in the future. The algorithm consists of the following phases. We briefly describe them in turn. The reader may refer to [7] for detailed description of the algorithm.

Phase 1: XPath Decomposition. In this phase, the algorithm splits the XPath expression P into two types of XPath compo-nents (Algorithm 1, Line 01). One of them represents the XPath fragments that do not contain a rank-distance axis and the other represents the rank-distance axis expressions. For ex-ample, consider the expression P = /league/team/rank-distance::name[1 to 3] over the XML document in Fig-ure 1(a). In this phase, P is split into the fragments E 1 resenting /league/team and //name , respectively. Note that we transform rank-distance::NodeTest into //NodeTest as the rank-distance axis is non-directional and the path of NodeTest cannot yet be determined.

Phase 2: Directional XPath to SQL Translation. Next, the al-gorithm invokes the SQL translation algorithm for the XPath ex-pression without a rank-distance axis in Line 02 in Algo-rithm 1. Since this algorithm has already been described in [3, 11], we do not elaborate on this further. Here we focus our attention on the translation of the rank-distance axis component.

Phase 3: NCA Computation. In Algorithm 1, Line 03 is used to generate an SQL query to determine the level of the NCA Algorithm 1 : The RankDistance algorithm.
 Input : XPath P
Output : Translated SQL S rd ( E 1 , E 2 )  X  decomposeXPath ( P ) ;
S 1  X  translate ( E 1 ) ;
S 2  X  SQLToFindNCA ( S 1 , E 1 , E 2 ) ;
S 3  X  SQLToComputeDistance ( E 1 , E 2 ) ;
S 4  X  SQLForRankDistance () ;
S rd  X  finalTranslatedSQL ( S 2 , S 3 , S 4 ) ; return S rd S , E 1 , and E 2 as input. The idea is to find the level of the of the context node (in our example, team node) and the test node ( name node). This is achieved by exploiting the DeweyOrderSum , BranchOrder , and RValue attributes of S UCXENT ++ .

Phase 4: Ranked Distance Computation. The next step is to compute the ranked distances between the context and test nodes (Algorithm 1, Line 04). Intuitively, we can compute the distances of only those nodes that have rank at most  X  based on their dis-tances from the context node. The advantage of this approach is that it is not necessary to compute and rank distances of all test nodes. However, if a user wishes to explore more results by modi-fying values of  X  or  X  then the algorithm may have to either com-pute new results incrementally or from scratch. Hence, we first compute distances of all pairs of context and test nodes for the query and rank them. Then, nodes satisfying user-specified  X  and  X  values can be efficiently retrieved using a simple SELECT query (achieved in Phase 5). Note that this approach supports efficient exploratory query evaluation as the ranks of all relevant nodes have been already computed. Also, observe that the algorithm computes distance information of relevant nodes  X  X n-the-fly" for generating the answer set. Consequently, there is no overhead of computing, maintaining, and storing distance information ( O ( n 2 ) space com-plexity) a priori .

Next, the algorithm ranks the test nodes based on their distances from the context node (Algorithm 1, Line 05) by invoking the SQL-ForRankDistance function. Here we exploit the ranking function "DENSE_RANK" 1 of an industrial-strength RDBMS .

Phase 5: SQL Merge. At this point of time, we have three SQL queries, namely, S 2 , S 3 , and S 4 . The finalTranslatedSQL func-tion combines these SQL queries to generate the final translated query of P (Algorithm 1, Line 06). We illustrate this procedure using the running example discussed in Phase 1. Figure 3 depicts the final translated SQL query. Lines 01 X 19 are used to determine the level of the NCA . In particular, Lines 06 and 13 exploit the DeweyOrderSum and RValue values to determine the level of NCA of the context and rank-distance nodes. The MINVAL function (Line 15) is used to compute the minimum value between the level of the context node, and the level of the test nodes, computed by in-voking the user-defined SQL function computeLevel . The distances between context nodes and test nodes are computed by Lines 20 X  24. It first determines the node labels of the context and test nodes and then compute the distance using the user-defined tion computeDistance . Lines 25 X 28 rank the test nodes based on their distance (Phase 4). Lines 29-39 return tuples containing pairs of context nodes and the test nodes satisfying the lower and upper ranks.

The algorithm for Phase 5 includes two optional steps which are common to producing results in real-world queries. First, it extends the query result to include all of the nodes in the subtree rooted at the test nodes by performing an additional join with the PathValue table (denoted as V ). Second, the context node values are added to the result through another join with the PathValue table (denoted as U ). Line 38 sorts the result according to the document order. Line 39 enforces the join order option due to performance benefits as highlighted in [6, 11].
Our objective to flexibly issue XML queries independent of the structure is shared by several recent papers [1, 2, 4, 8]. [4] presents a semantic search engine for XML . The search relies on an inter-connection relationship to decide whether nodes are semantically related. Two nodes are interconnected if and only if the path be-tween them contains no other node that has the same label as the two nodes. [8] proposes a schema-free XQuery, facilitated by a Meaningful Lowest Common Ancestor Structure ( MLCAS ) opera-tion. Both these techniques are similar to the  X  X losest X  relationship between nodes. Unlike rank-distance axis, these approaches do not retrieve nodes based on distances from the context node. Furthermore, these approaches do not leverage on relational tech-nology for structure-independent query evaluation.

Recently, several XML keyword search techniques [9, 10, 12] have been proposed to offer more user-friendly solution for retriev-ing relevant results. Essentially, these approaches return vari-ants of the subtree rooted at the lowest common ancestor ( e.g., VLCA , SLCA ) of all the keywords. Due to the lack of expressivity and inherent ambiguity of keyword search, several techniques have been also been developed to infer and retrieve relevant results for a search query [9, 10]. Our work differs from the keyword search paradigm in the following ways. Firstly, we retrieve nodes based on distances from the context node and not the entire LCA of all the keywords. Note that existing keyword search strategies do not exploit node distances for retrieving results. Secondly, as a rank-distance query is an extension of conventional XPath query, it can impose more complex predicates compared to keyword search queries. Furthermore, it does not suffer from expressivity and am-biguity issues similar to keyword search.

More germane to this work is the effort by Zhang and Dyre-son [13]. They extended the XPath language with a symmetric lo-cator, called the closest axis, which locates nodes that are closest to a context node. The authors focused on the syntax and seman-tics of closest axis and showed how the closest axis can be im-plemented using main-memory and a native XML DBMS . It was shown that this axis can replace many directional steps in path ex-pressions in XML queries. Our work differs from this effort in the following ways. First, rank-distance is a more generic non-directional axis compared to the closest axis. Not only it can find closest node(s) (by setting  X  and  X  to one) but also nodes that are further away from the context node. Second, in [13] the closest node types are computed prior to query execution and stored in a special index to facilitate closest axis evaluation. In contrast, in our proposed approach the node distances are computed on-the-fly dur-ing query execution. Third, closest axis is built on top of a native XML database whereas we show how an industrial-strength RDBMS can be exploited effectively to support a non-directional XPath axis.
In this paper, we present a relational-based strategy to evaluate a non-directional XPath axis, called the rank-distance axis, to locate nodes that are within the specified distance range with re-spect to a context node. The rank-distance axis is useful for formulating XML queries in an environment where there is insuffi-cient familiarity with an underlying XML document X  X  structure or changes to the structure. Our scheme is built on top of the S ENT ++ system. It exploits the encoding scheme of S UCXENT and ranking facility of an off-the-shelf RDBMS to effectively com-pute the distances between pairs of nodes and rank them in order to compute rank-distance nodes. In this context, we presented an overview of an XPath-to-SQL translation algorithm to translate a rank-distance axis query to its equivalent SQL form.
