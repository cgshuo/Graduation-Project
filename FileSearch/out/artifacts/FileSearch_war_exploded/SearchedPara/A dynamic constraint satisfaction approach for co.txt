 1. Introduction variety to satisfy diverse customer needs while maintaining near mass production efficiency ( Pine, 1993 ). Under the mass custo-mization paradigm, products are designed as those of consisting of modules or components where commonality and variability exist. The task of product configuration is to automatically or interactively configure a product by assembling a set of compo-nents without the violation of any constraints such that indivi-dual needs of a customer are satisfied. It has been recognized as an enabling technology for the mass customization production because the configuration processes have a significant impact on both sale-delivery processes and engineering processes of pro-ducts. The application of configuration systems to the mass customization production can avoid delay and rework in the engineering processes of products, which are caused by potential errors existing in manual configuration ( Soininen et al., 1998 ). In this way, the lead-time of tailored products can be effectively reduced. Since the successful application of the first configuration system, namely R1/XCON ( Barker and O X  X onnor, 1989 ), research on product configuration technologies has received much atten-tion ( Sabin and Weigel, 1998 ; Stumptner, 1997 ). Various tech-nologies for carrying out inferences on configuration processes have been widely studied to solve a variety of product configura-tion problems like configuring personal computers ( Fohn et al., 1995 ), automobiles ( Felfernig and Zanker, 2000 ) and communica-tion device ( Fleischanderl et al., 1998 ). Main technologies for configuring products include the rule-based approach ( Barker and
O X  X onnor, 1989 ), the case-based reasoning (CBR) ( Tseng et al., 2005 ; Lee and Lee, 2005 ), genetic algorithm (GA) technique ( Hong et al., 2008 ; Zhou et al., 2008 ; Li et al., 2006 ; Yeh et al., 2007 ), the constraint satisfaction problem (CSP) method ( Fohn et al., 1995 ; Ong et al., 2006 ; Huang et al., 2008 ), and pre-compilation approach ( Subbarayan et al., 2004 , Subbarayan, 2005 ). However, those researches mainly focused on the problem-solving technol-ogies for product configuration. In those research studies, config-uration problems were regarded as flat ones where the structures of products were ignored ( Huang et al., 2008 ; Veron and
Aldanondo, 2000 ). To deal with the configuration problem of complex product structures, Stumptner et al. (1998) developed the approach of Generative Constraint Satisfaction Problem (GCSP) as an extension to DCSP, allowing to partially describe the structural relationships (such as is-a and part-of relation-ships) among components of a product. However, some problems with modeling and solving structured configuration problems still exist in GCSP approaches:
K Lacking a well-founded modeling formalism to represent
K Encoding structured configuration problem into DCSP is indirectly K Configuration optimization problem, namely that there existed
To overcome the first problem with the representation of configuration structures, i.e. configuration modeling, Felfernig et al. (2000) employed the Unified Modeling Language (UML) ( OMG, 2004 ), a standard for object-oriented notations, to repre-sent product configuration models. The advantage of object-oriented modeling approach was that reusability and maintain-ability of configuration models could be ensured. Nevertheless, actual configuration solving was still carried out by ILOG JConfi-gurator, a commercial solver developed by ILOG Corporation that implemented the GCSP algorithm ( Stumptner et al., 1998 ).
To address the problem of structured product configuration problem, we present in this paper a novel and direct encoding approach to transforming object-oriented configuration model into DCSP. In our approach, the structural relationships are directly encoded as component variables and corresponding activity constraints by taking advantaging of the semantics of the structural relationships in the encoding process. As a result, additional virtual port variables for representing the structural relationships are no longer needed in our approach. Thus less search spaces need to be explored and the solving efficiency of configuration processes can be effectively enhanced. Furthermore, configuration constraints are encoded as DCSP compatibility constraints, instead of DCSP activity constraints as in GCSP. During the solving process, components are joined in the solving processes in accordance with strict h ierarchy levels. In other words, a low-level component can only be involved in the solving process through the compositional relationship and inheritance relationship with its immediate high-level components (the aggregate or parent component). Therefore, the problem with withdrawal of a chain of previous component assignments due to the inconsistency of dynamically created components in the GCSP is overcome. Furthermore, we further extend DCSP with Branch and Bound (B&amp;B) to handle the configuration optimization problem where multiple feasible solutions exist and the optimal solution thus needs to be found.

This paper is organized as follows. Technical background and related work are summarized in Section 2 .In Section 3 , config-uration concepts and object-oriented configuration models are introduced. Encoding an object-oriented configuration model as a DCSP is presented in Section 4 . The solving algorithm based on DCSP is described in Section 5 . Experimental study and conclusion are given in Sections 6 and 7 , respectively. 2. Technical background and related work 2.1. Product configuration
Given a finite set of pre-defined components, the task of product configuration is to assemble a set of components, set the attributes of components and build connections (if possible) between components to satisfy the individual requirements of a customer without violating any constraints imposed on compo-nents. These constraints are often specified due to economical, technical and processing factors. 2.2. The solving approach for product configuration
Research on product configuration systems can date back to early 1980s when R1 system (later called XCON) ( Barker and O X  X onnor, 1989 ) was developed using the rule-based method.
Since then, product configuration has become a commercially successful application of artificial intelligent techniques ( Sabin and Weigel, 1998 ). Various techniques have been suggested to solve product configuration problems, including the Genetic algorithm (GA)-based approach, case-based reasoning (CBR) method, rule-based approach, CSP technique, etc. Some literature used the genetic algorithm to solve the product configuration problem. Hong et al. (2008) addressed the problem of optimal product configuration under the One-of-a-Kind production (OKP) paradigm. Variations for customizable products and parameters in the OKP product family were modeled with the AND-OR tree and parameters of nodes in this tree. They employed the genetic algorithm as the solving mechanism to obtain optimal configura-tion, taking customer requirements on different aspects such as performances and costs into consideration. Zhou et al. (2008) adopted the AND-OR graph to represent the configuration spaces of a customized product. The optimization of product configura-tion was done by means of the genetic algorithm. The objective function of optimization considered both customer preferences on product attributes, which were measured using the utility function, and costs of a product. Different from the work in Hong et al. (2008) , a distinguishing characteristic in their research is that configuration constraints, such as inclusive relations and exclusive relations, are considered in the genetic algorithm for solving and optimizing product configuration problems. Similar work on the use of genetic algorithms for solving product configuration problems was also reported by Li et al. (2006) and
Yeh et al. (2007) . Nevertheless, the GA approach for product configuration is only suitable for the configuration problems where only a few configuration constraints exist in configuration models and thus a numerous feasible solutions can be obtained.
Obviously, it is not ideal candidate for the configuration problems with complex structures of products and constraints.

A different viewpoint on product configuration is that the product configuration problem can be viewed as one of case-based reasoning (CBR) ( Tseng et al., 2005 ; Lee and Lee, 2005 ). To configure a new customer order, similar previous cases are retrieved and the one with best similarity degree is recom-mended. For instance, Tseng et al. (2005) adopted the CBR to perform actual product configuration, aiming to reuse previous successful reasoning cases. Similar research that used the CBR for product configuration was also reported by Lee and Lee (2005) .
However, the CBR approach is only useful when knowledge is incomplete. Therefore, the structures of products are not sup-ported in the CBR-based product configuration.

The rule-based reasoning is efficient in handling product configuration problems because no backtracking occurs. The ear-liest product configurator, namely R1 system, used the rule-based reasoning for product configuration ( Barker and O X  X onnor, 1989 ).
However, the weakness of R1 system lies in the problem with the maintenance of rule bases because both configuration knowledge (including product structures and constraints) and policy knowl-edge (namely that concerning how to solve configuration) were interweaved in rules.

Constraint Satisfaction Problem (CSP) ( Tsang, 1993 ; Dechter, 2003 ) is one of well-known problem-solving technology in artificial intel-ligent domain. Mittal and Frayman (1989) first present that produc-tion configuration can be regarde d as components and connections between components. And the conne ction between two components is built through the ports of the corresponding components. Port is a concrete or abstract place for connecting to or relating to other component. Based on the port-connection paradigm, they further view the product configuration problem as a CSP where ports and components were encoded as discrete variables with finite domains set of assignment of values to variables without violating any constraint. Fohn et al. (1995) suggest the CSP-based method to interactively configure personal c omputer systems. Nevertheless, classical CSP-based method for product configuration cannot handle the situation where constraints may dynamically be joined in constraint networks, depending on some decisions, such as user X  X  choices. To consider this problem, the Dynamic Constraint Satisfac-tion Problem (DCSP) ( Mittal and Falkenhainer, 1990 ) is presented as an extension to traditional CSP, introducing activity variables and active constraints to specify condition under which a variable may or may not be actively considered as a part of a final solution ( Aldanondo and Vareilles, 2008 ). To improve the efficiency of the configuration processes, Subbaraya n adopts a pre-compilation way of encoding CSP of a configuration prob lem as an orderly binary decision diagram (OBDD) ( Subbarayan et al., 2004 ; Subbarayan, 2005 ).
Amilhastre et al. (2002) also propose a similar idea with an automaton. As a consequence, the time-consuming compilation process can be performed in an offline way and thus the efficiency of configuration processes can be greatly enhanced due to the fact that the configuration proce sses are backtracking-free. 2.3. Structural configuration and composite configuration methods have proved to be successful in solving product config-uration problems, some problems still arise. For example, the structures and topologies of products, such as aggregation (whole X  X art) and inheritance relationships (taxonomy), are not considered in the above approaches. To take structures and topology of products into account, composite CSP ( Sabin and
Freuder, 1996 ) and an improvement to conditional CSP ( Veron and Aldanondo, 2000 ) are developed to handle this problem.
However, the approaches like composite CSP only can deal with the configuration problems of special type of rather simple hierarchy and topology. Additionally, the component types (the group of component which have same attributes) and individuals (instances) are not differentiated in the approaches
CSP. Thus, configuration constraints are not allowed to define on the component type levels, i.e. abstract levels. 2.4. The combined approach for modeling and solving structural product configuration realize that there should be a modeling method to describe the structures and topology of configurable products, and to allow differentiating com ponent types and instances, to express con-straints on the component type levels (abstract component levels).
Huang et al. (2008) employed the concept of product data models to represent configuration knowled ge. However, complex structural relationships among componen ts were not addressed in their research. Ong et al. (2006) presented an object-oriented modeling method to explicitly and hierarchically represent the configuration knowledge using special O-O notations. In both Huang and Ong X  X  study, CSP is employed as the solving technology for product configuration by encoding the configuration model as a CSP.
Generative Constraint Satisfaction Problem (GCSP) which allowed to partially describe both is-a and part-of relationship among components within a product. In their study, however, all structural relationships and configuration constraints were represented as the port-connection paradigm presented by Mittal and Frayman (1989) .
Intheapproach,theportisalsousedtorepresentavirtualplaceof one component for describing the structural relationship in addition to originally denoting a physical place through which other compo-nent can be connected. Therefore, in the GCSP, both structural relationships and configuration constraints were encoded as DCSP port variables and activity constraints. The configuration solving process was performed using DCSP by encoding GCSP representation as DCSP. Going one step further, Felfernig et al. (2000) adopted
Unified Modeling Language (UML), an industrial standard for object-oriented notations, to model the pr oduct configuration knowledge.
High-level modeling concepts inclu ding part-of, subc lass-of, ports and resources were considered in their research using UML stereo-types. The main benefit for their approach is that UML has the graphical means, enabling it more convenient to communicate among experts, modelers and use rs. The configuring process was done using JConfigurator. From the above analysis regarding the configuration of structured products, the solving technologies mainly rely on CSP or DCSP for performing inference processes by encoding the configuration model as a CSP or DCSP. Since not all component variables in the DCSP are require d to assign values, the searching efficiency of DCSP is much faster than that of CSP. However, in the both Felfernig and Stumptner X  X  stu dies, configuration models were firstly represented as the port-connection paradigm in which the structural relationship or configu ration constraint was depicted as the connections between two ports meaning virtual places in components to connect to other components. Then, the transformed ports and connection relationships are encoded as corresponding variables and constraints in the DCSP. Thus, a component that has structural relationships or configuration constraints is encoded as at least two DCSP variables, one representing component itself, another for its port. An obvious weakness for their approach is that inner structures of products are not utilized in transforming from a configuration model into DCSP. In our approach, port becomes unimportant and the structural rel ationship is no longer represented as virtual ports. Port is only a concrete place within a component to connect to other component. The composition relationships are directly encoded as DCSP activity constraints by taking the semantics of structural relationships into account. Considering that in GCSP and
Felfernig X  X  research, port variables are roughly proportional to the number of structural relationships in a product, the number of total
DCSP variables can be greatly reduced in our approach since the structural relationships are not represented through ports. As a result, the configuring efficiency in our approach can be greatly enhanced due to the fact that the solving efficiency of DCSP is closely related to the number of variables in the DCSP. Moreover, the component is created through stric t hierarchy relationship, namely that a low-level component can be only configured before its high-level component is selected in the configuration. Additionally, configuration constraints are encoded as DCSP compatibility con-straints, instead of port-based DC SP activity constraints as in GCSP and Felfernig X  X  research. As a result, withdrawal of a chain of previous component assignment can be avoided.

An alternative way to configure structural products is to use the decomposition strategy in which a configuration problem is partitioned into independent sub-problems by defining the equivalent classes of constraints ( Magro and Torasso, 2003 ;
Margo et al., 2002 ; Anselma and Margo, 2003 ). In their approach, structures and topologies of products are represented in Frames,
Parts and Constraints (FPL) Language. The configuration is derived by solving the independent sub-problems. 3. Configuration concepts and object-oriented representation
Configuration is defined to select a set of components from a component catalog, set the attributes of the components and build connection between components with all configuration constraints and customer requirements simultaneously satisfied. To configure a structured product, main configuration concepts are introduced as below.

Component is a concrete, abstract part, or an aggregate con-taining other parts. In the case as a concrete part, a component means an individual (instance), such as CPU-586. On the other hand, as an abstract part, a component indicates a type, i.e. a group of parts with same attributes, such as CPU. Binary relation-ships including Optional and Mandatory may exist between components. In addition, more complex n -ary relationships such as Alternative and OR may form among components. For the former, it means that only one of components can be selected in the configuration, namely that these components are exclusively selected. For the latter it denotes that one or several components can be involved in the configuration, meaning that they are non-exclusive. Furthermore, multiple occurrences of the same compo-nent are represented by Cardinality .

A component has Attribute which is the parametric properties of a component and can be measured using some units. For example, a CPU has the attribute clock-rate. Resource ,asaspecialkindof attribute, indicates what a component may provide or consume. A hard disk, for instance, offers disk capacitywhileasoftwaresystem consumes disk capacity. Likewise, resource can be measured using some units. Port , in our approach, is only a concrete place in a component where other component can be connected directly or through some kinds of connectors. For example, a motherboard has several slots (i.e. port) for other components such as a network card to plug in. Notes that the port in our research does not stand for an abstract or virtual place that is the basic standpoint of the port-connection paradigm on which GCSP and Felfernig X  X  research is based.
Configuration constraints , which are specified in accordance with technical, economic and processing factors, may be imposed on concrete components, abstract components (types) or aggre-gate components. They restrict possible combination of various components in a valid configuration. Essential configuration constraints contain the requisition constraints and exclusion con-straints . The former denotes that selection of a component requires the selection of another component in the same config-uration. However, the reverse does not hold, which means that the requisition constraint is directional. The exclusion constraint specifies that two components cannot be in the same configura-tion because they are incompatible. Both requisition constraints and exclusion constraints can be defined on component types (abstract levels) or the aggregate components, which makes the transformation into DCSP a tedious task since the hierarchy and structures of products are required to take into consideration. Port constraint enforces that the corresponding ports of two compo-nents should be physically connected in a legal configuration. More complex configuration constraint such as resource con-straint may be a n -ary relation among components. Resource constraint specifies that the total amount of resource consumed by components should be less than or equal to that of resource provided by components. For instances, the total disk capacity consumed by software should be less than or equal to that offered by hard disks in a legal computer configuration. Customer require-ments may be specified by restricting the components, or the attributes or parameters of a component. In the case, customer requirements can be represented as unary constraints on the domains of the component variables or attribute variables. On the other hand, customer requirements may be represented in terms of configuration constraints, such as the requisition constraints and exclusion constraints. In addition, customer requirements may be stated in terms of functions, which may be implemented in one or several components. This can be described through the mapping relationships from function to component.

A configuration model represents the structural relationships of components, ports and attributes as well as configuration constraints among components in a product family, thus encompassing all possible variants of products in a compact way. The object-oriented modeling technique offers an approach to representing the model of a system in a reusable way by utilizing abstraction mechanisms such as aggregation and decomposition, generalization and inheritance. To illustrate how to represent configuration models using UML, we use a configuration case from the literature ( Tiihonen et al., 1998 )for configurable ranger drilling machine as an example of product configuration. This ranger drilling machine consists of a cabin, a tracked crawler base, a power unit, a boom and drilling equipment.
Fig. 1 depicts the configuration model u sing UML class diagram. It can be seen that structural relationsh ips such as optional and mandatory can be represented in the multiplicity (such as 0 y 1or1 y respectively) of classes in UML. Alter native relationship is represented as the subclass-of relationship while configuration constraints such as exclusion and requisition constraints can be depicted in UML stereo-types. The requisition constraints exist from Tank USA to Three edge track, from Hose reel to LDA, from HL600 to Tank EURO. There exist the exclusion constraints between High capacity pump and Three edge track, between Three edge track and Tank EURO.

In addition, the port constraint requires that Ldp port of LDA should be connected with Lba port of HL500. A resource con-straint indicates that total amount of power consumed by HL500 and HL600&amp;700 should be equal to or less than that supplied by Engine. For example, HL600 consumes 135 kW power whereas Engine_R supplies 130 kW power.
 If all technical constraints C1 X  X 10 and customer requirements
R1 X  X 4 are considered, a configuration solution for this ranger drilling machine is the component set: {High_capacity_pump, Engine_W, Engine_S, Tank_EURO, HDA, Hdp, HL600, Hba,
Normal_track, AC5, Winch, Rear jack, Cabin, Boom} (only leaf components are listed). It can be checked that this solution satisfies all constraints and customer requirements.

To know more about the use of UML for representing product configuration models, readers can refer to the literature ( Felfernig and Zanker, 2000 ) due to the fact that we focus on encoding object-oriented configuration model into DCSP, not object-oriented modeling technique for product configuration. In the following section, we will address how to encode the structured configuration model into DCSP such that the solving mechanism for DCSP can be employed in deriving configuration solutions. 4. Encoding the object-oriented configuration model as a dynamic constraint satisfaction problem
To solve product configuration problems, the configuration model needs to be encoded as the dynamic constraint satisfaction problem. To make this paper self-contained, a brief explanation of both CSP and
DCSP is given before the encoding approach is further elaborated. 4.1. Constraint satisfaction problem (CSP)
Definition 4.1. A constraint satisfaction problem ( Tsang, 1993 )is formulated as
V , D , C fg where V is a finite set of variables, namely { V 1 , V 2 , set of domains, i.e. { D 1 , D 2 , y , D n }. For any variable V exists a corresponding domain D i A D from which the variable
V takes the value d i ; C is a set of compatibility constraints. For a k -ary constraint C i A C ,itisa k -ary relation on the set
D D 2 D k , restricting allowable value combination of variables in the form of the tuple {( v 1 , d 1 ), ( v 2 , d in the form of arithmetical, or logical formula.

Definition 4.2. A solution to the constraint satisfaction problem { V , D , C } is an assignment of all variables in V such that all constraints in C are satisfied. This can be formulated as  X 8 v i A V ( x A D i v i  X  x  X  4 8 c A CSatisf y  X  c 9 x ! where the predicate Satisf y  X  c 9 x !  X  represents that the constraint c holds true in the case of this assignment x !  X  X  v 1  X  x 1 x 2 , ... , v n  X  x n :
Example 4.1. Consider for instance, the CSP: {{ x , y , z }, {{0, 1, 2}, {1, 2, 3}, { 1, 0}}, { x  X  y 4 3}} where variables x , y and z take values in the domains {0, 1, 2}, {1, 2, 3} and { 1, 0}, respectively, and are constrained by { x  X  y 4 3}. A solution to the CSP is { x  X  2, y  X  3, z  X  0}.

A CSP can be further classified into discrete, continuous and mixed CSP in terms of the types of values of variables. A discrete
CSP means that the values of all variables are discrete, such as integer domain, the domain of enumerable values. A continuous
CSP is defined as a sequence of variables taking values respec-tively in a set of continuous domains. In a mixed CSP, the variables can take either discrete values or real values. For most of the product configuration problem, the corresponding CSP belongs to discrete CSP.

When CSP is applied in solving product configuration problem for structured products, a corresponding CSP variable with the domain {0, 1} is needed for each component to indicate whether or not the component occurs in the final configuration. Both structural relationships and configuration constraints can be represented either in the form of equality (inequality), or in the form of tuple. For example, the mandatory relationship between components x and y is represented by the equality x  X  y whereas a requisition constraint from x to y is indicated by the inequality x r y . 4.2. Dynamic constraint satisfaction problems
CSP requires that all variables in the set V must be assigned a value from their respective domains, which is generally infeasible for many real-life problems. For example, in the product config-uration problem, the existence of some type of motherboard requires some type of hard disk in the same configuration. This indicates that whether or not the variable representing the hard disk is assigned a value depends on the existence of the type of motherboard. In other words, the variable for hard disk may not need to be assigned a value if the type of motherboard is not selected in the configuration. Hence, variables under this envir-onment to some extent exhibit dynamic characteristics. Consider-ing this factor, the dynamic constraint satisfaction problem (DCSP) was presented to deal with this problem.
 Definition 4.3. A dynamic constraint satisfaction problem (DCSP) ( Mittal and Frayman, 1989 ) is formulated as V
I , V A , D , C A , C C no where V I is a finite set of initial variables that must be assigned values in a configuration; V A is a finite set of active variables. The activation of these variables, which depends on corresponding activity constraints, indicates that these variables are involved in the constraint network and thus are required to be assigned values in a configuration; D is a finite set of domains of the variables in the sets V I and V A ; C C is a finite set of compatibility constraints in the CSP. The compatibility constraint in C legal combination of values that two or more variables can take; C
A is a finite set of activity constraints, which specify the activation condition of active variables. Basic activity constraints take the following general form: x
The above formula means that the active variable x k is activated, namely that x k must be assigned a value from its domain in a solution, if the variables x i , x j , etc., take the values di , dj b , respectively. Here, the  X  X  ACT  X  X  is the shorthand for  X  X  X ctivation X  X .

Example 4.2. We assume that a new condition (i.e. z is only considered when y Z 3) is added to the above CSP example.
Initially, it is required that x and y must be assigned values in a configuration. This is a DCSP since the variable z is not considered in solving the problem, that is to say, that z does not need to pick a value from its domain, when the condition y Z 3 does not hold. The condition can be represented as an activity constraint in the DCSP: y  X  3 ! ACZ z . Therefore, the DCSP is described as
V , D , C fg where V  X  x , y V  X  z
D  X  D x , D y , D z , D x  X  0 , 1 , 2 , D y  X  1 , 2 , 3 , D z  X  1 , 0 C  X  y  X  3 ! ACT z C  X  x  X  y 4 3 :
A valid solution to this DCSP is { x  X  2, y  X  2}. 4.3. Encoding rules for object-oriented configuration models
With regard to the configuration models represented in the object-oriented method, the modeling elements are classes (including component, resource and port classes), structural relationships (i.e. subclass-of and aggregation), and constraints (containing requisition, exclusion, resource and port-connection constraints). In the DCSP domain, main concepts are variables, domains, compatibility constraints and activity constraints. To implement the configuring processes for a customizable product, the O-O configuration model should be encoded as a DCSP. Some predicates and notations are introduced in order to clarify the encoding rules, as shown in Table 1 .

The predicate sub_of ( X , Y ) holds true if the component X is a subclass of Y in the configuration model. Moreover, the functions such as DSV ( X ) and Dom ( x ) are used to describe a DCSP. DSV ( X ) returns a corresponding DCSP variable representation for the component X , the port X or the attribute X . The function Dom ( x ) gets the domain from which a DCSP variable x takes a value.
Additionally, in the following representation, a DCSP variable starts with the letter v followed by an italic upper case letter(such as vA ) while a value that a DCSP variable may take begins with an italic lowercase letter (such as a ). An exception is that the italic uppercase letter such as A can play the roles of both values and variables, as explained in the table. Additionally, an underlined uppercase letter (such as A , X ) indicates a component, attribute or port depicted in the configuration model.
 4.3.1. Components in configuration models
Rule 4.1. For a component type A that is a constituent part of the aggregate in a configuration model, depending on the character-istic of composition, the corresponding DCSP variable is (1) if A is mandatory: (2) if A is optional: (3) if A is a part with cardinality n y m ( n o m ) the domain of which depends on compositional characteristics.
This variable only takes the value a if A is mandatory part and has not any subclass components. However, the variable will take the value A if A is mandatory and has subclass components. The reason is that A will be instantiated as a specific subclass component in further configuration. In the case of an optional component, a value nil indicates that the component will not occur in the configuration. The value a is added to the domain if the component A has not any subclass parts. Otherwise, the value
A is added to the domain when component A has subclass component, namely a general component (such as CPU-586) that should be instantiated as a specific or concrete component (such as Pent-II) during the further configuration process. Consequently, the value A plays two roles: both a value representing that component A is selected for its upper-level (i.e. assembly), and a variable that takes another value denoting that specific subclass component is to be selected in further configuration. Finally, if a component can occur several times in a product, the number of which is specified by the cardinality n y m , the domain of the variable consists of the value ia or iA where i denotes the number of this component in a configuration.
 Example 4.3. The components X , A and C in the model depicted in Fig. 2 are encoded as DCSP variables: DSV  X  X  X  X  vX Dom  X  vX  X  X  x
Rule 4.2. For component B i that is a child of the component A , the corresponding DCSP representation is DSV  X  B i  X  X  A
Dom  X  A  X  X  b i 9 sub _ of  X  B i , A  X  4 : ( xsub _ of  X  x , B vA  X  A ! ACT A :
Component B i is a child component of A , meaning that B i kind of A. For instance, CPU-586 is a kind of CPU. Therefore, the corresponding variable of B i should be A whose domain consists of
B and its sibling components. Moreover, the activity constraint denotes that the variable A should be assigned (i.e. instantiated as a specific component) when the component A is selected for its upper-level component.

Example 4.4. It often happen that the two rules above should be used together during the encoding process. For instance, the DCSP encoding of the component A shown in Fig. 2 is DSV  X  A  X  X  vA Dom  X  vA  X  X  A , nil  X  1  X  D SV  X  B 1  X  X  D SV  X  B 2  X  X  DSV  X  B 3  X  X  A  X  2  X 
Dom  X  A  X  X  B 1 , b 2 , b 3  X  3  X  vA  X  A ! ACT A  X  4  X 
The component A in Fig. 2 plays two roles in the configuration model. On the one hand, A is an optional part of X and on the other hand, A is a parent component of B 1 , B 2 , and B 3 that B 1 , B 2 , B 3 is a kind of A . One direct way is to represent the component A as the variable vA with the domain { nil , B 1
However, this direct representation suffers from the problem with consistency checking. If a constraint is restricted on A , the representation will enforce the consistency of B 1 , B 2 , B checked. In fact, if A fails on consistency checking, this implies that all child components do not satisfy the corresponding constraints. Therefore, there is no need to check the constraints of the child components. As a consequence, this direct represen-tation will lead to redundant constraint checking and thus will bring slow configuring efficiency. Thus, in our approach, corre-sponding variable vA of component A takes the value A , which is itself DCSP variable and can pick up a value from { B 1 , b formula (1) is encoded according to Rule 4.1 while (2) X (4) are represented in terms of Rule 4.2 . 4.3.2. Structural relationship
The structural relationships between components in a con-figuration model encompass compositional relationships and subclass-of relationships. The former includes mandatory, optional, or cardinality relationship whereas the latter indicates the parent X  X hild relationship. In our approach, a new component can only be created and join in the configuring process through the structural relationships. Namely, the child components or sub-parts can only be involved in a configuration only after its aggregate (assembly) or parent component is selected in the configuration. The structural relationships are encoded as the activity constraints in DCSP.
 Rule 4.3. If a compositional relationship (mandatory, optional, or cardinality) is built from component B to A , meaning that B is a (mandatory, optional, or cardinality) part of A , the relationship can be encoded as a DCSP activity constraint: vA  X  t  X  t a nil  X ! ACT vB where vA  X  DSV  X  A  X  ; vB  X  DSV  X  B  X  ; t A Dom  X  vA  X  :
This reason is that the structural relationship can be regarded a function, as shown in Fig. 3 (a) X (c), which represents mandatory, optional, cardinality relationship, respectively. The definition of a function requires that if the variable vA takes a value in its domain, then there exists a corresponding value in the co-domain. This indicates that the variable vB must pick up a value if the variable vA is assigned a value. This is exactly what the activity constraint in the DCSP can characterize.
 Example 4.5. For the model shown in Fig. 2 , the optional relationship between A and X is encoded as the activity constraint vX  X  x ! ACT vA whereas the cardinality relationship between B and C is represented as A  X  b 3 ! ACT vC where DSV  X  B 3  X  X  A . Rule 4.4. If a subclass-of relationship is formed from component B to A (i.e. B is a child component of A ) and B also has other subclass components, the relationship is encoded as the DCSP activity constraint: A  X  B ! ACT B : Example 4.6. For the model shown in Fig. 2 , there is an inheri-tance relationship from B 1 to A in which A is the parent of B B also acts as parent component of B 11 and B 12 . This is encoded as: A  X  B 1 ! ACT B 1 . Note that B 1 is a value of the variable A , and on the other hand, serves as a variable with the domain: { b 4.3.3. Attribute and port
The port in our approach is a physical place within a compo-nent, which is of concrete shape and size, and is employed for connecting to other component by using a connector or plugging.
For example, a motherboard may have several slots (namely ports) for connecting to a network card, a video card, etc. The encoding of the port relationship is similar to that of the mandatory relationship since port is an inseparable part of a component. Moreover, an attribute of a component represents the characteristic of a component, such as cock-rate of a CPU. For the same reason, the encoding of the attribute relationship is the same as that of the mandatory relationship.

Rule 4.5. If the component A has a port P , this port relationship is encoded as the activity constraint in the DCSP. vA  X  t  X  t a nil  X ! ACT vP where vA  X  DSV  X  A  X  ; vP  X  DSV  X  P  X  ; : t A Dom  X  vA  X  :
Rule 4.6. If a component A has the attribute T which can take a encoded as the activity constraint in the DCSP. vA  X  m  X  m a nil  X ! ACT vT where m
A Dom  X  vA  X  vA  X  DSV  X  A  X  vT  X  DSV  X  T  X  : 4.3.4. Configuration constraints in the configuration model
Configuration constraints in product configuration domain typically include requisition constraints, exclusion constraints, port-connection constraints and resource constraints. The con-straints will be encoded as compatibility constraints in the DCSP, which will be elaborated below.

The exclusion constraint in configuration models specifies that two components cannot exist together in a configuration. The semantic of the exclusion constraints is exactly opposite to that of the compatibility constraints in the DCSP. Consequently, the transformation of the exclusion constraints is straightforward.
Namely, the exclusion constraints are directly encoded as com-patibility constraints in the DCSP.

Rule 4.7. If there exists the exclusion relationship between the components X 1 and Y 1 in the configuration model, and both
X and Y 1 are child components of the components P and Q , respectively, as shown in Fig. 4 , this relationship can be encoded as the compatibility constraint in DCSP.

C P , Q  X  X  x i , y i  X  9 sub _ of  X  X i , P  X  , sub _ of  X  Y elements that are contained in A , not in B . It can be seen that the configuration constraint on X 1 and Y 1 is transformed into the
DCSP compatibility constraint which is restricted on the variables that represent their corresponding parent components, i.e. P and
Q . This reason is that the variable representation of the compo-nent X 1 ( Y 1 ) should be P ( Q ) in accordance with the Rule 4.2 . This encoding rule is also suitable for the case in which the exclusion constraint is imposed on the component, which is an optional, or cardinality part. Fig. 5 shows that the exclusion constraint on the optional component P can be encoded in terms of this rule by equivalently transforming P as a component vP with child components P and nil . Similarly, the encoding paradigm can be used for the constraint on the component with the cardinality n y m . For example, for the exclusion constraint between P and Y in Fig. 5 , the following compatibility constraint can be derived: C vP , Q  X  X  nil , y 1  X  ,  X  nil , y 2  X  ,  X  p , y 2  X 
Example 4.7. For the model shown in Fig. 2 , the exclusion constraint between E and B 12 is encoded as DCSP compatibility constraint: DSV  X  E  X  X  vE Dom  X  vE  X  X  nil , e DSV  X  B 12  X  X  B 1 Dom  X  B 1  X  X  b 11 , b 12 C vE , B 1  X  X  b 11 , e  X  ,  X  b 11 , nil  X  ,  X  b 12 , nil  X  : and B 12 is transformed into DCSP compatibility constraint on the variables vE and B 1 . This is because that the corresponding DCSP variables of components E and B 12 are vE and B 1 , respectively, according to the Rules 4.1 and 4.2 .
 rather complicated, when structural relationships of a product, including the compositional and subclass-of relationships, are taken into account. There are two ways to deal with the transformation of the requisition constraints. One is that the requisition constraints are purely treated as activity constraints in the DCSP, which was adopted in the GCSP and Felfernig X  X  research ( Felfernig et al., 2002 ). In the case, a component can be dynamically created and join in the configuration before the aggregate (assembly) containing it exists in the configuration.
However, it may later happen that the aggregate is inconsistent when the aggregate is selected in the configuration. As a con-sequence, a chain of withdrawal of previous component assign-ment is needed and thus searching efficiency of the algorithms is adversely affected. By contrast, in our approach, the requisition constraint is encoded as the DCSP compatibility constraint, rather than the activity constraint as in GCSP. A new component can only be created through the compositional or subclass-of relation-ship with its high-level component (namely its aggregate or parent component). That is to say, a low-level component can be joined in the configuration only after its high-level component has been selected in the configuration. To encode the requisition constraint, a common root component between the two compo-nents should be found. To start with, the path expression and root component are defined below.

Definition 4.4. A path from P to Q in the configuration model is defined to find a path consisting of the components C 1 , C where C i  X  1 is a direct upper-level component of C i ( i  X  1, 2, 3, n ). In other words, these components satisfy the following logic formula: path  X  P , Q  X  has _ upper  X  P , c 1  X  4 has _ upper  X  c 1 where has _ upper  X  x , y  X  part _ of  X  x , y  X  3 sub _ of  X  x , y  X 
In the definition, the upper-level component y of x , i.e. has_upper ( x , y ), means that x is a part (i.e. optional, mandatory, cardinality) of y or a child component( sub_of )of y .
Definition 4.5. The components in the path from P to Q consti-tute a set r ( P , Q ),i.e.  X  P , Q  X  X  c i 9 c i is a component in Path  X  P , Q  X  , c
Here r ( P , Q ) is defined as a set of all components along the path from P to Q , but not including P and Q .

Definition 4.6. The root component R ( A , B ) is a high-level com-ponent that the two components A and B have in common. It should satisfy the logic sentence: path  X  A , R  X  4 path  X  B , R  X  where r  X  A , R  X \ r  X  B , R  X  X  F
Thus, the root component represents the first common upper-level component of A and B .

X whereas the path( A , X ) comprises A , K , X . Accordingly, component of A and B , i.e. R ( A , B )  X  X .

The requisition constraint from A to B in our approach is encoded as the compatibility constraints, which are imposed between the variable of A and that of each component in the r ( B , R ), namely each component in the path from B to R . The components along the path from B to R should be carefully checked to exclude potential assignment combination consisting of the value a and the child components or sub-components that are not in this path. For instance, if a component C 1 ,whose parent component is D , is in the path, the assignments consisting of its sibling components (such as C 2 and C 3 ) and the value a should be excluded from the value combination of variables corresponding to A and D . Take another example, if an optional component E occurs in this path, the value combination, i.e. ( a , nil ), should be excluded from value combination of A and vE .
 Rule 4.8. If there exists the requisition constraint from the component A to B and R is the root component of A and B , the constraint can be encoded into the following DCSP compatibility constraints. For every component C A r ( B , R ), (1) if C is an optional component: (2) if C is a child component: Example 4.9. For the requisition constraint from A to B shown in Fig. 6 , it can be encoded as the following DCSP compatibility constraints: R  X  A , B  X  X  X ; r  X  B , X  X  X  I , D , F DSV  X  K  X  X  vK ; Dom  X  vK  X  X  k DSV  X  I  X  X  vI ; Dom  X  vI  X  X  I DSV  X  D  X  X  I ; Dom  X  I  X  X  e , c , d DSV  X  F  X  X  vF ; Dom  X  vF  X  X  nil , F DSV  X  B  X  X  F ; Dom  X  F  X  X  b , g DSV  X  A  X  X  vA ; Dom  X  vA  X  X  nil , a C 1  X  C vA , F  X  X  a , b  X  ,  X  nil , b  X  ,  X  nil , g  X  C 2  X  C vA , vF  X  X  a , F  X  ,  X  nil , F  X  ,  X  nil , nil  X  C 3  X  C vA , I  X  X  a , d  X  ,  X  nil , e  X  ,  X  nil , c  X  ,  X  nil , d  X  C 4  X  C vA , vI  X  X  a , I  X  ,  X  nil , I  X  :
The connection constraint in the configuration model specifies that two ports must be connected in final configuration. If a port A requires another port B to be connected, this means that port B needs to be connected to A . Thus, the connection constraint between two ports is a symmetric relation. In fact, the connection constraint is a kind of special requisition constraint and thus, it can be treated as two requisition constraints. For instance, if connection ( A , B ) holds, the two requisition constraints, namely the encoding of the connection constraints is equivalent to that of two requisition constraints.
 Rule 4.9. If there exists the connection constraint on ports A and
B , it can be equivalently represented as a pair of the requisition then encoded as the DCSP compatibility constraints according to the Rule 4.8 .

In comparison with the requisition, exclusion and connection constraints, the encoding of the resource constraint, which restricts that the total amount of consumed resources should be less than or equal to that of supplied resources in a valid configuration, is much more complex. The resource constraint can be described in arithmetic formula involving operators such as  X  , , Z ,  X  , r . In our approach, checking resource constraint is also treated as compatibility checking.

Rule 4.10. For a resource constraint, RC k in a structural product configuration, it is represented as DCSP compatibility constraint in the form of inequality:
RC : where 0 , Val  X  DSV  X  C i  X  X  X  nil and C i is optional : 1 , Val  X  DSV  X  C i  X  X  X  C i or C i is mandatory : n , Val  X  DSV  X  C i  X  X  X  nC i and C i is a cardinality component : 1 , Val  X  DSV  X  C i  X  X  X  C i , and C i is a child component : 0 , Val  X  DSV  X  C i  X  X  a C i and C i is a child component : 8 &gt; &gt; &gt; &gt; &gt; &gt; &gt; &lt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; :
In the above definition, the predicate Val ( x ) means the value that the variable x takes from its domain. 4.3.5. Customer requirements
A customer requirement is often specified either by a function, which may be implemented by one or several components, or by directly specifying the value of component variables or attribute variables. For example, a customer requires that the desired drilling diameter should be between 72 mm and 92 mm. This in turn implies the selection of HL600 according to the mapping from function to component. Therefore, this requirement is encoded as a unary constraint on domain of the variable
HL600&amp;700 : HL600&amp;70  X  HL600 . Moreover, customers may indi-cate that two components are needed to (or not to) exist in the configuration, which can be directly represented as DCSP compat-ibility constraints using the encoding approach for the requisition constraints and exclusion constraints.
 as costs and weight on the configuration as soft constraints. This preference is considered as a factor in the objective function of configuration optimization problem. 4.4. Encoding structural product configuration as a DCSP straints in the model can be encoded as DCSP elements, as shown above. Consequently, the configuration model in O-O representa-tion is treated as a DCSP such that the inference technologies for solving a DCSP can be utilized to obtain the configuration solutions. The product configuration problem (PCP) is formalized as a DCSP as below:
PCP :  X  V U , V V , D , C A , C C , C N where V U is a set of unassigned active variables. Initially, there is only one element in this set, i.e. the root node in the class diagram for the configuration model. V V : a set of assigned active variables. variables, attribute variables and port variables that correspond to component classes, attribute classes and port classes, respec-tively. D :  X  { D C , D A , D P } where D C , D A and D P which variables in the set V C , V A and V P take values, respectively.
C A : a set of activity constraints that are derived in terms of the encoding rules for the structural relationships. C C : a set of compatible constraints, represented in the form of sets of com-patible value combination or arithmetic formula, are derived in accordance with the encoding rules for configuration constraints. 5. Backtracking-based search algorithm for solving structural product configuration 5.1. The algorithm CONFIG_SOLVE customizable product and configuration constraints, the solving algorithm for structural product configuration utilizes backtrack-ing-based search, which is main inference mechanism for solving DCSP, to derive configuration solutions. The algorithm CONFIG_-
SOLVE, as shown in both Figs. 7 and 8 in pseudo-code way, generates a solution or all solutions to the configuration problem by encoding the conceptual model into a DCSP in accordance with the rules in Section 4 . It starts with the initialization of the sets where Vroot , representing the top-level node in the model, is added to the set V U (line 2 X 5). Next, configuration constraints such as the requisition and exclusion constraints are reduced to compatibility constraints in the DCSP in terms of the Rules 4.7 and 4.8 (line 6). The main configuring process is performed by means of invoking a recursive procedure CONFIG_BACK-
TRACK_DCSP with the variable model , Vroot and sol as inputs, which denote the model, the root node, the set to save the solution, respectively (line 7). The procedure CONFIG_BACK-
TRACK_DCSP adopts the recursive depth-first traversal algorithm with backtracking. With the variable var representing a node in the configuration model as the input (line 9), this procedure picks a value val from its domain and assigns the value to this variable (line 12 X 13). If the assignment, i.e. var  X  val , satisfies the compat-ibility constraints and resource constraints (line 14), the proce-dure CHECK_SUBCLASS_COMP is invoked to check whether the value or the variable has the subclass components (line 15). If this holds true, the activity constraints and the new variable are added to the corresponding sets C A and V U , respectively, according to
Rule 4.4 (line 31 X 44 in Fig. 8 ). Then, structural relations (such as optional relationships, ports and attributes) in the configuration model are transformed into DCSP by applying the procedure
TRANS_STRUCT_DCSP (line 16). Accordingly, the activity con-straints and new variables are inserted into corresponding sets C and V U in terms of Rules 4.3, 4.5 and 4.6 (line 46 X 64). The next variable to be assigned is picked from the set V U (line 17). With this variable as an input, CONFIG_BACKTRACK_DCSP invokes itself recursively (line 18). If the recursive algorithm returns true, it indicates that the picked variable and its value satisfy the constraints in the DCSP. Therefore, the variable and its assign-ment are added to the solution (line 19 X 21). Otherwise, the activity constraints and active variables that have been added to the set C A and V U due to the assignment of this variable are removed from the sets (line 23). When all values of the variable have been attempted and the procedure return false, backtracking occurs (line 26). The backtracking begins with removing the assigned value (line 27). The algorithm stops when all variables in the V U are assigned. Depending on the requirements, the algorithm can generate one or all solutions to a configuration problem Fig. 9 . 5.2. The configuration example
To illustrate complete procedure of this algorithm, consider the configuration example that has been shown in Fig. 6 . Initially, the sets C A , containing activity constraints, and V V , representing the set of assigned active variables, are empty sets. It is known that the configuration constraint, namely the requisition con-straint from A to B , is transformed into four compatibility constraints C 1, C 2, C 3 and C4, as shown in Example 4.9 . The root variable vX whose domain is { x } is included in the set V representing the set of unassigned variables (line 3 X 7). The solving procedures according to the algorithm CONFIG-SOLVE are shown below:
Step 1 : Select the only variable vX from the table V U and assign the value x to vX (line 12 X 13; node 1).

Step 2 : Generate the activity rules Vx ! ACT vK , vI and add them to C A (line 16). Add the variables vK and vI to the table V the and set their domain ( Rule 4.1 ).

Step 3 : Select the next variable vK from the table V U and assign k to vK (line 17 X 18; node 2).

Step 4 : Generate the activity rule vK  X  k ! ACT vH , vA and add them to C A ( Rule 4.3 ). Add vA and vH to the table V U and set their domain ( Rule 4.1 ).
 Step 5 : Select the next variable vI and assign I to vI (node 3). Step 6. Generate the activity rule vI  X  I ! ACT I and add it to C ( Rule 4.2 ). Add I to the table V U and set its domain ( Rule 4.2 ). Step 7 : Select the next variable vH and assign h to vH (node 4). Step 8 : Select the next variable vA and assign a to vA (node 5).
The value combination ( v A  X  a , vI  X  I ) satisfies the compatibility constraint C 4 (see Example 4.9 ).

Step 9 : Select the next variable I and assign e to I (node 6). The value combination ( v A  X  a , I  X  e ) violates the compatibility constraint C 3 (see Example 4.9 ).

Step 10 : The algorithm re-selects the value d and assign it to I (node 6). The constraint C 3 is satisfied.
 Step 11 : Generate the activity rule I  X  d ! ACT vF and add it to C
A ( Rule 4.3 ). Add vF to the table V U and set its domain ( Rule 4.1 ).
 Step 12 : Select the next variable vF and assign nil to vF (node 7).
The value combination ( v A  X  a , vF  X  nil ) violate the compat-ibility constraint C 2 (see Example 4.9 ).
 Step 13 : Re-reselects the value F and assign it to vF (node 7). The constrain C 2 is satisfied.
 Step 14 : Generate the activity rule vF  X  F ! ACT F and add it to C
A ( Rule 4.2 ). Add F to the table V U and set its domain ( Rule 4.2 ).

Step 15 : Select the next variable F and assign b to F (node 8). All variables in V U are assigned and satisfy all compatibility constraints including C 1 X  C 4. As a consequence, the algorithm finishes.

Therefore, a solution to the example is the component set consisting of the component variables from node 1 to node 8, satisfy corresponding constraints in the example. 5.3. Product configuration optimization
In most cases, there exist multiple configuration solutions when customer requirements are given. In this situation, config-uration optimization is needed to take into account given some criterion such as prices and costs. The presented algorithm
CONFIG_SOLVE can be extended with Branch-and-bound (B&amp;B) ( Wayne, 2003 ) to derive the optimal configuration. The detailed procedures are omitted due to space limitation. 6. Comparison, analysis and experimental study
To compare different encoding paradigms (i.e. CSP, GCSP and our presented approach) for the configuration problems, the model in Fig. 6 is used as an illustrate example due to its simplicity. Fig. 10 compares corresponding encoding representa-tions for the model using CSP, GCSP and the presented approach.
As shown in the figure, numerical encoding is adopted for CSP while both presented approach and GCSP employ symbolic encoding. Comparatively, the symbolic encoding is more compact than numerical encoding in which every component must be represented in 0 or 1. For GCSP encoding, additional port variables (like X_Ports , D_Port ) are generated for the parts (such as X and D ) with a part-of relationship, in addition to the required component variables (such as X and D ). Furthermore, 4 activity constraints are needed to represent a part-of relationship in the configuration process. For instance, constraints (1) X (4) denote the part-of relationship from F to D . Obviously, the number of the variables required to encode the configuration model using the presented approach is smallest among these three encoding paradigms.
Table 3 also compares the number of variables and constraints used to encode the models in both Figs. 1 and 6 using the three approaches whereas Table 2 summarizes the parameters of both models.

The complexity of CSP or DCSP algorithm depends on the size of the search space, i.e. the number of nodes in the search tree ( Tsang, 1993 ), which is 1  X  where n is the total number of variables and 9 Dx 1 9 is the size of domain of the variable X i
Thus, the complexity of CSP is dominated by the last term, 9 Dx 1 9 : 9 Dx 2 9 : 9 Dx n 9 .

It can be seen that the size of search space depends on the number of variables and the size of domains. As shown in Table 3 , our presented method allows compact encoding of configuration models. For the same configuration problem, the number of variables that are generated using the presented approach is much smaller. To take the model in Fig. 6 as an example, there are 11 variables for CSP encoding approach while only 8 variables need to be described in our study. According to the complexity of
CSP, the last term for CSP representation, i.e. 9 Dx 1 9 : is 2 11  X  2048 whereas the term is 3 2 3  X  24 for the presented approach. Furthermore, for a concrete configuration instance, not all 8 variables need to be assigned due to the advantage of DCSP.
Therefore, the presented approach shows a tangible advantage over the CSP paradigm. As described before, both our study and the work of Felfernig et al. and GCSP method are based on DCSP, and however, differ in handling the encoding of the compositional relationships (i.e. part-of) in the model. If we assume that there are n part-of (i.e. compositional) relationships in the configuration model, the numbers of the DCSP variables and activity constraints using the presented approach are 2 n and n respectively. Nevertheless, theoretically, 4 n DCSP variables and 4 n activity constraints are required using the method presented by Felfernig et al. and GCSP, if there does not exist any component that is involved in two or more compositional relationships. Due to the complexity of DCSP algorithm depending on the number of the variables, our encod-ing approach implies a substantial improvement in the configur-ing efficiency.

We have implemented the presented DCSP configuration algorithm (called OO-DCSP) and optimization algorithm (called OO-DCSP-BB) based on Java Constraint Library (JCL) ( Viappiani, 2004 ) which provided essential Java classes for handling a CSP. Due to the fact that JConfigurator, the core solving mechanism of which is not completely known from the literature, has been no longer maintained by ILOG and thus becomes unavailable, we cannot carry out the experiments on the comparison of our study and that of Felfernig et al. However, it is obviously seen from the aforementioned analysis that the presented approach show more compact encoding of the configuration problems. Thus, the pre-sented DCSP configuration and optimization algorithms are com-pared with the CSP algorithm. The experiments were conducted on a Intel Core Dual T2050 computer at 1.60 GHz with 1 G GB of RAM. A random generator was designed to accept the three inputs: the number of components ( NC ), the number of con-straints ( NCC ), the number of abstract levels ( AL ) the branching width of a component ( B ) (i.e. maximum number of child components or sub-parts). In accordance with the combination of randomly generated parameters, a number of configuration instances can be derived. Fig. 11 shows the test results of yielding all configuration solutions for the configuration case with the parameters ( AL  X  5, B  X  3, NCC r 12). However, the number of components ( NC ) in this experiment varied from 10 to 50. As the metric for comparison, we counted the number of visited nodes of the search tree and CPU time in Fig. 11 (a) and (b), respectively. The result shows that the algorithm OO_DCSP significantly outperforms the CSP configuration algorithm as number of the total components increases. However, for yielding a feasible solution, OO_DCSP did not perform better than CSP configuration algorithm, as shown in Fig. 12 . We further com-pared the presented configuration optimization algorithm (OO_DCSP_BB), which extended DCSP with Branch-and-Bound, with standard CSP with Branch-and-Bound optimization algo-rithm (CSP_BB). The results in Fig. 13 shows that OO_DCSP_BB offers a significant improvement in reducing the number of visited nodes in the search tree. Consequently, it can be obviously seen that DCSP algorithm is much more effective in configuring products when multiple feasible solutions or configuration optimization are dealt with. 7. Conclusion
In this paper, a novel approach to encoding the configuration model as a DCSP is presented with the emphasis on the customization of structural products. The main contribution is to apply structural knowledge of products in encoding the configuration problem as a DCSP. Furthermore, configuration constrains are translated into compatibility constrains in DCSP.
The presented encoding approach can help to reduce the number of variables in DCSP, thus allowing a more compact encoding representation. As a consequence, the efficiency of the configura-tion can be substantially enhanced. The backtracking-based con-figuration algorithms are implemented based on JCL. Experiments are conducted to compare the presented approach with CSP based configuration approach. The result shows that the presented approach makes a significant improvement in the performance of configuration algorithm. Further research is to investigate the combination of ontology-based representation for configuration models with DCSP to solve the product configuration and opti-mization problem. Moreover, the tighter lower bound in DCSP with B&amp;B should be studied to further prune the search space. Acknowledgments from National Natural Science Foundation of China (Project No. 70971084) and  X  X  X hu Guang X  X  project (No. 09SG17) of Shanghai
Municipal Education Commission and Shanghai Education Devel-opment Foundation.
 References
