 Data completeness is an important aspect of data quality. We con-sider a setting, where databases can be incomplete in two ways: records may be missing and records may contain null values. We (i) formalize when the answer set of a query is complete in spite of such incompleteness, and (ii) we introduce table completeness statements, by which one can express that certain parts of a database are complete. We then study how to deduce from a set of table-completeness statements that a query can be answered completely.
Null values as used in SQL are ambiguous. They can indicate unknown. We study completeness reasoning for the di ff erent in-terpretations. We show that in the combined case it is necessary to syntactically distinguish between di ff erent kinds of null values and present an encoding for doing that in standard SQL databases. With this technique, any SQL DBMS evaluates complete queries correctly with respect to the di ff erent meanings that nulls can carry. We study the complexity of completeness reasoning and provide al-gorithms that in most cases agree with the worst-case lower bounds. H.2.7 [ Database Management ]: Database Administration Data Quality, Data Completeness, Metadata Management
Decisions in business, politics and administration are taken on the basis of an ever increasing supply of information. To make the right decision, it is crucial to know how reliable the underlying data is. Often, data from diverse backgrounds are combined, which originate independently and according to di ff erent policies. As a consequence, the quality of the data may largely vary.

Aspects of data quality concern accuracy, currency, correctness, and similar issues [3]. In settings such as manual data insertion or data integration, completeness of data plays a key role [15]. Many approaches aim to improve data quality by inspecting and trans-forming concrete data. For instance, there is a wealth of techniques to detect and eliminate duplicate records. To deal with data com-pleteness, such approaches have limited applicability: by inspect-ing data it is hard to detect whether or not something is missing.
Consider as a driving example the management of school data in a school district, which motivated the technical work reported here. The schools in the district are largely autonomous in the way they run their business: although the district provides a cen-tral database for administering data about students, teachers and the like, the schools can choose to what extent to use this system. As a consequence, on many topics data is incomplete, which becomes a problem when statistics about the schools are needed. While in principle, those statistics could be generated by queries over the database, the administration does not know whether or not it can trust the answers. In particular, if an item does not show up in whether that item does not have the property queried for in real-ity, or relevant data were just not submitted. The administration has some knowledge as to what data individual schools put into the central database. The question is how such metadata can be utilized to judge whether it is complete and thus can be trusted.

The first researcher to address this question was Motro who for-malized completeness of databases and queries [14]. Halevy intro-duced statements, by which one can express that certain parts of a database are complete and raised the question how to use such statements to infer query completeness [12]. Recently, Razniewski and Nutt provided a general solution to this problem, including a technique to design algorithms and a comprehensive study of the complexity [16]. All this work considered only incompleteness in the form of missing records. In practice however, incompleteness in the form of null values is at least the same important. To take into account nulls we extend in this work previous formalisms by refining the granularity of completeness descriptions.

A problem with null s as used in standard SQL databases is their ambiguity, as those null s may mean both that an attribute value exists but is unknown, or that no value applies to that attribute. The established models of null values, such as Codd, v-, and c-tables [13], avoid this ambiguity by concentrating on the aspect of unknown values. In this work, we consider the ambiguous standard SQL null values [5], because those are the ones used in practice.
In this paper, we define a formal framework to study reasoning about the completeness of query answers over databases with null values and missing records. In Section 2, we introduce a school database as running example. Sections 3 formalizes databases with null values, incomplete databases and completeness statements. Sec-tion 4 presents the reasoning for simple, uniform meanings of null values, while in Section 5 we point out the limitations when com-bining the di ff erent meanings. Section 6 shows how the di meanings of nulls can be made explicit in standard SQL databases, while Sections 7 shows that reasoning is possible in that case. Sec-tion 8 discusses the reasoning for queries under bag semantics, Sec-tion 9 the complexity of reasoning, and Section 10 related work.
Our running example is that of a school database, which con-tains, inter alia, the following two tables:
The student table stores for each student the name, the class and the home town. Because we assume that the school is situated in a remote area, some students do not belong to any class but are taught at home. This would be indicated by a null value for the classCode attribute. It may also happen that there is no entry for the homeTown attribute, because the student did not provide this information or the secretary did not enter the data yet.

The class table stores the classes of the school. For each class, it stores its code, its form teacher and its profile, such as arts, sci-ence or similar. The formTeacher attribute may be null , because the decision of forming a class may have been taken before assign-ing the form teachers, or because the secretary may have forgotten to insert the form teacher. The profile attribute can be null , because some classes do not have a special profile.
In the following, we introduce standard notations about databases with null values and query evaluation, and introduce the notions of partial databases, query completeness and table completeness that we use in reasoning about completeness.
A database schema is a set of relation symbols  X  each with an arity. In the following, we assume the schema to be fixed. We as-sume an infinite set of constants dom including a special symbol  X  for null values.

For a relation R with arity n , an atom is an expression R ( t where t 1 ... t n are either elements of dom or variables. A database instance D is a finite set of ground atoms. We sometimes refer to the atoms in an instance as facts. A condition is a set of atoms.
A conjunctive query is written as Q (  X  x )  X  L , where L is a condi-tion and  X  x is a tuple of variables, each occuring also in L . We call L the body of Q , the variables in  X  x the distinguished variables and the other variables in L the nondistinguished variables . Given a con-junctive query Q (  X  x )  X  L and an instance D , an answer to Q is a tuple  X   X  x , where  X  is an assignment of values to variables such that  X  L  X  D . The set of all answers to Q over D is written as Q s ( D ). Similarly, we define Q b ( D ) as the bag of anwers that contains as many copies of a tuple as there are assignments returning it. We say that Q is evaluated under set or bag semantics, respectively, if we refer to the set or bag of answers. We drop the superscripts s , b if they are not important or clear from the context.

A conjunctive query is linear , if its body does not contain any relation symbol twice. It is minimal , if no atom can be removed from its body without changing the semantics of the query (cf. [4]).
Nulls are a common form in which incompleteness is manifested in real-world databases. Null values mainly have two meanings: In database theory, unknown values are represented by so-called Codd nulls, which are essentially existentially quantified first-order variables. A relation instance with Codd nulls, called a Codd ta-ble , represents the set of all regular instances that can be obtained by instantiating those variables with non-null values. [1]. For a conjunctive query Q over an instance with Codd nulls, say D one usually considers certain answer semantics [1]: the result set Q cert ( D Codd ) consists of those tuples that are in Q ( D stantiation D 0 of D Codd . The set Q cert ( D Codd ) can be computed by evaluating Q over D Codd while treating each occurrence of a null like a di ff erent constant and then dropping tuples with nulls from the result. Formally, using the notation
The null values supported by SQL ( X  X QL nulls X  in short) have a di ff erent semantics than Codd nulls. Evaluation of first order queries follows a three-valued semantics with the additional truth value unknown . For a conjunctive query Q , we say that y is a join variable if y occurs at least twice in the body of Q and a singleton variable otherwise. If D SQL contains facts with null values, then under SQL X  X  semantics the result of evaluating Q (  X  x ) over D To see this, note that a twofold occurrence of a variable y is ex-pressed in an SQL query by an equality between two attributes, which evaluates to unknown if a null is involved.

Recently, Franconi and Tessaris [11] have shown that the SQL way to evaluate queries over instances with nulls captures exactly the semantics of attributes that are not applicable. To make this more precise, suppose that R is an n -ary relation with attribute set X : = { A R can be seen as representing for each Y  X  X a relation R attribute set Y . In this perspective, an instance of R with tuples tions R Y , where a tuple t belongs to the instance R Y i t for the attributes in Y are not null. In other words, null values are padding the positions that do not correspond to attributes of R
Example 1. Consider the query Q that asks for all classes whose form teacher is also form teacher of a class with arts as profile, which we write as Q ( c 1 )  X  class ( c 1 , t , p ) , class ( c the instance D = { class (1 a ,  X  , 0 arts 0 ) } . If we interpret  X  as Codd-null, then (1 a )  X  Q Codd ( D ). If we evaluate Q under the standard SQL semantics, we have that (1 a ) &lt; Q SQL ( D ).

Suppose we know that class 1a has a form teacher. Then whoever the teacher of that class really is, the class has a teacher who teaches a class with arts as profile and the the first interpretation is correct. If no teacher exists, the second interpretation is correct.
Note that certain answer semantics and SQL semantics are not comparable in that the former admits more joins, while the latter allows for nulls in the query result. Later on we will show how for complete queries we can compute certain answers from SQL answers by simply dropping tuples with nulls.

We will say that a tuple with nulls representing an unknown but existing value is an incomplete tuple , since this nulls indicate the absence of existing values. We say that a tuple where nulls rep-resent that no value exists is a restricted tuple , because only the not-null values in the tuple are related to each other. When mod-eling databases with null values, we will initially not syntactically distinguish between di ff erent kinds of null values and assume that some atoms in an instance contain the symbol  X  .
When stating that data is incomplete, one must have a concep-tual complete reference. We model partial databases in the style of Levy [12] as pairs D = ( D i , D a ) of database instances: D i , the ideal state, with complete information, and D a , the available state, which contains possibly less information. In general, both D i and D
In an application, the state stored in a DBMS is the available state, which represents only a part of the facts that hold in real-ity. The facts holding in reality constitute the ideal state, which however is unknown. (Later on we will assume that we have some meta-information about the extent to which the available state cap-tures the ideal state.)
We formalize that the available database contains less informa-tion than the ideal one using the concept of dominance: Let R (  X  s ) and R (  X  t ) be atoms that possibly contain nulls. Then R (  X  s ) is dom-except that R (  X  s ) may have nulls where R (  X  t ) does not. An instance D is dominated by an instance D 0 , written D D 0 , if each fact in D is dominated by some fact in D 0 .
 Proposition 1 (Monotonicity) Let Q be a conjunctive query and D, D 0 be database instances with nulls. Suppose that D is domi-nated by D 0 . Then Q cert ( D )  X  Q cert ( D 0 ) and Q SQL
A partial database (or PDB for short) is a pair of database in-D = ( D i , D a ) is a simple partial database if D a  X  D i and neither D i nor D a contains a null value. Completeness reasoning for simple partial databases has been studied in [16]. We say that D is a par-tial database with restricted facts if D a  X  D i . Note that in this case the ideal state may contain nulls and that every fact in the available state must appear in the same form in the ideal state. Thus, a null in the position of an attribute means that the attribute is not applicable and nulls are interpreted the way SQL does. The pair ( D i , D a ) is a partial database with incomplete facts if D i does not contain any nulls and D a is dominated by D i . In this case, there are no nulls in the ideal state, which means that all attributes are applicable, while the nulls in the available state indicate that attribute values are un-known. Therefore, those nulls have the same semantics as Codd nulls.

Example 2. Recall the school database from our running exam-ple, defined in Section 2. In Table 1 we see a partial database with restricted facts for this scenario. All null values appearing in the available database mean that no value exists for the correspond-ing attributes. The class table shows that no profile hass been assigned to class 2b and that Mary is an external student not be-longing to any class.

In contrast, Table 2 shows a partial database with incomplete facts. Here, null values in the available database mean that a value exists but is unknown. So, class 1a has form teacher, but we do not know who. Class 2b has a profile, but we do not now which. John has a hometown, but we do not no from where he comes.

Observe that in both kinds of partial databases, some facts, such as the one about Paul being a student, can be missing completely.
In practice, null values of both meanings will occur at the same time, which may lead to di ffi culties if they cannot be distinguished.
Data are accessed by posing queries. The core question we pur-sue in our work is whether a database has su ffi cient information to answer a query, that is, whether a query is complete. Intuitively, if we can infer from some meta-information that a query is complete, we know that the answer we receive over the available database at hand is the same as the one we would get when querying the ideal database. In other words, the available database contains all the data that is relevant for calculating the query answer, so one can trust the result that one gets.

We write Compl s ( Q ) and Compl b ( Q ), respectively, to indicate that Q is complete under set or bag semantics. We now define when such a query completeness (QC) statement is satisfied by a partial database.

If D = ( D i , D a ) is a simple partial database (i.e., without nulls), then D | = Compl s ( Q ) if and only if Q s ( D i ) = Q s ( Compl b ( Q ) if and only if Q b ( D i ) = Q b ( D a ) (cf. [14]).
If D contains nulls, then Q s ( D ) and Q b ( D ) depend on whether we interpret those as Codd or as SQL nulls.

Suppose D is a PDB with incomplete facts. Then nulls are in-terpreted as Codd nulls and queries are evaluated under certain answer semantics. While D a may contain nulls, D i does not and Q where  X  X  X { s , b } . That is, the tuples returned by Q over D i are also returned over D a if nulls are treated according to certain answer is also returned over D i follows by mononoticity from the fact that D
Suppose that D is a PDB with restricted facts. Then nulls are interpreted as SQL nulls and queries are evaluated under SQL se-mantics. For  X  X  X { s , b } we define Again, the crucial part is that tuples returned by Q over D i are also returned over D a if nulls are treated according to SQL semantics, while the converse inclusion holds due to monotonicity.

Example 3. The query Q art_students ( n )  X  student ( n , c , h ) , class ( c , t , 0 arts 0 ) asks for the names of students in classes with arts as profile. Over D i in Table 2 it returns the singleton set { (John) } and over D a as well. Therefore, Q art_students is complete over that partial database.

In contrast, Q homes ( h )  X  student ( n , c , h ) is not complete over this database, because it returns { (Chester) , (Hampton) , (Westfield) } over the ideal database but only { (Hampton) , (  X  ) } over the available one.
We use table completeness (TC) statements to specify that parts of a table are complete. A table completeness statement, written dition G . The numbers in P are interpreted as attribute positions of R . For instance, if R is the relation student , then { 1 , 3 } refers to the attributes name and hometown .

Let C = Compl ( R (  X  s ); P ; G ) be a TC statement and D an incomplete database. An atom R (  X  u )  X  D i is constrained by C in P . We say that C is satisfied by D if for every atom R (  X  u )  X  D i that is constrained by C there is an indicator R (  X  u 0
Note that this type of TC statements extends the ones in [12] and [16] in that it allows one to state the completeness of projections of tables.
 Example 4. In our school scenario, the TC statement states, intuitively, that the available database contains for all stu-dents of classes with arts as profile the name and the class. How-ever, the student X  X  hometown need not be present. Over the ideal database in Example 2, the fact student (John , 1a , Chester) is con-strained by the statement (5). Any fact student (John , 1a ,  X  ), student (John , 1a , Chester) or student (John , 1a , Clayton) in D would be an indicator. In the database in Table 2 the first fact is present, and therefore Statement (5) is satisfied over it.
The semantics of TC statements can also be expressed using rule notation like the one that is used for instance for tuple-generating dependencies (TGDs) (see [7]). As a preparation, we introduce two copies of our signature  X  , which we denote as  X  i and first contains a relation symbol R i for every R  X   X  and the second contains a symbol R a . Now, every incomplete database ( D i , D a ) can to conditions G . By replacing every occurrence of a symbol R by R Q i and Q a for a query Q . With this notation, ( D i , D a ) | i ff
We associate to each TC statement C = Compl ( R (  X  s ); P ; G ) a rule  X  C . For instance, to Statement (5) we associate the rule class i ( c , t , 0 arts 0 ) , student i ( n , c , h )  X  X  X  h To simplify our notation, we assume that the projection positions P are the first k positions of R and that  X  s has the form (  X  s  X  s has length k and  X  s 00 has length arity ( R )  X  k . Then  X  where  X  z is a tuple of distinct fresh variables that has the same lenght as  X  s 00 . Clearly, for every TC statement C , an incomplete database satisfies C in the sense defined above if and only if it satisfies the rule  X  C in the classical sense of rule satisfaction.

Note, that our definition of when a TC statement is satisfied takes into account null values. Regarding nulls in D a , we treat nulls like non-null values and consider their presence su ffi cient to satisfy an existential quantification in the head of a TC rule.

Nulls in D i , however, have to be taken into account when eval-uating the body of a rule. Since nulls in the ideal database always represent the absence of a value, we always interpret the rules that we associated with TC statements under SQL semantics.
As usual, a set C of TC statements entails completeness of a query Q (we write C | = Compl ( Q )) if every partial database that satisfies all statements in C also satisfies Compl ( Q ).
While TC statements are a natural way to describe completeness of available data ( X  X hese parts of the data are complete X ), query completeness captures requirements for data quality ( X  X or these queries we need complete answers X ). Thus, in the following we investigate how to decide whether a set of TC statements entails query completeness (TC-QC entailment).
In this section we discuss reasoning for databases where the meaning of nulls is unambiguous. In 4.1, we assume that nulls always mean that a value is missing but exists, while in 4.2, we assume that nulls mean that a value is inapplicable. For both cases we give decidable characterizations of TC-QC entailment. More-over, we show that evaluation under certain answer and under SQL semantics lead to the same results for minimal complete queries.
We suppose we are given a set of TC statements C and a conjunc-tive query Q , which is to be evaluated under set semantics. We say that C entails Compl s ( Q ) over PDBs with incomplete facts , written i ff for every such PDB D we have that To decide property (6), we will derive a characterization that can be e ff ectively checked.

To this end we introduce for every set C of TC statements a transformation T C that, intuitively, maps an instance D to the least informative instance T C ( D ) such that ( D , T C ( D )) | Compl ( R (  X  s 0 ,  X  s 00 ); P ; G ) be a TC statement, where wlog  X  s of the terms in the positions P . We define the query Q C This means, given an instance D , the query Q C returns for every  X  satisfying the condition R (  X  s 0 ,  X  s 00 ) , G , a tuple (  X   X  s of the projected part  X   X  s 0 and is padded with  X  s for the positions projected out. We then define and T C ( D ) : = S C  X  X  T C ( D ).

Intuitively, for a database instance D i and a TC statement C , the function T C calculates the minimal information that any available database D a must contain in order that ( D i , D a ) together satisfy C . Observe that every atom in T C ( D ) is an indicator for some R (  X  u ) in D wrt C . This is the case because every fact in T C ( D ) is created as an indicator for some fact in D constrainted by C . Observe also that in general, T C ( D ) may contain more facts than D , because several TC statments may constrain the same atom and therefore several indicators are produced.

Example 5. Consider the TC statement C defined in Example 4 as Compl ( student ( n , c , h ); { 1 , 2 } ; class ( c , t , sponding query is Q C ( n , c ,  X  )  X  student ( n , c , h ) , class ( c , t , For the partial database in Table 2, Q C ( D i ) is { ( John , 1 a ,  X  ) } and hence T C ( D i ) = { student ( John , 1 a ,  X  ) } , which is the minimal information that any available database must contain to satisfy to-gether with D i the TC statement C .
 The following proposition formalizes the intuition about T Proposition 2 Let D be a database instance without nulls and let D 0 be the partial database ( D , T C ( D )) . Then 1. T C ( D ) is dominated by D, 2. D 0 is a PDB with incomplete facts, and 3. D 0 | = C .
 Moreover, if D 0 is another instance such that ( D , D 0 ) is a PDB with incomplete facts that satisfies C , then D 0 dominates T C
Similar to a database instance, the body of a conjunctive query is a set of atoms, to which we can apply the transformation T we view the variables as constants. The following characterization of TC-QC-entailment over PDBs with incomplete facts says that completeness of Q wrt. C can be checked by evaluating Q over T ( L ).
 Theorem 3 Let Q (  X  x )  X  L be a conjunctive query and C be a set of table completeness statements. Then
P roof .  X   X   X  By Proposition 2, ( L , T C ( L )) is a PDB with incom-plete facts that satisfies C . Thus, by assumption, ( L , T L to L is a satisfying assignment for Q over L , from which it follows that  X  x  X  Q ( L ), and hence  X  x  X  Q cert ( T C ( L )).  X   X   X  Suppose that  X  x  X  Q cert ( T C ( L )). We show that C | Compl s ( Q ). Let D = ( D i , D a ) be a PDB with incomplete facts that satisfies C and suppose that  X  d  X  Q s ( D i ). We show that  X  (the converse holds because of the dominance of D a by D i ).
Given that there is an assignment  X  such that  X  L  X  D i and  X   X  x we construct an assignment  X  0 such that  X  0 L  X  D a and  X  0  X  define  X  0 , we specify how it maps atoms of L to D a .

Let A be an atom in L . Since  X  x  X  Q cert ( T C ( L )), there is a ho-morphism  X  from L to T C ( L ) such that  X   X  x =  X  x . Let B T ( L ). By construction of T C ( L ), there is a TC-statement C Compl ( B ; P ; G ) such that ( B , G )  X  L and B 0 has been constructed as indicator for B wrt. C . Since  X  L  X  D i , we have (  X  B , X  G )  X  D i . Clearly,  X  B is constrained by C over D . Since D | = C , there is an indicator atom  X  B for  X  B in D a . Defining that  X  0 A : ping  X  0 proves that  X  d is also in Q ( D a ) and hence that the query is complete.

The idea of the theorem is the following: To check whether com-pleteness of a query Q is entailed by a set of TC statements C , we perform a test over a prototypical database: Considering the body of the query as an ideal database, we test whether the satisfaction of the TC statements C implies that there is also enough information in any available database to return the tuple of the distinguished variables  X  x . If that is the case, then also for any other tuple found over an ideal database, there is enough information in the available database to compute that tuple again.

Example 6. Consider again the query from Example 3, which is Q art_students ( n )  X  student( n , c , h ) , class( c , t , state that complete facts about all classes are in our database, and that for all students from art classes the name and the class attribute are in the database. When we want to find out whether C 1 imply that query Q art_students returns a complete answer, we proceed according to Theorem 3 as follows: 1. We take the body of the query Q art_students as a prototypical 2. We apply the functions T C 1 and T C 2 to L to generate the mini-3. We evaluate Q art_students over T C 1 ( L )  X  T C 2 ( L ). The result is The tuple ( n ) is exactly the distinguished variable of Q Therefore, we conclude that C 1 and C 2 entail query completeness under certain answer semantics.

We will discuss the complexity of reasoning in Section 9. At this point we only remark that the reasoning is in NP for conjunctive queries, since all that needs to be done is query evaluation, first of the TC rules in order to calculate T C ( L ), second of Q , in order to check whether  X  x  X  Q ( T C ( L )). Also, for conjunctive queries without self-joins the reasoning can be done in polynomial time.

So far we have assumed that nulls in the available database are treated as Codd nulls and that queries are evaluated under certain answer semantics. Existing DBMSs, however, implement the SQL semantics of nulls, which is more restrictive, as it does not allow for joins involving nulls, and thus leads to fewer answers. In the following we will show that SQL semantics gives us the same re-sults as certain answer semantics for a query Q , if Q is complete and minimal.
 In analogy to  X  | = inc  X , we define for a PDB with incomplete facts D = ( D i , D a ) that D | = Q if D | = inc , SQL Compl s ( Q ) for all PDBs where D | =  X  | = D
We show that query completeness for this new semantics can be checked in a manner analogous to the one for certain answer semantics in Theorem 3. The proof is largely similar.
 Lemma 4 Let Q (  X  x )  X  L be a conjunctive query and C be a set of table completeness statements. Then Now, suppose that the conjunctive query Q is minimal (cf. [4]). Then Q returns a result over T C ( L ) only if each atom from L has an indicator in T C ( L ). The next lemma shows that it does not matter whether the nulls in T C ( L ) are interpreted as SQL or as Codd nulls. Lemma 5 Let C be a set of TC statements and Q (  X  x )  X  L be a minimal conjunctive query. Then
Combining Theorem 3 and Lemmas 4 and 5 we conclude that for minimal conjunctive queries that are known to be complete, it does not matter whether one evaluates them under certain answer or under SQL semantics.
 Theorem 6 Let D = ( D i , D a ) be an incomplete database with in-complete facts, let C be a set of TC statements, and let Q (  X  x )  X  L be a minimal conjunctive query. If C| = inc Compl s ( Q ) and if D|
It follows that for complete queries we also get a complete query result when evaluating them over standard SQL databases.

Example 7. Consider again the query Q art_students from Example 3, where Q art_students ( n )  X  student ( n , c , h ) , class ( c , t , TC statements C 1 and C 2 from Example 6 that entailed query com-pleteness over PDBs with incomplete facts. Since Q art_students no self-joins it is clearly minimal, and hence over the available database of any PDB that satisfies C 1 and C 2 we can evaluate it under set semantics and will get a complete query result.
We now move to PDBs with restricted facts. Recall that in this Accordingly, a PDB with restricted facts is a pair ( D i , D a ) where both the ideal and the available database may contain nulls, and where the available is a subset of the ideal database ( D a  X  D i ).
Again, we suppose that we are given a set of TC statements C and a conjunctive query Q (  X  x )  X  L , which is to be evaluated under set semantics. Similar to the case of incomplete facts, we say that C entails Compl s ( Q ) over PDBs with restricted facts , written i ff for every such PDB D we have that
We will derive a characterization of (9) that can be e ff checked. We reuse the function T C defined in Equation (8). Proposition 7 Let D be an instance that may contain nulls and let D 1. D 1 is a PDB with restricted facts; 2. D 1 | = C .
 Moreover, if D 0 is another instance such that ( D  X  D 0 , with restricted facts that satisfies C , then D 0 dominates T
In contrast to databases with incomplete facts, nulls can now ap-pear in the output of queries over the ideal database, and therefore must not be ignored in query answers over the available database. Recent results in [11] imply that for queries over databases with restricted facts, evaluation according to SQL X  X  semantics of nulls returns correct results.

The characterization of completeness entailment is di ff erent now because Q  X  X  body L is no more a prototypical instance for Q to retrieve an answer  X  x . Since the ideal database may now contain nulls, we must consider the case that variables in L are mapped to  X  when Q is evaluated over D i .

We first present a result for boolean queries, that is, for queries where the tuple of distinguished variables  X  x is empty, and for linear (or self-join free) queries, that is, queries where no relation symbol occurs more than once.

A variable y in a query Q (  X  x )  X  L is a singleton variable, if it appears only once in L . Recall that only singleton variables can be mapped to  X  when evaluating Q under SQL semantics. Let L  X   X  x be obtained from L and  X  x , respectively, by replacing all singleton variables with  X  .
 Theorem 8 Let Q (  X  x )  X  L be a boolean or linear conjunctive query and C be a set of table completeness statements. Then
The theorem reduces completeness reasoning in the cases above to conjunctive query evaluation. We conclude that deciding TC-QC entailment wrt databases with restricted facts is in PTIME for linear and NP-complete for arbitrary boolean conjunctive queries.
For general conjunctive queries, which may have distinguished variables, evaluating Q over a single test database obtained from L is not enough. We can show, however, that it is su consider all cases where singleton variables in L are either null or not. A null version of L is a condition obtained from L by replacing some singleton variables with  X  . We represent null versions of L as instantiations  X  L , where  X  is a substitution that replaces some singleton variables of L with  X  and is the identity otherwise. Theorem 9 Let Q (  X  x )  X  L be a conjunctive query. Then the fol-lowing are equivalent:
The theorem says that instead of just one prototypical case, we have to consider several now, because query evaluation for databases with nulls is more complicated: while the introduction of nulls makes the satisfaction of TC statements and the query evaluation more di ffi cult, it also creates more possibilities to retrieve null as a result (see [10]).

The above characterisation can be checked by a  X  P 2 algorithm: in order to verify that containment does not hold, it su ffi one null version  X  L and then show that  X   X  x is not in Q ( T which is an NP task.
So far we have assumed that nulls have one of two possible meanings, standing for unknown or for non-existing values. In this section we discuss completeness reasoning in the presence of one syntactic null value, which can have three possible meanings, the previous two plus indeterminacy as to which of those two applies. This is the typical usage of nulls in SQL.

We model PDBs for this case as pairs D = ( D i , D a ), where both instances, D i , D a , may contain  X  and each tuple in D a is dominated by a tuple in D i . We assume that queries are evaluated as in SQL, since we cannot tell which nulls are Codd-nulls and which not. For a query Q and  X  X  X { s , b } we define
Di ff erent from the case where nulls stand for unknown values, we may not drop nulls in the query result over the available database, because they might carry information (absence of a value).
We observe that without further restrictions on the PDBs, for many queries there is no way to conclude query completeness from table completeness.
 Proposition 10 There exists a PDB D with ambiguous nulls and a query Q, such that D satisfies any set of TC statements but D does not satisfy Compl s ( Q ) .
 P roof . Let D be with D i = { student (Mary , 2a , Chester) } and D a = { student (Mary , 2a , Chester) , student (Mary ,  X  , Chester) } . Clearly, D satisfies all possible TC statements, because D a  X  D i . But query Q classes ( c )  X  student ( n , c , h ) is not complete over D , because Q s ( D i ) = { (2 a ) } while Q s ( D a ) = { (2 a ) , (  X  ) } .
Inspecting D in the proof above more closely, we observe that the two facts in D a are dominated by the same fact in the ideal database. Knowing that, we can consider the second fact in D a as redundant: it does not add new information about Mary. This dupli-cate information leads to the odd behaviour of D wrt completeness: while all information from the ideal database is also in the available database, Q ( D a ) contains an additional fact with a null.
Sometimes, such duplicates occur naturally, e.g., when data from di ff erent sources is integrated. In other scenarios, however, redun-dancies are unlikely because objects are identified by keys, and only non-key attributes may be unknown or non-applicable.
In a school database, it can happen that address or birth place of a student are unknown. In contrast, it is hard to imagine that one may want to store a fact student (  X  ,  X  , Chester), saying that there is a student with unknown name and class living in Chester. Keys alone, however, are still not su ffi cient:
Example 8. Suppose we are given a partial database with D { student (Mary , 2a , Chester) , student (Paul , 2a , Hampton) } and D a = { student (Mary , 2a , Chester) , student ( Paul ,  X  , Hampton) } . Observe that there are no redundant tuples in D a . The TC statement D that over a PDB satisfying this statement the query Q fined above, is complete, as it is the case for PDBs with incomplete facts or with restricted facts. However, query evaluation returns
The problem with ambiguous nulls is that while all information needed for computing a query result may be present in the available database, it is not clear how to treat a null in the query answer. If it represents an unknown value, we can discard it because the value will still be there explicitly. But if it represents that no value exists, it should also show up in the query result.

Therefore, we conclude that one should disambiguate the mean-ing of null values. In the next section we propose how to do this in an SQL database.
Nulls in an available database can express three di ff erent state-ments about a value: absence, presence with the concrete value be-ing unknown, and indeterminacy which of the two applies. As seen in Section 5, this ambiguity makes reasoning impossible. To ex-plicitly distinguish between the three meanings of nulls in an SQL database, we present an approach that adds an auxiliary boolean attribute to each attribute that possibly has nulls as values. Example 9. Consider relation student ( name , code , hometown ). Imagine a student John for whom the attribute code is null because John attends a class, but the information was not entered into the database yet. Imagine another student Mary for whom code is null because Mary is an external student and does not attend any class. Imagine a third student Paul for whom code is null because it is unknown whether or not he attends a class. We mark the di meanings of nulls by symbols  X  uk (unknown but existing value),  X  n / a (not applicable value) and  X   X  (indeterminacy), but remark that in practice, in an SQL database, all three cases would be expressed using syntactically identical null values.

We can distinguish them, however, if we add a boolean attribute hasCode . For John, the value of hasCode would be true , express-ing that the tuple for John has a code value, which happens to be unknown, indicated by the  X  for code . For Mary, code would have the value false , expressing that the attribute code is not applicable. For Paul, the hasCode attribute itself would be  X  , expressing that nothing is known about the actual value. Table 3 shows a student instance with explicit types of null, on the left using three nulls, on the right with a single null and the auxiliary attribute.
In general, for an attribute attr where we want to disambiguate null values, we introduce a boolean attribute hasAttr . We refer to hasAttr as the sign of attr , because it signals whether a value exists for the attribute, no value exists, or whether this is unknown.
Note that if hasAttr is false or  X  , then attr must be  X  . This can be enforced by an SQL check constraint.

As seen earlier, in general SQL semantics does not fully cap-ture the semantics of unknown nulls as it may miss some certain answers. We will show in Theorem 12, that our encoding can be exploited to compute answer sets for complete queries by joining attributes with nulls according to SQL semantics and then using the signs to drop tuples with unknown and indeterminate nulls.
In the previous section we showed how to implement a syntac-tic distinction of three di ff erent meanings of null values in SQL databases. In this section we discuss how to reason with these three di ff erent nulls.

An instance D with the three di ff erent kinds of nulls represents an infinite set of instances D 0 that can be obtained from D by (i) re-placing all occurrences of  X  uk with concrete values and (ii) replac-ing all occurrences of  X   X  with concrete values or with  X 
As usual, the set of certain answers of a query Q over D consists of the tuples that are returned by Q over all such D 0 and is denoted as Q cert ( D ).

It is easy to see that a tuple  X  d is in Q cert ( D ) i ff  X  d are  X  n / a and there exists an assignment  X  such that (i) (ii)  X  L  X  D , (iii)  X  does not map join variables to  X  n / a (iv) no two occurrences of a join variable are mapped to di occurences of  X  uk . Intuitively, this means that we have to treat  X  as Codd null and the other nulls as SQL nulls.
We say that a partial database D = ( D i , D a ) contains partial facts if (i) the facts in D i may contain the null  X  n / a , (ii) the facts in D a may contain all three kinds of nulls, and (iii) each fact R (  X  t )  X  D a is dominated by a fact R (  X  t 0 ) in D i in the sense that for any position p
We then say that a query is complete over a database D = ( D i , D a ) with partial facts, if Q ( D i ) = Q cert ( D a ), and write D|
Satisfaction of TC-statements is not a ff ected by these changes, as D i contains only nulls  X  n / a , which indicate restricted facts that can be treated according to SQL semantics.

Example 10. Consider the available database D a that contains the three facts class (1a ,  X  uk , 0 arts 0 ), class (2b ,  X  that asks for all classes whose form teacher is also form teacher of an arts class, written as Q ( c 1 )  X  class ( c 1 , t , p
Then similar to before, the only tuple in Q cert ( D a ) is (1 a ), be-cause since the teacher of that class is unknown but existing, it holds in any complete database that the class 1a has a teacher that also teaches an arts class (1a again). The tuples 2b and 3c do not show up in the result, because the former has no form teacher at all (  X  n / a ), while the latter may or may not have a form teacher.
A first result is that TC-QC entailment over PDBs with partial facts is equivalent to entailment over PDBs with restricted facts: Theorem 11 Let Q be a conjunctive query and C be a set of TC statements. Then
P roof . (Sketch)  X   X   X  Trivial, because PDBs with restricted facts are PDBs with partial facts that contain only the null value  X   X   X   X  Assume, C6| = 3  X  Compl s ( Q ). Then there is a PDB with par-tial facts D such that D | = C , but D 6| = 3  X  Compl s ( a PDB D 0 with restricted facts that also satisfies C , but does not of D a where  X  uk and  X   X  are replaced by  X  n / a , and let D i
The additional facts in D i 0 do not lead to violations of TC state-ments, since they are dominated by facts in D i , thus, D ever, Q ( D a 0 )  X  Q ( D a ), since changing nulls to  X  evaluation more restrictive, and Q ( D i )  X  Q ( D i 0 ) due to monotonic-ity. Hence, Q ( D a 0 ) $ Q ( D i 0 ), that is, D 0 6| = res
Also, we define the query evaluation Q ( D )  X  as Q ( D ) without all tuples containing  X  uk or  X   X  .

Similar to a database with incomplete facts only, it holds that query answering for minimal queries that are complete does not need to take into account certain answer semantics but can safely evaluate the query using standard SQL semantics: Theorem 12 Let D = ( D i , D a ) be an incomplete database with partial facts, Q be a minimal conjunctive query and C be a set of table completeness statements. If C | = 3  X  Compl s ( Q ) and D |
Bag semantics is the default semantics of SQL queries, while set semantics is enabled with the DISTINCT keyword. As the next example shows, for relations without keys reasoning about query completeness under bag semantics may not be meaningful.
 Example 11. Consider the partial database with incomplete facts D = ( D i , D a ), where D i = { student (Mary , 2a , Chester) } and D a = { student (Mary , 2a , Chester) , student (Mary ,  X  , Chester) } . Since it is a priori not possible to distinguish whether the fact con-taining  X  is redundant, the boolean query Q ()  X  student ( n , c , h ) that is just counting the number of students is not complete, because the redundant tuple in the available database leads to a miscount.
As tuples with nulls representing unknown values can introduce redundancies, we require that keys are declared for PDBs with in-complete facts, with one ambiguous null or with partial facts. Only for partial databases with restricted facts keys are not necessary, because there the available database is always a subset of the ideal one and hence no redundancies can appear.

Formally, for a relation R with arity n , a key is a subset of the attribute positions { 1 ,..., n } . Wlog, we assume that the key at-tributes are the first k ( R ) attributes, where k is a function from re-lations to natural numbers. An instance D satisfies the key of a relation R , if (i) no nulls appear in the key positions of facts and (ii) no two facts have the same key values, that is, if for all R (  X  t ), R (  X  t 0 )  X  D it holds that  X  t [1 .. k ( R )] =  X  t 0 [1 .. k ( R )] implies  X  t
Table completeness statements that do not talk about all key at-tributes of a key are not useful for deciding the entailment of query completeness under bag semantics, because, intuitively, they can-not assure that the right multiplicity of information is in the avail-able database. We say that a TC statement Compl ( R (  X  x ); P ; G ) is key-preserving , if { 1 .. k ( R ) }  X  P . In the following, we only con-sider TC statements that are key-preserving.

We develop a characterization for TC-QC entailment that is sim-ilar to the one for set semantics. However now, we need to ensure that over a prototypical database not only query answers but assign-ments are preserved, because a query answer tuple can be produced by di ff erent assignments. So if an assignment is missing, the mul-tiplicity of a tuple in the result is incorrect. As a consequence, a set of TC statements may entail completeness of a query Q for set semantics, but not for bag semantics.

Example 12. The relation lnCourse(student,language) stores the language courses that students take. Consider the query Q nr_for_french ( n )  X  lnCourse ( n , l ) , lnCourse ( n , counts for each student that attends French, how many language courses he attends. Under set semantics, Q nr_for_french if D a contains all facts about French courses, which is expressed completeness for set semantics, we apply T C to the query body L , which results in T C ( L ) = { lnCourse ( n , 0 french 0 ) } , since the first body atom is not constrained by C french . Evaluating Q nr_for_french T ( L ) returns ( n ), which shows set completeness.

But this does not entail that Q nr_for_french is complete under bag se-mantics. The PDB ( L , T C ( L ) is a counterexample: it satisfies C and we can evaluate Q nr _ f or _ f rench over L two times, while over T just once. If Paul takes French and Spanish according to D i , it is clearly not su ffi cient to only have the fact about French in D a when we want to count how many courses Paul takes! We therefore modify the test criterion in Theorem 8 in two ways.
For a query Q (  X  x )  X  L , the tuple  X  w of crucial variables consists of the variables that are in  X  x or occur in key positions in L . For any two assignments  X  and  X  that satisfy L over a database D , we have that  X  and  X  are identical if they agree on  X  w . Thus, the crucial vari-ables determine both, the answers of Q and the multiplicities with which they occur. We associate to Q the query  X  Q (  X  w )  X  L that has the same body as Q , but outputs all crucial variables. Consequently, Q is complete under set semantics if and only if  X  Q is complete un-der set semantics. The first modification of the criterion will consist in testing  X  Q instead of Q .

A direct implication of the first modification is that we need not consider several null versions  X  L of L as in Theorem 9. The reason for doing so was that a null  X  =  X  x in the ouput of Q over  X  L could have its origin in an atom  X  A in  X  L such that x does not occur in A , but another variable, say y is instantiated to  X  . Now, the query passes the test for set completeness only if an atom in L is mapped to an atom with the same key values. Thus, a variable x cannot be bound to a null  X  =  X  y . Hence it su ffi ces to consider just the one version L  X  where all singleton variables are mapped to null. By the same mapping,  X  w  X  is obtained from  X  w .

The second modification is due to the possibility that several TC statements constrain one fact in D i und thus T C generates several indicators. Since we assumed TC statements to be key-preserving, these indicators all agree on their key positions. However, in some non-key position one indicator may have a null while another one has a non-null value. So, T C ( L  X  ) may not satisfy the keys. This can be repaired by  X  X hasing X  T C ( L  X  ) (cf. [1]).

The function chase takes a database D with nulls as input and merges any two R -facts A 0 , A 00 that have the same key values into one R -fact A as follows: the value of A at position p , denoted A [ p ] preserving and D satisfies the keys, then chase ( T C ( D )) also satisfies the keys. Intuitively, chase condenses information by applying the key constraints. Obviously, chase runs in polynomial time.
We now are ready for our characterization of completeness en-tailment under bag semantics, which is similar, but slightly more complicated than the one in Theorem 8.
 Theorem 13 Let Q (  X  x )  X  L be a conjunctive query and C be a set of key-preserving TC statements. Then
Since the criterion holds for incomplete databases with three dif-ferent nulls, it holds also for the special cases where only one type of null values is present (restricted or incomplete facts).
Notably, it also holds for partial databases with one ambiguous null, because when keys are present and TC statements guarantee that all mappings are preserved, no additional nulls can show up in the query result.
We now discuss the complexity of inferring query completeness from table completeness. We define TC -QC ? as the problem of deciding whether under ? -semantic for all partial databases D it holds that D | = C implies that D | = Compl ( Q ). We will find that for all cases considered in the paper, the complexity of reasoning is between NP and  X  P 2 : Theorem 14 (Complexity Bounds) 1. TC -QC s inc is NP-complete; 2. TC -QC s res is NP-hard and in  X  P 2 ; 3. TC -QC s 3  X  is NP-hard and in  X  P 2 ; 4. TC -QC b 3  X  is NP-complete.

P roof . NP-hardness in all four cases can be shown by a re-duction of containment of Boolean conjunctive queries, which is known to be NP-complete [4]. We sketch the reduction for (1) X (3), the one for (4) being similar. Suppose we want to check whether Q ()  X  L is contained in Q 0 ()  X  L 0 . Let P be a new unary re-lation. Consider the query Q 0 ()  X  P ( a ) , L and the TC statement incomplete facts NP-complete NP-complete C ment that R is complete for every relation R in L . Then it fol-lows from Theorems 3, 8 and 11 that C | =  X  Compl s (  X   X  { inc , res , 3  X } , if and only if P ( a )  X  T C ( L ), P ( a )  X  T and P ( a )  X  T C ( L  X  ), respectively. The latter three conditions hold i ff
P ( a ) = T C 0 ( P ( a ) , L ), which holds i ff Q is contained in Q
Problem 1 is in NP, because according to Theorem 3 to show that the entailment holds, it su ffi ces to construct T C assignments that satisfy su ffi ciently many TC statements in C over L , and to guess an assignment that satisfies Q over T C ( L ) such that the tuple  X  x is returned.

Problem 2 is in  X  P 2 , because according to the characterization in Theorem 9, to show that entailment does not hold, it su guess one null version  X  L of the body of Q and show that  X   X  x is not in Q ( chase ( T C (  X  L ))), which is an NP task.
 Problem 3 is in  X  P 2 for the same reason.

Problem 4 is in NP, because we do not consider di ff erent nullver-sions of L but only one. The remaining argument is the same as for Problem 1, since one needs to show that  X  x  X  is in T C an NP task.
 Reasoning becomes easier for special cases of queries: Theorem 15 (Special Cases) Let  X  X  X { inc , res , 3  X } . Then 1. TC -QC s  X  and TC -QC b  X  are in PTIME for linear queries; 2. TC -QC s  X  is NP-complete for boolean queries.

P roof . Regarding Claim 1, the most critial case is  X  = linear queries under bag semantics, observe that the criterion in Theorem 13 can be checked in polynomial time. First, there is only one choice to map an atom in a query Q C to an atom in L  X  with the same relation). Second, chase ( T C ( L  X  )) can be computed in polynomial time. Lastly, the evaluation of  X  Q over the chase result is in PTIME, because an atom in  X  Q can be mapped in only one way.
Note that for linear queries under set semantics, we only need to consider one null version L  X  because a binding for an output term can only come from one position.

The lower bounds of Claim 2 follow from Theorem 14, the upper bounds from Theorem 14 for inc, and from Theorems 8 and 11 for res and 3  X  , since evaluation of conjunctive queries is in NP.
In Table 4 we summarize our complexity results for TC-QC en-tailment over databases with nulls. Notably, if we have keys then under bag semantics the complexity does not increase with respect to databases without null values. For queries under set semantics, it remains open whether the complexity of reasoning increases from NP to  X  P 2 for databases with restricted facts and with 3 null values.
Since the introduction of null values in relational databases [5], there has been a long debate about their semantics and the cor-rect implementation. In particular, the implementation of nulls in SQL has led to wide criticism and numerous proposals for improve-ment (for a survey, see [19]). Much work has been done on the querying of incomplete databases with missing but existing val-ues [2, 17], while only recently, Franconi and Tessaris showed that SQL correctly implements null values that stand for inapplicable attributes [11]. It was observed early on that di ff erent syntactic null values in databases would allow to capture more information [6], but these ideas did not reach application.

Query completeness over incomplete databases was first studied by Motro [14]. He investigated query completeness as an aspect of query integrity, and introduced the notion of partially incomplete and incorrect databases as databases that can both miss facts that hold in the real world and contain facts that do not hold there, but do not contain null values. He described partial completeness in terms of query completeness (QC) statements under set semantics. To infer completeness of a query from a set of queries known to be complete, he would search for a conjunctive rewriting of the given query in terms of the complete queries. This solution is correct, but not complete, as later results on query determinacy show [18].
Halevy [12] suggested local completeness statements, which we call table completeness (TC) statements, as an alternate formalism for asserting partial completeness of an incomplete database with-out nulls. The main problem he addressed was how to derive query completeness from table completeness (TC-QC reasoning). How-ever, his approach led only to a decision procedure applicable to trivial cases.

Fan and Geerts [8] discussed the problem of query completeness in the presence of master data. Their work is not directly compa-rable to the one presented here because in addition to the di setting it always considers a database instance. In follow-up work, they considered incomplete data also in the form of missing, but existing values [9], which they represented by c-tables [13]. Recently, Razniewski and Nutt picked up Levy X  X  problem of TC-QC entailment over databases that can miss records [16]. They showed that TC-QC entailment is decidable if conjunctive queries with comparisons are used for formulating TC and QC statements and analysed the complexity of the problem in detail for queries under bag semantics, set semantics and aggregate queries, finding complexities ranging from PTIME to  X  P 2 .
Although null values are an important aspect of incompleteness in relational databases, they were not supported by formalisms for reasoning about data completeness. We generalized partially com-plete databases, table completeness and query completeness state-ments as in [12, 16] so that one can describe incompleteness in the form of both missing records and missing values.

Our approach addresses two challenges. First, if a table contains nulls, it may be that not entire rows, but only the columns of some rows are complete. To describe such a situation, we refined ta-ble completeness statements so that they can refer to projections of parts of tables. Second, null values as used in practice are ambigu-ous (unknown, not applicable, indeterminate). To resolve such am-biguities, we proposed an encoding for SQL databases that makes di ff ent kinds of nulls explicit. We then developed techniques to in-fer the completeness of conjunctive queries from such refined state-ments for di ff erent semantics of nulls and assessed the complexity of the reasoning task.

While SQL X  X  query evaluation is generally not correct for nulls that represent missing values, we showed that for a minimal com-plete query correct query answers can be calculated from the SQL query result by dropping tuples with unknown and indeterminate nulls.

In this work, we focussed on conjunctive queries without built-in predicates like inequalities or disequalities. Treatment of built-in is orthogonal to the one of nulls, so that our results can be extended to them, using the techniques in [16]. Similarly, as aggregate queries are computed on top of non-aggregate queries, our results can also be extended in this direction.
 This work was partially supported by the ESF project 2-299-2010 "SIS -Wir verbinden Menschen", and the European commission FP7 project ICT-2009.4.2 "TERENCE". [1] Serge Abiteboul, Richard Hull, and Victor Vianu.
 [2] Serge Abiteboul, Paris C. Kanellakis, and G X sta Grahne. On [3] Carlo Batini and Monica Scannapieco. Data Quality: [4] Ashok K. Chandra and Philip M. Merlin. Optimal [5] Edgar F. Codd. Understanding relations (installment #7). [6] Edgar F. Codd. Missing information (applicable and [7] Ronald Fagin, Phokion Kolaitis, Ren X e Miller, and Lucian [8] Wenfei Fan and Floris Geerts. Relative information [9] Wenfei Fan and Floris Geerts. Capturing missing tuples and [10] Carles Farr X , Werner Nutt, Erneste Tenient, and Toni Urp X . [11] Enrico Franconi and Sergio Tessaris. On the logic of SQL [12] Alon Y. Halevy. Obtaining complete answers from [13] Tomasz Imieli  X  nski and Witold Lipski, Jr. Incomplete [14] Amihai Motro. Integrity = Validity + Completeness. ACM [15] Felix Naumann, Johann C. Freytag, and Ulf Leser.
 [16] Simon Razniewski and Werner Nutt. Completeness of [17] Raymond Reiter. A sound and sometimes complete query [18] Luc Segoufin and Victor Vianu. Views and queries: [19] Ron van der Meyden. Logical approaches to incomplete
