 It is one of the important tasks for data mining to discover frequent patterns from time-related data. For such a task, Mannila et al. [7] have introduced the episode mining to discover frequent episodes in an event sequence . Here, the episode is formulated as an acyclic labeled digraphs in which labels correspond to events and edges represent a temporal pr ecedent-subsequent relation in an event sequence. Then, the episode is a richer re presentation of temporal relationship than a subsequence , which represents just a linearly ordered relation in sequential pattern mining ( cf. , [3,9]). Furthermore, since the frequency of the episode is formulated by a window that is a subsequence of an event sequence under a fixed time span, the episode mining is more appropriate than the sequential pattern mining when considering the time span.

Mannila et al. [7] have designed an algorithm to construct episodes from a parallel episode as a set of events and a serial episode as a sequence of events. Note that their algorithm is general but inefficient. Then, the episode mining has been developed by introducing the specific forms of episodes for every target area together with efficien t algorithms [5,6,8].

As such specific forms of episodes, Katoh et al. have introduced diamond episodes [6] and elliptic episodes [5]. In Fig. 1, we show examples of an input event sequence, a serial episode, and a diamond episode over an alphabet. Both episodes have the special event types, a source and a sink . Then, by setting the source and the sink to the specified event types, we can find frequent episodes with the source as a premise and the sink as a consequence. In particular, from bacterial culture data [5,6], they have succeeded to find frequent diamond and elliptic episodes concerned with the replacement of bacteria and the changes for drug resistance , which are valuable from the medical viewpoint. Here, the source and the sink are set to the bacteria and another bacteria for the former episodes, and the sensitivity of antibiotic and the resistant of the same antibiotic for the latter episodes.
 Note that the algorithms designed by Katoh et al. [5,6] are so-called level-wise ; The algorithms first find the information for the occurrences of serial episodes in an event sequence, by scanning it just once. After regarding the serial episodes as itemsets, the algorithms then construct the frequent episodes by using the frequent itemset mining algorithm AprioriTid [1].

While the level-wise algorithms are sufficient to find frequent episodes ef-ficiently in practice (in particular, appropriate to apply the bacterial culture data), it is difficult to give theoretical guarantee of the efficiency to the level-wise algorithms from the view of enumerat ion. In this paper, as a space-efficient episode mining algorithm, we newly design the episode-growth algorithm, called PolyFreqDmd , to enumerate frequent diamond episodes.

The algorithm PolyFreqDmd adopts the depth-first search, instead of the level-wise search. Then, the algorithm finds all of the frequent diamond episodes in an input sequence S without duplication in O ( |  X  | 2 n ) time per an episode and in O ( |  X  | + n ) space, where  X  and n are an alphabet and the length of S , respec-tively. Hence, we can guarantee that the e pisode-growth algorithm enumerates frequent diamond episodes in polynomial delay and in polynomial space. Further, we presents some practical optimization techniques for reducing the running time and the required space of the algorithm PolyFreqDmd .

This paper is organized as follows. In Section 2, we introduce diamond episodes and other notions necessary to the later di scussion. In Section 3, we present the algorithm PolyFreqDmd and show its correctness and the time complexity. In Section 4, we give some experimental r esults from randomly generated event sequences to evaluate the practical perf ormance of the algorithms. In Section 5, we conclude this paper and discuss the future works. In this section, we prepare diamond episodes and the related notions necessary to later discussion. We denote the sets of all integers and all natural numbers by Z and N , respectively. For a set S , we denote the cardinality of S by | S | . Let  X  = { 1 ,...,m } ( m  X  1) be a finite alphabet with the total order  X  over N .Eachelement e  X   X  is called an event 1 .An input event sequence ( input sequence , for short) S on  X  is a finite sequence S 1 ,...,S n  X  (2  X  )  X  of events ( n  X  0), where S i  X   X  is called the i -th event set for every 1  X  i  X  n . Then, we call n the length of S and denote it by |S| , and define the total size of S by ||S|| = n
For a fixed input sequence S 1 ,...,S n  X  (2  X  )  X  ,a position or an index on S is any integer, where we allow an index out of S by defining that S i =  X  if i is either i  X  0or i&gt;n .Let1  X  k  X  n be a fixed positive integer, called the window width . For any index  X  k +1  X  i  X  n , we define the k -window W S ,k i at position i in S by the contiguous subsequence of length k of S as follows: W S ,k i = w S ( i, k )=
S windows in S by W S ,k .Wesimplywrite W i and W instead of W S ,k i and W S ,k by omitting the scripts S and k , when they are clear from t he context. Moreover, we may identify the set of all k -windows by the set { X  k +1  X  i  X  n | i  X  W S ,k } X  Z of their indices.
 A serial episode over  X  of length m  X  0(or, m -serial episode ) is a sequence P = a 1 ,...,a m  X   X   X  of events.
 Definition 1. A diamond episode over  X  is either an event a  X   X  (a 1-serial episode) or a triple P = a, E, b  X   X   X  2  X   X   X  (called a proper diamond episode), where a, b  X   X  are events and E  X   X  is a subset of  X  . Then, we call a , b ,and E the source ,the sink ,andthe body of P , respectively. For the body E ,wedenote the maximum element in E (w.r.t.  X  )bymax( E ).
 To emphasize the chronological dependencies of events, we often write ( a 1  X   X  X  X   X  a episode a, E, b , respectively. Also we denote the classes of m -serial episodes, proper diamond episodes and diamond episodes (over  X  )by SE m , PDE and DE , respectively. Since any ( a  X  b )  X  X E equivalent to ( a  X  X  X   X  b )and( a  X  X  b }  X  c )  X  X DE , respectively, we see that SE Example 1. In Figure 1, we show examples of an event sequence S =( ABC, AB , A, AB, ABC, AB )oflength n =6,aserialepisode P = A  X  B  X  C and a diamond episode Q = A  X  X  A, B }  X  C on an alphabet of events  X  = { A, B, C } , where the body { A, C } is written as a sequence AC .
 Next, we introduce the concept of occurre nces of episodes in a window. Then, we give the formal definition of the occurre nces of episodes, which is consistent with the original definition by [7]. Let P = e 1  X  X  X  X   X  e n be a serial episode, Q = e s  X  X  e 1 ,...,e m }  X  e t a diamond episode and W = S 1  X  X  X  S k  X  W S ,k a window, respectively. A serial episode P = e 1  X  X  X  X   X  e m occurs in an window W = S 1  X  X  X  S k  X  W S ,k , denoted by P W , iff there exists some mapping e  X  S Definition 2 (occurrence for a diamond episode). A diamond episode P = e  X  X  e noted by D W , iff there exists some mapping h : { s , t , 1 ,...,m } X  X  1 ,...,k } e  X  S For a window W andanevent e  X   X  , we denote the first and the last position in W at which e occurs by st ( e, W )and et ( e, W ), respectively. The matching algorithm for diamond episodes will be studied in Section 3.

For an episode P , we define the occurrence list for P in S by W S ,k ( P )= { X  k +1  X  i  X  n | P W episode P occurs in S at position i or at the i -th window.
 Example 2. Consider an input event sequence S =( ABC, AB , A, AB, ABC, AB ) in Figure 1. Then, if the window width k is 4, has nine 4-windows from W  X  2 to W 6 for all  X  2  X  i  X  6, i.e., W S , 5 = { W i | X  2  X  i  X  6 } . Among them, the window list for a diamond episode P = A  X  AB  X  C is W ( P )= { W 2 ,W 3 } . Lemma 1. Let P be a partial diamond episode ( e s  X  E  X  e t ) and W a window in W S ,k .Then, P W iff for every e  X  E , there exists some position p for e such that e  X  S p and st ( e s ,W ) &lt;p&lt;et ( e t ,W ) hold.
 Proof. (Only if-direction) If P W then there exists some embedding h from P (If-direction) Suppose that for every e  X  E , there exists a position p e for e with h ( e t )= et ( e t ,W ), and h ( e )= p e for every e  X  E . Then, the claim holds. Lemma 1 implies the following two important corollaries.
 Corollary 1 (serial construc tion of diamond episodes). Let P be a partial diamond episode ( e s  X  E  X  e t )( m  X  0) and W a window in W S ,k .Then, P W iff ( e s  X  e  X  e s ) W for every e  X  E .
 Corollary 2 (anti-monotonicity for diamond episodes). Let a, b  X   X  be events, and E, F  X   X  be event sets. For every frequency threshold  X  and window width k  X  1 ,if E  X  F ,then ( a  X  E  X  b )  X  X  S ,k, X  implies ( a  X  F  X  b )  X  X  S ,k, X  . Let S be an input sequence, k  X  1awindowwidthand P a diamond episode a  X  E  X  b . The (absolute) frequency of P in S is defined by the number of k -1  X   X   X | W S that the frequency is an absolute value, while the support is a relative value. We denote by F S ,k, X  be the set of all  X  -frequent diamond episodes occurring in S . Definition 3. Frequent Diamond Episode Mining Problem :Givenan input sequence S , a window width k  X  1, and a minimum frequency threshold  X   X  1, the task is to find all  X  -frequent diamond episodes P  X  X  S in S with window width k without duplicates.
 In the remainder of this paper, we design an algorithm for efficiently solving the frequent diamond episode mining problem in the sense of enumeration algo-rithms [2,4]. Let N be the total input size and M the number of all solutions. An enumeration algorithm A is of output-polynomial time ,if A finds all solutions S  X  X  in total polynomial time both in N and M .Also A is of polynomial delay , if the delay , which is the maximum computation time between two consecutive outputs, is bounded by a polynomial in N alone. It is obvious that if A is of polynomial delay, then so is of output-polynomial. In this section, we present a polynomial-delay and polynomial-space algorithm PolyFreqDmd for mining all frequent diamond episodes in a given input se-quence. Let S =( S 1 ,...,S n )  X  (2  X  )  X  be an input sequence of length n and total input size N = ||S|| , k  X  1 be the window width, and  X   X  1 be the minimum frequency threshold.

In Fig. 2, we show an outline of our polynomial-delay and polynomial-space algorithm PolyFreqDmd and its subprocedure FreqDmdRec for mining fre-quent diamond episodes of DE appearing in an input sequence S .

The algorithm PolyFreqDmd is a backtrack algorithm that searches the whole search space from general to sp ecific using depth-first search over the class FDE of frequent diamond episodes. For every pair of events ( a, b )  X   X  , PolyFreqDmd starts the depth-first search by calling the recursive procedure FreqDmdRec with the smallest (complete) diamond episode D ab =( a  X  X  X   X  b )  X  X E and with its occurrence window list W ( D
By Corollary 2, in each iteration of FreqDmdRec , the algorithm tests if the current candidate D =( a  X  E  X  b )isfrequent.Ifso, FreqDmdRec output D , and furthermore, for every event e  X   X  such that e&gt; max( E ), FreqDmdRec grows diamond episode D by adding the new event e to the body E .Otherwise, FreqDmdRec prunes the search below D and backtrack to its parent. We call this process the tail expansion for diamond episodes. For episodes P, Q ,if Q is generated from P by adding new event e as above, then we say that P is a parent of Q ,or Q is a child of P .
 Lemma 2. For any the window width k&gt; 0 and any minimum support  X  ,the algorithm PolyFreqDmd enumerates all and only frequent diamond episodes from S without duplicates.
 Proof. Suppose that Q =( a  X  E  X  X  e }  X  b )  X  X E is a child of some P = ( a  X  E  X  b )  X  X E obtained by the tail expansion such that e&gt; max( E ). From Corollary 2, we see that any frequent Q can be obtained by expanding some frequent parent P . Furthermore, since e&gt; max( E ), the parent P is unique for each Q . This means that the parent-child relationship forms a spanning tree T for all frequent diamond episodes in DE .Since FreqDmdRec makes the DFS on T by backtracking, the result immediately follows.
 In the recursive procedure FreqDmdRec in Fig. 2, the procedure newly create a child episode C =( a  X  E  X  X  e }  X  b ) from the parent D =( a  X  E  X  b ) by tail expansion with e  X   X  at Line 4. Then, at Line 5, it computes the new occurrence window list U = W S ,k ( C )for C in S . To compute the new list U ,we can use a native procedure that scans all k -windows in S one by one for checking occurrences of C .
 Lemma 3. There is an algorithm that computes the occurrence of a 3 -serial From Lemma 3, this naive algorithm requires O ( |  X  | kmn ) time, where k is the window width, m = || D || is the episode size, and n = |S| is the input length.
In Fig. 3, we show an improved algorithm UpdateDmdOcc that computes of m = || C || , with incrementally updating the old list W for the parent D . To see the validity of the improved algorithm, we require two properties, called the serial construction for DE showninCorollary1andthe downward closure property for DE shown in Lemma 4 below. Here, Lemma 4 is an extension of the downward closure property for itemsets [1].
 Lemma 4 (downward closure property). Let a, b  X   X  and E  X   X  .Then, for any input sequence S and any k  X  1 , the following statement holds: From Lemma 3 and Lemma 4, we see the correctness of the improved algorithm UpdateDmdOcc in Fig. 3, and have the next lemma. Note in the following that the computation time of UpdateDmdOcc does not depends on the size m = || C || of the child episode. If we implement the procedure FindSerialOcc by an algorithm of Lemma 3, we have the next result.
 Lemma 5. The algorithm UpdateDmdOcc in Fig. 3, given the old list W for the parent diamond episode D and a newly added event e , computes the new occurrence list U = W S ,k ( C ) for a new child C in O ( kN )= O ( |  X  | kn ) time, where n = |S| and N = ||S|| are the length and the total size of input S , respectively.
 Next, we present a faster algorithm for implementing the procedure FindSeri-alOcc for serial episodes than that of Lemma 3. In Fig. 4, we show the faster algorithm FastFindSerialOcc that computes W ( P ) for a 3-serial episode P = a  X  e  X  b by a single scan of an input sequence S from left to right. Lemma 6. The algorithm FastFindSerialOcc in Fig. 4 computes the occur-rence list of a 3 -serial episode P = a  X  b  X  c in an input sequence S of length n in O ( N )= O ( |  X  | n ) time regardless window width k ,where N = ||S|| . Corollary 3. Equipped with FastFindSerialOcc in Fig. 4, the modified al-gorithm UpdateDmdOcc computes U = W S ,k ( C ) for a child C  X  X E from the list W = W S ,k ( D ) for the parent D  X  X E and e  X   X  in O ( N )= O ( |  X  | n ) time, where n = |S| and N = ||S|| .
 During the execution of the algorithm FreqDmdRec , the subprocedure Find-SerialOcc (or FastFindSerialOcc ) for updating occurrence lists are called many times with the same arguments (( a  X  e  X  b ) ,k, S )( e  X   X  ). In the worst case, the number of calls may be |  X  | times in the search path s. Therefore, we can achieve the reduction of the number of calls for FindSerialOcc by memorizing the results of the computation in a hash table TABLE .
In Fig. 5, we show the codes for pract ical speed-up method using dynamic programming. Then, we modify PolyFreqDmd in Fig. 2 and UpdateDmdOcc in Fig. 3 as follows:  X  Before Line 5 of PolyFreqDmd ,insertLine2( initialization )inFig.5.  X  Replace the call of FindSerialOcc (( a  X  e  X  b ) ,k, S )in FreqDmdRec by This modification does not change the behavior of procedures PolyFreqDmd , FreqDmdRec and UpdateDmdOcc . Moreover, this makes the total number of the calls of FindSerialOcc to be bounded above by |  X  | 3 , while it uses O ( |  X  | n ) space in main memory. In Section 4 below, we know this technique will be useful in practice.

The running time of the algorithm FreqDmdRec in Fig. 2 mainly depends on the time T ( m, N ) for the subprocedure UpdateDmdOcc at Line 5 to compute the occurrence list U = W S ,k ( D ) of a candidate D  X  X E in S ,where m = || D || and N = ||S|| .

Unfortunately, if the height of the search tree is d =  X  ( m )=  X  ( |  X  | ), then the straightforward execution of the algorithm FastFindSerialOcc in Fig. 4 at least d recursive calls to come back to the root from the leaf of depth d .We can remove this factor d =  X  ( m ) by using a technique called alternating output in backtracking [10], which can be realized by replacing Line 2 and Line 8 in the algorithm FreqDmdRec with the corresponding lines (*) in the comments. Theorem 1. Let S be any input sequence of length n . For any window width k  X  1 and minimum frequency threshold  X   X  1 , the algorithm PolyFreqDmd in Fig. 2 finds all  X  -frequent diamond episodes D in DE occurring in S without N )= O ( |  X  | n ) space, where N = ||S|| and m = || D || is the maximum size of frequent episodes.
 Corollary 4. The frequent diamond episode mining problem is solvable in linear delay w.r.t. the total input size and in polynomial space.
 Finally, we can reduce the space complexity of the algorithm PolyFreqDmd by using the diffset technique introduced by Zaki [11] for itemset mining, which can be realized by replacing Line 5 and Line 6 of PolyFreqDmd with the code in Fig. 6. Hence, we can reduce the space complexity in Theorem 1 to O ( m + n )= O ( |  X  | + n ). In this section, we give the experimental results for the following combinations of the algorithms given in Section 3, by applying to the randomly generated event sequences S =( S 1 ,...,S n ) over an alphabet  X  = { 1 ,...,s } ,whereeach event set S i ( i =1 ,...,n ) is generated by a uniform distribution with letter probability 0  X  p  X  1 / |  X  | and stopping probability 1  X  p .
 All experiments were run in a PC (AMD Mobile Athlon64 Processor 3000+, 1.81GHz, 2.00GB memory) with 32-bit x86 instruction set. Without saying ex-plicitly, we assume that the length of the sequence is n = |S| = 2000, the alphabet size is s = |S| = 30, the probability of each event is p =0 . 1, the window width is k = 10, the minimum frequency threshold is  X  =0 . 4. Fig. 7 shows the running time and the number of solutions of the algorithms DF , DF-FFS and DF-DP for the input length n ,where s = 20, k =10and  X  =0 . 1 n . Then, we know that DF-FFS is twice as faster as DF and DF-DP is one hundred times as faster as DF . On the other hand, we cannot find any difference between DF-SWO , DF-DIFF and DF on this data set, although the first two techniques are useful in technical improvements. Moreover, the running time of these algorithms seems to be linear in the input size and thus expected to scales well on large datasets.

Fig. 8 shows the running time for the number of outputs, where n =10 , 000, k =30and  X  =0 . 3 n . Then, we see that the slope is almost constant and thus the delay is just determined by the input size as indicated by Theorem 1.
Fig. 9 shows the running time of DF-DP , our fastest algorithm, with varying the minimum support 0 . 5 n  X   X   X  5 . 0 n with the input size n = 2000. We see that the number of outputs, and thus, the running time increase as  X  decreases.
Figs. 10, 11 and 12 show the running time of the algorithms DF , DF-FFS and DF-DP with varying the window width 13  X  k  X  25,thesizeofalphabet 10  X |  X  | X  50 and the event probability 0 . 02  X  p  X  0 . 12, respectively. Then, we see that DF-DP outperforms other algorithms in most cases. The performance of DF-DP is stable in most datasets and the parameter settings. We also see that DF-FFS is from 20% to 60% faster than DF .

Overall, we conclude that the proposed algorithm FindDmdMain with the practical speed-up technique by dynamic programming in Fig. 5 ( DF-DP )isquite efficient on the data sets used these exper iments. The fast linear-time update by FastFindSerialOcc ( DF-FFS ) achieves twice speed-up. This paper studied the problem of frequent diamond episode mining, and pre-sented an efficient algorithm PolyFreqDmd that finds all frequent diamond episodes in an input sequence in polynomial delay and polynomial space in the input size. We have further studied several techniques for reducing the time and the space complexities of the algorithm.

Possible future problems are extension of PolyFreqDmd for general frag-ments of DAGs [7,8], and efficient mining of closed patterns [2,3,8,11] for dia-mond episodes and their generalizations. Also, we plan to apply the proposed algorithm to bacterial culture data [5,6].

