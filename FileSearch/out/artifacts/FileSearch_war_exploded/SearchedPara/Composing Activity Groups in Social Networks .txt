 One important function of current social networking services is allowing users to initialize different kinds of activity groups (e.g. study group, cocktail party, and group buying) and invite friends to attend in either manual or collaborative manners. However, such process of group formation is tedious, and could either include inappropriate group members or miss relevant ones. This work proposes to automatically compose the activity groups in a social network according to user-specified activity information. Given the activity host, a set of labels representing the activity X  X  subjects, the desired group size , and a set of must-inclusive persons, we aim to find a set of individuals as th e activity group, in which members are required to not only be familiar with the host but also have great communications with each other. We devise an approximation algorit hm to greedily solve the group composing problem. Experiments on a real social network show the promising effectiveness of th e proposed approach as well as the satisfactory human subjective study. H.2.8 [ Database Management ]: Database Applications X  Data mining .
 Social network, activit y group, group formation With the progress of ubiquity and accessibility in social networking services (SNS), su ch as Facebook, LinkedIn, and MySpace, people are more convenient to interact with each other. One of the popular characteristics of SNS is that allowing users to says, for a specific goal or to pic, through the power of social connections, one can ask some friends who are interesting in or suitable for such subject to join the group. And then these newly-joined persons could further invite their friends to attend such activity according to the intent of the activity. Another way to organize this kind of topic-driven groups is to restrict that only the group administrator has the authority to invite friends to join. However, the former fashion co uld include some irrelevant persons into the group due to human subjectivity or personal bias while the latter manner has some potential to miss adding those individuals who could have some great contribution to the group. In addition, current social platfo rms do not provide mechanisms to control the quality of activity groups. Users in the activity group usually do not be familiar with one another, or even are not acquainted with the activity host. In this study, to facilitate the composition of task-driven and strongly-interacted activity groups for the activity originator, we develop an Activity Composer system. Activity Composer aims to automatically find a group of individuals who will effectively and efficiently communicate with each other. The group formation process will consider the activity requirement, including the activity goal, the host, the group size, and some must-inclusive guys. There are wide scenarios that require composing activity groups in a social network. Here we elaborate four realistic scenarios. First, an enthusiastic guy would like to organize a study group for the topic of social network analysis (SNA), and requires that all members should not only have knowledge about SNA but also have great interactions with each other. Second, a project leader plans to form a team of individuals, in which the skills of each member need to cover the designated ones and these experts are expected to have effective communi cation with one another. Third, someone intends to hold a cocktail party and desires that the attended friends or friends of friends coming from different kinds of occupations and are acquainted with each other as more familiarly as better. Fourth, a pe rson starts an activity of group buying and wants to find a crew of individuals who not only interested in the buying items, but also have great trust in the host. We believe that the selection of joined individuals in a group has significant impact on the willingness of group members to interact with each other and determine whether the activity will be successful. If the activity group contains adversarial guys, persons with ineffective communications, or individuals who do not play any desired roles about the activit y requirement, the activity could lead to an unfavorable situation. In this study, we leverage the personal attributes and past inter action records between people to compose the effective activity group. The developed Activity Composer system will facilitate and enhance the process of selecting group members for the activity host, instead of going through the tedious experience of manually and collaboratively adding members. Prior work on online social networks has explored diverse group properties and link structures in groups. Backstrom et al. [2] investigate how topic-based groups grow and evolve in online social networks. Kairam et al. [4] utilize machine learning techniques to predict the future growth of online groups. Leskovec et al. [7] analyze how positive a nd negative social links affect group evolution in social networks. Gregory et al. [3] use both structural and personal attributes to detect footprint-based groups while Shah and Sukthankar [9] also identify social groups from online conversation data. The other relevant direction is to form task-driven group according to user requirements. Lappas et al. [6] and Li and Shan [8] form teams of experts in the expertise social networks, where team members must satisfy skill requirements specified by the given task. Anagnostopoulos et al. [1] further tackle the issue of load balance in each team. And Kargar and An [5] discover the team members together with group leaders. However, these works target at skill-driven methods and cannot apply to compose and host an activity group. Though Sozio and Gionis [10] aim to find densely connected subgraphs to compose the initiator-driven groups, and Ya ng et al. [11] consider the available time slots to search ac tivity members, their discovered groups are irrelevant to any ac tivity objectives or topics. Though there are several proposals on group formation, we argue that composing activity gr oups should simultaneously consider group size, activity intent, and the communication between members, which are what we deal with in this work. The social network  X  X , X  X  X  X  X  we tackle is a graph, in which each node  X  is an individual and associated with a set of labels  X  X  X  X  X  X  X  X  X   X   X ,  X   X ,...,  X   X  X  X  X  , where  X  is the universe set of  X  labels, representing the personal informati on such as interests, expertise  X  . A subset of individuals  X  X  X  X  X  possesses label  X   X  if at least one of them has  X   X  . For each label  X   X  , the set of individuals possessing  X  is denoted by  X  X  X   X   X | X  X  X  X  X   X   X  X  X  X  X  X  X  . In addition, each edge in  X  has a weight value  X  that captures the interaction cost between two individuals. Lower interact ion cost indicates efficient communication, better trust, or we ll acquaintance. For example, if two persons are well acquainted with each other, their interaction cost tends to be low. Now we can formally describe the problem of composing activity groups in a social networ k. We first define the activity query , which consists of four parts: (a) the activity host  X  (i.e., initiator), (b) a set of required labels  X   X   X  X  describing the objective of such activity, (c) the group size  X  (i.e., the number of members), and (d) a set of some must-inclusive individuals  X  X  X  . The goal aims at finding a set  X  of individual nodes satisfying (1)  X   X  X  X  ; that is, for each individual  X  X  X  , at least one of  X   X  X  labels need to be covered by group members, and (3) minimizing the activity cost  X   X   X   X  , which is defined as: in which the former part measures the host leadership , which is the sum of interaction costs between the initiator  X  and each group member  X  while the latter part estimates the communication ability between group members. Note that  X  X  X  X   X   X , X   X  is the sum of edge weight along the shortest path between node  X  and  X  . Finally, the parameter  X 1 X  X  X  X 0 X   X  determines the importance of the host leadership and the communication ability, and  X  is decided by users. The usage of  X  value depends on the activity scenario. For example, composing study groups tends to have lower  X  values because such kinds of groups encourages the members to have more interactions with on e another, while organizing group-buying crew might need higher  X  values because such groups requires the member to trust in the host or needs the host to have the great mediation ability. Theorem 1. Composing activity groups with the above-defined activity cost function is an NP-hard problem. The proof of Theorem 1 can be achieved by a reduction from 3-satisfiability (3-SAT). Due to the page limit, we skip this proof. We give the overview of the devised Activity Composer system, as shown in Figure 1. Under a certain social network, the input of activity query is first feed in to the preprocessing component, which aims at doing some indexing to enhance the time efficiency of graph search. And then we develop a greedy search method to find a set of  X  individuals  X  that minimizes the activity cost  X   X   X   X  . The set  X  is output and visualized for user relevance feedback. After few individuals are selected as must-inclusive ones, the relevant structure is updated and proceeds into the greedy group composing. Such procedure will be terminated until the user satisfies the members in the resulting group. We first construct the indexing for boosting the time efficiency of the following group formation process. It consists of two parts, (1) node-label indexing and (2) shortest distance hashing table . We perform the inverted indexing on the mapping between each label and those nodes possess each label. We denote the set of nodes short distances between nodes in the network and store these pair-wise distances in a hash table for quick access. We propose a greedy method to minimize the activity cost  X   X   X   X  for finding the set of individuals  X  . We find that when  X 1 X  , the problem can be exactly solved by greedily searching the network and selecting  X  nodes with least costs. And while  X 0 X  , we need to devise a certain method to approximately compose the final group. When  X 1 X 0 X  , we divide desired nodes into  X  X  and  X  X  X  X 1 X  X  parts. We first find  X  X  nodes which exactly minimize the cost of host leadership, and then aim to select  X  X  X  X 1 X  X  nodes minimize the cost of communication ability. Therefore, we design our method consisting of two steps, (1) the leadership-based selection and (2) the communication-based selection , which are corresponding to two parts of the activity-cost function. For the first step, the leadership-based selection, we exploit the Uniform-Cost Search ( UCS ) algorithm to find the  X  X  nodes with lowest cost towards the host. Specifically, we start from the host node  X  , and iteratively visit the neighboring node  X  which has the Note that the neighborhood means the one-step neighboring nodes from the current selected nodes. If the current lowest-cost neighboring node  X  contains at least one of the required labels, i.e.,  X   X  X   X   X  X  X  , we add  X  into the final group set  X  ; otherwise, we ignore  X  and keep the uniform-cost search. Such process continues until the size of final set  X  is up to  X  X  . The uniform-cost search guarantees the discovered  X  X  nodes to be exact solution with respect to the cost of host leadership. We perform the second step, the communication-based selection, to find the other  X  X  X  X 1 X  X  nodes. The goal is to discover  X 1 X  X   X  X  nodes in the neighborhood of  X  such that all group members can have effective communications with each other. Specifically, together with previously-selected  X  X  nodes and the set of must-inclusive nodes  X  , we aim to minimize the total cost of communication ability between group members, where each of  X  X  X  X 1 X  X  nodes not only need to cover at least one required label and the union of total  X  nodes must cover all required labels. We develop a greedy approximation algorithm, termed GroupComp , as shown in Figure 2, to obtain such goal. We first find the  X  X  nodes using UCS and update the following labels to be satisfied (line 1-3). To cover the required labels, we create a circular linked list to store each set  X  X  X   X   X  of nodes with label  X  keeps finding nodes up to  X  X  X  X 1 X  X  size and requires all required labels to be covered. We iteratively retrieve the set with label  X   X   X  X  X  in a descending order from th e circular list (line 6), and greedily find a node  X   X  from  X   X  X  X  which possesses the lowest  X  X , X  X  X  X  X  X  X  X  X  X  X  computes the shortest distance between node  X  and the set of selected nodes  X  , which is the shortest distance between  X  and its nearest node in  X  . And then we add the node  X  into  X  and update the labels to be covered in the following (line 13-15). This iterative process terminates when the activity query is satisfied. That says, if the size of resulting set  X  is equal to  X  but the required labels are not totally covered, the algorithm will proceed to the largest set from the smallest set in the circular list. Input: the pruned social network  X  ; the activity query: host  X  , required labels  X   X  , group size  X  , and the set of must-inclusive ones  X  ; the set of nodes with label  X   X  ,  X  X  X   X   X  , for  X |,..., X 1 X  Output: the best activity group (i.e., the set of nodes  X  ). 1:  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X , X  X   X   X , X  X , X , X   X   X  . 2:  X  X  X  X  X  . 3:  X   X   X  X   X   X  X  \  X   X  X  X  X   X  | . 4:  X  X  X  X  X  X  X  X  X  X  X  X  X   X   X   X   X   X   X   X ,  X   X   X   X   X  X  X ,..., | X  5: while |  X  |  X  X   X  X  |  X   X  |  X 0 do: 6:  X   X  X  X  . X  X  X  X . X  X  X  X  X  X  X  X  X  X  X  X  X  7:  X  X  X  X  X  X  X  X  X  X  X  . 8: for  X  X  X   X  X  X  do: 9:  X  X , X  X  X  X  X  X  X  X  X  X  X  X   X  X  X  X  . 10: if  X  X  X  X  X  X  X  X   X  X  X  X  then: 11:  X  X  X  X  X  X  X  X  X  X  X  X  . 12:  X   X   X  X  . 13:  X  X  X  X  X  X  X   X   X  . 14:  X   X   X   X   X   X  \  X   X  . 15:  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  . 16: return  X  X  X  X  X  X  X  X  X  X  X  X  X , X  X  . Theorem 2. The GroupComp algorithm finds the activity group of nodes that minimizes the activity-cost  X   X   X   X  with 2 -approximation . 
Proof. Since the host  X  is given, we are able to find the first  X  X  members (i.e.,  X  X   X   X   X   X ,  X   X ,...,  X  X  X   X  ) with the lowest (optimal) cost  X   X  X  X  X   X   X , X   X   X   X  X  X   X  X  X  X  . And thus we focus on finding the remaining  X   X   X 1 X   X  members (denoted by subgroup in the following proof). Consider the optimal subgroup and the best subgroup from the proposed GroupComp algorithm. For the best subgroup, there always has a node  X   X  , termed anchor member , with the lowest cost to all group members. The cost from anchor node to all other group members is  X   X  X  X  X   X   X   X   X ,  X   X   X  generality, the anchor node has lo west cost among all nodes in the subgroup and also among all nodes of all possible subgroups including the optimal subgroup . Consider a certain node  X  optimal subgroup with cost to each node in the subgroup, denoted by  X  X  X  X   X   X   X   X   X   X  X   X   X ,  X   X  X  X  X  X ,  X   X   X   X   X   X  X   X   X ,  X   X  X  X  X  X ,...,  X  X  X  X   X   X   X   X   X   X  X  We further consider for all the  X  nodes of the optimal subgroup, we can rewrite the inequalities as On the other hand, we can derive the cost of the best team as follows using the triangle inequality of the shortest distances By integrating the above two equations, we can find the cost of the best subgroup is at most twice that of the optimal subgroup .  X  Since we have pre-computed and indexed the all-pair shortest distances between nodes,  X  X , X  X  X  X  X  X  X  X  X  X  X  can be efficiently derived. Here we analyze the time complexity of the GroupComp algorithm. The while-loop is executed  X |, X  X  X  X  X  X  X  X   X  | X  times. In every iteration, the inner for-loop is executed  X | X  X   X   X  Besides, the run time of  X  X , X  X  X  X  X  X  X  X  X  X  X  is  X  X  X  X  X  . As a result, the total time complexity of GroupComp is  X  X  X | X  X  X  X  X  X  X  . In the worst case, |  X  |  X  X  X  X  X  X  ,  X  X  X  X  X  X  X  , and | X | X  X  , where  X  is the number of nodes in the network and | X | is the number of universe of labels. Thus, the time complexity will be  X  X  X   X   X  X  X | X  Once the discovered group of individuals is reported to the host user, we allow the host to pick what she really wants to include. Those unselected ones will be removed from the set  X  . If the host selects  X   X  nodes from  X  resulting ones, we need to execute the group composing process again to find the other  X  X  X  We consider the communication-based selection to find these new  X  X  X   X  nodes (line 2-15 in the GroupComp algorithm). This process of user selection and feedback will con tinue until all reported nodes in  X  are satisfied by the host user. We conduct the experiments to show the effectiveness of the proposed approach. We compile the DBLP bibliography data to a connected co-authorship network, which contains 22,285 nodes and 49,365 edges in some premier conferences of data mining, including KDD, ICDM, SDM, PAKDD, PKDD, ICML, CIKM, WWW, SIGIR, ACL, SIGMOD, VLDB, PODS, ICDE, EDBT, and ICDT. Two authors are connected in the network if they co-authored at least three papers. The edge weights (i.e., interaction costs) are determined using the Jaccard coefficient . The formula of computing edge weights is defined as:  X   X   X , X   X   X 1 X   X  |  X   X   X  X   X  ||  X   X   X  X   X  | X   X  , where  X   X  is the set of papers of the author  X  . Besides, the label set  X   X  of each author  X  are produced by the textual terms (removing stop words) appearing in at least three titles of papers belonging to the author. Besides, we generate the activity query as follows. We randomly pick 500 authors with the larger  X |  X  | as the hosts, and randomly choose  X | each author  X  to be host  X   X  X  required label se t. By setting the group size  X 4,8,12,16,20  X  and |  X   X  |  X 2,4,6,8,10 correspondingly, we compute the av erage activity cost under the parameter  X  X 0.8,0.5,0.2 . We compare the activity cost of our GroupComp algorithm with that of the Enhanced-Steiner algorithm [6] which was devised to solve team formation problem. The experimental results are show n in Figure 3. We can find as  X  GroupComp outperforms the Enhanced-Steiner method. In more details, as  X  is set to be higher (e.g. 0.8), the activity cost decreases because such value is slowly gained by the cost of host leadership, which is the shortest distance between group member and the host. While  X  is set to be lower (e.g. 0.2), the activity cost increases since the cost of communication ability between pair-wise group members is quickly accumulated. Such cost tendency also exhibits the degree of intera ctions for different kinds of real-world activities. That says, groups with lower  X  (e.g. study group) need intense communications between members while groups with higher  X  (e.g. group buying) require the focused and featured relations towards the hosts. Figure 3: Effectiveness on activity cost by varying the group size (  X  ) and the number of required labels (  X  X   X  | ). On the other hand, we also perform the human subjective study to test if the activity gr oup composed by our method is satisfactory (under the scenario of composing a study group). We invite 10 authors, who appear in our constructed DBLP co-authorship network, as the human subjects. We ask them to use some of their research keywords as the query labels to play with the Activity Composer system (  X  X 0.5 ). Then they are asked to give scores from 1 to 5 to express their satisfaction for the three questions: (a) Can the group members have effective communication? (b) Are the group members familiar with you? (c) Does group members cover the query labels? The average resulting scores are 3.8 , 4.1 , and 4.7 respectively. Such results show our system can really help organize the activity group w ith promising user satisfaction. This paper proposes and tack les the problem of composing activity groups based on user-input activity information in a social network. A novel system, Activity Composer , is developed, in which a greedy GroupComp algorithm is devised to solve the problem with 2-approximation. Our system also allows users to interactively organize the group members through relevant feedback. In addition, by varying the parameter  X  of activity-cost function, our system is able to compile diverse kinds of activity groups, such as study group, cock tail party, and group buying. [1] A. Anagnostopoulos, L. Becche tti, C. Castillo, A. Gionis, [2] L. Backstrom, D. Huttenlocher, J. Kleinberg, and X. Lan. [3] M. Gregory, D. W. Engel, E. Bell, A. Piatt, S. Dowson, and [4] S. Kairam, D. Wang, and J. Leskovec. The Life and Death of [5] M. Kargar and A. An. Discovering Top-k Teams of Experts [6] T. Lappas, K. Liu, and E. Te rzi. Finding a Team of Experts [7] J. Leskovec, D. Huttenloche r, and J. Kleinberg. Signed [8] C.-T. Li and M.-K. Shan. Team Formation for Generalized [9] F. Shah and G. R. Sukthankar. Using Network Structure to [10] M. Sozio and A. Gionis. Th e Community-Search Problem [11] D.-N. Yang, Y.-L. Chen, W.-C. Lee, and M.-S. Chen. On 
