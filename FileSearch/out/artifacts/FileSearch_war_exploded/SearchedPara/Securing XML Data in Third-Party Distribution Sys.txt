 Web-based third-party architectures for data publishing a re today receiving growing attention, due to their scalability and t he abil-ity to efficiently manage large numbers of users and great amo unts of data. A third-party architecture relies on a distinction between the Owner and the Publisher of information. The Owner is the producer of information, whereas Publisher provides data m anage-ment services and query processing functions for (a portion of) the Owner X  X  information. In such architecture, there are impor tant se-curity concerns especially if we do not want to make any assum p-tion on the trustworthy of the Publishers. Although approac hes have been proposed [4, 5] providing partial solutions to thi s prob-lem, no comprehensive framework has been so far developed ab le to support all the most important security properties in the presence of an untrusted Publisher. In this paper, we develop an XML-b ased solution to such problem, which makes use of non-convention al digital signature techniques and queries over encrypted da ta. Categories and Subject Descriptors: [D.4.6] Security and Pro-tection Access General Terms: Security.
 Keywords: XML, Third-party architecture, Data outsourcing.
Third-party information dissemination represents today a n in-teresting paradigm for data-intensive web-based applicat ions in a large variety of contexts, from grid computing to web servic es or P2P systems. Relevant applications include large-scale fe derated Digital Libraries, e-commerce catalogs, e-learning, coll aborative applications, content distribution networks. The main ide a of third-party architectures is that the information Owner outsources all or some portions of its data to one or more Publishers that pro-vide specialized data management services and query proces sing functions. Such an approach is scalable, results in highly e fficient query execution, and reduces the management costs of the Own er.  X 
The work reported in this paper has been partially supported by the Italian MIUR under the project  X  X eb-based management an d representation of spatial and geographical data X .
 Copyright 2005 ACM 1-59593-140-6/05/0010 ... $ 5.00.
 Clearly, such architecture has challenging security requi rements. Requiring the Publishers to be trusted wrt security propert ies is not always an appropriate solution in that large web-based syst ems can-not be easily verified to be trusted and can be easily penetrat ed. Thus, our goal is to ensure security properties even in the pr esence of untrusted Publishers.

The main security properties that should be assured are: confi-dentiality , integrity , and authenticity . Confidentiality has two as-pects. The first, that we call confidentiality wrt the user , refers to protecting data against unauthorized accesses by users. Th e second, that we call confidentiality wrt the Publisher , deals with protecting data from accesses by Publishers. Integrity requires that d ata con-ity assures that a user receiving some data can verify that th e data have been generated by the Owner and that the Publisher has no t modified their contents. To provide strong guarantees about data contents to users, we need to complement the three basic secu rity properties with an additional property that we refer to as complete-ness . By completeness we mean that the user receiving a portion of data is able to verify whether he/she has received all the i nfor-mation is allowed to see according to the specified access con trol policies. Although some proposals exist assuring the satis faction of some of these properties [4, 5], no comprehensive framewo rk exists able to enforce all such properties.

In this paper, we develop such a comprehensive solution, by f o-cusing our attention on data expressed in XML [10]. Our solu-tion relies on the use of encryption and non-conventional si gnature techniques. Encryption is used to support confidentiality. The basic idea is that the Publisher does not operate on clear text data , but on an encrypted version. Encryption is driven by the specified a ccess control policies: all data portions to which the same polici es apply are encrypted by the Owner with the same key. Then, each user i s provided by the Owner with all and only the keys correspondin g to the portions of data he/she is allowed to access. Clearly, both users and Publishers must be provided with additional infor ma-tion to make them able to submit and answer queries on encrypt ed data. Authenticity/integrity requirements cannot be ensu red by tra-ditional digital signature techniques. The reason is that s ince a user may be returned only selected portions of a document, depend ing on his/her queries and the specified policies, it is not enoug h that the Owner signs each document it sends to the Publisher. Thus , we propose an alternative solution, based on Merkle hash trees [8], to generate document signatures.

Finally, completeness is verified through the so-called query tem-plate , which consists of the encrypted structure of the original d oc-ument. We show that, by executing the queries submitted to a P ub-lisher on the query template, a user is able to verify the comp lete-ness of the query answer without accessing information he/s he is not allowed to see.

Our work has been inspired by the work by Hacigumus et al. [5, 6], which developed a method for querying encrypted data sto red in relational databases. From such work we borrow the method for querying encrypted data, which is based on partitioning the do-mains of the relation attributes. The same method has been ex -ploited also in the context of XML data in [7]. However, such a p-proaches only consider confidentiality wrt the Publisher, a nd they do not address the requirement of confidentiality wrt the use rs, nor authenticity/integrity and completeness. By contrast, in this paper we extend these approaches to data encrypted with different keys, thus providing confidentiality wrt the users. In addition, w e con-sider also all the other security properties. Other related work is by Miklau and Suciu [9], which proposed a method for a controlle d sharing of XML data, dealing only with confidentiality. As in our approach, confidentiality is ensured by the use of cryptogra phic techniques. However, the main difference with our proposal is that they do not rely on a Publisher for managing data, rather data are simply published on the web in an encrypted form and each user can access the authorized portions, using the keys he/she re ceives from the data Owner. However, we strongly believe that relyi ng on a data Publisher has many benefits, in terms of efficiency and o pti-mization of resource usage. Indeed, simply publishing the d ata over the web would make them the target of a huge number of attacks, with many users trying to perform queries over them, and thus con-suming a huge amount of computational resources. By contras t, the Publisher can be equipped with sophisticated anti-intrusi on tools and techniques avoiding queries floods. Additionally, not r elying on a Publisher requires each user be equipped with a query eng ine able to process queries over encrypted contents.

Merkle hash trees are a well-known mechanism used in several computer areas for certified query processing. For instance , they have been exploited for authenticating XML documents by De-vanbu et al. in [4]. However their approach has many differen ces wrt our proposal. First, it addresses only authenticity, wh ereas we address all security properties. Moreover, our approach to authen-ticity verification does not have limitations on the structu re of XML documents to which it can be applied, whereas the approach by De-vanbu et al. does not handle attributes and it assumes that da ta con-tents can be only present in leaf nodes. Another important di ffer-ence is that we can certify the authenticity for each possibl e kind of XPath queries, whereas the approach by Devanbu et al. only handles queries returning whole sub-trees. The work report ed in this paper builds on a previous paper by us [1], where we devel op the technique for authenticity verification that we use in th e current paper. However, the current paper significantly extends our pre-vious work with techniques for confidentiality and complete ness enforcement. Moreover, we define also an architecture and re lated data structures supporting security properties verificati on.
The remainder of this paper is organized as follows. Next sec -tion presents an overview of the proposed framework. Sectio ns 3 and 4 describe authenticity and confidentiality enforcemen t; Sec-tion 5 introduces the XML encoding we propose to represent th e needed security information, whereas Section 6 focuses on q uery processing. Section 7 deals with completeness. Section 8 fo rmally states some properties of the proposed framework, whereas S ection 9 concludes the paper.

In the architecture we propose (see Figure 1) users submit qu eries to Publishers through a client , that the user can download from the Owner site, and which makes the user able to verify the securi ty properties on the received answers. The novelty of our propo sal is that we do not make any assumption on the trustworthy of Publi sh-ers. In the following we give a general overview of the techni ques we have devised.

Because the proposed framework requires additional inform a-tion to be transmitted by the Owner to both Publishers and use rs, we store all such information into a directory server (which can also be shared among different Owners belonging to the same d o-main or to federated ones), to limit the overhead that these o per-ations require. In particular, as depicted in Figure 1, the d irectory server contains three kinds of entries: the Publishers entry, which is shared by all Publishers and contains all encrypted documen ts that they are entitled to manage, plus additional information th ey need for the correct functioning of the system; the Users entry, shared by all the subscribed users, storing common information; and a distinct User ID entry for each single user, containing needed information to verify the security properties. Thus, after a mandatory r egistra-tion phase, each user/Publisher receives by the Owner the ke ys for accessing the corresponding entries in the directory.
 We now briefly discuss how the security properties are enforc ed. Confidentiality wrt final users are expressed by the Owner by m eans of a set of access control policies, regulating the operatio ns that can be performed on its data [2]. To enforce confidentiality w rt the Publisher, the Owner encrypts its data before delivering th em to the Publisher. Following an approach we will explain in Section 4, the Publisher is able to answer user queries, without the need of de-crypting the data. Thus, it returns the requesting user an en crypted answer. If the Publisher operates according to the Owner pol icies, this answer contains all and only the portions of the request ed data the user can access. Otherwise, it may contain a superset of t he data the requesting user is allowed to see. The key aspect is t hus that a user must be able to decrypt all and only the portions of the returned answer he/she is authorized to see. This is obta ined by selectively encrypting the documents in the Owner source : the Owner encrypts them in such a way that all the portions that ar e protected by the same policies, hereafter called policy configura-tion , are encrypted with the same key. 2 These keys are then stored in the User ID entries by the Owner, on the basis of the policies the corresponding users satisfy. Additionally, the entry stor es the user policy configuration , a certificate signed by the Owner maintaining information on the access control policies the user satisfie s, which are determined according to the credentials the user submit s during a mandatory subscription phase.

To make a Publisher able to correctly answer queries over en-crypted data, the Owner provides the Publisher with informa tion on which users can access which portions of the managed docu-ments, according to the access control policies it has speci fied. Ad-ditionally, the Owner supplies the Publisher some informat ion that makes it able to query encrypted data. The basic idea is that t he Owner divides the domain of each document node (i.e., attrib ute and element) into distinguished partitions, to which a uniq ue id is assigned. Then, the Owner provides the Publisher together w ith the encrypted nodes also the ids of the partitions correspon ding to their values. The Publisher is thus able to perform queries d irectly on the encrypted documents, by exploiting the partitioning ids (see Section 4 for more details). Similarly, users find in the comm on Users entry information on the partitioning techniques adopted b y the Owner.

Authenticity and integrity are assured by the use of the Merkle signature , a signature generated by the Owner using a bottom-up computation on the whole document, based on Merkle hash tree s [8]. Such signature is generated before encrypting a docume nt and it is provided to the Publisher along with the corresponding doc-ument. The Publisher will then forward it to a user querying t he document to which it refers to. The problem here is that, sinc e the Publisher answer may not contain all the document portions o ver which the signature has been generated, a user may not be able to validate the signature. To avoid this shortcoming, the Owne r gives the Publisher a set of additional hash values, one for each no de, which represent the information needed to validate the sign ature if the corresponding node is not inserted into the Publisher an swer. Thus, when a user queries a certain document, the Publisher s ends him/her, besides the corresponding Merkle signature, also these ad-ditional hash values, referring to the document portions no t con-tained in the query answer. This makes the user able to locall y perform the computation of the Merkle signature and compari ng it with the one generated by the Owner.

All the additional information needed by the Publisher for c onfi-dentiality and authenticity/integrity enforcement is enc oded in XML and attached to the encrypted document, forming the so calle d secu-rity enhanced encryption (SE-ENC) of the original document. All the SE-ENC documents are stored by the Owner in the Publisher s directory entry. Similarly, all information needed by a use r to ver-ify the security properties are encoded by the Publisher in X ML and attached to the query answer, resulting in what we have ca lled the reply document .

Finally, to make a user able to verify the completeness of a qu ery result, the Owner generates a query template , containing the en-crypted structure of the original document. The query templ ate has the twofold goal of making a user able to verify the completen ess of the received answers, as well as to make easier the task of q uery submission, in that by inspecting the query template a user c an ob-tain information on the structure of the documents (or porti ons) he/she is allowed to access. The query template is encrypted by the Owner using the same strategy employed for XML documents . This means that a user can see only the portions of the query te m-plate on which he/she can perform the queries, according to t he specified access control policies. The query template is dig itally signed by the Owner, through a Merkle signature, to prevent a l-terations. All the query templates are stored by the Owner in the Users directory entry.
For authenticity enforcement we adopt an alternative way to com-pute the digest value of an XML document wrt traditional digi tal signature techniques [1]. The function we use to compute the di-gest value is the Merkle hash function . This function univocally associates an hash value (referred to as Merkle hash value ) with a whole XML document through a recursive bottom-up computati on on its structure. The basic idea is to associate a Merkle hash value with each node n of the XML document, denoted as MhX ( n ) Merkle hash value associated with an attribute is obtained b y apply-ing an hash function over the concatenation of the attribute value and the attribute name; the Merkle hash value associated wit h an element is the result of the same hash function computed over the concatenation of the element content, the element tag name, and the Merkle hash values of its children nodes, both attribute s and elements. The digest of the XML document is thus the Merkle hash value of the root of the document. Once the digest has bee n computed, it is signed by the Owner, generating what we call t he Merkle Signature of the document. The Merkle signature is in-serted by the Owner into the corresponding SE-ENC document, by adding a Sign subelement to the document root, which con-tains the signature value. When a user submits a query to the P ub-lisher, the Publisher returns him/her, besides the query re sult, also the Merkle signatures of the documents on which the query is p er-formed. Moreover, to make the user able to validate the signa ture, the Publisher sends him/her a set of hash values, referring t o the portions of the requested documents not returned in the quer y an-swer. This additional information is called Merkle hash paths .
E XAMPLE 3.1. Let us consider the XML document presented in Fig-
More formally, given two nodes v, w such that v  X  P ath ( w ) the Merkle hash path between w and v is the set of hash values necessary to compute the Merkle hash value of v having the Merkle hash value of w . The Merkle hash path between w and v consists of all the Merkle hash values of w  X  X  siblings, together with the hash value of tagname and content of w  X  X  father node. Indeed, accord-ing to Merkle hash function definition, given w , these hash values make possible the computation of the Merkle hash value of father node. Thus, given this Merkle hash value to compute th e Merkle hash value of v are necessary also the Merkle hash values of all the siblings of the nodes belonging to the path connect ing v to w . Thus, for each node n belonging to the query result, the user must be supplied by the Publisher with the Merkle Hash pa th between n and the root element. Since the Publisher operates on encrypted data, it is not able to compute the Merkle hash valu es, and, as a consequence, to generate the appropriate Merkle ha sh paths to be returned to the user submitting the query. For thi s rea-son, the Owner gives Publisher some additional information , called Authenticity information , which makes the Publisher able to com-pute the Merkle hash values of all the document nodes, respec ting, at the same time, confidentiality requirements. Such inform ation are attached to the SE-ENC document using the strategy we wil l illustrate in Section 5.
To ensure confidentiality, we propose a solution based on enc ryp-tion techniques. The idea is that the Owner, before outsourc ing a document to Publishers, encrypts it on the basis of the speci fied access control policies. All the portions of an XML document to which the same policy configuration applies are encrypted wi th the same secret key (we refer to the document encryption driven b y the Owner policies as well-formed encryption ). The appropriate keys are then stored in the Owner directory server, in such a way th at each user obtains all and only the keys corresponding to the p olicies he/she satisfies. Moreover, to limit the number of keys that n eed to be permanently maintained we adopt an hierarchical key mana ge-ment schema defined in such a way that from the encryption key associated with an access control policy it is possible to de rive all and only the encryption keys corresponding to policy configu ration containing such a policy. In this way the number of keys that n eed to be managed is linear in the number of the specified access co ntrol policies.

Generation of the well-formed encryption ensures confident ial-ity both wrt the users and the Publishers. Each node of the res ult-ing encrypted document is accessible only to authorized use rs, that is, those users who have been provided with the appropriate k eys. Since the Publisher does not have keys, this solution preven ts its accesses to the managed data, thus ensuring the confidential ity wrt Publisher. Additionally, the fact that a user submits queri es to a Publisher in encrypted form ensures a certain degree of priv acy to the user in that the Publisher does not know the details of the sub-mitted queries.
To make the Publisher able to evaluate queries on encrypted d oc-uments, we adopt an approach similar to the one proposed in [5 , 6] for relational databases. The underlying idea of this appro ach is the following: given a relation R , the Owner divides the domain of each attribute in R into distinguished partitions, to which it as-signs a different id. Then, the Owner sends the Publisher the en-crypted tuples, together with the ids of the partitions corr esponding to each attribute value in R . According to this approach, the Pub-lisher is able to perform queries directly on the encrypted t uples, by exploiting the partition ids. As an example, consider the re-lation Employee ( eid, ename, salary ) , and, for simplicity, con-sider only the salary attribute. Suppose that the domain of is in the interval [500k, 5000k], and that an equi-partition with 100k as range is applied on that domain. Thus, each encrypted tupl e is complemented with the id of the partition corresponding t o the value of the salary attribute for that tuple. By using this id the Pub-lisher is able to perform queries such as:  X  X ELECT * FROM Em-ployee WHERE salary =1000k X , which is translated into the qu ery:  X  X ELECT * FROM Employee WHERE salary =XX X , where XX is the id of the partition containing the value 1000k. It is inte resting to note that this query returns an approximate result, in tha t it re-turns all the tuples of the Employee relation whose salary belongs to the range [1000K, 1100K). A further query process ing has thus to be performed by the client to refine the answer retu rned by the Publisher.

We adapt such an idea to the XML context. This requires first of all to deal with partition generation. In general, the cho ice of the most appropriate partitioning technique mainly depend s on the attribute domain. Thus, in defining the partitioning techni ques for an XML document, we need to consider the data types that it may contain. For numeric data (such as integer, real, etc.), a st rategy based on an equi-partitioning of the domain could be appropr iate. However, an XML document mainly contain textual informatio n (for instance, the data content of an element). For this reas on, it is necessary to devise ad-hoc partitioning techniques for tex tual data, which are not so important in the relational context. The sol ution we propose for partitioning textual data requires a first pha se dur-ing which the Owner preprocesses the textual data contained in an a partition id is associated with each keyword. More precise ly, all possible keywords are organized into a dictionary. Therefo re, parti-tion ids are associated with groups of dictionary terms (for instance, assuming that the terms in the dictionary are in alphabetic o rder, we can generate a different id for each group of N terms). In the rest of the paper, we assume that there exists a function P I () as input a value val returns the index of the partition to which belongs to.
All information for confidentiality and authenticity enfor cement is encoded in XML and attached to the well-formed encryption , forming the SE-ENC document. Generation of SE-ENC docu-ments consists of two main steps: generation of 1) the well-f ormed encryption, and 2) security information.

Generation of well-formed encryption is done by first markin g the nodes of the input document with the policies that apply t o them. Then, all the nodes to which the same marking applies ar e encrypted with the same key. In the literature, there exists different proposals for the encryption of an XML document (see for inst ance [7, 10]). However, we prefer to adopt a slightly different ap proach, to preserve as much as possible the structure of the original XML document in the document encryption. Indeed, since users fo rmu-late queries according to the structure of the original docu ment, this choice makes query processing easier. Thus, given an XML doc u-ment d , the well-formed encryption of d is an XML document which preserves the elements/attributes relationships of the original document, but which has the names and contents of all the node s encrypted. More precisely, the resulting document is forma lly de-fined as follows.

D EFINITION 5.1. ( Well-formed encryption of an XML docu-ment ). Let d = ( V d ,  X  v d , E d ,  X  E PC PB ( d ) be the set of policy configurations which apply to Key ( pc ) be the encryption key associated with policy configura-tion pc , and let V d ( pc ) be the set of nodes to which well-formed encryption of d is an XML document d e = ( V d e E
Once the well-formed encryption has been generated, it unde r-goes a second phase, during which it is complemented with inf or-mation for authenticity and confidentiality enforcement. A ll this information are wrapped into a unique element, called Security In-formation element. The SE-ENC document contains a different Security Information element for each element of the well-f ormed encryption. Such element is added as an additional child of t he corresponding element and contains confidentiality and aut hentic-ity information of both the element itself and of all its attr ibutes.
The authenticity information associated with each node n of the original document consists of the hash values needed to comp ute the Merkle Hash Path to be sent to users (cfr. Section 3). More precisely, these are the hash value of the name of n (i.e., the tag-name or the attribute name, depending on whether n is an attribute or an element) and the hash value of the content of n (i.e., the data content or the attribute value, respectively). All these va lues are contained into a unique element, called Auth -Info element, child of the Security Information element corresponding to n .

Confidentiality information associated with a node consist s of policy information and query-processing information . Policy in-formation gives the Publisher information on which access c ontrol policies apply to each node of the original document, and is e n-coded into a string of hexadecimal values. With each node equal to the cardinality of the set of access control policie s which applies to the corresponding clear-text document d , where, starting from the left side, the value of the i -th bit is: 1, if the 7 applies to n ; 0, otherwise. Then, we translate each 4-bits block of the resulting binary string into the corresponding hexad ecimal representation. This information is then stored as an addit ional at-tribute of the Security Information element. Finally, to ma ke pol-icy configurations meaningful to Publishers it is necessary to insert an additional element into the SE-ENC document. This elemen t, called Policy , contains the identifiers of the policies which apply to d . These identifiers help the Publisher to match a user policy c on-figuration with the policy information in the SE-ENC documen t.
Query-processing information associated with a node consi sts of the partition ids corresponding to it. All partition ids are contained into a unique element, called Query -Info element, child of the Security Information element. We are now ready to formally i ntro-duce the Security Information element.

D EFINITION 5.2. ( Security Information element ). Let ( V d e ,  X  v d e , E d e ,  X  E d e ) be the well-formed encryption of an XML document d . Let v 0  X  V e to v  X  V e d . The Security Information element associated with an XML element s such that:
When all the Sec -Info elements have been added to a well-formed encryption, the final SE-ENC document is obtained by a d-ding the Policy element previously illustrated, and the Sign el-ement described in Section 3. Figure 3 reports an example of t he Sec -Info element associated with the Investment element of Partner2 (see Figure 2), computed by considering the access control
In this section, we explain how the user can formulate querie s to the Publisher. We assume that users submit queries by means o f XPath expressions. XPath allows one to traverse the graph st ruc-ture of an XML document and to select specific portions on the document according to some properties, such as the type of th e el-ements, or specified content-based conditions. In this pape r, we consider conditions specified by means of equality or compar ison operators on data content. Moreover, among the functions su p-ported by XPath, we consider the contains() function, which allows the specification of conditions on textual data. In general, an XPath expression consists of a location path , that allows one to select a set of nodes from the target documents. A location path consi sts of one or more location steps , separated among each other by a slash. A location step consists of: an axis , specifying the tree re-lationships between the nodes selected by the location step and the current node (e.g., ancestor, ancestor-or-self, attribut e, child, de-scendant, descendant-or-self); a node test , used to identify a node within an axis, by specifying a node type or the node name (e.g ., text(), node()); and zero or more predicates , placed inside square brackets, used to further refine the set of nodes selected by t he lo-cation step (e.g., [@Type= X  X T X  X ). In the following, given a loca-tion step ls we use the dot notation to identify its components (i.e., ls.axis , ls.nodetest , ls.p ).

To query an XML document through XPath, it is thus necessary to know the corresponding schema. For this reason, the user r e-trieves from the Users entry the query template of the interested document, which consists of the encrypted structure of the c orre-sponding document. This operation is required only the first time the user inquiries a document. To make a user able to submit queries on encrypted documents, the query template contain s fur-ther information. One of this information is the Policy element and PC attributes contained in the SE-ENC document, that allow the client to correctly encrypt the queries to be submitted t o the
We explain now how the user can exploit the query template for formulating an XPath expression on encrypted documents. Fi rst of all, it is important to point out that a user can access only se lected portions of the query templates, that is, only the nodes for w hich he/she has the appropriate decryption keys. Thus, as a first s tep, the client extracts the authorized view from the query template . To de-crypt a node, the client has to know which key has to be used. Th is information can be derived from the PC attribute contained in the query template. The view of the query template is built by a fu nc-tion, called V iew () , which takes as input the policy configuration of a user u and the query template, and turns the set of decrypted nodes, into a well-formed XML document. This resulting view is, then, displayed to the user, making him/her able to formulat e XPath queries on it. However, before the user XPath queries can be s ub-mitted to the Publisher they have to be properly transformed and encrypted. The following example clarifies the discussion.
There are three main transformations to which each location step of a user XPath expression must undergo before being submitt ed to the Publisher. Since the user XPath expression has been gene rated on a partial view of the query template, it is first necessary i ts com-pletion, by inserting all the missing location steps. For in stance, considering again Example 6.1, between the first and the seco nd location step of the user query it is necessary to insert the l ocation step referring to element  X  X g2 X . Moreover, since the SE-ENC docu-ment is encrypted, it is necessary to encrypt the tagnames sp ecified in the node test of the location steps with the proper keys, so that they can be evaluated by the Publisher. Finally, the third tr ans-formation is the transformation of the location step predic ates, by computing the ids of the partitions, using the information o btained during the subscription phase, and by adapting the resultin g predi-cates to the SE-ENC structure.

An Algorithm doing all the above mentioned operations is pre -sented in Figure 5. For simplicity, the algorithm considers only XPath queries whose predicates contain a unique condition; how-ever, it can be easily extended to consider more complex pred i-cates. Due to the nature of well-formed encryption, where no des with the same name could be encrypted with different keys, th e en-cryption of a location step does not always return a unique va lue. For instance, the second location step of the XPath query in E x-ample 6.1 (i.e.,  X /tg3[@Att= X  X T X  X  X ) must be transformed in two dif-ferent location steps:  X /Enc(tg3, K 1 )[...] X  and  X /Enc(tg3, (cfr. Figure 4). Let us see how Algorithm 1 works. It receives as input an XPath expression exp submitted by a user u , the query template qt on which the query is submitted, and the view of generated by the client according to the policies satisfied b y generate the set of XPath queries to be submitted to the Publi sher, the algorithm exploits a recursive function, called T ransform () which recursively applies the same transformations to each location step of exp . The T ransform () function first verifies whether all the location steps in exp have been processed. If this the case, step 2 .a returns the resulting set of XPath expressions. Other-wise, the T ransform () function computes the set of nodes, called Nodes , whose tagname is specified by the node test of the current location step. Then, in step 4 the algorithm iteratively con siders each node in Nodes . For each of these nodes the T ransform () function generates a different location step by applying th e above-mentioned transformations. After the insertion of this new loca-tion step into the XPath expression (step 4 .i ), the T ransform () function recursively calls itself, to consider the next loc ation step of exp . Let us see how the algorithm applies the needed trans-formations to each location step. At first, the algorithm com pletes the input XPath expression by inserting the missing locatio n steps (steps 4 .a  X  d ). To verify whether the path between the considered location step and the previous one in the input XPath express ion must be completed, the algorithm first computes the absolute path connecting the node identified by the current location step t o the root of the query template (step 4 .a ). Then, in step mines the nodes that are missing in the input XPath expressio n wrt the absolute path. Note that, since the query template conta ins en-crypted nodes, the nodes are first encrypted with the corresp onding key. The second transformation is performed by step 4 .g crypts the tagname of the current node. The encrypted name is inserted as node test in an empty location step. Finally, the last phase is the translation of the predicates in the location st ep. In general, a predicate p of a location step specifies a node ( to which a comparison operator  X  is applied (e.g., &lt; , contains () ), matching it with the contained value ( p.value viously, the Publisher can not evaluate  X  directly on the of the SE-ENC document, since it contains only encrypted dat a. By contrast, the predicate has to be adapted to the SE-ENC doc u-ment. This implies that the condition has to be evaluated dir ectly on the Value attribute of the Id subelements, that is, the attribute containing the partition id. More precisely, the new XPath e xpres-sion must be applied to the Id subelements of the Query -Info element contained into the Node -Info element corresponding to p.node in the SE-ENC document. Thus, the predicate that replaces p in the new location step is the following: [/ Sec -Info // Node -Info [@Name= Enc ( ls.p.node, Key ( P C ( ls.p.node )) ]/ Query -Info / id [@Value  X  P I ( ls.p.value ) ]], where P I () is the func-tion returning the partition id corresponding to the input v alue (step 4 .h ).

In this section we show how the client can verify the complete -ness of the query answer by using the query template. The quer y template of d is generated by the Owner, by applying a simple XSLT transformation [10] on the corresponding SE-ENC docu-ment. This transformation prunes from the SE-ENC document t he encrypted data contents and authenticity information, whi ch are not necessary for completeness verification. To prevent altera tions of the query template, the Owner signs it with a Merkle signatur e, which is stored into a Sign element. Once the client receives a query template, it is able to verify the completeness of the q ueries submitted on XML documents conforming to the template. Com-pleteness verification can be done for all XPath queries whos e con-ditions are based on = , &lt; , &lt; = , &gt; , &gt; = operators or the function.

The node-set returned by evaluating a query on the query tem-plate could be a superset of the nodes the user is entitled to s ee, according to the Owner access control policies. Thus, in ord er to verify the completeness, the client must also consider the a ccess control policies specified on the document. For this reason, the query template contains also policy information (i.e., the Policy element and PC attributes).

In this section, we state the correctness of the proposed sol ution, proofs can be found in [3]. In particular, we show how the prop osed framework is able to enforce the considered security proper ties. Before presenting the formal results, we introduce the reply doc-ument , that is, the XML document generated by the Publisher and containing the query answer plus additional information ne eded for authenticity verification.

D EFINITION 8.1. ( Reply document ) Let g = ( V g ,  X  v g be the SE-ENC version of an XML document d , let u be a user, and q be a query on d submitted by u to a Publisher. Let V iew ( q, u ) = ( V q ,  X  v q , E q ,  X  E q ) be the XML document answer to q the policy configuration of u . The reply document of query respect to u is an XML document r = ( V r ,  X  v r , E r ,  X 
The following theorem states the correct enforcement of con fi-dentiality requirements.

T HEOREM 8.1. Let O be an Owner, P be a publisher managing a portion P S of the Owner source. Let PB be the policy base of and let u be a user subscribed to O . Let d be a document belonging to
P , and let V d ( u ) be the portion of d that u is allowed to see according to the policies in PB . Let q be a query on d submitted by u to P and let r be the corresponding reply document. Then, 1)
P is not able to read information in P S . 2) there does not exist a node n in d such that n 6 X  V d ( u ) and u is able to access processing r .

As far as authentication is concerned, the correctness is ba sed on the fact that the Merkle hash paths sent by the Publisher are s uffi-cient for the user to authenticate all the elements he/she is allowed to see in the reply document. We need thus to first state the not ion of authenticable element.

D EFINITION 8.2. ( Authenticable element ). Let d = ( V d  X  ENC version of d , and r = ( V r ,  X  v r , E r ,  X  E ment corresponding to a query submitted on d by a user u V
T be the set of terminal nodes of r . For each v  X  V e authenticable by s , iff there exists v t  X  V T , with v  X  P ath ( v such that it is possible, through a recursive bottom-up comp uta-tion, to compute the Merkle hash value of v d using only the values in { w. MhPath | w  X  P ath ( v t ) } .

Note that authenticability is required only for the nodes of the reply document that represent elements. Indeed, attribute nodes in the reply document (i.e., MhPath attributes) are inserted only to store values needed to check the authenticity and completen ess of the answer.

T HEOREM 8.2. Let P be a Publisher, let d be a document, and let d e be the SE-ENC version of d managed by P . Let r reply document corresponding to a query submitted on d by a user u . Each element node belonging to r is authenticable by u .
Finally, completeness enforcement is ensured by the follow ing theorem.

T HEOREM 8.3. Let P be a Publisher, O be an Owner and PB its policy base. Let q be a query submitted by a user u to document d . Let qt be the query template associated with r be the reply document returned by P to u , and let V d ( u ) portion of d that u is allowed to see according to the policies in PB . By using the information in qt and r , u can verify that he/she receives all the portions of V d ( u ) answering query q .
In this paper we have provided a comprehensive framework abl e to ensure security properties in the context of a third-part y architec-ture. Our approach also includes a suite of strategies for mi nimiz-ing the overhead due to updates to the policy base or the docum ent source [3]. The strategies are based on incrementally maint aining the document encryption and the related data structures, up on each update operation, without rebuilding them from scratch eac h time an update occurs. The work reported in this paper can be exten ded along several directions. First, we would like to complemen t our framework with privacy enforcement. An implementation of t he proposed system is currently underway. Up to now we have com-pleted the modules for authenticity and completeness verifi cation. We plan to develop also the modules for confidentiality enfor ce-ment to test the system performance and to assess the overhea d due to update management. [1] E.Bertino, B.Carminati, E.Ferrari, B. Thuraisingham, A. [2] E. Bertino and E. Ferrari. Secure and Selective [3] B. Carminati, E. Ferrari, E. Bertino. Securing XML Data i n [4] P. Devanbu, M. Gertz, A. Kwong, C. Martel, G. Nuckolls, [5] H. Hacigumus, B. Iyer, C. Li, and S. Mehrotra. Executing [6] H. Hacigumus, B. Iyer, and S. Mehrotra,  X  X roviding datab ase [7] R. Jammalamadaka and S. Mehrotra. Querying Encrypted [8] R.C. Merkle A Certified Digital Signature. In Advances in [9] G. Miklau and D. Suciu. Controlling Access to Published [10] World Wide Web Consortium. Available at
