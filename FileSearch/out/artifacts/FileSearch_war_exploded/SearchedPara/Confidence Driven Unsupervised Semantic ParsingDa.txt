 Semantic parsing, the ability to transform Natural Language (NL) input into a formal Meaning Repre-sentation (MR), is one of the longest standing goals of natural language processing. The importance of the problem stems from both theoretical and practi-cal reasons, as the ability to convert NL into a formal MR has countless applications.

The term semantic parsing has been used ambigu-ously to refer to several semantic tasks (e.g., se-mantic role labeling). We follow the most common definition of this task: finding a mapping between NL input and its interpretation expressed in a well-defined formal MR language. Unlike shallow se-mantic analysis tasks, the output of a semantic parser is complete and unambiguous to the extent it can be understood or even executed by a computer system.
Current approaches for this task take a data driven approach (Zettlemoyer and Collins, 2007; Wong and Mooney, 2007), in which the learning algorithm is given a set of NL sentences as input and their cor-responding MR, and learns a statistical semantic parser  X  a set of parameterized rules mapping lex-ical items and syntactic patterns to their MR. Given a sentence, these rules are applied recursively to de-rive the most probable interpretation.

Since semantic interpretation is limited to the syn-tactic patterns observed in the training data, in or-der to work well these approaches require consider-able amounts of annotated data. Unfortunately an-notating sentences with their MR is a time consum-ing task which requires specialized domain knowl-edge and therefore minimizing the supervision ef-fort is one of the key challenges in scaling semantic parsers.

In this work we present the first unsupervised approach for this task. Our model compensates for the lack of training data by employing a self training protocol based on identifying high confi-dence self labeled examples and using them to re-train the model. We base our approach on a sim-ple observation: semantic parsing is a difficult struc-tured prediction task, which requires learning a com-plex model, however identifying good predictions can be done with a far simpler model capturing re-peating patterns in the predicted data. We present several simple, yet highly effective confidence mea-sures capturing such patterns, and show how to use them to train a semantic parser without manually an-notated sentences.

Our basic premise, that predictions with high con-fidence score are of high quality, is further used to improve the performance of the unsupervised train-ing procedure. Our learning algorithm takes an EM-like iterative approach, in which the predictions of the previous stage are used to bias the model. While this basic scheme was successfully applied to many unsupervised tasks, it is known to converge to a sub optimal point. We show that by using confi-dence estimation as a proxy for the model X  X  pre-diction quality, the learning algorithm can identify a better model compared to the default convergence criterion.

We evaluate our learning approach and model on the well studied Geoquery domain (Zelle and Mooney, 1996; Tang and Mooney, 2001), consist-ing of natural language questions and their prolog interpretations used to query a database consisting of U.S. geographical information. Our experimental results show that using our approach we are able to train a good semantic parser without annotated data, and that using a confidence score to identify good models results in a significant performance improve-ment. We formulate semantic parsing as a structured pre-diction problem, mapping a NL input sentence (de-noted x ), to its highest ranking MR (denoted z ). In order to correctly parametrize and weight the pos-sible outputs, the decision relies on an intermediate representation: an alignment between textual frag-ments and their meaning representation (denoted y ). Fig. 1 describes a concrete example of this termi-nology. In our experiments the input sentences x are natural language queries about U.S. geography taken from the Geoquery dataset. The meaning rep-resentation z is a formal language database query, this output representation language is described in Sec. 2.1.

The prediction function, mapping a sentence to its corresponding MR, is formalized as follows: Where  X  is a feature function defined over an input sentence x , alignment y and output z . The weight vector w contains the model X  X  parameters, whose values are determined by the learning process.
We refer to the arg max above as the inference problem. Given an input sentence, solving this in-ference problem based on  X  and w is what com-promises our semantic parser. In practice the pars-ing decision is decomposed into smaller decisions (Sec. 2.2). Sec. 4 provides more details about the feature representation and inference procedure used.
Current approaches obtain w using annotated data, typically consisting of ( x , z ) pairs. In Sec. 3 we describe our unsupervised learning procedure, that is how to obtain w without annotated data. 2.1 Target Meaning Representation The output of the semantic parser is a logical for-mula, grounding the semantics of the input sen-tence in the domain language (i.e., the Geoquery domain). We use a subset of first order logic con-sisting of typed constants (corresponding to specific states, etc.) and functions, which capture relations between domains entities and properties of entities (e.g., population : E  X  N ). The seman-tics of the input sentence is constructed via func-tional composition, done by the substitution oper-ator. For example, given the function next to(x) and the expression const(texas) , substitution replaces the occurrence of the free variable x with the expression, resulting in a new formula: next to(const(texas)) . For further details we refer the reader to (Zelle and Mooney, 1996). 2.2 Semantic Parsing Decisions The inference problem described in Eq. 1 selects the top ranking output formula. In practice this decision is decomposed into smaller decisions, capturing lo-cal mapping of input tokens to logical fragments and their composition into larger fragments. These deci-sions are further decomposed into a feature repre-sentation, described in Sec. 4.

The first type of decisions are encoded directly by the alignment ( y ) between the input tokens and their corresponding predicates. We refer to these as first order decisions . The pairs connected by the align-ment ( y ) in Fig. 1 are examples of such decisions.
The final output structure z is constructed by composing individual predicates into a complete formula. For example, consider the formula pre-sented in Fig. 1: river( const(colorado)) is a composition of two predicates river and const(colorado) . We refer to the composition of two predicates, associated with their respective input tokens, as second order decisions .

In order to formulate these decisions, we intro-duce the following notation. c is a constituent in the input sentence x and D is the set of all function and constant symbols in the domain. The alignment y is a set of mappings between constituents and symbols in the domain y = { ( c,s ) } where s  X  X  .

We denote by s i the i -th output predicate compo-sition in z , by s i  X  1 ( s i ) the composition of the ( i  X  1 )-th predicate on the i -th predicate and by y ( s i ) the in-put word corresponding to that predicate according to the alignment y . Our learning framework takes a self training ap-proach in which the learner is iteratively trained over its own predictions. Successful application of this approach depends heavily on two important factors -how to select high quality examples to train the model on, and how to define the learning objective so that learning can halt once a good model is found.
Both of these questions are trivially answered when working in a supervised setting: by using the labeled data for training the model, and defining the learning objective with respect to the annotated data (for example, loss-minimization in the supervised version of our system).

In this work we suggest to address both of the above concerns by approximating the quality of the model X  X  predictions using a confidence measure computed over the statistics of the self generated predictions. Output structures which fall close to the center of mass of these statistics will receive a high confidence score.

The first issue is addressed by using examples as-signed a high confidence score to train the model, acting as labeled examples.

We also note that since the confidence score pro-vides a good indication for the model X  X  prediction performance, it can be used to approximate the over-all model performance, by observing the model X  X  to-tal confidence score over all its predictions. This allows us to set a performance driven goal for our learning process -return the model maximizing the confidence score over all predictions. We describe the details of integrating the confidence score into the learning framework in Sec. 3.1.

Although using the model X  X  prediction score (i.e., w
T  X ( x , y , z ) ) as an indication of correctness is a natural choice, we argue and show empirically, that unsupervised learning driven by confidence estima-tion results in a better performing model. This empirical behavior also has theoretical justification: training the model using examples selected accord-ing to the model X  X  parameters (i.e., the top rank-ing structures) may not generalize much further be-yond the existing model, as the training examples will simply reinforce the existing model. The statis-tics used for confidence estimation are different than those used by the model to create the output struc-tures, and can therefore capture additional informa-tion unobserved by the prediction model. This as-sumption is based on the well established idea of multi-view learning, applied successfully to many NL applications (Blum and Mitchell, 1998; Collins and Singer, 1999). According to this idea if two models use different views of the data, each of them can enhance the learning process of the other.
The success of our learning procedure hinges on finding good confidence measures, whose confi-dence prediction correlates well with the true quality of the prediction. The ability of unsupervised confi-dence estimation to provide high quality confidence predictions can be explained by the observation that prominent prediction patterns are more likely to be correct. If a non-random model produces a predic-tion pattern multiple times it is likely to be an in-dication of an underlying phenomenon in the data, and therefore more likely to be correct. Our specific choice of confidence measures is guided by the intu-ition that unlike structure prediction (i.e., solving the inference problem) which requires taking statistics over complex and intricate patterns, identifying high quality predictions can be done using much simpler patterns that are significantly easier to capture.
In the reminder of this section we describe our Algorithm 1 Unsupervised Confidence driven Learning Input: Sentences { x l } N l =1 , 1: define Confidence : X  X Y  X Z  X  X  , 2: repeat 3: for l = 1 ,...,N do 4:  X  y ,  X  z = arg max y , z w T  X ( x l , y , z ) 5: S i = S i  X  X  x l ,  X  y ,  X  z } 6: end for 7: Confidence = compute confidence statistics 8: S conf i = select from S i using Confidence 10: i = i + 1 11: until S conf i has no new unique examples 12: best = arg max i ( P s  X  S learning approach. We begin by introducing the overall learning framework (Sec. 3.1), we then ex-plain the rational behind confidence estimation over self-generated data and introduce the confidence measures used in our experiments (Sec. 3.2). We conclude with a description of the specific learning algorithms used for updating the model (Sec. 3.3). 3.1 Unsupervised Confidence-Driven Learning
Our learning framework works in an EM-like manner, iterating between two stages: making pre-dictions based on its current set of parameters and then retraining the model using a subset of the pre-dictions, assigned high confidence. The learning process  X  X iscovers X  new high confidence training examples to add to its training set over multiple it-erations, and converges when the model no longer adds new training examples.

While this is a natural convergence criterion, it provides no performance guarantees, and in practice it is very likely that the quality of the model (i.e., its performance) fluctuates during the learning process. We follow the observation that confidence estima-tion can be used to approximate the performance of the entire model and return the model with the high-est overall prediction confidence.

We describe this algorithmic framework in detail in Alg. 1. Our algorithm takes as input a set of natural language sentences and a set of parameters used for making the initial predictions 1 . The algo-rithm then iterates between the two stages -predict-ing the output structure for each sentence (line 4), and updating the set of parameters (line 9). The specific learning algorithms used are discussed in Sec. 3.3. The training examples required for learn-ing are obtained by selecting high confidence exam-ples -the algorithm first takes statistics over the cur-rent predicted set of output structures (line 7), and then based on these statistics computes a confidence score for each structure, selecting the top ranked ones as positive training examples, and if needed, the bottom ones as negative examples (line 8). The set of top confidence examples (for either correct or incorrect prediction), at iteration i of the algorithm, is denoted S conf i . The exact nature of the confidence computation is discussed in Sec. 3.2.

The algorithm iterates between these two stages, at each iteration it adds more self-annotated exam-ples to its training set, learning therefore converges when no new examples are added (line 11). The al-gorithm keeps track of the models it trained at each stage throughout this process, and returns the one with the highest averaged overall confidence score (lines 12-13). At each stage, the overall confidence score is computed by averaging over all the confi-dence scores of the predictions made at that stage. 3.2 Unsupervised Confidence Estimation Confidence estimation is calculated over a batch of input ( x ) -output ( z ) pairs. Each pair decomposes into smaller first order and second order decisions (defined Sec. 2.2). Confidence estimation is done by computing the statistics of these decisions, over the entire set of predicted structures. In the rest of this section we introduce the confidence measures used by our system.
 Translation Model The first approach essentially constructs a simplified translation model, capturing word-to-predicate mapping patterns. This can be considered as an abstraction of the prediction model: we collapse the intricate feature representation into high level decisions and take statistics over these de-cisions. Since it takes statistics over considerably less variables than the actual prediction model, we expect this model to make reliable confidence pre-dictions. We consider two variations of this ap-proach, the first constructs a unigram model over the first order decisions and the second a bigram model over the second order decisions. Formally, given a set of predicted structures we define the following confidence scores: Unigram Score: Bigram Score: Structural Proportion Unlike the first approach which decomposes the predicted structure into in-dividual decisions, this approach approximates the model X  X  performance by observing global properties of the structure. We take statistics over the propor-tion between the number of predicates in z and the number of words in x .

Given a set of structure predictions S , we com-pute this proportion for each structure (denoted as Prop ( x , z ) ) and calculate the average proportion over the entire set (denoted as AvProp ( S ) ). The confidence score assigned to a given structure ( x , y ) is simply the difference between its proportion and the averaged proportion, or formally PropScore ( S, ( x , z )) = AvProp ( S )  X  Prop ( x,z ) This measure captures the global complexity of the predicted structure and penalizes structures which are too complex (high negative values) or too sim-plistic (high positive values).
 Combined The two approaches defined above capture different views of the data, a natural question is then -can these two measures be combined to pro-vide a more powerful estimation? We suggest a third approach which combines the first two approaches. It first uses the score produced by the latter approach to filter out unlikely candidates, and then ranks the remaining ones with the former approach and selects those with the highest rank. 3.3 Learning Algorithms Given a set of self generated structures, the param-eter vector can be updated (line 9 in Alg. 1). We consider two learning algorithm for this purpose.
The first is a binary learning algorithm, which considers learning as a classification problem, that is finding a set of weights w that can best sepa-rate correct from incorrect structures. The algo-rithm decomposes each predicted formula and its corresponding input sentence into a feature vector  X ( x , y , z ) normalized by the size of the input sen-tence | x | , and assigns a binary label to this vector 2 The learning process is defined over both positive and negative training examples. To accommodate that we modify line 8 in Alg. 1, and use the con-fidence score to select the top ranking examples as positive examples, and the bottom ranking examples as negative examples. We use a linear kernel SVM with squared-hinge loss as the underlying learning algorithm.

The second is a structured learning algorithm which considers learning as a ranking problem, i.e., finding a set of weights w such that the  X  X old struc-ture X  will be ranked on top, preferably by a large margin to allow generalization.The structured learn-ing algorithm can directly use the top ranking pre-dictions of the model (line 8 in Alg. 1) as training data. In this case the underlying algorithm is a struc-tural SVM with squared-hinge loss, using hamming distance as the distance function. We use the cutting-plane method to efficiently optimize the learning process X  objective function. Semantic parsing as formulated in Eq. 1 is an in-ference procedure selecting the top ranked output logical formula. We follow the inference approach in (Roth and Yih, 2007; Clarke et al., 2010) and formalize this process as an Integer Linear Program (ILP). Due to space consideration we provide a brief description, and refer the reader to that paper for more details. 4.1 Inference The inference decision (Eq. 1) is decomposed into smaller decisions, capturing mapping of input to-kens to logical fragments (first order) and their com-position into larger fragments (second order). We encode a first-order decision as  X  cs , a binary vari-able indicating that constituent c is aligned with the logical symbol s . A second-order decision  X  cs,dt , is encoded as a binary variable indicating that the sym-bol t (associated with constituent d ) is an argument of a function s (associated with constituent c ). We frame the inference problem over these decisions: F w ( x ) = arg max
We restrict the possible assignments to the deci-sion variables, forcing the resulting output formula to be syntactically legal, for example by restricting active  X  -variables to be type consistent, and force the resulting functional composition to be acyclic. We take advantage of the flexible ILP framework, and encode these restrictions as global constraints over Eq. 2. We refer the reader to (Clarke et al., 2010) for a full description of the constraints used. 4.2 Features The inference problem defined in Eq. (2) uses two feature functions:  X  1 and  X  2 .
 First-order decision features  X  1 Determining if a logical symbol is aligned with a specific con-stituent depends mostly on lexical information. Following previous work (e.g., (Zettlemoyer and Collins, 2005)) we create a small lexicon, mapping logical symbols to surface forms. 3 Existing ap-proaches rely on annotated data to extend the lexi-con. Instead we rely on external knowledge (Miller et al., 1990) and add features which measure the lex-ical similarity between a constituent and a logical symbol X  X  surface forms (as defined by the lexicon). Second-order decision features  X  2 Second order decisions rely on syntactic information. We use the dependency tree of the input sentence. Given a second-order decision  X  cs,dt , the dependency fea-ture takes the normalized distance between the head words in the constituents c and d . In addition, a set of features indicate which logical symbols are usu-ally composed together, without considering their alignment to the text. In this section we describe our experimental evalua-tion. We compare several confidence measures and analyze their properties. Tab. 1 defines the naming conventions used throughout this section to refer to the different models we evaluated. We begin by de-scribing our experimental setup and then proceed to describe the experiments and their results. For the sake of clarity we focus on the best performing mod-first and discuss other models later in the section. 5.1 Experimental Settings In all our experiments we used the Geoquery dataset (Zelle and Mooney, 1996), consisting of U.S. geography NL questions and their corresponding Prolog logical MR. We used the data split described in (Clarke et al., 2010), consisting of 250 queries for evaluation purposes. We compared our system to several supervised models, which were trained us-ing a disjoint set of queries. Our learning system had access only to the NL questions, and the log-ical forms were only used to evaluate the system X  X  performance. We report the proportion of correct structures (accuracy). Note that this evaluation cor-responds to the 0/1 loss over the predicted structures. Initialization Our learning framework requires an initial weight vector as input. We use a straight for-ward heuristic and provide uniform positive weights to three features. This approach is similar in spirit to previous works (Clarke et al., 2010; Zettlemoyer and Collins, 2007). We refer to this system as I NI -TIAL M ODEL throughout this section.
 Competing Systems We compared our system to several other systems: (1) P RED . S CORE : An unsupervised frame-work using the model X  X  internal prediction score ( w T  X ( x , y , z ) ) for confidence estimation. (2) A LL E XAMPLES : Treating all predicted struc-tures as correct, i.e., at each iteration the model is trained over all the predictions it made. The re-ported score was obtained by selecting the model at the training iteration with the highest overall confi-dence score (see line 12 in Alg. 1). (3) R ESPONSE B ASED : A natural upper bound to our framework is the approach used in (Clarke et al., 2010). While our approach is based on assessing the correctness os the model X  X  predictions according to unsupervised confidence estimation, their frame-work is provided with external supervision for these decisions, indicating if the predicted structures are correct. (4) S UPERVISED : A fully supervised framework trained over 250 ( x , z ) pairs using structured SVM. 5.2 Results Our experiments aim to clarify three key points: (1) Can a semantic parser indeed be trained with-out any form of external supervision? this is our key question, as this is the first attempt to approach this task with an unsupervised learning protocol. 4 In order to answer it, we report the overall performance of our system in Tab. 2.

The manually constructed model I NITIAL M ODEL achieves a performance of 0.22. We can expect learning to improve on this baseline. We com-pare three self-trained systems, A LL E XAMPLES , P in their sample selection strategy, but all use con-fidence estimation for selecting the final seman-tic parsing model. The A LL E XAMPLES approach achieves an accuracy score of 0.656. P REDICTION -S
CORE only achieves a performance of 0.164 us-ing the binary learning algorithm and 0.348 us-ing the structured learning algorithm. Finally, our confidence-driven technique C OMBINED achieved a score of 0.536 for the binary case and 0.664 for the structured case, the best performing models in both cases. As expected, the supervised systems R E -performance.

These results show that training the model with training examples selected carefully will improve learning -as the best performance is achieved with perfect knowledge of the predictions correctness (R
ESPONSE B ASED ). Interestingly the difference between the structured version of our system and that of R ESPONSE B ASED is only 0.07, suggesting that we can recover the binary feedback signal with high precision. The low performance of the P RE -DICTION S CORE model is also not surprising, and it demonstrates one of the key principles in confidence estimation -the score should be comparable across predictions done over different inputs, and not the same input, as done in P REDICTION S CORE model. (2) How does confidence driven sample selection contribute to the learning process? Comparing the systems driven by confidence sample-selection to the A LL E XAMPLES approach uncovers an inter-esting tradeoff between training with more (noisy) data and selectively training the system with higher quality examples. We argue that carefully select-ing high quality training examples will result in bet-ter performance. The empirical results indeed sup-port our argument, as the best performing model (R
ESPONSE B ASED ) is achieved by sample selec-tion with perfect knowledge of prediction correct-ness. The confidence-based sample selection system (C
OMBINED ) is the best performing system out of all the self-trained systems. Nonetheless, the A LL E
XAMPLES strategy performs well when compared to C OMBINED , justifying a closer look at that aspect of our system.

We argue that different confidence measures cap-ture different properties of the data, and hypothe-size that combining their scores will improve the re-sulting model. In Tab. 3 we compare the results of the C OMBINED measure to the results of its individ-ual components -P ROPORTION and B IGRAM . We compare these results both when using the binary and structured learning algorithms. Results show that using the C OMBINED measure leads to an im-proved performance, better than any of the individ-ual measures, suggesting that it can effectively ex-ploit the properties of each confidence measure. Fur-thermore, C OMBINED is the only sample selection strategy that outperforms A LL E XAMPLES . (3) Can confidence measures serve as a good proxy for the model X  X  performance? In the unsu-pervised settings we study the learning process may not converge to an optimal model. We argue that by selecting the model that maximizes the averaged confidence score, a better model can be found. We validate this claim empirically in Tab. 4. We com-pare the performance of the model selected using the confidence score to the performance of the fi-nal model considered by the learning algorithm (see Sec. 3.1 for details). We also compare it to the best model achieved in any of the learning iterations.
Since these experiments required running the learning algorithm many times, we focused on the binary learning algorithm as it converges consider-ably faster. In order to focus the evaluation on the effects of learning, we ignore the initial model gen-erated manually (I NITIAL M ODEL ) in these exper-iments. In order to compare models performance across the different iterations fairly, a uniform scale, such as U NIGRAM and B IGRAM , is required. In the case of the C OMBINED measure we used the B I -GRAM measure for performance estimation, since it is one of its underlying components. In the P RED . S
CORE and P ROPORTION models we used both their confidence prediction, and the simple U NIGRAM confidence score to evaluate model performance (the latter appear in parentheses in Tab. 4).

Results show that the over overall confidence score serves as a reliable proxy for the model perfor-mance -using U NIGRAM and B IGRAM the frame-work can select the best performing model, far better than the performance of the default model to which the system converged.
 Semantic parsing has attracted considerable interest in recent years. Current approaches employ various machine learning techniques for this task, such as In-ductive Logic Programming in earlier systems (Zelle and Mooney, 1996; Tang and Mooney, 2000) and statistical learning methods in modern ones (Ge and Mooney, 2005; Nguyen et al., 2006; Wong and Mooney, 2006; Kate and Mooney, 2006; Zettle-moyer and Collins, 2005; Zettlemoyer and Collins, 2007; Zettlemoyer and Collins, 2009).

The difficulty of providing the required supervi-sion motivated learning approaches using weaker forms of supervision. (Chen and Mooney, 2008; Liang et al., 2009; Branavan et al., 2009; Titov and Kozhevnikov, 2010) ground NL in an external world state directly referenced by the text. The NL input in our setting is not restricted to such grounded settings and therefore we cannot exploit this form of supervi-sion. Recent work (Clarke et al., 2010; Liang et al., 2011) suggest using response-based learning proto-cols, which alleviate some of the supervision effort. This work takes an additional step in this direction and suggest an unsupervised protocol.

Other approaches to unsupervised semantic anal-ysis (Poon and Domingos, 2009; Titov and Kle-mentiev, 2011) take a different approach to seman-tic representation, by clustering semantically equiv-alent dependency tree fragments, and identifying their predicate-argument structure. While these ap-proaches have been applied successfully to semantic tasks such as question answering, they do not ground the input in a well defined output language, an essen-tial component in our task.

Our unsupervised approach follows a self training protocol (Yarowsky, 1995; McClosky et al., 2006; Reichart and Rappoport, 2007b) enhanced with con-straints restricting the output space (Chang et al., 2007; Chang et al., 2009). A Self training proto-col uses its own predictions for training. We esti-mate the quality of the predictions and use only high confidence examples for training. This selection cri-terion provides an additional view, different than the one used by the prediction model. Multi-view learn-ing is a well established idea, implemented in meth-ods such as co-training (Blum and Mitchell, 1998).
Quality assessment of a learned model output was explored by many previous works (see (Caruana and Niculescu-Mizil, 2006) for a survey), and applied to several NL processing tasks such as syntactic parsing (Reichart and Rappoport, 2007a; Yates et al., 2006), machine translation (Ueffing and Ney, 2007), speech (Koo et al., 2001), relation extrac-tion (Rosenfeld and Feldman, 2007), IE (Culotta and McCallum, 2004), QA (Chu-Carroll et al., 2003) and dialog systems (Lin and Weng, 2008).

In addition to sample selection we use confidence estimation as a way to approximate the overall qual-ity of the model and use it for model selection. This use of confidence estimation was explored in (Re-ichart et al., 2010), to select between models trained with different random starting points. In this work we integrate this estimation deeper into the learning process, thus allowing our training procedure to re-turn the best performing model. We introduced an unsupervised learning algorithm for semantic parsing, the first for this task to the best of our knowledge. To compensate for the lack of training data we use a self-training protocol, driven by unsupervised confidence estimation. We demon-strate empirically that our approach results in a high preforming semantic parser and show that confi-dence estimation plays a vital role in this success, both by identifying good training examples as well as identifying good over all performance, used to improve the final model selection.

In future work we hope to further improve un-supervised semantic parsing performance. Particu-larly, we intend to explore new approaches for confi-dence estimation and their usage in the unsupervised and semi-supervised versions of the task.
 Acknowledgments We thank the anonymous re-viewers for their helpful feedback. This material is based upon work supported by DARPA under the Bootstrap Learning Program and Machine Read-ing Program under Air Force Research Laboratory (AFRL) prime contract no. FA8750-09-C-0181. Any opinions, findings, and conclusion or recom-mendations expressed in this material are those of the author(s) and do not necessarily reflect the view of the DARPA, AFRL, or the US government.
