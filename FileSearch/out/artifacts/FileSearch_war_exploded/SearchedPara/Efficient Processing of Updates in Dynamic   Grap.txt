 As XML is gaining unqualified success in being adopted as a universal data exchange format, particularly in the World Wide Web, the problem of managing and querying XML documents poses interesting challenges to database researchers. Previous works always model the XML as a directed tree. However, in many applications, an XML document needs to be modeled as a directed graph more naturally than a tree. For example, the XML document of the relationship of chapters and authors adapts to graph structure since one author may write more than one chapter and one chapter may have more than one author. A fragment of an XML document about books is shown in Fig.1. Obviously, the Graph-structured XML document can be represented in tree structure by duplicating the element with more than one incoming paths. But it will result in redundancy. If the information in Fig.1 is represented with a tree-structured XML document, the element  X  X uthor X  will be duplicated. XML standard uses ID and IDREF types to avoid redundancy. ID represents a unique ID name for the attribute that identifies the element within the context of the document. The IDREF type allows the value of one attribute to be an element elsewhere in the document provided that the value of the IDREF is the ID value of the referenced element. Taking ID/IDREF into account, XML data should be modeled as a graph. Unlike other graph data (e.g. graph data in biological networks, social networks, and so on), there is an ordering, document order, defined on all the nodes in XML data. So XML data should be modeled as an ordered directed graph in this paper. 
To process the queries (e.g. XQuery[1]) in XML database efficiently, a common method is that assign each node a label in advance and process queries using these labels. For Graph-structured XML, when the XML is static, it is easy to extend some existing labeling schemes to label them, like the approach in [2]. However, when the XML becomes dynamical, in other words, XML data changes over time, ID/IDREF relationships make the maintenance of labeling schemes of XML data more complex. but also need maintain the reachability relationship. Although there have existed some methods to process updates of labeling for tree-structured XML, they can X  X  be used to process updates of labeling of Graph-structured XML. We will give the detailed reasons in section 3. In response to these, this paper studies the incremental maintenance of labeling of XML modeled as an ordered directed graph. We identify the main reason for the inefficiency of updates of labeling. Then, we propose an efficient and general update approach for dynamic XML. The main contributions of this paper include:  X 
We model the graph-structured XML data as ordered directed graph and propose an updatable extended interval labeling for XML data.  X 
Illustrate inefficient cases in updates of the extended labeling and propose a simple approach to deal with them.  X 
To get more efficient, we design an effective indexing, called XUI. Based on this indexing, we propose two novel algorithms for deletion and insertion of edges.  X 
We conduct comprehensive experiments to demonstrate the benefits and performances of our labeling scheme and updating algorithms. The remainder of the paper is organized as follows: Section 2 presents summarizing the preliminaries. In section 3, we analyze inefficient cases in updates and present two na X ve methods. Section4 introduces the novel indexing XUI. The efficient updating algorithms are presented in Section 5. In Section 6, we present an experimental evaluation of the proposed labeling and our update algorithms. Related work is discussed in Section 7 and Section 8 concludes this paper. 2.1 Graph-Structured XML Data Before giving the definition of Graph-structured XML Data, we first introduce the document order of XML. The document order is an order defined on all the element XML representation of each element occurs in the XML representation of the document after expansion of general entities. From definition 1, we can see the reference edges can X  X  affect the document order of a all nodes in V and all nesting edges. A reachability relationship  X  X  X  represents that there is a path in G from v to u , in other words, v is an ancestor of u on G . 2.2 Extended Interval Labeling Scheme In 1989, [2] proposed an interval-based labeling to label reachability relationships on directed acyclic graph. However, it didn X  X  concern the document order between nodes. Since 2000, several interval-based labeling schemes have been proposed for tree-structured XML which use an interval to represent the order of nodes, like work [11] In addition, there have been a lot of approaches to maintain this kind of labeling, such as CDQS [8], Float-point [9], and so on. is updatable for XML. The basic idea of our labeling is to assign an special interval Id [ start, end ] for each node n in G to identify the node and represent the order of nodes and assign an interval set ISet to record nodes which can be reached by n in G . There according to approach in [ 11]. Second, each strongly connected component (SCC)in compute an interval set like [2] for each node in D ; all of ISet of nodes in the same SCC are set as the interval set of SCC. Table 1 is the labels of nodes on G in Fig.2. According to above construction steps, it is easy to understand the two following Lemmas. Lemma2 is proved according to lemma1.Due to limitations on space, we don X  X  give proofs. In XML, updates (updates of a node and an ID/IDREF attribution) can be transformed edges are the core operations of updates. In our paper, we only discuss insertions and deletions of edges. We focus on how to maintain the reachability relationship and the document order. Note that insertion and deletion of an element will cause insertion and deletion of its subelements. So, the update of nesting edges can X  X  change reachability relationships of left nodes. For simplify, we only consider the insertions and deletions of edges causing by inserting or deleting a leaf node in XML. In fact, it internal node. Firstly, consider the insertion of an edge ( u , v ). There are two cases: 1) Insert a reference edge; 2) Insert a nesting edge. In the remainder of the paper,  X   X   X   X   X  X  X  X  X  X  X  X  X  ,  X   X  v  X   X  X  X  X | X  X  X  X  . 
According to above analysis, we propose a na X ve approach to process the insert of an edge ( u, v ) as follow: Next, discuss a deletion of an edge ( u , v ) in G. If the deleted edge is a reference edge, nodes. After deleting a nesting edge (in other words, deleting a leaf node), the order and reachability of left nodes can X  X  be changed. According to lemma 2, their labels the deletion of an edge ( u , v ) is as follow: Above na X ve approaches need lots of times of merging two interval sets and once of calculating the reversal topological of A (the time Complexity is O (| V |)). These largely increase the time of processing the updates. To improve the update efficiency, we detail. 
In designing the index, we consider both update efficiency and lookup efficiency of the index. Hash Index is a good choice. So we design XUI based on Hash Index. The structure of XUI is shown in Fig.4. In hash table, the number of a node n in G is set as a key and each node points to an interval list RL . In RL , each record consists of three parts: START, END , and SOURCE , where START and END represent an interval, and SOURCE is a nodes set composed by children of n . Let LS the interval set of RL . For a node u in G ,  X  X   X   X  X  X  X  X  X  X  X  X   X | X  X  X  X   X   X   X   X  X . X  X   X   X  X  X   X  X  X  X . }. For each record, SOURCE stores u  X  X  children whose label contains the interval related with the SOURCE . Algorithm 3 illustrates the construction procedure of XUI. Based on the analysis in Section 3, we propose a novel messaging-based method, called UOGX, which makes full use of the indexing XUI to speed up the processing of updates. The main idea of our method drives from a discovery: 1) after deleting an edge ( v1, v2 ), if some node on the paths from a to v1 can still reach 2 X  X  X  X  X  X   X  , then a between some node on paths from 1 X  X  X  X  X a X  X  to u1 and 2 X  X  X  X  X  X  X  X  is not changed, then the reachability relationship between a X  and d X  mustn X  X  be changed. According to this discovery, we propose a bottom-up method to re-label nodes. We first define the structure of message queue, followed by the introduction of algorithms for insertion and deletion. 5.1 Insertions for Extended Interval Labeling In this section, we will describe how to use message queue to process the insertion of an edge in detail. affected. So nothing needs to do (Line 03). Otherwise, the labels of some nodes in A ( u ) may be changed. Lines 04-25 process this case. We first process the node u in lines 06-update the corresponding index item. According above discovery (2), the label of any node in A (u) needn X  X  be changed. So, we needn X  X  send messages to their parents we process u  X  X  ancestor nodes in D (lines 15-23) until the message queue is empty. For Otherwise, replace u or v with C X  and deal with it by algorithm 5. Complexity: In algorithm2, the dominating steps are lines 15-26. For each node v X  in MQ , we performs XUI updates once and at most max times (the maximum | v.ISet |) reachability tests in lines 18-25. We need less than Max * |E| times index updates and queue. Suppose m the maximum space cost of a piece of message in MS . The cost of space is less than m*Max * |V|, where |V| is the total number of nodes in D . Hence, in the worse case, the overall space complexity is O (| V |). 5.2 Deletions for Extended Interval Labeling Using XUI indexing, it is easy to check the reachability relationship between two nodes after deleting. In this section, we introduce how to use message queue and XUI indexing to process the deletion of an edge from the bottom up. 
In algorithm 3, Lines 01-02 deal with the deletion of a nesting edge. Others process reference edges. Lines 04-14 process u . In line 5, if i is contained by u.ID , then nodes represented by i still can be reached by u . So u  X  X  label needn X  X  be changed. According (1), we know all u  X  X  ancestors needn X  X  relabel too. So we needn X  X  send message to u  X  X  ancestors. Otherwise, update u  X  X  index in line 06. In line 07,  X  X  X  X . X  X  X  and  X  X   X  X . X  X  X UI X  means that all u  X  X  children can X  X  reach node n ( n.ID = i ), after deleting. So u must be relabeled (line 8) and send messages to its parents (lines 9-11).  X  X  X  X   X  X . X  X  X UI X  means that u can also reach n  X  descendant. Hence, we relabel u and send still able to reach n, so we need do nothing, according to discovery (1). Then process u  X  X  ancestors until the message queue is empty (lines 15-31). To relabel node v  X  message is insertion, then we only need update v  X  X ndex. In a MS , if there is a piece of insertion message, then there must be a piece of deletion message with the same interval. Therefore, if it needs to relabel v X  , we will do it in case2 (lines 20-31). Lines 20-31 are similar with lines05-14. In Lines30-31, the function Maximal ( M ) returns other interval in  X  X . X  X  X UI X  . Finally, we should remark that if u or v is in some SCC replace u or v with C X  and deal with it by algorithm 3. Complexity: In algorithm3, the dominating steps are lines 15-31. We perform lines16-Hence, we at most need max*|E| times reachability tests and | E | times XUI lookups. The overall time complexity is O (| E |), in the worst case. The main space cost is that of message queue. Suppose m the maximum space cost of a piece of message in MS . Hence, the cost of space is at most m* d*max* | V | , where d is the maximum fan-out . The overall space complexity is O (| V |) in the worse case. Fig.6 (b). After deleting ( e1, d2 ) and ( e2, d2 ), all indexes aren X  X  changed (the result is shown in Fig.7 (a)) and all labels aren X  X  changed, which concise with the fact that the and XUI[ C ]. RL. Because there is an interval [6, 7] in XUI[ C ], insert [6, 7] to C . ISet and send two pieces of messages to b1 and a1 (see Fig.7 (b)). Then MS [ b1 ] is out of queue and process b1 . Because [6, 7] and [5, 8] are contained by b1.ID , nothing needs f1 , after deleting the three edges. Intel R Core TM Duo CPU type E8300 with two cores at 2.83GHz. We implemented all our algorithms with C++. The dataset we tested were the XMark benchmark [10] and generating random graphs. XMark can be modeled as a graph with complicated schema and circles. To check the effect of density, we generated 5 random graphs with different density. Their parameters are shown in Table2. 
We are particularly interested in the following issues: the size of labeling and indexing and updates performance. In following, we will discuss in detail. 6.1 Size of Labeling and Indexing We performed an experiment with five different files in table2 and compared the results are depicted in Fig 8. From the results, we can see, firstly, the size of labeling and indexing increases sharply with the increase of density, and in 1.5, the maximum the DAG size will decrease when the density becomes larger, lot of nodes can share with the size of labeling. When the density is very small (for example, the structure of graph is close to a tree structure), our labeling scheme is very good. 6.2 Performance of Updates To check the performances of insertion and deletion, we randomly chose 100 edges in graph. First, we deleted these edges from the graph, and then inserted them into graph. 
In the experiment, we run our result in XMark data set and G2 because they have 46878.The results are depicted in Fig.9 and Fig.10. As we known, insertions and edges. 
First, consider the deletion. In Fig.9, the basic deletion algorithm is called b_delete optimal approach is better than the basic approach. Specially, when the graph is U_delete is less than half of that of b_delete in Fig.9 (b) . We can see XUI indexing is useful to speed up the processing of deletions. From the two pictures, we can get that the efficiency of deletions is related with the size of labels. Then consider the insertion of an edge. See Fig.10. The optimal algorithm is called U_insert and basic algorithm is called b_insert . Compared with deletion, the insertion is very easy. The results verify the collusion. The elapsed time of deletions is several hundred times of that of insertions with same edges. In some cases, the elapsed time However  X  using XUI indexing, U_delete can improve the performance of deletions and processing of deletion is the bottleneck of updates. So, it is worth to do that. We classify the related works into two categories, labeling schemes for graph data and incremental maintenances of interval labeling scheme. 
As we known, testing reachability relationships is a fundamental operator in queries on directed graphs. So far, a lot of labeling schemes have been proposed for this problem. 2-hop [5], optimal tree [2], optim al chain [4] are the well-known labeling schemes. Recently, Jin et al . proposed a labeling schemes 3-hop [6] for sparse graphs and dense graphs, and van Schaik et al. proposed a memory efficient labeling scheme PWAH [7] for very large graphs. However, these approaches can X  X  be used to label Graph-structured XML directly. There are two reasons: 1) Most of them are not suitable to be extended for labeling the document order. 2) Most of them are difficult to be maintained. In this paper, we choose a based-interval labeling to extend, because interval labeling has made a great success in labeling ordered Tree X  X tructured XML. 
On the other hand, there have been a lot of works to maintain interval labeling scheme for Tree-structured XML, such as CDQS [8], Float-point [9], and so on. All of them can be used to our approach to process the updates of nesting edges. To simplify, we choose Float-point in this paper. Float-point uses real values for the X  start X  and  X  X nd X  of intervals, so we can insert many real values between any two different real values. To the best of our knowledge, there haven X  X  been studies on processing of update of Graph-structured XML. In this paper, we focus on how to maintain the reachability relationship and the document order in Graph  X  X tructured XML. In this paper, we model XML with ID/IDF as an ordered directed graph, and propose an updatable extended interval labeling. After analyzing the inefficiency of processing updates of this labeling, we give a basic solution. To improve the Performance of updates, we design a novel indexing XUI. Finally, we present an efficient approach to deal with the updates of extended interval labeling, based on the XUI indexing and message-passing queue. The main idea of this method comes from our discovery as described as section5.2. Through experiment and analysis on XMARK data sets and five generated random graph. By the experiment results, we confirmed the effectiveness and efficienty of our method. 
In this paper, we deal with the problems on small data set, when the data becomes strongly connected component. Hence, in th e future, we will consider these problems. and section5.2 without consideration of the generation or destroy of a strongly connected component. 
