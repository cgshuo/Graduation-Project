 The availability and the accuracy of the data dictate the success of a data mining application. Increasingly, there is a need to resort to on-line data collection to address the problem of data availability. However, participants in on-line data collection applications are naturally distrustful of the data collector as well as their peer respondents, result-ing in inaccurate data collected as the respondents refuse to provide truthful data in fear of collusion attacks. The current anonymity-preserving solutions for on-line data col-lection are unable to adequately resist such attacks in a scal-able fashion. In this paper, we present an efficient anony-mous data collection protocol for a malicious environment such as the Internet. The protocol employs cryptographic and random shuffling techniques to preserve participants X  anonymity. The proposed method is collusion-resistant and guarantees that an attacker will be unable to breach an hon-est participant X  X  anonymity unless she controls all N -1 par-ticipants. In addition, our method is efficient and achieved 15-42% communication overhead reduction in comparison to the prior state-of-the-art methods.
 E.3 [ Data ]: Data Encryption; H.2.8 [ Information Sys-tems ]: Database Applications-Data Mining Algorithms, Security Privacy, Anonymity, Data Mining
Decision makers need data to guide their decision mak-ing through data mining. Many organizations are increas-ingly turning to on-line data collections services to obtain the data. For example, the human resource department of a large organization may wish to poll its employees for infor-mation such as how satisfied they are with respect to their bosses management skills in a corporate climate survey, a health organization may wish to collect data on people X  X  medical status, or a government agency may wish to data mine the people X  X  opinions on a newly introduced policy. Protection of privacy becomes an important problem [1] as even a routine market survey often involve collection of sen-sitive personal information (e.g. education level, martial status, household income, etc.).

While the Internet may be a cost-effective platform for large-scale data collection for data mining, the accuracy of the data collected using on-line methods can be compro-mised due to concerns of privacy breaches. It is naive to expect participants in on-line data collection applications to be fully trusting of the data collector as well as the peer respondents, as collusion attacks can easily undermine con-ventional methods for preserving anonymity [17] of the re-spondents. Such distrust can lead to the respondents to provide incorrect data as a desperate means to protect their privacy [2-4].

As the availability and the accuracy of the data dictate the success of a data mining application, it is of interest to the data mining community to devise a data collection method that can preserve anonymity in a malicious on-line environment. Anonymity, accuracy and efficiency are key is-sues that should be taken into consideration when designing protocols for practical online data collection. In particu-lar, the data collection protocol should work well in a setup in which the respondents are mutually distrusting and the data collector is possibly dishonest. Unfortunately, the cur-rent anonymity-preserving solutions for on-line data collec-tion are unable to adequately resist collusion attacks in a scalable fashion. In fact, we observe that even the currently best anonymous data collection method for data mining [2,3] will put an honest respondent X  X  anonymity at risk if the data collector collaborates with a single dishonest participant (see Appendix A).

In this paper, we propose an efficient anonymity preserv-ing data collection protocol that works in a malicious sce-nario in which a possibly dishonest data collector is tasked to collect potentially private and sensitive data from a large number of mutually distrusting individuals in such an inher-ently insecure environment as the Internet. The proposed protocol is based on cryptographic and shuffling techniques and incorporates additional techniques to address the fol-lowing needs of anonymous online data collection:
Various anonymity-preserving data collection models have been proposed recently. We summarize them into three rep-resentative classes below.

Randomized response : The respondents are required to perturb some of their sensitive response before submit-ting to the data miner. The more perturbed the data are, the more privacy is guaranteed. For example, for a query expecting a binary answer (e.g. what is a respondent X  X  gen-der), the respondent could flip a bias coin and alters her response if the coin comes up with the head [7]. As long as the parameters of the perturbation process (e.g. the bias) are also shared with the data miner, the data miner could modify his algorithms accordingly so as to discover results comparable to that with the original (i.e. non-perturbed) responses. The privacy of the respondents is protected indi-rectly as the data collector can never be certain about the truthfulness of a response [10-12]. However, there is an in-advertent tradeoff in the data mining accuracy because of the noise that had been introduced into the data. In many applications, this is simply not an acceptable tradeoff. Our technique proposed in this paper is designed to provide the data miner with exact, unperturbed responses. This way, there is no need to modify any data mining algorithms, and there is no needless sacrifice on the accuracy of the results for preserving anonymity.

Cryptographic techniques : This class of anonymity preserving data collection techniques is best illustrated by the one presented in [2] 1 . Each respondent first encrypts her response using a set of public keys (i.e. all participant X  X  key) before sending it to the data collector. The data collector then forwards the set of responses back to each respondent sequentially. One by one, the respondent will strip off a layer of encryption from each of the responses, shuffle the
The protocol presented in [3] also employs similar tech-niques as [2] but it requires a much higher communication overhead to achieve the same level of anonymity. responses and then transmit them back to the collector who will then send them to the next responder to process them similarly. At the end of this sequential randomization pro-cess, the data collector sends the randomized responses (i.e. the randomized responses that data collector received from the final responder) to all responders for verification. How-ever, despite the laborious encryption and shuffling, such methods are not collusion resistant. A dishonest data collec-tor could easily reveal the identity of an honest respondent if it collaborates with other dishonest respondents during the course of the protocol (see appendix). In this work, we make sure that our proposed technique is efficient and at the same time collusion resistant.

Mix networks : Recently, mix networks such as onion route [5, 16], Crowds [15], k -anonymous message transmis-sion [11], Hordes [13], and DC-nets [6, 21, 22] have been de-vised for anonymous communications over public networks (e.g. anonymous Internet browsing) by hiding the identi-ties of the message senders. It is a probabilistic approach where an honest respondent X  X  response will only reach to the data collector if all of the intermediate hops (i.e. ORs) act honestly. In fact, that is very far fetched assumption in ma-licious environment where neither the respondents X  nor the data collector has mutual trust. As the mix networks aim to hide the respondent identity, a dishonest respondent could utilize this opportunity and sends many responses to the data collector which clearly diminishes the goal of the data collection at the first place. Moreover, if a malicious adver-sary controls some portion of the network then she can reveal the honest respondents identity to the data collector. In this work, we safeguard an honest respondent X  X  anonymity from such collusion attacks as well as ensure respondents X  message integrity that the data collection applications needed.
Let r = { r i | i = 1 ...N } be the response of a set of N respondents R = { R 1 ,...,R N } and DC is data collector. The data collector DC would like to collect response from each of the respondents R i . A response that the data collector DC obtains is said to be anonymous if the respondent R of that response appears to be no more likely the originator of the response than any of the other respondents who are participating in that data collection exercise.

We formally define an online anonymity preserving data collection protocol as follows:
Definition 1. Let A be a probabilistic polynomial-time algorithm and P be the online data collection protocol. The protocol P is anonymous if for every pair of respondents R ,R j  X  R , for every plaintext response r 0  X  r , P ( R i and P ( R j ,r 0 ,  X  ) are computationally indistinguishable such that Pr [ A ( R i ,r 0 ) = 1] = Pr [ A ( R j ,r 0 ) = 1].
To better achieve a respondents X  anonymity as well as the confidentiality of all responses that the data collector re-ceived, one can employ a probabilistic encryption scheme in which a plaintext message could have one of many pos-sible ciphertexts. Probabilistic encryption algorithms are said to be semantically secure  X  that is, it is infeasible for a computationally-bounded adversary to derive significant in-formation about a message (plaintext) when given only its ciphertext.

Definition 2 (Oded Goldreich [9]). A public key en-cryption scheme ( K , E , D ) is semantically secure if for ev-ery probabilistic polynomial-time algorithm A there exists a probabilistic polynomial-time algorithm A 0 such that for every { X n } n  X  N , for every pair of polynomially bounded functions f,h : { 0 , 1 }  X   X  { 0 , 1 }  X  , every polynomial p and all sufficiently large n Pr h A (1 n , K
The problem of anonymity preserving online data collec-tion among mutually distrustful participants is basically in designing a protocol that can obtain a random permutation of all the respondents X  responses { r 1 ,...,r N } from which the data collector is unable to breach an honest respondent X  X  anonymity. Given an honest respondent R i in online sce-narios is unable to appraise her follow peers, the challenge is how to protect an honest respondent R i  X  X  anonymity in an hostile environment where an adversary of the system may have control over as many as ( N -2) corrupt respondents of the system.

While a high level of anonymity is clearly desired, a dis-honest respondent in the system could exploit it as an op-portunity to pose a threat to the integrity of the responses. The protocol must therefore serve a dual goal of preserving respondent anonymity as described, and at the same time ensuring the integrity of the system such that the result in random permutation is free from any malicious responses.
Current methods often make efficiency tradeoffs for the price of anonymity. Attempts to achieve fool-proof anonymity have heavily relied on computational and communication in-tensive operations, resulting in overheads that render them impractical for online data collection scenarios. Therefore, we should also focus on designing a more efficient online data collection protocol that minimizes the computational and communication overhead.
In this section, we propose a collusion resistant data collec-tion method that safeguards all honest respondents anonymity effectively and efficiently in a malicious model [9]. In the proposed protocol, the data collector collects the respon-dents X  encrypted responses in a one-to-one fashion. In this way, she assures that all responses are coming from legit-imate respondents. Although the data collector obtains a random permutation of all plaintext responses at the end of a successful protocol execution, she is unable to pose any threat to an honest respondent X  X  anonymity. It is important to mention that in our protocol, the respondents also rigor-ously verify all intermediate computation results before the data collector obtains this random permutation of all plain-text responses. As such, any deviation in protocol execution will be known by all participants, foiling any possible threats to their anonymity by such manipulations.

Before we go into the details of our proposed protocol, let us outline our assumptions on the respondents and the data collector: 1. Prior to exchanging a response with the data collec-2. As the different sizes of the responses in the response 3. Each of the respondents performs all encryption and/or
We describe the two building blocks used in our proposed anonymity preserving data collection protocol.

Substitution Cipher: A substitution cipher is an en-cryption technique that typically involves replacing one or more entities of the plaintext (single letters, or pairs of let-ters or composition, etc.) with other symbols or groups of symbols [8]. There are a number of different types of sub-stitution ciphers. Caesar Cipher is one of the simplest and most widely known substitute cipher techniques. It simply substitutes each character of a plaintext with a character of some fixed number of positions further down the alphabet.
ElGamal Crypto: ElGamal is a randomized asymmetric public key encryption scheme. Let p be a large random prime and g be a generator of the multiplicative group Z p The private key S is an integer chosen at random between 0 and p  X  2. The public key for ElGamal encryption is then the triplet ( p,g,Y ), where Y = g S mod p . To encrypt a plain text m  X  Z p , a random integer r relatively prime to p  X  1 is selected and a pair C =( C 1  X  g r mod p , C 2  X  mY mod p ) is computed as the cipher text message. To decrypt the cipher text message C given the private key S, we can compute m = C 2 /C S 1 = mY r /g rS = mg Sr /g rS . This can be computed in polynomial time. For more details, interested readers please see [19].
Although the ElGamal technique achieves semantic secu-rity 2 given that decisional Diffie-Hellman assumption (DDH) holds in Z p , it is malleable. As such, direct adoption of this is clearly unable to protect an honest respondent X  X  anonymity. On the other hand, the substitution cipher described ear-lier has very few keys compared to any modern crypto sys-tems. Employing only this technique in anonymity preserv-ing data collection protocol does not preserve the respon-dents X  anonymity.

Since malleability is the primary issue that an attacker may utilize to reveal an honest respondent X  X , we propose here a hybrid crypto model that uses both ElGamal and Substitution cipher to prevent malleability attack of ElGa-mal method. It is important to note that prior protocol em-ploys non-malleable encryption methods Cremar-Shoup[18] but may reveal an honest X  X  respondent identity in a mali-cious environment (see appendix). As such, the rationale of this hybrid model is not design a non-malleable encryp-tion method rather a non-reversible encryption process and it can be describes as follows. As the ElGamal method is semantically secure, the ciphertext it produces from a plain-text message m is random at { 0 , 1 } k . On the other hand, Indistinguishable under Chosen Plaintext Attack (IND-CPA) attack the substitution cipher can conceal the original plaintext m from an attacker if the ciphertext it generates is encrypted using ElGamal. As the ciphertext c of an original plaintext message m that substitution cipher method generates will be encrypted with ElGamal. Thus any malleability that the ElGamal method has in the encrypted result is only related to the cipher text c and not to the original plaintext message m .
 The proposed hybrid crypto model, which we denote as Onion , has three layers of encryption. Let S and Y be the private and public key of the ElGamal encryption. The first layer takes an original plaintext message m and encrypts it using the public key Y . The encrypted result (for simplicity, let us denote it as the intermediate result) is re-ciphered using a substitution cipher method f . Finally, the result in cipher text is encrypted again using the public key Y to give the desired Onion O = E Y [ f [ E Y ( m )]]. To decrypt an onion O , first, the private key S is applied to an onion and strips off a layer of encryption. Then, the result in decryption result is de-ciphered using an inverse substitution cipher method. Finally, the de-cipher result is again decrypted using the private key S which reveals the original plaintext message m such that m = D S f  X  1 [ D S ( O )] .
 Let us now describe the details of our substitution method. The substitution cipher we use is similar to ROT-13 [8]; but to make it more probabilistic, we do not add a fixed num-ber to every character. Instead we generate a new substi-tution number for every digit except the most significant digit 3 Each of the digit is replaced in an order and the substitution process iterates from left to right digits of a number. The cipher text (replacement digit) for each of the digits is obtained as: d 0 [ i ] = ( d [ i  X  1] + d [ i ]) mod 10. To de-cipher each of the cipher digits it computes d (10 + d [ i ]  X  d 0 [ i  X  1]) mod 10 and obtains the plaintext digit. For example, to encrypt a plaintext message 1234567890 our proposed substitution method works as follows: at first, it encrypts the 2nd most significant digit that is d [1] = 2 and finds the corresponding cipher d 0 [ i ] = ( d [ i  X  1] + d [ i ]) mod 10 = (1 + 2) mod 10 = 3. Then it takes the next digit 3 and computes d 0 [2] = ( d [1] + d [2]) mod 10 = (2 + 3) mod 10=5. The process continues for all of the remaining digits and we obtain the result in cipher text 1357913579 at the end. To de-cipher, we first take the second most significant cipher digit, which is 3 in this case and compute d (10 + d [ i ]  X  d 0 [ i  X  1]) mod 10 = (10 + 3  X  1) mod 10 = 2. Next, we take cipher digit 5 and find the de-cipher digit as d [ i ] = (10 + d [2]  X  d 0 [1]) mod 10 = (10 + 5  X  2) mod 10 = 3. We continue this process and each of the digit is de-ciphered until we reach the right most cipher digit.
Proposition 1 : Let C i = ( c 0 ,c 1 ) be the onion of an un-known plaintext message m and an adversary is able to gen-erate a valid encryption of C such that C 0 = ( c 0 , X c 1 their decryption results in m and M such that M 6 =  X m .
Proof: Each onion has three layers of encryption. To obtain a plaintext from an onion it needs two decryptions as well as in between these decryptions an inverse substitution function f  X  1 . Let S and Y be Alice X  s private and public key and f be the public substitution cipher. Assume Bob
Here we assume the plain text length (i.e. number of dig-its) is smaller than the length of the p , the prime number use in the ElGamal crypto system. If not, the substitution process will start from the latter digits so that the result in substitution ciphertext is smaller than p . uses Alice X  s public key Y and substitution cipher f to make an onion C . Let Carol be an adversary who has access to C , tries to generate an valid encryption C 0 = ( c 0 , X c would like to know whether decryption of onion C 0 (i.e. M is equal to  X m ), where m is the decrypted result of onion C . To achieve that suppose Carol impersonate Bob and successfully sends both C i and C i +1 to Alice . Upon receiving these onions Alice first strips off a layer of encryption from them and obtains the decryption results as: Z = c 1 /c S 0 Z 0 =  X c 1 /c S 0 . At this point, Z 0 =  X Z , given that Z = c and Z 0 =  X c 1 /c S 0  X   X Z mod  X  . Alice then employs inverse substitution function f  X  1 to de-cipher the decryption result and obtains Q = f  X  1 ( Z ) and Q 0 = f  X  1 ( Z 0 ).
Let us assume Q 0 =  X Q . As such, f (  X Q mod  X  )  X   X Z mod  X  . Alternatively, we can say f (  X Q ) should yield the same value as  X Z , given that the f (  X Q ) / X   X  Z and  X  is constant. Since different arithmetic operations order results in different values thus  X Z =  X f ( Q ) 6 = f (  X Q ) which implies Q 0 6 =  X Q . As such,the subsequent decryption m = Q/c S 0 and M = Q 0 / c S 0 that Alice employs to Q and Q 0 will also result in M and m 0 such that M 6 =  X m .
Our proposed protocol has five distinct phases: (i) data preparation, (ii) data submission (iii) anonymization (iv) verification and (v) decryption and result. In phase (i), all respondents will each carry out their own preparatory local processing to generate an encrypted response and the cor-responding partial intermediate verification code. In phase (ii), the respondents ship their encrypted response and the partial verification code to the data collector. The data col-lector combines these partial intermediate verification code, and the result in code is forwarded to all respondents. In phase (iii), the data collector sends all encrypted responses back to each of the respondents sequentially. Each respon-dent will perform decryption, shuffle the decryption results, generate partial intermediate results and then send these randomized responses along with the partial intermediate code back to the data collector. The process continues un-til the data collector has received the randomized responses from the last respondent. In phase (iv), each respondent will verify the honesty of her peers X  participants and decide whether she will continue or terminate based on the veri-fication outcomes. Finally in phase (v), the data collector generates a random permutation of all plaintext responses if all respondents succeed in the verification phase.
Before initiating the protocol, all respondents agree to generate a secondary key pair { s,y } defined over multiplica-tive group Z  X  , where s is private key, y is public key and  X  = p . All respondents send the respective secondary keys to the data collector who forwards these keys to all partici-pants. i. Data Preparation 1. At first, each respondent R i encrypts its response  X  2. Each of the respondents R i then proceeds as follows. 3. Each of the respondent R i generates a digital signa-ii. Data Submission 4. Each of the respondent R i sends  X  00 i ,  X  i and v i 5. The data collector computes the verification code  X  C 6. The data collector applies her secondary public key en-7. Finally, the data collector sets the initial response set iii. Anonymization 8. The data collector sends a response set to each of the iv. Verification 9. From the random response set  X  that the data collec-10. Then, the data collector sends its secondary secret key 11. All respondents also verify the signature of all partial 12. Each of the respondents R i verifies whether  X  C v. Decryption 13. The data collector uses these secondary secret keys and
Proposition 2 : If all respondents are honest then B = ( g  X  i is the respondent R i  X  X  original secondary encryption.
Proof : Let  X  = {  X  0 1  X  X  X   X  0 N } be the respondents X  orig-inal secondary encrypted result set. Recall in the proto-col, during the anonymization phase, each respondent R strips off the corresponding primary encryption layers that she employed earlier. Given that all the respondents are data collector will have received a random response set  X  = {  X  1  X  X  X   X  N } , where each of the  X  i is some respondent X  X  original secondary result  X  j and  X   X   X  =  X  . As such,
Proposition 3 : If all participants are honest then two intermediate verification codes have the same outcome.
Proof : Each of the respondents computes the intermedi-ate verification code when she employs the primary keys of others. Let us assume that R = R 1 ,  X  X  X  ,R N be the set of respondents and  X  0 i is the R i  X  X  encrypted response that she already encrypted with the data collector and all the respon-dents secondary public keys. During the data preparation phase each R 0 i s also applies all respondents X  primary public keys to  X  0 i two times. In other words, respondent R i at first encrypts  X  0 i using her peer respondent R 0 j s primary public key and obtains an intermediate result. She keeps a copy of this result. Next, R i applies f to this result and then she employs R 0 j s primary public key to the resultant value. At the end, R i generates a partial intermediate verification code using these intermediate results that she kept earlier. Similarly, during the anonymization phase each respondent R i decrypts the response set that she received from the data collector twice. At first, she decrypts the response set using her primary secret key and applies f  X  1 to obtain an interme-diate result set. She then computes the partial intermediate verification code using this set and finally decrypts this set with her primary secret key.

M =
Let M be the matrix of all intermediate encrypt results X , its X  column denotes the respondents and the row denotes the different layer of encryption. The respondent R 0 i s inter-mediate verification codes  X  i at data preparation phase is the partial intermediate verification codes  X  i at anonymiza-tion phase is equal to  X  00 1 i  X   X  00 2 i  X   X  00 3 i mod  X  . As such, the verification code that the data col-lector generates at data preparation phase is equal to  X  C ( c r 1  X  X  X  X  X  c 1 r N  X  X  X  X  X  c N r 1  X  X  X  X  c N r N  X  b 1  X   X  X  X  X  X  b  X  . And the verification code that each of the respondents computes at the verification phase is equal to  X  V = ( c 1  X  X  X  X  c N r 1  X  c 1 r N  X  X  X  X  c N r N  X  b 1  X   X  X  X  X  b N  X   X  B ) mod  X   X  ( c r 1  X  X  X  X  X  c N r 1  X  c 1 r N  X  X  X  X  c N r N  X  b 1  X   X  X  X  X  b N commutative, this implies the  X  C and  X  V are also equal if and only if all the factors that used to generate them are remained the same.
In this section, we verify if an honest respondent X  X  anony-mity as well as the secrecy of her response are well protected under our protocol.
Respondents in online data collection exercises typically know little or nothing about her peers. As such, to preserve an honest respondent X  X  anonymity in a malicious adversary model, an anonymity preserving data collection protocol should be prepared against any potential collusion attack in which the malicious collector and/or malicious respon-dents collude to reveal an honest respondent anonymity. In our model, we do not consider an extreme case (where N -1 respondent collude with the data collector). Rather, we con-sider a scenario where N -2 respondent and the data collector colludes to breach an honest respondent anonymity.

Proposition 4 : The random response set that the data collector received from an honest respondent R i during the anonymization phase is computationally indistinguishable as long as there are t honest respondents such that t  X  2.
Proof: During anonymization phase, respondent R i strips off three layers of encryption from every response she re-ceived from the data collector. R i then randomly shuffles each element and sends that random set to the data col-lector. Suppose C j  X   X  is an element of the set that the data collector sent to respondent R i . Let  X  0 be the ran-dom response set that R i sends to the data collector. To nullify our claim that the random responses that the data collector receives during the anonymization phase are indis-tinguishable we need to show { C 0 k  X   X  0 | C 0 k = E [ f [ E ( C If C 0 k = E f E ( C 0 j is true then according to Definition 2, the C j is the one of the n possible encryption result of C . Since random response set  X  0 has N elements, this im-plies that all other elements of set  X  0 may also have same encryption result as C 0 k . Let us assume all participating respondents are honest. As such, the probability the data collector could achieve that C 0 k = E f E C 0 j is equal to Pr [ A ( C 0 k ,C j ) = 1] = 1 /N where N is the total number of elements in the random response set, and A is a probabilis-tic polynomial-time adversary algorithm. The only way the data collector could contradict our indistinguishable claim if she succeeds to carried out a subtle malleability attack on the encrypted response set. For example, let C j = ( C 0 and the data collector generates C 0 j = ( C 0 , X C 1 ) such that at the end of anonymization phase she could fine two elements sition 1 that the decryption of C 0 j and C 0 j only result in C and C 00 k such that C 00 k 6 =  X C 0 k , thus the malleability attack that the data collector attempt fails to distinguish any two responses from the random response set.

Now, let us assume a scenario where the data collector collaborates with a set of corrupt respondents R corrupt  X  R such that ( | R | X  X  R corrupt | ) = t and  X  0  X   X  be the corrupt respondents responses. To distinguish honest respondents from random responses, respondent in R corrupt could as-sist the data collector to exclude their random responses  X  from  X  0 . As such, the data collector obtains probability Pr [ A ( C 0 k ,C j ) = 1] = 1 /t . Let us assume t  X  2, therefore plies each honest respondent response in the set {  X   X   X  0 are indistinguishable.

Proposition 5 : All honest respondents terminate the protocol execution if there is any deviation.

Proof : Let us assume R honest  X  R and | R honest | X  2 | be the set of honest respondents and  X  = {  X  0 1 ,  X  X  X  , X  0 N all respondents X  secondary encryption result set. At Phase (i), an honest respondent R i  X  R honest applies all respon-dent primary key to re-encrypt her secondary encryption result. During the re-encryption process she also computes a partial intermediate verification code  X  i . The partial ver-ification code is then encrypted using a key b i  X  where  X  0 i is the respondent X  X  R i  X  X  response and sends the re-sult in encrypted value to the data collector. As the encryp-tion result is semantically secure, any adversary including the data collector is unable to discover the original  X  i Phase (ii), the data collector combines all these intermedi-ate results, generates an intermediate verification code  X  and forwards  X  C to all respondents. In Phase (iii), all re-spondents generate another partial intermediate verification code  X  i after performing a decryption to the set  X  that she received from the data collector. The factors that use to generate  X  i are different form  X  i that R i generated earlier. The result in encrypted value  X  i is re-encrypted with a key b its digital signature along with the random response set to the data collector who forwards this the partial verification pair to all respondents. In phase (iv) the data collector computes final secondary encryption B = g  X  1  X  X  X  X   X  g  X  N , where  X  is the random response set she received from the last respondent R N . If all respondents perform honestly then  X   X   X  =  X  . The data collector forwards B and her secondary private key s DM to all respondents. Each respon-dent uses both B and s DM and verify her peers respondent honesty.

Let us assume some of the dishonest respondents intend to corrupt the response set by replacing some of the re-sponses during their respective processing at the anonymiza-tion phase. As such, the random response set  X  that the data collector will use to generate the final secondary encryp-tion result B will not contain all elements of set  X . There-fore, at the verification phase all honest respondents will generate two different verification codes and subsequently terminate from the protocol execution.
Each of the respondents submits their encrypted response to the data collector in an one-to-one fashion. This guar-antees that at the submission phase, the data collector suc-cessfully collects all encrypted responses from every valid re-spondent. During the anonymization phase, these encrypted responses are sent back to each of the respondents one by one, who then performs decryption and shuffling operations at her own process space over which the data collector has no control. As such, a dishonest respondent may alter or replace some of the encrypted responses without letting the data collector know. In fact, any multi-party computation based protocol inherently possesses this drawback and is very difficult to overcome[20, 23].

However, performing such malicious acts to corrupt the original response set that the data collector wishes to col-lect will never succeed, thus the integrity remains uncompro-mised. This is because if any dishonest respondent carries out such malicious manipulation, then her partial interme-diate verification code will also be corrupted. Subsequently, in the verification phase, the intermediate verification codes that each of the respondents generates using these interme-diate results will differ in value from the verification code (i.e. after performing decryption using the data collector X  X  secondary secret key) they had received from the data collec-tor. Consequently, all honest respondents including the data collector will come to know about such malicious acts and none of the respondents will submit their secondary secret key to the data collector. As such, the malicious attempt that the dishonest respondent made will not incur any in-centive.

On the other hand, if there is no manipulation during the anonymization phase, then each of the respondents will succeed in the verification phase. As such, they will ship their secondary private keys to the data collector. The data collector uses these keys as well as her own primary private key to remove the remaining layer of encryption that each of the random responses has. Therefore, the data collector suc-ceeds in collecting a random permutation of all respondents X  plaintext responses.
Each of the respondents submits their encrypted response directly to the data collector. The encrypted responses the data collector obtained are never exposed to any other re-spondent. During the anonymization phase, each respon-dent receives a set of encrypted response from which she (assuming she has no collaborator) cannot distinguish any response other than her own. As each responses has at least N +1 layers of encryption, she is unable to find the plaintext of those responses. In fact, if she collaborates with other n number of respondents such that n  X  ( N  X  2) then she will still be unable to decrypt these responses. Thus there is no confidentiality breach during the anonymization phase. At the verification phase, the data collector holds the random-ized response set and only collects respondents X  secondary keys in an one-to-one manner if the verification succeed. As the data collector alone will use these secondary keys at the decryption phase to decrypt the randomized response set, none of the respondents will be able to reveal any of the plaintext responses.

It is important to note that similar to other anonymity preserving data collection methods [2, 3], we are unable to make any confidentiality claims if the data collector reveals plaintext responses to a respondent. However, as we have seen from the plaintext response set the data collector could not find any association between a response and its respon-dent. Thus revealing plaintext response to a respondent will neither bring any additional benefit to her.
Let us now analyze the computational complexity and the communication costs of our proposed protocol.

In Phase (i), each respondent performs N +2 modular ex-ponentiations (assuming participants use the same modular exponentiations to perform two ElGamal encryption oper-ations for each of the onion), N substitution encryptions, N modular multiplications and generates a signature. In Phase (ii), each respondent performs a single signature veri-fication. In Phase (iii), each of the respondents performs 2 N modular divisions, N substitution decryptions, N modular multiplications as well as generates a digital signature and verifies N signatures. In Phase (iv), each of the respondents computes N modular multiplications. Based on the above analysis, we can conclude the average computational com-plexity for each respondent is O ( N ). On the other hand, the data collector receives N encrypted responses and verifies N signatures in Phase 2 and perform 1 encryption, N multipli-cations as well as generates a message signature. In Phase 3, the data collector verifies N signatures. In Phase (iv), the data collector performs N modular exponentiations and in Phase (v), N 2 + N modular divisions. Based on the above analysis, we can conclude the computational complexity of the data collector is O ( N 2 ).

Let us now consider the communication complexity. Be-fore embarking on the protocol execution each respondent and the data collector collect N primary public keys as well as N secondary public keys, which require two rounds of communication. Suppose that each of the primary and sec-ondary public keys has K bits and each digital signature has S bits; the total communication cost of this phase is ( K + S )  X  N 2 . In Phase (i), neither of the respondents nor the data collector are involve in any external communication. In Phase (ii), each respondent sends an encrypted response, a partial intermediate verification code and a signature to the data collector. Each of the respondents receives a verifica-tion code and its signature from the data collector. Suppose that each encrypted response is X bits, verification code V bits and signature has S bits long; the total communica-tion cost of this phase is equal to ( X + 2 V + 2 S )  X  N . In Phase (iii), the data collector sends the encrypted response set that she collected from all respondents to each of them sequentially and receives a random response set, a partial verification code and a digital signature. The data collector also forwards a partial verification code and its signature to all respondents. The total communication cost of this Phase is equal to (2 X + V + S )  X  N 2 . During Phase (iv), the data collector sends a private key and a encrypted result to all respondents. If the respondents succeed in the verification phase, then the data collector receives a secret key from all respondents, thus the communication cost is equal to 3 NK . Phase 5 is not involved in any communications. The total communication cost of our protocol is thus the aggregate communication cost of the four phases:
Cost = ( X +2 V +3 K +2 S )  X  N +(2 X + K + V + S )  X  N 2
We compare our proposed protocol with the current best-known anonymity preserving data collection method, Effi-cient Anonymity-Preserving Data Collection (EAPDC) [2]. Note that although the protocol outlined in [3] is also similar to EAPDC, we do not include it in this comparison study because of the excessive communication overhead that it re-quires to achieve the similar level of anonymity as EAPDC. In our simulation experiment, we assume the primary and secondary public keys that each participant uses are 1024 bits, the digital signature is 128 bits and the verification code is 1024 bits long. The EAPDC method employs a cryp-tographic technique that consists of five different phases. As mentioned by the EAPDC authors, the communication cost of EAPDC is calculated as follows:
Cost EAPDC = ( K + 3 X + 2 S )  X  N 2 + ( X + K + S )  X  N We use formulae (1) and (2) to compare the total number of bits of data transmission incurred by our proposed proto-col and EAPDC. At first, we keep the respondent X  X  response length as constant (i.e. response size is equal to 2048 bits) and calculate the total number of bits each of those meth-ods transmitted by varying the total number of respondents. Then we keep the total number of respondents as constant (i.e. 100 respondents) and compute the total number of bits each of those methods transmitted by varying the length of response size. Figure 1(a) and 1(b) shows the comparison between the two methods in these settings.

From the figure, it is clear that our proposed onion-route based method transmitted a significantly lower number of bits of data as compared to the EAPDC protocol. At differ-ent settings our proposed method transmitted only between 15 to 42 percent less data than data transmitted by EAPDC. Similar to our protocol, each of the respondents in EAPDC receives all responses that they submitted to the data col-lector, who strips off a layer of encryption, shuffles each of the responses randomly and then sends these random re-sponses back to the data collector, this implies respondents X  responses are sent back and forth between the data collec-tor and all respondents at least N times. However, in the EAPDC protocol, once all respondents performed their re-spective shuffling, the data collector broadcasts the entire response set to each of the respondents who verifies those random responses and find the honesty of her peers X  re-spondents. This was not required in our proposed protocol. For verification, our method needs to exchange the interme-diate verification code rather than entire random response set to each of the respondents consequently minimizes com-munication overhead. It is also worth mentioning that the data transmission ratio between the proposed method and EAPDC increases as the length of the response increases (e.g. the ratio is around 15% when response size is 2 Kbits long, and it increases up to 42% when response size is 12 Kbits as illustrated in the Figure 1(b)). This means that our protocol is indeed much better suited for data collection scenarios.
The inherent insecurity of the online environment under-mines its effectiveness as a cost-effective data collection plat-form for data mining applications. Anonymity, accuracy and efficiency are key issues that should be taken into consid-eration. However, the current data collection methods are either inadequately resistant to malicious attacks, or are not sufficiently scalable for the potentially large numbers of re-spondents involved in online data collections. Some of the methods even introduced inaccuracies into the data as a way to protect the respondents X  anonymity.

We have proposed an efficient anonymity-preserving data collection protocol that is suitable for collecting private data from a large number of mutually distrusting individuals by an untrusted data collector in an insecure online environ-ment. The proposed method is both collusion and tamper resistant, and it allows the data collector to receive the re-sponses correctly even in adversarial situations. With a re-duction of 15-42% communication overhead, our method is highly efficient for online data collection scenarios that typi-cally involve large numbers of respondents. By ensuring the anonymity of respondents even in a malicious environment, we hope that the respondents will be encouraged to respond truthfully, resulting in accurate data collected to ensure the success of the data mining applications. [1] R. Agrawal, A. Evfimievski, and R. Srikant.
 [2] J. Brickell and V. Shamatikov. Efficient Anonymity [3] Z. Yang, S. Zhong and R. N. Wright. Anonymity [4] P. Golle, F. McSherry and I. Mironov. Data Collection [5] D. Chaum. Untraceable electronic mail, return [6] D. Chaum. The dining cryptographers problem: [7] S. L. Warner. Randomized response: A survey [8] B. Schneier, Applied Cryptography, 2nd Edition, John [9] O. Golderich. Foundation of Cryptography. Cambridge [10] A. Evfimievski , J. Gehrke and R. Srikant. Limiting [11] A. Evfimievski, R. Srikant, R. Agrawal and J. Gehrke. [12] A. Ambainis, M. Jakobsson, and H. Lipmaa.
 [13] L. V. Ahn, A. Bortz and N. J. Hopper. k -anonymous [14] B. N. Levine and C. Shields. Hordes: a multicast [15] M. K. Reiter and A. D. Rubin. Crowds: Anonymity [16] P. F. Syverson and D. M. Goldschlag and Michael G. [17] A. Pftzmann and M. K  X  ohntopp. Anonymity, [18] R. Cramer and V. Shoup. A practical public key [19] T. ElGamal. A Public-Key Cryptosystem and a [20] G, Oded (2002). Secure multi-party computation. [21] M. Waidner. Unconditional sender and recipient [22] P. Golle and A. Juels. Dining cryptographers revisited. [23] Y. Li, J. D. Tygar, and J. M. Hellerstein. Private
