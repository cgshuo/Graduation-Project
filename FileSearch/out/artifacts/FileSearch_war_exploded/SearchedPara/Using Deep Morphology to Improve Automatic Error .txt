 After years of development, optical character recog-nition (OCR) for Latin-character languages, such as English, has been refined greatly. Arabic, however, possesses a complex orthography and morphology that makes OCR more difficult (M X rgner and Abed, 2009; Halima and Alimi, 2009; Magdy and Dar-wish, 2006). Because of this, only a few systems for Arabic OCR of printed text have been devel-oped, and these have not been thoroughly evalu-ated (M X rgner and Abed, 2009). OCR of Arabic handwritten text (handwriting recognition, or HR), whether online or offline, is even more challenging compared to printed Arabic OCR, where the unifor-mity of letter shapes and other factors allow for eas-ier recognition (Biadsy et al., 2006; Natarajan et al., 2008; Saleem et al., 2009).

OCR and HR systems are often improved by per-forming post-processing; these are attempts to eval-uate whether each word, phrase or sentence in the OCR/HR output is legal and/or probable. When an illegal word or phrase is discovered (error detec-tion), these systems usually attempt to generate a le-gal alternative (error correction). In this paper, we present a HR error detection system that uses deep lexical and morphological feature models to locate possible "problem zones"  X  words or phrases that are likely incorrect  X  in Arabic HR output. We use an off-the-shelf HR system (Natarajan et al., 2008; Saleem et al., 2009) to generate an N-best list of hy-potheses for each of several scanned segments of Arabic handwriting. Our problem zone detection (PZD) system then tags the potentially erroneous (problem) words. A subsequent HR post-processing system can then focus its effort on these words when generating additional alternative hypotheses. We only discuss the PZD system and not the task of new hypothesis generation; the evaluation is on er-ror/problem identification. PZD can also be useful in highlighting erroneous text for human post-editors.
This paper is structured as follows: Section 2 pro-vides background on the difficulties of the Arabic HR task. Section 3 presents an analysis of HR er-rors and defines what is considered a problem zone to be tagged. The experimental features, data and other variables are outlined in Section 4. The exper-iments are presented and discussed in Section 5. We discuss and compare to some related work in detail in Section 6. Conclusions and suggested avenues of for future progress are presented in Section 7. Arabic has several orthographic and morphological properties that make HR challenging (Darwish and Oard, 2002; Magdy and Darwish, 2006; M X rgner and Abed, 2009). 2.1 Arabic Orthography Challenges The use of cursive, connected script creates prob-lems in that it becomes more difficult for a machine to distinguish between individual characters. This is certainly not a property unique to Arabic; methods developed for other cursive script languages (such as Hidden Markov Models) can be applied success-fully to Arabic (Natarajan et al., 2008; Saleem et al., 2009; M X rgner and Abed, 2009; Lu et al., 1999).
Arabic writers often make use of elongation (tatweel/kashida) to beautify the script. Arabic also contains certain ligature constructions that require consideration during OCR/HR (Darwish and Oard, 2002). Sets of dots and optional diacritic markers are used to create character distinctions in Arabic. However, trace amounts of dust or dirt on the origi-nal document scan can be easily mistaken for these markers (Darwish and Oard, 2002). Alternatively, these markers in handwritten text may be too small, light or closely-spaced to readily distinguish, caus-ing the system to drop them entirely. While Arabic disconnective letters may make it hard to determine word boundaries, they could plausibly contribute to reduced ambiguity of otherwise similar shapes. 2.2 Arabic Morphology Challenges Arabic words can be described in terms of their morphemes. In addition to concatenative prefixes and suffixes, Arabic has templatic morphemes called wkmkAtbhm 1 ( w+k+mkAtb+hm )  X  X nd like their of-fices X  has two prefixes and one suffix, in addition to a stem composed of the root H . H  X  k-t-b  X  X rit-ing related X  and the pattern m1A23 . 2 Arabic words can also be described in terms of lexemes and inflec-tional features. The set of word forms that only vary inflectionally among each other is called the lexeme . A lemma is a particular word form used to represent the lexeme word set  X  a citation form that stands in for the class (Habash, 2010). For instance, the lemma I . J X  X  mktb  X  X ffice X  represents the class of all forms sharing the core meaning  X  X ffice X : I . K A X  X 
Just as the lemma abstracts over inflectional mor-phology, the root abstracts over both inflectional and derivational morphology and thus provides a very high level of lexical abstraction, indicating the  X  X ore X  meaning of the word. The Arabic root H . H  X   X  X ilitary unit (of conscripts) X .

Arabic morphology allows for tens of billions of potential, legal words (Magdy and Darwish, 2006; Moftah et al., 2009). The large potential vocabulary size by itself complicates HR methods that rely on conventional, word-based dictionary lookup strate-gies. In this paper we consider the value of morpho-lexical and morpho-syntactic features such as lem-mas and part-of-speech tags, respectively, that may allow machine learning algorithms to learn general-izations. We do not consider the root since it has been shown to be too general for NLP purposes (Larkey et al., 2007). Other researchers have used stems for OCR correction (Magdy and Darwish, 2006); we discuss their work and compare to it in Section 6, but we do not present a direct experimen-tal comparison. 3.1 HR Error Classifications We can classify three types of HR errors: substi-tutions, insertions and deletions. Substitutions in-volve replacing the correct word by another incor-rect form. Insertions are words that are incorrectly added into the HR hypothesis. An insertion error is typically paired with a substitution error, where the two errors reflect a mis-identification of a single word as two words. Deletions are simply missing words. Examples of these different types of errors appear in Table 1. In the dev set that we study here (see Section 4.1), 25.8% of the words are marked as problematic. Of these, 87.2% are letter-based words (henceforth words), as opposed to 9.3% punctuation and 3.5% digits.

Orthogonally, 81.4% of all problem words are substitution errors, 10.6% are insertion errors and 7.9% are deletion errors. Whereas punctuation sym-bols are 9.3% of all errors, they represent over 38% of all deletion errors, almost 22% of all insertion er-rors and less than 5% of substitution errors. Simi-larly digits, which are 3.5% of all errors, are almost 14% of deletions, 7% of insertions and just over 2% of all substitutions. Punctuation and digits bring dif-ferent challenges: whereas punctuation marks are a small class, their shape is often confusable with Ara-bic letters or letter components, e.g., @  X  A and ! or P r and , . Digits on the other hand are a hard class to language model since the vocabulary (of multi-digit numbers) is infinite. Potentially this can be addressed using a pattern-based model that captures forms of digit sequences (such as date and currency formats); we leave this as future work.

Words (non-digit, non-punctuation) still consti-tute the majority in every category of error: 47.7% of deletions, 71.3% of insertions and over 93% of substitutions. Among substitutions, 26.5% are simple orthographic variants that are often normal-ized in Arabic NLP because they result from fre-quent inconsistencies in spelling: Alef Hamza forms ( / we consider whether the lemma of the correct word and its incorrect form are matchable, an additional 6.9% can be added to the orthographic variant sum (since all of these cases can share the same lemmas). The rest of the cases, or 59.7% of the words, in-volve complex orthographic errors. Simple dot mis-placement can only account for 2.4% of all substi-tution errors. The HR system output does not con-tain any illegal non-words since its vocabulary is re-stricted by its training data and language models. The large proportion of errors involving lemma dif-ferences is consistent with the perception that most OCR/HR errors create semantically incoherent sen-tences. This suggests that lemma models can be helpful in identifying such errors. 3.2 Problem Zone Definition Prior to developing a model for PZD, it is necessary to define what is considered a  X  X roblem X . Once a definition is chosen, gold problem tags can be gen-erated for the training and test data by comparing the hypotheses to their references. 3 We decided in this paper to use a simple binary problem tag: a hypothe-sis word is tagged as "PROB" if it is the result of an insertion or substitution of a word. Deleted words in a hypothesis, which cannot be tagged themselves, cause their adjacent words to be marked as PROB in-stead. In this way, a subsequent HR post-processing system can be alerted to the possibility of a miss-ing word via its surroundings (hence the idea of a problem  X  X one X ). Any words not marked as PROB are given an "OK" tag (see the PZD row of Table 1). We describe in Section 5.6 some preliminary exper-iments we conducted using more fine-grained tags. 4.1 Training and Evaluation Data The data used in this paper is derived from im-age scans provided by the Linguistic Data Consor-tium (LDC) (Strassel, 2009). This data consists of high-resolution (600 dpi) handwriting scans of Ara-bic text taken from newswire articles, web logs and newsgroups, along with ground truth annotations and word bounding box information. The scans in-clude variations in scribe demographic background, writing instrument, paper and writing speed.
The BBN Byblos HR system (Natarajan et al., 2008; Saleem et al., 2009) is then used to pro-cess these scanned images into sequences of seg-ments (sentence fragments). The system generates a ranked N-best list of hypotheses for each segment, where N could be as high as 300. On average, a seg-ment has 6.87 words (including punctuation).
We divide the N-best list data into training, de-velopment (dev) and test sets. 4 For training, we consider two sets of size 2000 and 4000 segments ( S ) with the 10 top-ranked hypotheses ( H ) for each segment to provide additional variations. 5 The ref-erences are also included in the training sets to pro-vide examples of perfect text. The dev and test sets use 500 segments with one top-ranked hypothesis each { H =1}. We can construct a trivial PZD base-line by assuming all the input words are PROBs; this results in baseline % Precision/Recall/F-scores of 25.8/100/41.1 and 26.0/100/41.2 for the dev and test sets, respectively. Note that in this paper we eschew these baselines in favor of comparison to a non-trivial baseline generated by a simple PZD model. 4.2 PZD Models and Features The PZD system relies on a set of SVM classi-fiers trained using morphological and lexical fea-tures. The SVM classifiers are built using Yamcha (Kudo and Matsumoto, 2003). The SVMs use a quadratic polynomial kernel. For the models pre-sented in this paper, the static feature window con-text size is set to +/-2 words; the previous two (dy-namic) classifications (i.e. targets) are also used as features. Experiments with smaller window sizes re-sult in poorer performance, while a larger window size (+/-6 words) yields roughly the same perfor-mance at the expense of an order-of-magnitude in-crease in required training time. Over 30 different combinations of features were considered. Table 2 shows the individual feature definitions.

In order to obtain the morphological features, all of the training and test data is passed through MADA 3.0, a software tool for Arabic morpholog-ical analysis disambiguation (Habash and Rambow, 2005; Roth et al., 2008; Habash et al., 2010). For these experiments, MADA provides the pos (using MADA X  X  native 34-tag set) and the lemma for each word. Occasionally MADA will not be able to pro-duce any interpretations (analyses) for a word; since this is often a sign that the word is misspelled or un-common, we define a binary na feature to indicate when MADA fails to generate analyses.

In addition to using the MADA features directly, we also develop a set of nine N-gram models (where N=1, 2, and 3) for the nw , pos , and lem features de-fined in Table 2. We train these models using 220M words from the Arabic Gigaword 3 corpus (Graff, 2007) which had also been run through MADA 3.0 to extract the pos and lem information. The models are built using the SRI Language Modeling Toolkit (Stolcke, 2002). Each word in a hypothesis can then be assigned a probability by each of these nine mod-els. We reduce these probabilities into one of nine bins, with each successive bin representing an order of magnitude drop in probability (the final bin is re-served for word N-grams which did not appear in the models). The bin labels are used as the SVM features.

Finally, we also use a word confidence ( conf ) feature, which is aimed at measuring the frequency with which a given word is chosen by the HR system for a given segment scan. The conf is defined here as the ratio of the number of hypotheses in the N-best list that the word appears in to the total number of hypotheses. These numbers are calculated using the original N-best hypothesis list, before the data is trimmed to H ={1, 10}. Like the N-grams, this num-ber is binned; in this case there are 11 bins, with 10 spread evenly over the [0,1) range, and an extra bin for values of exactly 1 (i.e., when the word appears in every hypothesis in the set). We describe next different experiments conducted by varying the features used in the PZD model. We present the results in terms of F-score only for sim-plicity; we then conduct an error analysis that exam-ines precision and recall. 5.1 Effect of Feature Set Choice Selecting an appropriate set of features for PZD re-quires extensive testing. Even when only consider-ing the few features described in Table 2, the param-eter space is quite large. Rather then exhaustively test every possible feature combination, we selec-tively choose feature subsets that can be compared to gain a sense of the incremental benefit provided by individual features. 5.1.1 Simple Features Table 3 illustrates the result of taking a baseline fea-ture set (containing word as the only feature) and adding a single feature from the Simple set to it. The result of combining all the Simple features is also in-dicated. From this, we see that Simple features, even collectively, provide only minor improvements. 5.1.2 Binned Features Table 4 shows models which include both Simple and Binned features. First, Table 4 shows the effect of adding nw N-grams of successively higher orders to the word baseline. Here we see that even a sim-ple unigram provides a significant benefit (compared to the improvements gained in Table 3). The largest improvement comes with the addition of the bigram (thus introducing context into the model), but the tri-gram provides only a slight improvement above that. This implies that pursuing higher order N-grams will result in negligible returns.

In the next part of Table 4, we see that the sin-gle feature ( pos ) which provided the highest single-feature benefit in Table 3 does not provide simi-lar improvements under these combinations, and in fact seems detrimental. We also note that using all the features in one model is outperformed by more selective choices. Here, the best performer is the model which utilizes the word , nw N-grams, and lem as the only features. However, the dif-ferences among this model and the other models using lem Table 4 are not statistically significant. The differences between this model and the other lower performing models are statistically significant (p &lt; 0.05). 5.1.3 Word Confidence The conf feature deserves special consideration be-cause it is the only feature which draws on informa-tion from across the entire hypothesis set. In Table 5, we show the effect of adding conf as a feature to several base feature sets taken from Table 4. Except for the baseline case, conf provides a relatively consistent benefit. The large (27.3%) improvement gained by adding conf to the word baseline shows that conf is a valuable feature, but the smaller im-provements in the other models indicate that the in-formation it provides largely overlaps with the in-formation already present in those models. The dif-ferences among the last four models (all including lem ) in Table 5 are not statistically significant. The differences between these four models and the first two are statistically significant (p &lt; 0.05). 5.2 Effect of Training Data Size In order to allow for rapid examination of multi-ple feature combinations, we restricted the size of the training set ( S ) to maintain manageable train-ing times. With this decision comes the implicit as-sumption that the results obtained will scale with ad-ditional training data. We test this assumption by taking the best-performing feature sets from Table 5 and training new models using twice the training data { S =4000}. The results are shown in Table 6. In each case, the improvements are relatively con-sistent (and on the order of the gains provided by the inclusion of conf as seen in Table 5), indicating that the model performance does scale with data size. However, these improvements come with a cost of a roughly 4-7x increase in training time. We note that the value of doubling S is roughly 3-6x times greater for the word baseline than the others; how-ever, simply adding conf to the baseline provides an even greater improvement than doubling S . The differences between the final four models in Table 6 are not statistically significant. The differences be-tween these models and the first two models in the table are statistically significant (p &lt; 0.05). For con-venience, in the next section we refer to the third model listed in Table 6 as the best system (because it has the highest absolute F-score on the large data set), but readers should recall that these four models are roughly equivalent in performance. 5.3 Error Analysis In this section, we look closely at the performance of a subset of systems on different types of prob-lem words. We compare the following model set-tings: for { S =4000} training, we use word , word + conf , the best system from Table 6 and the model using all possible features ( word , wconf , best and all , respectively); and we also use all trained with { S =2000}. We consider the performance in terms of precision and recall in addition to F-score  X  see Table 7 (a). We also consider the percentage of re-call per error type, such as word/punctuation/digit or deletion/insertion/substitution and different types of substitution errors  X  see Table 7 (b). The second col-umn in this table ( %Prob ) shows the distribution of gold-tagged problem words into word and error type categories.

Overall, there is no major tradeoff between preci-sion and recall across the different settings; although we can observe the following: (i) adding more train-ing data helps precision more than recall (over three times more)  X  compare the last two columns in Ta-ble 7 (a); and (ii) the best setting has a slightly lower precision than all features, although a much better recall  X  compare columns 4 and 5 in Table 7 (a).
The performance of different settings on words is generally better than punctuation and that is better than digits. The only exceptions are in the digit cat-egory, which may be explained by that category X  X  small count which makes it prone to large percent-age fluctuations.

In terms of error type, the performance on sub-stitutions is better than insertions, which is in turn better than deletions, for all systems compared. This makes sense since deletions are rather hard to de-tect and they are marked on possibly correct adja-cent words, which may confuse the classifiers. One insight for future work is to develop systems for different types of errors. Considering substitutions in more detail, we see that surprisingly, the simple approach of using the word feature only (without conf ) correctly recalls a bigger proportion of prob-lems involving orthographic variants than other set-tings. It seems that the more complex the model, the harder it is to model these cases correctly. Er-ror types that include semantic variations (different lemmas) or shared lemmas (but not explained by or-thographic variation), are by contrast much harder for the simple models. The more complex models do quite well recalling errors involving semantically in-coherent substitutions (around 77.7% of those cases) and words that share the same lemma but vary in in-flectional features (63% of those cases). These two results are quite a jump from the basic word baseline (around 29% and 18% respectively).

The simple addition of data seems to contribute more towards the orthographic variation errors and less towards semantic errors. The different settings we use (training size and features) show some de-gree of complementarity in how they identify errors. We try to exploit this fact in Section 5.5 exploring some simple system combination ideas. 5.4 Blind Test Set Table 8 shows the results of applying the same mod-els described in Table 7 to a blind test set of yet un-seen data. As mentioned in Section 4.1, the trivial baseline of the test set is comparable to the dev set. However, the test set is harder to tag than the dev set; this can be seen in the overall lower F-scores. That said, the relative order of performing features is the same as with the dev set, confirming that our best model is optimal for test too. On further study, we noticed that the reason for the test set difference is that the overlap in word forms between test and train is less than dev and train: 63% versus 81%, respectively on { S =4000}. 5.5 Preliminary Combination Analysis In a preliminarily investigation of the value of com-plementarity across these different systems, we tried two simple model combination techniques. We re-stricted the search to the systems in the error analy-sis (Table 7).

First, we considered a sliding voting scheme where a word is marked as problematic if at least n systems agreed to that. Naturally, as n increases, precision increases and recall decreases, provid-ing multiple tradeoff options. The range spans 49.1/83.2/61.8 (% Precision/Recall/F-score) at one end ( n = 1 ) to 80.4/27.5/41.0 on the other ( n = all ). The best F-score combination was with n = 2 (any two agree) producing 62.8/72.4/67.3, an almost 1% higher than our best system.

In a different combination exploration, we ex-haustively sought the best three systems from which any agreement (2 or 3) can produce an even better system. The best combination included the word model, the best model (both in { S =4000} training) and the all model (in { S =2000}). This combination yields 70.2/64.0/66.9, a lower F-score than the best general voting approach discussed above, but with a different bias towards better precision.

These basic exploratory experiments show that there is a lot of value in pursuing combinations of systems, if not for overall improvement, then at least to benefit from tradeoffs in precision and recall that may be appropriate for different applications. 5.6 Preliminary Tag Set Exploration In all of the experiments described so far, the PZD models tag words using a binary tag set of PROB/OK. We may also consider more com-plex tag sets based on problem subtypes, such as SUB/INS/DEL/OK (where all the problem sub-types are differentiated), SUB/INS/OK (ignores deletions), and SUB/OK (ignores deletions and in-sertions). Care must be taken when comparing these systems, because the differences in tag set definition results in different baselines. Therefore we com-pare the % error reduction over the trivial baseline achieved in each case.

For an all model trained on the { S =2000, H =10} set, using the PROB/OK tag set results in a 36.3% error reduction over its trivial baseline (using the dev set). The corresponding SUB/INS/DEL/OK tag set only achieves a 34.8% error reduction. The SUB/INS/OK tag set manages a 40.1% error re-duction, however. The SUB/OK tag set achieves a 38.9% error reduction. We suspect that the very low relative number of deletions (7.9% in the dev data) and the awkwardness of a DEL tag indicating a neighboring deletion (rather than the current word) may be confusing the models, and so ignoring them seems to result in a clearer picture. Common OCR/HR post-processing strategies are similar to spelling correction solutions involving dictionary lookup (Kukich, 1992; Jurafsky and Mar-tin, 2000) and morphological restrictions (Domeij et al., 1994; Oflazer, 1996). Error detection sys-tems using dictionary lookup can sometimes be im-proved by adding entries representing morphologi-cal variations of root words, particularly if the lan-guage involved has a complex morphology (Pal et al., 2000). Alternatively, morphological information can be used to construct supplemental lexicons or language models (Sari and Sellami, 2002; Magdy and Darwish, 2006).

In comparison to (Magdy and Darwish, 2006), our paper is about error detection only (done in us-ing discriminative machine learning); whereas their work is on error correction (done in a standard gen-erative manner (Kolak and Resnik, 2002)) with no assumptions of some cases being correct or incor-rect. In essence, their method of detection is the same as our trivial baseline. The morphological fea-tures they use are shallow and restricted to breaking up a word into prefix + stem + suffix ; whereas we ana-lyze words into their lemmas, abstracting away over a large number of variations. We also made use of part-of-speech tags, which they do not use, but sug-gest may help. In their work, the morphological fea-tures did not help (and even hurt a little), whereas for us, the lemma feature actually helped. Their hypoth-esis that their large language model (16M words) may be responsible for why the word-based mod-els outperformed stem-based (morphological) mod-els is challenged by the fact that our language model data (220M words) is an order of magnitude larger, but we are still able to show benefit for using mor-phology. We cannot directly compare to their re-sults because of the different training/test sets and target (correction vs detection); however, we should note that their starting error rate was quite high (39% on Alef/Ya normalized words), whereas our start-ing error rate is almost half of that (  X  26% with un-normalized Alef/Yas, which account for almost 5% absolute of the errors). Perhaps a combination of the two kinds of efforts can push the perfomance on correction even further by biasing towards problem-atic words and avoiding incorrectly changing correct words. Magdy and Darwish (2006) do not report on percentages of words that they incorrectly modify. We presented a study with various settings (linguis-tic and non-linguistic features and learning curve) for automatically detecting problem words in Ara-bic handwriting recognition. Our best approach achieves a roughly  X  15% absolute increase in F-score over a simple baseline. A detailed error anal-ysis shows that linguistic features, such as lemma models, help improve HR-error detection specifi-cally where we expect them to: identifying semanti-cally inconsistent error words.

In the future, we plan to continue improving our system by considering smarter trainable combina-tion techniques and by separating the training for different types of errors, particularly deletions from insertions and substitutions. We would also like to conduct an extended evaluation comparing other types of morphological features, such as roots and stems, directly. One additional idea is to implement a lemma-confidence feature that examines lemma use in hypotheses across the document. This could potentially provide valuable semantic information at the document level.

We also plan to integrate our system with a system for producing correction hypotheses. We also will consider different uses for the basic system setup we developed to identify other types of text errors, such as spelling errors or code-switching between languages and dialects.
 We would like to thank Premkumar Natarajan, Rohit Prasad, Matin Kamali, Shirin Saleem, Katrin Kirch-hoff, and Andreas Stolcke. This work was funded under DARPA project number HR0011-08-C-0004.
