 In this paper, we study the problem of privacy preserving record linkage which aims to perform record linkage without revealing anything about the non-linked records. We propose a new secure embedding strategy based on frequent variable length grams which allows record linkage on the embedded space. The frequent grams used for constructing the embedding base are mined from the orig-inal database under the framework of differential privacy. Com-pared with the state-of-the-art secure matching schema [15], our approach provides formal, provable privacy guarantees and achieves better scalability while providing comparable utility.
 H.2.7 [ Database Management ]: Database Administration X  Secu-rity, integrity, and protection Algorithms, Security, Performance Privacy, Security, Record Linkage, Differential Privacy
Record linkage [18, 7] plays a central role in many data integra-tion and data mining tasks that involve data from multiple sources. It is the process of identifying records that refer to the same real world entity across different sources. It is extensively used in many applications, for example, in linking medical data of the same pa-tient across different hospitals in the country or in collecting the credit history of users from several sources. However, many of these data may contain sensitive personal information that could disclose individual privacy. For this reason, the problem of privacy preserving record linkage has drawn considerable attention over re-cent years. The objective is to allow two parties to identify records that are close to each other according to some distance function, such that no additional information about the data records other than the result is disclosed to any party.

In the existing literature, several techniques have been proposed, and they can be mainly categorized into a few categories: Secure Multiparty Computation (SMC) [13, 20], secure transformation [1, 4, 15, 16], and hybrid methods [8, 10, 11, 19]. SMC techniques use cryptographic mechanisms and allow two parties to perform record linkage as a secure function such that no party knows anything ex-cept its own input and the results. However, they are computa-tionally prohibitive in practice. Secure transformation methods use data transformation techniques such as one-way hashing or embed-ding to map the original data into new data values that cannot be reversed and then perform record linkage on the transformed data typically by a third party. While these methods are more efficient, the challenge is to have a secure transformation while preserving the accuracy of linkage on the transformed space as high levels of protection typically implies a great loss of accuracy in the final re-sults. Finally, hybrid techniques attempt to combine anonymization or transformation techniques with SMC protocols. They typically use a privacy preserving blocking step to restrict the comparisons to smaller groups of records which are then compared by SMC protocols. While they provide a trade-off between efficiency and accuracy, the SMC step is still required and are typically not imple-mented or evaluated due to the high computation cost.

In this paper, we present a new secure data transformation method based on frequent grams embedding and we provide a comparison with the approach proposed by Scannepieco et. al. [15] for linking string records. The latter uses SparseMap [9] to embed strings into a vector space, where the common base among the parties is formed by random strings, so that no information is disclosed. However, as the protocol is designed, the shared base is optimized according to the data at one party. Therefore, if a malicious party is involved, some sensitive information could be disclosed. In contrast, our pro-tocol uses frequent grams as a base for secure embedding which gives a better representation of the records than a random base and the frequent grams are mined from the original database with a for-mal guarantee of differential privacy [5]. As a proof-of-concept, we focus on string records in this paper, and perform approximate matching of the records based on a similarity criterion.
 Our contributions:  X  We propose a novel embedding strategy based on frequent vari-able length grams to map string records into vectors in the real space. We show that the use of frequent variable length grams substantially increases the utility of the results with respect to random bases.  X  We adapt and extend the privacy preserving mining algorithm in [3] to mine frequent variable length grams which can be used as the embedding base. The proposed privacy preserving record linkage protocol hence satisfies the differential privacy frame-work which provides formal guarantees of individual privacy.  X  Finally, we present a set of empirical experiments using real world datasets showing the benefit of our approach.

The rest of the paper is organized as follows. In Section 2, we introduce some basic definitions and the privacy model adopted in our solution. Section 3 provides a description of the major compo-nents in our proposed solution. The experiment results are reported in Section 4. Finally, we conclude the paper in Section 5
In this section, we introduce some notations and definitions re-lated to our approach.

Let  X  be a finite alphabet, we denote by x = x 0 x 1  X  X  X  x string of length n where each symbol x i is defined in  X  . Moreover, we denote by | x | the length of the string x . As a similarity measure between strings we consider the Edit distance [12] ( d Edit measures the number of edit operations needed to transform a string into the other one. The problem of record linkage that we consider in this paper is defined as follows.
 P ROBLEM 1 (R ECORD L INKAGE ). Given two sets D A and D
B of string records, find M  X  D A  X  D B , such that M = { ( x,y ) | d Edit ( x,y )  X  ed } (matching records) and no informa-tion about the individual records ( x,y ) 6 X  X  (non-matching records) is disclosed.
Differential privacy [5] is a recent notion of privacy that aims to protect the disclosure of information when statistical data are released. The differential privacy mechanism guarantees that the computational output is insensitive to change in any particular in-dividual record of the input data.
 active privacy mechanism M has -differential privacy if for any two input sets (databases) D A and D B with symmetric difference one (neighbor databases), and for any set of outcomes S  X  Range ( M ) , where is the privacy parameter (also referred to as privacy bud-get). Intuitively, lower value of implies stronger privacy guaran-tees, and vice versa.

Two composition properties are extensively used when multiple differential privacy computations are combined. These two proper-ties are known as sequential and parallel compositions [14]. The former states that any sequence of computations that each provides differential privacy in isolation also provides differential privacy in sequence. The latter instead holds when the computations involved are performed on disjoint data. In this case, the privacy cost does not accumulate but depends only on the worst guarantee.

A common mechanism to achieve differential privacy is the Laplace mechanism [6] which we will use in this paper. Let f be a statistical function, and be the privacy parameter, the mechanism adds cali-brated noise to the result f ( D ) in order to guarantee -differential privacy. The noise is generated from a Laplace distribution with probability density function pdf ( x |  X  ) = 1 2  X  e  X  X  x | / X  rameter  X  is determined by and GS ( f ) , the global sensitivity [6] of the function to the inclusion and exclusion of any record in the dataset. We restrict our attention to counting queries, which can be proven to have GS ( count ) = 1 .
We propose an embedding technique based on grams , which al-lows approximate matching of the records (i.e. within a fixed num-ber of edit operations). The proposed technique maps the original data into a vector space by projecting each string in the databases on a base formed by a set of frequent grams , where a gram of length q is a substring x 0 x 1  X  X  X  x q  X  1 of the original strings.
Each party starts to build a base for the embedding by mining grams from its own database, and this phase is denoted as mining phase . This process is performed with a guarantee of differential privacy, so that the parties involved in the protocol can share their bases and determine a common base for the embedding without disclosing any sensitive information of individual records. When a final base is determined, each party embeds its data using the com-mon base, and the matching is performed in the embedded space. We denote this step as embedding phase . Our overall protocol is illustrated in Figure 1. Our strategy requires the presence of a third trusted party denoted by C , whose task consists in matching the records in the embedded space. A summary of the steps is listed as follows. 1. Mining Phase: Parties A and B apply a differentially private algorithm to mine their respective databases D A and D B , and compute private bases B A and B B . 2. Base Generation: One of the two parties is in charge of merg-ing the two bases and producing a shared base B of frequent variable length grams. 3. Embedding Phase: Each party A and B , by using the shared base, embeds its own data and generates a set of vectors V V B respectively, representing the strings in the original datasets.
These sets are sent to the third party C . 4. Matching Phase: The third party C , for each vector  X  s  X  V returns a set of neighbor vectors N from V B that are within
Euclidean distance of Th ( global threshold ). This set identifies the matching set M .
 Figure 2(a) illustrates the mining and base generation phase. The party A and B mine their respective datasets and produce a shared private base formed by the following grams { A,M,MA,E,O } . This base is used to produce the set of embedded vectors in Figure 2(b).
Contrary to the SparseMap approach in [15], we construct a base mined from the original data mainly for two reasons. First, we take advantage of the fact that the strings being matched in record link-age scenarios typically have similar properties (e.g. same alphabet, similar length, etc. ). Hence, by using a base mined from the orig-inal dataset, we can capture this information. Second, a randomly generated base can not represent every dataset well since it is de-fined in a generic way and not data dependent.
 We form a base by mining the frequent grams in the database. Formally, given a positive integer k , a minimum length q a maximum length q max , our goal is to mine the top-k frequent q -grams where q  X  [ q min ,q max ] , and to use this set as a base for the embedding. Intuitively, we can obtain a base set that is a good rep-resentative for all the strings in the databases since frequent grams are more likely to be shared among the strings. In addition, by re-stricting the attention to the top-k frequent grams, we can control the dimensionality of the data in the new space. In order to pro-tect the privacy of individual records, the grams are mined from the original dataset to guarantee -differential privacy. In our ap-proach, we consider an extension of the prefix tree mining algo-rithm [3] originally introduced to mine frequent trajectory data. In our case, the two databases may be correlated as they may contain records belonging to the same entity, the total privacy parameter is split among the two parties holding the dataset, so that the overall privacy level is .
The mining algorithm proposed in [3] mines the frequent trajec-tory data by using a prefix tree. In the same way, we partition the space of all the possible grams using a top-down approach, where each partition is identified by a node in a prefix tree T . Each node has the following information: a prefix  X  , an accumulated privacy budget, and the subset of all the strings in the original database having  X  as a prefix, called the partition represented by the node.
The construction of the prefix tree can be summarized as fol-lows. Starting from the root of the tree, the database is partitioned by extending the prefix of the current node using Algorithm 1. For every symbol a in the alphabet  X  , a new node is attached to the tree only if the string  X a is a frequent prefix, where  X  is the pre-fix represented by the parent of the current node. To determinate if a prefix is frequent, a counting query is issued on the partition of the dataset represented by the current node and the real count is perturbed by Laplace noise to guarantee differential privacy. In this process, only partitions with frequent prefixes ( count &gt;  X  ) are further refined. The allocation of the budget at each level in the tree is performed at line 6 in Algorithm 1. In our approach, we propose several strategies to allocate the private budget: linear allocation , exponential allocation , adaptive , and hybrid . Details Algorithm 1 Private Prefix-Tree Partitioner 1: about these strategies are presented later in this section. After we partition the data, we traverse the prefix tree and apply the con-sistency constraints for each root-to-leaf path as in [3]. Once the consistency constraints are enforced, we identify a list of frequent grams by traversing the tree. As a final result, we return the top-k grams sorted by their noisy frequencies. An example of the prefix tree is illustrated in Figure 3.
 Budget Allocation Strategies: We investigate and propose more allocation strategies than the linear allocation introduced in [3].  X  Linear: Each node at each level in the tree is allocated the same amount of budget.  X  Exponential: At level i in the tree, a node is allocated a budget double the amount of its parent.  X  Adaptive: This strategy is an adaptation of the previous expo-nential allocation strategy, where the entire remaining budget on the path is spent on the next counting query if the current node represents a non frequent prefix.  X  Hybrid: This strategy is a combination of the previous strate-gies, where the total budget is distributed in the tree according to q max . In particular, we reserve half of the total budget to the nodes on the first q max levels of the tree, where the budget is al-located to each node in a linear fashion. For the remaining nodes, the adaptive strategy is used.
 Privacy Analysis: All the partitions produced by Algorithm 1 on the same level of the tree are disjoint since they correspond to strings with different prefixes. Therefore, by the parallel compo-sition property [14], the overall privacy level is determined by the maximum value of the budget used over all the root-to-leaf path of the tree. For any path, the overall privacy level is given by the sequential composition property [14] and can be computed as the sum of the privacy budget used for each counting query for each node on the path.

T HEOREM 1 (P REFIX T REE -PRIVACY ). The Prefix-tree Miner guarantees -differential privacy.

P ROOF . The proof follows directly from the differential privacy result proposed in [3] since all the allocation strategies uses at most budget on the root-to-leaf paths in the tree.
 Complexity Analysis: Algorithm 1 has running time proportional to the number of nodes in the prefix tree T . By using a similar analysis as in [3], it can be shown that our mining approach requires O ( N |  X  | h MAX +1 ) operations, where N is the size of the dataset,  X  is the alphabet, and h MAX is the maximum depth in the tree.
In this section, we describe the embedding phase to map strings into vectors. Let B = { g 1 ,g 2 ,...,g k } be a base of k grams, each string s in the database is mapped into a vector  X  s in R component  X  s i represents the number of occurrences of the gram g in s , normalized by the length of g i . Let Occ s ( g ) denote the set of positions in s where the gram g occurs, then each coordinate is de-the distance between vectors is computed using the Euclidean dis-tance: d 0 (  X  x,  X  y ) = k  X  x  X   X  y k 2 . An example of embedded records is illustrated in Figure 2(b).
 Threshold Computation: In the original space, we are interested in matching strings within ed edit operations; however in the new space, this task is casted into the problem of finding all the vectors whose Euclidean distance is within a threshold value Th . This threshold value plays a central role on the overall performance, since it will determine the candidate records that may represent matching strings. Therefore, it is crucial to compute a threshold value as tight as possible to the real value. This problem is gen-erally very hard, since proving formal guarantees requires analysis on the distance distortion and properties of the embedding strategy used. We define as a global threshold value, the Euclidean distance that can be used in matching all the records in the new space. This can be done by estimating how the original distance is distorted af-ter the embedding map is applied. In this direction, we propose an initial upper bound for our embedding.

P ROPOSITION 1 (U PPER BOUND ). Given x and y , two strings in the original space with Edit distance d Edit ( x,y )  X  ed , then d (  X  x,  X  y )  X   X  q  X  ed , where  X  q = q max  X  q min + 1
P ROOF . The number of grams of length q that can contribute to the distance is at most q  X  ed (since on a position i at most q grams of length q are overlapping). Since the base B used in the embedding is a subset of all variable length q -grams, it follows that: d 0 (  X  x,  X  y ) = k  X  x  X   X  y k 2  X   X  q  X  ed .
 In addition to this approach, we also studied the concept of per-sonalized threshold which dynamically computes a threshold value for each individual record required to be matched. Due to space restrictions, we focus on global threshold in this paper and refer readers to [2].
In this section, we present a set of experimental results evaluating the impact of the private parameter and the dimensionality k on the overall utility of our protocol. We compare our approach with the method in [15] to show the benefit of our approach in scalability and stronger privacy model while achieving comparable data utility.
We use two real datasets, NAMES 1 and CITIES . The first con-tains a list of the most frequent surnames from the Census 2000.
NAMES is publicly available at United States Census (http://www.census.gov/genealogy/www/data/2000surnames/) Figure 4: Utility and threshold: (Left) frequent grams, (Right) ran-The second is a list of the top 5000 most populated cities in U.S. in 2008. Some of the statistics of the datasets are summarized in Table 1, where l max , l min and l avg are the maximal, minimal and average lengths of the strings, respectively. The experiment and al-gorithm parameters, if not specified in the descriptions, assume the default values as reported in Table 2.
 Frequent grams vs random grams: We first verify the advantage of using frequent grams over random grams in the embedding base. Figure 4 reports the utility in terms of F 1 score [17] for different values of global threshold ( Th ) in the embedded space, with a di-rect comparison between random and frequent grams. We tested the embedding strategy on the NAMES dataset, by allowing an ap-proximate matching with the number of edit operations up to 2, with k = 100 . From the graph, it is evident that frequent grams lead to a considerable improvement in the utility compared to ran-dom grams (an improvement from 20% to 60%). This result is justified by the fact that a base of frequent grams is more likely to share a higher number of grams with the strings. In addition, we can also observe that when approximate matching is allowed, the utility decreases as the number of edit operations increases. Impact of the privacy parameter: The relationship between the privacy parameter and the utility of our protocol is reported in Figure 5. In these graphs, we also compare the results provided by private miners with an exact non private miner. We restrict our attention to the linear and hybrid budget allocation strategies since their performances are slightly better than those provided by the Figure 5: Impact of the privacy parameter: (Left) Exact match, Figure 6: Running Time Vs N : comparison between the frequent other two strategies. As we can see, the utility of the protocols using private miners approaches the results obtained from the non private algorithm as increases. Moreover, this figure points out the hardness of solving record linkage when approximate matching is allowed. Indeed, the utility for approximate matching is moderately smaller than that of exact matching.
 Protocol Performances: The scalability results of our strategy are reported in Figure 6. The running time is measured in millisec-onds [ms], and it consists of the time needed to mine the base for each party, to combine the bases to form the shared base, and to embed the data. As we can see from Figure 6, the running time for our protocol is linear with the size of the dataset considered. Figure 6 shows also the running time for the Lipschitz approach proposed in [15]. For this approach, we measure the time required to generate the base using the heuristic and produce the embedding map. As we can see, this approach also scales linearly with the size of the dataset, but its running time is considerably higher. In Figure 7 we tested the approaches with different base sizes on the CITIES dataset. As we can see, Lipschitz provides a better utility for smaller bases, while our strategies achieve similar results when k  X  20 . However, the dependency of the running time with respect to the dimensionality is exponential for the Lipschitz strategy, while in our approach is considerably lower.
In this paper, we presented a novel frequent grams based em-bedding strategy to perform privacy preserving record linkage for string records. Compared with the state-of-the-art secure match-ing approach [15], our approach provides formal, provable privacy guarantees of differential privacy and achieves better scalability while providing comparable utility. As future work, we plan to Figure 7: Performance of Lipschitz and frequent grams embedding enhance the allocation strategies for the prefix tree miner and the threshold schemes for matching in embedded space.
This material is based upon work supported by the National Sci-ence Foundation under Grant No. 1117763. The authors would also like to thank the anonymous reviewers for their valuable com-ments and suggestions to improve the quality of the paper.
