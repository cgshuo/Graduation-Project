 Rock art is an archaeological term for human-made markings on stone. It is believed that there are millions of petroglyphs in North America alone, and the study of th is valued cultural resource has implications even beyond anthropology and history. Surprisingly, although image processing, informa tion retrieval and data mining have had large impacts on many hum an endeavors, they have had essentially zero impact on the study of rock art. In this work we identify the reasons for this , and introduce a novel distance measure and algorithms which allow efficient and effective data mining of large collections of rock art. H.2.8 [ Database Management ]: Database Applications  X  Data Mining , Image databases Algorithms, Experimentation, Measurement Rock art is an archaeological term for human-made markings on stone, including petroglyphs, carvings into stone surfaces and pictographs, paintings on stone. Figure 1 illustrates some examples of each, which hint at the extraordinary variability of rock art in terms of complexity. Petroglyphs and pictographs are one of the earliest expressions of abstract thinking, and a true hallmark of humanity. They provide a rich body of information on several different dimensions, beyond their value as an aesthetic expression. Studies of rock art have implications beyond anthropol ogy and history. For example, a recent study postulates the existence of a now-extinct Australian bat species based on extraordinarily detailed pictographs known to be at least 17,500 years old [19]; petroglyphs have been used in studies of climate change; the changing inventories of species in the Dampier Archipelago from the Pleistocene to the early Holocene period have been reconstructed partly by petroglyph evidence [3]. However, in spite of these successes, progress in petroglyph research has been frustratingly slow. A decade ago, Walt et al. summed up the state of petroglyph research by noting,  X  Complete-site and cross-site research thus remains impossible, incomplete, or impressionistic  X  [24]. Surprisingly, there has been little change in the intervening decade, yet in the same time frame we have seen significant advances in image processing a nd data mining. These advances have resulted in fielded applica tions in domains as diverse as medicine, entertainment, wildlife management, e-commerce, biometrics, zoology [18], etc. Ne vertheless, these advances have had essentially zero impact on the analysis of petroglyphs and pictographs. We believe that this is because the extraordinarily diverse and complex structure of rock art images defies most existing image matching algorithms. Most approaches are simply not suitable to capture the similarity of petroglyphs, and those that are, even in limited cases, do not scale to large collections we need to examine. In this work we in troduce a novel distance measure for rock art, and show that it can correctly capture the subjective (and where available, objective ) similarity between petroglyphs. We show how we can use this distance measure as a basis of several higher-level  X  X ata-mining X  algorithms, for example finding repeated motifs, clustering, or simply enabling query-by-content. The rest of the paper is organized as follows. Section 2 contains background information and a discussion of related work. In Section 3 we review the Genera lized Hough Transform, and show how we can adapt it to produce a fast and robust distance measure for petroglyphs. We test our ideas with a comprehensive set of experiments in Section 4, be fore offering conclusions and directions for future work in Section 5. The earliest petroglyphs have traditionally been associated with the appearance of modern humans in Europe such as the famous example from the Lascaux Cave, France, and an early one from the Chauvet Cave, France which dates back to as early as 30,000 years ago [22]. Recent work has shown that the idea of expressing abstract motif appear s much earlier, 77,000 years ago in South Africa [10]. Given this long history, it is one of the most valuable sources of humanity that has persisted to the present time. Beyond their value as an aesthetic expression, petroglyphs provide a rich source of information for researchers. Repeated motifs can be identified and traced through time and space, which in turn may shed light on the dynamic histories of human populations, patterns of their migr ations and interactions, and even continuities to the present indigenous societies. However, the nature of petroglyphs poses an extremely difficult challenge. As in the case for any other artifacts of history, damages to petroglyphs are permanent and i rreversible. However, unlike other artifacts that can be preserved and protected within the confines of a controlled envir onment in a museum, petroglyphs are mostly left in their natural settings, exposed to elements of nature that will erode them inev itably with time. There is an urgent need to identify petrogl yphs and to archive them for humanity. As we shall show in Section 3, our algorithm assumes the input images are (relatively) low-resolu tion bitmaps with a 1-bit color depth, one petroglyph per image. However, as Figure 1 illustrates, obtaining such images may be non-trivial. With rare exceptions, petroglyphs do not lend themselves to automatic extraction with segmentation algorithms. For example, in the two images on the left of Figure 1, segmentation al gorithms find the  X  X dges X  due to cracks in the rock to be more significant that the actual edges of the petroglyphs. Moreover, these images were chosen for this example for their high contrast and clarity; most petroglyphs would be even more challenging. In spite of this, in the next two sections we show how we easily obtained tens of thousands of petroglyphs for this study, and how we plan to have at least one million examples in the very near future. The last five years has seen a flurry of research on Human Computation , much of it leveraging of the pioneering work of Luis von Ahn at CMU [1]. The e ssence of human computation is to have computers do as much work as possible to solve a given problem, but to outsource certain critical steps to humans. These steps are ones which are difficult for computers, but simple for humans. One of the most famous examples is the Google Image Labeler , which is a program that allo ws the user to label random images to help improve the qua lity of Google X  X  image search results. Like many such efforts, human time is donated for free, because the task is embedded in a fun game, hence the recently coined term, Games with a Purpose, or GWAP [2]. In a parallel ongoing research effort, we have created a tool called PetroAnnotator which allows human volunteers to  X  X elp X  computer algorithms segment and annotate petroglyphs. While the domain of interest does not have the broad appeal of Google Image Labeler , and is difficult to frame as a game, this does not matter. We tentatively estimate that if every grad student in anthropology in the US were to donate just one hour a month to the project, all the worlds X  rock art could be processed in just a few years. We leave a detailed discuss of PetroAnnotator to a future publication; however the interested reader can find more details and working code at [27]. Beyond the examples captured by our human computation system, there are several other rich sources of rock art data to be mined. For example, anthropol ogists have been sketching petroglyphs for hundreds of years, and recent efforts to digitize historical manuscripts have made at least hundreds of books, each with at least a few thousand pe troglyph images, freely available on the web. In Figure 2 we show an example from the 1888 edition of a series of government reports [20]. Images of this type can be of particular interest because they may refer to petroglyphs which have long since been destroyed. Furthermore, although the petroglyphs in Figure 2 predate photography, it is important to note that because petroglyphs often do not reproduce well in photographs, the practice of hand drawing or tracing petroglyphs is still used in modern anthropological texts. An understanding of similarity must be at the heart of any effort to analyze petroglyphs and other cultural artifacts. For example, an image of a horseman incised on a fossilized ostrich eggshell fragment was recently found among eolian deposits in the Gobi Desert, Mongolia [14]. An obvious thing to do with such an image in order to place it in a cultural context is to ask if a similar image exists in the many petrogl yphs in the region. Thus, we began this project with careful cons ideration of shape similarity. In soliciting feedback and advice for early previews of this work from various researchers in the data mining and image processing community, the feedback obtained was almost always of the form  X  Very nice, but have you considered using X  X , where X was Geometric Hashing, Hausdorff Distance, Chamfer Matching, Shape Contexts, Fr X chet Distance, Skeleton Graphs, Zernike moments, Earth Movers, etc. While we have considered (and in some cases experimented with, see [27]) these distance measures, space limitations prohibit a detailed review and discussion of the pros and cons of each of them. Indeed, the preceding list is only a small subset of the hundreds of shape similarity measures in existence. See [23][26] and the references therein for an overview. However, we argue that some of the unique properties of petroglyphs render most of them unsuitable for the task at hand. Consider the following difficulties illustrated by Figure 3.  X  A single atomic petrogly ph may contain several  X  Geometric hashing is a very useful technique for indexing  X  There are many specialized distance measures which have Instead of attempting an exhaus tive discussion of why we have discounted existing shape distan ce measures, we will briefly review the positive reasons for wh y we choose the GHT measure.  X  As we shall show, on real, but unlabeled anthropological  X  As we will demonstrate in this work, we are able to tightly  X  The GHT makes essentially no assumptions about the data, We are now in a position to give some intuition as to why we intend to do data mining on a relatively low resolution of the petroglyph images. Using our PetroAnnotator , we asked two individuals to trace a petroglyph of a bighorn sheep petroglyph found in Arizona; the resulting two skeletons are shown in Figure 4.A. The skeletons are on a bitmap of 340 by 250. Although the two images are very similar, less than 3.5% of the pixels from each image overlap. We can contrast this with the situation after converting the images to a down sampled representation as shown in shown in Figure 4.B. Here the images are transformed to a mere 30 by 23 grid representati on. However, of the 130 pixels that form each image, 75.6% of the pixels are common to both. In essence, the original imag e representation has spurious precision. This precision is unwarranted because there is some uncertainty introduced by the human element of the algorithm The quantizing produced in the downsampling step also introduced some uncertainty, but th is is completely dwarfed by original uncertainty. Furthermore, as we shall see, the lower resolution representation has seve ral unique advantages which we can leverage off. In Section 5, we provide forceful empirical evidence that appropriate amount s of downsampling significantly improve accuracy in objective tests. We begin by reviewing the cla ssic generalized Hough Transform algorithm and then introduce our m odifications and extensions. The Hough transform [11][8] is a useful method for two-dimensional shape detection, but it is limited to analytic curves. It was generalized to detect arbitrary shapes in [5][15]; however, these works did not explicitly encode a similarity measure. We note that there are many variants of the Hough transform, and the notation in the literature is in consistent. The particular variant of the algorithm we consider, and the notation we will describe it, is most similar to Merlin and Farber X  X  [15], in which shapes are constituted of edge points . Edge points are simply the dark pixels in our one-bit representation of shapes. Suppose we have a candidate shape C defined as: and we want to find the best fit of a query shape Q defined in the same way as C . That is, given a reference point R in Q , to find the best point R X  in C , if we put C onto Q (with only translation in the plane is allowed) and points R and R X  coincide, then the number of matched edge points would be the maximal. For clarity, we use a very simple example to illustrate the algorithm. Figure 5 shows a query shape Q and a candidate shape C . Note that the shapes can be disconnected, as in Q . As shown in Figure 6, the first st ep is to mark a reference point R in Q (usually the center of mass of all edge points) and rotate edge points of Q around R by 180 X  (left and center of Figure 6). We then draw vectors from R to each edge point (as shown in the right of Figure 6). These vectors form a  X  X tar-like X  pattern which we will use to determine the best fit of Q in C . To find both the best alignment of Q to C, together with a numeric evaluation of their similarity, we do the following. The  X  X tar X  vectors are superimposed on each edge point of C (as shown in Figure 7. left ). An accumulator matrix A of the same dimensions as C is used to record the number of vector-ends (i.e. the arrowheads) that fall into each cell (Figure 7. right shows the final accumulator). The cell in A with the maximal value is the best point R X  we want to find, and its value equals th e maximal number of edge points can be matched between Q and C . This is 3 in our example. Note not necessarily the center of mass of C . Based on this maximal value, we can further obtain the minimal unmatched edge points ( MUE ) of Q . This is simply the number of edge points in Q minus maximal matc hed points. This MUE can be used as a distance measure. In our toy example, with similar shapes, its value is 1. If Q were exactly the same as C , the MUE would be 0, meaning D( Q , C ) = 0. As we shall later see, it can be useful to normalize and adjust th is number before using it as a distance measure. For concreteness we show the algorithm to compute the minimal unmatched edge points in Table 1. If Q and C have S  X  S pixels, and we denote the number of edge points in Q and C by N Q and N C respectively, then the time complexity of this algorithm is O( N Q  X  N C + S 2  X log S The classic GHT algorithm can be seen as a cell value incrementation process of the accumulator (as reflected line 8-12 in Table 1), and we need to wait for all of the incrementation to finish before we can obtain the value for any particular cell. Here we propose a new cell value incrementation strategy which allows obtaining the cell values one by one. This will allow us, for the first time, to use a lower bounding strategy for the GHT. Instead of superimposing vector s on edge points and increasing the value of the corresponding cell, we reverse this process by checking all positions that are possible to increase the value of one particular cell. To achieve this, we need to reverse the direction of vectors. Figure 8 shows this simple idea (using the same example as in the last section): first we draw vectors from R to each edge point of Q , but without rotating Q (on the left); if we want to calculate the value of a particular cell, say, the one at the third row and second column, we superimpose all vectors on that cell (on the right). Then we check every cell with a v ector falling into it: if this is also an edge point, we increase the cell value by 1 (because it is guaranteed, when using classic GHT , one vector superimposed on this edge point would fall into the target cell). Finally, after checking four cells, we obtain the value 2 for this cell. It is obvious that our new cell va lue incrementation strategy is equivalent to the classic one. Ho wever, this strategy has one advantage in that it allows for the implementation of the cell incrementation process in parallel, which avoids nesting for-loops in the classic GHT (line 8-12 in Table 1). In this paper, we are not going to discuss this. We will utilize the nice property  X  X btaining cell value one by one X  as a basis to explore a lower bound of minimal unmatched edge points in the next two sections. As noted above, the time complex ity of the GHT is quite high, and this limits its applicability for larger datasets. The classic data mining solution to the problem of time consuming distance measures is to find an efficiently computable tight lower bound to the distance measure, and to us e this bound to cheaply prune off unpromising candidates [12]. We are now in a position to show the first known lower bound of the GHT-based distance. Our idea is based on extracting one-dimensional  X  X ignatures X  from the two-dimensional query and candidate images. While we extr act signatures from both the rows and columns, for ease of exposition we begin by showing just the column signature, which we denote as SigCx . For a candidate shape C with m rows and n columns, we have: In other words, we are simply c ounting all of the edge points in each column of C . For example, the truncated-corner square shape shown on the Figure 9. right has SigCx = {0,0,0,3,2,2,2,3,0,0,0} We can extract these signatures as part of the preprocessing of the images, and store them in an index. At query time, we can use an identical technique to extract a signature, SigQx, from the query image Q . As shown in the Figure 10. left the only difference is that we truncate any leading or trailing 0 X  X  from the SigQx signature. As it happens, the MUE distance in this case is 4, a number we can compute using the algorithm in the previous section. However, we can compute a lower bound to this value by looking at just the respective signatures. We can obtain the intuition behind the lower bound by imagining that Q  X  X ants X  to match perfectly to C , with no missing edge points. As we place  X  X tar X  vectors to one cell on the center column of C , if Q  X  X ants X  all vectors to fall into edge points of C , a necessary, but not sufficient, condition for this to happen is that the number of vectors falling into each column is less than or equal to the number of edge points in that column. This is equivalent to checking whether each value in a SigQx cell is less than or equal to the corresponding cell in SigCx (as shown in Figure 10). Referring to Figure 10, we can see that in the slot SigQx two edge points, and the corresponding slot in SigCx i actually has three. There is no penalty for SigCx having a surfeit of edge points. In the next slot SigQx 2 we need two edge points, and the corresponding slot in SigCx i+1 has the two required edge points. However, in the slot SigQx 3 we need four pixels, but the corresponding slot in SigCx i+1 has only two pixels. Thus, we are guaranteed that no matter how the pixels are arranged, this column will contribute at least two to the number of missed edge points in the accumulator. As we continue, we find that neither of the two remaining slots contributes to the lower bound, because in each case there are at least enough pixels in SigCx to satisfy SigQx . Thus, we can say that in this alignment, the lower bound LB( SigQx , SigCx [4:8] ) = 2. Note that this lower bound is only for the particular alignment shown in Figure 10; if we had shifted SigQx one to the left, the lower bound would be 12, and if we had shifted SigQx one to the right, the lower bound would also be 12. If we test all alignments, we must choose the smallest value discovered as the true lower bound for the columns, which we denote as LB( SigQx , SigCx ) = 2. Finally, as hinted at above, we can do the same thing for the rows, using SigQy and SigCy. The final global lower bound to D( Q , C ) is then simply the larger of the two individual lower bounds We expand the intuition presented in the last section to introduce a formal description of the lower bound. We again begin by considering the lower bound for just the columns. The algorithm is formalized in Table 2, which takes in a query shape Q and the column signature of candidate shape C . As described in the previous section, to obtain LB( SigQx , SigCx ), we need to shift SigQx from left to right of SigCx by aligning the center of mass of SigQx to each cell of SigCx (lines 5,7 and 8 of Table 2). In each alignment, we calculate the lower bound for each column of C . Note that when some cells of SigQx shift out of SigCx , the edge points in these cells cannot find points in C to match them and then all contribute to the number of missed points (line 9-10 of Table 2). Finally, LB( SigQx , SigCx ) is the minimal value of all these lower bounds (reflected in line 21-23 of Table 2). One important optimization we use here is early abandoning . When calculating the lower bound for a column, if the number of missed points exceeds the current best ( smallest ) lower bound, we can stop calculations and shift to the next position (line 17-19 of Table 2). For a better pruning, we can align SigQx and SigCx by their centers of mass first, and th en shift stepwise to two sides (omitted in Table 2 for brevity). Q C In summary, we have: To get the final lower bound, we simply run the algorithm in Table 2 again, this time with SigCy instead of SigCx , and with all column operators changed to row operations. After then calculating LB( SigQy , SigCy ), the final lower bound LB( Q , C ), is simply max [LB( SigQx , SigCx ), LB( SigQy , SigCy )]. The time complexity of our lower bound algorithm is O( S 2 that it is independent of the numbe r of edge points in images. As we shall show in Section 4.3, si milarity search using the lower bound achieves a one to two order of magnitude speed-up. While the MUE is in itself a useful distance measure, it is helpful to consider slight variations of it to enable higher-level data mining algorithms. Note that in every case, we can still use the lower bound technique to speed up the high-level data mining algorithms. Below we consider thr ee useful variants, and in the next section we empirically evaluate them. Query-by-Content : In the simple examples we have considered thus far, we have implicitly assumed that the number of edge points in Q and C was the same. While MUE is surprisingly robust to small deviations from this assumption (say, less than a factor of two differences) it is clear that it has a bias. In particular, images that have relatively numer ous edge points simply tend to be somewhat similar to everything. Since any large collection of images will invariably contain a fe w of these  X  X ich X  images, they can distort the results of any nearest neighbor searches. To mitigate this problem we define the nearest neighbor distance from Q to C as: Note that we do not use MUE directly, but the inverse of  X  N MUE  X  (i.e. maximal matched edge points ). The term an explicit penalty for the problem N C &gt;&gt; N still use the lower bound of MUE to lower bound D nn ( Q,C ). Clustering : The D nn measure is perfect for similarity searching, which requires one-to-all matching. However, clustering requires all-to-all matching. In this case, with all things being equal, the D nn measure would be biased into claiming that two images with many edge points are more similar than two images with few edge points. We can use D clustering ( Q,C ) to compensate for this: Finding Motifs : Many data mining algorithms explicitly require a distance measure that obeys the triangular inequality. As a concrete example, we recently introduce an efficient and exact algorithm for finding motifs (approxi mately repeated patterns) [16], which makes no assumptions about the data or distance measure, other than the triangular inequality. We can modify MUE to obtain such a distance with: The proof of triangular inequality can be found at [27]. We have designed all experiment s such that they are not only reproducible, but easily reproducible. To this end, we have built a webpage [27] which contains all da tasets and code used in this work, together with spreadsheets which contain the raw numbers displayed in all the figures. The webpage also contains many additional experiments which we did not include for brevity; however, we note that this paper is completely self-contained. All of the experiments are performed on a computer with an Intel i7-920 processor and 6.0GB of DDR3 memory. We begin with simple sanity checks. We took a collection of petroglyphs from the Southwest USA and extracted fourteen images that would reasonably be grouped into seven pairs. Figure 11 shows the clustering obtained by our distance measure. Not only does the measure correctly group the seven pairs, but the higher level structure of the dendrogram correctly groups the images into Bighorn Sh eep/Anthropomorphs/Atlatls 2 . Note that due to the thinning preprocessing step, the measure seems invariant to the hollow/solid nature of the Atlatls. In the 1920 X  X  Dr. Stephen Chauvet noticed that many of the petroglyphs discovered on Easter Island showed humans in poses very similar to petroglyphs created by the Harappa culture (in what is now modern-day Pakistan). He noted these similarities in his 1935 text [7], which inspired a flurry of speculation about the origin of the Easter Island peoples 3 . It is natural to ask if our proposed distance measure could ha ve  X  X oticed X  this similarity. This is a very difficult challenge for a distance measure, because the Harappa culture used stick-figures, whereas the Easter Island petroglyphs used highly stylized outlines. Nevertheless, as we can see in Figure 12, our method can capture the intuitive similarities. Because there currently no large collections of objectively labeled petroglyphs, in this section we will test two publicly available datasets that are very similar to (some kinds of) petroglyphs. With these experiments we intend to show:  X  Competitive or superior accuracy for query-by-content compared to some state-of-the-art algorithms.  X  Relative insensitivity to amount of downsampling, which would mean our method is essentially parameter-free.  X  As claimed in Figure 4, very high resolution imagery hinders rather than helps accuracy. The first dataset is the NicIcon dataset [17], which contains 24,441 images from the 14 categories shown in Figure 13. Thirty-three participants were asked to sketch these icons in different sizes (small, medium and large) a nd a digital tablet was used to record the data (spatial, time and pressure coordinates). Note that counter to the original intention for the data and subsequent algorithms, our algorithm only considers the shape, and completely ignores pen speed and pressure information.
 We did both writer dependent (W D) and writer independent (WI) tests, in both cases, randomly choos ing 60% of data as the train set and the rest as the test set, the same division as used the original paper [17]. The original data is 234 X 234 pixels . To explore the sensitivity of our algorithm to the amount of downsampling (its only user-specified parameter), we tested on six resolutions from 5 X 5 to 50 X 50 for both WD and WI tests, using the simple one-nearest-neighbor classifier. Figure 14 shows the results. This plot suggests the sampling rate is not critical. The error rate only increased significantly when resolution was reduced to 5 X 5, which is clearly highly undersampl ed for any non-trivial dataset. We obtained the best error rate 4.78% for WD and 8.46% for WI with the size of 20 X 20 pixels. The dataset creators tested on the online data using three classifiers [17]: the multilayered perceptron, the linear multi-class SVM classifier and a Dynamic Time Warping Based (DTWB) algor ithm. The reported error rate for WD is from 1.94% to 15.61% and 5.3% to 20.01% for WI. Only the DTWB is better than our method, and recall that the DTWB had access to information about the pen speed, pen pressure, and the direction in which the lines were drawn, all of which is unknown to our algorithm. While the original authors do not measure time for classification, each comparison with the DTWB measure requires DTW calculations to be performed a number of times which are quadratic in the number of line strokes (i.e, the number of pen-ups) in each image, which is clearly very expensive. We also tested without any dow nsampling, and the error rate increased dramatically: 31.75% for WD and 35.75% for WI, even worse than the ultra-low resolution 5 X 5. This verifies our analysis in Section 2.2. Another petroglyph-like dataset is introduced by Khosravi and Kabir [13]. It is a very large dataset of handwritten Farsi digits extracted from about 11,942 regist ration forms. They obtained 102,352 binary images of Farsi digits, and chose 60,000 for training and 20,000 for testing (see samples in Figure 15). The size of images in the Farsi dataset is smaller than in the NicIcon dataset: the minimum bounding rectangle (MBR) of the largest digits is 54 X 64 pixels. We tested on four downsampling resolutions from 5 X 5 to 30 X 30, using a one-nearest-neighbor classification using the same train and test data splits. The results are shown in Figure 16. We obtained the best error rate of 4.54% in the resolution of 20 X 20 (the same as the best reso lution for the NicIcon dataset). Borji et al. [6] performed extensive empirical tests on this dataset, testing multiple algorithms, 3-NN, ANN, SVM polynomial and SVM RBF , each with four parameter choices (two choices of filters times two numbers of orientations ). Of the twenty reported error rates, the mean was 8.69% and only four combinations beat our approach with a best performance of 2.36%. However, it is important to note that in addition to the two explicit parameter choices, there are at least four other parameters set  X  X n the background X  here. Having shown that low resolution images can produce high accuracy in our domain, we have fixed the resolution to 30 X 30 pixels in all remaining expe riments in this paper. As noted in Section 2, while we currently have only thousands of petroglyphs, we expect to shortly have on the order of a million. Therefore, we will test our algorithm dataset containing more than one million objects. To make this possible, we made our own synthetic petroglyphs dataset. We obtained the twenty-two petroglyphs (samples are shown in the top row of Figure 17). Then ten volunteers were asked to duplicate the petroglyphs by drawing them with an HP pavili on tx2510us tablet PC. A total of 250 petroglyphs were created in this way as our basic dataset (samples are shown in the second row of Figure 17). We then applied a random second-order Polynomial Transformation to each image in the basic dataset to make [39 79 159 319 639 1,279 2,559 5,119] distorted copies of each (as shown in the third row of Figure 17). With this basic dataset, we finally created eight datasets from size 10,000 to 1,280,000. We first did a leave-one-out one-nearest-neighbor test. For each dataset, we randomly picked an image as the testing sample, removed it from the dataset and found its nearest neighbor using our lower bound based algorithm. We repeated this process ten times; Figure 18 shows the result. We can see that the range between the maximal and minimal time is relatively small. When viewed on a normal scale plot (see [27]), we can see that the average runni ng time is linear to the size of that the accuracy of this 22-class problem is 100% for all experiments. It is natural to ask how much of the effectiveness of the search can be attributed to our lower bound. We measured the pruning rate: for each of the 10 runs; the result is shown in Figure 19. The results show that the pruning is extremely effective, particularly for larger datasets. The average prune rate exceeds 99.0% when examining 80,000 objects, and even the minimal prune rate is more than 96.9% at that point. We also did a similar experiment with the brute force algorithm. Figure 20 compares the percentage of execution time for our lower bound algorithm relative to the brute force algorithm. Notice that for the largest dataset, our lower bound time is only 2% of the brute force one. In addition to query-by-content, we also tested our ability to find motifs in these datasets. We can use the D motifs combined with the algorithm r ecently published in [16] to efficiently find a pair of images whose distance is the smallest in a given dataset. Figure 21 shows the running time of finding motifs in our synthetic petroglyphs datasets. A brute force algorithm to find motifs requires time quadratic in the size of dataset. But from a normal scale plot (see [27]), we find that our algorithm scales linearly. This is because we only need to calculate a tiny fraction of the exact distance between two images: even for the smallest da taset with 10,000 objects, we can prune 99.84% of the calculations, and by the time we are considering 1,280,000 images we are pruning more than 99.99% of the calculations. In Figure 22 we show the explicit speed-up over the brute force search. Even for the smallest dataset, our algorithm is 712 times faster and by the time we see the largest dataset, our algorithm is more than 100,000 times faster. While these results show that we can make the otherwise intractable task of finding motifs in large datasets tenable, it does not consider the effectiveness . Normally motif discovery cannot be evaluated directly in terms of accuracy, since we assume unlabeled data. However, since we actually know the labels in this case, we can measure the accuracy. For example when testing the dataset with 80,000 petroglyphs images (from 22 classes) over 100 runs on random sets of 80,000 objects (taken from a pool of 1280K) , we found that on 99 occas ions the labels agreed. In this work we consider, for th e first time, the problem of mining large collections of rock art. We introduced an explicit framing of the GHT algorithm as a similarity measure, and showed that by lower bounding the measure we can effectively mine large data archives. Future work includes achieving rotation invariance and supporting partial shape matching. Acknowledgements : This work was funded by NSF 0803410 and NSF 0808770. And we would like to thank the many donors of datasets, particularly Dr. Robert Mark and Evelyn Billo of www.rupestrian.com , and Taryn T. Rampley of UCR. [1] von Ahn, L., Maurer, B., McMillen, C., Abraham, D., and Blum, M. [2] von Ahn, L.2006. Games with a purpose. Computer, 39(6):92 X 94. [3] Aseyev, I. V. 2008. Horseman image on an ostrich eggshell [4] Bai, X., and Latecki, L. J. 2008. Path similarity skeleton graph [5] Ballard, D. H. 1981. Generalizing the Hough transform to detect [6] Borji, A., Hamidi, M., Mahmoudi, F. 2008. Robust handwritten [7] Chauvet, St X phen-Charles. 1935. L'  X le de P X ques et ses Myst X res [8] Duda, R. O. and Hart, P. E. 1972. Use of the Hough transform to [9] Grant, C., Baird, J. &amp; Pringle, J. K. 1968. Rock drawings of the coso [10] Henshilwood, CS., d'Errico, F., Yates, R., Jacobs, Z., Tribolo, C., [11] Hough, P.V.C. 1966. Method and mean for recognizing complex [12] Keogh, E., Wei, L., Xi, X., Lee, S. H. and Vlachos, M. 2006. [13] Khosravi, H., Kabir, E. 2007. Intr oducing a very large dataset of [14] McDonald, J. J., Veth, P. M. 2007. Pilbara and Western desert rock [15] Merlin, P. M., and Farber, D. J. 1975. A parallel mechanism for [16] Mueen, A., Keogh, E., Zhu. Q., Cash, S., Westover, B. 2009. Exact [17] Niels, Ralph., Willems, Don. &amp; V uurpijl, Louis. 2008. The NicIcon [18] Pan, J., Balan, A., Xing, Eric P., Traina, Agma J. M., Faloutsos, C. [19] Pettigrew, J., Nugent, M., McPhee, A.,Wallman, J. 2008. An [20] Powell, J. W. (Editor) 1888. Annual report of the Bureau of [21] Takaki, R., Toriwaki, J., Mizuno, S., Izuhara, R., Khudjanazarov, M. [22] Valladas, H., Clottes, J., Geneste, J-M., Garcia, MA., Arnold, M., [23] Veltkamp, R.C. 2001.Shape matching: similarity measures and [24] Walt, H., David, B., Brayer, J. &amp; Musello, C. 2006. The International [25] Wolfson, H. J. &amp; Rigoutsos, I. 1997. Geometric hashing: an [26] Zhang, D. and Lu, G. 2004. Review of shape representation and [27] Zhu, Q. 2009. The Petroglyphs Webpage: 
