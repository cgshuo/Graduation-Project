 Keyword search in relational databases has gained popular-ity due to its ease of use. However, the challenge to return query answers that satisfy users X  information need remains. Traditional keyword queries have limited expressive capa-bility and are ambiguous. In this work, we extend keyword queries to enhance their expressive power and describe an semantic approach to process these queries. Our approach considers keywords that match meta-data such as the names of relations and attributes, and utilizes them to provide the context of subsequent keywords in the query. Based on the ORM schema graph which captures the semantics of objects and relationships in the database, we determine the objects and relationships referred to by the keywords in order to in-fer the search target of the query. Then, we construct a set of minimal connected graphs called query patterns, to rep-resent user X  X  possible search intentions. Finally, we translate the top-k ranked query patterns into SQL statements in or-der to retrieve information that the user is interested in. We develop a system prototype called ExpressQ to process the extended keyword queries. Experimental results show that our system is able to generate SQL statements that retrieve user intended information effectively.
 H.3.3 [ Information Storage and Retrieval ]: Information Search and Retrieval X  X earch process Keyword Query; Relational Database; Semantic Approach
Designing effective query mechanisms for users to query large and complex databases easily has been one of the most elusive goals of the database research community. Tradi-tional structured query models such as SQL for relational databases provide functionalities to query databases precise-ly. However, they require users to be knowledgeable about database schemas and query languages. Keyword queries have gained popularity due to their ease of use. However, they are inherently ambiguous and it is difficult to determine the users X  search intention.

The traditional approach to evaluate a keyword query first materializes the database as a graph where each node rep-resents a tuple and each edge represents a foreign key-key reference, and then finds the minimal connected subgraphs that contain all the keywords [8, 9, 6, 15]. But this is com-putationally expensive as the number of subgraphs is huge. Another approach translates a keyword query into a set of SQL statements, and leverages on relational DBMSs to e-valuate the statements and retrieve answers [1, 7, 5, 12, 13]. However, these works do not analyze the users X  search inten-tion, and often returns an overwhelming amount of answers, many of which are complex and not easily understood.
Recently, [2] exploits the relative positions of keywords in a query along with auxiliary external knowledge to make an educated guess of the users X  search intention. They measure the likelihood of mapping from a keyword to the database structure (a relation, an attribute, or a tuple), and generate the most probable mappings for the query keywords.
We observe that a relational database is essentially a repos-itory of objects that interact with each other via relation-ships that are embedded in the foreign key-key references. When a user issues a query, s/he must have some particular search intention in mind. If we can determine the keywords that refer to the same object or relationship in the database, we would be able to infer the search target of the user. These keywords can also provide the context of subsequent query keywords that impose conditions on the search target.
Figure 1 shows a sample company database. Suppose a user issues a keyword query { Employee Brown } .Thekey-word Brown can refer to an employee name or a department address. However, since the keyword Employee matches the name of the Employee relation, we deduce that the user is more likely to be interested in an employee called Brown than the address of a department. In other words, a keyword that matches a relation name specifies a target object or re-lationship, while a keyword that matches an attribute name indicates the information that the user wants to retrieve for the target object/relationship. Keywords that match tuple values impose restrictions on the object/relationship.
In this work, we extend the expressive power of keyword queries so that users can better express their search inten-tions. We design a semantic approach to process these ex-tended keyword queries. Our approach considers keyword-s that match meta-data e.g., names of relations and at-tributes, and utilizes them to provide the context of subse-quent keywords in the query. We discover the various ways objects in a database interact with each other, and construc-t query patterns to denote user X  X  possible search intentions. We propose a ranking scheme that takes into account the searchtargetsofthequeryaswellasthenumberofob-jects captured in a query pattern. The top-k ranked query patterns are used to generate SQL statements. We devel-op a prototype system called ExpressQ to process extend-ed keyword queries. Experimental results on two databas-es demonstrate the effectiveness of ExpressQ in generating SQL statements to retrieve relevant information for users.
The work in [16] classifies the relations in a database in-to object relations, relationship relations, mixed relation-s and component relations. An object (relationship) rela-tion captures the information of objects (relationships), i.e., the single-valued attributes of an object class (relationship type). Multivalued attributes are captured in the compo-nent relations. A mixed relation contains information of both objects and relationships, which occurs when we have a many-to-one relationship.

In our example database in Figure 1, relations Project and Department are object relations as they contain single-valued attributes of project and department objects respec-tively. Relations EmpProj and ProjDept are relationship relations. Employee is a mixed relation as it captures in-formation of employee objects and the many-to-one rela-tionships between employee and department objects. The relation EmployeeSkill is a component relation containing the multivalued attribute of employees.

We can model the relational schema with an undirect-ed graph called Object-Relationship-Mixed (ORM) schema graph G =( V,E ) [16]. Each node v  X  V comprises of an ob-ject/relationship/mixed relation and its component relation-s, and is associated with a v.type  X  X  object, relationship, mixed } . Two nodes u and v are connected via an edge e ( u, v )  X  E if there exists a foreign key-key constraint from the relations in u to that in v .
 Figure 2 shows the ORM schema graph of the database in Figure 1. It has two object nodes (rectangle), two relation-ship nodes (diamond) and one mixed node (hexagon). The node Department is an object node that comprises of the object relation Department , while the node Employee is a mixed node that comprises of the mixed relation Employee and component relation EmployeeSkill .Thesetwonodes are connected via an edge because there is a foreign key-key constraint from the relation Employee to the relation Department .
 Suppose a user issues the keyword query { Smith Green } . Both keywords match some employee name in the Employee relation. Based on the ORM schema graph in Figure 2, these two employees are possibly related via the relationship EmpProj , the many-to-one relationship with departments, and a combination of these relationships. Thus, some of the possible interpretations of the query are: a. Find information on the project in which both employ-b. Find information on the department in which both em-c. Find information on the department which conducts
Existing works would consider all the above query inter-pretations and retrieve the corresponding information from the database. Consequently, the user is often overwhelmed by a huge number of answers, many of which are complex and not easily understood.

In order to reduce the ambiguity of keyword queries, we propose to allow users to explicitly indicate his/her search intention whenever possible. This can be achieved by aug-menting the query with additional keywords that match the names of relations and attributes. For example, if the user would like to find the information on the department that both the employee Smith and the employee Green work in, s/he can express the query as { Department Employee Smith Employee Green } . The keyword Department matches the name of the Department relation, indicating that the us-er is interested in the information of the department. While the keyword Employee matches the name of the Employee relation, giving the context that the keywords Smith and Green refer to names of two employees.

Definition 1. An extended keyword query consists of a sequence of keywords Q = { k 1 k 2  X  X  X  k n } such that each keyword k matches a relation name, or an attribute name or a tuple value.
Given an extended keyword query, we want to generate a set of SQL statements that best capture the user X  X  search intention. This entails the following steps: 1. Query analysis. We parse each keyword in the query 2. Query interpretation. Based on the groups of tags, 3. SQL statement generation. The top-k ranked query The following sections give the details of each of these steps.
Given an extended keyword query Q = { k 1 k 2  X  X  X  k n } , we will determine the interpretation(s) of each keyword in Q . We capture each keyword interpretation in a tag T = ( label, attr, cond ), where label is the name of the object or relationship, attr is the attribute name, and cond is the restriction on the object or relationship. The restriction occurs in the form of a value. The tag(s) for a keyword k is generated depending on the following type of matches: a. k matches the name of some object/mixed/relationship b. k matches the name of a component relation or an c. k matches some tuple value.
 Example 1. Consider the keyword queries in Table 1. Table 2 shows the sequence of tags generated for these queries. For query Q 1 , we know that the keyword Department match-es an object relation, while the keyword Employee matches a mixed relation from the ORM schema graph in Figure 2. Hence, these keywords refer to the names of department and employee objects in the database, and we capture their inter-pretations in the corresponding tags. On the other hand, the keywords Smith and Green match the Name attribute values of some tuples in the Employee relation, and we capture these information in their tags T 13 and T 15 .

Query Q 2 contains the keyword Skill that matches an at-tribute name. From the ORM schema graph, we see that this attribute belongs to the component relation EmployeeSkill which is associated with the mixed node Employee .Hence, we know that skill is a multivalued attribute of the employee object and we capture this interpretation in the tag T 23 ther, the keywords Java and PhP match the Skill attribute values of some tuples.

Note that Q 3 contains the keyword Brown that matches the Name attribute value of some tuple in Employee rela-tion, as well as the Address attribute value of some tuple in Department relation. In this case, we create a tag for each matching. The tag T 34 in Table 2 captures the interpretation that keyword Brown refers to an employee name, while the tag T 34 captures the interpretation that Brown refers to a de-partment address. Hence, we see that Q 3 has two sequences of tags, denoting two different query interpretations.
After creating a sequence of tags for the keywords in the query, we group the tags that refer to the same object or re-lationship together. Clearly, tags that do not have the same label are placed into different groups since their keywords refer to different objects/relationships. However, keywords with tags that have the same label do not necessarily refer tothesameobject/relationship.
 Example 2. Consider query Q 1 in Table 1 and its tags in Table2. Allthesetagsexcept T 11 have the same label Em-ployee . However, their keywords actually refer to different objects: keywords Employee and Smith refer to the employee named Smith , while keywords Employee and Green refer to the employee named Green .

This example demonstrates the need to process the tags of keywords in a keyword query in sequence, and examine the objects or relationships referred to by the current and preceding keywords.

Let T be the sequence of tags for a query Q . We put a tag T i  X  X  into a new group to denote a different objec-t/relationship if one of these following cases is true: Case 1. T i has a different label from all the tags T j  X  X  j  X  [1 ,i  X  1].
 Case 2. T i has the same label as T j  X  X  for some j  X  [1 ,i  X  1], and the attr and cond of T i are null . Case 3. T i has the same label and attr as T j  X  X  for some j  X  [1 ,i  X  1], and attr is not a multivalued attribute.
A tag that satisfies Case 2 indicates that its keyword refer-stoa new object/relationship and provides the context for the next keyword in the query. Hence, we create a new group for this tag. On the other hand, a tag that satisfies Case 3 indicates that both its keyword and the preceding keyword refer to the same single-valued attribute of an ob-ject/relationship or its values. Since an object/relationship cannot have a single-valued attribute with two values, the keyword of this tag must refer to a new object/relationship. Example 3. Let us consider the sequence of tags for Q 1 . Tags T 11 and T 12 belong to two different groups g 1 and g since they have different labels. Since tag T 13 has the same label Employee as its preceding tag T 12 , it is placed in the same group g 2 . T 14 is put in a new group g 3 because its attr and cond are null and it refers to a different employee object (Case 2). Since T 15 has the same label as T 14 ,itisputin g . Notethatwecannotput T 15 in g 2 because Name is a single valued attribute of employees, and it is not possible for the same employee to have two different names (Case 3). In other words, the keywords Smith and Green are the names of two different employees. Hence, the tags for Q 1 are grouped as follows:
The following example illustrates a query involving mul-tivalued attributes.

Example 4. Consider query Q 2 and its sequence of tags in Table 2. The tags T 22 , T 23 ,and T 24 have the same label and are put in the same group. Note that T 24 and its pre-ceding tag T 23 have the same label and attr .Theyareput in the same group because the attribute Skill is a multivalued attribute. In other words, the keywords Java and PhP refer to the values of the multivalued attribute Skill ,andtheuser is interested in an employee who knows both Java and PhP . Hence, the tags for Q 2 are grouped as follows:
After grouping the tags of a query, the next step is to generate query patterns . Each query pattern is a minimal connected graphs that represents one possible search inten-tion of the query. Intuitively, we construct a query pattern by creating a node to represent each object/relationship re-ferred to by each group of tags. These nodes will correspond to nodes in the ORM schema graph and we can connect them based on the edges in the graph.
 Let S = { g 1 ,g 2 ,  X  X  X  ,g m } be a set of tag groupings, and G =( V,E ) be the ORM schema graph. A query pattern P =( V ,E ) is constructed as follows. For each group of tags g i  X  S ,1  X  i  X  m ,wecreateanode u i to denote the object/relationship referred to by g i . The corresponding object class or relationship type is given by a node v i in G . We say that u i corresponds to v i .

Let D = { u 1 ,u 2 ,  X  X  X  ,u m } and D = { v 1 ,v 2 ,  X  X  X  ,v first insert the nodes in D into the query pattern P .If |
D | = 1, then all the tags in the query are in one group which refers to the same object/relationship. Hence, the query pattern P has only a single node. However, if we have |
D | &gt; 1, then we need to use the schema graph G to con-nectthesenodes.Wehavetwocasestohandle: Case A. The object class or relationship type of every ob-ject/relationship is distinct.

In this case, all the nodes in D correspond to distinct nodes in D , i.e., | D | = | D | . We find a minimal subgraph H of G that connects all the nodes in D . For each intermediate node x in H , we create a node x that corresponds to x and insert it into P . For each edge e ( x, y )in H , we create an edge e ( x ,y )in P .
 Case B. The object class or relationship type of every ob-ject/relationship is not distinct.

In this case, some objects (or relationships) have the same object class (or relationship type). In other words, two or more nodes in D correspond to the same node in G , i.e., |
D | &gt; | D | . Weclusterthenodesin D according to their object classes, and connect the nodes between the clusters. We try to find a node u  X  D such that u can connect to the other nodes in D based on the paths between their corre-sponding nodes in the ORM schema graph. If no such node exists, we create a node x that corresponds to some node x  X  G to connect all the nodes in D .
 The following examples illustrate the above cases.
Example 5. Let us consider the set of tag groupings S = { g 21 ,g 22 } obtained for query Q 2 in Example 4. We create two nodes u 1 and u 2 to represent g 21 and g 22 respectively. Nodes u 1 and u 2 correspond to the nodes Project and Em-ployee in the ORM schema graph in Figure 2 respectively (Case A). Since the Employee and Project nodes can be con-nected via the EmpProj node in the ORM schema graph, we create a new node u 3 that corresponds to the EmpProj node to connect u 1 and u 2 , and output the graph as a query pat-tern (see Figure 3). This query pattern captures the user X  X  intention to find the information on the project that involves the employees with both skills Java and PhP .

Example 6. Consider the 3 groups of tags g 11 ,g 12 and g 13 obtained for Q 1 in Example 3. We create a set of nodes D = { u 1 ,u 2 ,u 3 } for these groups, and D = { Employee Department } . Note that the corresponding object classes of the nodes in D are not distinct (Case B). Node u 1 corre-sponds to the Department node in the ORM schema graph, while both nodes u 2 and u 3 correspond to the Employee node. We cluster the nodes in D according to their object classes, and connect the nodes between the clusters, i.e., c 1 = { and c 2 = { u 2 ,u 3 } , and we try to connect u 1 to u 2 Based on the ORM schema graph, the Department node can connect to the Employee node directly. Hence, we create two edges to connect u 1 to u 2 and u 3 respectively. Figure 4(a) shows the query pattern P 1 obtained which indicates that the user wants to find information on the department that both employees Smith and Green work in.
Further, we observe that the Department node can also connect to the Employee node via the path Department  X  Pro-jDept  X  Project  X  EmpProj  X  Employee in the ORM schema graph. By creating nodes u 4 and u 5 (correspond to ProjDep-t ), u 6 and u 7 (correspond to Project ), u 8 and u 9 (correspond to EmpProj ), we obtain the query pattern P 2 in Figure 4(b). This pattern indicates that the user is interested in the de-partment with projects involving both employees Smith and Green .
After generating the various query patterns, the next step is to rank them. The standard method typically ranks graph-s based on the number of nodes, i.e., a smaller graph is more easily understood and is ranked higher than a larger com-plex graph. This approach does not consider the semantics of objects and relationships in the graphs. For example, a query to find an employee who have both skills Java and Ph-P will have a graph with 3 nodes ( EmployeeSkill  X  Employee  X  EmployeeSkill ), each of which denotes a relation tuple. However, all 3 nodes refer to the same employee object. It should not be ranked equally as a graph with 3 nodes such as Employee  X  EmpProj  X  Project , where nodes Employee and Project refer to two different objects.

We observe that when a user issues a query, s/he must have some particular search intention in mind. We refer to the objects/relationships that meet the user X  X  interest in the search intention as the search targets of the query. Our pro-posed ranking scheme aims to take into account the search targets of the query as well as the number of object/mixed nodes in the query patterns.

In order to identify the search targets of a query, we clas-sify the nodes that correspond to the tag groups into target nodes and condition nodes since they denote the objects and relationships that the user is interested in. A target node specifies the search target of the query, while a condition node indicates the search conditions of the query. In our Example 6, u 1 is a target node since the user is interested in the information on a department. On the other hand, u 2 and u 3 are condition nodes as they specify two particu-lar employees by their names. We define target nodes and condition nodes formally as below:
Definition 2. Let u be an object/relationship node re-ferred to by a tag group g .Wesay u is a condition node if  X 
T  X  g such that T.cond = null . Otherwise, u is a target node if: 1.  X  T  X  g , we have T.cond = null or 2.  X  T  X  g such that T.attr = null and T  X  g where
The first condition indicates that the user is interested in the information of an object/relationship, while the second condition indicates that the user is interested in obtaining information on an object/relationship attribute.

Note that a node can be both a target node and a condi-tion node. Suppose we have the following group of tags: This group of tags refers to a department object node that is both a target and a condition node since the semantics of the tags indicates that the user is interested in the name of the department in Queen street.

Let X be the set of target nodes, Y be the set of condition nodes, and N be the number of object and mixed nodes in a query pattern P . Wecomputeascorefor P by counting the number of objects involved in the query pattern and the average distance between the target and condition nodes. We define the score of a query pattern P as: where dist ( u, v, P ) is the total number of object and mixed nodes in the path connecting two nodes u and v in P .
Query patterns with fewer object/mixed nodes, and a shorter average distance between target nodes and condi-tion nodes will be scored higher.
 Example 7. Figure 5 shows two query patterns P 1 and P 2 for the query Q 3 = { Project Employee Green Brown } . P indicates that the user wants to find the information on the project that involves both the employees Green and Brown , while P 2 indicates that the user is interested in the project involving the employee Green who works in the department in Brown street. Both these query patterns have 3 object/mixed nodes. Besides, node u 1 is a target node while nodes u 2 u 3 are condition nodes. We compute the average distance between the target node ( u 1 ) and the condition nodes ( u and u 3 ) for both query patterns. P 1 has an average distance of 2+2 2 =2 ,while P 2 hasanaveragedistanceof 2+3 2 =2 . 5 . Thus, we have score ( P 1 )= 1 6 and score ( P 2 )= 2 15 ,and P will be ranked higher than P 2 .

We see that this ranking complies with human intuition that both the employees Green and Brown are  X  X losely X  related to the target project in P 1 . In contrast, the department in Brown street is related to the target project just because it has some employee ( Green ) involves in the project in P 2 .Onthe other hand, using standard method which ranks graphs based on the number of nodes will give P 1 a lower rank than P 2 as P 1 consists of 5 nodes while P 2 consists of 4 nodes.
Note that a query may not contain keywords that explic-itly indicate the search targets. For example, none of the keywords in the query { Project XML Project RDB } indicate the search targets explicitly. In this case, we will need to infer the target nodes.

The work in [11] defines the centric distance of a node u as the longest distance between u and any node in the graph. Further, the radius of the graph is the minimal value among the centric distances of every node. A query answer is a graph whose radius is not larger than a specified value. Here, we use the radius of query patterns to determine the target nodes.

We define the centric distance of a node u in P as the longest distance between u and any node v in P ,thatis, Then the radius of P is given by the shortest centric distance among all the nodes in P . We infer that a node u is a target node if its centric distance is equal to the radius of P .
Example 8. Figure 6 shows a query pattern for the query { Project XML Project RDB } with 3 object nodes. Both the nodes u 1 and u 2 correspond to the Project node in the ORM schema graph and are condition nodes. There is no target node in the pattern according to Definition 2. Thus, we will look for a node whose centric distance is equal to the radius of the query pattern. This gives us u 4 as the target node, indicating that the user is interested in the department that conducts both projects XML and RDB . We compute the av-erage distance between the target node u 4 and the condition nodes u 1 and u 2 ,andobtainascoreof 1 6 for this pattern.
Finally, we generate a set of SQL statements based on the top-k query patterns. These SQLs statements are used to retrieve results from the relational database. The results are then returned as answers to the extended keyword query.
For each query pattern P ,wegenerateanSQLstatement as follows: SELECT clause. For each target node u in P ,if u specifies a search target via the object or relationship name (Condi-tion 1 in Definition 2), then we include all the attributes of the relations of u in the SELECT clause. Otherwise, if u specifies a search target via an attribute name (Condition 2 in Definition 2), then we include only the corresponding attribute of the relations of u in the SELECT clause. If u is inferred from the radius of P , then we assume that user is interested in all of information of u and include all the attributes of the relations of u in the SELECT clause. FROM clause. The FROM clause contains the relations of all the nodes in P .
 WHERE clause. The WHERE clause joins the relation-s in the FROM clause based on the foreign key-key con-straints. Further, for each condition node u in P ,wecheck the group of tags that refer to the object/relationship de-noted by u .Foreachtag T such that T.cond = null ,we include the condition  X  T k .label.attr contains T k .val  X  X nthe WHERE clause.
 Example 9. Consider the query pattern P 1 in Figure 4(a). Node u 1 is a target node and denotes a department object, while nodes u 2 and u 3 are condition nodes that denote the employee objects named Smith and Green respectively. We will generate the following statement for the query pattern:
We design a system called ExpressQ which enables users to query the database using extended keyword queries. Fig-ure 7 shows the main components in ExpressQ: (a) Query Analyzer, (b) Query Interpreter, and (c) SQL Generator.
Given a query Q and the ORM schema graph G , we first call the Query Analyzer to produce a list of sets of tag group-ings. Since a keyword in an extended keyword query may be ambiguous, and may be associated with multiple tags, we enumerate the different sequence of tags for a query. For each sequence of tags, the Query Analyzer produces a set of tag groupings. Then we call the Query Interpreter to gen-erate a list of query patterns for each set of tag groupings. We compute the scores of the query patterns and output the top -k patterns. Finally, we generate the SQL statements for the top -k ranked query patterns. The results of these SQLs are returned as the answers of Q .
 Algorithm 1: QueryAnalyzer Algorithm 1 describes the details of the Query Analyzer. We first create a list of tags for each keyword in the query (Lines 2-3). For each sequence of tags, we group the tags that refer to the same object or relationship. We initialize S and put the tag of the first keyword T 1 into a group g (Lines 5-6). Next, we check whether the tags of the subsequent keywords can be put into the same group g (Lines 8-13), and create new groups if needed (Lines 14-19). Finally, we insert S into the list L (Line 20).

Algorithm 2 gives the details of the Query Interpreter. For each group of tags g i in S , we create a node u i to denote the object/relationship referred to by g i .Weadd u i into set D and its corresponding node v i in the ORM graph into set D . Then we insert u i into the query pattern P (Lines 3-7).
If D has only one node, we simply add P into Plist (Lines 8-9). Otherwise, we compare the number of nodes in D and D .If | D | = | D | , we find the minimal subgraph H of G that connects all the nodes in D . For each intermediate node x in H , we create a node x that corresponds to x and insert it into P . For each edge e ( x, y )in H , we create an edge e ( x ,y )in P . Then we add P into Plist (Lines 10-16).
If | D | is larger to | D | , we divide the nodes in D into clus-ters c 1 ,c 2 ,  X  X  X  ,c m such that the nodes in each c i corresponds toanode v i in D ,and | c i | X | c i +1 | ,  X  i  X  [1 ,m  X  1].
If the smallest cluster c 1 has only one node u 1 , then we connect u 1 to the nodes in c 2 ,c 3 ,  X  X  X  ,c m .Let H be the path that connect v 1 and v i in G . We connect u 1 to the nodes in c based on H (Lines 17-25).

On the other hand, if c 1 has more than one node, then we will use a node x that corresponds to some node x  X  G  X  D to connect all the nodes in c 1 ,c 2 ,  X  X  X  ,c m . For each object or mixed node x in G  X  D , we first create a copy P of P , and insert a node x that corresponds to x into P .Again, let H be the path that connect x and v i in G . We connect x to the nodes in c i based on H . After all the nodes in D are connected, we add P into Plist (Lines 26-34).
In this section, we evaluate the effectiveness and efficiency of the ExpressQ system. We implement the algorithms in Java and carry out experiments on an 3.40GHz CPU with Algorithm 2: QueryInterpreter 8GB RAM. We use two relational databases in our experi-ments: the TPC-H database (TPCH) and the ACM Digital Library publication (ACMDL).

We construct 7 queries for each database. Tables 3 and 4 show the queries and the corresponding descriptions (or search intentions). The keywords of these queries may match relation names, attribute names and tuple values.
One of the advantages of ExpressQ is its ability to identi-fy the context of keywords and the search target of a query to retrieve user X  X  intended information. We verify its effec-tiveness by comparing ExpressQ with Spark [13], an existing relational keyword search engine that does not consider key-word contexts or search targets.

Spark finds the relations whose tuples matches the query keywords, and constructs a set of minimal connected graphs called candidate networks based on these relations. The candidate networks are ranked according to their size, and SQL statements are generated from the top-k networks.
Table 5 shows the generated SQL statements that best match the descriptions of the queries for the TPCH database. We see that although both ExpressQ and Spark generate the same SQL statement for query T 1, they differ greatly for the rest of the queries.

Queries T 2to T 4 show that ExpressQ is more selective in its retrieval of information as it identifies the search target in the query. ExpressQ retrieves only the retail price of the part  X  X ose X  for T 2, whereas Spark overwhelms the user by retrieving all the attributes of this part. This is because Ex-pressQ has identified retailprice as the search target in T 2. Similarly, ExpressQ retrieves only the customer phone and order date information for T 3and T 4 respectively, while S-park retrieves all the attributes of the relations in the FROM clause.

Queries T 5to T 7 demonstrate that by considering the context of keywords, ExpressQ is able to generate SQL state-ments to retrieve information that the user is interested in. ExpressQ uses the context provided by the keyword supplier in both T 5and T 6 to correctly generates SQL statements that retrieve supplier information.

In contrast, Spark generates SQL statements to retrieve information on the nation  X  X anada X  for T 5, and part infor-mation for T 6. We see that this does not match the query descriptions of T 5and T 6. Similarly, for T 7, the SQL state-ment obtained from ExpressQ retrieves the intended cus-tomer information, while Spark retrieves item information instead. Table 6 gives the results for the ACMDL database. Both ExpressQ and Spark generate the same SQL statements for queries A 1and A 2 because these are relatively straightfor-ward keyword queries. However, for query A 3, ExpressQ correctly retrieves the affiliation of the author  X  X agadish X  while Spark retrieves all the attributes of the author. This is because Spark is unable to identify that affiliation is the search target of a query.

Queries A 4to A 7 show that the context of keywords is important and enables ExpressQ to correctly generate SQL statements that retrieves the intended information: pub-lisher information for A 4, paper information for A 5, editor information for A 6, and author information for A 7. On the other hand, we observe that Spark retrieves information that clearly do not match the query descriptions, e.g., proceed-ings for A 4, and authors for A 5.

The results of this set of experiments clearly indicate that identifying the keyword context and search target of queries greatly enhances the evaluation of keyword queries and leads to the retrieval of appropriate information.
Finally, we compare the time taken by ExpressQ and S-park to generate SQL statements for the queries. Figure 8 shows the results for both TPCH and ACMDL queries in Tables 3 and 4 on cold cache.

We observe that Spark is faster than ExpressQ when the number of nodes in the candidate network/query pattern is small. This is because Spark does not analyze the search intention of the queries but only finds candidate networks containing all the keywords that match tuple values. However, Spark is slower than ExpressQ for queries T 4, T 7, A 6and A 7. This is because the number of nodes in the candidate networks for these queries is large, and Spark needs more time to enumerate the networks in a breadth-first traversal manner. For example, Spark generates 339 intermediate graphs before finding the top 3 candidate net-works for query T 7. In contrast, ExpressQ finds the path customer  X  lineitem  X  orders in the ORM schema graph, and builds the query pattern based on this path directly.
Figure 9 compares the time taken by ExpressQ to gener-ate SQL statements, and the time needed to execute these statements over the databases. We see that the execution of SQL statements dominates the overall processing time (in seconds), indicating that the extra time taken by ExpressQ to analyze the queries (in ms) to identify the search intention of the user is a good tradeoff. We note that the execution time of SQL statements varies significantly with the number of results retrieved and the number of joins. For example, the SQL statement for query T 7 takes more than 30 minutes to join 5 relations, while the SQL statement for query T 5 takes only 78 ms to retrieve 412 results.
Existing works in relational keyword search typically use a schema graph or a data graph to process a keyword query. The schema graph approach models the database schema as an undirected graph where each node represents a relation and each edge represents a foreign-key key constraint. Early works such as DBXplorer [1] and DISCOVER [7] propose a breadth-first traversal on the schema graph to generate a set of SQL statements. The output tuples of each SQL contain all the query keywords. [5] incorporates an IR-style rank-ing strategy to evaluate the relevance of query results and proposes two algorithms to compute the top-k results. [12] improves the effectiveness of [5] by normalizing the rank-ing factors. [13] avoids the side effect of overly rewarding contributions of the same keyword in [5] and [12].
The data graph approach models the database as an undi-rected graph where each node represents a tuple and each edge represents a foreign key-key reference. BANKS [8] pro-poses a backward expansion search to find the Steiner trees that contain all the keywords, and evaluates the relevance of a Steiner tree based on its root and leaf nodes. [9] improves the efficiency of BANKS by using a bidirectional expansion search to reduce the search space. [3] employs a dynamic programming technique by identifying top-k minimal group Steiner trees. CI-Rank [15] considers the importance of n-odes, as well as the cohesiveness of the tree structure.
To improve the usability of keyword search, [10] summa-rizes the results of keyword queries so that users can re-fine their search based on these summaries. [14] finds co-occurring terms of keywords to provide users relevant infor-mation to refine the answers. [4] generates a list of object summaries. None of these works consider the context of keywords and search target in the queries.
In this paper, we have examined the problem of enhancing the expressive power and evaluation of relational keyword queries. This is achieved by extending the keyword queries in two aspects. First, we consider keywords that match meta-data e.g., names of relations and attributes, and uti-lize them to provide the context of subsequent keywords in the query. Second, we use the ORM schema graph to enrich the semantics of the keywords, and identify sets of keywords that refer to the same object/relationship in the database, in order to infer the search target of the query. The proposed approach is implemented in a prototype system called Ex-pressQ that analyzes keyword query to identify user X  X  search intention and generates SQL statements to retrieve relevan-t information. Experimental results demonstrate that the effectiveness of ExpressQ.
