 Mining significant patterns in sequence(s) is an important and fundamental issue in knowledge discovery, including sequential patterns, frequent episodes, frequent continuities and periodic patterns [1]. In these studies, discovering frequent serial episodes is a basic problem in sequence analyzing[3]. The goal of episode mining is to find relationships between events. Such relationships can then be used in an on-line analysis to better explain the problems that cause a particular event or predict future result. Serial episode m ining has been of great interest in many applications, including internet anomaly intrusion detection [2], biomedical data analysis and web log analysis.

The task of mining frequent episodes was originally defined on  X  X  sequence of events X  where the events are sampled regularly as proposed by Mannila et al. [3]. Informally, an episode is a partially ordered collection of events occurring together. The user defines how close is close enough by giving the width of thetimewindow win . Mannila et al. introduced three classes of episodes. Serial episodes consider patterns of a total o rder in the sequence, while parallel episodes have no constraints on the relative order of event sets. The third class contains composite episodes like serial combination of parallel episodes.

Mannila et al. presented a framework for discovering frequent episodes through a level-wise algorithm, WINEPI [3], for finding parallel and serial episodes that are frequent enough. The algorithm was an Apriori-like algorithm with the  X  X nti-monotone X  property of episodes X  support. The support of an episode is defined as the number of sliding windows, a block of win continuous records, in the sequence. Take the sequence S = A 3 A 4 B 5 B 6 as an example, there are 6-3+3=6 sliding windows in S given win =3,e.g. W 1 = A 3 , W 2 = A 3 A 4 , W 3 = A 3 A 4 B 5 , W 4 = A 4 B 5 B 6 , W 5 = B 5 B 6 and W 6 = B 6 . Unfortunately, this support count has a defect in confidence calculation of an episode rule. For example, the serial episode rule  X  X hen event A occurs, then event B occurs within 3 time units X  should have probability or confidence 2/2 in the sequence S since every occurrence of A is followed by B within 3 time units. However, since episode &lt;A&gt; is supported by four sliding windows, while serial episode &lt;A,B&gt; is matched by two sliding windows ( W 3 and W 4 ), the above rule will have confidence 2/4.
 Instead of counting the number of sliding windows that support an episode, Mannila et al. consider the number of mi nimal occurrences of an episode from another perspective. They presented M INEPI [4], an alternative approach to the discovery of frequent episodes from minimal occurrences ( mo ) of episodes. A minimal occurrence of an episode  X  is an interval such that no proper subwindow contains the episode  X  . For example, episode &lt;A&gt; has mo support 2 (interval [3,3] and [4,4]), while episode &lt;A,B&gt; has only mo support 1 from interval [4,5]. Thus, the above rule will have confidence 1/2. However, both measures are not natural for the calculating of an episode rule X  X  confidence. Therefore, we need a measure that facilitates the calculation of such episode rules to replace the number of sliding windows or minimal occurrences.

In addition, we sometimes find several events occurring at one time slot in terms of various intervals, called complex sequences . Note that a temporal database is also a kind of complex sequence with temporal attributes. Mining frequent serial episodes in a complex se quence has more exten sive applications than that in a simple sequence. Therefore, we discuss the problem on mining fre-quent serial episodes over a complex sequence in this paper, where the support of an episode is modified carefully to count the exact occurrences of episodes. We propose two algorithms in mining frequent episodes in complex sequences, including MINEPI+ and EMMA. MINEPI+ is modified from previous vertical-based MINEPI [4] for mining episodes in a complex sequence. MINEPI+ employs depth first enumeration to generate the frequent episodes by equalJoin and tem-poralJoin . To further reduce the search space in pattern generation, we propose a brand new algorithm, EMMA ( E pisodes M ining using M emory A nchor), which utilizes memory anchors to accelerate the mi ning task. Experim ental evaluation shows that EMMA is more efficient than MINEPI+. 2.1 MINEPI+ MINEPI is an iteration-based algorithm which adopts breadth-first manner to enumerate longer serial episodes from shorter ones. However, instead of scanning the temporal database for support counting, MINEPI computes the minimal occurrences mo of each candidate episode from the mo of its subepisode by temporal joins. For example, we want to find all frequent serial episodes from a simple sequence S = A 1 A 2 B 3 A 4 B 5 with maxwin =4and minsup = 2. MINEPI first finds frequent 1-episode and records the respective minimal occurrence, i.e. connects events from differen t time intervals (less than maxwin ), we get intervals If we want to count the number of sliding windows that match serial episode &lt; A,B &gt; ,interval[1 , 3] should be retained since the first subwindow contains A . Therefore, we have support count 3 for serial episode &lt; A,B &gt; since [2,3] and [2,5] denote the same sliding window. To extend MINEPI for our problem, we also need equal join which connects event s at the same interval for dealing with complex sequences. We will use these intervals to compute the right support count for the problem.

Given the maximum window bound maxwin ,the bound list of a serial sequence of &lt;p 2 ,...,p k  X  1 &gt; .Eachinterval[ ts i ,te i ] is called a matching bound of P . By definition, the bound list of an event Y is the set of intervals [ t i ,t i ] such that X t i supports Y . Given a serial episode P = &lt;p 1 ,...,p k &gt; and a frequent 1-pattern f and their matching bound lists, e.g., P.boundlist = { eration equal join of P and f which computes the bound list for a new serial episode P 1 = &lt;p 1 ,...,p k f&gt; (denoted by P f ) is defined as the set of inter-operation temporal join (concatenation) of P and f (denoted by P  X  f )which computes the bound list for new serial episode P 2 = &lt;p 1 ,...,p k ,f &gt; is defined some j (1  X  j  X  m ).

Different from MINEPI, we apply depth-first enumeration to pattern gener-ation for memory saving. This is because breadth first enumeration must keep track of records for all episodes in two consecutive levels, while depth-first enu-meration needs only to keep intermediate records for episodes generated along a single path. Note that MINEPI+ does X  X  search the minimum occurrence in the temporal database, we call our algorithm as MINEPI+ since the vertical-based operation in MINEPI+ is similar to MINEPI. Though the extension of MINEPI discover all frequent serial episodes, MINEPI+ has the following drawbacks: 1. A huge amount of combinations :Let | I | be the number of frequent 1-episodes, WINEPI+ needs | I | 2 and | I | 2  X  X  I | 2 checking for temporal joins and equal joins, respectively. 2. Unnecessary joins : For example, while the number of the ex-tendable matching bounds for a serial episode is less than minsup  X  X  TDB | ,we can skip all temporal joins for this prefix. 3. Duplicate joins : For example, to find serial episode &lt; ABC, ABC &gt; , MINEPI+ needs four of equal joins (twice However, if we maintain the bound list for &lt;ABC&gt; , we only needs one tem-poral joins. 2.2 EMMA In this section, we propose an algorithm, EMMA ( E pisode M ining using M emory A nchor), that overcomes the drawbacks of the MINEPI+ algorithm. To reduce duplicate checking, EMMA is divided into three phases, including (I) Mining frequent itemset in the complex sequence. (II) Encode each frequent itemset with a unique ID and construct them into a encoded horizontal database. (III) Mining frequent serial episodes in the encoded database. The EMMA algo-rithm adopts DFS to enumerate local frequent patterns by memory anchors to accelerate the mining task, which is mo re like a pattern growth method since it searches the local frequent sub-pattern to form the long pattern. Thus, instead of frequent items, we have a larger set of al l frequent itemsets as frequent 1-tuple episodes. Again, we will use the boundlists for each frequent 1-tuple episode to enumerate longer frequent episodes. However, we only combine existing episodes with a  X  X ocal X  frequent 1-tuple episode to overcome the huge amount of candi-date generation.

Now, in order to discover local frequent 1-tuple episode efficiently, we con-struct an encoded database EDB indexed by time (Phase II) and utilize the boundlists as a memory anchor to access the horizontal-based information. Note that the timelists of the frequent itemsets are equivalent to the boundlists for fre-quent 1-tuple episodes. As an example, Figure 1 shows an illustrative transaction database, the frequent itemsets with min sup = 5, and the encoded database. Finally, we use depth first enumeration to enumerate frequent serial episodes and carefully avoid unnecessary joins in Phase III.

Similar to MINEPI+, it adopts depth first enumeration to generate longer serial episodes. However, EMMA generate s only frequent serial episodes by join-ing an existing serial episode with local frequent IDs. This is accomplished by examining those transactions following the matching bounds of current serial episodes. For example, if we want to extend an episode #3= { C } with boundlist { [1,1], [2,2], [4,4], [8,8], [11,11], [14,14], [15,15] } , we need to count the occurrences of IDs in the following intervals within maxwin = 4 bound, i.e. [2,4], [3,5], [5,7], [9,11], [12,14], [15,16] and [16,16]. We call these intervals the projected bound-list of a serial episode &lt; #3 &gt; . Formally, the projected bound list of a boundlist for an episode is defined as follows. Given the bound list of a serial episode P , where ts i = min ( ts i +1 , | TDB | )and te i = min ( ts i + maxwin  X  1 , | TDB | ).
When examining the IDs in the projected boundlist, we also record the bound-lists of IDs. For example, #4 is a local frequent ID in #3.PBL and has boundlist { [3,3], [5,5], [6,6], [9,9], [12,12], [13,13], [16,16] } . Thus, when new serial episodes &lt; C,D &gt; are generated by temporal join &lt; #3,#4 &gt; , we know their boundlists immediately, i.e. { [1,3], [2,3] [4,5], [8,9], [11,12], [14,16], [15,16] } .Toextendthis episode, the procedure emmajoin is called recursively until no more new serial episodes can be extended, i.e. when the number of extendable bounds for a serial episode is less than minsup  X  X  TDB | . For example, suppose the boundlist of of some serial episode is { [1,3], [3,5], [8,11], [11,14], [14,15] } ,with maxwin =4the extendable bounds include { [1,3], [3,5], [14,15] } since [8,11] and [11,14] already reach the maximum window bound. With minsup = 5, we do not need to ex-tend serial episode &lt; B &gt; . This strategy can avoid unnecessary checking spent in MINEPI+. We apply MINEPI+ and EMMA to a data set composed of 10 stocks in the Taiwan Stock Exchange Daily Official list for 2618 trading days from Septem-ber 5, 1994 to June 21, 2004. We discretize the stock price of go-up/go-down into five levels. Figure 2(a) shows the running time with an increasing support threshold, minsup , from 10% to 30%. Figure 2(c) shows the same measures with varying maxwin .Asthe maxwin / minsup threshold increases/decreases, the gap between MINEPI+ and EMMA in the running time becomes more sub-stantial. Figures 2(b) and (d) show the memory requirements and the number of frequent episodes with varying minsup and maxwin .Asthe maxwin threshold increases or minsup threshold decreases, the number of frequent episodes also increases. The memory requirement in MINEPI+ is steady. However, EMMA needs to maintain more frequent itemsets as the minsup decreases; whereas the memory requirement with varying maxwin in EMMA is changed slightly. Over-all, MINEPI+ is better than EMMA in memory saving (by a magnitude of 4 for minsup = 10%). In this paper, we discuss the problem of mining frequent serial episodes in a com-plex sequence and propose two algorithms to solve this problem. First, we modify previous vertical-based MINEPI to MINEPI+ as the baseline for mining episodes in a complex sequence. To avoid the huge amount of combinations/computations and unnecessary/duplicate checking, we utilize memory to propose a brand-new memory-anchored algorithm, EMMA. The experiments show that EMMA is more efficient than MINEPI+. So far we hav e only discussed serial episodes. Par-allel episodes, which have no constraint on event orders, and composite episodes, e.g. serial combination of parallel episodes, remain to be solved. Thus, further researches are required.

