 University of Haifa University of Haifa grammar development environments support sophisticated modularized grammar development, separate compilation and automatic linkage, information encapsulation, and so forth. grammars for natural languages. Much of the information in such formalisms is encoded by signature among the different modules. We define signature modules and provide operators of our definitions by providing a modular design of the HPSG grammar of Pollard and Sag. 1. Introduction
Development of large-scale grammars for natural languages is an active area of research in human language technology. Such grammars are developed not only for purposes of theoretical linguistic research, but also for natural language applications such as machine translation, speech generation, and so on. Wide-coverage grammars are being developed for various languages (Abeill  X  e, Candito, and Kinyon 2000; XTAG Research Group 2001; Oepen et al. 2002; Hinrichs, Meurers, and Wintner 2004; Bender et al. 2005; Levy, and Takahashi 1975), LFG (Dalrymple 2001), HPSG (Pollard and Sag 1994), and XDG (Debusmann, Duchier, and Rossberg 2005).
 mar to be developed by a team including several linguists, computational linguists, and computer scientists. The scale of grammars is overwhelming X  X arge-scale grammars can be made up by tens of thousands of line of code (Oepen et al. 2000) and may include thousands of types (Copestake and Flickinger 2000). Modern grammars are written in grammatical formalisms that are often reminiscent of very-high-level, declar-ative (mostly logical) programming languages, and are thus very similar to computer programs. This raises problems similar to those encountered in large-scale software development (Erbach and Uszkoreit 1990). Although whereas software engineering provides adequate solutions for the programmer, grammar engineering is still in its infancy.
 tion in grammar-development platforms such as LKB (Copestake 2002), ALE (Carpenter and Penn 2001), TRALE (Meurers, Penn, and Richter 2002), or Grammix (M  X  uller 2007).
Such platforms conceptually view the grammar as a single entity (even when it is distributed over several files), and provide few provisions for modular grammar de-velopment, such as mechanisms for defining modules that can interact with each other through well-defined interfaces, combination of sub-grammars, separate compilation and automatic linkage of grammars, information encapsulation, and so forth. This is the main issue that we address in this work. 1 of grammar modularization. We first specify a set of desiderata for a beneficial solu-tion in Section 1.1, and then survey related work, emphasizing the shortcomings of existing approaches with respect to these desiderata. Much of the information in typed unification grammars is encoded in the signature, and hence the key is facilitating a modularized development of type signatures. In Section 2 we introduce a definition of signature modules, and show how two signature modules combine and how the resulting signature module can be extended to a stand-alone type signature. We lift our definitions from signatures to full grammar modules in Section 3. In Section 4 we use signature modules and their combination operators to work out a modular design of the HPSG grammar of Pollard and Sag (1994), demonstrating the utility of signature modules for the development of linguistically motivated grammars. We then outline
MODALE , an implementation of our solutions which supports modular development of type signatures in the context of both ALE and TRALE (Section 5). We show in
Section 6 how our solution complies with the desiderata of Section 1.1, and conclude with directions for future research. 1.1 Motivation
The motivation for modular grammar development is straightforward. Like software development, large-scale grammar development is much simpler when the task can be cleanly distributed among different developers, provided that well-defined interfaces govern the interaction among modules. From a theoretical point of view, modularity 30 facilitates the definition of cleaner semantics for the underlying formalism and the construction of correctness proofs. The engineering benefits of modularity in program-ming languages are summarized by Mitchell (2003, page 235), and are equally valid for grammar construction:
A suitable notion of modularity should support  X  X euse of software, abstraction mech-anisms for information hiding, and import/export relationships X  (Brogi et al. 1994, page 1363). Similarly, Bugliesi, Lamma, and Mello (1994, page 444) state that do with the way linguistic knowledge is organized, either cognitively (Fodor 1983) or theoretically (Jackendoff 2002, pages 218 X 230). Although we do not directly subscribe to this notion of modularity in this work, it may be the case that an engineering-inspired definition of modules will facilitate a better understanding of the linguistic notion.
Furthermore, although there is no general agreement among linguists on the exact form of grammar modularity, a good solution for grammar development must not reflect the correctness of linguistic theories but rather provide the computational framework for their implementation.
 hand inspired by developments in programming languages and on the other useful for linguists, a clear understanding of the actual needs of grammar developers is crucial. A first step in this direction was done by Erbach and Uszkoreit (1990). In a similar vein, we carefully explored two existing grammars: the LINGO grammar matrix (Bender,
Flickinger, and Oepen 2002), 2 which is a framework for rapid development of cross-linguistically consistent grammars; and a grammar of a fragment of modern Hebrew, focusing on inverted constructions (Melnik 2006). These grammars were chosen since they are comprehensive enough to reflect the kind of data large-scale grammars encode, but are not too large to encumber this process.
 motivated by our observation of actual grammars, we define the following desiderata for a beneficial solution for (typed unification) grammar modularization:
Signature focus: Much of the information in typed formalisms is encoded by the signa-
Partiality: Modules should provide means for specifying partial information about the
Extensibility: Although modules can specify partial information, it must be possible to
Consistency: Contradicting information in different modules must be detected when
Flexibility: The grammar designer should be provided with as much flexibility as (Remote) Reference: A good solution should enable one module to refer to entities
Parsimony: When two modules are combined, the resulting module must include all
Associativity: Module combination must be associative and commutative: The order
Privacy: Modules should be able to hide (encapsulate) information and render it un-laborative development of grammars, where several applications of modularity are conceivable: 32 1.2 Related Work 1.2.1 Modularity in Programming Languages. Vast literature addresses modularity in pro-gramming languages, and a comprehensive survey is beyond the scope of this work. As unification grammars are in many ways very similar to logic programming languages, our desiderata and solutions are inspired by works in this paradigm.
 Gaifman and Shapiro (1989). Combination operators that were proved suitable for
Prolog include the algebraic operators  X  and  X  of Mancarella and Pedreschi (1988);
Lamma, and Mello (1993); and the set of four operators (encapsulation, union, inter-section, and import) defined by Brogi and Turini (1995). For a comprehensive survey, see Bugliesi, Lamma, and Mello (1994).
 operations proposed for logic programming languages. We define no counterpart of intersection-type operations, although such operations are indeed conceivable. Our  X  X ttachment X  operation is more in line with Gaifman and Shapiro (1989). 1.2.2 Initial Approaches: Modularized Parsing. Early attempts to address modularity in linguistic formalisms share a significant disadvantage: The modularization is of the parsing process rather than the grammar.
 grammar into two components, roughly along the syntax/semantics axis. Their mo-tivation is efficiency; observing that syntax usually imposes constraints on permissible structures, and semantics usually mostly adds structure, they propose to parse with the deleting the syntactic and semantic information (under their corresponding attributes in the rules and the lexicon) for the semantic and syntactic parsers, respectively. This proposal requires that a single grammar be given, from which the two components can be derived. A more significant disadvantage of this method is that coreferences between syntax and semantics are lost during this division (because reentrancies that represent the connection between the syntax and the semantics are removed). Kasper and Krieger observe that the intersection of the languages generated by the two grammars does not yield the language of the original grammar.
 operator that enables the grammar designer to break a grammar into sub-grammars that for dividing the development process into stages that correspond to morphological processing, syntax, semantics, and so on. The notion of composition here is such that sub-grammar G i + 1 operates on the output of sub-grammar G might not be suitable for all grammar development frameworks. A similar idea is pro-the task into sub-tasks, whereby a module component P i takes an input sentence at a given state of analysis S i and augments this information in S
K . Here, too, it is the processing system, rather than the grammar, which is modularized in a pipeline fashion. 1.2.3 Modularity in Typed Unification Grammars. Keselj (2001) presents a modular Head-driven Phrase Structure Grammar (HPSG), where each module is an ordinary HPSG grammar, including an ordinary type signature, but each of the sets F R
ULES is divided into two disjoint sets of private and public elements. The public sets consist of those elements that can communicate with elements from corresponding sets in other modules, and private elements are those that are internal to the module.
Merging two modules is then defined by set union; in particular, the type hierarchies are merged by unioning the two sets of types and taking the transitive closure of the union of the two BCPOs (see Definition 2). The success of the merge of two modules requires that the union of the two BCPOs be a BCPO.
 a highly insufficient mechanism for supporting modular grammar development: The requirement that each module include a complete type hierarchy imposes strong lim-itations on the kind of information that modules can specify. It is virtually impossible to specify partial information that is consistent with the complete type hierarchy re-quirement. Furthermore, module composition becomes order-dependent as we show in
Example 8 (Section 2.4.2). Finally, the only channel of interaction between modules is the names of the types. Our work is similar in spirit to Keselj (2001), but it overcomes these shortcomings and complies with the desiderata of Section 1.1.
 mar by both extending and restricting another grammar. An LFG grammar is presented to the system in a priority-ordered sequence of files containing phrase-structure rules, transducers for tokenization and morphological analysis. The grammar can include higher priority override lower priority items of the same type with the same name. The override convention makes it possible to add, delete, or modify rules. However, when a
Moreover, there is no real concept of modularization in this approach because the only interaction among files is overriding of information.
 development of untyped unification grammars. In addition, they suggest that any de-velopment team should agree in advance on the feature space. This work emphasizes the observation that the modularization of the signature is the key for modular devel-opment of grammars. However, the proposed solution is ad hoc and cannot be taken seriously as a concept of modularization. In particular, the suggestion for an agreement on the feature space undermines the essence of modular design.
 propose a framework in which the grammar developer can select pre-written grammar fragments, accounting for common linguistic phenomena that vary across languages (e.g., word order, yes X  X o questions, and sentential negation). The developer can spec-ify how these phenomena are realized in a given language, and a grammar for that language is automatically generated, implementing that particular realization of the phenomenon, integrated with a language-independent grammar core. This framework addresses modularity in the sense that the entire grammar is distributed between sev-eral fragments that can be combined in different ways, according to the user X  X  choice.
However, the notion of modularity is rather different here, as modules are pre-written pieces of code which the grammar designer does not develop and whose interaction he or she has little control over. 1.2.4 Modularity in Related Formalisms. The previously mentioned works emphasize the fact that existing approaches to modular grammar development in the area of unifica-tion grammars are still insufficient. The same problem has also been addressed in some 34 other, related, formalisms; we now survey such works and discuss the applicability of the proposed solutions to the problem of modularity in typed unification grammars.
The imported elements are those that are supplied to the module by other modules, the exported elements are those it provides to the outside world, and the internal ones are local to it. Two modules can be combined only if the set of internal elements of each module is disjoint from the exported and imported sets of the other module as well as if the exported sets are disjoint. Then the combination of two modules is done by simple measures of set union. This is the infrastructure underlying the definition of modular HPSG discussed earlier (Keselj 2001).
 grammars (TAG) (Joshi, Levy, and Takahashi 1975). A wide-coverage TAG may contain hundreds or even thousands of elementary trees, and syntactic structure can be redun-dantly repeated in many of them (XTAG Research Group 2001; Abeill  X  e, Candito, and
Kinyon 2000). Consequently, maintenance and extension of such grammars is a complex task. To address these issues, several high-level formalisms were developed (Vijay-
Shanker 1992; Candito 1996; Duchier and Gardent 1999; Kallmeyer 2001). These for-tree logic and combined through conjunction or inheritance; a module in this approach is merely a tree description, and modules are combined by means of the control logic. various ways to refer to nodes in the trees in order to control the possible combination of grammar modules. Several mechanisms have been suggested to facilitate reference across modules (Candito 1996; Perrier 2000; Crabb  X  e and Duchier 2004; Kahane 2006). to do so in a way that maintains the associativity of the main grammar combination operator, in contrast to some earlier approaches (Sygal and Wintner 2009). mar (XDG), which is a general framework for dependency grammars that supports modular grammar design. An XDG grammar consists of dimensions , principles ,anda lexicon; it characterizes a set of well-formed analyses. Each dimension is an attributed labeled graph, and when a grammar consists of multiple dimensions (e.g., multigraphs), of nodes and labels. The main mechanism XDG uses to control analyses are principles, that can be either local (imposing a constraint on the possible analysis of a specific dimension) or multi-dimensional (constraining the analysis of several dimensions with respect to each other). In XDG, principles are formulated using a type-system that includes several kinds of elementary types (e.g., nodes, edges, graphs, and even multigraphs) and complex types that are constructed incrementally over the elementary types. Then, parameters range over types to formulate parametric principles. A feasible
XDG analysis amounts to a labeled graph in which each dimension is a subgraph, such that all (parametric) principles are maintained (this may require nodes in differ-ent subgraphs to be identified). XDG supports modular grammar design where each dimension graph is a grammar module, and module interaction is governed through multi-dimensional parametric principles.

Our work shares with XDG the use of graphs as the basic components and the use of parameters to enforce interaction among modules. In both works, each module introduces constraints on the type system and interaction among modules through parameters is used to construct a multigraph in which some of the nodes are identified.
In our approach, however, the type system is part of the grammar specification, and modules are combined via explicit combination operations. In contrast, in XDG the used to impose constraints. Another major difference has to do with expressive power:
Whereas unification grammars are Turing-equivalent, XDG is probably mildly context-sensitive (Debusmann 2006).
 language designed for multilingual grammars. Ranta introduces a module system for
GF where a module can be either one of three kinds: abstract , concrete ,ora resource module. Each of them reflects the kind of data this module may include. A module of type abstract includes abstract syntax trees which represent grammatical information, such as semantic or syntactic data. A module of type concrete includes relations between trees in the abstract module and relations between strings in the target language.
Communication between modules of these two types is carried out through inheri-tance hierarchies similarly to object-oriented programs. Resource modules are a means for code-sharing, independently of the hierarchies. The system of modules supports development of multilingual grammars through replacement of certain modules with others. A given grammar can also be extended by adding new modules. Additionally, to avoid repetition of code with minor variations, GF allows the grammar writer to define operations which produce new elements.
 tation, and individual extensions to different languages are developed independently. where general purpose modular applications are considered (see section 1.1 for exam-ples of such conceivable applications). Mainly, GF forces the developer to pre-decide on the relations between all modules (through the concrete module and inheritance hierar-the development process. Each module should be able to independently declare its own interface with other modules; then, when modules combine they may do so in any way elements in GF is carried out only through naming, again resulting in a weak interface for module interaction. Finally, the operations that the grammar writer can define in GF are macros, rather than functions, as they are expanded by textual replacement. 2. Modularization of the Signature 2.1 Typed Signatures
We assume familiarity with theories of (typed) unification grammar, as formulated by, for example, Carpenter (1992) and Penn (2000). The definitions in this section set the notation and recall basic notions. For a partial function F , X  F ( x ) for x and for y and assigns them equal values or it is undefined for both. Definition 1
Given a partially ordered set P ,  X  ,thesetof upper bounds of a subset S
S = { y  X  P | X  x  X  Sx  X  y } . 36 and is denoted min ( S ).
 Definition 2 A partially ordered set P ,  X  is a bounded complete partial order (BCPO) iff for every
S  X  P such that S u =  X  , S u has a least element, called a least upper bound (lub) and denoted S .
 Definition 3 A type hierarchy is a non-empty, finite, bounded complete partial order T subset S =  X  of T YPE has the non-empty set of upper bounds, S have a least element due to bounded completeness.
 Definition 4 and y is a subtype of x .If x y , x = y andthereisno z such that x z y and z = x , y then x is an immediate supertype of y and y is an immediate subtype of x . as greater than their supertypes (hence the least element than the other way round (inducing a glb interpretation), which is sometimes common in the literature (Copestake 2002).
 Definition 5 Given a type hierarchy T YPE , and a finite set of features F specification is a partial function, Approp :T YPE  X  F EAT
F 1. (Feature Introduction) there is a type Intro ( F )  X  2. (Upward Closure / Right Monotonocy) if Approp ( s , F ) Definition 6 A type signature is a structure T YPE , ,F EAT , Approp , where T hierarchy, F EAT is a finite set of features, F EAT and T appropriateness specification.

Again, note that type constraints are not addressed in this work. 2.2 Overview
We define signature modules (also referred to as modules herein), which are structures that provide a framework for modular development of type signatures. These structures follow two guidelines. 1. Signature modules contain partial information about a signature: part of 2. Modules may choose which information to expose to other modules and then introduce (Section 2.4) two combination operators for signature modules which facilitate interaction and (remote) reference among modules. We end this section by showing how to extend a signature module into a bona fide type signature (Section 2.5). 2.3 Signature Modules
The definition of a signature module is conceptually divided into two levels of in-formation. The first includes all the genuine information that may be encoded by a signature, such as subtyping and appropriateness relations, types, and so forth. The of a signature, but rather a device that enables advanced module communication. Con-signatures (PSSs) , which are finite directed graphs that encode partial information about the signature. Then, we extend PSSs to signature modules which are structures, based on PSSs, that provide also a complete mechanism for module interaction and (remote) reference.
 of nodes, over which signatures are defined.
 Definition 7 A partially labeled graph (PLG) over T YPE and F EAT is a finite, directed labeled graph
P = Q , T , , Ap , where: 1. Q  X  N ODES is a finite, nonempty set of nodes. 2. T : Q  X  T YPE is a partial function, marking some of the nodes with types. 38 3.  X  Q  X  Q is a relation specifying (immediate) subtyping. 4. Ap  X  Q  X  F EAT  X  Q is a relation specifying appropriateness.

A partially specified signature (PSS) over T YPE and F EAT
P = Q , T , , Ap , where: 5. T is one to one. 6.  X   X  is antireflexive; its reflexive-transitive closure, denoted  X  7. (Relaxed Upward Closure) for all q 1 , q 1 , q 2  X  Q and F
A PSS is a finite, directed graph whose nodes denote types and whose edges denote the subtyping and appropriateness relations. Nodes can be marked by types through the function T , but can also be anonymous (unmarked). Anonymous nodes facilitate reference, in one module, to types that are defined in another module. T is one-to-one (item 5), because we require that two marked nodes denote different types.  X   X  is required to be a partial order (item 6). The type hierarchy of an ordinary type signature is required to be a BCPO, but current approaches (Copestake 2002) relax this requirement to allow more flexibility in grammar design. Similarly, the type hierarchy of PSSs is partially ordered but this order is not necessarily a bounded complete one.
Only after all modules are combined is the resulting subtyping relation extended to a BCPO (see Section 2.5); any intermediate result can be a general partial order. Relax-ing the BCPO requirement also helps guarantee the associativity of module combination (see Example 8). 4 mar development, since different modules may specify different appropriate values ac-this way, each module may specify its own appropriate values without needing to know the value specification of other modules. We do restrict the Ap relation, however, by a is desirable, after all modules combine (see Section 2.5).
 Example 1
A simple PSS P 1 is depicted in Figure 1, where solid arrows represent the  X   X (subtyp-ing) relation and dashed arrows, labeled by features, the Ap relation. P subtypes of cat , n and v , with a common subtype, gerund .Thefeature for all three categories, with distinct (but anonymous) values for Approp ( n , Approp ( v , AGR ). Approp ( gerund , AGR ) will eventually be the lub of Approp ( n , Approp ( v , AGR ), hence the multiple outgoing AGR arcs from gerund . tion condition does not hold.
 Definition 8 A pre-signature module over T YPE and F EAT is a structure S = P , Int , Imp , Exp where
P = Q , T , , Ap is a PLG and: 1. Int  X  Q is a set of internal types 2. Imp  X  Q is an ordered set of imported parameters 3. Exp  X  Q is an ordered set of exported parameters 4. Int  X  Imp = Int  X  Exp =  X  5. for all q  X  Q such that q  X  Int , T ( q )  X  We refer to elements of (the sequences) Imp and Exp using indices, with the notation Imp [ i ], Exp [ j ], respectively.
 Imp , Exp in which P is a PSS.

Similarly to parameters in programming languages, parameters are entities through which information can be imported from or exported to other modules. The nodes of a signature module are distributed among three sets of internal , imported ,and exported nodes. If a node is internal it cannot be imported or exported; but a node 40 can be simultaneously imported and exported. A node which does not belong to any of the sets is called external . All nodes denote types, but they differ in the way they communicate with nodes in other modules. As their name implies, internal nodes are internal to one module and cannot interact with nodes in other modules. Such nodes provide a mechanism similar to local variables in programming languages. expect to receive information from other modules, while exported nodes provide informa-tion to other modules. External nodes differ from imported and exported nodes in the way they may interact with other modules, and provide a mechanism similar to global variables in programming languages. Because anonymous nodes facilitate reference, in one module, to information encoded in another module, such nodes cannot be internal.
The imported and exported nodes are ordered in order to control the assignment of parameters when two modules are combined, as will be shown subsequently. examples, the classification of nodes is encoded graphically as follows: Example 2
Figure 2 depicts a module S 1 , based on the PSS of Figure 1. S where P 1 is the PSS of Figure 1, Int 1 =  X  , Imp 1 = { q or without subscripts)  X  over (pre-)signature modules, P (with or without subscripts) over PLGs and PSSs, and Q , T , , Ap (with the same subscripts) over their constituents. 2.4 Combination Operators for Signature Modules
We introduce two operators for combining signature modules. The first operator, merge , is a symmetric operation which simply combines the information encoded in the two modules. The second operator, attachment , is a non-symmetric operation which uses the concept of parameters and is inspired by function composition. A signature module is viewed as a function whose input is a graph with a list of designated imported nodes and whose output is a graph with a list of designated exported nodes. When two signature modules are attached, similarly to function composition, the exported nodes of the second module instantiate the imported parameters of the first module.
Additionally, the information encoded by the second graph is added to the information encoded by the first one.
 channels: by naming or by reference. Through interaction by naming, nodes marked by the same type are coalesced. Interaction by reference is achieved when the imported parameters of the calling module are coalesced with the exported nodes of the called module, respectively. The merge operation allows modules to interact only through naming, whereas attachment facilitates both ways of interaction.

One module does not include types which are internal to the other module and the two signature modules have no common nodes. If this is not the case, nodes, and in particular internal nodes, can be renamed without affecting the operation. Definition 9
Let S 1 = Q 1 , T 1 , 1 , Ap 1 , Int 1 , Imp 1 , Exp 1 , S two pre-signature modules. S 1 and S 2 are consistent iff all the following conditions hold: 1. { T 1 ( q ) | q  X  Int 1 } X  X  T 2 ( q ) | q  X  Q 2 and T 2 2. { T 2 ( q ) | q  X  Int 2 } X  X  T 1 ( q ) | q  X  Q 1 and T 1 3. Q 1  X  Q 2 =  X  modules are combined as a mechanism to coalesce corresponding nodes in the two modules. 2.4.1 Compactness. When two modules are combined, a crucial step in the combination is the identification of corresponding nodes in the two modules that should be coalesced.
Such pairs of nodes can be either of two kinds: 1. Two typed nodes which are labeled by the same type should be coalesced 2. Two anonymous nodes which are indistinguishable , that is, have 42 dant (such arcs are not prohibited by the definition of a module). Redundant arcs can be of two kinds: 1. A subtyping arc ( q 1 , q 2 ) is redundant if it is a member of the transitive 2. An appropriateness arc ( q 1 , F , q 2 ) is redundant if there exists q
Redundant arcs encode information that can be inferred from other arcs and therefore may be removed without affecting the data encoded by the signature module. defined over the more general case of pre-signature modules. This more general notion will be helpful in the definition of module combination. Informally, when a pre-signature module is compacted, redundant arcs are removed, nodes marked by the same type are coalesced, and anonymous indistinguishable nodes are identified.
Additionally, the parameters and arities are induced from those of the input pre-signature module. All parameters may be coalesced with each other, as long as they are then the result is an internal node. Otherwise, if one of the nodes is imported then the resulting parameter is imported as well. Similarly, if one of the nodes is exported then the resulting parameter is exported. Notice that in the case of signature modules, because T is one to one, an internal node may be coalesced only with other internal nodes.
 mostly technical and are therefore deferred to the Appendix. We do provide two simple examples to illustrate the general idea.
 Example 3 cause even without this arc, there is a subtyping path from q redundant appropriateness arc: Eventually the appropriate value of q least q 5 .
 Example 4
Consider S 2 , the pre-signature module depicted in Figure 4. Note that S signature module (because it includes two nodes labeled by a ) and that compactness is defined over pre-signature modules rather than signature modules as this is the case for which it will be used during combination. In compact ( S because they are both marked by the type a . Additionally, q and q 7 , respectively, because these are two pairs of anonymous nodes with isomorphic environments. q 5 is not coalesced with q 3 and q 4 because q not, even though they are otherwise indistinguishable. q 8 q because they are distinguishable: q 8 has a supertype marked by a whereas q have anonymous supertypes. 2.4.2 Merge. The merge operation combines the information encoded by two signature modules: Nodes that are marked by the same type are coalesced along with their attributes. Nodes that are marked by different types cannot be coalesced and must denote different types. The main complication arises when two anonymous nodes are considered X  X uch nodes are coalesced only if they are indistinguishable. unioned (this is a simple pointwise union of the coordinates of the graph, see Defi-nition 10). Then, the resulting graph is compacted, coalescing nodes marked by the same type as well as indistinguishable anonymous nodes. However, the resulting graph does not necessarily maintain the relaxed upward closure condition, and therefore some modifications are needed. This is done by Ap-Closure (see Definition 11). Finally, the addition of appropriateness arcs may turn two anonymous distinguishable nodes into indistinguishable ones and may also add redundant arcs, therefore another compact-ness step is needed (Definition 12).
 Definition 10
Let S 1 = Q 1 , T 1 , 1 , Ap 1 , Int 1 , Imp 1 , Exp 1 , S two consistent pre-signature modules. The union of S 1 and S pre-signature module (where  X   X   X  is the concatenation operator). 44 Definition 11
Let S = Q , T , , Ap , Int , Imp , Exp be a pre-signature module. The Ap-Closure of S , denoted ApCl ( S ), is the pre-signature module Q , T , , Ap , Int , Imp , Exp where and there exists q 1  X  Q such that the relaxed upward closure condition: Arcs are added to create the relations between elements separated between the two modules and related by mutual elements. Notice that Ap  X  Ap by choosing q 1 = q 1 .
 indeed a partial order, where the only obstacle can be the antisymmetry of the resulting relation. The combination of the appropriateness relations, in contrast, cannot cause the merge operation to fail because any violation of the appropriateness conditions in signature modules can be deterministically resolved. Note that our specification language does not support inequations; there is no way to specify that two nodes must not be identified with each other. Such extensions are indeed possible, but are beyond the scope of this work.
 Definition 12
Let S 1 = Q 1 , T 1 , 1 , Ap 1 , Int 1 , Imp 1 , Exp 1 , S two consistent signature modules. S 1 , S 2 are mergeable if there are no q q , q 4  X  Q 2 such that the following hold: 1. q 1 = q 2 and q 3 = q 4 2. T 1 ( q 1 )  X  , T 1 ( q 2 )  X  , T 2 ( q 3 )  X  and T 2 ( q 3. T 1 ( q 1 ) = T 2 ( q 4 )and T 1 ( q 2 ) = T 2 ( q 3 ) 4. q 1
If S 1 and S 2 are mergeable, then their merge , denoted S indistinguishable anonymous nodes are coalesced. An anonymous node cannot be coalesced with a typed node, even if they are otherwise indistinguishable, because that would result in a non-associative combination operation. Anonymous nodes are assigned types only after all modules combine (see Section 2.5.1).
 nature module. Again, this is done to guarantee the associativity of the merge operation (see Example 9). Example 5
Let S 3 and S 4 be the signature modules depicted in Figure 5. S pre-signature modules are also shown in this figure. First, S c . Notice that this pre-signature module is not a signature module because it does not maintain the relaxed upward closure condition. To enforce this condition appropriate-indistinguishable anonymous nodes and therefore another compactness operation is required to yield the final result.
 Example 6
Figure 6 depicts a naive agreement module, S 5 . Combined with S
S 5 S 1 = S 6 . All dashed arrows are labeled AGR , but these labels are suppressed for readability.
 closure are not depicted.
 46 Example 7
Let S 7 and S 8 be the signature modules depicted in Figure 7. S agreement information and S 8 specifies detailed values for several specific properties. feature individually.
 defer the conversion of signature modules to BCPOs to a separate resolution stage (Section 2.5).
 Example 8
Let S 10 , S 11 , S 12 be the signature modules depicted in Figure 8. The merge of S results in a non-BCPO. However, the additional information supplied by S the problem, and S 10 S 11 S 12 is bounded complete.
 Example 9
Let S 13 , S 14 , S 15 be the signature modules depicted in Figure 9. In S value for a and F is b and in S 14 it is c . Hence S 13 S marked by a are not replaced by a single arc whose target is the node marked by d ,since other signature modules may specify that the lub of b and c is some type other than d .
These multiple outgoing arcs are preserved to maintain the associativity of the merge operation.
 Proposition 1
Merge is commutative: For any two signature modules, S 1 , S
S 2 S 1 where P , P are their underlying PSSs, respectively. Then P = P . In particular, either both are defined or both are undefined.
 set union and equivalence relations which are commutative operations.
 Proposition 2
Merge is associative up to isomorphism: 6 for all S 1 , S
S = S 1 ( S 2 S 3 ) where P , P are their underlying PSSs, respectively. Then P 48 ized) forest combination (Sygal and Wintner 2009) and is therefore suppressed. 2.4.3 Attachment. Consider again S 1 and S 9 , the signature modules of Figures 1 and 7, respectively. S 1 stipulates two distinct (but anonymous) values for Approp ( n , that these nodes be coalesced with the two anonymous nodes of S anonymous nodes in S 1 have different attributes from their corresponding typed nodes in S 9 . In order to support such a unification of nodes we need to allow a mechanism that specifically identifies two designated nodes, regardless of their attributes. The parametric view of nodes facilitates exactly such a mechanism.
 where a signature module, S 1 , receives as input another signature module, S the exported parameters of S 2 are assigned to the imported parameters of S the exported parameters of S 2 is forced to coalesce with its corresponding imported are indistinguishable or not).
 Definition 13
Let S 1 = Q 1 , T 1 , 1 , Ap 1 , Int 1 , Imp 1 , Exp 1 and S be two consistent signature modules. S 2 can be attached to S hold: 1. | Imp 1 | = | Exp 2 | 2. for all i ,1  X  i  X | Imp 1 | ,if T 1 ( Imp 1 [ i ])  X  3. S 1 and S 2 are mergeable 4. for all i , j ,1  X  i  X | Imp 1 | and 1  X  j  X | Imp 1 |
The first condition requires that the number of formal parameters of the calling module be equal to the number of actual parameters in the called module. The second condition states that if two typed parameters are attached to each other, they are marked by the same type. If they are marked by two different types they cannot be coalesced. the last two conditions guarantee the antisymmetry of the subtyping relation in the resulting signature module: The third condition requires the two signature modules to be mergeable. The last condition requires that no subtyping cycles be created by the attachment of parameters: If q 1 is a supertype of q 1 in S
S , then q 2 and q 2 cannot be both attached to q 1 and q 1 merge operation, two signature modules can be attached only if the resulting subtyping cause the attachment operation to fail because any violation of the appropriateness conditions in signature modules can be deterministically resolved. Definition 14
Let S 1 = Q 1 , T 1 , 1 , Ap 1 , Int 1 , Imp 1 , Exp 1 and S be two consistent signature modules. If S 2 can be attached to S
S
Ap , Int , Imp , Exp is defined as follows: Let  X  be an equivalence relation over Q defined by the reflexive and symmetric closure of { ( Imp Then:
When a module S 2 is attached to a module S 1 , all the exported nodes of S attached to the imported nodes of S 1 , respectively, through the equivalence relation,  X   X   X . In this way, for each imported node of S 1 , all the information encoded by the corresponding exported node of S 2 is added. Notice that each equivalence class of  X   X   X  contains either one or two nodes. In the former case, these nodes are either non-imported node of S 1 and its corresponding exported node from S transitive. Then, similarly to the merge operation, pairs of nodes marked by the same type and pairs of indistinguishable anonymous nodes are coalesced. In contrast to the merge operation, in the attachment operation two distinguishable anonymous nodes, as well as an anonymous node and a typed node, can be coalesced. This is achieved by the parametric view of nodes and the view of one module as an input to another module. classes of the imported and exported nodes of the first module, S resulting module. This asymmetric view of nodes stems from the view of S
S as input: In this way, S 1 may import further information from other modules. 50 between modules, external nodes facilitate interaction only through naming, and im-ported and exported nodes facilitate interaction both through naming and by reference. Example 10 Consider again S 1 and S 9 , the signature modules of Figures 1 and 7, respectively. Let
S 1 a and S 9 a be the signature modules of Figure 10 (these signature modules have the of nodes). Notice that all nodes in both S 1 a and S 9 a are non-internal. Let Imp coalesced with p 9 , p 10 , respectively, even though q 4 typed and each pair of nodes has different attributes. Such unification of nodes cannot be achieved with the merge operation.
 unification-based formalisms, for example in HPSG. The mathematical foundations for parametric lists were established by Penn (2000). As an example of the utility of signature modules and the attachment operation, we show how they can be used to construct parametric lists in a straightforward way.
 receives as input, through the imported node q 3 , a node which determines the type of the list members. The entire list can then be used through the exported node q that q 2 is an external anonymous node. Although its intended denotation is the type subsequently. Now, if Phrase is a simple module consisting of one exported node, of type the imported node of List with the single exported node of Phrase .
 an imported node as the appropriate value for the feature entire list is then attached to the signature module Struct , where the root of the list instantiates the imported node typed by phrase list in Struct .
 types of list elements. Uniqueness is guaranteed by the anonymity of the node q
List : q 2 can be coalesced only with anonymous nodes with the exact same attributes, that is, only with nodes whose appropriate value for the feature 52 by phrase .If q 2 would have been typed by ne list it could be coalesced with any other node marked by the same type, such as other such nodes from different copies of the list, resulting in a list whose members have various types. Observe that the uniqueness of each copy of the list could be achieved also by declaring q solution prevents other modules from referring to this node, as is reasonably desired. q copies, there is no problem with typing this node.
 of parametric lists is simple and general: It falls out directly as one application of signature modules, whereas the construction of Penn requires dedicated machinery (parametric subtyping, parametric appropriateness, coherence, etc.) We conjecture that signature modules can be used to simulate parametric type signatures in the general case, although we do not have a proof of such a result. 2.4.5 Example: The  X  X ddendum X  Operator in LKB. The  X  X ddendum X  operator the type definition language of LKB (Copestake 2002) in 2005, to allow the grammar developer to add attributes to an already defined type without the need to repeat previously defined attributes of that type. The need for such an operation arose as a consequence of the development of frameworks that generate grammars from pre-written fragments (e.g., the LINGO grammar matrix, Bender, Flickinger, and Oepen 2002), since editing of framework-source files may lead to errors.
 which case different attributes of a typed node are gathered from different modules) or by attachment, where attributes can be assigned to a specific node, even without specifying its type. 2.5 Extending Signature Modules to Type Signatures
Signature modules encode only partial information, and are therefore not required to conform with all the constraints imposed on ordinary signatures. After modules are combined, however, the resulting signature module must be extended into a bona fide signature. For that purpose we use four algorithms, each of which deals with one property: 1. Name resolution : This algorithm assigns types to anonymous nodes 2. Appropriateness consolidation : This algorithm determinizes Ap , converts 3. Feature introduction completion : This algorithm (whose use is optional) 4. BCPO completion : This algorithm extends  X   X  X oaBCPO.Again,weuse fide type signature.

Algorithm 1 ( ( Resolve ( ( S ) )) ) ) 1. S : = NameResolution ( S ) 2. S : = BCPO  X  Completion ( S ) 3. S : = ApCl ( S ) 4. S : = ApConsolidate ( S ) 5. S : = FeatureIntroductionCompletion ( S ) 6. S : = BCPO  X  Completion ( S ) 7. S : = ApCl ( S ) 8. S : = ApConsolidate ( S ) 9. return S that the result is indeed a bona fide signature. First, the resolution algorithm assigns types to anonymous nodes via the name resolution algorithm (stage 1). The BCPO completion algorithm (stage 2) of Penn (2000) adds types as least upper bounds for sets of types which have upper bounds but do not have a minimal upper bound. However, the algorithm does not determine the appropriateness specification of these types. A natural solution to this problem is to use Ap-Closure (stage 3) but this may lead to a situation in which the newly added nodes have multiple outgoing Ap-arcs with the same label. To solve the problem, we execute the BCPO completion algorithm before the Ap-consolidation algorithm (stage 4), which also preserves bounded completeness.
Now, the feature introduction completion algorithm (stage 5) of Penn assumes that the subtyping relation is a BCPO and that the appropriateness specification is indeed a function and hence, it is executed after the BCPO completion and Ap-consolidation algorithms. However, as Penn observes, this algorithm may disrupt bounded complete-ness and therefore the result must undergo another BCPO completion and therefore another Ap-consolidation (stages 6 X 8).
 the different modules have been gathered. Therefore, there is no need to preserve the classification of nodes and only the underlying PSS is of interest. However, because the resolution procedure uses the compactness algorithm which is defined over signature modules, we define the following algorithms over signature modules as well. In cases tion (i.e., Int = Imp = Exp =  X  ). 2.5.1 Name Resolution. During module combination only pairs of indistinguishable anonymous nodes are coalesced. Two nodes, only one of which is anonymous, can still be otherwise indistinguishable but they are not coalesced during combination to ensure the associativity of module combination. The goal of the name resolution procedure is to assign a type to every anonymous node, by coalescing it with a typed node with an such node, the anonymous node is given an arbitrary type. 54 iteration, for each anonymous node the set of its typed equivalent nodes is computed (stage 1). Then, using the computation of stage 1, anonymous nodes are coalesced with such pairs may result in a signature module that may include indistinguishable anony-mous nodes and therefore the signature module is compacted (stage 2.2). Compactness (stage 2.3). When no pairs that need to be coalesced are left, the remaining anonymous nodes are assigned arbitrary names and the algorithm halts.
 from S by coalescing q with q .
 Definition 15
Let S = Q , T , , Ap , Int , Imp , Exp be a signature module and let q , q
NodeCoalesce ( S , q , q ) = Q 1 , T 1 , 1 , Ap 1 , Int 1 be a signature module, and let N AMES  X  T YPE be an enumerable set of fresh types from which arbitrary names can be taken to mark nodes in Q . The following algorithm marks all the anonymous nodes in S :
Algorithm 2 ( ( NameResolution ( ( ( S = Q , T , , Ap , Int , Imp , Exp ) )) ) 1. for all q  X  Q such that T ( q )  X  , compute Q q = { q 2. let Q = { q  X  Q | T ( q )  X  and | Q q | = 1 } .If Q = 3. Mark remaining anonymous nodes in Q with arbitrary unique types from
For a given anonymous node, the calculation of its typed equivalent nodes is mostly technical and is therefore suppressed. Example 11
Consider the signature module S 6 depicted in Figure 6. Executing the name resolution algorithm on this module results in the signature module of Figure 12 ( suppressed for readability.) The two anonymous nodes in S nodes marked nagr and vagr , as per their attributes. Compare to Figure 1, in particular how two anonymous nodes in S 1 are assigned types from S 5 marked by the lub of the types of all q .Ifno lub exists, a new node is added and is which upward closure is preserved; feature introduction is dealt with separately. tion, T , is total; its output is a signature module whose typing function is total and whose appropriateness relation is a function that maintains upward closure. Let S =
Q , T , , Ap , Int , Imp , Exp be a signature module. For each q
Algorithm 3 ( ( ApConsolidate ( ( S = Q , T , , Ap , Int , Imp , Exp ) )) ) 1. Set Int : = Imp : = Exp : =  X  2. Find a node q and a feature F for which | target ( q , F ) 3. If target ( q , F )hasa lub , p , then: 56 4. (a) Otherwise, If target ( q , F )hasno lub , add a new node, p ,to Q with: 5. S : = ApCl ( S ) 6. S : = compact ( S ) 7. go to (2)
The order in which nodes are selected in step 2 of the algorithm is from supertypes to subtypes. This is done to preserve upward closure. When a set of outgoing appro-priateness arcs with the same label F , { ( q , F , q ) } the subtypes of all q are added as subtypes of q l (stage 3c). This is done to maintain the upwardly closed intention of appropriateness arcs (see Example 13). Additionally, q is added as an appropriate value for F and all the subtypes of q . This is achieved by the Ap-Closure operation (stage 5). Again, this is done to preserve upward closure.
If a new node is added (stage 3), then its subtypes are inherited from its immediate supertypes. Its appropriate features and values are also inherited from its immediate supertypes through the Ap-Closure operation (stage 5). In both stages 3 and 4, a final step is compaction of the signature module in order to remove redundant arcs. Example 12
Consider the signature module depicted in Figure 12. Executing the appropriateness consolidation algorithm on this module results in the module depicted in Figure 13. Example 13
Consider the signature modules depicted in Figure 14. Executing the appropriateness consolidation algorithm on S 16 , the two outgoing arcs from a labeled with F are first replaced by a single outgoing arc to a newly added node, new 1, which is the lub of b and c . During this first iteration, new 1isalsoaddedasasupertypeof e and f .The appropriate value of a and F is at least b . X  In particular, this value may be e . S is S 18 , which is also the final result. 3. Grammar Modules
Before extending signature modules to grammar modules, we first recall basic notions of typed unification grammars. For the following definitions we assume that a type signature T YPE , ,F EAT , Approp has been specified.
 Definition 16
A path is a finite sequence of features, and the set P ATHS paths. is the empty path.
 Definition 17 A typed pre-feature structure (pre-TFS) is a triple  X  ,  X  , where:
A typed feature structure (TFS) is a pre-TFS A =  X  ,  X  , for which the following requirements hold: 58 Definition 18 ATFS A =  X  ,  X  , is well-typed iff whenever  X   X   X  and F  X   X  , then Approp (  X  (  X  ), F )  X  ,and Approp (  X  (  X  ), F )  X  (  X  F ). TFSs and a start symbol which is a TFS.

A grammar module is a structure M = S , G , where S is a signature module and G is a grammar. The grammar is defined over the signature module analogously to the way ordinary grammars are defined over type signatures, albeit with two differences: 1. TFS S are defined over type signatures, and therefore each path in the TFS 2. Enforcing all TFS S in the grammar to be well-typed is problematic for modules to grammar modules. In both cases, the components of the grammars are most of the information in typed formalisms is encoded by the signature, and therefore modularization is carried out mainly through the distribution of the signature between the different modules; the lifting of the signature combination operation to operations on full grammar modules is therefore natural and conservative. by extending the underlying signature module into an ordinary type signature and adjusting the grammar accordingly. 10 4. Modular Construction of the Basic HPSG Signature
To demonstrate the utility of signature modules for practical grammar engineering we use signature modules and their combination operators in this section to work out a modular design of the HPSG grammar of Pollard and Sag (1994). This is a grammar of
English whose signature, covering several aspects of syntax and semantics, is developed throughout the book. The signature is given (Pollard and Sag 1994, Appendix A1) as one unit, making it very hard to conceptualize and, therefore, to implement and maintain.
We reverse-engineered this signature, breaking it up into smaller-scale modules that emphasize fragments of the theory that are more local, and the interactions among such fragments through  X  X erge X  and  X  X ttachment X . 11 Some of the fragments make use of the signature module List of Figure 11. 60 most general type. This module defines the main fragments of the signature. word and phrase . The latter is exported and will be used by other modules, as we the values of PHON and RETRIEVED are imported.

Figure 17. Note in particular that the feature COMP -DTRS as values a list of phrases; this is an imported type, which is obtained as a result of several attachment operations (Figure 11).
 a specification of the inventory of syntactic categories defined by the theory. Note how simple it is to add, remove, or revise a category by accessing this fragment only.
As another example, Figure 20 depicts the type hierarchy of nominal objects, which is completely local (in the sense that it does not interact with other modules, except at the root). Finally, Figure 21 abstracts over the internal structure of Phonstring and
Quantifier ; these are only representatives of the actual signature modules which define these fragments.
 here. With this in mind, the HPSG signature can now be constructed in a modular way from the fragments defined earlier. The construction is given in Figure 22. module through the operation in the module Sign through the operation
Notice how the order of the parameters ensures the correct instantiation. Now, in the second element, List ( Sign ) both creates a list of phrase (since phrase is an exported 62 node in the module Sign ) and unifies the information in the two modules. Similarly, node phrase list in the module ConStruc . In the same way, List ( Synsem ) both creates a list of synsem (since synsem is an exported node in the module Synsem ) and unifies information from the different modules is unified through the merge operation. Other modules can be added, either by merge or by attachment. Additionally, the internal structure of each module can be locally modified. Such changes become much easier given the smaller size and theoretical focus of each of the modules.
 of Pollard and Sag (1994): The signature of Pollard and Sag is hard to conceptualize because all the information is presented in a single hierarchy. In contrast, looking at each small fragment (module) separately, it is easier to understand the information encoded in the module. Contemporary type signatures are in fact much larger; working with small fragments in such grammars is instrumental for avoiding or tracking errors.
Moreover, grammar maintenance is significantly simplified, because changes can be done locally, at the level of specific modules. Of course, when a new grammar is devel-oped from scratch, modularization can be utilized in such a way as to reflect indepen-dent fragments of the linguistic theory in separate modules.
 enough to reflect the kind of knowledge organization exhibited by linguistically moti-vated grammars, but is at the same time modest enough so that its redesign in a modular way can be easily comprehended. It is therefore useful as a practical example of how type signatures can be constructed from smaller, simpler signature modules. Real-world grammars are not only much larger, they also tend to be more complex, and in particular express interactions in domains other than the type signature (specifically, as type constraints and as phrase-structure rules). Extending our solution to such interactions is feasible, but is beyond the scope of this preliminary work. 5. MODALE : A Platform for Modular Development of Type Signatures
Two leading implementation platforms are available for the development of typed unification grammars: The Linguistic Knowledge Building system (LKB) (Copestake 2002) and TRALE (Meurers, Penn, and Richter 2002), an extension of the Attribute
Logic Engine (ALE) (Carpenter and Penn 2001). MODALE (MODular ALE) is a system that supports modular development of type signatures in both ALE and TRALE. The main features of the system are: and algorithms that take advantage of type signature properties such as bounded completeness, upward closure, and feature introduction, none of which can be assumed when working with a signature module. As a result, our implementation is not a direct adaption of the existing ALE / TRALE code, but a new system that was developed from 64 scratch. Extending the algorithms of Penn (2000) from type signatures into signature modules is left as a direction for future research.
 the time efficiency of module combination. Indeed, the combination and resolution isomorphism, a problem which is neither known to be solvable in polynomial time nor NP-complete. 12 However, in the signatures we have experimented with so far, we encountered no time issues. Furthermore, it is important to note that these calculations are executed only once, in compile time, and have no impact on the run time of
ALE/TRALE, which is the crucial stage in which efficiency is concerned. 6. Discussion and Conclusions
We presented a complete definition of typed unification grammar modules and their interaction. Unlike existing approaches, our solution is formally defined, mathemati-cally proven, can be easily and efficiently implemented, and conforms to each of the desiderata listed in Section 1.1, as we now show.

Signature focus: Our solution focuses on the modularization of the signature (Sec-
Partiality: Our solution provides the grammar developer with means to specify any
Extensibility: In Section 2.5 we show how a signature module can be deterministically
Consistency: When modules are combined, either by merge or by attachment, the
Flexibility: The only restrictions we impose on modules are meant to prevent subtyp-(Remote) Reference: This requirement is achieved by the parametric view of nodes.
Parsimony: When two modules are combined, they are first unioned; thus the resulting
Associativity: We provide two combination operations, merge and attachment .Theat-
Privacy: Privacy is achieved through internal nodes which encode information that
We believe that our definition of signature modules, along with the operations of merge and attachment , provide grammar developers with powerful and flexible tools for collaborative development of natural language grammars, as demonstrated in Section 4. grammar designer must determine how to abstract away certain aspects of the devel-oped theory, thereby identifying the interaction points between the defined module and (2005); we believe that we provide a more general, flexible, and powerful framework to achieve the full goal of grammar modularization.
 in typed unification grammars. An extension of signature modules to include also type constraints is called for and will provide a better, fuller solution to the problem of grammar modularization. In a different track, we also believe that extra modularization for future research.
 tions. An environment that supports modular construction of large-scale grammars will 66 greatly contribute to grammar development and will have a significant impact on prac-tical implementations of grammatical formalisms. The theoretical basis we presented in this work was implemented as a system, MODALE , that supports modular develop-ment of type signatures (Section 5). Once the theoretical basis is extended to include also type constraints, and they, as well as grammar modules, are fully integrated in a grammar development system, immediate applications of modularity are conceivable (see Section 1.1). Furthermore, although there is no general agreement among linguists on the exact form of modularity in grammar, a good modular interface will provide the support their comparison in a common platform.
 grammar development environments, and various other provisions will be needed in order for grammar engineering to be as well-understood a task as software engineering now is. We believe that we make a significant step in this crucial journey. Appendix: Compactness
We provide a formal definition of the compactness algorithm in this section. For an example of the following two definitions see Example 3.
 Definition 19
Let S = Q , T , , Ap , Int , Imp , Exp be a pre-signature module. ( q dant subtyping arc if there exist p 1 , ... , p n  X  Q , n p Definition 20
Let P = Q , T , , Ap , Int , Imp , Exp be a pre-signature module. ( q dundant appropriateness arc if there exists q 2  X  Q such that q ( q 1 , F , q 2 ) graphs, we can adapt the well-defined notion of graph isomorphism to pre-signature modules. Informally, two pre-signature modules are isomorphic when their underlying
PSSs have the same structure; the identities of their nodes may differ without affecting the structure. In our case, we require also that an anonymous node be mapped only to an anonymous node and that two typed nodes, mapped to each other, be marked by the same type. However, the classification of nodes as internal, imported, and/or exported has no effect on the isomorphism since it is not part of the core of the information encoded by the signature module.
 Definition 21
Two pre-signature modules S 1 = Q 1 , T 1 , 1 , Ap 1 , Int
Ap 2 , Int 2 , Imp 2 , Exp 2 are isomorphic , denoted S 1 and onto function i ( isomorphism ) mapping the nodes of S that all the following hold: 1. for all q  X  Q 1 , T 1 ( q ) = T 2 ( i ( q )) 2. for all q , q  X  Q 1 , q 1 q iff i ( q ) 2 i ( q ) 3. for all q , q  X  Q 1 and F  X  F EAT ,( q , F , q )  X  Ap of arcs (subtyping or appropriateness, in any direction), up to and including the first typed node. The environment of a typed node includes itself only.
 Definition 22
Let S = Q , T , , Ap , Int , Imp , Exp be a pre-signature module. For all q environment of q , denoted env ( q ), be the smallest set such that: Definition 23
Let S = Q , T , , Ap , Int , Imp , Exp be a pre-signature module and let Q strict restriction of S to Q , denoted S | strict Q ,is Q , T subgraph induced by the nodes of Q without any labeled or unlabeled arcs connecting two typed nodes in Q .
 Definition 24
Let S = Q , T , , Ap , Int , Imp , Exp be a pre-signature module. Two nodes q are indistinguishable , denoted q 1  X  q 2 ,if S | strict env ( q that i ( q 1 ) = q 2 .
 Example 14
Let S 1 be the signature module of Figure A1
The strict restrictions of S 1 to these environments are depicted in Figure A2. q q  X  q 68
However, q 5 is distinguishable from q 2 and q 4 because T ( q
Notice also that q 3 is distinguishable from q 2 , q 4 and q appropriateness arcs.
 Proposition 3
Let S = Q , T , , Ap , Int , Imp , Exp be a pre-signature module. Then  X  lence relation over Q .
 Definition 25
A pre-signature module S = Q , T , , Ap , Int , Imp , Exp is non-redundant if it in-cludes no redundant subtyping and appropriateness arcs and for all q implies q 1 = q 2 .
 Definition 26
Let S = Q , T , , Ap , Int , Imp , Exp be a pre-signature module. The coalesced pre-signature module , denoted coalesce ( S ), is Q 1 , T 1 ,
Additionally, the parameters and arities are induced from those of the input pre-signature module. All parameters may be coalesced with each other, as long as they are otherwise indistinguishable. If (at least) one of the coalesced nodes is an internal the resulting parameter is imported as well. Similarly, if one of the nodes is exported then the resulting parameter is exported.
 a non-redundant signature module which encodes the same information.

Algorithm 4 ( ( compact ( S = Q , T , , Ap , Int , Imp , Exp ) )) ) 1. Let S 1 = Q 1 , T 1 , 1 , Ap 1 , Int 1 , Imp 1 , Exp 2. S = coalesce ( S 1 ) 3. If S is non-redundant, return S , otherwise return compact ( S ) includes redundant arcs or nodes. In each iteration, all the redundant arcs are first removed and then all indistinguishable nodes are coalesced. However, the identifica-tion of nodes can result in redundant arcs or can trigger more nodes to be coalesced. Therefore, the process is repeated until a non-redundant signature module is obtained.
Notice that the compactness algorithm coalesces pairs of nodes marked by the same type regardless of their incoming and outgoing arcs. Such pairs of nodes may exist in a pre-signature module (but not in a signature module).
 Example 15
Consider again S 1 , the signature module of Figure A1. The compacted signature module of S 1 is depicted in Figure A3. Notice that S 1 has no redundant arcs to be removed and 70 pairwise distinguishable and no arc is redundant.
 Example 16 compactness algorithm on S 2 , first the redundant subtyping arc from q resulting in S 3 which has no redundant arcs. Then, q 2 and q
S is S 5 which is non-redundant.
 Proposition 4 The compactness algorithm terminates.
 Proposition 5 The compactness algorithm is deterministic: it always produces the same result. Proposition 6 If S is a signature module then compact ( S ) is a non-redundant signature module. Proposition 7
If S is a non-redundant signature module then compact ( S ) Acknowledgments References 72
