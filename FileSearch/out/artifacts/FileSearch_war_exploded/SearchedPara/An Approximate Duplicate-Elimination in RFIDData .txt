 RFID (Radio Frequency Identification) based system usually contains many tags and readers. A tag is attached to a physical object with the aim to track the movement of this object. An reader, which has a limited detection region, is deployed to detect the tags that occurs in the region without contact; then it sends a sequence of RFID data to a server for real-time analysis. Given that the RFID data is generated and sent to t he server continuously by many RFID readers in an RFID based system, the RFID data comes to the server in the form of an input RFID data stream [10, 13]. The server conducts some kinds of real-time analysis based on the input RFID data stream. It is defined in [13] that each element in RFID data streams in cludes: a tag identifier, the location of the reader that detects the tag, and t he detected time of the tag (similar to [13], we also call it the detected time of an element in RFID data streams).
Due to the low price of tags and the non-intrusive way that the reader detects tags, RFID based systems have been applied in many fields [1, 10, 11, 12, 14], such as postal package tracking and customer behavior analysis. In real RFID based systems, multiple RFID readers are deployed in the same area to prevent missing readings of RFID tags. Because, if RFID tags move quickly and a large number of tags pass simultaneously through the detection region of an RFID reader, the reader can X  X  ensure to detect all of them [13]. On the other hand, if an RFID tag moves slowly or stands still in the detection region of an reader, many unnecessary RFID data of this tag (called duplicate elements in RFID data streams) is generated [13]. Thus, usually, there are a larger number of duplicates in RFID data streams. These duplicates will degenerate the accuracy of real-time analysis in an RFID based system if they are not eliminated.

For example, an RFID based system can be used to tracking the user behavior in a large department store, where each customer is attached with a unique tag and each area of the department is deployed with some readers. Readers send the RFID data of tags (elements in RFID data streams) to a server for the real-time analysis of customers behavior, such as the real-time number of customers in every store. In this application, when a customer stays at the same region for a long time, a larger number of unnecessary RFID data will be generated [13]. Obviously these duplicates must be dropped.

As raw RFID data obtained from RFID readers contains false and uncertain readings, there has been some research on RFID data cleaning [2, 3, 6, 9, 10]. However these researches don X  X  consider approximate duplicate-elimination in RFID data streams.

It has been pointed out in [13] that eliminating the duplicates in an RFID data stream exactly requires a large number of memory bits to store all ele-ments in RFID data streams within a time length of  X  , thus is an inefficient approach. There are also many methods for approximate duplicate detection in data streams, e.g. [7, 8]. However these approaches can X  X  store the detected time of an element in RFID data streams. To eliminate duplicates in an RFID data stream approximately, some methods have been proposed. The authors in [13] propose Time Bloom filters (TBF), which uses a time counter to substitute the bit used in a Bloom filter. They store th e detected time of an element in RFID data streams into the k time counters hashed by this element, and eliminate duplicates based on the values of time counters in TBF. They also propose Time Interval Bloom filters (TIBF) to reduce the false positive rate of TBF. How-ever, these methods are not memory efficient, since multiple time counters are required to store the detected time of an element in RFID data streams in TBF or TIBF. In [11], the authors deploy a TBF in each RFID reader, with the aim to reduce the bandwidth requirement to transfer those duplicates to the server.
Our work is mainly motivated by [4] and [13]. We devise a d-left Time Bloom filter (DLTBF), which is an extension of d-left Counting Bloom filter in [4]. Based on DLTBF, we propose an one-pass approximate method to remove duplicates in RFID data streams. In an RFID data stream, suppose that the detected time of an element is T -bit, the number of non-duplicate elements within a time length of  X  is W and false positive probability is  X  , the number of bits used by DLTBF in our method is O( W log(1 / X  )+ WT ), while the existing methods based on TBF in [13] need O( W log 2 (1 / X  ) T )bits.

The rest of this paper is organized as follows. In Section 2, we give some background on the definitions of duplicate element and the duplicate-elimination problem in RFID data streams. We descr ibe d-left Time Bloom filter (DLTBF) and an one-pass duplicate-elimination method based on DLTBF in Section 3. In Section 4, experimental results on synt hetic data set demonstrate the effective-ness of our method. Section 5 concludes this paper. An RFID based system is depicted in Fig . 1. Each reader generates RFID data continuously and an RFID data stream c omes into the server. There is a module for duplicate elimination in the server, which sends a non-duplicate RFID data stream to the real-time analysis module. To be more specific, the duplicates are effectively dropped out from the raw RFID data stream by the duplicate-elimination module. Thus the real-time analyis module can give more accurate result based on a non-duplicate RFID data stream.

In [13], an RFID data stream RFIDStream is defined as a sequence of el-ements: RFIDStream = s 1 ,...,s n ,... , where each element s i is a triple s i = &lt; TagID,Loc,Time&gt; . TagID is an unique electronic product code (EPC) of a tag [10]. Loc is the location of the reader that detects the tag with TagID . Time is the detected time of a tag (we also call it the detected time of s i an element in RFIDStream ). Considering the example in Fig. 1, there are two readers ( Reader 1, Reader 2), and two tags with the identifier (EPC) ID 1and ID 2 (the two tags are attached to two objects respect ively). Two Readers generate the de-tection information such as &lt; TagID,Location,Time &gt; . For example, Reader 1 may detect the tag with ID 1 and generate an element: s n = &lt;ID 1 ,Loc 1 , 3 &gt; in an RFID data stream. ID 1 is the EPC of a tag, Loc 1 is the location of Reader 1, and 3 represents the detected time of s n .

It is also defined in [13] that an element s i in RFIDStream is considered as a duplicate if there exists an element s j  X  RFIDStream,j = i , such that s .TagID = s j .TagID and s i .Time  X  s j .Time  X   X  ,where  X  is a positive value depends on an application. This definition is intuitive because that elements in RFIDStream with the same TagID that are generated repeatedly at time intervals that are less than or equal to  X  are usually useless [13]. Considering the RFID data stream in the server in Fig. 1 and assuming  X  =2 . 5, based on the definition of duplicate in RFIDStream , we know the third element &lt; fourth element &lt;ID 2 ,Loc 2 , 4 &gt; is a duplicate because of the third element &lt; ID 2 ,Loc 2 , 2 &gt; . The non-duplicate elements sent to the real-time analysis module non-duplicate RFID data stream for RFIDStream is an RFID data stream after eliminating all duplicates in RFIDStream , see Fig. 1. In this section, we describe the d-left Time Bloom filter (DLTBF) , which is an extension of d-left Counting Bloom filter in [4], for approximate duplicate-elimination in RFID data streams. The main working principle of DLTBF is to store the fingerprints (produced based on the TagID ) and the detected time of elements in an RFID data stream evenly into four hash tables, based on the d-left hashing (a variation of the balanced allocations mechanism [15]). Based on the stored fingerprints and detected times of elements, we can approximately remove duplicates in an RFID data stream. 3.1 d-Left Time Bloom Filter Design We assume that the maximum number of non-duplicate elements in an RFID data stream is W within a time length of  X  . The d-left Time Bloom filter (DLTBF) is depicted in Fig. 2. (For convenience W/ 24 is assumed to be an integer.) The DLTBF uses 4 independent hash functions ( h 1 ,h 2 ,h 3 ,h 4 ) with produces the fingerprint of an element in RFID data streams).

The explicit data structure of DLTBF is as follows. There are 4 hash tables in DLTBF. Each hash table contains W/ 24 buckets: B [1] ,...,B [ W/ 24] and each bucket contains 8 slots. Each slot in one bucket B [ i ] includes a R -bit (the R -bit is used for storing the fingerprint f ( x.TagID )ofanelement x in RFID data streams) and a T -bit counter (the T -bit is used for storing the detected time x.Time of x ). The reason that we adopts 4 hash tables, each with W/ 24 buckets (8 slots in a bucket) in DLTBF, is that this setting is good enough to prevent bucket overflow (more than 8 elements are put into the same bucket) in DLTBF with very high probability (we give the proof in Lemma 1).

The steps for storing an element x in RFID data streams into DLTBF are as follows. we first find 4 possible buckets B [ h i ( x.TagID )] ,i =1 , 2 , 3 , 4inHash Table 1  X  4. B [ h 1 ( x.TagID )] is the h 1 ( x.TagID )-th bucket in Hash Table 1, B [ h 2 ( x.TagID )] the h 2 ( x.TagID )-th bucket in Hash Table 2 and so on. Then we place the fingerprint f ( x.TagID )andtime x.Time into the least loaded bucket (the bucket contains the largest number of free slot); in case of a tie, f ( x.TagID )and x.Time are stored into the bucket of the leftmost Hash Table. When the 4 buckets all don X  X  have free slot, we store f ( x.TagID )and x.Time of x into a stash, which contains a number of counters. In the following, we will prove that the expected number of elemen ts stored in the stash is less than O(1) at any time t .

In order to check whether an incoming element x from an RFID data stream is a duplicate or not, we check the 4 buckets B [ h i ( x.TagID )] ,i =1 , 2 , 3 , 4, one in each hash table. If there exists a slot Slot [ j ] in one bucket such that Slot [ j ] .Fingerprint = f ( x.TagID )and x.Time  X  Slot [ j ] .Time  X   X  , x is taken to be a duplicate (there may be some false positive errors in this case due to hash collisions). Otherwise, we are sure that x is not a duplicate. Because if x is a duplicate of y (this means y.TagID = x.TagID and x.Time  X  y.Time  X   X  ), then y must have occupied one slot in the 4 buckets with the fingerprint f ( y.TagID )= f ( x.TagID )( y.TagID = x.TagID ) and the time y.Time ( x.Time  X  y.Time  X   X  ). It should be noted that when we can X  X  find a slot Slot [ j ] in the four buckets such that Slot [ j ] .Fingerprint = f ( x.TagID ), in order to prevent false negative error, we still have to check the fingerpr ints and detected times stored in the stash. But considering that the query cost in this case is O(1) (Based on Lemma 1, we know that the expected number of el ements stored in the stash is less than O(1) at any time t ), so we omit this process in Algorithm 1.
 Algorithm 1. Duplicate-elimination algorithm based on DLTBF
How to eliminate duplicates in an RFID data stream RFIDStream based on DLTBF is depicted in in Algorithm 1. The algorithm can efficiently remove all duplicates in one-pass scan of RFIDStream . The two counters in each slot Slot [ i ] are initially set as: Slot [ i ] .Time =  X  1and Slot [ i ] .Fingerprint =  X  1 (  X  1representsthat Slot [ i ]isfree).Whenanelement x of RFIDStream ar-rives at the server, it will pass through the DLTBF in the duplicate-elimination module ( x will be dropped or sent to the real-time analysis module). To be more specific, when x passes through the DLTBF, firstly we check the condi-tion: if there exists a slot Slot [ j ] such that Slot [ j ] .Fingerpint = f ( x.TagID ) and x.Time  X  Slot [ j ] .Time  X   X  in the 4 buckets B [ h i ( x.Tag )] ,i =1 ,.. 4(Line 5-6 in Algorithm 1). If so, x is taken to be a duplicate and dropped from the RFID data stream (Line 7). It should be noted that, in this case, x may be a non-duplicate element, since Slot [ j ] may be set by another non-duplicate element y due to hash collisions ( y.TagID = x.TagID , there exists a i  X  { table, and B [ h i ( y.TagID )] = B [ h i ( x.TagID )], f ( y.TagID )= f ( x.TagID ), x.Time  X  y.Time  X   X  ). Otherwise x is surely a non-duplicate element and sent to the real-time analysis module. Finally, we store x.Time and f ( x.TagID )into a slot or a position in the stash whenever x is duplicate or not (Line 8 and 13-16).
Fig. 3 shows the state of DLTBF before the arrival of an element x  X  RFIDStream . For ease of illustration, in Fig. 3, we assume W/ 24=4 and each bucket contains 4 slots (Actually, each bucket in DLTBF contains 8 slots). In Fig. 3, x is hashed to the four buckets (one in each hash table) by h ,h 2 ,h 3 ,h 4 . In Fig. 4, three cases for the insertion of x into DLTBF are showed. In case 3, x is surely a non-duplicate element, so it will be stored into the least loaded bucket. In case 2, x is also surely a non-duplicate element, but given that there a slot contains the same fingerprint as f ( x.TagID ), so we just update this slot. For case 1, x is assumed to be a duplicate element and the update is same as that in case 2. 3.2 Theoretical Performance Analysis of DLTBF In this section, we shall analyze the false positive probability of Algorithm 1 and compare its performance with that of the approximate duplicate-elimination method based on Time Bloom filter (TBF) in [13]. We assume that the readers detect various tags independently from one another in the following analysis.
If a newly incoming element x is non-duplicate (there is not an element y such that y.TagID = x.TagID and x.Time  X  y.Time  X   X  ), Algorithm 1 will take x to be duplicate only if there exists an element z ( z.TagID = x.TagID ) such that x.Time  X  z.Time  X   X  , h i ( x.TagID )= h i ( z.TagID )forsome i  X  X  1 , 2 , 3 , 4 } , and f ( x.TagID )= f ( z.TagID ). In an RFID data streams, suppose there are W non-duplicate elements within a time length of  X  ,a R -bit counter in each slot for storing fingerprint of elements, then the probability that Algorithm 1 takes a non-duplicate element x to be duplicate (the false positive probability) is given in the following.
 Theorem 1. For a non-duplicate element x =( x.TagID,x.Loc,x.Time ) ,the false positive probability of Algorithm 1 is 24 / 2 R .
 Proof. Considering a stored element z in DLTBF such that z.Time  X  (0 ,x.Time  X   X  ) , it is obviously that z will not affect the decision of Algorithm 1 on x ,since z is an expired element in time x.Time .

Given that the number of the non-duplicate elements stored in DLTBF within a time length of  X  is W (denote y one of the W elements, then y satisfies y.Time  X  [ x.Time  X   X ,x.Time ) ), the W elements may affect the decision of Al-gorithm 1 on x . Without loss of generality, we assume that there are W i elements stored in the i -th hash table, i =1 , 2 , 3 , 4 ( W 1 + W 2 + W 3 + W 4 = W ). Obvi-ously, in the i -th hash table, if one of the W i elements is hashed to the bucket B [ h i ( x.TagID )] and has the fingerprint f ( x.TagID ) , Algorithm 1 will surely take x to be duplicate. Furthermore, in the i -th hash table, the probability that one of the W i elements is hashed to the bucket B [ h i ( x.TagID )] and has finger-print f ( x.TagID ) is 24 W  X  1 2  X  R . Thus the probability that Algorithm 1 takes a non-duplicate x to be duplicate due to the impact of the W i elements in the i -th
Obviously, Algorithm 1 uses the randomized multiple-choice allocation scheme same as the Always-Go-left algorithm in [15]. In the following, we will use the Theorem 1 (generalized ve rsion) in [15] to show that the expected number of elements that are stored in the stash used in Algorithm 1 is O(1) at any time t . In this paper, we say an event A to occur with high probability if P ( A )  X  1  X  W  X   X  for an arbitrarily constant  X   X  1. We use  X  X .h.p. X  as an abbreviation of  X  X ith high probability X .
 Lemma 1. Suppose there are at most W non-duplicate elements x 1 ,..,x W ( t  X  x .Time  X   X ,i =1 ,..,W ) stored in DLTBF of Algorithm 1 at any point of time t . Then the maximum loaded bucket in DLTBF contains ln ln( W/ 6) 4ln1 . 927 +6 elements, w.h.p., at any time t .
 Proof. Plugging d =4 ,  X  4 =1 . 927 (see in [5]) and h =6 (there are altogether W/ 6 buckets in DLTBF) into the Theorem 1 (generalized version) in [15], we get the conclusion.
 Given that W is usually smaller than 6  X  10 20 in an RFID based system, then at any point of time t , the maximum loaded buckets in Algorithm 1 is less than 4ln1 . 927 +6=7 . 4596 &lt; 8, w.h.p. (with probability at least 1 Then we can see that the probability that one of the W non-duplicate elements within the time interval ( t  X   X ,t )isstoredinthestashisless W  X   X  ,thusthe expected number of the elements stored in the stash is less than W  X   X  W =O(1) (noting that an element will be stored in stash only if there is an bucket contains 8 elements). Actually, the expected number of the elements stored in the stash is much less than 1, since in the above analysis, we don X  X  consider the probability that the maximum loaded buckets are selected by one of the W elements.
Since there is not a closed form formula of false positive rate for the ap-proximate duplicate-elimination algorithm based on Time Interval Bloom filter (TIBF) in [13], so we compare Algorithm 1 with the method based TIBF exper-imentally in Section 4.

We compare the approximate duplicate-elimination algorithm based on TBF in [13] with Algorithm 1 in Theorem 2. In an RFID data stream, suppose that the detected time of an element is T -bit, the number of non-duplicate elements within a time length of  X  is W and false positive probability is  X  ,thenwehave the following.
 Theorem 2. Given the same false positive rate  X  , the number of bits used by the approximate duplicate-elimination algorithm based on TBF in [13] is Proof. According to Theorem 1 in [13], given m counters (each is a T -bit counter) and W non-duplicate elements within a time length of  X  , the false positive probability of the approximate duplicate-elimination algorithm based on TBF is (1 / 2) ( m ln 2) /W , and the number of bits used by this algorithm is mT .Let  X  =(1 / 2) ( m ln 2) /W , we have m = (log 2 e )log 2 (1 / X  ) W , Thus we get the number of bits used by the algorithm based on TBF is (log 2 e )log 2 (1 / X  ) WT . In Algorithm 1, DLTBF uses [ T + R ] W 4 / 3 bits. This is because that there are W/ 6 buckets in DLTBF, and the number of bits used by a bucket is 8[ T + R ] (a bucket contains 8 slots and each slot contains a T -bit and a R -bit counters). By Theorem 1, we know the false positive rate of Algorithm 1 is 24 / 2 R .Let  X  =24 / 2 R , we can get the number of bits used by Algorithm 1 is [log 2 (1 / X  )+ T + log 2 24]4 W/ 3 (Since the stash contains O (1) elements, we neglect the constant bits used in the stash).

Considering that there are W non-duplicate elements within a time length of  X  , thus to obtain a false positive rate  X  , Algorithm 1 uses m 1 =1 . 33(log 2 (1 / X  )+ T +4 . 5) bits per element, while the algorithm based on TBF needs m 2 = 1 . 44log 2 (1 / X  ) T bits. It is easy to see that when  X   X  0 . 125 and T&gt; 3 . 5, m 1 is less than m 2 ,and m 2  X  m 1 increases with the increase of T and 1 / X  . In this section, we use the detection mod el in [10, 13] to generate synthetic RFID data streams. In this model, tags move in a straight line with different velocities that are assigned randomly when the tags are generated. There are many de-tection locations in this line and multiple readers may be used to monitor each location in order to increase detection ratio. Similar to [13], we deploy one reader in each detection location and generate an RFID data stream of 10 7 elements (denoted by DataSet1); and we deploy thr ee readers in each detection location and generate an RFID data stream of 10 7 elements (denoted by DataSet2). Obviously, DataSet2 (83% elements in DataSet2 are duplicate) contains more duplicates than DataSet1 (39% elements in DataSet1 are duplicate). The maxi-mum numbers of non-duplicate elements within a time length of  X  in Dataset1 and Dataset2 are 1265 and 1333 respectively (  X  = 100). The experiments are conducted on 2GHz PC with 4GB main memory using Matlab.

We evaluate Algorithm 1 (the algorithm based on DLTBF), the algorithms based on Time Bloom filter and Time Interval Bloom filter with respect to a false positive rate and a processing rate. In the experiments, the three algorithms use the same number of memory bits.
 Fig. 5 shows the false positive rates of the three algorithms in DataSet1 and DataSet2. The false positive rate is sum of false positive errors divided by the 10 7 (the number of elements in DataSet1 or DataSet2 that will be processed by the three algorithms). In Fig. 5, we can see that given the same number of memory bits, DLTBF based algorithm produces a least false positive rate among the three algorithms. It should be noted that the theoretical false positive rate of DLTBF based algorithm is obtained when an element is actually non-duplicate, while there are a large number of duplicates in Dataset1 and Dataset2. Thus the theoretical false positive rate of DLTBF based algorithm is larger than the experimental false positive rate of this algorithm. The reason why the theoretical false positive rate of TBF based algorithm is larger than its experimental false positive rate is the same.

Fig. 6 shows the processing rates of the three algorithms. A processing rate of an approximate duplicate-elimination algorithm is the number of elements that the algorithm can process in one second. In Fig. 6, we can see that given the same number of memory bits, The processing rate of TBF based algorithm is about 1.4 times as that of the other two algorithms over DataSet1 and DataSet2. However from Fig. 5, we can see that the false positive rate of TBF based algorithm is about 10 times as that of DLTBF based algorithm. DLTBF based algorithm has a processing rate similar to that of TIBF based algorithm in Fig. 5, but we note that the false positive rate of TIBF based algorithm is about 8 times as that of DLTBF based algorithm. Usually, there are a larger number of duplicates in RFID data streams, and these duplicates must be eliminated effici ently before an accurate analysis can be conducted on RFID data streams. Existing duplicate-elimination methods based on Time Bloom filter require multiple counters to store the detected time of an element in RFID data streams, thu s waste valuable memory resources. In this paper, we devise d-left Time Bloom filter (DLTBF) as an extension of d-left Counting Bloom filter. With the d-left hashing, a balanced allocation mechanism, DLTBF can store the detected time of an element into one counter. Then we propose an one-pass approximate method to remove duplicates in RFID data streams based on DLTBF. Experimental results on the synthetic data verify the effectiveness of our method.
