 Recommender systems take into account a wide range of in-formation about both an individual user and other users X  preferences in order to provide relevant content. However, one source of information that appears to be under-utilized is contextual information about the user X  X  trajectory: where they are currently located, and where they are traveling to. We demonstrate a system that recommends the reading or-der of Twitter content based on the user X  X  planned travel. H.4 [ Information Storage and Retrieval ]: Miscellaneous
Recommender systems take into account a wide range of information about both an individual user and other users X  preferences in order to provide relevant content; however, traditional content-based and collaborative filtering-based systems tend to rely on static user models [1]. As such there has been an increase in interest in context-aware recom-mender systems. One source of information that appears to be under-utilized is contextual information about the user X  X  current travel. While there is previous work on recommen-dations from location-based social networks [2], little work has been done exploring trajectories.

With the current rising popularity of intelligent personal assistants such as Microsoft X  X  Cortana and Google Now, mo-bile devices are increasingly aware of the context in which they are used. In particular, these assistants track users X  daily commute patterns and also scheduled appointments, giving a wealth of contextual information that can be used to provide better content recommendation across a wide va-riety of content types. Our motivating scenario is as follows: a user commutes from home to work using public transporta-tion and would like to consume relevant content as he/she travels to the destination. We are interested in exploring the directionality criterion, which assumes that users may Francisco are ranked higher than those closer to their destination.
The demo uses two models. The first model (the  X  X ravel X  model) asks the user to provide his/her current location and destination, and provides a reading order based on how each tweet falls along the user X  X  approximate trajectory. For ex-ample, in Figure 1 the user is traveling between San Fran-cisco and Sunnyvale. The trajectory is modeled as a straight line between the origin and destination. For each tweet, the ranking function identifies the closest point along this line to the tweet; tweets that fall at the user X  X  current loca-tion along the line are given the highest score, and tweets closest to the destination are given a lower score. In this example, the user is currently in San Francisco, so tweets in the vicinity rank higher than those tweets that are lo-cated closer to the user X  X  destination in Sunnyvale. This corresponds to the order in which the user will pass by the tweets X  locations while traveling. The score of each tweet is penalized by exponential decay functions based on how far the tweet X  X  location is from the closest point on the path, and the age of the tweet; this ensures that tweets that will fall in the user X  X  vicinity rank higher than those that fall far away from the path, and that possibly stale tweets will be less likely to score highly. The equation is defined as: from the closest point along the path to the tweet X  X  loca-tion, d 1 is the distance from the start of path to that closest point, and  X  is the age of the tweet.  X  1 and  X  2 are config-urable parameters that can be tuned to adjust how much tweets are penalized based on their age and distance from the path of travel.

The second model (the  X  X lended X  model) combines the score from the travel model with a score computed from the basic user model created for each user. The user model score is calculated using cosine similarity between the user model vector and a document vector derived from each tweet. As explained above, the user model consists of a vector in which the value for each token is the term frequency across tweets the user authored, retweeted, or marked as favorite: w term,usermodel = count ( term ). The tweet is modeled as a vector consisting of term frequencies, weighted by the inverse document frequency of the term (as seen across all tweets the system has consumed from the user X  X  home stream): w the total number of tweets consumed from the stream and
