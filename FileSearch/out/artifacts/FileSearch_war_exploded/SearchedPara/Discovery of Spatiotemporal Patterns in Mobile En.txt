 The rapid developments in wireless communication devices and the increasingly accuracy of GPS technology pave the way to a range of new type of location-based services(LSB). The services capture the requests including geographical origins re-ceived in multidimensional databases. 1
Moving patterns are possibly used to provide proper services customizing users X  references according to their location contex t. Although there have been many studies on spatiotemporal mining they mainly focus on the models and structures for indexing moving objects. There is a recent approach DFS_MINE in[8] discovering spatiotem-mining moving patterns. In this study, we offer algorithms for mining spatiotemporal patterns in mobile environment. With the view that space and time form a disjoint partition of the spatiotemporal activity we plan to decompose the object space into separate regions. We then preprocess moving object histories by transforming moving data into moving sequences. Moving patterns are generated using two algorithms called All_MOP and Max_MOP. The first one mines all frequent patterns and the other discovers only maximal frequent patterns. We finally conduct an experiment to evaluate the efficiency of our algorithm. Our proposed method is applicable to LBS such as tourist service, safety-related service, and so on. 
The remainder of this paper is organized as follows. The next section reviews several detail the process of discovering frequent patterns. Section 5 illustrates the performance study of these algorithms. Section 6 concludes this paper and offers future work. In this section, we review some of the most relevant researches in the field of knowl-edge discovery mining. 
Sequential patterns[1],[7],[8],[12] are described informally as the discovery of in-ter-transaction patterns in large customer tr ansaction databases. A sequence is a set of temporally ordered itemsets. One can divide approaches for finding frequent itemsets based on two criteria: by their strategy to traverse the search space and by their strat-egy to determine the support values of itemsets[13]. Based on the first criteria today's common approaches are either breadth-first search or depth-first search. A compari-son of methods based on these approaches revealed that the methods all have some types of data for which they perform better than the others. Moving sequential pattern mining deals with time series of object location information involving temporal and spatial dimensions[5][10],[11]. We observe that previous temporal and spatial data mining researches mostly focus either on temporal or spatial mining[2],[3],[6]. Al-though there has been some work on spatiotemporal mining, they mainly focus on the models and structures for indexing moving objects[9]. The recent approach in[8] discovers spatiotemporal sequential patterns for weather prediction. It is seeking rela-tionships between time-varying attributes for fixed location, but does not show how to between stable attributes of objects with varying-time location. Spatial organization of a specific region P  X  R 2 is represented as a partitioning, called reference plane . The partition is related to a specific thematic interpretation of space. We choose a thematically  X  X eutral X  partition [4]. A moving object database D is defined as the union of time series of locations, i.e., = . Each time series D i of one corresponding object contains triples ( x,y,t ). 
Locations of a trajectory are mapped to an area in the reference plane. A trajectory quence, we eliminate such repetition since it provides no useful information. 
A moving sequence with respect to a time constraint max_gap is defined as an or-2  X  i  X  m . A sequence is composed of k areas is denoted as k-pattern. sequence of another sequence s 2 is there exists a one-to-one order preserving function t . The user-specified minimum support ( min_sup ) is the lowest value that each sequence tern . A frequent sequence is maximal if it is not a subsequence of any other sequences The Problem Definition: Given a moving object database D , a reference plane P  X  R 2 , discover all frequent moving patterns in D satisfying min_sup. This section successively describes the processes of discovering all frequent spatio-temporal patterns and maximal frequent patterns in detail. 4.1 The Algorithm All_MOP database is arranged by object identifier oid as the primary key and effective time t as the assistant key. As mentioned previously, for a given grid threshold grid_thres the spatial reference plane P is decomposed array of equal-sized cells. Every trajectory is ously mentioned. 
Only when the time between two locations stay within the time constraint max_gap can a sequence be produced. The moving object database D is transformed into a database in the form of a set of data-sequences. This operation is handled by the func-tion MovingSequenceExtraction (). 
The algorithm All_ MOP () shown in the fig.1 discovers moving patterns based on the GSP algorithm with respect to the way of generating candidates and frequent minimal infrequent patterns in memory MinInfreqList . Initially, MinInfreqList con-tains all infrequent 2-patterns. When a new candidate pattern P is generated, check if it is a superpattern of any of the patterns in this list. Function All_MOP() Method: 
Discovering all frequent patterns become a big challenge when the length of pat-introduce the second algorithm in the next subsection. 4.2 The Algorithm Max_MOP Max_MOP described in fig.2 mines only maximal frequent patterns. The data struc-keeping candidate patterns CandList . Principally, we use the same way to generate candidate patterns described in All_MOP. MaxFreqList is initialized with all frequent 2-patterns. Compare with DFS_MINE generating candidate patterns in Max_MOP limits the number of candidates. Function Max_MOP() Method: To carry out performance studies we implemented All_MOP, Max_MOP and DFS_MINE [8] in C++. The experiments were performed on a PC Pentium IV, 2.00GHz processor with 256MB RAM, and window XP. The experiments were carried The parameters used for synthetic database generation are shown in the below table. 
Datasets are generated by the following principle: on average 70% object trajecto-ries have the maximal length L in which average 30% trajectories have the same trip. changed from L -1 to L +10. Dataset D500_L10 means 500 trajectories and an average size of their maximal length of 10. 
Figures from fig.3 to fig.6 show the runtime behavior for different datasets by fix-ing the number of objects and changing the maximal lengths or vice verse according to different min_sup values. The results show that for constant database size, the exe-cution time of All_MOP and Max_MOP gradually increases with the changes of trajectory length (fig.4). Also, the similar results are for the changes of database size with the same maximal length L (fig.3). We can observe that the increase of the num-ber of frequent patterns along the decreasingly changing values of min_sup , that leads to the execution time changes increasingly. Figure 6 depicts a comparison of Max_MOP and DFS_MINE. It is clear that our algorithm is less time-consuming than DFS_MINE. The reason is explained in the previous sections that the number of gen-the case of patterns with short length All_MOP seems to be more efficient with re-spect to time spending on discovery. However, for long patterns Max_MOP is more superior with regard to storage space. In this paper, we offered two algorithms All_MOP and Max_MOP for mining all frequent moving patterns and only maximal moving pattern in mobile environment respectively. Patterns are yielded based on spatiotemporal distances of moving ob-into areas. The moving object database is preprocessed using a clustering method. Finally, All_MOP enumerates all frequent sequences. Also, we described the second method to mine only maximal frequent patters. We conducted an experiment to study their performance and also compared with the typical technique DFS_MINE. From LBS applications. 
We are implementing a moving patterns discovery prototype with visualized inter-face, generating rules applied in queries. 
