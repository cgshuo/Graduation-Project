 The rap i d growth of the w i reless commun i cat i ons techn i ques such as global pos i t i on i ng systems and locat i on determ i nat i on techn i que have opened up var i ous locat i on based serv i ces . Locat i on-based serv i ces support useful and conven i ent serv i ces based on the are cont i nuously mov i ng and send quer i es v i a WWW or w i reless commun i cat i on . Ap-pl i cat i ons for locat i on based serv i ces must store the current locat i on of the large number of mov i ng user and process the locat i on based query i n real-t i me manner [13, 14] .
 Trad i t i onal R-tree structure [4] may be used to i ndex mov i ng ob j ects . However, Use of trad i t i onal R-tree structure cannot prov i de the real-t i me response s i nce the query process i ng i s frequently blocked by node-spl i t or reg i on propagat i on as the locat i ons of ob j ects change . Dur i ng the last decade a number of i ndex methods, wh i ch mod i f i ed the bas i c structure of R-Tree, have been proposed to max i m i ze concurrent eff i c i ency of updat i ng and query i ng, such as Rl i nk-Tree [6], CG i ST[7], and [2],[9],[12] . They have tr i ed to i mprove the query performance by m i n i mally us i ng the lock or by l i nk i ng the s i bl i ng nodes l i ke i n Rl i nk-tree . In h i ghly concurrent env i -ronments, those i ndex methods are not su i table for i ndex i ng mov i ng ob j ects s i nce the query process i ng should be blocked even though they have tr i ed to i mprove the query performance .

Th i s paper proposes the i mproved concurrency control techn i que w i th lock-free query i ng by us i ng the new vers i on i ng techn i que . It i s called as "the i nstant vers i on i ng techn i que" . It does not phys i cally mod i fy the or i g i nal data, but rather make a new vers i on for compensat i ng the data i ntactness . Unl i ke the trad i t i onal vers i on i ng tech-n i que [11], th i s techn i que does not keep mult i ple vers i ons, but i t i nstantly keeps the or i g i nal data only unt i l the creat i on of new vers i on i s done . That i s, the or i g i nal data rema i ns i ntact not for further operat i ons but for operat i ons that are currently access i ng i t . The old data i s removed when no other operat i ons are access i ng i t anymore . Ac-cord i ng to the i nstant vers i on i ng techn i que, an entry or a node i s vers i oned . The pro-posed techn i que make lock-free search operat i ons by read i ng old vers i on even though s i oned data due to the data i ntactness . However the space reclamat i on does not re-qu i re heavy overhead s i nce the vers i oned entr i es are reused and the vers i oned nodes are recla i med by an i ndependent process w i thout d i sturb i ng the normal operat i ons . Exper i ments show better performance i n search operat i on at least tw i ce as fast as compared to Rl i nk-Tree .

The rema i nder of th i s paper i s organ i zed as follows . Sect i on 2 descr i bes related works and sect i on 3 descr i bes the proposed concurrency techn i que . Sect i on 4 presents cons i stency and Sect i on 5 presents exper i ments compared to Rl i nk-Tree . F i nally sec-t i on 6 makes a conclus i on . In th i s sect i on we present a problem of concurrent operat i ons i n the R-Tree . And we expla i n how the prev i ous techn i ques solve th i s problem . F i g . 1 presents the problem of wrong path .
In F i g . 1, let X  X  assume that o 1 i s search operat i on that i s wa i t i ng for acqu i r i ng lock lock on node n 2 after node-spl i t f i n i shes, i t only searches the half of n 2 s i nce the other half of n 2 has been moved to n 3 by o 2 .

The prev i ous concurrency control techn i ques are class i f i ed i nto the pess i m i st i c so-lut i on [2, 9] and the opt i m i st i c solut i on [6, 7, 12] to solve the problem of wrong path . solut i on allows the problem of wrong path but i t corrects the wrong path by apply i ng some spec i al act i on .
 The representat i ve techn i que of the pess i m i st i c solut i on i s the lock-coupl i ng [2, 9] . When descend i ng the tree a lock on a parent node can only be released after the lock on the ch i ld node i s granted, also when ascend i ng the tree (node-spl i ts or reg i on propagat i on) locks on ancestor nodes should be hold unt i l ascend i ng step i s term i -nated . Th i s techn i que decreases concurrent eff i c i ency s i nce m i n i mum of two nodes are kept locked at a t i me . The opt i m i st i c solut i on needs spec i al method to correct the wrong path and to j udge i f the v i s i t i ng node has been mod i f i ed . The representat i ve techn i que for the opt i m i st i c techn i que i s Rl i nk-Tree [6] . Rl i nk-Tree uses LSN (Log i -cal Sequence Number) to j udge i f v i s i t i ng node has been spl i t, and i t corrects the wrong path by ma i nta i n i ng the l i nk between s i bl i ng nodes . LSN i s i n charge of same roles as the max i mum key of Bl i nk-tree [10] due to the fact that R-Tree has the prop-erty that the entr i es of nodes are not l i nearly ordered . Each entry i n a non-leaf node cons i sts of a key, a po i nter, and the expected LSN that i t expects the ch i ld node to have . If the expected LSN taken from the parent node i s d i fferent from the actual LSN of ch i ld node, a process, moves r i ght v i a s i bl i ng l i nk unt i l the node hav i ng the ex-pected LSN i s found, i s carr i ed out .

Search i ng process of the prev i ous works may be blocked s i nce they requ i re the shared mode lock for retr i ev i ng the cons i stent data aga i nst update operat i ons . Th i s s i tuat i on over the lock-based techn i que cannot be avo i ded . Th i s paper proposes the vers i on-based techn i que wh i ch enables the search operat i on to progress w i thout block i ng i t . Th i s sect i on i ntroduces the mod i f i ed structure of R-Tree, called RIV-Tree, for apply-i ng the i nstant vers i on i ng techn i que, and descr i bes i nternal and external operat i ons of RIV-Tree . F i nally, th i s sect i on d i scusses the reclamat i on of garbage space due to the i nstant vers i on i ng techn i que . 3.1 Structure In order to i mplement the i nstant vers i on i ng techn i que, t i mestamp i s an adaptable i mposes search operat i ons to compare t i mestamps of them w i th that of garbage ver-s i ons . Moreover, when spl i tt i ng a node i t needs a complex mechan i sm to d i str i bute entr i es s i nce i t cannot dec i de eas i ly wh i ch entr i es are the latest vers i ons . So, the t i me-used . It i s not for sort i ng entr i es, but i t i s for prevent i ng operat i ons from access i ng old vers i ons . Bas i cally, RIV-Tree has a standard structure of R-Tree, but the trad i t i onal R-Tree structure i s extended for i mplement i ng the i nstant vers i on i ng techn i que .
F i rst, the entry structure i s extended by add i ng two po i nters for l i nk i ng between s i bl i ng entr i es . Each entry i n a node cons i sts of a key rectangle, a po i nter to the ch i ld node or i ndexed ob j ect, a po i nter nxtActive to the next s i bl i ng act i ve entry, and a po i nter nxtFree to the next s i bl i ng free entry . Also, the node structure i s extended by add i ng two po i nters, fstActive and fstFree , for complet i ng the i nstant entry vers i on i ng . fstActive i s a po i nter that po i nts to the f i rst among the act i ve entr i es . And fstFree i s a po i nter that po i nts to the f i rst among the unused entry . Search operat i ons f i rstly take fstActive , and then they move r i ght v i a nxtActive . They v i s i t only the latest entr i es s i nce there are only the latest entr i es i n the act i ve l i nk . And update operat i ons take new entry from fstFree .

Second, the node structure does not need add i t i onal po i nters for apply i ng the i n-stant node vers i on i ng techn i que s i nce nodes i n the tree are already l i nked between cord i ng to the i nstant node vers i on i ng . A node i s i nstantly vers i oned only when i t i s unl i ke the trad i t i onal spl i tt i ng (that only creates one new node), then entr i es of n 2 are f i nally the po i nters of n 3 and n 4 are i nserted to n 1 . Th i s techn i que does not cause any mod i f i cat i on on the spl i tt i ng node n 2 , so that the search operat i ons can traverse sub-tree of n 2 w i thout any lock i ng and latch i ng . However, i f i nsert operat i on i s wa i t i ng for acqu i r i ng lock on n 2 , i t may i nsert a new key to the wrong node n 2 (vers i oned node) . Th i s i s the problem of wrong path as ment i oned above i n the related works . In order to solve th i s problem, the bas i c node structure of RIV-Tree i s extended as descr i bed i n the follow i ng paragraph .

Th i rd, two po i nters p 1 , p 2 and a vers i on b i t v are added to the bas i c node structure of RIV-Tree . The var i ables are used to solve the problem of wrong path . That i s, operat i ons check v to detect the fact that the node has been spl i t, and use p 1 , p 2 to correct the wrong path . v i s marked dur i ng the spl i t process, and i t i nd i cates the fact that the node i s vers i oned . If a vers i on b i t v of v i s i t i ng node i s true, update operat i ons can j udge that the node has been spl i t by another operat i on wh i le they were wa i t i ng . p , p 2 are po i nters that po i nt to the two new nodes der i ved from the or i g i nal node .
If the v i s i t i ng node i s a vers i oned node, a process moves r i ght v i a vers i on po i nters unt i l meet i ng the latest nodes . F i g . 5 presents the scenar i o to correct the wrong path . The update operat i on conf i rms the fact that n 2 has been vers i oned by check i ng the These po i nters may po i nt to another vers i oned node s i nce the non-vers i oned node that was der i ved from vers i oned node can st i ll be vers i oned aga i n by subsequent spl i ts, but cont i nued mov i ng v i a vers i on po i nters can guarantee that non-vers i oned nodes (latest nodes) are found .

Th i s techn i que requ i res add i t i onal work to recla i m the vers i oned node or the ver-s i oned entry that does not need to be accessed any more . The deta i ls are d i scussed i n subsect i on 3 . 4 . 3.2 Internal Operat i ons RIV-tree has four i nternal operat i ons, such as i nsert i on, delet i on, mod i f i cat i on of entry, and search operat i on . They are l i m i ted to a node .

Insert i on and delet i on of entry are very s i mple . A new entry, allocated from the free l i nk, i s appended to the end of the act i ve l i nk . It i s l i nked only after i t becomes cons i s-tent . If i t does not, search operat i ons may access the i ncons i stent entry . Delet i on of entry i s done by unl i nk i ng from the act i ve l i nk . In F i g . 6 (b), an entry e 2 i s deleted by l i nk of e 2 should not be cut because of search operat i ons that are access i ng e 2 . If i t i s cut, they cannot move to the next act i ve entry, e 3 . The deleted entr i es are reused by further operat i on . It should carefully be reused because of search operat i ons that are st i ll access i ng i t . In order to s i mpl i fy the procedure of i nternal operat i ons, th i s i ssue i s d i scussed i n subsect i on 3 . 4 .

Entry mod i f i cat i on i s a comb i nat i on of the i nsert i on and delet i on of entry . It should be atom i cally done s i nce search operat i ons could access both entr i es, the or i g i nal entry and the entry der i ved from the or i g i nal entry . F i g 6 (c) descr i bes mod i f i cat i on of the entry e 2 . The entry e 2 i s atom i cally mod i f i ed by ass i gn i ng the nxtActive of e 1 to e 4 . Espec i ally, when spl i tt i ng a node accord i ng to the i nstant node vers i on i ng, entry also done i n the same manner .

Internal search operat i ons v i s i t entr i es by tak i ng nxtActive . They do not requ i re any lock i ng and latch i ng due to the atom i c l i nk i ng of update i nternal operat i ons . 3.3 External Operat i ons Th i s subsect i on descr i bes external operat i ons such as search and i nsert operat i on . These operat i ons are i nteract i vely i nvoked by the external component above the i n-dex, such as  X  cursor  X . In th i s subsect i on, delete operat i on i s not descr i bed s i nce i t i s a comb i nat i on of the search and i nsert operat i on . Delet i on of empty node i s d i scussed i n subsect i on 3 . 4 . 3.3.1 The Search Operat i on Search operat i on f i nds all entr i es that belong i n the range of query cond i t i on . Search-i ng starts by push i ng the root node po i nter to the stack . The stack i s used to remember po i nters of nodes or ob j ects that need to be tested . The root node po i nter w i ll be the voked search operat i on . In next t i me, findNext procedure i s i nvoked w i th the returned empty . 3.3.2 The Insert Operat i on The i nsert operat i on progresses i n three steps . The f i rst step i s the descend i ng step . Th i s step f i nds the opt i mal leaf node that i s f i t to i nsert the new key by mov i ng down the tree . The second step i nserts the new key to the found leaf node, and the last step i s the ascend i ng step . It moves up the tree to mod i fy the ancestor nodes i n two cases: when the reg i on of node has changed or a node should be spl i t due to the lack of space .
When descend i ng the tree the v i s i ted nodes are pushed to the stack . Its saved path w i ll be used i n the further ascend i ng step . When descend i ng the tree, the vers i oned node i s maybe found s i nce the i nsert operat i on does not use lock-coupl i ng to he i ghten concurrent execut i on . That i s, the ch i ld node could be spl i t by another i nsert operat i on after tak i ng the ch i ld node po i nter from i ts parent node . In th i s case, the non-vers i oned nodes can be found by mov i ng r i ght v i a the vers i on po i nters . The vers i on po i nters po i nts to each der i ved nodes that have been created due to node-spl i t, so that all nodes der i ved from the or i g i nal node can be v i s i ted by mov i ng r i ght . Before a process moves r i ght, the pushed node i s popped as shown i n F i g . 8 (l i ne 29) . If a process f i nds non-vers i oned node lead i ng to geometr i cally opt i mal node, i t i s pushed to the stack . F i nally, only non-vers i oned nodes are i n turn pushed to the stack, and i f a process reaches to a leaf node, i t returns .
If there i s space to i nsert the new key to the found leaf node, a new key i s s i mply i nserted . If reg i on of the node i s changed due to the key i nsert i on, the reg i on propaga-t i on occurs to reflect th i s change to the parent node . The reg i on propagat i on moves up the tree unt i l the reg i on of ancestor nodes do not need to be changed any more . It may meet a vers i oned node dur i ng the reg i on propagat i on . However, th i s case i s l i ttle d i f-ferent to the wrong path correct i on of the descend i ng step . The descend i ng step f i xes the path by f i nd i ng a geometr i cally opt i mal node among all non-vers i oned nodes that have been der i ved from the vers i oned node . That i s, all non-vers i oned nodes der i ved from the vers i oned node should be v i s i ted . But the ascend i ng step only moves r i ght v i a vers i on po i nters unt i l the non-vers i oned node, that conta i ns the po i nter to the correspond i ng ch i ld node, i s found .

A node i s spl i t i f there i s no space to i nsert the new key to the leaf node . Unl i ke the trad i t i onal node-spl i t, the spl i tt i ng process does not phys i cally mod i fy the spl i tt i ng node, but rather marks i t as  X  vers i oned  X  , then two other nodes are created for com-pensat i ng i ts i ntactness . F i nally, the po i nters of newly created two nodes are reflected on parent node . If there i s no space to i nsert them i n the parent node, the spl i t process moves up to i ts parent node aga i n . 3.4 Space Reclamat i on Accord i ng to the i nstant vers i on i ng techn i que, the garbage space, such as vers i oned entr i es and vers i oned nodes, i s essent i ally created . Th i s subsect i on d i scusses how to recla i m garbage space and who collects i t .

The garbage space i s recla i med only when no other operat i ons access i t anymore, so that the reclamat i on needs the s i mple compar i son between t i mestamp of garbage space and those of currently act i ve operat i ons . That i s, i f t i mestamp of garbage space i s smaller or equal to the smallest one among those of act i ve operat i ons, i t can be recla i med . In order to i mplement the t i mestamp, a log i cal vers i on number i s used .
The vers i oned entr i es are not returned to system, but they are reused by i nternal update operat i ons . Each node keeps a log i cal entry vers i on number ( levn ) i n the i r header sect i on . When vers i on i ng an entry, levn i s i ncreased and the new value i s as-s i gned to the vers i oned entry . The i nternal operat i ons memor i ze levn before they v i s i t the node . If levn of the vers i oned entry i s smaller or equal to the smallest one among the i nternal operat i ons that are currently v i s i t i ng the node, the vers i oned entry can be reused .

The reclamat i on of vers i oned nodes i s s i m i lar to that of vers i oned entr i es . That i s, tree globally keeps another log i cal vers i on number, a log i cal node vers i on number ( lnvn ), and the external operat i ons memor i ze lnvn before they start . When vers i on i ng a node, lnvn i s i ncreased and the new value i s i nserted i nto the collector queue w i th the node . Garbage collector i s act i vated on a regular bas i s, and pops a node from the queue . If lnvn of the popped node i s smaller or equal to the smallest one among the act i ve external operat i ons, i t i s returned to system .

Actually, the space reclamat i on does not requ i re heavy overhead s i nce the ver-s i oned entr i es are reused and the vers i oned nodes are recla i med by an i ndependent process w i thout d i sturb i ng the normal operat i ons . Th i s sect i on d i scusses the phantom problem that i s a common requ i rement of data-base systems . It i s d i ff i cult to avo i d the phantom problem by i ndex i tself . One s i mple way to avo i d the phantom problem i s to hold the lock on every node (leaf nodes and non-leaf nodes) that search operat i ons v i s i t unt i l transact i on f i n i shes . But i n th i s way, the concurrent execut i on i s severely decreased . Rl i nk-Tree i ntroduces a s i mpl i f i ed form of pred i cate locks [3], where exclus i ve pred i cates cons i st of a s i ngle rectangle and shared pred i cates cons i st of query range . Insert operat i ons check shared pred i -cates w i th the i r s i ngle rectangle, and i f they confl i ct, they suspend unt i l the confl i cted shared pred i cate i s released . The ma i n advantage of the pred i cate lock i ng i s to i solate the concurrency techn i que on i ndex from the phantom problem . That i s, when an operat i on i s passed the pred i cate lock i ng manager, i t can freely access any nodes on the tree w i thout cons i der i ng the phantom problem . The pred i cate lock i ng could be employed w i th RIV-Tree . However, i t does not ut i l i ze the advantage of th i s paper, non-block i ng search operat i on, s i nce search operat i ons could be blocked before enter-i ng to the i ndex by the pred i cate lock i ng .

A more effect i ve solut i on for RIV-Tree i s to cooperate w i th the mult i -vers i on re-cord manager . Read transact i on gets a cand i date ob j ect qual i fy i ng the i r search cond i -t i on from the i ndex, and then the cand i date ob j ect i s compared w i th mult i ple vers i ons i n record manager . If the t i mestamp of the cand i date ob j ect i s greater than that of read transact i on, i t i s i gnored s i nce the cand i date ob j ect has been created after read transac-t i on has i nstalled, and the next cand i date ob j ect i s got from the i ndex . Th i s approach needs to cons i der a delete operat i on on i ndex . If a key i s deleted after search operat i on scan the tree, the number of ob j ects got from rescan operat i on i s maybe smaller than that of prev i ous scan . So, the key delet i on i s not done by the currently delete transac-t i on, but i t i s lately done by a garbage record collector l i ke  X  ager  X  i n [5] . The ager i s an i ndependent process that recla i ms garbage records . When recla i m i ng the garbage records the correspond i ng keys are deleted from the i ndex . Th i s sect i on proves the excellence of th i s techn i que through compar i son to Rl i nk-Tree . It expla i ns exper i mental env i ronment, and est i mates the proposed techn i que by i ncreas i ng i nsert and search process . 5.1 Exper i mental Env i ronment Rl i nk-Tree and RIV-Tree were i mplemented i n C under GMS [10] wh i ch i s a spat i al database management system . GMS run on Solar i s equ i pped w i th 8 CPUs of 1 . 2GHz and ma i n memory of 1G bytes .

The s i ze of node i s 4K . The fan-out of non-leaf node and leaf node i s each 98 and 81 for Rl i nk-Tree, 89 and 75 for RIV-Tree . Th i s exper i ment does not cons i der the phantom problem s i nce Rl i nk-Tree does not ment i on i n deta i l . And the quadrat i c spl i t algor i thm i s appl i ed to both i ndexes .

In i t i ally, the data sets w i th 10000 rectangles (10 X 10 s i ze) were preloaded i n the 20000 X 20000 area . It was equally d i str i buted i n total doma i n area . In actual exper i -ments, each i nsert process i nserts ob j ects w i th s i ze of 10x10 randomly extracted from total area i nto the tree . Also, each search process searches w i th s i ze of 2000x2000 (1% of ent i re area) randomly extracted . The response t i me and throughput of search and i nsert operat i on i s est i mated by dynam i cally i ncreas i ng the number of i nsert and search process . 5.2 Exper i mental Results F i g . 10 and F i g . 11 are the results of est i mat i ng response t i mes and throughputs by i ncreas i ng number of i nsert processes to measure i nsert-workload . It shows that RIV-Tree has sl i ghtly bad performance even though i t tr i es to i mprove the concurrent eff i -c i ency of the update operat i ons . Th i s i s due to the fact that RIV-Tree i s more spl i t than Rl i nk-Tree s i nce the fan-out of RIV-Tree i s smaller than Rl i nk-Tree . That i s, the overhead caused by correct i on of wrong path or block i ng due to node-spl i t, i s i n-creased .

F i g . 12, F i g . 13, F i g . 14, and F i g . 15 are the results of est i mat i ng average re-sponse t i mes and throughput of search operat i ons by i ncreas i ng search operat i ons under the low-content i on (4 i nsert processes) and h i gh-content i on (20 i nsert proc-esses) . RIV-Tree i s show i ng better performance than Rl i nk-Tree under the low-content i on as shown i n F i g . 12 and F i g . 13 . Th i s i s due to the fact that search opera-t i ons of RIV-Tree traverse the tree w i thout any lock i ng . In contrast, those of Rl i nk-Tree are blocked by concurrent i nsert operat i ons . The d i fference i n performance of both i ndexes i s more severe under the h i gh-content i on . Rl i nk-Tree performs poorly as content i on i s i ncreased . Not i ce that response t i mes of RIV-Tree ach i eve nearly s i m i lar results i n two cases, low-content i on and h i gh-content i on . Consequently, response t i mes of RIV-Tree i s shown w i th i n expected t i me even though the conten-t i on i s i ncreased s i nce search operat i ons of RIV-Tree are not requ i re any lock i ng or latch i ng .
 Th i s paper has des i gned the mod i f i ed R-Tree structure w i th lock-free query i ng, and i mplements i t on ex i st i ng spat i al database management system . In order to ach i eve the goal, the i nstant vers i on i ng techn i que i s i ntroduced . Th i s techn i que has not phys i cally mod i f i ed data, but rather new vers i on has been created for compensat i ng data i ntact-ness . Search operat i on could access data w i thout any lock i ng or latch i ng by read i ng old vers i on . Th i s approach has made garbage data due to compensat i ng act i on, but the reclamat i on task has not confl i cted w i th the normal operat i on of i ndex s i nce i t has been executed by an i ndependent process . Exper i ments have showed better perform-ance i n search operat i on at least tw i ce as fast as compared to Rl i nk-Tree .

The further work for th i s paper i s the study of recovery . The reclamat i on of gar-bage nodes are executed i ndependently of transact i ons . If system i s crashed after creat i on of garbage node, i t i s never returned to system even though transact i on has comm i tted .

