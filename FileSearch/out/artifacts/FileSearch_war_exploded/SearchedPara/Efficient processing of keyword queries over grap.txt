 1. Introduction
Recently, graph-structured data are widely used in many applications such as XML, bio-informatics, semantic web, ontol-ogies, and social networking services. Keyword-based query over graph-structured databases has been attracting much attention since it enables users to represent their information need using only a set of keyword terms, instead of using a word-based query processing has also been studied extensively in the literature of relational databases, where relational data can be modeled as a directed graph of tuples based on the foreign-key relationships among tuples ( Agrawal, Chaudhuri, &amp; Das, 2002; Baid, Rae, Li, Doan, &amp; Naughton, 2010; Balmin, Hristidis, &amp; Papakonstantinou, 2004;  X 
Keyword-based search on a graph-structured database usually returns a set of connected structures derived from the database, which represent how the data containing query keywords are interconnected in the database. In most approaches, a sub-tree of the graph is used to describe an answer to a given query. Since there can be a significant number of answer structures in a large graph database, a relevance scoring function is often used to rank the candidate answers and return top-k ones most relevant to the query.

The problem of answering keyword-based queries over graph-structured databases is described as follows. Let G =( V , E ) be a directed graph representing a graph-structured database, where each node is labeled with some text. The nodes and edges in G may have weights on them. Given a keyword query Q over G consisting of a set of keywords, denoted by keyword nodes. Given a relevance scoring function rel ( T ), which maps an answer sub-tree T to a numeric score value mea-
To evaluate and rank the answer sub-trees, various scoring functions have been proposed in the literature based on dif-ferent semantics, which will be described in Section 2 . In this paper, we adopt distinct root-based semantics, where the weight of a sub-tree is computed as the sum of the shortest distance from the root to each keyword node and at most 2005 ). This approach can deal with top-k query processing over very large graph databases more efficiently than the other approaches based on Steiner tree-based semantics. It also enables effective indexing on the graph ( He et al., 2007 ). cated in the figure, nodes K , L , M , O , and R are keyword nodes containing keyword volcano and nodes S and U are keyword tics, only one among the sub-trees T B 1 , T B 2 , and T B the previous approaches, only sub-trees including exactly one keyword node for each query keyword, such as T and T D 1 , have been considered candidate answer trees. However, we consider that sub-trees which have more than one key-word node for each query keyword, such as T B and T C , also can be possible answers to Q .

The main contributions of our work are as follows:
To produce more effective and relevant search result for a given query, we propose an extended structure of answer trees and a new relevance metric and ranking mechanism for the answer trees. Different from the existing approaches, the pro-posed answer structure has no such constraint that it should include one and only one keyword node for each keyword in the query. That is, an answer tree is allowed to contain a part of query keywords and to have more than one node con-taining the same keyword, and based on the new measure of relevance, more extended and relevant answers can be generated.

For efficient finding of top-k answers in the proposed structure, we design an inverted list-style index to the keywords and nodes in the graph, which stores information on the connectivity and relevance of a node to each keyword term. Then we present a basic query processing algorithm which exploits the pre-constructed inverted lists to aggregate most rele-vant keyword nodes for each candidate answer tree with a distinct root and find top-k answer trees most relevant to the given query.

Aiming at improving the efficiency of the basic approach, we extended the above inverted list index to store at each entry additional relevance information of another entry related in the same list. We also introduce a relevance lookup table which pre-computes and stores the largest relevance value of each node to each keyword term in the graph. Then we present an enhanced search algorithm based on the extended inverted list and the relevance lookup table. It estimates the worst and best relevance scores of a node more closely to its actual score and thus can find top-k answer trees rooted at different nodes more efficiently than the basic approach.

The rest of the paper is organized as follows. Section 2 presents related work and motivation of our study. Section 3 defines a new answer structure and relevance measure for keyword queries over graph databases. In Section 4 , we propose an inverted list index for keywords and nodes in the graph and a top-k query processing algorithm using the index. In Sec-tion 5 , we improve the proposed indexing scheme and present a more efficient search method. We provide experimental results on the effectiveness and performance of the proposed method in Section 6 and draw a conclusion in Section 7 . 2. Related work and motivation
There has been much work on keyword search over relational databases ( Agrawal et al., 2002; Baid et al., 2010; Balmin et al., 2003; Li et al., 2009; Liu et al., 2006; Luo et al., 2007; Qin, Yu, Chang, 2009; Qin, Yu, Chang, Tao, 2009 ). Many approaches, however, use underlying schema information to generate candidate expressions on the schema graph and then schema-agnostic and materialize a relational database as a graph, and thus they can be applied to any graph-structured data ( Bhalotia et al., 2002; Ding et al., 2007; Li et al., 2009; Qin, Yu, Chang, Tao, 2009 ).

Most of the studies on keyword-based search over graph databases find minimal connected sub-trees as succinct answers large volume of graph data.

To evaluate and rank sub-trees satisfying answer conditions, weight functions have been proposed in the literature based
The Steiner tree-based semantics defines weight of an answer tree as the total weight of the edges in the tree. Under this semantics, finding an answer tree with the smallest weight is a well-known optimal group Steiner tree problem, which is for small-sized queries efficiently ( Ding et al., 2007 ). Another work presented an algorithm to enumerate answers in a 2-approximate order by height with polynomial delay ( Golenberg et al., 2008 ). Li et al. (2009) proposed a polynomial time approximate solution for answering top-k queries over relational databases based on Compact Steiner Tree structure and the capabilities of relational DBMS. Those methods, however, cannot produce top-k Steiner tree-structured answers efficiently over large-scale graph databases.

As an alternative to the Steiner tree semantics, other approaches adopted easier semantics, namely distinct root seman-the graph, only a single sub-tree which has a minimal weight among those rooted at the node is considered a candidate answer to the query. The weight of a sub-tree is defined as the sum of the shortest distances from the root to the keyword nodes chosen for each query keyword. Under this semantics, given a graph having n nodes, there can be at most n answer trees and thus we can deal with queries over very large graph databases more efficiently than under the Steiner tree seman-expand during the bi-directional search while it does not take advantage of any prior knowledge on the connectivity between nodes in the graph. Thus it may lead to poor performance on certain complex graphs. In BLINKS approach ( He et al., 2007 ), indexing schemes and query processing algorithms were proposed to speed up the bi-directional exploration of the graph with a good performance guarantee. A single-level index consisting of sorted keyword-node lists and a node-keyword map pre-computes and indexes all the shortest paths and distances from nodes to keywords in the graph.
By accessing the sorted lists of nodes relevant to the given keywords in parallel and exploiting the node-keyword map, the search method of BLINKS performs backward and forward expansions efficiently and finds top-k answers in a time and space efficient manner. To reduce index space for large graph, they also suggested graph partitioning strategies and a bi-level indexing scheme. Dalvi et al. (2008) considered the issue of keyword search on graphs that are larger than main memory. They proposed to create and exploit a multi-granular representation of graph data to minimize I/O by directing search toward limited areas of the graph resident in memory. They suggested two approaches to extending existing search graphs. As described in the paper, any in-memory graph search algorithm can be used in their approach. Thus, their strategy structure and indexing scheme.

The previous approaches including those mentioned above have a common constraint on the answer structure employed: it should have one and only one keyword node for every keyword in the query. In Fig. 1 , for example, sub-tree T volcano and are reachable from node B , but an answer tree rooted at node B should have only one of them in the previous approaches. Moreover, the distinct root semantics allows at most one answer tree rooted at a certain node hence another candidate answer tree T B 2 rooted at node B cannot be returned with T other candidate answer trees, such as sub-tree T C 1 rooted at C and containing { O , U } as keyword nodes and sub-tree T puted as the sum of the shortest distance from the root to each keyword node selected, answer trees T weight, and thus lower relevance score, than answer tree T evance score as T D 1 since they have the same distances from the root to the keyword nodes in them. However, we observe that node B has connections to more nodes containing query keywords than node C or D have, and we consider that we can obtain a more relevant answer by including more paths from B to the keyword nodes in a single sub-tree rooted at B .
To improve the quality of query result based on the consideration, we propose a new answer structure which has no con-straint on the number of keyword nodes chosen for each query keyword, so that an answer tree can have more than one keyword node for some keywords while it may include no keyword node for other keywords. To restrict an answer tree to an acceptable size, we limit the number of pairs of a keyword and keyword node for it in an answer tree. For instance, allowing maximum 4 pairs of a keyword and keyword node to be included in an answer tree for the query in Fig. 1 , we have a new candidate answer tree T B which is extended from the conventional answer trees T nodes M in addition to K and L for volcano , as shown in Fig. 1 (b). A sub-tree T propose an effective relevance measure for the candidate answer trees in Section 3 . According to the metric, T more relevant to the query than T C or T D 1 in our approach. 3. Answer trees and relevance measure in K contained in a specific node in the graph. When a node contains a keyword term, the relevance of the node to the key-which contains k , i.e., a keyword node for k . Its relevance is formally defined as follows.
 defined by node s is defined by rel  X  n ; s ; k  X  X  rel 2  X  n ; s  X  rel that if n and s denote the same node, rel ( n , s , k ) equals to the relevance of s to k , i.e., rel the query is defined based on rel ( n , s , k ) as follows.

Definition 2 ( Answer tree for a query ). Given a keyword query of size l , Q ={ k in s is in the p highest over all the pairs of a node in V ( Q ) and a keyword in Q . Formally, where ties in relevance are broken at random. Let S ( n, Q ) be the set of keyword nodes in Top
S ( n , Q )={ s |( s , k ) 2 Top p ( n , Q )}. An answer tree for query Q rooted at node n , denoted by T of the nodes and edges on the shortest path from n to each node in S ( n, Q ). Formally, where V n ? s and E n ? s are respectively a set of nodes and a set of edges on the shortest path from n to s .
Note that based on the distinct root semantics, our approach finds at most one answer tree T graph. It is derived from at most p pairs of a query keyword k and a keyword node s for k to which its root node n is most relevant. For ranking candidate answer trees with different root nodes, we propose a relevance measure for them as follows.
Definition 3 ( Relevance measure for answer trees ). Given an answer tree T
Q , denoted by rel ( T n , Q ), is the sum of the relevance of n to k contained in s for all pairs of ( s , k )in Top
Definition 2, i.e., { K , L , M , O , R , S , U }. Assuming that p = 4, we have Top rooted at nodes B and C , respectively, can be derived from the graph as shown in Fig. 1 (b). Supposing that the relevance rel 1 ( s , k ) of keyword node s to each keyword k in Q are the same as 1, rel  X  T rel  X  T C ; Q  X  X  1 4  X  1 5  X  1 3  X  1 3  X  1 : 12 based on Definition 3 hence answer tree T 4. Basic strategy
In this section, we present an indexing scheme and query processing algorithm to find k best answers to a given keyword query based on the answer structure and relevance measure defined in the previous section. 4.1. Indexing scheme
To enable efficient search of top-k answer trees in a graph database, we suggest an inverted list-style index which pre-computes and stores information on the relevant nodes for each keyword term in the database. We first find all keyword nodes and relevant nodes for each keyword term in the graph, pre-compute relevances of the nodes to the keyword as defined in Definition 1, and then build an inverted list per keyword which can be formally defined as follows. where n i 2 V  X  G  X  ; s i 2 S  X  k  X  ; r i  X  rel  X  n i ; s proposed inverted list is different from the conventional one used for ranked search over documents or multi-dimensional which stores a keyword node in the shortest distance from n . In order to compute the amount of relevance of a node to the keywords in a given query, we should aggregate a set of the most relevant entries of the same node in the inverted lists in the following section. 4.2. Query processing algorithm
Our query processing model is based on the threshold algorithm ( Fagin et al., 2003; G X ntzer et al., 2001 ), which is pop-
Majumdar, Schenkel, Theobald, &amp; Weikum, 2006; Bruno et al., 2002; Theobald, Weikum, &amp; Schenkel, 2004 ). It performs sequential scans on the pre-computed index lists which are sorted in descending order of per-attribute scores of data and searches for top-k data items having the highest total scores aggregated from the index lists.
 k manner. During the scans, it maintains the relevance values of the entries at the current scan position in each list L ( k denoted by curScore i (1 6 i 6 l ). The largest one among those is called maxCurScore , i.e. maxCurScore  X  max bound for the relevances of the entries which have not been read yet from the lists in L ( Q ).

While reading the lists, the query processor also maintains a priority queue per a root node n of a candidate answer tree, called a relevance queue of n and denoted by q n . It stores at most p entries of n which have the highest relevance values among the entries of n retrieved from the lists. From an entry ( n , s , r ), only the pair of s and r is stored in q the current top-p relevance values of n found from the lists, the sum of the current values in q follows:
On the other hand, the best score of n can be calculated using the relevances in q the relevance values in q n that are greater than or equal to maxCurScore , i.e. R values in R n belong to the p highest of all the entries of n in the lists while the other relevance values in q of n are the same as maxCurScore , an upper bound of the relevance rel ( T follows: bestScore ( n ) decreases monotonically during the list scan. When the relevance queue q
Example 2. Given a graph G and a keyword query Q ={ k 1 , k
Assuming that scanning of the lists has proceeded to the entries denoted by rectangles, curScore the lists, i.e. q n =[( s 1 , 4.0), ( s 2 , 3.5), ( s 4 , 3.0), ( s than or equal to maxCurScore is {4.0, 3.5, 3.0}. Consequently, based on Eqs. (1) and (2) , we have worstScore ( n )= and bestScore ( n )= P r 2 R As scanning the lists in L ( Q ), we can find the nodes which are roots of top-k answer trees using two priority queues: Top -k queue T stores at most k nodes with the highest worst scores over the nodes that have been found from the lists.
The nodes in T are sorted by their worst scores in a descending order. The minimum (i.e., rank-k ) worst score value from the current top -k nodes in T is called min-k , i.e.,
Whenever the worst and best scores of a node change as a new entry of the node is read from a list, we check if the node can be entered into top-k queue T or it should be maintained in candidate queue C . Query processing can terminate safely with the correct top-k relevant nodes in T when the maximum best score in C as well as the best score of any node n rently unseen from the lists is no higher than min-k , i.e., when tree T n rooted at n is constructed by merging the nodes and edges in the shortest paths from n to each keyword node in q
Fig. 3 shows a pseudo-code algorithm of the basic query processing scheme described above. At each step of reading an 7). In Line 8 10, the current entry is inserted into relevance queue q relevance queues (Line 22 and 26).

In our method, the worst and best scores of the nodes in top-k queue or candidate queue may change as the list scan pro-ceeds since they depend on maxCurScore determined from the entries at the current scan position of each list. However, a na X ve approach to re-calculating the worst and best scores of all the nodes in the queues and to conducting re-organization shown in Line 23, procedure updateQueues is invoked periodically, which performs rebuilding of top-k queue and candidate queue based on maxCurScore (Refer to the pseudo-code of the procedure in Fig. 3 ). 5. Enhanced approach
In the basic method described in Section 4 , the worst score and best score of each node n are estimated assuming that all the unknown relevances of the entries of n unseen from the inverted lists are equal to the largest of the relevances of the relevance of an entry of n unseen from a list L ( k i ) can be much smaller than curScore we propose an enhanced search algorithm which can compute a narrower range of relevance score for each node in the graph and identify top -k answer trees for a given query earlier than the basic query processing algorithm. 5.1. Extended inverted list and relevance lookup table For more efficient processing of a keyword query, we extend the index structure defined in Definition 4 as follows. which contain k . For a node n in V ( G ), let L ( n , k ) be an ordered list of quadruples ( n , s in S ( k ) and sorted in a non-increasing order of r i , the relevance of n to k contained in s where s i 2 S  X  k  X  ; r i  X  rel  X  n ; s i ; k  X  ; r i P r
The extended inverted list for k , denoted by L 0 ( k ), is a list of quadruples merged from the lists L ( n V ( G ), which are sorted in a non-increasing order of their relevance values.
 e =( n ; s i ; r i ; r 0 i  X  of a node n is read from the list, we can see not only the relevance r r i +1 = rel ( n , s i +1 , k ), i.e. the relevance of the next entry e the first entry of each node appearing in the list for each keyword term.
 s , k ) among all keyword nodes s containing k in G . Formally, appearing in the extended inverted list for k . 5.2. Enhanced query processing algorithm set of extended inverted lists for a given query Q ={ k 1 sequentially read in a round-robin manner and the top-p relevant entries of each node n are aggregated using its relevance candidate queue C until the final top-k nodes are identified.

However, different from the basic method, the enhanced approach exploits next relevance values in the entries of the extended inverted lists, as well as the relevance lookup table, to estimate the worst and best scores of each node more exactly. When an entry of a new node n is found from a list, the relevances of the first entries of n in the other lists in
L 0 ( Q ) are also looked up from the relevance lookup table and inserted into the relevance queue q belongs to the current top-p relevance values of n . Since q the lists, the sum of those values in q n gives a lower bound for the relevance rel ( T the worst score of n is defined as
For each node n in top-k queue T and candidate queue C , the query processor maintains its next relevance value for each query keyword k i in Q , which is either retrieved from the list L 0 ( k
Score n,i , it indicates the relevance in an entry of n which will appear next in the list L 0 ( k assuming that all the unknown relevances are the same as maxNextScore the best score of n , can be computed based on maxNextScore where R 0 n is a multi-set of the relevance values in q
R including the next relevance values looked ahead, the best score of n is calculated using only the relevances greater than or equal to maxNextScore n . Since the entries in each list are stored in a descending order of relevance, nextScore and maxNextScore n monotonically decrease as entries are read from the lists. Therefore, we ensure that for each node n , worstScore ( n ) monotonically increases while bestScore ( n ) monotonically decreases during the list scan.
Example 3. Fig. 4 shows an example of computing the worst and best scores of a node n when evaluating a query Q over graph data using extended inverted lists. Suppose that graph data and the given query are the same as in Example 2 and the of n represented by nextScore n,i (1 6 i 6 4), are 2.0, 2.5, 1.0, and 1.5, respectively, and thus maxNextScore nextScore n, 4 is obtained from RT because no entry of n has been found from L 0 ( k by nextScore n,i 0 s. Thus, assuming p = 6, the next relevances of n in L 0 ( k maintained in q n instead of the second entry of n read from L 0 ( k ( s , 2.3), ( , 2.0)]. According to Eqs. (4) and (5) , we have worstScore ( n )= narrower than the range [14.5, 19.5] obtained by the basic method in Example 2.

Fig. 5 shows a pseudo-code of the enhanced query processing algorithm based on the extended inverted lists and rele-nextScore n,i is introduced to maintain the next relevance of each node n in each list L from list L i . If the entry is the first entry of n found from the lists in L 0 ( Q ), nextScore tialized by the values looked up from RT using ( n , k j ) as a search key. They are also inserted into relevance queue q in Line 15. Note that if the current entry is not the first entry of n from the list L relevance value and no keyword node for the current entry should be updated using the keyword node in the entry. Then, the and maxNextScore n , regardless of the relevance curScore Processing the current node in the top-k queue or candidate queue and checking the fulfillment of termination condition in trees can be determined much earlier than the basic method. It should be also noted that since the worst and best scores of do not have to conduct periodic update and re-organization of the queues shown in Line 23 24 in Basic query processing algorithm in Fig. 3 and thus can process queries more efficiently than the basic method. 5.3. Processing keyword queries with AND semantics
As defined earlier in Section 3 , the proposed answer structure has no such constraint that an answer tree should contain all the keyword terms in the query, and our relevance measure is to find answer trees having the keyword nodes most rel-evant to the root nodes, regardless of which query keywords are concerned. For that reason, in the query processing algo-rithm presented above, a relevance queue for each root node maintains top-p pairs of a keyword and keyword node most relevant to the root node without considering keywords. However, if a user X  X  information need underlying the given keyword
To handle keyword queries with AND semantics effectively, we modify our method to search for a restricted form of answer trees which include at least one keyword node for every keyword in the queries. Specifically, the relevance queue structure and the worst and best score metrics should be changed in the query processing scheme.
 keyword node for k which is the most relevant to n . Thus, given a query Q of l keywords with AND semantics, the keyword nodes in firstEntry ( n , k i ) 0 s for all keywords k i (1
Considering this, we store the pairs of the keyword node and relevance in firstEntry ( n , k entry of n is first retrieved from an inverted list in L ( Q ). The relevance queue q evance values in firstEntry ( n , k i ) 0 s for all k i in Q and R and
When the scanning of the lists terminates, the keyword nodes in firstEntry ( n , k answer tree rooted at node n if n belongs to top-k queue T . 6. Performance evaluation
In this section we evaluate effectiveness and efficiency of the proposed approach including basic method (BM) and enhanced method (EM-RL) by experiments using real datasets. We compare their performances with the BLINKS method ( He et al., 2007 ) which adopts distinct root semantics and inverted list-style index similar to our approach.
In the implementation of the proposed methods in Java, we use a hash table to maintain data associated with each node in the graph whose entries have been read from the inverted list index, such as a relevance queue q erence to the entry in top-k queue or candidate queue. The top -k queue and candidate queue are implemented using a Fibo-node having the smallest worst score in the queue efficiently. Meanwhile, the candidate queue stores node ID X  X  using the dition in Eq. (3) in an efficient way.

As for the test graph databases, we use Mondial 2 , IMDB 3 tively. From Mondial dataset, we built a graph which has 6,441 nodes, 25,865 edges, and 14,131 keyword terms. In IMDB data-with the movies, and derived a graph consisting of about 831 K nodes, 2.82 M edges, and 303 K keyword terms. From DBLP bib-liography database, we extracted data on papers, authors, conferences, and citations to build a graph having about 2.24 M nodes, 8.88 M edges, and 460 K keyword terms. For each dataset, we used JGraphT the shortest paths between the nodes. We extracted keyword terms from text type attributes of nodes in the graph and com-puted the relevance of a node to a keyword term in the node using Lucene word term contained in a certain node can be computed as defined in Section 3 . Based on the results, we built basic and extended inverted lists for the given graph as proposed in Sections 4 and 5 .

In the first experiment, we evaluate the precision of search results produced by our methods and BLINKS. Test queries used in the experiments are shown in Table 1 , which have been selected by the authors reflecting a variety of information needs on the test datasets. Most queries have both Boolean-AND and OR semantics in their keywords while queries Q 4, Q 5, Q 13, Q 14, Q 15, Q 22, Q 23, and Q 26 have only AND semantics among their keywords. Given a query, the precision of a set
Res  X  1 :: k of top-k answer trees returned as a search result is measured by P @ k  X  conducted by five independent adjudicators who were not aware of the considered search methods. Relevance judgment for each query. The multiple independent judgments of the assessors were integrated into the final assessment on the answer by selecting the majority opinion among them. In the experiment of our approach, parameter p was set to 1.5 times the number of keywords in the query.
 Fig. 6 shows the precisions of the top-10 and top-20 answers obtained by our approach and BLINKS for the test queries.
Note that the proposed methods, BM and EM-RL, produce the same answers to a given query. The experimental result shows 0.64 and 0.53 for top-20 query processing. It means that search effectiveness in terms of precision at top-20 answers improves by about 21% compared to the BLINKS method. We can observe that our method outperforms BLINKS for the most while BLINKS achieves higher precision than our method for many queries with AND-only semantics (specifically, in about 63% of the query evaluations). This is mainly due to the fact that our method finds sub-trees containing a set of keyword nodes chosen for any given keyword to which its root node is most relevant in the graph while the previous method such as BLINKS searches only for the sub-trees having a keyword node for each and every keyword in the query. On the other hand, Fig. 7 shows experimental results of EM-RL method optimized for the queries with AND-only semantics which was described in Section 5.3 . We can see that the adapted method, denoted by EM-RL-A, achieves precision better than or equal to that of BLINKS in the most evaluations of the queries with AND-only semantics, except in top-10 processing of Q 22 and top-20 processing of Q 15. Specifically, the average precision of the top-20 answers to the queries obtained by EM-RL-A is about 0.58, which is better than the average precisions of 0.48 and 0.46 achieved by BLINKS and BM/EM-RL, respectively.
Note that if we use EM-RL and EM-RL-A adaptively for the different kinds of test queries, we can achieve average precisions of 0.76 and 0.68 for top-10 and top-20 answers, respectively, which are about 26% higher than those of BLINKS. Thus, we observe that our approach can produce more effective answers than the previous method for keyword queries with various semantics.
 Next, we measured precision of the top-k answers obtained by our method varying the value of parameter p . As defined in
Section 3 , it denotes the number of pairs of a keyword and keyword node which are selected to derive an extended answer tree in our approach. The chart in Fig. 8 shows the average precision of the top-10 answers to the test queries on Mondial when p is 6. This implies that including more keyword nodes irrespective of keywords may results in an answer tree less relevant to the user X  X  need.

In the third experiment, we evaluate performances of the proposed search methods as well as BLINKS by measuring their execution time in processing top-k queries. We generated and executed 20 test queries, each of which has 4 keywords, on query size. Periodic updates of the priority queue T and C in BM are conducted after reading every 3,000 entries from the inverted lists. In the results shown in Fig. 9 , execution time of the proposed method EM-RL is shown to be worse than that trees having the proposed extended structure, which requires identifying p pairs of a keyword and keyword node most rel-evant to each candidate root of an answer tree. When comparing the performances of our methods, query processing time of
EM-RL is reduced, compared to that of BM, by about 56.5% for top-5 answers and 83.6% for top-30 answers on the average. As k grows from 5 to 30, average execution time of BM increases by a factor of about 3.5 while EM-RL shows relatively stable performances as its execution time increases by only about 31.9%. This indicates that enhanced method utilizing the extended indexing scheme and the relevance lookup table provides great benefits on the execution performance especially when a large number of answers should be obtained.

We also evaluated execution time of the considered methods with respect to different query sizes, i.e. the number of key-of BM increases by a factor of about 3.6 while that of EM-RL grows by about 2.9 times. Average execution time of EM-RL is reduced by about 75.4% compared to that of BM when the query size is 6. These results imply that EM-RL is scalable with query size and is much more efficient than BM for large queries.

Finally, we investigate performances of our methods with respect to parameter p used in our approach. Varying the value of p from 4 to 8, we evaluated a set of 20 test queries having 4 keywords and finding top-10 answers over IMDB dataset. of about 13.3 while it does not take two times for EM-RL. As a result, the average execution time of EM-RL is reduced by about 86.9% with respect to BM when p is 8. Thus, we consider that the enhanced search method exploiting relevance lookup is also scalable with parameter p , i.e., the number of pairs of a keyword and keyword node chosen for an answer tree. 7. Conclusion
In this paper, we propose a new ranked keyword search method for graph databases. To find more effective top-k answers to a given query, we define a new measure of relevance of a node to a keyword query and suggest an extended and flexible answer structure which may have multiple keyword nodes for a keyword in the query. For efficient top-k query processing based on the proposed answer structure and relevance measure, we design an inverted list index which stores reachability and relevance information of the nodes with respect to each keyword term. Then we present a query processing algorithm term. These techniques enable the search method to estimate a range of relevance score of a node more precisely and to find top-k answer trees more quickly than the basic method. Additionally, we proposed a query processing algorithm which can find more effective answers to the queries with AND-only semantics.

We have evaluated effectiveness and efficiency of the proposed methods by experiments using real datasets and various test queries. The result shows that precision of the top-k answers obtained by our approach is higher than that of the answers by a pervious method BLINKS for the most queries. Thus we observe that top-k answer trees based on the proposed structure and relevance measure can satisfy users X  various information needs better than conventional answer structures.
The execution performance of the proposed search algorithm is shown to be worse than the previous method, mainly due to the overhead incurred by adopting the new answer structure. However, the enhanced method based on the extended inverted list and relevance lookup table executes much more efficiently than the basic method, particularly for finding a large number of top-k results. The enhanced method is also scalable with respect to the number of keywords in the query, the number of answer trees to be found, and the number of keyword nodes included in an answer tree.
As for future work, we plan to elaborate the proposed answer structure, inverted list index, and query processing algo-rithm to enable evaluation of keyword queries and multi-word phrase queries over nodes as well as edges in the graph. We also consider exploiting the multi-granular graph representation and search strategy introduced in Dalvi et al. (2008) to improve the performance of our method.
 References
