 For any outsourcing service, privacy is a major concern. This paper focuses on outsourcing frequent itemset mining and examines the issue on how to protect privacy against the case where the attackers have precise knowledge on the sup-ports of some items. We propose a new approach referred to as k -support anonymity to protect each sensitive item with k  X  1 other items of similar support. To achieve k -support anonymity, we introduce a pseudo taxonomy tree and have the third party mine the generalized frequent itemsets un-der the corresponding generalized association rules inste ad of association rules. The pseudo taxonomy is a construct to facilitate hiding of the original items, where each origi -nal item can map to either a leaf node or an internal node in the taxonomy tree. The rationale for this approach is that with a taxonomy tree, the k nodes to satisfy the k -support anonymity may be any k nodes in the taxonomy tree with the appropriate supports. So this approach can provide more candidates for k -support anonymity with lim-ited fake items as only the leaf nodes, not the internal nodes , of the taxonomy tree need to appear in the transactions. Otherwise for the association rule mining, the k nodes to satisfy the k -support anonymity have to correspond to the leaf nodes in the taxonomy tree. This is far more restricted. The challenge is thus on how to generate the pseudo taxon-omy tree to facilitate k -support anonymity and to ensure the conservation of original frequent itemsets. The experimen tal results showed that our methods of k -support anonymity can achieve very good privacy protection with moderate storage overhead.
 H.2.8 [ Database Management ]: Database Applications X  Data Mining Algorithms frequent itemsets, privacy, outsourcing
In recent years, an increasing number of people in various fields such as business, networks, bioinformatics and to nam e a few are interested in data mining due to its great promise [4, 8, 22]. For those who lack of expertise in data mining and/or computational resources, they have the need of out-sourcing data mining tasks to a professional third party. At the same time, the advance of cloud computing [3] also fa-cilitates the providing of outsourcing services, especial ly for the computational intensive tasks. We note that the fre-quent itemset mining could be very time consuming if the dataset or the pattern is long [22, 24].

For the problem of outsourcing frequent itemset mining, a data owner concerns most about (1) the correctness and completeness of the mining results and (2) the privacy pro-tection of sensitive information, including the raw data an d the frequent itemsets. The perturbation approaches [2, 5] and the bloom filter approaches [9, 17] require the sacrifice of the precise mining results for better privacy protection , while the encryption approach [23] provides much privacy protection under the conservation of precise mining result s.
To best of our knowledge, the work in [23] is the first en-cryption solution to the security in the outsourcing of pre-cise association rule mining, which is closely related to th e outsourcing of frequent itemset mining since one must get frequent itemsets first for finding association rules. Their method encrypts real items by a mapping function, and adds fake items independently into the encrypted transactions t o enlarge the search space of inverse item mappings to enhance the protection. However, a very recent work in [15] noted that the independently added fake items can be removed by detecting the low correlations between items, and showed some success in re-identifying top frequent items.
The challenge of privacy protection in the outsourcing fre-quent itemset mining is that, since a third party is profes-sional in data mining, he may learn knowledge about fre-quent itemsets and the support information from his past experience [14]. Then, not only the frequent itemsets are clues to the decryption, but also the support information can drastically reduce the search space of possible inverse mappings of an encrypted item. Especially, top frequent items are usually unique within a range of their supports and thus can be easily identified by exact or approximate support information. That is, in the worst case, there could be only one possible inversion for an encrypted item of a particular support or within a small support range.
Defending against attacks of support information, we note that still another approach to privacy protection is the gro up based approach which hides individual entity behind a group of entities. There are many variations to this approach, in-cluding k -anonymity [18], l -diversity [12], t -closeness [10], etc. This approach has been applied to not only conven-tional database records, but also other types of data like graphs or social networks [11, 16]. We then adopt the idea of k -anonymity in our encrpytion scheme.

Specifically, this paper studies the problem of enhancing the security in outsourcing frequent itemset mining under the conservation of precise mining results. We assume an experienced attacker referred to as an  X  -knowledgeable at-tacker, who knows not only  X  % of the frequent items but also the exact support information of the known frequent items. To defend an  X  -knowledgeable attacker, we introduce the k -support anonymity to protect each encrypted sensitive item with k  X  1 other encrypted items of similar support. The insight is that it is difficult for a data owner to estimate how much knowledge a malicious third party has. However, the protection against precise supports can indicate the prote c-tions against approximate supports and top frequent items, which are much easier for the third party to learn from his background knowledge. That is, if there are k items with the same support sup ( x ) in the encrypted database to pre-vent unique identification of each real item x by its exact support, there are at least k items with a support within the range [ sup ( x )  X   X , sup ( x )+  X  ]. Similarly, there are also k items in the encrypted database as frequent as a top frequent real item. Therefore, our purpose is then to achieve the k -support anonymity and retain all original frequent itemset s in the encrypted database for outsourcing frequent itemset mining.

Fig. 1 is an overview of a straightforward scheme for out-sourcing frequent itemset mining. The naive solution to the problem of k -support anonymity is to introduce many fake item occurrences into the encrypted database so that the fake items can have the same support as the sensitive items. However, this method suffers from unreasonable large over-head in the dataset size when a large k -support anonymity is required.

Alternatively, our method is to introduce a pseudo taxon-omy tree and have the third party mine the frequent item-sets under generalized association rules [7, 20], referred to as the generalized frequent itemsets, instead. Fig. 2 is the overview of our scheme. The pseudo taxonomy is an artifi-cial construct to facilitate hiding of the original items an d to achieve better storage efficiency. The rationale for this approach is that we can hide each original item in either a leaf node or an internal node, and make other nodes in the taxonomy tree as cohorts for k -support anonymity. Note that an internal node does not directly appear in the trans-actions, but gets supports from a set of transactions inferr ed through the taxonomy. By using internal nodes in the taxon-omy tree, we can avoid expanding the transaction database due to the fake items. In addition, note that fake items here are added according to the pseudo taxonomy tree. Since fake items are not independent from other items, the attack method in [15] cannot break our encryption. The challenge is then on how to generate the pseudo taxonomy tree to facilitate k -support anonymity and to ensure the conserva-tion of original frequent itemsets. The experimental resul ts showed that our methods of the k -support anonymity can achieve very good privacy protection with moderate storage overhead.
 Figure 1: A general scheme of outsourcing frequent itemset mining.

Let I be a set of items, and T I is a transaction database where each transaction t is a subset of I . A transaction t contains an itemset X if and only if X is a subset of t . The support of X in T I , denoted as sup T I ( X ), is the number of transactions in T I containing X . An itemset X is frequent if the support of X is not less than the given minimal support. The problem of mining frequent itemsets is to discover all the frequent itemsets in T I .

Our purpose in this paper is to protect the security in the outsourcing of frequent itemset mining against an expe-rienced attacker. The attacker can learn knowledge about the database T I from his past experiences and background knowledge.

Definition 1. (  X  -knowledgeable attacker ) Let L be the set of frequent items in T I , and  X L be the set containing  X  % of frequent items in L . An attacker is  X  -knowledgeable if he knows  X L and the exact support information of the known frequent items.

The encryption of the original database is an effective way to shelter original data from the attacker. To ensure (1) the correctness and completeness of the mining results and (2) the security of the outsourced data, the applied encryption method should have the following properties. 1. Let E (  X  ) be the encryption function, and T N is the 2. There exists a decryption function D (  X  ). For any en-3. The original database T I , the functions E (  X  ) and D (  X  )
Properties 1 and 2 ensure that no frequent itemset is missed and no infrequent itemset is introduced because of the encryption/decryption. Property 3 allows only the data owner to correctly discover the real frequent itemsets from the mining results of the encrypted database T N .
In addition, note that the  X  -knowledgeable attacker can attack with exact support information. To enhance the se-curity, we propose k -support anonymity, which is to hide each sensitive item in a group of at least k encrypted items with the same support.

Definition 2. ( k -support anonymity ) Let S be the set of sensitive items in the transaction database T I , i.e., S  X  I . An encrypted database T N of T I satisfies k -support anonymity if and only if, for every sensitive item x  X  S , there are at least k encrypted items y  X  N and sup T N ( y ) = sup T I Example 1. Given the original database T I in Table 1(a). In this example, we suppose that  X  X eer X  and  X  X ea X  are the sensitive items in T I , and T N in Table 1(b) is an encrypted database of T I . (We will show the mappings between T I and T
N in Section 3.) Then, T N satisfies 3-support anonymity because there are 3 encrypted items  X  a  X ,  X  g  X , and  X  h  X  with support 2. Consequently, the attacker cannot correctly re-identify  X  X eer X  and  X  X ea X  from T N with the item support of 2.

Proposition 1. If a dataset is k 1 -support anonymity, then it is also k 2 -support anonymity for every k 2 &lt; k
The concept of k -support anonymity can effectively pre-vent single identification of an item by the exact support in-formation. Our problem, named the k -support anonymity problem , is to have the encryption satisfy the above three properties and the fourth property below. 4. The encrypted database T N satisfies k -support anonymity.
A naive solution to the k -support anonymity problem is that, for the desired support level sup T I ( x ) of sensitive items x , first repeatedly create a fake item p and randomly insert p into sup T I ( x ) transactions, until there are k items with support sup T I ( x ). Then, replace the items with encrypted items. The disadvantage of this method is the very large storage overhead, which is about ( k  X  1) ditional item occurrences in the worst case.

Instead, we transform the frequent itemset mining to the generalized/multi-level frequent itemset mining, and lim it the additional item occurrences with the help of a pseudo taxonomy tree. Compared to the naive approach, our meth-ods can achieve better storage efficiency while protecting th e sensitive information with the k -support anonymity.
Different from the frequent itemset mining defining each item in a single concept level, the generalized (or said, (a) Original DB T I (b) Encrypted DB T N trans. ID real items trans. ID encryptions multi-level) frequent itemset mining [7, 20] defines items in hierarchical concepts and extends the mining to the discovery of all frequent itemsets across concept level s. For example, if 60% customers buy low-fat milk and whole-wheat bread together, { low-fat milk, whole-wheat bread } is a frequent itemset given a minimal support smaller than 60%. In addition, given the concept  X  X ow-fat milk is a kind of milk X , the generalized frequent itemset mining also discov ers { milk, whole-wheat bread } as a frequent itemset.
In the generalized frequent itemset mining, what is usually used to indicate the hierarchical concepts is the taxonomy tree, where the root is the most general concept of all items and the leaf is the most specific concept of an item.
Definition 3. ( taxonomy tree, = ) A taxonomy tree = of a transaction database T is a directed acyclic graph, where a node n j is a specialization of its parent node n j  X  1 the parent node n j  X  1 is a generalization of n j ) in concept. A transaction containing a leaf node n j will support n j and all the ancestor nodes of n j . Let T ( n j ) be the set of transactions in T supporting n j . The support of n j in T , denoted as sup T ( n j ), is the cardinality of the set T ( n j ).
A taxonomy tree has the property of support depen-dency . Because each node n j is a kind of its parent node n j  X  1 in concept, transactions supporting n j will also sup-porting n j  X  1 . Therefore, T ( n j )  X  T ( n j  X  1 ) and sup sup T ( n j  X  1 ) always hold.
 Example 2. Fig. 3(a) is the taxonomy trees of T I in Table 1(a). (In this paper, we list T ( n j ) under each leaf node n j and count sup T ( n j ) in all the corresponding nodes n j for illustrative purposes.) Referred to T I and the tax-onomy tree in Fig. 3(a),  X  X lcoholic beverage X  represents a more general concept of  X  X eer X  and  X  X ine X . Therefore, T (alcoholic beverage) = T I (beer)  X  T I (wine) = { 1 , 2 , 4 , 5 } and sup T I (alcoholic beverage) = 4. Figure 3: Taxonomy trees of (a) T I and (b) T N .

Given a transaction database together with a taxonomy tree and a user-specified minimal support, there are many researches [7, 20] studying efficient algorithms for the gene r-alized frequent itemset mining problem and the variations.
For the k -support anonymity problem, it is necessary to introduce fake items in the encrypted database. To limit the storage overhead, we transform the frequent itemset mining to the generalized frequent itemset mining. Note that this method does not require a real taxonomy tree. Instead, we construct a pseudo taxonomy tree to protect real items which may appear in different node levels of the tree. This is in contrast to the traditional taxonomy tree in generaliz ed association rule mining, where the real items only appear in the leaf level. However, this will increase the confusion to the attackers as any node in the hierarchical tree may be mapped to a real item, or a cohort of the anonymous group, or neither. Finally, we encrypt the original database such that the discovered generalized frequent itemsets contain the real frequent itemsets as a subset.

Example 3. Consider the database T I in Table 1(a) and assume that all items are sensitive items. Fig. 4(a) shows a correct way to protect the items in the nodes of a pseudo taxonomy tree. First, note that every real item gets sup-ports from the same transactions as in T I . Since the gen-eralized frequent itemset mining finds all frequent itemset s across concept levels, the real frequent itemset like { beer, wine } with a minimal support of 2 will be included in the mining result of generalized frequent itemsets. Next, by a one-to-one mapping, we can obtain the taxonomy tree in Fig. 3(b), and T N in Table 1(b) is the corresponding encrypted database. Note that there are only 4 additional item occur-rences introduced into transactions 1, 2 and 5 in T N , while each sensitive item is protected in a 3-support anonymous group because there are 3 nodes in the tree with the same support.

Our method has three advantages as follows. First, it does not need new mining algorithms. The third party can treat the given encrypted database and the corresponding pseudo taxonomy tree as the usual ones, and apply any existing gen-eralized frequent itemset mining algorithm to find a super set of the real result. Second, our method has good storage efficiency for the k -support anonymity problem. We utilize the internal nodes in the pseudo taxonomy tree to alleviate the need to introduce fake items at the leaf level as well as additional item occurrences in the encrypted database. Third, the extra frequent itemsets discovered by the gener-alized frequent itemset mining can also help to confuse the attacker in the re-identifications of items. The experiment al results show that our method can also protect the security against the attack of exact itemset supports, even though the k -support anonymity only anonymizes item supports.
The challenges are (1) pattern conservation and (2) sup-port anonymity. First, pattern conservation is the need to ensure that the real frequent itemsets are included in the generalized frequent itemsets under the same minimal sup-port. A naive solution is to treat real items as leaf nodes similar to the traditional generalized association rule mi n-ing. However, this will make the detection trivial even with fake items inserted. Second, support anonymity is to create enough nodes with the same support. Note that the taxon-omy tree has the property of support dependency. There is a cascading effect on support upward and downward when a node with a particular support is created. The cascad-ing effect may undo the previously created cohorts of the anonymous groups.

Example 4. Consider the database T I in Table 1(a). Fig. 4(b) shows a pseudo taxonomy tree violating pattern conser-vation. Note that because  X  X igar X  gets supports from trans-actions { 3,4,5 } but not from transactions { 2,3,4 } as in T this tree cannot preserve the correct mining result of T I under the generalized frequent itemset mining. Figure 4: Examples of (a) good and (b) bad protec-tions for real items in the taxonomy trees.

We take care of the challenges in two steps. First, in Sec-tion 3.2, we present a k -bud pseudo taxonomy tree, and show that the k -bud pseudo taxonomy tree can ensure the pattern conservation and facilitate the accomplishment of k -support anonymity. After that, in Section 3.3, we propose three alteration operations on the taxonomy tree to achieve the support anonymity. These operations posses the property of anonymous group preservation which means that once the cohorts are created for an anonymous group, they will not be undone in the subsequent creations of another anonymous group. Finally, Section 3.4 presents a linear-time decryp-tion algorithm for the discovery of the real result from the generalized frequent itemsets.
For the k -support anonymity problem, our first step is to transform the frequent itemset mining into the generalized frequent itemset mining. That is, the purpose in this sub-section is to build a pseudo taxonomy tree that can conserve the real frequent itemsets in the generalized frequent item -sets, given any minimal support. Note that there are many ways to build such a pseudo taxonomy tree. In the follow-ing, we introduce one way and show that our method builds a pseudo taxonomy tree that can also facilitate the support anonymity in Section 3.3. In this paper, we build a pseudo taxonomy tree on a full binary tree structure. Nevertheless , our methods can be easily extended to other tree structures.
First, we define a k -bud taxonomy tree, which ensures the conservation of real results and the capability of facilita ting the k -support anonymity.

Let x M be the most frequent sensitive item in the original database T I . Given a taxonomy tree of T I , we define three sets A &gt; , A = and A &lt; as follows. A &gt; is the set of leaf nodes with supports larger than sup T I ( x M ). A = is the set of nodes with supports sup T I ( x M ). A &lt; is the set of nodes with sup-ports smaller than sup T I ( x M ), where the parent nodes have supports larger than sup T I ( x M ).

Definition 4. ( k -bud pseudo taxonomy tree, = k ) A tax-onomy tree is a k -bud pseudo taxonomy tree of a transaction database T I if and only if all items in I are at the leaf level and k  X  | A &gt; | + | A = | + | A &lt; | holds.

Example 5. Fig. 5(a) shows a 3-bud pseudo taxonomy tree of T I in Table 1(a). Suppose that  X  X ine X  is the most frequent sensitive item. Then, A &gt; is an empty set, A = the set { p 1 , wine } , and A &lt; is the set { tea } .
Proposition 2. If a taxonomy tree is k 1 -bud, then it is also k 2 -bud for every k 2 &lt; k 1 .

A k -bud taxonomy tree = k can preserve the real frequent itemsets as a subset of the generalized frequent itemsets. Specifically, note that in the frequent itemset mining prob-lem, each item is considered in a single concept level and there is no hierarchical relationships between items. Ther e-fore, a pseudo taxonomy tree with real items at the leaf nodes can conserve the real result. In Section 3.3, we will introduce our methods to raise up real items from leaf level to internal level for better security.

On the other hand, a k -bud taxonomy tree = k can also fa-cilitate the accomplishment of k -support anonymity. Specifi-cally, for the most frequent sensitive item x M , we can include the nodes in A = as the created cohorts for the anonymous group of x M , and create new nodes with support sup T I ( x as the descendants of the nodes in A &gt; and as the parents of the nodes in A &lt; . According to Definition 4, there are at least k places where we can have nodes with support sup T I ( x As for the other sensitive items with smaller supports, we can always get cohorts as the descendants of the nodes with support sup T I ( x M ).

In the following, we present the algorithm of constructing a k -bud pseudo taxonomy tree on a full binary tree structure (Algorithm 1). The inputs include a transaction database T
I and an integer k . First, to conserve the real frequent itemsets, we randomly partition real items into k groups, and build a full binary subtree = G p for each group G p with real items at the leaf nodes (Lines 1-2). Then, we iterativel y connect the k subtrees into a single tree as follows (Lines 3-6). At each iteration, note that there is at least one subtree = sup T I ( x M ) since the item x M is a leaf node of some subtree. a support larger than or equal to sup T I ( x M ) (Line 4), and = node of the roots of = G a and = G b (Line 6). When the k subtrees are connected, the single tree is a k -bud taxonomy tree.
 1: Randomly partition real items into k groups G p , p = 1 , ..., k
Theorem 1. Algorithm 1 generates a k -bud taxonomy tree.

Proof. We shows that k  X  | A &gt; | + | A = | + | A &lt; | holds when the algorithm terminates. Specifically, consider the k sub-trees of k groups. All the subtrees, where the supports of the roots are larger than or equal to sup T I ( x M ), contribute to A &gt; , A = , or A &lt; at the beginning. The other subtrees contribute to A = or A &lt; when being connected to a subtree =
G a . Consequently, k  X  | A &gt; | + | A = | + | A &lt; | holds when the k subtrees are connected into a single tree. Theorem 1 is proved. Figure 5: Examples of (a) a 3-bud tree, (b) the in-sertion, (c) the split and (d) the increase operations.
In this subsection, our purpose is to alter the k -bud tree to achieve the k -support anonymity. We propose three al-teration operations: insertion, split and increase. These op-erations have the property of the anonymous group preser-vation, which means that once the cohorts are created for an anonymous group, they will not be undone in the sub-sequent creations of another anonymous group. By first marking nodes of real items as the created cohorts to be preserved for the anonymous groups, we can thus achieve the k -support anonymity without destroying the conserva-tion of real result. In addition, as we shall see later, the split operation can raise up the real items from leaf nodes to internal nodes, and the insertion operation can introduc e fake items as leaf nodes. Therefore, the detection of a real item from a set of nodes becomes non-trivial even with the item support information.

The challenge is that the taxonomy tree has the property of support dependency. Whenever a node of a particular support is created, there is a cascading effect on support upward and downward. To alleviate the cascading effect and prevent the created cohorts from being undone, we would need to carefully manage the occurrences of fake items in the encrypted transaction database T N . That is, the alteration operations not only alter the taxonomy tree but also update the encrypted database T N .

Before introducing the alteration operations, we define the notations used.
 Notations. Consider the nodes related to a node n j . The parent node of n j is denoted as n j  X  1 , the sibling of n is denoted n s j , and the two child nodes of n j are denoted as n j +1 and n s j +1 respectively. T N ( n j ) is the set of transactions in the database T N supporting n j . (1) Insertion. This operation creates cohorts of the anony-mous groups by inserting nodes onto edges. For a sensitive item x , the insertion operation is applicable on a node n sup T N ( n j ) &lt; sup T I ( x ) &lt; sup T N ( n j  X  1 this operation creates a new node n a with support sup T I in-between n j and n j  X  1 . Note that, due to the support dependency, the support of n a is contributed from n j . To eliminate the cascading effect downward, the operation adds a new leaf node n b as the other child node of n a , and makes the additional support needed for n a come from n b . Si-multaneously, to eliminate the cascading effect upward, the occurrences of n b in the database T N is limited to a sub-set of the transactions supporting n j  X  1 . That is, T N T
N ( n j  X  1 )  X  T N ( n j ) and | T N ( n b ) | = sup T I Finally, n a is marked as a created cohort for its preservation.
Example 6. Given the 3-bud taxonomy tree in Fig. 5(a), consider how to create a node with a support of 4 by the insertion operation, for increasing the number of cohorts i n the anonymous group of  X  X ine X . Note that the insertion is applicable on  X  X ea X  because sup T N (tea) &lt; 4 &lt; sup holds. As the black nodes shown in Fig. 5(b), an internal node  X  p 4  X  is inserted on the edge ( p 3 , tea) together with a new leaf node  X  p 5  X . Simultaneously, because the node  X  X ea X  only contributes a support of 2 to the node  X  p 4  X , 2 trans-actions { 1,2 } are selected from T N ( p 3 )  X  T N (tea), which is { 1,2,4 } , to contain the item  X  p 5  X . Consequently, the supports of the nodes  X  p 3  X  and  X  X ea X  are unchanged, and the support of the node  X  p 4  X  is 4 with only 2, instead of 4, additional item occurrences in the encrypted database.

In addition to create cohorts of the anonymous groups, the insertion operation has the side effect of introducing fa ke items as leaf nodes. However, this makes the detections of real items more difficult. (2) Split. This operation creates cohorts of the anonymous groups by allocating the support of some leaf node to its newly created child nodes from the split operation. For a sensitive item x , the split operation is applicable on a node n j if n j is a leaf node and sup T I ( x ) &lt; sup T N ( n Specifically, this operation creates two nodes n a and n b the child nodes of n j , and allocates the occurrences of n the database T N to n a and n b such that the support of n is sup T I ( x ), i.e., T N ( n a )  X  T N ( n j ), T N ( n | T
N ( n a ) | = sup T I ( x ). Finally, n a is marked as a created cohort for its preservation.

Example 7. Follow Example 6. Consider how to create a node with a support of 3 by the split operation, for in-creasing the number of cohorts of  X  X igar X  in the taxonomy tree in Fig. 5(b). Note that the split is applicable on  X  X ine X  because  X  X ine X  is a leaf node and 3 &lt; sup T N (wine) holds. As the black nodes shown in Fig. 5(c), the nodes  X  p 6  X  and  X  p are created as the child nodes of  X  X ine X . Simultaneously, 3 transactions { 1,4,5 } in the set T N (wine) are allocated to con-tain p 6 instead, while the other transaction { 2 } is allocated to contain p 7 instead. Consequently, the node  X  X ine X  still receives supports from the set of transactions { 1,2,4,5 } , and the support of  X  p 6  X  is 3 without additional item occurrences in the encrypted database.

In addition to create cohorts of the anonymous groups, the split operation also raises up the leaf nodes to internal nod es as well as the levels of all the ancestor nodes. Therefore, real items can also be at internal nodes when the k -support anonymity is achieved, even though all real items are at the leaf level at first. (3) Increase. This operation creates cohorts of the anony-mous groups by increasing the supports of nodes. For a sensitive item x , the increase operation is applicable on a node n j if sup T N ( n j ) &lt; sup T I ( x ) &lt; sup T within the subtree of n j , there is a path from n j to some leaf node n j + m , m  X  0, such that all the nodes n j , n and n j + m on the path are not the cohorts of any anonymous group. (The latter condition prevents the existing cohorts from being undone.) Specifically, this operation increases the support of n j to sup T I ( x ) by simultaneously increasing the supports of its descendant nodes n j +1 , ..., and n j + m said, by increasing the occurrences of n j + m in the database T
N ). Note that, to eliminate the cascading effect upward and to contribute new supports to n j , the additional occur-rences of n j + m in the database T N are limited to a sub-set of the transactions which support n j  X  1 but not n j T
N ( n j  X  1 )  X  T N ( n j ). Finally, n j is marked as a created co-hort for its preservation.

Example 8. Follow Example 7. Consider how to create another node with a support of 3 by the increase operation, for increasing the number of cohorts of  X  X igar X  in the taxon-omy tree in Fig. 5(c). Note that the increase operation is applicable on  X  p 7  X  because sup T N ( p 7 ) &lt; 3 &lt; sup holds and, within the subtree of  X  p 7  X ,  X  p 7  X  is a leaf node and is not a cohort of any anonymous group. As the black node shown in Fig. 5(d), to increase the support of  X  p 7  X  from 1 to 3, 2 transactions { 1,5 } are selected from T N (wine)  X  T which is { 1,4,5 } , to contain the item  X  p 7  X . Consequently, the support of  X  X ine X  is not changed and the support of  X  p 7 becomes 3 with only 2 additional item occurrences in the encrypted database.
 We now present our encryption algorithm (Algorithm 2). The inputs include a transaction database T I , a k -bud tax-onomy tree = k of T I , the set of sensitive items S  X  I , and an integer k . First, the encrypted database T N is initial-ized with T I (Line 1). All leaf nodes in the taxonomy tree = k are marked as created cohorts for the conservation of real result (Line 2), because the leaves are real items at the beginning and the supports of these nodes should not be changed by the subsequent alteration operations. After that, we start the taxonomy alteration process and gener-ate the anonymous groups for sensitive items (Lines 3-13) as follows. For each sensitive item x , we first assume that the three alteration operations are applicable on some node s in the tree (Line 4), and mark the existing nodes with the same support as created cohorts (Lines 5-6). Then, until there are at least k nodes with support sup T I ( x ) in T iteratively choose a possibly applicable operation op (Line 8). If there exists a node n j on which op is applicable for the sensitive item x , we alter the taxonomy tree = k and update the encrypted database T N as explained above (Line 9-10). Otherwise, op is considered not applicable anywhere for the sensitive item x (Line 13). After the k -support anonymous groups for all sensitive items are completed, we generate a one-to-one mapping function M (  X  ) (Lines 14) and encrypt each item n j in = k and T N with M ( n j ) (Lines 15). Finally, the algorithm outputs the encrypted database T N together with the altered taxonomy tree = k and the mapping function M (  X  ) (Lines 16).

Note that Algorithm 2 guarantees to terminate and achieve the k -support anonymity, because the alteration operations have the property of the anonymous group preservation and it is proved in Section 3.2 that we can find or create k cohorts for each sensitive item in the inputted k -bud tree. an attacker can never find the correct mappings for the items that are not in his knowledge. For the same reason, the de-cryption accuracy of a transaction t is defined as the inter-section of the decrypted transaction and the original trans -action normalized by the items known to the attacker, i.e., is the average of decryption accuracy of the transactions fo r which t  X  6 =  X  . The lower the accuracy is, the better the security our methods provide.

First, consider the attack of exact item supports, which is the case our scheme designed for. Fig. 7 shows that the decreasing, increasing and random orders achieve similar s e-curity levels on the Retail and T10I1kD100k datasets under 20-support anonymity ( k =20) and 100-support anonymity ( k =100). For the case k =100, our approaches can almost perfectly protect the sensitive items (the item accuracy is about 0%  X 3%). For the case k =20, the privacy protection is a little bit lower (the item accuracy is about 5%  X 8%). This is because, with exact item supports, an attacker has about 1/ k probability to correctly guess the mapping of an item protected with the k -support anonymity. Moreover, the attacker can further reduce the privacy protection a lit -tle bit according to the taxonomy tree since we assume that the attacker is a malicious third party. On the other hand, the database accuracy for the case k =100 is also lower than the database accuracy for the case k =20. Compared to the item accuracy, the database accuracy may be lower as shown in Fig. 7(a) or higher as shown in Fig. 7(b). This is because the database accuracy is the average of decryption accuracy of transactions for which t  X  6 =  X  .

Next, we consider a more challenging case, where a super  X  -knowledgeable attacker knows not only exact item sup-ports but also exact itemset supports. Under the same pa-rameter settings, the attack accuracies in Fig. 8 are simila r to those in Fig. 7. Both the item and database accura-cies against attack of itemset supports are about only 0  X 2% higher than the accuracies against attack of item supports. These results show that our approaches can also work well for attacker knowledge on itemset supports.
In this subsection, we study the storage and time efficien-cies of our methods on the Retail and T10I1kD100k datasets.
First, we compare the storage overhead, i.e., the num-ber of additional item occurrences in the encrypted transac -encryption algorithm on (a) Retail and (b) T10I1kD100k data sets. tion database, introduced in our approaches with that in the naive method. Fig. 9 shows that our methods can achieve k -support anonymity with less than 45% of the overhead in the naive method. Furthermore, the decreasing and increasing orders achieve better storage efficiency (less than 25% of the overhead in the naive method) than the random order does. This is because our methods protect real items with nodes in the hierarchical taxonomy tree, and each occurrence of items is permitted to contribute a support to the cohorts of the anonymous groups as many times as possible through support dependency on the taxonomy tree, especially in the decreasing and increasing orders.

In addition, our approaches except for the random order can achieve the privacy protections with moderate storage overhead. For the case k = 20, the sizes of the encrypted databases processed in the decreasing (increasing) order a re about 1.26 (1.37) times of the size of T10I1kD100k dataset and about 1.9 (2.9) times of the size of Retail dataset. Un-der a similar security level (but we are against a stronger at -tacker model), the work in [23] has their encrypted database s about 1.6 and 2.4 times of the size of original database. Our methods achieve the protections against a stronger attacke r model with comparable storage overheads to the work in [23].

Next, we study the time efficiency of our approaches. Note that our methods do not encrypt the original database un-der a particular minimal support. The comparison of the encryption efficiency and the mining efficiency is not ap-propriate since we can mine the frequent itemsets from the same encrypted database many times with different minimal supports. Instead, we study the execution time for different k -support anonymity. As shown in Fig. 9, the three orders are comparable on the execution efficiency. The execution time grows almost linear to the parameter k .

Summing up the results in the security analysis and cost efficiency, we note that the three encryption orders provide similar degree on privacy protection, but the decreasing an d increasing orders have better saving on storage efficiency and are compatible with the random order on the execution time of encryption. We can conclude that the k -support anonymity has more impact in the privacy protection than the number of additional items.
Various approaches have been studied to achieves the pri-vacy protections in the problem of pattern mining, and these approaches suffer differently.

In [2, 5], the raw data is randomly perturbed before it is given to a third party. The works in [9, 17] protect privacy through an approximation protocol, the bloom filter. Still another work [21] directly decreases the occurrences of ite ms to eliminate sensitive patterns. All these method above sac -rifice the precision of mining result.

On the other hand, for the conservation of precise patterns in secured outsourcing of association rule mining, the work s in [6, 23] replace items with meaningless symbols and add noise to prevent re-identification. In [6], the noise is a set of fake transactions consisting of the original items. Howeve r, this approach can affect not only the number of occurrences of a pattern but also the total number of transactions, i.e., both the numerator and denominator of the support calcu-lation. To filter out false positive patterns from the mining results, this method suffers from the need to determine the false positive patterns in advance, especially when the pat -terns are long. Differently, the other approach [23] adds fak e items into original transactions to avoid this problem. We hence take this approach in the paper.
The background knowledge such as the supports of fre-quent itemsets can be utilized to obtain privacy informa-tion in the outsourcing of frequent itemset mining. In this paper, we propose k -support anonymity to provide protec-tion against a knowledgeable attacker with exact support information. To achieve k -support anonymity, we intro-duce a pseudo taxonomy tree and have the third party mine the generalized frequent itemsets instead. The construct o f the pseudo taxonomy tree facilitates hiding of the original items and limits the fake items introduced in the encrypted database. The experimental results showed that our meth-ods of the k -support anonymity can achieve very good pri-vacy protection with moderate storage overhead.
This work is supported in part by NSF through grant IIS-0914934 and by National Science Council, Taiwan, R.O.C. under Contract No. NSC97-2917-I-002-130. [1] R. Agrawal and R. Srikant. Mining sequential [2] R. Agrawal and R. Srikant. Privacy-preserving data [3] R. Buyya, C. S. Yeo, and S. Venugopal.
 [4] L. Cao, P. S. Yu, C. Zhang, and H. Zhang. Data [5] A. Evfimievski, R. Srikant, R. Agrawal, and [6] F. Giannotti, L. V. Lakshmanan, A. Monreale, [7] J. Han and Y. Fu. Discovery of multiple-level [8] M. Kamber and J. Han. Data Mining: Concepts and [9] M. Kantarcioglu, R. Nix, and J. Vaidya. An efficient [10] N. Li, T. Li, and S. Venkatasubramanian. t -closeness: [11] K. Liu and E. Terzi. Towards indentity anonymization [12] A. Machanavajjhala, J. Gehrke, D. Kifer, and [13] A. J. Menezes, P. C. van Oorschot, and S. A.
 [14] T. Mielik  X  ainen. Privacy problems with anonymized [15] I. Molloy, N. Li, and T. Li. On the (in)security and [16] J. Pei and B. Zhou. Preserving privacy in social [17] L. Qiu, Y. Li, and X. Wu. Preserving privacy in [18] P. Samarati and L. Sweeney. Generalizing data to [19] R. Spillman, M. Janssen, B. Nelson, and M. Kepner. [20] R. Srikant and R. Agrawal. Mining generalized [21] X. Sun and P. S. Yu. A border-based approach for [22] J. T. L. Wang, M. J. Zaki, H. T. T. Toivonen, and [23] W. K. Wong, D. W. Cheung, E. Hung, B. Kao, and [24] F. Zhu, X. Yan, J. Han, P. S. Yu, and H. Cheng.
