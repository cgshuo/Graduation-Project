 1. Introduction vast majority, is stored in databases on the so-called hidden web. automatically annotate the information in these pages and make it available to standard query engines. concept.
 plexities make automatic table interpretation challenging.
 CGC name , as does Entrez Genes and Ace View beside NCBI .
 model(s).Amino Acids is the label for the first dimension, and 2 is the row label for the second dimension. labels and look for variations to find data values.
 the web site and of the individual tables embedded within pages of the web site. cation.Gene Model(s).Gene Model are below, and the values for Identification.Species are to the right. that the top rows are rows for labels.
 optional. The basic label-value association pattern is still the same. tion visible to users from outside specialized hand-built GUIs.
 2. Initial table processing HTML tables.
 two-third level nested tables.
 tables. As a result, TISP decomposes the page in Fig. 1 into the set of tables in Fig. 4 . 3. Table matching
To compare and match tables, we first transform each HTML table into a DOM tree [13]. Tree conditions for all  X  i 1 ; j 1  X  ;  X  i 2 ; j 2  X 2 M, where i (1) i 1  X  i 2 iff j 1  X  j 2 ; (2) T  X  i 1 comes before T  X  i 2 iff T 0  X  j 1 comes before T (3) T  X  i 1 is an ancestor of T  X  i 2 iff T 0  X  j 1 is an ancestor of T ber of ordered pairs.
 ming with complexity O  X  n 1 n 2  X  , where n 1 is the size (number of nodes) of T and n in Tree 1 in Fig. 5 shows the matched nodes for Tree 1 with respect to tree 4. Sibling-table identification nodes in a sibling-table pair.
 [18] to pair sibling tables one-to-one from two sibling pages.
 by 27 (tree size of Tree 2 ), which, expressed as a percentage, is 70.4%. we set the upper threshold at 90% and the lower threshold at 20%. table. When more sibling pages are compared, we might find a matching table. 5. Structure patterns pairs from sibling tables in the web site (Section 5.5). 5.1. Pattern templates tions of patterns we have constitute a large majority of HTML tables. 5.2. Pattern generation greater than a threshold, which we set at 80%.

Consider the mapped result in Fig. 5 as an example. The highlighted nodes are matched nodes in tree tern 1.

We now impose the chosen pattern, ignoring matches and mismatches. Note that for tree table for which we must generate record numbers.
 substituting the actual labels for each L and by substituting a placeholder V 7in Fig. 4 . 5.3. Pattern usage tion 5.5, we explain how TISP reacts to a failure notification.) and collects all needed labels. 5.4. Pattern combinations Pattern 2 perfectly, as do the last two columns.
 column-wise. This second pattern matches the table in Fig. 8 , where n = m = 1, and the plus (+) is 4. 5.5. Dynamic pattern adjustment locate a table, and (2) adjust the generated structure pattern regular expression. cessing with the next table.
 and we add it as an optional label as Fig. 10 shows. 6. Experimental results Two of the geopolitical sites and eight of the molecular biology sites contained nested HTML tables. it recognized new structure patterns correctly.
 all tables from the generated patterns. No adjustment were needed, neither for any path nor for any label. relationship between Murders and per 100,000 and between Rapes and per 100,000 . TISP considered the irrelevant information To Top as a header.
 of 95.8%. Overall the F -measure for table interpretation was 94.5% for the sites we tested. actual time reached a maximum of 15 s for a complicated web site where pages had more than 20 tables. adjustments. 7. Semantic ontology generation OWL ontology.
 we attach ontological concepts. Line 10 in Fig. 12 shows the OWL class  X  X  X ormBase X . show, its domain is AminoAcids and its range is string, by default. as a value V . The pattern then becomes  X  X (&lt; tr &gt;&lt;( td | th )&gt;{ V }(&lt;( td | th )&gt;{ V }) 8. Semantic annotation and querying declarations.
  X  X  X P:CE18608 X  at character 10015 in the cached HTML document.
 base : AminoAcidsV alue (Lines 45, 58, 51, and 64).
 vidual value, TISP++ displays the source page with the corresponding value highlighted. standable and automatically manipulatable by computer agents. 9. Related work 9.1. Sibling page comparison makes various comparisons among main pages and linked pages to find record segmentations. 9.2. Table interpretation work we discuss to only HTML table processing.
 with respect to each other.
 ments here are for solving variations of the same problem, not identical problems. 9.3. Ontology generation features to learn ontologies. The results, however, are not very satisfactory [30]. only one simple way, while TANGO aims at generating more sophisticated ontologies. 9.4. Semantic annotation 10. Conclusion and future work doing so, all the data present in the sibling tables becomes accessible through a standard query interface. and placed in a higher level heading, such as those in Fig. 11 b. generalization/specialization, and aggregation.
 Acknowledgements Appendix. TISP algorithms
Algorithm 1. processTISP(list of two or more sibling pages) 10: if lower threshold &lt; matchPercentage &lt; higher threshold then 11: put the potentialSiblingTablePair in a list of siblingTablePairs 12: else if higher threshold 6 matchPercentage then 13: add both tables to layoutTables 14: else if matchPercentage 6 lower threshold then 15: add both tables to unpairedTables
Algorithm 3. interpretTables( pageDOM , tablePatterns , interpretedTables , unpairedTables , layoutTables ) 1: for each table in pageDOM do 2: get the xpath expression for table in pageDOM 3: use the xpath expression to identify table in layoutTables or in tablePatterns 4: if table identified in layoutTables then 5: do not interpret --not a data table 6: else if table identified in tablePatterns then 7: let foundPattern be the table pattern found 8: tableMatch = matchTablePattern( table , foundPattern ) --see Algorithm 4
Algorithm 1 ( continued ) 16: end if 17: end for 18: let tablePatterns be an empty list of table patterns 19: for each siblingTablePair in siblingTablePairs do 20: tablePattern = determineTablePattern( siblingTablePair ) --see Algorithm 2 21: if tablePattern  X  null then 22: add tablePattern to tablePatterns 23: end if 24: end for 25: let interpretedTables be an empty list of interpreted tables 26: for each sibling page in the input list do 27: parse page to a DOM tree, yielding pageDOM 29: end for 30: use tablePatterns to generate a conceptualization (e.g., generate an OWL ontology) --see Section 7
Algorithm 2. determineTablePattern( siblingTablePair ) 2: for all pre-defined table patterns 3: for all labels in the pattern 4: if the nodes in the label position in the siblingTablePair are matched nodes then 5: increase matchCount by 1 6: end if 7: end for 8: for all values in the pattern 9: if the nodes in the value position in the siblingTablePair are mis-matched nodes then 10: increase matchCount by 1 11: end if 12: end for 14: end for 15: find the pattern that has the highest patternMatchPercentage 16: if the highest patternMatchPercentage &gt; threshold then 18: record the label names found as labels for the pattern 19: mark any label that does not appear in both sibling tables as optional 21: else if findCombination( siblingTablePair )  X  null then 22: return the result of findCombination( siblingTablePair ) --see Algorithm 5 23: else 24: return null 25: end if
Algorithm 3 ( continued ) 9: if tableMatch  X  null then 10: save returned interpreted table in interpretedTables 11: else 12: put table in unmatchedPathTables 13: end if 14: else 15: put table in unmatchedPathTables 16: end if 17: end for 18: --The code above usually processes all tables in a page; the code below processes anomalies. 19: for each table in unmatchedPathTables do 20: if table matches a table in layoutTables then 21: adjust the xpath expression for the matching table in layoutTables 22: do not interpret --not a data table 23: else if table matches with a pattern in tablePatterns then 24: adjust the xpath expression for table in tablePatterns 26: else 27: put table in unmatchedTables 28: end if 29: end for 30: for each table in unmatchedTables do 31: check whether table is a sibling table of any table in unpairedTables 32: if sibling table found then 33: let s _ table be the sibling table found 34: if the match percentage is such that s _ table is a layout table then 35: add both table and s _ table to layoutTables 36: remove s _ table from unpairedTables 37: else 38: tablePattern = determineT ablePattern(&lt; table , s _ table &gt;) --see Algorithm 2 39: if tablePattern  X  null then 40: save table pattern found in tablePatterns 41: use the table pattern found to interpret both table and s _ table 42: save returned results for both tables in interpretedTables 43: remove s _ table from unpairedTables 44: else 45: add table to unPairedTables 46: end if 47: end if 48: else 49: add table to unpairedTables 50: end if 51: end for
Algorithm 4. matchTablePattern( table , pattern ) 10: increase matchCount by 1 11: end if 12: end for 13: calculate matchRate = matchCount /(total number of cells in table ) 14: if matchRate &gt; threshold then 15: for each extra label found do 16: add the extra label to pattern, mark it optional 17: end for
Algorithm 4 ( continued ) 18: for each missing label found do 19: mark it optional 20: end for 22: record label-value pairs in table with respect to pattern , yielding interpretedTable 23: return interpretedTable 24: else 25: return null 26: end if
Algorithm 5. findCombination( siblingTablePair ) 1: let table 1 and table 2 be the two tables in siblingTablePair 2: let tableRegions 1 and tableRegions 2 be empty lists of table-row groups 3: for each row in table 1 do 4: if (number of matched nodes in row )/(number of nodes in row ) &gt; threshold then 5: mark row as a row of labels 6: else 7: mark row as a row of values 8: end if 9: end for 10: if the first row of the table is not a row of labels then 12: add this table-row group to tableRegions 1 13: end if 14: for each row of labels do 17: add this table-row group to tableRegions 1 18: end if 19: end for 20: repeat 3 X 19 with table 2 and tableRegions 2 21: if the number of table regions in tableRegions 1 and tableRegions 22: create tableRegionPairs of corresponding table regions in tableRegions 23: let tablePatternCombinations be an empty list of table pattern combinations 24: for each tableRegionPair in tableRegionPairs do 25: tablePatternCombination = determineTablePattern( tableRegionPair ) --see Algorithm 2 26: if tablePatternCombination  X  null then 27: add tablePatternCombination to tablePatternCombinations 28: end if 29: if tablePatternCombinations is not empty then 30: syntactically form the list into a single combined pattern 32: return null --to prevent infinite recursion 33: else 34: return the combined pattern 35: end if 36: end if 37: end for 38: end if 39: repeat 3 X 38 column-wise 40: return null --neither row-wise nor column-wise pattern found
References
