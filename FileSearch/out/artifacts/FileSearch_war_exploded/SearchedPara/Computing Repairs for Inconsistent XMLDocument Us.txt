 Integrity constraints capture an important normative aspect of every data-based application. However, it is often the case that their satisfaction can not be guaranteed, especially when overlapping or redundant information from mul-tiple sources is integrated. In this paper, we consider the problem of computing repairs for an inconsistent XML document, based on a framework introduced in our earlier work [11].

We summarize the framework here first. The concept of repairs for relations, originally introduced by Arenas et al.[2], is extended to XML. Intuitively, a repair for an XML document T is a document T satisfying the constraints, which is obtained from T by applying some  X  X inimal change X . Given a constraint set  X  and an XML document T , we compute repairs for T in a two-step approach: (1)To generate mend , which is obtained from T by removing those conflicting information w.r.t.  X  .(2)To chase repair from mend, or to say, to  X  X ush X  the information from  X  to mend.

In this paper, We further discuss some key points about mends generation and repairs chasing. We also give a novel cost model for our repair framework, which can be used to evaluate the cost of each repair. We implement prototypes of our method, and evaluate our framework and algorithms in the experiment. To the best of our knowledge, our work is the first prototype implementation of data inconsistency problem for XML constraints, and with a strong formal solution.
 Related Work. There are a lot of research on inconsistent databases[2,4,5,6,9,12]. The results can not be applied to XML directly because of the different data model. For example, even the basic notions of repair need to be redefined. [3] discusses query answers in XML data exchange, to restructure XML docu-ments that conform to a source DTD under a target DTD, and to answer queries written over the target schema. [1] presents a framework for Webhouses with incomplete information, it can represent partial information about the source document acquired by successive queries. They differ from our goal to compute repairs for inconsistent XML documents. [10] considers the problem of querying XML documents which are not valid with respect to given DTDs. It proposes a method for measuring the invalid-ity of XML documents and compactly representing minimal repairing scenarios. Furthermore, [10] presents a validity-sensitive method of querying XML docu-ments. In this paper, we consider integrity constraints for XML in the situation where a DTD is absent. Our framework can be adapted by taking DTDs into consideration, which may restrict the update operations available. [7] considers inconsistent XML data w.r.t. a set of functional dependencies. The repairs are based on the replacing of node values, and the introduction of a function stating whether the node information is reliable. [8] investigates the existence of repairs w.r.t. a constraint set and a DTD. And for all the cases where the existence of a repair is decidable, th e complexity of providing consistent answers to a query is characterized. In this paper, we consider a more general constraint model and more update operations, and provide a formal foundation for the solution in a different way.

The rest of the paper is organized as follows. Section 2 provides the basic notations, including DTD, XML path, symbol mapping and a general constraint model. The repair framework in [11] is summarized in section 3. We discuss some key points about the mends generation in section 4. We give a cost model for the repair framework in section 5. The experimental result of evaluation of our framework and algorithms is given in section 6. Finally section 7 draws a conclusion. We adopt the usual view that an XML document is modeled as a node-labeled data tree, and assume that an element nod e is either followed by a sequence of element nodes and a set of attribute n odes, or is terminated with a text. Definition 1. Assume a finite set E of element labels, a finite set A of attribute names. An XML document(tree)is defined to be T=(V,lab,ele,att,val, v r ). 1) V is a finite set of nodes, and T is empty iff V =  X  . 2)Lab is a function from V to E  X  A, v is called an element node if lab ( v )  X  E , an attribute node if lab ( v )  X  A .3)An element node v may be either followed by other nodes, or terminated with a text. to attribute nodes and element nodes terminated with a text, the value may be a string constant, or a string variable. 5) v r is a distinguished node in V and is called the root of T; without loss of generality, assume lab( v r )=r. Element nodes terminated with a text and attribute nodes are c alled leaf nodes. We extend the val function so that is can assign a string variable to node value. The reason for this is that we want to allow value modification as a repair primitive, and sometimes we are not con cerned about the specific values used.
A symbol mapping from one symbol set A to another symbol set A is a function h , such that for any symbol a in A , h ( a )isasymbolin A . To map node values between different XML documents, we naturally extend symbol mapping to nodes and XML documents. Let the symbol set for XML document T be composed of all the constants and variables from node values. Given a symbol Let the root of T be v r , h ( T ) is an XML document rooted at h ( v r ), and for any node v in T ,if v is the kth child node of v , h ( v )isthe kth child node of h ( v ) in h ( T ). In the rest of paper, we consider h that preserves constants. That is, if aisaconstant, h (a)=a.

Let v and v be two nodes in V . v and v are value equal, denoted as v  X  v iff (1) lab ( v )= lab ( v ), and (2) val ( v )= val ( v ).
 AsimplepathinDTD D is a sequence of node names, with the form P ::= | e/P . Here represents the empty path, e  X  E  X  A , and  X / X  denotes concatenation of two paths. If the first element of P is r ,wecall P root path.

In XML document T ,wesaythatanode v 2 is reachable from node v 1 by following the path P ,iff(1) v 1 = v 2 ,and P = ,or(2) P = P /e ,thereisanode v such that v is reachable from node v 1 by following P ,and v 2 is a child of v with label e .Wewrite v { P } for the set of nodes in T that can be reached by following P from v . In particular, when there is only one node in v { P } ,we use v { P } to denote this node. If v is the root node, we write P for v { P } . Definition 2. A General Integrity Constraint Model.
 The constraint  X  is either of the form ( R 1 ,R 2 , ( Q 1 ,...,Q n ))( X 1 ,...,X m  X  X m +1 ) ,oroftheform ( R 1 ,R 2 , ( Q 1 ,...,Q n ))( X 1 ,...,X m [1 ,m +1] ) is a sequence of values [ x j 1 ,...,x jn ] that may contain variables. u(and w) is either a variable or a constant.
 We require all the variables in constraints are bound, that is, all the variables in X m +1 , u ,or w should also occur in X 1 ,...,X m .Letthesymbolsetforconstraint be composed of all the variables and constants in X 1 ,...,X m ,X m +1 , u and w . Definition 3. Aconstraint  X  is satisfied by an XML tree T , denoted as T | =  X  iff: For any symbol mapping h from  X  to T,  X  v  X  R 1 ,if(1)  X  v j  X  v { R 2 } , ( i  X  [1 ,n ] , j  X  [1 ,m ] ), and b. If  X  = ( R 1 ,R 2 , ( Q 1 ,...,Q n ))( X 1 ,...,X m  X  u = w ) ,h(u)=h(w).
For a set of constraints  X  ,if T | =  X  for any  X   X   X  ,wewrite T | =  X  .Belowwe use  X  to denote the constraint of the form ( R 1 ,R 2 , ( Q 1 ,...,Q n ))( X 1 ,...,X m  X  X m +1 ), and use  X  for ( R 1 ,R 2 , ( Q 1 ,...,Q n ))( X 1 ,...,X m Example 1. Figure 1 gives an XML document about dealers. For each dealer, we give its name(dname) and each shipment of product(plist). The shipment information is composed of product name, product color, shipment destination and date. If not empty, values of element or attribute nodes are recorded under the node names in bold. For example, figure 1 says that a dealer named corp 1 sent out red desk to dest 2 on  X 2006/1/1 X  . We also list 4 integrity constraints this document should satisfy using the notations from definition 2.

This document violates some of the integ rity constraints. There are two dif-ferent dealers with the same name corp 1 , which violate constraint 1. Red product was shipped to dest 2 , which violates constraint 2. Desk was shipped to dest 2 , but was not shipped to dest 1 , it violates constraint 3. And the date  X 2006/1/1 X  for shipment violates constraint 4. Arepair R for an XML document T w.r.tasetofconstraints  X  is an XML document consistent with  X  , and is also as close as possible to T .Intheframe-work, we consider three update operations for fixing an XML document, which are node insertion, node deletion and no de value modification. To describe the semantics of  X  X s close as possible X , we assume the repairing is done according to some partial order. The order  X  below can describe node insertion and node deletion only, the order is further defined based on symbol mapping, which can describe all the thr ee update operations.
 Definition 4. Let S, T be two XML documents, if T is empty, T  X  S. Otherwise let the root node for T be r T , the root node for S be r S , the child nodes of r T be { v 1 ,...,v n the subtree rooted at v i in T, and S u j to denote the subtree rooted at u j in S. T  X 
Siff 1. r T  X  r S ; 2.  X  T v i ,  X  S u j , such that T v i  X  S u j ;(i  X  [1,n], j  X  [1,m]) Definition 5. Let S, T be two XML documents, we write T Siffthereexists a symbol mapping h from T to S, such that h(T)  X  S. If T S, and S T, we write T  X  S. If T S, and T  X  S, we write T  X  S.
 It is clear that if S  X  T , S T .  X  ignores the order of sibling nodes, and allows different symbol sets for node values.
 We get repairs in the following way: Starting from the original XML document T , we find document M first, and M subsatisfy  X  . Here  X  X ubsatisfy X  means that we can further find a document R based on M ,and R | =  X  . To be specific, when getting M from T , we  X  X emove X  those data from T , which conflicts with  X  .This is done by nodes value modifications, to replace a constant by a variable, or by nodes deletions. The insertion of nodes will not help to  X  X olve X  conflicts, so it will not be used in this step. Please note that M T . When obtaining R from M ,we  X  X ush X  some information from  X  to M .Itisdonebynodesvaluemodifications, to replace a variable in M by a constant, or to replace a variable in M by another variable in M . It can also be done by some nodes insertions. In this step, deletion of nodes will not be used, and M R . Further, to accommo date the  X  X s close as possible X  requirement, M should be the document meeting the requirements, and be the closest to T w.r.t .And R should be the document meeting the requirements, and be the closest to M w.r.t .
 Definition 6. LetTbeanXMLdocumentand  X  a set of constraints, an XML document S is said to subsatisfy  X  iff there exists an XML document J, such that S J, and J | =  X  .

AmendforTand  X  is an XML document M T, M subsatisfy  X  ;andthere does not exist M X , such that M M X  T, and M X  subsatisfy  X  .
 A repair for T and  X  is an XML document R, R | =  X  ; and there exists a mend MforTand  X  , such that M R, and for any R X , M R X  R, R X  | =  X  .
 By definition 6, we can X  X  judge whether a mend is valid unless we can further find a repair based on it. So a mend is just called a candidate before we can generate a repair from it. Next we introduce the chase method to justify whether a mend candidate is a mend indeed. And if the mend candidate is a mend, the chase will generate the corresponding repair as well. This is a novel extension of the relational chase method used for logical implication.

For those mend candidates which are not mends indeed, the chase process will fail to  X  X hase X  repairs. We introduce a special XML document, denoted ,for such situations. Definition 7. Let S and T be XML documents, and  X  a set of constraints. We write T  X  S if S can be obtained from T by a single application of one of the following rules: 1.  X  ; 2. if T | =  X  ,T  X  T; otherwise  X   X   X   X  ,T | =  X  . By definition, there is a A chase of T by  X  is a maximal sequence T= T 1 , T 2 ,. . . , T n of XML documents such that for every i  X  X  1 ,...,n } ,T i  X  T i +1 ,and T i = T i +1 . Example 2. We give all the mends and corresponding repairs in figure 2, other mends are  X  to them. In the mends, we replace either corp 1 as variable x , replace  X 2006/1/1 X  as variable z , and replace either dest 2 or red as variable y .
It can also be verified R i is the chase result of M i respectively in figure 2. For example, R 1 is obtained from M 1 by applying  X  rule on constraint 2. And R 3 is obtained from M 3 by applying  X  rule on constraint 3. The fact is that repairs will add information from  X  to mends. In R 1 , we replace y as dest 1 ,whichis implied by constraint 2. And we insert new nodes describing the shipment to dest 1 by constraint 3 in R 3 .
 According to [11], we know that the chase approach has some good properties. 1)The chase can terminate in finite st eps; 2)we can  X  X hase X  repair from T by  X  iff T subsatisfies  X  ; 3)For any two possible chase results S 1 and S 2 , S 1  X  S 2 . Next we discuss some key points about mends generation, which is vital to the implementation of our method. From original document T ,wemayusenode deletions, and replace constant node values by variables, to get the candidates of mend. It is clear that the number of possible candidates are limited w.r.t.  X  .
To preserve more information from the document, we should use as few up-dates as possible. The basic intuition of mends generation is that: First we apply some update operations to the original document, and get a mend candidate M . Next we try to find a repair based on M . If we can find such a repair, M is a mend indeed, and we get the corresponding repair. Or else, we further apply updates to M , get a new candidate M , and try on it again. This routine will continue until all the possible updates are applied to the failed candidates.
Of course we are not interested in applying updates to arbitrary nodes, but to those (possibly) violated nodes only. The violated nodes can be found by validating the document against the constraint set. In the implementation, we further optimize the method of mend candidates generation as follows: 1. We disallow multiple occurrences of the same variable in a mend, to exclude some unnatural mends. For example in figure 1, to replace both corp 1 and  X 2006/1/1 X  as variable x is unnatural, because there is no clear relationship between these two values. We can find the e quivalence of two variables suggested by constraints when generatin g repair from mend by chase. 2. Some constraints are mutually isolated, and can be dealt with separately. For example, constraint 1 and 4 do not share any violated nodes. So the candi-dates for these two constraints can be generated separately, which will greatly reduce the number of possible candidates. 3. There is no need to enumerate all the candidates. By definition 6, if we know M is a mend, there is no need to check any candidate M ,if M M .So we can generate candidates by step by step. In this section, We propose a novel cost model for our repair framework. The cost model attaches a cost to each repair, which can be used in some specific applications. For example, to compute a repair with the  X  X owest X  cost. We leave to future work the development of techniques for automatically setting some parameters in the cost model.

The cost model is based on two factors, reliability and similarity. The reliability of data is reflected in a conditional probability associated with each element and attribute node, with values ranging between 0 and 1. It represents the confidence placed by the user. Each probability in the source XML document is assigned conditioned on the fact that t he parent element exists. That is, with a given probability p , the node X  X  conditional probability equals p when the parent exists, and the node X  X  probability equals 0 when the parent does not exist. Con-sider the chain root  X  dealer in figure 1. Assume the XML document contains clear that a parent must exist with a probability of 1 if its child exists, then eral, the probability of a node n can be found by multiplying the conditional probabilities found in the source XML, along the path from n to the root.
The similarity of data is available at the value level, to accommodate up-date operations using node value modification. The similarity measurement for strings is itself a broad field, and our discussion does not depend on a particular approach. We assume that for two values v , v , a distance function dis ( v, v )is available, with lower values indicating greater similarity.

The cost of a node value modification is the probability of the changed node times the distance between the original value and the value in the repair. To be specific, given a node value modification on node n ,fromnodevalue v to v ,the cost is prob ( n )  X  dis ( v, v ).

We next come to the cost of a node insertion. Assume a node n with empty value is inserted, with node m as its parent. Note that the possibility of a newly inserted node is always 1, then the cost is prob ( m )  X  inscost .Here inscost &gt; 0is a user-defined parameter, to reflect the pre ference of different update operations. For example, if the user prefer value modification in the repairs, inscost can be set with a larger value to increase the cost of node insertions. The insertion of a node with a specific value can be treated i n two steps: 1)a node is inserted with empty values; 2)a node value modification for this node, changing the value from empty to the desired one. Then the cost is the sum of the two separate costs.
The cost of a node deletion can be calculated in a similar way. The difference is that the node being deleted will usually have a conditional probability p =1. 6.1 Experimental Setting We have implemented prototypes of our method in Java. All the experiments are conducted on a PC with a 3.6GHz Pentium 4 CPU and 1GB RAM, running Windows XP(SP2) and JRE 1.5.0. The JVM memory is 512MB. We perform our experiments with artificial data set s generated by the I BM XML Generator.
XML Generator is a program that can create random instances of valid XML given a DTD. The schema used in the expe rimentsisanextensionoffigure1, and has the following characteristics: 22 schema elements with a maximum depth of 6; average and maximum number of subelements(attributes) per element at 2.2 and 7, respectively.

To assess our technique with complicated constraints setting, we include 8 constraints in the experiment, which is composed of 3  X  constraints and 5  X  constraints. Recall that we use  X  to denote the constraint of the form ( R 1 ,R 2 , ( Q 1 ,...,Q n ))( X 1 ,...,X m ( X 1 ,...,X m  X  u = w ). Among the 5  X  constraints, 3 constraints are the tradi-tional functional dependencies(keys). The constraint set is defined such that all the leaf nodes are involved in at least one constraint. Among the 8 constraints, 2, 3 and 4 share same violated nodes, and are treated as a unit in mend candi-dates generation and chase.

All the data sets are processed as follows: 1) Noise is introduced to leaf nodes involved in constraints. When noise is introduced, with probability p n , a leaf node will have value violating constraints; 2)The data set is validated against the pro-posed constraints, and the violated nodes are marked; 3)Initial mend candidates are generated according to the marked nodes in step 2, then chase starts to find repairs. If chase fails, new mend candidates will be produced from the failed can-didates. The chase will continue until no new candidates can be generated.
To make the implementation effective, we build a skeleton tree after step 2, which is composed of only the violated nodes and the nodes along the paths from violated nodes to the root. Each node in t he skeleton contains a reference to the original node in the full document, so the skeleton is used as an index. Since all the nodes accessed in computing can be located directly using the index, it will greatly improve the performance for large document.

We generate mend candidates and chase repairs wisely as discussed in section 3 and 4. Mutually isolated constraints are dealt with separately, and their  X  X epairs X  are combined finally to get the full repairs. With this implementation, for two mutually isolated constraints, the time to compute the full repairs is the sum of the time to compute their own  X  X epairs X , while the number of full repairs is the product of the number of their  X  X epairs X . So the running time grows much more slowly compared with the number of repairs.

We note that the experimental results are very sensitive to the method of noise introduction. In the implementation, we avoid having too much violated nodes for one related constraints unit. The basic intuition is that we try to average the running time among different related constraints unit. 6.2 Experimental Results We evaluate the time(in millisecond) to compute repairs and the number of repairs in the experiment. For timing measurements, each experiment is run three times and the average time is reco rded. We consider three factors while evaluating our method.
 Noise. We generate an XML document with 17295 leaf nodes(totally 36586 nodes containing element, attribute and leaf nodes), then apply different noise ratio to it. We test p n with values ranging between 1  X  and 4  X  in figure 3. With a fixed data set, more noise will cause more violated nodes, which in turn affect both the running time and the number of repairs. Note that the running time grows much more slowly compared with the number of repairs. Scalability. In figure 4, with a fixed noise p n =2.5  X  , we vary the size of data sets. To be more accurate, the size of ea ch data set is measured as the number of leaf nodes it contains(the number of total nodes nearly doubles). The increase of document size will cause more violated nodes, and more time to build the index. Once the index is built, the time to locate a specific node for chase is determined by the index only. Since the index is much smaller than the whole document, in the experiment, we find that the time to compute each repair is almost not affected by the increasing document size.
 Impact of Constraint Sets. The algorithm discussed in this paper gives the user flexibility in specifying the integrity constraints that need to be met. In real applications, users may find a balance between calculation efficiency and data accuracy. In figure 5, we give the running time on a data set with 17295 leaf nodes, with a fixed noise p n =4  X  , when different constraint sets are considered. From #2, each time one constraint is removed in the experiment. At #4, con-straint 4 is removed. Since the only way to fix constraint 4 is to set  X 2006/1/1 X  to a variable, the total repair numbers are the same at #3 and at #4. There is a sharp decrease in the running time, because to remove a constraint from a related constraints uni t will greatly reduce the number of possible mend can-didates, and also simplify the chase approach for this unit. The situations at #5 and #6 are similar, where constrain t 3 and 2 are removed respectively. At #6, only the three functional dependencies(keys) are considered. If we consider only functional dependencies, the chase method in definition 7 can be simplified. Since it it clear that node insertions have no effect on the correction of violations caused by functional dependencies. In this paper, we study the data inconsistency problem for XML. Based on a re-pair framework, we build a prototype syst em to compute repairs for inconsistent XML document. We discuss some key points in the prototype implementation, and evaluate our framework and algorithms in the experiment. We also give a cost model for our repair framework, to evaluate the cost of each repair.
For future work, we will extend our framework to consider more constraints for XML, and make a further study about the computational complexity of our method.

