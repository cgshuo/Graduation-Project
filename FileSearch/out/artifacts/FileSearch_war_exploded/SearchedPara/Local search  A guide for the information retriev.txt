 1. Introduction
There are various tasks in information retrieval that are computationally difficult if not impossible to solve using normal computational methods. These problems can be NP-hard and require the application of combinatorial optimisation methods, particularly the utilisation of local search. There has been a great deal of work in the area, and readers interested in reviews should refer to Chen (1995) and Sebastiani (2002) . Having read the literature, we have identified a number of areas which need to be tackled in order to improve the quality of work in applying local search to IR problems:
Local search techniques are used piecemeal without any thought about what might be the best method for a particular IR problem.

There is no overall overview or structure of how local search can be applied to IR, understanding the available techniques and which local search method is best suited to what task.

Much of the research is methodologically flawed in terms of evaluation techniques, in particular the application and choice of test collections.

In this paper we define a number of IR tasks, and show how local search either has, or could be, used to tackle combinatorial optimisation problems. We propose the following solutions to the problems in applying local search to IR specified above:
We discuss a technique of knowledge based optimizer design through which we can understand local search techniques in general. This gives us a methodology with which we can apply to the problem.
Using the current practice in knowledge based optimizer design we describe how knowledge from the IR domain can be used to inform local search techniques through the application of a Query based taxonomy to various problems in IR. We examine how a methodologically sound experiment can be used to improve the quality of research in the area.
Our overall purpose is to give an outline of the area and provide practitioners in IR who have combinatorial optimisation problems a method with which they can use to conduct their experiments. The evidence used to build this advice comes from current practice in both areas from the literature, theory in the area of optimizer design and the experience of applying techniques to various problems by both authors. However, limitations of these techniques lie mainly in their effective design e.g. Papadimitriou and Steiglitz (1982) note that  X  X  X he design of effective local search algorithms has been, and remains, very much an art X .

The paper is structured as follows. We describe local search using an example from IR in Section 2, from research done so far with hillclimbers. Extensions to hillclimbers for IR are then described in Section 3, providing an overview of the various neighbourhood search techniques and giving references for further reading  X  though the reader is directed to other introduc-tions ( Osman &amp; Kelly, 1996; Osman &amp; Laporte, 1996;Osman, 1995;Reeves, 1993 ). The concept of knowledge based optimizer design is outlined in Section 4. In Section 5 we then outline how local search techniques can be used in IR using a Query based taxonomy, and then outline ideas for good practice when applying local search methods to IR problems in Section 6 by discussing the issue of evaluation. A conclusion is given at the end and we discuss the implications of the research. 2. What is local search?
Local search is a method which can be applied to computationally complex problems (which therefore cannot be com-pleted in a reasonable length of time). In this class of problems there is no specific algorithm or heuristic which can be ap-plied to solve the problem in its entirety. An example of the application of local search are hillclimber techniques used by the
City University Okapi team on the routing track at the text retrieval (TREC) conference run by NIST ( Voorhees &amp; Harman, 2000). This is the process of using relevant documents from a training set to produce a set of terms to be applied to a test set. When choosing terms from a training set, the reader can imagine that normal relevance feedback techniques ( Robertson, by Robertson (1990) for limited query expansion. In limited query expansion the number of terms would normally be re-stricted to the 15 X 20 range. However, a further process can be applied by increasing the initial set of terms to say 200 and try to find the best possible combination of terms from this term set. This cannot realistically be done as the computa-tional requirement is of order O(2 200 ), therefore optimisation techniques must be used in order to select a good set of terms from this second stage process  X  it is known as a Combinatorial Optimisation Problem or COP. Using this example we can give a more precise definition of local search in IR terms.
 Consider a combinatorial optimisation problem (COP) which has the form: A space of possible solutions, S , with possibly constraints on valid solutions.
 A  X  X uality X  for each solution, quality(s) where s e S .

Where the objective is to find a solution s such that quality(s) is maximised and the constraints satisfied. In the context of the Okapi experiments described briefly above the space of all possible solutions is the power set of terms, and an example of the quality of the solution is average precision. Other evaluation measures have been tried in these experiments, but it has been empirically found that average precision is a good predictor of other measures, but other measures are not good pre-this issue below in Section 6.2.

Such problems are usually NP-hard (Garey &amp; Johnson, 1979 ) and therefore, for a problem of large enough size, the time taken to find an optimal solution by exact methods will become prohibitive. Fortunately, in practice a  X  X ood enough X  answer in the time available is all that is required, which opens up the possibility of using heuristic methods that do not guarantee optimality, but work well in practice. A good enough answer in our example would be to produce a term set which would produce better results on the test set than just using the initial set of terms from relevance feedback.
 One heuristic approach would be to employ some form of hillclimbing that requires the following decisions to be made: Find a suitable encoding scheme for the candidate solutions in S , such as a list/matrix of average precision scores. Choose a quality metric for each solution, quality(s ), such as an increase in average precision.

Utilise a method of modifying an encoded solution to give another solution (a move operator) e.g. add/delete terms from term set, or adjust weight for term/document pairs (reduce weight, increase weight).

There is usually more than one possible solution (valid or invalid) that can be produced by applying the move operator on a given solution, therefore we define a neighbourhood, N(s , m ), as the set of solutions in S that are produced by applying the move operator, m , on a solution s . Once the above have been defined, the general algorithm is quite straightforward and is described below: Generate an initial solution (in our example the top three ranked terms from relevance feedback) and evaluate it.
Apply and evaluate a move in the neighbourhood of the current solution and apply an acceptance criterion to decide whether to use the new solution e.g. add a new term and evaluate its usefulness using average precision.
 Go back to step 2 until a termination criterion is reached.

The termination condition is merely when the user would like to stop the search. Examples would include when a certain amount of CPU time has elapsed, or when a solution of a certain quality has been found. In the Okapi experiments the ter-mination conditions included a limit of 100 iterations for term selection and when no increase in average precision was found in a single iteration ( Robertson et al., 1995 ). The acceptance criterion determines whether a new solution generated by a move operator replaces the current solution, and introduces a bias towards better solutions in the search. Acceptance criteria, and thus hillclimbers, can be broadly classified as follows:
Any-ascent hillclimbers (AHC) accept moves that give (new) solutions, which have better or equal quality than the current solution, curr (i.e. accept when quality( s new ) P quality( s moves are tried in a random order. Not used on Okapi experiments.

First-ascent (FAHC) hillclimbers operate similarly, but take the first improvement in quality found (i.e. accept if qual-ity( s new ) &gt; quality( s curr )). Okapi algorithm: choose first positive (Robertson et al., 1995 ).

Steepest-ascent (SAHC) hillclimbers, systematically evaluate the entire neighbourhood of the current solution and accept the most improving move (i.e. accept if quality( s_ best) &gt; quality( s_ curr ) and quality( s Okapi algorithms: Find Best and choose all positive (Robertson et al., 1995 ).

The bias introduced by the acceptance criterion, though necessary, can lead to problems. This happens when an implicit assumption is made about the landscape (Tuson, 2000 )  X  which is a graph induced by the move operator and quality function that connects solutions accessible to each other by a move operator  X  is correlated in such a way as to lead the hillclimber into a region of the landscape with high-quality solutions. Deviations from this ideal can lead to the hillclimber being de-ceived (the correlations lead the hillclimber away from the optimum), or stuck in local optima. This can force the hillclimber to choose a set of terms which may not do so well on the test set, causing overfitting. Overfitting of terms on the training set remove terms strategy in Okapi hillclimbing (Robertson et al., 1996 ). 3. Extending the hillclimber
The most common type of meta-heuristic, commonly known as neighbourhood (or local) search, extends hillclimbing in some fashion, usually by relaxing the acceptance criterion, so to escape local optima. Thus they can be placed in a common implementation framework such as described by the pseudo-code below (Rayward-Smith, 1994 ). described later, are the exception to this rule. With the problem encoding, move operator(s), quality measure specified, and by defining the above functions appropriately, any of the versions of neighbourhood search described in the remainder of this paper can be implemented. In the following sub-sections, we show how the hillclimbers can be extended to tackle the term selection problem below, using the example of the Okapi experiments discussed above. 3.1. Iterated hillclimbers and GRASP
One way out of the problem of local optima is to restart the hillclimber with a different initial solution when a local opti-mum has, or is suspected to have, been found. This is known as iterated hillclimbing. A common criterion for restart is when a certain user-defined number of evaluations have been made without an improvement in solution quality. The search will then resume in a different part of the search space, with a different, and possibly better quality, local optimum. neighbourhood_search() initialise( P );// generate starting solution(s) while(!finished(P)) Q = select_solution( P ); // choose solution(s) to perturb R = create_moves( Q ); // apply move operator(s) P = merge_sets( P , Q , R ); // merge to obtain a new set P END while END neighbourhood_search
A variant of this, GRASP, greedy randomised adaptive search procedure ( Feo, Bard, &amp; Claflin, 1991 )  X  a trade mark of Opti-mization Alternatives, Austin, Texas, incorporates a construction phase where the new starting point is generated using a greedy algorithm which is then followed by a local search improvement phase. The intelligent initialisation procedure used in GRASP attempts to start the search in the vicinity of good solutions. More emphasis is thus placed on the initialisation procedure than the other components of neighbourhood search, to the extent that its design is highly problem-specific and it often is adaptive in nature, making use of past experience in the search. This contrasts with the role of the improve-ment phase which is merely to locate a local optimum. Applications of GRASP include vehicle routing ( Hjorring, 1995 ), and single machine scheduling ( Feo, Venkatraman, &amp; Bard, 1991 ). A review of other applications, such as flight scheduling for selection problem by restarting the selection process when the top average precision  X  X eak X  is reached and continually reus-ing evidence from a number of term selection runs to improve the final result. 3.2. Simulated annealing
Simulated annealing (SA) is based upon an analogy between optimisation and the annealing process in physics ( Kirkpa-limbing with a modified acceptance criterion that accepts lower quality solutions with a probability (the Metropolis criterion) given by the equation below where T k is the  X  X emperature X  at time-step k . In plain English, the temperature controls how likely it is for a lower quality solution to be accepted, and thus allows SA to escape local optima; i.e. low quality differences/high temperatures indicate a higher probability of acceptance of a lower quality solution. At T = 0, SA is equivalent to SHC.

The temperature varies with time according to a cooling schedule where, usually, the temperature is reduced as the opti-misation progresses. This allows exploration of the search space at the start of the search, followed by exploitation of a prom-ising region later on. The technique-specific choices of initial and final temperatures and the form of the cooling schedule are important in order to obtain a balance between exploration and exploitation (also termed intensification/diversification).
However, there is no reason why the cooling schedule should be of any particular form, or even monotonically decreasing  X  the choice is problem-dependent. That said, two common cooling schedules that generally work well ( Lundy &amp; Mees, 1986), are given below
Work on SA has looked at the theory (Hajek, 1988 ), cooling schedules ( Lundy &amp; Mees, 1986 ), and applications of SA such as sequencing ( Ogbu &amp; Smith, 1990; Osman &amp; Potts, 1989 ), timetabling (Abramson, 1991 ) and the Steiner problem in graphs (Downsland, 1991 ). Further information on SA can be found in a variety of sources ( Collins, Eglese, &amp; Golden, 1988; Van Laarhoven &amp; Aarts, 1988 ; Aarts and Korst, 1989).

This technique has been used in Okapi routing experiments, with disappointing results ( Walker, Robertson, &amp; Boughanem, 1998). A very simple simulated annealing process was tried, reducing the  X  X emperature X  at a number of stages for term re-weighting, until a zero or  X  X uench X  temperature was reached. Unlike the hillclimbers used in previous experiments on Okapi, terms which actually decreased the average precision were kept, but with a probability which decreases with the current temperature. This was done so that the term selection process could escape from a local maximum (which the hillclimbers were unable to do). The results on the training set were encouraging when using the re-weighting operation, but when the was overfitting terms on the training set. A deterministic re-weighting process was combined with a mild simulated anneal-ing mechanism, which gave a noticeable increase on the training set, but the authors were unable to demonstrate an improvement on the test set. It was noted that a significant number of tuning parameters would need to be investigated such as the temperature reduction function, the re-weighting process (which terms to choose, how to vary the re-weighting), and rules for both ending a stage in the procedure, and the simulated annealing process itself. This method was not investigated further with respect to the term selection process. 3.3. Threshold methods
Threshold methods are additional extensions of stochastic/any-accept hillclimbing, that use the idea of a threshold which sets a level below which new solutions will not be accepted (i.e. acceptance is deterministic). For similar reasons to SA, the threshold, L k is time varying. Threshold methods including the following:
Threshold accepting (TA) accepts a new solution if its quality is not below a set threshold relative to the current solution (Dueck &amp; Scheuer, 1990) (i.e. accept if quality( s new
Record-to-record travel (RTRT) accepts a new solution if its quality is not below a certain threshold relative to the best solution or record found during the search so far (Dueck, 1990) (i.e. if quality(s
The great deluge algorithm (GDA) accepts a new solution if its quality is not below an absolute quality threshold  X  the current water-level (Dueck, 1990) (i.e. if quality( s new
These techniques differ in the way the threshold is used. For all of these techniques it is usual to vary L referred to the papers (Althofer &amp; Koschnick, 1991; Sinclair, 1993 ).

This scheme was not used in Okapi term selection experiments but it is easy to see how two of these schemes could be used to augment the optimisation process. For example RTRT could be utilised by using something like a 0.05 limit on increase in average precision, below which evaluations are rejected. The GDA would not be a useful method for term selection as there are no absolute values for average precision, which can vary significantly with the set of topics, and from topic to topic. 3.4. Evolutionary algorithms
Evolutionary algorithms (EAs) are based upon the theory of evolution by natural selection ( Darwin, 1859 ). A population of idea behind them is the same and the differences can be considered historical. As an example of the concept, the following describes a simple EA with steady-state reproduction: 1. Generate an initial population of solutions. 2. Select two parent solutions from the population according to their quality. 3. Apply move operator(s) to generate a new solution, s new 4. If s new is superior to the worst member of the population, s 5. Go back to step 2 until the termination criterion is reached.

There are many flavours of EAs, as almost all of the stages have a wide choice of alternatives; however, all have popula-tion-based acceptance criteria as a set of solutions are maintained and a new set of solutions are produced by applying the available move operator(s) and then somehow merging the two sets. Two types of moves are commonly used: mutation (roughly analogous to asexual reproduction), which is equivalent to the conventional move operator, and a binary move operator, crossover (roughly analogous to sexual reproduction) which selects two candidate solutions and (probabilistically) swaps information between them. An example is  X  X wo-point X  crossover which randomly picks two-points along the strings and swaps the contents of the string between those points, to produce a child as shown in Fig. 1 .

The usual rationale for why crossover is a useful search operator is that the recombinative process can bring together por-tions of separate strings associated with high fitness to produce even fitter children. Both the population-based nature of the search, and the crossover operator help to avoid the search being trapped in local optima.

Unfortunately, some practitioners still equate EAs with encoding solutions as binary strings  X  due to a misunderstanding of early theoretical work on the schema theorem (Holland, 1975 ). This is simply not true ( Radcliffe, 1992 ) and successful EA applications use whichever encoding is appropriate to the problem. Such applications are extremely varied, covering fields as applications in OR include: sequencing problems ( Reeves, 1995 ), vehicle routing (Thangiah, 1995 ), and timetabling ( Corne,
Fang, &amp; Mellish, 1993 ). A variety of textbooks are available though Michalewicz (1992) is a good starting point for those interested in how to apply EAs, whereas the more recent  X  X andbook of Evolutionary Computation X  is recommended for its in-depth coverage of the field (Baeck, Fogel, &amp; Michalewicz, 1997 ).

An example of the way this would work with term selection would be to generate some strings of the term set size, with each element of a string representing either the absence or presence of a term. Average precision scores for these strings would then be generated, applying move operators and replacing the worse average precision scores until a termination con-dition was reached. This scheme could be extended for term reweighing by assigning a positive integer for each element of the string to indicate not only the presence of a term, but the level at which it would be re-weighted. 3.5. Tabu search
Tabu search (TS) ( Glover, 1990 ) is based on steepest-ascent or first-ascent hillclimbing, and avoids local optima in a deter-ministic way, based on an analogy with memory, which centres on the use of a tabu list of moves/solutions (or their features) which have been made/visited in the recent past (tabu tenure) of the search. Applications of TS include: vehicle routing the acceptance criterion of the hillclimber is altered slightly so that if no improving move can be found after the neighbour-hood has been fully examined, then the move that gives the least drop in quality is taken. Then a basic form of memory, recency, is used, which is short-term in nature. In essence, any move/solution that is on the tabu list cannot be made/revis-ited; this prevents the search cycling in an already explored area of the search space.

In addition, aspiration criteria can be used to override this mechanism under certain circumstances (e.g. when making a tabu move would lead to a higher quality solution). As neighbourhoods can be quite large and thus expensive to search fully, candidate list strategies are often used to choose subsets of the neighbourhood to search. An alternative approach is to use some form of cheap, but approximate, evaluation procedure.

A form of long term memory, frequency, can be used to direct the search by adjusting the quality function (e.g. solutions closer to a frequently visited area of the search space are penalised more than distant ones). Other forms of memory are: quality, which refers to solutions of high-quality, and is often used to intensify search in the region of good solutions; and influence, which is a measure of change in solution structure, and often used as part of an aspiration criterion. Of course, all of these memory structures have to be defined for the problem being solved.

Examples of research in this area include dynamic rules for tabu tenure (Battiti &amp; Tecchiolli, 1994 ), hashing functions to recency-based approach with a simple neighbourhood structure and a restricted candidate list strategy will often produce good results (Reeves, 1993 ). For more information, the reader is directed to Glover and Laguna (1997) .

In the context of Okapi experiments, this would require a term removal from the current working set, and the term that yields the least reduction in average precision is chosen for removal. This term is recorded in the tabu list to prevent any reduction in average precision. Generic aspiration criteria could include making a term non-tabu if using it leads to a better solution than the current best. One way to use long term memory is to keep sets of terms already examined and to reduce average precision by say 0.1 if the optimizer attempts to use that particular set of terms again. 3.6. Related methods
Another technique that fit into the framework of neighbourhood search is iterative repair ( Zweben, Davis, Daun, &amp; Deale, 1993), which views moves as  X  X epairs X  to flaws in the solutions and has been successfully applied to coordinate space shuttle ground processing, and tabu thresholding (Glover, 1995 ), which is a variant of TS that replaces some of the memory struc-tures in TS with a form of randomisation. Needless to say, hybrids of all of the techniques described here are also possible.
Meta-heuristic techniques also exist which are not local search-based, though they are less commonly used. However, two are worthy of mention. Ant systems are based on the use of pheromone trails by ants (Dorigo &amp; Gambardella, 1997 )  X  a population of  X  X nts X  makes a path through the solution construction process, where the choice at each stage is balanced between following the trails of other ants, and what a greedy heuristic would decide. Finally, Hopfield nets arose from neural network research on associative memories and can also be used for optimisation (Hertz, Krogh, &amp; Palmer, 1991 ). 3.7. Genetic programming
One sub-area of evolutionary computation/local search that is worth mentioning separately is that of genetic program-ming (GP) ( Koza, 1992 ). Though the original idea was to evolve computer programs, for our purposes GP can be best thought of as the use of an EA to optimise mathematical functions represented as trees. The leaf/terminal nodes indicate variables and constants that are successively operated on by function nodes on their way to the root node, giving the final result.
The choice of the terminal and function nodes is user (and also problem) dependant, and GP can potentially be used for any application that a neural network can, e.g. regression and classification. However, GP does have one distinct advantage. If the function nodes are chosen well, the trees evolved by GP can be readily interpretable. One notable example was the use of
GP, with a set of function nodes corresponding to Monod kinetics, in the identification of the kinetics of a fermentation pro-cess ( Pohlheim &amp; Marenbach, 1996 ). The results provided valuable insights into the process for the chemists and biologists working on the process.

In addition the tree structure of GP allows the tree to be of whatever complexity is needed to solve the problem, whereas the complexity of a neural network is constrained by the user X  X  chosen network configuration. However, as this could affect neural networks text such as (Masters, 1993 ) because issues such as overfitting, data preparation, and validation, are equally applicable in GP. 4. Knowledge based optimizer design
Local search optimizers are considered weak (need little domain knowledge) and heuristic (not guaranteed to find the optimal solution); therefore they are not suitable for all problems and should not be considered a panacea. Practitioners should first ask, can the problem be solved exactly by complete search? Also, it should be asked whether human/current performance is  X  X  X ood enough X  (or all that can be achieved)? Although local search optimizers are relatively straightforward to understand, care does need to be taken in their design and evaluation. Practice in both the IR and optimisation literature produce the desired performance in practice.

In general, the guiding principle today seems to be  X  X  X ould the algorithm to the problem, not the problem to the algo-been applied to a wider range of problems, it has been increasingly found that many do not map well into a binary string-or vector-based representation. Thus, workers have been driven to experiment with more natural representations and opera-tors and have often found success by doing so. Secondly, and more fundamentally, the  X  X  X o free lunch X  theorems of Wolpert and Macready (1995) state broadly that, for any algorithm, any elevated performance on one class of problems is exactly countered by poorer performance on another class. Thus, an optimizer tailored for a specific application by the incorporation of problem-specific knowledge in the encoding and operators is likely to outperform a canonical,  X  X  X lack-box X  implementa-tion. However, it is not enough just to say that domain knowledge is important, guidelines are required on how to approach a problem, extract the salient features, and to map these onto the optimizer. Therefore the design of local search optimizers remains very much an art, and a  X  X ethodological gap X  remains between the literature, textbooks, and the application of these techniques that needs to be addressed (Tuson, 2000 ).

Despite the above discussion and the record for IR applications and local search, the question of how to design an effective optimizer is non-trivial and remains an ad hoc process, partly (but not wholly) due the lack of an effective theory. In this context the need for a knowledge based design approach for local search is required. One recent approach ( Tuson, 2000 ) is based on the idea of viewing optimizers as knowledge based systems (KBS):  X  X  X  computer system that represents and uses knowledge to carry out a task X  (Stefik, 1995 ). Furthermore the AI community has, for many years, been addressing the prob-lems of how to design a knowledge based system (KBS), and therefore if we could place these optimizers into a KBS frame-work, then the reuse of the extensive research into KBS design may be possible.

One such useful concept from the KBS literature is the distinction made between the knowledge level (the description of what domain knowledge is present in the system), and the symbol level (the description of how the knowledge is repre-sented in the system  X  the data structures used and their operations on them) (Newell, 1982 ). The design of optimizers is, at present, conducted primarily at the symbol level, and therefore the knowledge/domain assumptions made by the opti-mizer designer are implicit, and may well not be properly utilised. A knowledge level analysis would make these assump-tions explicit and ensure that they are fully considered in the optimizer design. To this end (Tuson, 2000 ) proposes that domain knowledge used by an optimizer can be split into three roles:
Problem-solving knowledge  X  this assists the search by providing problem-specific knowledge that structure and guides the search.
 Problem specification (goal) knowledge  X  specifying what are desirable solution(s) (i.e. the evaluation function).
Search control knowledge  X  given a defined search space, how do we go about searching it? Our knowledge of the search process is represented here.

Given that we would be interested in exploiting knowledge of a user X  X  information needs it would appear that problem-solving knowledge role is most relevant. However, exactly what is meant by this? A working definition is that it is all of the knowledge that can be directly related to the problem itself, and which is not involved with specifying the quality of a solu-tion. This allows for a clean separation from the technique-specific aspects of the search algorithm. Once these roles have been defined, then there are various types of knowledge sources available that need to be identified  X  some example opti-mizer problem-solving knowledge sources are outlined below: Problem features that correlate with solution quality (i.e. the decision variables).
 How these features interact (as strongly interacting decision variables could be usefully considered as a single unit). Areas of the search space which could be excluded from the search (to allow reductions of the size of the search space).
Areas of the search space where good solutions lie (as an initialisation strategy could be used to start the search in a poten-tially productive region).

Some reflection should suggest to the reader that the above sources could be framed as questions that an IR practi-tioner would be able to answer in his role as a domain expert without necessarily having any expertise in optimisation.
In addition ( Tuson, 2000 ) shows that the above sources can be formalised in such a way that suitable evolutionary algo-rithms (EA) crossover and mutation operators (or equivalent local search operators) can be derived. Therefore it appears possible that, in the future, optimizer design will centre on the modelling and acquisition of expert knowledge, rather than algorithm design in much the same way that the KBS community has been advocating (Motta, 1997 ). Furthermore, KBS methods such as those used for knowledge acquisition should allow the designer to more effectively take out the required domain knowledge. Such knowledge based design approaches should help ensure the scalability of IR applications in the future.
 5. How can local search be used in IR?
The discussion so far indicates that there are three classes of design choices that are made in using local search methods in practice: How solution quality is measured using a fitness function; What encoding and operators are used, and; What local search method is used and how it is configured.

The first issue is a specification of what the IR practitioner considers to be a good solution. Often this is straightforward, only where there are multiple objectives or a constraint upon solution feasibility does the user need to think carefully (these are situations where the standard texts can provide guidance). The examples presented here should also be helpful.
The second point refers to the use of domain knowledge in the design of the local search optimizer as described earlier in the discussion on knowledge based design. It is here that the insights of the IR practitioner can be brought to bear most effectively.

The third class of design choice would appear at first glance the most important, after all, we are addressing local search. However, it should be considered secondary. The reason is that it is impossible to say in any meaningfully general way that a particular local method is more suited to a given task than another. This is borne out by practical experience as well as theoretical results such as the no free lunch theorems (see Section 4 above). In any case, they are based on similar assumptions as all are based on hillclimbing in some manner. It is the fit of the overall optimizer, in terms of its domain knowledge, to the problem that is the key to its success. In fact, practitioners would be well advised to start with a simple hillclimber in the first instance and focus on domain knowledge before considering more complex local search methods.

So the fit between the overall optimizer design and the task to be solved is key. Therefore, it is useful to give the reader a taxonomy within the context of the IR tasks that local search may be applied to. This allows the focus to be rightly put on issues that relate to the problem domain such as the suitability of the problem representation to the task. We put forward a query based taxonomy, showing elements of a query to which optimisation can be applied. For each of the components of this taxonomy we state what can be done via local search and describe some current work in the area for each. Some of these can be done in conjunction with each other e.g. term selection with raw weight optimisation (e.g. okapi) or in isolation. This should help the IR practitioner to relate their problems to local search optimizer decisions. The purpose of the taxonomy is therefore to provide the domain information needed for the knowledge based optimizer design process.

We describe a number of tasks to which local search can be applied, and we then discuss the kinds of uses that local search techniques can be applied to in terms of both matching and term operations. Examples of work done in the area are provided (see Fig. 2 ).
 5.1 Tasks in IR
We define an IR task as a process which has its own functionality, but which may on occasion share some processes. This are as follows:
Ad-hoc and interactive search: A user types in a query to resolve a current information need and uses query modification techniques such as relevance feedback to refine their query. Local search could be useful in matching queries to docu-ments, optimising relevance feedback and providing adaptive user interfaces. Mathematical logic in search models is important here. It is difficult to use such techniques for real time search, but prior or post processes to search such as parameter optimisation for term weighting schemes are valid applications.

Information filtering: A user has a long term information need and poses a query. Documents are  X  X ushed X  through this query and filtered to the user. Optimisation techniques are very useful for this task (more details are given above). The techniques can be extended to social groups (collaborative filtering) as well as individuals. A  X  X rofile X  query is created by this task.

Text classification: A  X  X ueryless X  task at least initially. Organises text into groups or classes either by learning on the text itself (unsupervised) or by using evidence from pre-defined categories or taxonomies (supervised). A lot of clustering work has been done on this task. It can be thought of as another type of indexing process.

Topic detection and tracking: Another  X  X ueryless X  task, akin to text classification and filtering, but more refined in that it is split up into two main subtasks of topic detection (a classification task) and tracking (a filtering sub-task). A profile query can be created by this task.

We will use these tasks in our discussion below using examples from the literature. 5.2. The role of the fit between technique and task
As noted above, we cannot match the technique and task without consideration of the particular problem at hand, with the relevant domain knowledge. A task, having its own particular functionality, will place requirements that will be different for that unique functionality, but will share some requirements with other tasks where functionality is shared. For example, most tasks will require some kind of ranking mechanism (apart from the case where Exact Match operators are required), while lexical analysis of terms is done at indexing. Techniques can also be applied to more than one element of the taxon-omy, as in the Okapi experiments where both terms selection and term weights were optimised. There are some cases where local search techniques could be applied to any given task for a particular part of the taxonomy (see the discussion on stem-ming below).

The practitioner must consider the issue of how a query (or profile in the case of some  X  X ueryless X  tasks) from a given task is represented (Chen, 1995 ). For example, weights may be best represented as a vector of floating-point numbers, and a term selection task as a binary string, one bit for each term to be included/excluded. In GAs, a query can be represented by a chro-mosome, where each query term is represented by a gene. Each gene can either represent the presence or absence of a given term, or a more complex entity which represents a term together with its weight. Operators on chromosomes such as cross-over ( Vrajitoru, 1998 ) can be investigated, in order to ascertain which is best for a particular task. In neural networks, associations between terms or between terms/documents can be established with the links assigned some weight (a floating-point number). Methods such as back propagation can then be investigated over the networks created by these associations ( Chen, Shankaranarayanan, She, &amp; Iyer, 1998 ). 5.3. Matching operations
The first major class of operations to be considered is matching operations i.e. taking a query and applying an operation to retrieve a set of documents which  X  X atch X  that query. This usually means taking sets retrieved from inverted lists ( Harman,
Fox, Baeza-Yates, &amp; Lee, 1992 ) and merging them together to create a final set for presentation. Two major types of opera-tions in IR are defined: exact match ( Wartik, 1992 ) and best match (Harman, 1992b ). 5.3.1. Exact match Local search is applied to the information filtering task, where the requirement is to build a Boolean query user profile.
Exact match operators such as Boolean (AND, OR, NOT) and Adjacency (phrases, same sentence, same paragraph) can be opti-mised in conjunction with the query terms they are applied to. Genetic programming (GP) has been applied to this problem. The query is treated like a program, and different forms of the query are  X  X volved X  and evaluated against the fitness function.
Cordon, Herrera-Viedma, and Luque (2006) use a multi-objective pareto based evolutionary algorithm to optimize Boolean queries. Smith and Smith (1997) use a GP method which creates an initial 1000  X  X oolean X  organisms using the terms set and three Boolean operators (AND, OR, NOT),  X  X reeding X  the organisations until some optimum is reached. Fernandez-Villacanas Martin and Shackleton (2003) compare a GP with a GA using a number of fixed bits for genes to represent function types and negation. Both of these methods are based on decision trees. Cordon, Moya, and Zarco (2002) also use GP on fuzzy sets, where a fuzzy set weight is generated and optimised using a simulated annealing process  X  this method is a hybrid Best/Ex-act match scheme. 5.3.2. Best match
Best match operators, unlike exact match ranking documents given some order, usually based on the motive of retrieving more relevant documents higher up the rank. In order to do this, term weighting schemes assign a weight using some func-tion that utilises collection statistics such as inverse document frequency (IDF) and term frequency (TF). There are two main way of optimising this information; applying a technique to a pre-defined weight or learning a function from a set of given parameters. Optimisation on this aspect is applicable to virtually all tasks in IR, although for the ad-hoc task this will mean offline processing as real time support for optimisation operations would be very hard to support.
 With respect to learning on a pre-defined weight, the usual method is to use some matching function model such as
BM25 and optimise the weight by varying it. A scenario could be envisaged where no matching function was used, and a random weight generated to be optimised on. In IR terms this would be theoretically very suspect, as matching functions such as BM25 would do far better than random weights, and matching on pre-defined weights produced by the former would provide a better initialisation in the search space. Some examples of work done in this area include Martin-Bautisata,
Vila, and Larsen (1999) , who learn weights on fuzzy set genes and Horng and Yeh (2000) who use a GA to adapt pre-assigned weights produced by the vector space model. Other types of evidence can also be used to adapt weights. Lam, Wang, and Yue (2003) use link information to optimise weights for documents on an information filtering task. Belew (1989) used a NN to adapt weights on links between authors, documents and keywords. A disadvantage with this method is there is no trail of evidence as to why a particular weight has been produced.

However, optimising on functions does produce evidence  X  a list of parameters which have been produced during train-ing. These parameters can either be variables such as term frequency or tuning constants such as K1 and B used in the BM25 weighting function (Robertson et al., 1995 ). As with Best Match operators, weighting functions can be treated as programs, and optimised using Genetic Programming techniques. Fan, Fox, Pathak, and Wu (2004), Fan, Gordon, and Pathak (2004a, 2004b,2006) learn ranking functions per query on variables only (no constants are used), the argument being that there is no best match function for a query or query set. Alternatively Burges et al. (2005) learn ranking functions using NN gra-dient descent methods utilizing a function based on a preferable ranking for documents  X  the ranking from each instantiated parameter value is compared with this preferred value, and the NN learns accordingly. Taylor, Zaragoza, Craswell, Robertson, and Burges (2006) compare this method with line search, and conclude that gradient descent appears to be a very useful method for such a task and that gradient descent and line search track each other quite closely with respect to final model effectiveness. There is also considerable interest in optimising tuning parameters for weighting functions. For example the
BM25 weighting function will require values for each K1, B constant pairs when undertaking XML retrieval  X  the number of values depending directly on the element set size (Wei, Robertson, &amp; Macfarlane, 2006 ). In structured document retrieval element parameters for weighting functions can also be optimised: Trotman (2005) uses a GA to learn field parameters for each node of the XML tree using a range of 0 X 1 with each parameter  X  each node in the tree being a gene, the chromo-somes representing the flattened tree. Choosing values for constants can therefore become a significant issue, and can quickly become unmanageable for any manual selection method. In such cases local search can provide a reasonable solution. 5.4. Term operations
The second major class of query operations is on the terms which constitute the  X  X uery X  and are the source for matching operations (see above). Term operations are divided up into two main types, term selection using relevance feedback (Harman, 1992a ) or operations individual words such as stemming (Frakes, 1992b ). 5.4.1. Term selection
Local search is useful for tasks which need to optimise a set of terms e.g. information filtering, text classification and topic detection and tracking. For the most part this optimisation process works on the presence or absence of terms in a query, as described in the Okapi examples above. Other examples include Chen et al. (1998) who use a GA in conjunction with an SA in order to optimise term selection. Queries can be treated as fixed size or variable size entities; the Okapi experiments used the former, whereas Lopez-Pujalte, Guerrero-Bote, and de Moya-Anegon (2003a) used a variable size chromosome together with a binary representation for a gene. Wong, Cai, and Yao (1993) describe the process of learning a term association matrix using NNs. i.e. relationships between terms. The strength of relationships are fed in to the NN; relationships are therefore learned, not the strength of them (there is no reason why optimisation could not be applied to each relationship). Terms for a given query can then be selected on the back of the relationships identified in the learning process. Tamine, Chrisment, and Boughanem (2003) and Boughanem, Chrisment, and Tamine (2002) describe a technique that evaluates multiple queries using population niches and merging the results. Niches are sections of the population which are allowed to evolve indepen-dently. Mock and Rao Vemuri (1997) and Mock (1996) describe a global hill climbing method to select terms that uses col-laborative evidence from a set of queries rather than evidence from a single queries task, a method targeted at information filtering. This method may be useful for some collaborative tasks, but its use is primarily for tasks that require optimisation for an individual user on the basis of their particular information need. This is a good example of when to use local as op-posed to global search. Global search could usefully be applied to indexing schemes such as stop wording, particularly words which are reasonably frequent, but may be poor search terms in some circumstances. 5.4.2. Word operations
In this context we refer to operations on terms themselves, i.e. the constituent part of the queries being optimised. Word operations include stemming, truncation, lexical analysis and synonym detection. Most tasks use these operations, and therefore local search can be generically applied to word operations in them. Some operations such as stemming and lexical analysis are done at indexing time for the most part and would therefore be candidates for global search techniques (as with stop wording). Query time operations such as truncation would be a more appropriate target for local search. Note that there are some similarities between stemming and truncation, but the former is based on a series of rules while the latter is more free form. We could consider the use of GP for stemming, treating a set of rules as elements of a program and optimising to find the best set for a stemmer. The authors are not aware of any work done using GP, but Mladenic  X  (2002) describes a local search algorithm based on k -Opt, a neighbourhood operator used for the travelling salesman problem, for learning stemmer rules in text classification. Operations on truncation could be used in conjunction with term selection to find good query stems at search time (no work has been identified in this area). Synonym detection is another phrase for dimension reduc-tion; this can either be done at indexing or search time. An example of using local search for dimension reduction is the work by Kuflik, Boger, and Shoval (2006) , which uses a term reduction process similar to term selection, where the number of dimensions is reduced at every iteration until some limit has been reached. The method uses a version of a NN called the
Guteman X  X oger algorithm. 6. Evaluation methods for local search in IR The most appropriate method for evaluation when applying local search to IR is the laboratory style evaluation method. sible for users to feed relevance assessments into a local search process, but this is out of the scope of the paper and we do not discuss it here. The emphasis here is on applying laboratory style of evaluations in a rigorous way when evaluating local search, by looking at the role of test collections and fitness functions. They are used to drive the process of local search and have an impact on the outcomes. We point out how some research in the area has been methodologically flawed, and how these issues can be resolved by looking at benchmarking and test collections as well as fitness functions used in the optimi-zation process. 6.1. Benchmarking and test collections
The Cranfield paradigm has had a significant impact on the evaluation of IR systems over the years, particularly after the advent of TREC. Test collections for benchmarking have been developed including the somewhat small Cranfield set (con-taining 1400 records) and the GOV2 set which is 426 GB in size, and contains 25 million web documents. However, a test collection does not only contain documents. Just as important are the topics or information needs which must be serviced over the document set, and relevance judgements which indicate both relevant and irrelevant documents for that informa-tion need on the given document set. Test collections provide the basic framework for benchmarking and evaluation for local search experiments. There are some very important issues about each element of a test collection which must be considered when choosing such a set for evaluation purposes.

Test collections come in two types, those with special purpose and general purpose document datasets. Examples of both are Cranfield-2 which is a set of abstracts for the area of metallurgy (Cleverdon, 1967 ), and the TREC collection (Harman, 1995) which contains a range of documents including government reports and newspaper articles etc. It is better to use more general datasets as any statements made about the applicability of a method are more likely to be more generally useful; conclusions on an experiment on a special collection may not be so applicable to other types (Frakes, 1992a ). Experiments on specialised collections should be done in the full knowledge of the limitations of those datasets, in particular an under-
IDF, TF) will be very different from larger datasets which are of more interest to users. Early in the field of test collection research Sparck Jones and van Rijsbergen (1976) asserted that small collections  X  X  X re unsatisfactory on purely statistical grounds, and the increasing scale of operational systems makes the results obtained with them appear irrelevant to real sys-tems X . Given the size of the web, this view is strongly reinforced. Hawking and Robertson (2003) provide some theoretical and empirical evidence on the relationship between collection size and effectiveness, in particular that precision at N doc-uments retrieved (P@N) declines with a sample collection. Cranfield, being a set of abstracts for a special area ( Cleverdon, 1976). Local search practitioners have used reasonably sized and general datasets for experiments e.g. Tamine et al. (2003) who use standard TREC datasets and Fan et al. (2004) who use the WT10gb collection (which is 10 GB in size and contains 1.69 million records). Once a collection has been chosen for experimentation, it needs to be separated into training, valida-for training, 21% for validation and 30% for test. Standard datasets used at TREC by Okapi for the routing/filtering tracks use around 2/3 of the collection for training and 1/3 for testing. The Okapi strategy of splitting the training set into extract and select sets is much the same as a split between training and validation sets. This is known as the holdout method. This can be extended by using the K fold cross validation method, where the holdout method is repeated K times. There is very little work on the issue of formally modelling datasets. One example is Cormack and Lynam (2006) , who treat datasets as  X  X ource populations X  in order to examine the issue of random errors in them.

The second strand in a test collection is the set of information needs and topics, which are used for forming the query to be serviced over the collection. The issues of information need type and query set size need to be considered carefully. It should be noted that the issue of query size is not one to be overly concerned about for many tasks, most of which use rel-evance feedback  X  a process that produces plenty of terms. With respect to the type of information need, what we mean is how hard it is to formulate a successful query in order to retrieve relevant documents. If possible, it is best to have a mix of hard and easy topics, as this is more likely to be a reflection of users X  information needs (Sparck Jones &amp; van Rijsbergen, 1976). The number of information needs used in the experiment needs to be of a reasonable size; it is unlikely that any con-clusions drawn from a small query set is transferable to other sets (Sparck Jones &amp; van Rijsbergen, 1976 ). For example, Lam et al. (2003) use seven queries in one experiment for optimising search and 13 in another optimising relevance feedback. The
Cranfield collection does have one advantage, it has 225 information needs associated with it. It should be noted, however, that the number of records returned per query should also be considered together with the query set size. For example,
Buckley and Voorhees (2000) argue that when using web collections at TREC which evaluate only on the top 10 retrieved documents, many more than 50 queries will be needed. They also recommend the use of at least 25 topics, with 50 being preferable.

The third strand of the test collection, relevance judgements, are subjective assessments made by humans on information needs formulated into queries and applied to document sets. They can be negative or positive. Typically the relevance judge-tribution of relevant documents differs significantly between collections (Hawking &amp; Robertson, 2003 ), a further aspect any practitioner should think about when choosing a test collection. With respect to size, there is no rule about how many po-sitive relevance judgements are needed for a particular topic. This number will naturally vary between topics where queries can either be hard or easy to formulate. However, it is a moot point as to how many relevance judgements are needed to make the best use of local search, or, to put it another way, when have enough relevant documents been accumulated for local search to become useful. For the hillclimbers used for Okapi experiments, around 20/30 is approximately the number of positive relevance judgements required to make such a scheme worth while i.e. very little will be gained by using the
Okapi methods on 1 or 2 relevant documents. The number of positive relevance judgements has a direct effect on the fitness function; a topic with few relevant documents and optimised using average precision could quickly finish with a perfect score of 1 ( MacFarlane, 2000 ). It is unclear how this evidence is likely to behave on the test set.

There are a couple of quite contentious issues in IR evaluation generally which impact on any practitioner interested in tween two outputs e.g. a comparison between an Okapi relevance feedback and hillclimbing procedures. Kuflik et al. (2006) normal distribution, while the Wilcoxon is a non-parametric test. Sanderson and Zobel (2005) assert that the t -test is highly
Wilcoxon tests. This issue is somewhat contentious as the underlying distribution of relevant documents in topics is difficult to establish; relevance assessment may differ significantly on the relevant documents for a particular topic, where there can be no agreement at all between the assessors (Voorhees, 1998 ). Care therefore needs to be used when using statistical testing.
The second of these contentious issues relates to treatment of test collections for benchmarking purposes. Sebastiani (2002) asserts that comparisons for classifiers can only be performed when the test collection is the same (identical docu-ments, topics and relevance judgements), the same split between training and test set is used, and finally the same evalu-ation measure must be applied to the test set. Unfortunately this is not the case from the literature in local search in IR, for example Lopez-Pujalte, Guerrero-Bote, and de Moya-Anegon (2002) only use 33 of the 225 Cranfield queries for their exper-iments. Drawing any conclusions from the literature on which is the best local search technique for any given task is there-arise in evaluating local search optimizers, which, given their stochastic nature, require evaluations to be made over a num-ber of runs, e.g. (Christiensen, 2007 ). 6.2. Fitness functions
There is a bewildering array of fitness functions for local search in IR, but there is one common element for them: use of relevance judgements as the primary source of information (see above). Functions can either use positive relevance judge-ments, or use both positive or negative relevance judgements in conjunction with each other. For the most part this means binary relevance assessments, but non binary user assigned scores are used e.g. a score between 0 and 1 is assigned by a user in ( Martin-Bautisata et al., 1999 ). Graded relevance assessments as put forward by Kek X l X inen and J X rvelin (2002) are also be potentially used in fitness functions e.g. using an ideal ranked set to compare the difference between two outputs when using gradient descent methods (Burges et al., 2005; Taylor et al., 2006 ). We divide fitness functions into two types, set-based and rank-based.

Set based functions are used in binary classification tasks (Lewis, 1997 ), which separate documents into accepted and re-do not imply order. The two main forms of set based measures are Precision and Recall, used since the days of the early
Cranfield experiments. In the context of local search for IR, set based functions are largely used on exact match operations, utilise a weighted combination of precision and recall. Recall has also been used as a fitness measure ( Cordon et al., 2002 ).
Other methods for set based fitness functions include one used by Chen, Yi-Ming, Ramsey, and Yang (1998) and Yang, Yen, and Chen (2000) , which utilises the difference between two retrieved sets using a Jacquard scoring mechanism.
Rank-based functions do imply order and are used to evaluate the fitness of best match operators. It has been suggested by Fan et al. (2004) from Lopez-Pujalte et al. (2003a) that order based functions yield better results than set based methods, and this is not inconsistent with evidence found in Okapi experiments. The most popular fitness function appears to be aver-age precision; a recall-based precision measure used in standard IR evaluations such as TREC. This was found to be the best predictive measure in Okapi experiments (Robertson et al., 1995 ). Buckley and Voorhees (2000) assert that average precision is a  X  X  X easonably stable and discriminating choice X  for general purpose retrieval. Others who have used this measure include
Fan et al. (2006) and Horng and Yeh (2000) . Lopez-Pujalte et al. (2002) and Lopez-Pujalte, Guerrero-Bote, and de Moya-Ane-gon (2003b) provide an extensive survey on 12 fitness functions, and found that the choice of fitness function was essential when guiding GAs through the search space. Other examples include use of the Guttman model, a statistical measure of rank correlation which has many of the same properties of average precision according to Tamine et al. (2003) . All rank-based measures evaluate on the top N documents, for example the standard top 1000 retrieved used for TREC style evaluations.
However, not all fitness functions work in this way, for example Utility functions. These are based on the preference of a user for a given document, which can either be based on rank preferences (Fan et al., 2004 ) or based on rewarding ranking mech-anisms which retrieve relevant documents, whilst penalising them for retrieving irrelevant documents. Utility functions are tuned to preferences by some parameters e.g.
 where A and B are relevant and non-relevant documents, respectively, and u non-relevant. Fan et al. (2004) show their rank-based utility functions provide better results than using average precision  X  this contradicts results from the Okapi experiments (see above).

What fitness function is best for a particular task, or element of the taxonomy? For the most part the task itself will deter-mine the fitness function as different tasks imply different evaluation measures e.g. the topic detection and tracking task is evaluated by miss rate (new events not detected and assigned to existing events) and false alarm rate (events already iden-tified incorrectly detected as new events). In some tasks therefore, fitness functions based on average precision are not appropriate. However, slight modifications to average precision may be useful. If the user is more interested in harder topics, geometric average precision (GMAP) may be a more useful measure to use (Robertson, 2006 ). This measure is more sensitive to observations at the lower end of the ranking scale than mean average precision, potentially allowing the local search method to emphasize those elements (e.g. terms) which yield better results at the bottom end.

The stability of the function used is another very important consideration. Stability in this context means the ability to use a fitness function in order to predict a good outcome for another. In recent years the Binary Preference or BPREF function (Buckley &amp; Voorhees, 2004 ) has been put forward for IR evaluation. There has been some debate on the merits of using aver-uments, and do not differentiate between identified and non identified non-relevant documents. When you use measures such as average precision, some important evidence is discarded which could be used to support optimisation. With BPREF the information recorded is pairs of non-relevant documents ranked higher than relevant documents, so preference of non-relevant over relevant documents is explicitly recorded in the function. Buckley and Voorhees (2004) demonstrated that the measure correlated with the original ranking, while mean average precision did not. With small numbers of relevance assessments (say 1 or 2) it is difficult to use BPREF measure as there are too few pairs to usefully distinguish between objects leading to severe overfitting. There is a question on the stability of the BPREF function at low sampling rates  X  correlations little evidence is much use for optimisation problems in IR (see Section 6.1 above).

Should the same function be applied to the training set as to the test set? Taylor et al. (2006) assert that ranked based methods are not efficient in terms of run time for tuning ranking function parameters. They suggest that gradient descent methods using cost functions are far more efficient than fitness functions that depend on ranking of documents (relevant or irrelevant). However, rank-based methods are more in line with what the user wants from an IR system, and attempts to use methods outside of this could pose serious problems.
 7. Conclusion and discussion
This paper has concerned itself with providing an introduction to the neighbourhood search paradigm and the main tech-niques in use today for IR. We have introduced a query based taxonomy for examining local search techniques, which show when optimisation can be applied, and which techniques are appropriate for each element of the taxonomy or a particular task. The paper also examined methodological issues and good practices from the IR and optimisation literature. A number of conclusions can be drawn from this paper.

Though local search optimizers show clear promise and wide applicability, it is hard to say definitely if many of the pro-posed methods have achieved real improvements over conventional IR approaches, a notable exception being ( Robertson et al., 1995 ).

Because of this, comparisons between the different optimizer techniques are hard to make. This is for two reasons; from an IR perspective, inadequate and differing test collections are used in evaluation; from a local search perspective insuf-ficient use of samples and hypothesis testing is made (Hooker, 1995 ).

To take the use of local search in IR forward, frameworks are needed to help IR practitioners relate their experience to the appropriate design choices for local search. As a starting point this paper has proposed a query based taxonomy to assist in decisions regarding what is optimised, and reviewed an approach due to (Tuson, 2000 ) that guides the use of domain knowledge in optimizer design.

The next stage in this area of research is to take the taxonomy and theory of optimizer design and build a framework with which to better inform the practitioner of choices in deploying local search methods. The framework would take account of the known limitations of optimizer design (Papadimitriou &amp; Steiglitz, 1982 ), but would take the taxonomy derived from the literature in this paper to build concepts on which methods can be chosen to solve given problems.

Finally the metaphors used should not be taken too literally. For example, the evolutionary metaphor has expressed itself in a belief that such natural processes inherently possess some additional computational power; examples of this view can be readily found in the evolutionary computation literature. However, the no free lunch (NFL) results discussed earlier and the effectiveness of other approaches such as Tabu Search do speak against adhering to this view too strongly. Furthermore (Glover &amp; Laguna, 1997 ) argue that though such metaphors do have a place, to help suggest ideas from which to launch an investigation, but that problems begin when the metaphor is taken too far and is allowed to define the actual research agenda.
 Acknowledgements
Many thanks to Marcus Andrews for his positive feedback on the paper, and to the reviewers of an earlier draft for their constructive comments.
 References
