 University of Pennsylvania University of Edinburgh tory Categorial Grammar (CCG) derivations augmented with local and long-range word X  X ord coverage statistical parsers that obtain state-of-the-art rates of dependency recovery. expressive grammars from the Treebank, and for the design of future treebanks. 1. Introduction
In order to understand a newspaper article, or any other piece of text, it is necessary to construct a representation of its meaning that is amenable to some form of inference.
This requires a syntactic representation which is transparent to the underlying seman-tics, making the local and long-range dependencies between heads, arguments, and modifiers explicit. It also requires a grammar that has sufficient coverage to deal with the vocabulary and the full range of constructions that arise in free text, together with a parsing model that can identify the correct analysis among the many alternatives that such a wide-coverage grammar will generate even for the simplest sentences. Given our current machine learning techniques, such parsing models typically need to be trained on relatively large treebanks X  X hat is, text corpora hand-labeled with detailed syntactic structures. Because such annotation requires linguistic expertise, and is therefore diffi-cult to produce, we are currently limited to at most a few treebanks per language. and Marcinkiewicz 1993; Marcus et al. 1994), which contains a one-million word and test data for statistical parsers. Its annotation, which is based on generic phrase-structure grammar (with coindexed traces and other null elements indicating non-local dependencies) and function tags on nonterminal categories providing (a limited degree of) syntactic role information, is designed to facilitate the extraction of the underlying predicate X  X rgument structure. Statistical parsing on the Penn Treebank has made great progress by focusing on the machine-learning or algorithmic aspects (Magerman 1994;
Ratnaparkhi 1998; Collins 1999; Charniak 2000; Henderson 2004; McDonald, Crammer, and Pereira 2005). However, this has often resulted in parsing models and evaluation measures that are both based on reduced representations which simplify or ignore the linguistic information represented by function tags and null elements in the original
Treebank. (One exception is Collins 1999, whose Model 2 includes a distinction between arguments and adjuncts, and whose Model 3 additionally captures wh -movement in relative clauses with a GPSG-like  X  X lash-feature-passing X  mechanism.) healthy turn towards quantitative evaluation interacts with the fact that just about every temptation to concentrate on capturing the few high-frequency cases at the top end of the distribution, and to ignore the  X  X ong tail X  of rare events such as non-local dependen-cies. Despite the fact that these occur in a large number of sentences, they affect only a small number of words, and have thus a small impact on overall dependency recovery. gorithms (Blaheta and Charniak 2000; Johnson 2002; Campbell 2004), and integrated parsing with function tags or null elements (Dienes and Dubey 2003a, 2003b; Merlo and
Musillo 2005; Gabbard, Kulick, and Marcus 2006), such approaches typically require ad-ditional pre-or postprocessing steps that are likely to add further noise and errors to the parser output. A completely integrated approach that is based on a syntactic representa-tion which allows direct recovery of the underlying predicate X  X rgument structure might therefore be preferable. Such representations are provided by grammar formalisms that are more expressive than simple phrase-structure grammar, like Lexical-Functional
Grammar (LFG) (Kaplan and Bresnan 1982), Head-driven Phrase-Structure Grammar (HPSG) (Pollard and Sag 1994), Tree-Adjoining Grammar (TAG) (Joshi and Schabes 1992), Minimalist Program X  X elated Grammars (Stabler 2004), or Combinatory Catego-rial Grammar (CCG) (Steedman 1996, 2000). However, until very recently, only hand-written grammars, which lack the wide coverage and robustness of Treebank parsers, were available for these formalisms (Butt et al. 1999; XTAG-group 1999; Copestake and Flickinger 2000; OpenCCG 1 [White and Baldridge 2003; White 2006]).
 there have been a number of efforts to extract TAGs, LFGs, and, more recently, HPSGs, from the Penn Treebank (Xia 1999; Chen and Vijay-Shanker 2000; Xia, Palmer, and Joshi 2000; Xia 2001; Cahill et al. 2002; Miyao, Ninomiya, and Tsujii 2004; O X  X onovan et al. 2005; Shen and Joshi 2005; Chen, Bangalore, and Vijay-Shanker 2006). Statistical parsers that are trained on these TAG and HPSG corpora have been presented by Chiang (2000) and Miyao and Tsujii (2005), whereas the LFG parsing system of Cahill et al. (2004) uses 356 a postprocessing step on the output of a Treebank parser to recover predicate X  X rgument dependencies.
 derivations and dependency structures from the Penn Treebank, together with some observations that we believe carry wider implications for similar attempts with other grammar formalisms and corpora. Earlier versions of the resulting corpus, CCGbank, have already been used to build a number of wide-coverage statistical parsers (Clark,
Hockenmaier, and Steedman 2002; Hockenmaier and Steedman 2002; Hockenmaier 2003b, 2003a; Clark and Curran 2004, 2007), which recover both local and long-range dependencies directly and in a single pass.
 formalism that was specifically designed to provide a base-generative account of coor-dinate and relativized constructions like the following: constructions, including control and raising, via an enriched notion of syntactic types, a  X  X urface-compositional X  syntax X  X emantics interface, in which monotonic rules of semantic composition are paired one-to-one with rules of syntactic composition. The corresponding predicate X  X rgument structure or logical form can therefore be directly known. In this article and in CCGbank, we approximate such semantic interpretations with dependency graphs that include most semantically relevant non-anaphoric local and long-range dependencies. Although certain decisions taken by the builders of the original Penn Treebank mean that the syntactic derivations that can be obtained from the Penn Treebank are not always semantically correct (as we will discuss), subsequent work by Bos et al. (2004) and Bos (2005) has demonstrated that the output of parsers trained on CCGbank can also be directly translated into logical forms such as Discourse
Representation Theory structures (Kamp and Reyle 1993), which can then be used as in-put to a theorem prover in applications like question answering and textual entailment recognition.
 sources of noise and inconsistency in the original annotation that have had to be cor-rected in order to permit induction of a linguistically correct grammar. Because of this preprocessing, the dependency structures in CCGbank are likely to be more consistent than those extracted directly from the Treebank via heuristics such as those given by
Magerman (1994) and Collins (1999), and therefore may also be of immediate use for dependency-based approaches. However, the structure of certain constructions, such as compound nouns or fragments, is deliberately underspecified in the Penn Treebank.
Although we have attempted to semi-automatically restore the missing structure wher-ever possible, in many cases this would have required additional manual annotation, going beyond the scope of our project. We suspect that these properties of the original
Treebank will affect any similar attempt to extract dependency structures or grammars for other expressive formalisms. The Penn Treebank is the earliest (and still the largest) corpus of its kind; we hope that our experiences will extend its useful life, and help in the design of future treebanks. 2. Combinatory Categorial Grammar
Combinatory Categorial Grammar (CCG) was originally developed as a  X  X ear-context-free X  theory of natural language grammar, with a very free definition of derivational structure adapted to the analysis of coordination and unbounded dependency without movement or deletion transformations. It has been successfully applied to the analysis of coordination, relative clauses and related constructions, intonation structure, binding and control, and quantifier scope alternation, in a number of languages X  X ee Steedman and Baldridge (2006) for a recent review. Extensions of CCG to other languages and word-orders are discussed by Hoffman (1995), Kang (1995), Bozsahin (1998), Komagata tions in CCGbank follow the analyses of Steedman (1996, 2000), except where noted. 2.1 Lexical Categories
Categorial Grammars are strongly lexicalized , in the sense that the grammar is entirely defined by a lexicon in which words (and other lexical items) are associated with one or more specific categories which completely define their syntactic behavior. The set of categories consists of basic categories (e.g., S , NP and result category X . Functor categories of the form X / Y right, whereas those of the form X \ Y expect Y to their left. code subcategorization information, that is, the number and directionality of expected arguments. English intransitive verbs and verb phrases have the category verbs have the category ( S \ NP ) / NP : they take an (object) verb phrase ( S \ NP ), which in turn takes a (subject) NP
Each syntactic category also has a corresponding semantic interpretation (here given as a  X  -expression). Hence, the lexical entry for ditransitive give can be written as follows:
In our translation algorithm, we use simple word X  X ord dependency structures to ap-proximate the underlying semantic interpretation. 2.2 Derivations
A universal set of syntactic combinatory rules defines how constituents can be com-bined. All variants of categorial grammar since Ajdukiewicz (1935) and Bar-Hillel (1953) include function application, where a functor X / Y or X \ 358
This derivation is isomorphic to a traditional context-free derivation tree like the fol-lowing (the semantics is omitted): combinatory logic (Curry and Feys 1958), which enable succinct analyses of extraction and coordination constructions. It is a distinctive property of CCG that all syntactic rules are purely type-driven , unlike traditional structure-dependent transformations. Compo-type-raising is a unary rule that exchanges the roles of functor and argument:
For example, the following is the derivation of a relative clause related to (4): algorithm yields normal form derivations (Hepple and Morrill 1989; Wittenburg and when syntactically necessary. For coordination, we will use a binarized version of the following ternary rule schema: 5 ory of grammar, the reader is directed to Steedman (1996, 2000). 2.3 Head-Dependency Structure in CCGbank
The syntactic derivations in CCGbank are accompanied with bilexical head-dependency structures, which are defined in terms of the lexical heads of functor categories and their arguments. The derivation in (6) corresponds to the following dependency structure, which includes the long-range dependency between give and money :
The dependency structures in CCGbank are intended to include all non-anaphoric local and long-range dependencies relevant to determining semantic predicate X  X rgument relations, and hence approximate more fine-grained semantic representations. In sing models of Collins (1999) and Charniak (2000) and returned by the depen-dency parser of McDonald, Crammer, and Pereira (2005). In order to obtain such or raising and control verbs require additional coindexation information (described subsequently).
 dependencies is one of its most useful features for researchers using other expressive grammar formalisms, including LFG, HPSG, and TAG, facilitating comparisons in non-subject extracted relative clauses. Because these dependency structures provide a suitable approximation of the underlying semantics, and because each interpreta-tion unambiguously corresponds to one dependency structure (but may be obtained from multiple, equivalent, derivations), we furthermore follow Lin (1998) and Carroll,
Minnen, and Briscoe (1999) in regarding them as a fairer, and ultimately more useful, 360 standard against which to evaluate the output of parsers trained on CCGbank than the syntactic derivations themselves. 3. The Penn Treebank
The Wall Street Journal subcorpus of the Penn Treebank contains about 50,000 sentences, or 1 million words, annotated with part-of-speech tags and phrase-structure trees:
These trees are relatively flat: modals and auxiliaries introduce a new VP level, whereas verb modifiers and arguments typically appear all at the same level, as sisters of the main verb. A similarly flat annotation style is adopted at the sentence level. NPs are flat as well, with all complex modifiers appearing at the same NP level, and compound nouns typically lacking any internal structure.
 between complements and modifiers. In the Treebank, this information is not explicit.
Although some non-terminal nodes carry additional function tags, such as -SBJ (sub-ject) or -TMP (temporal modifier), truly problematic cases such as prepositional phrases are often marked with tags such as -CLR ( X  X losely related X ) or -DIR ( X  X irection X ), which argument.
 dependencies. These are essential for our algorithm since they make it possible to obtain correct CCG derivations for relative clauses, wh -questions, and coordinate constructions such as right node raising. Their treatment is discussed in Sections 6.2 and 6.3. 4. The Basic Translation Algorithm
In order to obtain CCG derivations from the Penn Treebank, we need to define a mapping from phrase structure trees to CCG derivations, including a treatment of the null elements in the Treebank. We also need to modify the Treebank where its syntactic analyses differ from CCG, and clean up certain sources of noise that would otherwise result in incorrect CCG derivations.
 steps:
Similar algorithms for phrase-structure trees without traces or other null elements have been suggested by Buszkowski and Penn (1990) and Osborne and Briscoe (1998). extend this algorithm to deal with coordination, and introduce a modification to cope processing steps that were necessary to obtain the desired CCG analyses from the
Treebank trees. Section 6 extends this basic algorithm to deal with the null elements in the Treebank. 4.1 Determining Constituent Types: Heads, Complements, and Adjuncts determined, using heuristics adapted from Magerman (1994) and Collins (1999), which take the label of a node and its parent into account. 6 We assume that NP daughters of VP s are complements, unless they carry a function tag such as -LOC , -DIR , -TMP ,andsoon, but treat all PPs as adjuncts unless they carry the -CLR function tag. In our example, PP: 4.2 Binarizing the Tree Next, the tree is binarized:
This binarization process inserts dummy nodes into the tree such that all children to the left of the head branch off in a right-branching tree, and then all children to the right of the head branch off in a left-branching tree. 7 362 4.3 Assigning Categories
We assign CCG categories to the nodes in this binary tree in the following manner: 4.3.1 The Root Node. The category of the root node is determined by the label of the root of the Treebank tree (e.g., { VP } X  S \ NP , { S , SINV , SQ category S , it typically carries a feature that distinguishes different types of sentences, such as declaratives ( S [ dcl ] ), wh -questions ( S [ wq ] (
S [ frg ] ). In our running example, the root is S [ dcl ] head word, the auxiliary, has the POS tag VBZ . 4.3.2 Head and Complement. The category of a complement child is defined by a similar mapping from Treebank labels to categories, for example, {
CCG category of the head is a function which takes the category of the complement as argument and returns the category of the parent node. The direction of the slash is given by the position of the complement relative to the head:
The VP that is headed by the main verb passing is a complement of the auxiliary. Because the POS tag of passing is VBG , the CCG category of the complement VP is participle) and the lexical category of is is therefore (
Other VP features include [ to ] ( to infinitival), [ b ] 4.3.3 Head and Adjunct. According to the Treebank annotation and the assumptions of the algorithm, our example has two VP adjuncts: the adverb just , and, because of its -DIR function tag, the PP to young people . In both cases, the adjunct category depends on the category of the parent, and the category of the head child is copied from the parent: the adjunct child is to the left of the head child (a premodifier), or of the head (a postmodifier). In most cases, the category without any features such as [ dcl ] , [ ng ] , and so forth, and the modifier combines with the head via simple function application. As shown in Figure 1, in many cases, a more elegant (and general) analysis can be obtained if we allow modifiers to compose with the head. For example, regularly has the category ( S \ NP ) \ that is, a constituent with category ( S [ dcl ] \ NP ) / NP egory of regularly would have to be (( S \ NP ) / NP ) \ (( S allows the ordinary category ( S \ NP ) \ ( S \ NP ) to also work in this case. off all outermost forward arguments / $ (and syntactic features) from
Similarly, if C is of the form X \ $ , all outermost backward arguments features) are stripped off from C to obtain C . 4.3.4 Head and Punctuation Mark. With the exception of some dashes and parentheses (see Section 4), the category of a punctuation mark is identical to its POS tag, and the head has the same category as its parent. ample. The category assignment procedure corresponds to a top-down normal-form derivation, which almost always uses function application. In the basic case presented here, composition is only used to provide a uniform analysis of adjuncts. Long-range dependencies represented in the Penn Treebank by traces such as *T* and *RNR* require extensions to the basic algorithm, which result in derivations that make use of type-presents the constructions that motivate them. 4.4 Assigning the Dependency Structure
Finally, we need to obtain the word X  X ord dependencies which approximate the un-derlying predicate X  X rgument structure. This is done by a bottom-up procedure, which simply retraces the steps in the CCG derivation that we have now obtained. 364 are associated with a corresponding list of lexical heads. This list can be empty (in the case of yet uninstantiated arguments of functor categories), or it can consist of one or
He for the first NP ,and is for the ( S [ dcl ] \ NP ) / ( S [ b ] in terms of the heads of lexical functor categories and of their arguments. In order to distinguish the slots filled by different arguments, we number the arguments of complex lexical categories from left to right in the category notation (that is, from innermost to outermost argument in a purely applicative derivation), for example, ( lexical head of all result categories ( S [ dcl ] \ NP and argument (the unmodified verb phrase). We use indices on the categories to represent by the fact that they are of the form X | X or ( X | X ) | have any of the features described previously, such as [ dcl ] ( the ) take a noun ( N , buck ) as argument to form a (non-bare) noun phrase whose lexical is buck ,not the .
 local dependencies. For instance, the category of the auxiliary, ( the subject NP is coindexed with the head of subject inside the VP argument: which creates the actual dependency structures. A complete list of the lexical entries in sections 02 X 21 of the Treebank which use this coindexation mechanism to project non-local dependencies is given in the CCGbank manual (Hockenmaier and Steedman 2005).
We believe that in practice this mechanism is largely correct, even though it is based on the (fundamentally flawed) assumption that all lexical categories that have the same syntactic type project the same dependencies. It may be possible to use the indices on the PRO-null elements ( *-1 ) in the Treebank to identify and resolve ambiguous cases; we leave this to future research. 10 pendencies, whereas coordination creates a new category whose lexical head lists are concatenations of the head lists of the conjuncts.
 of the NP 2 is instantiated with buck . Similarly, when the adverb just ( applied to passing the buck , a dependency between just and passing is created: S [ ng ] \ NP is passing ,not just (and no dependency is established between just and its In the next step, this S [ ng ] \ NP is combined with the auxiliary ( argument of passing . Because the NP in the ( S [ ng ] \ NP ) 1 of the auxiliary, the NP of the resulting S [ dcl ] to the subject NP 1 of is and passing . When the entire verb phrase is combined with the subject, He fills both slots:
Figure 2 shows the resulting CCG derivation and the corresponding list of word X  word dependencies for our example sentence. It is the latter structure that we claim approximates for present purposes the predicate X  X rgument structure or interpretation of the sentence, and provides the gold standard against which parsers can be evaluated. 4.5 Coordination
In order to deal with coordination, both the tree binarization and the category assign-ment have to be modified.
 rather than the ternary rule (7) X  X ompare to Steedman (1989):
In order to obtain this analysis from Treebank trees, a separate node that spans only the conjuncts and the conjunction or punctuation marks (comma, semicolon) is inserted if necessary. Identifying the conjuncts often requires a considerable amount of preprocess-366 dummy nodes inserted during binarization receive the same category as the conjuncts, but additionally carry a feature [ conj ] : ordinate phrases X  ( UCP ), namely, coordinate constructions where the conjuncts do not belong to the same syntactic category:
Such constructions are difficult for any formalism. This phenomenon could be handled
Villavicencio (2002), and McConville (2007). Because the induction of such a hierarchy was beyond the scope of our project, we modify our grammar slightly, and allow the algorithm to use instantiations of a special coordination rule schema, such as: This enables us to analyze the previous example as: 4.6 Type-Changing Rules for Clausal Adjuncts which may potentially generate a large number of lexical entries for each item in that class. One particularly frequent example of this is clausal adjuncts.
 categories depending on what occurrence of used they modify. This is undesirable, participles (and their possible modifiers) in all their possible surface positions. Similar regularities have been recognized and given a categorial analysis by Carpenter (1992), who advocates lexical rules to account for the use of predicatives as adjuncts. In a statis-tical model, the parameters for such lexical rules are difficult to estimate. We therefore follow the approach of Aone and Wittenburg (1990) and implement these type-changing few rules. If these rules apply recursively to their own output, they can generate an infinite set of category types, leading to a shift in generative power from context-free to recursively enumerable (Carpenter 1991, 1992). Like Aone and Wittenburg, we therefore those which arise when we extend the category assignment procedure in the following way: For any sentential or verb phrase modifier (an adjunct with label S or SBAR with null complementizer, or VP ) to which the original algorithm assigns category the following type-changing rule (given in bottom-up notation) in reverse: where S $ is the category that this constituent obtains if it is treated like a head node by the basic algorithm. S $ has the appropriate verbal features, and can be
Some of the most common type-changing rules are the following, for various types of reduced relative modifier: 368
In order to obtain the correct predicate X  X rgument structure, the heads of corresponding arguments in the input and output category are unified (as indicated by coindexation). the extraposed noun phrase:
Because any predicative noun phrase could be used in this manner, this construction is also potentially problematic for the coverage of our grammar and lexicon. However, the fact that a comma is required allows us to use a small number of binary type-changing rules (which do not project any dependencies), such as: 5. Necessary Preprocessing Steps
The translation algorithm presumes that the trees in the Penn Treebank map directly to the desired CCG derivations. However, this is not always the case, either because of noise in the Treebank annotation, differences in linguistic analysis, or because CCG, like any other expressive linguistic formalism, requires information that is not present in the Treebank analysis. Before translation, a number of preprocessing steps are there-noun level, which is required in virtually all sentences), preprocessing affects almost 43% of all sentences. Here we summarize the most important preprocessing steps for those constructions that do not involve non-local dependencies. Preprocessing steps required for constructions involving non-local dependencies (i.e., traces or null elements in the Treebank) are mentioned in Section 6. Remaining problems are discussed in
Section 7. More detailed and complete descriptions can be found in the CCGbank manual. 5.1 Dealing with Noise in the Treebank
Annotation errors and inconsistencies in the Treebank affect the quality of any extracted grammar or lexicon. This is especially true for formalisms with an extended domain may contain information that is distributed over a number of distinct phrase-structure rules.

Part-of-Speech Tagging Errors. Ratnaparkhi (1996) estimates a POS tagging error rate of sistencies, because POS tagging errors can lead to incorrect categories or to incorrect tense). For instance, if a simple past tense form occurs in a verb phrase which itself is the daughter of a verb phrase whose head is an inflected verb, it is highly likely that it should be a past participle instead. Using the verb form itself and the surrounding context, we have attempted to correct such errors automatically. In 7% of all sentences, our algorithm modifies at least one POS tag.

Quotation Marks. Although not strictly coming under the heading of noise, quotation marks cause a number of problems for the translation algorithm. Although it is tempting to analyze them similarly to parentheticals, quotations often span sentence boundaries, and consequently quotation marks appear to be unbalanced at the sentence level. We therefore decided to eliminate them during the preprocessing stage. 5.2 Adding Structure to the Treebank Analyses
Unlike a hand-written grammar, the grammar that is implicit in a treebank has to cover all constructions that occur in the corpus. Expressive formalisms such as CCG provide explicit analyses that contain detailed linguistic information. For example, CCG deriva-tions assign a lexical head to every constituent and define explicit functor X  X rgument relations between constituents. In a phrase-structure grammar, analyses can be much coarser, and may omit more fine-grained structures if they are assumed to be implicit in the given analysis. Furthermore, constructions that are difficult to analyze do not need to be given a detailed analysis. In both cases, the missing information has to be added before a Treebank tree can be translated into CCG. If the missing structure is implicit in the Treebank analysis, this step is relatively straightforward, but constructions such as parentheticals, multiword expressions, and fragments require careful reanalysis in order to avoid lexical coverage problems and overgeneration.

Detecting Coordination. Although the Treebank does not explicitly indicate coordination, nominal coordinations, the conjuncts are only separated by commas or semicolons, and may be difficult to distinguish from appositives. There are also a number of verb-phrase or sentential coordinations in the Treebank where shared arguments or modifiers simply appear at the same level as conjuncts and the conjunction:
In CCG, the conjuncts and conjunction form a separate constituent. In 1.8% of all sen-tences, additional preprocessing is necessary to obtain this structure.

Noun Phrases and Quantifier Phrases. In the Penn Treebank, non-recursive noun phrases have remarkably little internal structure:
Some, but not all, of the structure that is required to obtain a linguistically adequate analysis can be inferred (semi-)automatically. The CCGbank grammar distinguishes noun phrases, NP , from nouns, N , and treats determiners ( the ) as functions from nouns 370 also includes the adjuncts Dutch and publishing , which receive both the category
However, because nominal compounds in the Treebank have no internal bracketing, we always assume a right-branching analysis, and are therefore not able to obtain the correct dependencies for cases such as (lung cancer) deaths .
 tation lacks internal structure:
We use a number of heuristics to identify the internal structure of these constituents X  re-bracketed:
Fragments. 1.24% of the sentences in the Penn Treebank correspond to or contain frag-mentary utterances (labeled FRAG ), for which no proper analysis could be given:
FRAG s are often difficult to analyze, and the annotation is not very consistent. The CCG-bank manual lists heuristics that we used to infer additional structure. For example, if a node is labeled FRAG , and there is only one daughter (and potentially an end-of-sentence punctuation mark), as in the first example, we treat the tree as if it was labeled with the label of its daughter ( NP in this case).
 preceded by a dash. Unless the parenthetical element itself is of a type that could be a modifier by itself (e.g., a PP), we assume that the opening parenthesis or first dash takes the parenthetical element as argument and yields a modifier of the appropriate type: usually balanced (Nunberg 1990):
We use a similar treatment for other constituents that appear after colons and dashes, such as sentence-final appositives, or parentheticals that are not marked as PRN . Overall, these changes affect 8.7% of all sentences.

Multi-Word Expressions. Under the assumption that every constituent has a lexical head that corresponds to an individual orthographic word, multi-word expressions require an analysis where one of the items subcategorizes for a specific syntactic type that can only correspond to the other lexical item. We only attempted an analysis for expres-sions that are either very frequent or where the multi-word expression has a different subcategorization behavior from the head word of the expression. This includes some closed-class items (described in the CCGbank manual), including connectives (e.g., as if , tary expressions, and dates, affecting 23.8% of all sentences. 5.3 Changing the Treebank Analyses
Additionally, there are a number of constructions whose Treebank annotation differs from the standard CCG analysis for linguistic reasons. This includes small clauses, as well as pied-piping, subject extraction from embedded sentences and argument cluster coordination (discussed in Section 6).

Small Clauses. The Treebank treats constructions such as the following as small clauses: should rather be treated as involving two complements. We eliminate the small clause, and transform the trees such that the verb takes both NP children of the small clause as complements, thereby obtaining the lexical category ((
Because our current grammar treats predicative NPs like ordinary NPs, we are not able analysis would assign a functor category S [ nom ] \ NP (or perhaps tive NP arguments of verbs like makes , not only in these examples, but also in copular sentences and appositives. The other case where small clauses are used in the Treebank includes absolute with and though constructions ( with the limit in effect ). Here, we also assume that the subordinating conjunction takes the individual constituents in the small clause as complements, and with obtains therefore the category (( predicative analysis of the PP might be desirable in order to express the dependencies between limit and in effect . Eliminating small clauses affects 8.2% of sentences. 6. Long-Range Dependencies in the Treebank ference between grammar formalisms. The Treebank uses a large inventory of null element types and traces, including coindexation to represent long-range dependencies. 372
Because standard Treebank parsers use probabilistic versions of context-free grammar, they are generally trained and tested on a version of the Treebank in which these null elements and indices are deleted or ignored, or, in the case of Collin X  X  (1999) Model 3, only partially captured. Non-local dependencies are therefore difficult to recover from their output. In CCG, long-range dependencies are represented without null elements or traces, and coindexation is restricted to arguments of the same lexical functor category.
Although this mechanism is less expressive than the potentially unrestricted coin-dexation used in the Treebank, it allows parsers to recover non-anaphoric long-range dependencies directly, without the need for further postprocessing or trace insertion. 6.1 Passive, Control, Raising and Extraposition
Passive. In the Treebank, the surface subject of a passive sentence is coindexed with a null element in direct object position:
Our translation algorithm uses the presence of the  X  null element to identify passive mode, but ignores it otherwise, assigning the CCG category
In order to reduce lexical ambiguity and deal with data sparseness, we treat optional by -PPs which contain the  X  X ogical X  subject ( NP-LGS ) as adjuncts rather than arguments of the passive participle. 15 Here is the resulting CCG derivation, together with its dependency structure: imperatives, and to-VP arguments are annotated as sentences with a
We treat these like verb phrases ( S \ NP ) with the appropriate feature ( [ depending on the part-of-speech tag of the verb.
 Control and Raising. CCGbank does not distinguish between control and raising. In the
Treebank, subject-control and subject-raising verbs (e.g., want and seem ) also take an S complement with a null subject that is coindexed with the subject of the main clause:
Because an S with an empty subject NP has category S \ NP
We ignore the coindexation in the Treebank, and treat all control verbs as non-arbitrary control. As indicated by the index i , we assume that all verbs which subcategorize for a verb phrase complement and take no direct object mediate a dependency between their subject and their complement. Because the copula and to mediate similar dependencies between their subjects and complements, but do not fill their own subject dependencies,
Japanese has the following dependencies: ment with non-empty subject. Following our treatment of small clauses (see Section 5.3) we modify this tree so that we obtain the lexical category ( (( for wanted , which mediates the dependency between debt and forgiven . 374
Extraposition of Appositives. Appositive noun phrases can be extraposed out of a sentence or verb phrase, resulting in an anaphoric dependency. The Penn Treebank analyzes these as adverbial small clauses with a coindexed null subject:
CCG derivation deliberately omits the dependency between dummies and drivers :
This derivation uses one of the special binary type-changing rules (see Section 4.6) that takes into account that these appositives can only occur adjacent to commas. 6.2 Long-Range Dependencies Through Extraction
The Penn Treebank analyzes wh -questions, relative clauses, topicalization of comple-ments, tough movement, cleft, and parasitic gaps in terms of movement. These construc-tions are frequent: The entire Treebank contains 16,056 *T* traces, including 8,877 NP traces, 4,120 S traces, 2,465 ADVP traces, 422 PP traces, and 210 other *T* traces. Sections 873 reduced object relative clauses. The dependencies involved in these constructions, argument, the corresponding long-range dependencies can be recovered directly from the correct CCG derivation.
 inserted at the extraction site: require syntactic movement. In the CCG derivation of the example, the relative pronoun type-raising and forward composition into an S [ dcl ] / NP takes as its argument: missing object unifies with the modified NP, and we obtain the desired dependencies:
CCG to use the same category for the verb when its arguments are extracted as when they are in situ. This includes not only relative clauses and wh -questions, but also pied-piping, tough movement, topicalization, and clefts.
 ence of a long-range dependency for a particular argument of the verb, and allow us that long-range dependencies are represented in the gold-standard dependency struc-tures of the test and training data. This is crucial to correctly inducing and evaluating grammars and parsers for any expressive formalism, including TAG, GPSG, HPSG,
LFG, and MPG. A detailed description of this mechanism and of our treatment of other constructions that use *T* traces can be found in the CCGbank manual.
 *T* on their loans ), resulting in the following long-range dependencies: 6.2.1 Subject Extraction from Embedded Sentences. In CCG, verbs which take a bare sen-tential complement have the category (( S \ NP ) / NP i ) / ( S complement is extracted (Steedman 1996). In order to obtain these categories from the
Treebank (where the corresponding subject trace is in its canonical position), we assume 376 that the verb takes the VP and the NP argument in reversed order and change the tree accordingly before translation, resulting in the correct CCG analysis:
We obtain the following long-range dependencies:
Because our grammar does not use Baldridge X  X  (2002) modalities or Steedman X  X  (1996) equivalent rule-based restrictions, which prohibit this category from applying to in situ NPs, this may lead to overgeneralization. However, such examples are relatively frequent: There are 97 instances of (( S [ . ] \ NP ) / NP ) / ( S [ dcl ] omit this category would reduce coverage and recovery of long-range extractions. 6.2.2 Wh -Questions. *T* traces are also used for wh -questions:
By percolating the *T* trace up to the SQ -level in a similar way to relative clauses and treating Which as syntactic head of the WHNP , we obtain the desired CCG analysis: i )) / N i , and the subject of do with the subject of its complement (( to obtain the following dependencies: 6.2.3 Pied-Piping. *T* traces are also used for pied-piping: constituent, 18 apply a special rule to assign the category ( and combine it via type-raising and composition with details . This constituent is then treated as an argument of the relative pronoun:
With appropriate coindexation (( NP \ NP i ) / ( S [ dcl ] non-local dependencies: 19 6.2.4 Extraction of Adjuncts. *T* traces can also stand for extracted adjuncts:
Because adjuncts generally do not extract unboundedly, (which account for 20% of all *T* traces) can be ignored by the translation procedure. 378
Instead, the dependency between when and dropped is directly established by the fact that dropped is the head of the complement S [ dcl ] : This results in the following set of dependencies of when : 6.3 Long-Range Dependencies Through Coordination 6.3.1 Right Node Raising. Just as composition and type-raising permit CCG analyses of wh -extraction, which use the same lexical categories as for in situ complements, they also provide an analysis of right node raising constructions without introducing any new lexical categories.
 with two *RNR* traces in both of its canonical positions:
We need to alter the translation algorithm slightly to deal with *RNR* traces in a man-ner essentially equivalent to the earlier treatment of *T* wh -traces. Details are in the CCGbank manual. The CCG derivation for the above example is as follows:
The right node raising dependencies are as follows: noun phrases share the same head, which is also annotated with *RNR* traces. node raising is actually far more frequent, because *RNR* traces are not used when the conjuncts consist of single verb tokens. The Treebank contains 349 VPs in which a verb form ( /VB/ ) is immediately followed by a conjunction ( CC ) and another verb form, and has an NP sister (without any coindexation or function tag). In CCGbank, sections 02 X 21 alone contain 444 sentences with verbal or adjectival right node raising. 6.4 Right Node Raising Parasitic Gaps
Right node raising is also marked in the Penn Treebank using *RNR* traces for  X  X arasitic gap X  constructions such as the following: These sentences require rules based on the substitution combinator S (Steedman 1996). ward crossing rule &lt; S  X  , and allows us to obtain the following correct dependencies: forward substitution rule &gt; S , since the PPs are both arguments. Unfortunately, as we saw in Section 3, the Treebank classifies such PPs as directional adverbials, hence we 380 more, all also involving from and to :
As in the case of leftward extraction, including such long-range dependencies in the grammar formalisms. Although no leftward-extracting parasitic gaps appear to occur in the Treebank, our grammar and model predicts examples like the following, and will cover them when encountered: 6.4.1 Argument Cluster Coordination. If two VPs with the same head are conjoined, coordination in which the second VP lacks a verb. The daughters of the second conjunct are coindexed with the corresponding elements in the first conjunct using a = index:
In the CCG account of this construction, $5 million right away and additional amounts in the future form constituents ( X  X rgument clusters X ), which are then coordinated. These con-stituents are obtained by type-raising and composing the arguments in each conjunct, yielding a functor which takes a verb with the appropriate category to its left to yield a verb phrase (Dowty 1988; Steedman 1985). Then the argument clusters are conjoined, and combine with the verb via function application: 21
This construction is one in which the CCGbank head-dependency structure (shown subsequently) fails to capture the full set of predicate X  X rgument structure relations that would be implicit in a full logical form:
That is, the dependency structure does not express the fact that right away takes scope over $5 million and in future over additional amounts , rather than the other way around.
However, this information is included in the full surface-compositional semantic inter-pretation that is built by the combinatory rules.
 we create a copy of the entire argument cluster which corresponds to the constituent argument cluster. For a detailed description of this algorithm and a number of variations on the original Treebank annotation that we did not attempt to deal with, the interested reader is referred to the CCGbank manual.
 bank. The algorithm delivers a correct CCG derivation for 146 of these. Translation fail-ures are due to the fact that the algorithm can at present only deal with this construction if the two conjuncts are isomorphic in structure, which is not always the case. This is un-fortunate, because CCG is particularly suited for this construction. However, we believe that it would be easier to manually reannotate those sentences that are not at present translated than to try to adapt the algorithm to deal with all of them individually. 6.4.2 Gapping. For sentential gapping, the Treebank uses annotation similar to argument cluster coordination:
This construction cannot be handled with the standard combinatory rules of CCG that are assumed for English. Instead, Steedman (2000) proposes an analysis of gapping that uses a unification-based  X  X ecomposition X  rule. Categorial decomposition allows a category type to be split apart into two subparts, and is used to yield an analysis of gapping that is very similar to that of argument cluster coordination: 382
Because the derivation is not a tree anymore, and the decomposed constituents do not correspond to actual constituents in the surface string, this analysis is difficult to represent in a treebank. The 107 sentences that contain sentential gapping are therefore omitted in the current version of CCGbank, even though special coordination rules that mimic the decomposition analysis are conceivable. 6.5 Other Null Elements in the Treebank
Besides the cases discussed herein, the Treebank contains further kinds of null elements, all of which the algorithm ignores. The null element *ICH* ( X  X nsert Constituent Here X ), is a case of a semantic dependency which we believe to be anaphoric, and therefore not reflected in the syntactic category. For this reason we treat any constituent that is coindexed with an *ICH* as an adjunct. The null element *PPA* ( X  X ermanent Predictable Ambiguity, X  26 occurrences) is used for genuine attachment ambiguities. Since the
Treebank manual states that the actual constituent should be attached at the more likely attachment site, we chose to ignore any *PPA* null element. Our algorithm also ignores the null element *?* , which occurs 582 times, and indicates  X  X  missing predicate or a piece thereof X  (Marcus, Santorini, and Marcinkiewicz 1993). It is used for VP ellipsis, and can also occur in conjunction with a VP pro-form do ( You either believe he can do it or you don X  X  *?* ), or in comparatives ( the total was far higher than expected 6.6 The Complete Translation Algorithm
We can now define the complete translation algorithm, including the modifications necessary to deal with traces and argument clusters: foreach tree  X  :
The successive steps have the following more detailed character: preprocessTree: Correct tagging errors, ensure the constituent structure conforms to the determineConstituentTypes: For each node, determine its constituent type (head, com-makeBinary: Binarize the tree. percolateTraces: Determine the CCG category of *T* and *RNR* traces in complement treatArgumentClusters: Assign categories to argument clusters. cutTracesAndUnaryRules: Cut out constituents that are not part of the CCG derivation, verifyDerivation: Discard those trees for which the algorithm does not produce a valid assignDependencies: coindex specific classes of lexical categories to project non-local 7. Remaining Problems for the Translation Algorithm constructions needed to inform the translation is missing, and cannot be inferred de-terministically from the Treebank analysis without further manual re-annotation. We discuss these residual problems here, because they are likely to present obstacles to the extraction of linguistically adequate grammars in any formalism. 7.1 Complement/Adjunct Distinction Our translation algorithm requires a distinction between complements and adjuncts.
In many cases, this distinction is easily read off the Treebank annotation, but it is in general an open linguistic problem (McConnell-Ginet 1982). Because the Treebank annotation does not explicitly distinguish between complements and adjuncts, researchers typically develop their own heuristics X  X ee, for example, Kinyon and
Prolo (2002). For prepositional phrases, we rely on the -CLR ( X  X losely related X ) function tag to identify complements, although it is unclear whether the Treebank annotators were able to use this tag consistently. Not all PP arguments seem to have this function tag, and some PPs that have this tag may have been better considered adjuncts: 384
For TAG, Chen, Bangalore, and Vijay-Shanker (2006) show that different heuristics yield grammars that differ significantly in size, coverage, and linguistic adequacy. We have not attempted such an investigation. In a future version of CCGbank, it may be possible (Palmer, Gildea, and Kingsbury 2005) to distinguish arguments and adjuncts. 7.2 Phrasal Verbs
Particle-verb constructions are difficult to identify in the Treebank, because particles can be found as PRT , ADVP-CLR ,and ADVP . Therefore, verbs in the CCGbank grammar do not subcategorize for particles, which are instead treated as adverbial modifiers. 7.3 Compound Nouns
Compound nouns are often inherently ambiguous, and in most cases, the Treebank does not specify their internal structure:
In order to obtain the correct analysis, manual re-annotation would be required. Because this was not deemed feasible within our project, compound nouns are simply translated into strictly right-branching binary trees, which yields the correct analysis in some, but not all, cases. This eschews the computational problem that a grammar for compound nouns induces all possible binary bracketings, but is linguistically incorrect. 7.4 Coordinate Nouns
A similar problem arises in compound nouns that involve internal coordination:
We include the following (linguistically incorrect) rule in our grammar, which yields a default dependency structure corresponding to N / N coordination: This rule allows us to translate the above tree as follows: 7.5 Appositives and Lists
The Treebank markup of NP appositives is indistinguishable from that of NP lists:
Therefore, our current grammar does not distinguish between appositives and NP coordination, even though appositives should be analyzed as predicative modifiers. This leads to a reduction of ambiguity in the grammar, but is semantically incorrect: 7.6 Lack of Number Agreement
Our current grammar does not implement number agreement (which is, however, represented in the POS tags). One problem that prevented us from including number agreement is the above-mentioned inability to distinguish NP lists and appositives. 7.7 Attachment of Noun Phrase Modifiers mantically undesirable, because a correct interpretation of restrictive relative clauses can only be obtained if they modify the noun, whereas non-restrictive relative clauses are noun phrase modifiers. Because this distinction requires manual inspection on a case-by-case basis, we were unable to modify the Treebank analysis. Thus, all CCGbank rel-ative pronouns have categories of the form ( NP i \ NP i ) / ( S / NP
This will make life difficult for those trying to provide a Montague-style semantics for relative modifiers. Like most other problems that we were not able to overcome, this limitation of the Treebank ultimately reflects the sheer difficulty of providing a consis-tent and reliable annotation for certain linguistic phenomena, such as modifier scope. 7.7.1 Heavy NP Shift. In English, noun phrase arguments can be shifted to the end of the sentence if they become too  X  X eavy. X  This construction was studied extensively by
Ross (1967). The CCG analysis (Steedman 1996) uses backward crossed composition to provide an analysis where brings has its canonical lexical category ( 386
CCGbank derivation does not conform to the desired analysis, and requires additional lexical categories which may lead to incorrect overgeneralizations:
This will also be a problem in using the Penn Treebank or CCGbank for any theory of grammar that treats heavy NP shift as extraction or movement. 8. Coverage, Size, and Evaluation Here we first examine briefly the coverage of the translation algorithm on the entire Penn Treebank. Then we examine the CCG grammar and lexicon that are obtained from
CCGbank. Although the grammar of CCG is usually thought of as consisting only of the combinatory rule schemata such as (3) and (5), we are interested here in the instantiation of these rules, in which the variables X and Y are bound to values such as because statistical parsers such as Hockenmaier and Steedman X  X  (2002) or Clark and
Curran X  X  (2004) are trained on counts of such instantiations. We report our results on sections 02 X 21, the standard training set for Penn Treebank parsers, and use section 00 to evaluate coverage of the training set on unseen data. Sections 02 X 21 contains 39,604 sentences (929,552 words/tokens), whereas section 00 consists of 1,913 sentences (45,422 words/tokens). 8.1 Coverage of the Translation Algorithm CCGbank contains 48,934 (99.44%) of the 49,208 sentences in the entire Penn Treebank.
The missing 274 sentences could not be automatically translated to CCG. This includes 107 instances of sentential gapping, a construction our algorithm does not cover (see
Section 6.4.2), and 66 instances of non-sentential gapping, or argument-cluster coordi-nation (see Section 6.4.1).
 are not separated by commas, some fragments, and a small number of constructions involving long-range dependencies, such as wh -extraction, parasitic gaps, or argument cluster coordinations where the translation did not yield a valid CCG derivation be-cause a complement had been erroneously identified as an adjunct. 8.2 The Lexicon
A CCG lexicon specifies the lexical categories of words, and therefore contains the entire language-specific grammar. Here, we examine the size and coverage of the lexicon that consists of the word X  X ategory pairs that occur in CCGbank. This lexicon could be used by any CCG parser, although morphological generalization (which is beyond the scope of the present paper) and ways to treat unknown words are likely to be necessary to obtain a more complete lexicon.
 44,210 word types (or 929,552 word tokens). Many words have only a small number of categories, but because a number of frequent closed-class items have a large number of categories (see Table 1), the expected number of lexical categories per token is 19.2.
Number and Growth of Lexical Category Types. How likely is it that we have observed the complete inventory of category types in the English language? There are 1,286 lexical category types in sections 02 X 21. Figure 4 examines the growth of the number of lexical category types as a function of the amount of data translated into CCG. The log X  X og plot 388 of the rank order and frequency of the lexical categories in Figure 5 indicates that the underlying distribution is roughly Zipfian, with a small number of very frequent cate-gories and a long tail of rare categories. We note 439 categories that occur only once, and only 556 categories occur five times or more. Inspection suggests that although some of the category types that occur only once are due to noise or annotation errors, most are correct and are in fact required for certain constructions. Typical examples of rare but correct and necessary categories are relative pronouns in pied-piping constructions, or verbs which take expletive subjects.
 the necessary categories (as determined by our translation algorithm) for 94.0% required for the remaining 6% of tokens fall into two classes: 1,728, or 3.8%, correspond to completely unknown words that do not appear at all in section 02 X 21, whereas the other 2.2% of tokens do appear in the training set, but not with the categories required in section 00.
 regardless of the underlying grammar formalism. Typically, frequency information for rare words in the training data is used to estimate parameters for unknown words (and when these rare or unknown words are encountered during parsing, additional infor-mation may be obtained from a POS-tagger (Collins 1997)). However, in a lexicalized formalism such as CCG, there is the additional problem of missing lexical entries for small fraction of missing lexical entries can have a significant effect on coverage, since the parser will not be able to obtain the correct analysis for any sentence that contains such a token. Hockenmaier and Steedman (2002) show that this lexical coverage prob-lem does in practice have a significant impact on overall parsing accuracy. However, because many of the known words with missing entries do not appear very often in the training data, Hockenmaier (2003a) demonstrates that this problem can be partially alleviated if the frequency threshold below which rare words are treated as unseen is set to a much higher value than for standard Treebank parsers. An alternative approach, advocated by Clark and Curran (2004), is to use a supertagger which predicts lexical
CCG categories in combination with a discriminative parsing model. 8.3 The Syntactic Component
Hockenmaier and Steedman (2002) or Clark and Curran (2004) are trained on counts of specific instantiations of combinatory rule schemata by category-types. It is therefore instructive to consider the frequency distribution of these category-instantiated rules. once, and 2,027 appear less than five times. Although there is some noise, many of the
CCG rules that appear only once are linguistically correct and should be used by the parser. They include certain instantiations of type-raising, coordination, or punctuation rules, or rules involved in argument cluster coordinations, pied-piping constructions, or questions, all of which are rare in the Wall Street Journal . As can be seen from Figure 5, the distribution of rule frequencies is again roughly Zipfian, with the 10 most frequent rules accounting for 59.2% of all rule instantiations (159 rules account for 95%; 591 rules for 99%). The growth of rule instantiations is shown in Figure 4. If function tags are ignored, the grammar for the corresponding sections of the original Treebank contains 12,409 phrase-structure rules, out of which 6,765 occur only once (Collins 1999). These rules also follow a Zipfian distribution (Gaizauskas 1995). The fact that both category types and rule instances are also Zipfian for CCGbank, despite its binarized rules, shows that the phenomenon is not just due to the Treebank annotation with its very flat rules.
Syntactic Rule Coverage on Unseen Data. Syntactic rule coverage for unseen data is almost perfect: 51,932 of the 51,984 individual rule instantiations in section 00 (corresponding to 844 different rule types) have been observed in section 02 X 21. Out of the 52 missing rule instantiation tokens (corresponding to 38 rule types, because one rule appears 13 times in one sentence), six involve coordination, and three punctuation. One missing rule is an instance of substitution (caused by a parasitic gap). Two missing rules are instances of type-raised argument types combining with a verb of a rare type. 9. Conclusion
This paper has presented an algorithm which translates Penn Treebank phrase-structure trees into CCG derivations augmented with word X  X ord dependencies that approxi-mate the underlying predicate X  X rgument structure. In order to eliminate some of the noise in the original annotation and to obtain linguistically adequate derivations that conform to the  X  X orrect X  analyses proposed in the literature, considerable preprocessing was necessary. Even though certain mismatches between the syntactic annotations in the Penn Treebank and the underlying semantics remain, and will affect any similar attempt to obtain expressive grammars from the Treebank, we believe that CCGbank, the resulting corpus, will be of use to the computational linguistics community in the following ways.
 wide-coverage CCG parsers, including Hockenmaier and Steedman (2002), Clark,
Hockenmaier, and Steedman (2002), Hockenmaier (2003b), and Clark and Curran (2004, project, CCGbank can also be seen as a resource which may enable the automatic con-struction of full semantic interpretations by wide-coverage parsers. Unlike most Penn
Treebank parsers, such as Collins (1999) or Charniak (2000), these CCGbank parsers re-turn not only syntactic derivations, but also local and long-range dependencies, includ-390 ing those that arise under relativization and coordination. Although these dependencies are only an approximation of the full semantic interpretation that can in principle be obtained from a CCG, they may prove useful for tasks such as summarization and ques-tion answering (Clark, Steedman, and Curran 2004). Furthermore, Bos et al. (2004) and
Bos (2005) have demonstrated that the output of CCGbank parsers can be successfully translated into Kamp and Reyle X  X  (1993) Discourse Representation Theory structures, to support question answering and the textual entailment task (Bos and Markert 2005). expressive grammar formalisms. We also hope that our experiences will be useful in designing guidelines for future treebanks. Although implementational details will differ across formalisms, similar problems and questions to those that arose in our work will be encountered in any attempt to extract expressive grammars from annotated corpora. somewhat less noisy form, we hope that others will find it directly helpful for inducing grammars and statistical parsing models for other linguistically expressive formalisms. There are essentially three ways in which this might work.
 egorization frames in the CCG lexicon directly into the target theory. For type-logical grammars (Moortgat 1988; Morrill 1994; Moot 2003), this is little more than a matter formalisms like LTAG, the relation is more complex, but the work of Joshi and Kulick (1996), who  X  X nfold X  CCG categories into TAG elementary trees via partial proof trees, and Shen and Joshi (2005), who define LTAG  X  X pines X  that resemble categories, suggest possible in principle.
 target formalism. There seems to be a similar ordering over alternative formalisms from straightforward to less straightforward for this approach. We would also expect that de-pendency grammars Mel X   X  cuk and Pertsov 1987; Hudson 1984) and parsers (McDonald,
Crammer, and Pereira 2005) could be trained and tested with little extra work on the dependencies in CCGbank.
 scratch into other grammar formalisms will benefit from including preprocessing simi-lar to that described here.
 offer the observation that the 900K-word German Tiger dependency corpus has recently been translated into CCG using very similar techniques by Hockenmaier (2006), and
C  X  ak X c X  (2005) has derived a Turkish lexicon from the a similarly preprocessed version of the METU-Sabanc  X  X  Turkish dependency treebank (Oflazer et al. 2003).
 tactically annotated corpora into different grammatical formalisms such as CCG, TAG, be mapped directly (or, at least, without too much additional work) into the desired analyses in the target formalism. This can only hold if all constructions that are treated in a similar manner in the original corpus are also treated in a similar manner in the target formalism. For the Penn Treebank, our research and the work of others (Xia 1999;
Chen and Vijay-Shanker 2004; Chiang 2000; Cahill et al. 2002) have shown that such a correspondence exists in most cases.
 detail of the original annotation X  X n particular, the additional information present in the null elements and function tags that are ignored by most other parsers X  X hat has made the creation of CCGbank possible. The translation process would have been easier if some of the annotation had been more explicit and precise (as in the case of and consistent (most importantly in identifying adjuncts and arguments). An impor-established by the Penn Treebank of including all linguistically relevant dependencies should be continued, with if anything even closer adherence to semantically informed linguistic insights into predicate X  X rgument structural relations. Our results also indicate coverage to recover these relations completely.
 Acknowledgments References 392 394
