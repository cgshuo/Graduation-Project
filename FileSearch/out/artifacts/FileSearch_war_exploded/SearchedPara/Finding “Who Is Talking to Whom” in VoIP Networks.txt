  X  Aris Anagnostopoulos  X   X  Philip S. Yu  X 
Technologies that use the Internet network to deliver voice communications have the potential to reduce costs and improve access to communications services around the world. However, these new technologies pose several chal-lenges in terms of confidentiality of the conversations and anonymity of the conversing parties. Call authentication and encryption techniques provide a way to protect con-fidentiality, while anonymity is typically preserved by an anonymizing service (anonymous call).

This work studies the feasibility of revealing pairs of anonymous and encrypted conversing parties (caller/callee pair of streams) by exploiting the vulnerabilities inherent to VoIP systems. In particular, by exploiting the aperiodic inter-departure time of VoIP packets, we can trivialize each VoIP stream into a binary time-series. We first define a sim-ple yet intuitive metric to gauge the correlation between two VoIP binary streams. Then we propose an effective tech-nique that progressively pairs conversing parties with high accuracy and in a limited amount of time. Our metric and method are justified analytically and validated by experi-ments on a very large standard corpus of conversational speech. We obtain impressively high pairing accuracy that reaches 97% after 5 minutes of voice conversations.
The International Telecommunications industry is in the early stages of a migration to Voice over Internet Proto-col (VoIP). VoIP is a technology that enables the routing of voice conversations over any IP-based networks such as the public Internet. The voice data flows over a general-purpose packet-switched network rather than over the tradi-tional circuit-switched Public Switched Telephone Network (PSTN). Market research firms including In-Stat and IDC predict that 2005-2009 will be the consumer and small busi-ness VoIP ramp-up period, and migration to VoIP will peak in the 2010-2014 time frame. Research organization Gart-ner Inc. recently reported that spending by U.S. companies and public-sector organizations on VoIP systems is on track to grow to $903 million in 2005 (up from the $686 million in 2004). Gartner expects that by 2007, 97% of new phone systems installed in North America to be VoIP or hybrids.
While the migration to VoIP seems inevitable, there are security risks associated with this technology that are care-fully being addressed. Eavesdropping is one of the most common threats in a VoIP environment. Unauthorized in-terception of audio streams and decoding of signaling mes-sages can enable the eavesdropper to tap audio streams in an unsecured VoIP environment. Call authentication and encryption mechanisms [2, 15] are being deployed to preserve customers X  confidentiality. Preserving customers X  anonymity is also crucial, which encompasses both the identity of the people involved in a conversation and the re-lationship caller/callee (pair of voice streams). Anonymiz-ing overlay networks such as Onion Routing [7] and Find-Not.com [16] aim at providing an answer to this problem by concealing the IP addresses of the conversing parties. A recent work [14] shows that tracking anonymous peer-to-peer VoIP calls on the Internet is actually feasible. The key idea consists in embedding a unique watermark into the en-crypted VoIP flows of interest by minimally modifying the departure time of selected packets. This technique trans-parently compromises the identity of the conversing parties. However, the authors rely on the strong assumption that one has access to the customer X  X  communication device, so that the watermark can be inserted before the streams of interest reach the Internet.

This work studies the feasibility of revealing pairs of anonymous conversing parties (caller/callee pair of streams) by exploiting the vulnerabilities inherent in VoIP systems. Using the methods provided in this work, we also note one seemingly surprising result; that the proposed techniques are applicable even when the voice packets are encrypted. While the focus of this work is on VoIP data, the tech-niques presented here are of independent interest and can be used for pairing/clustering any type of binary streaming data. The contributions of the paper function on different levels: 1. We formulate the problem of pairing anonymous and 2. We present an elegant and fast solution for the con-3. Our solution is based on an efficient transformation of 4. Finally, we verify the accuracy of the proposed solu-
The paper is organized as follows. Sections 2 -5 present our solution for pairing conversations over any medium by mapping the problem into a complementary clustering problem for binary streaming data. We introduce various intuitive metrics to gauge the correlation between two bi-nary voice streams and we present effective methods for progressively pairing conversing parties with high accuracy within a limited amount of time. Section 6 shows how the presented solution can be adapted for a VoIP framework, and demonstrates that encryption schemes do not hinder the applicability of our approach. Section 7 validates the pre-sented algorithm by experiments on a very large standard corpus of conversational speech [8]. Finally, we provide our concluding remarks in Section 8 and we also instigate directions for future work.
We start with a generic description of the conversation pairing problem, with the intention of highlighting the key insights governing our solution. We will later clarify the required changes so as the following model can be adapted for the VoIP scenario.
Let us assume that we are monitoring a set S = { S 1 ,S 2 ,...,S k } of k voice streams (for now suppose is even), comprising a total of k/ 2 conversations 1 . Each stream holds one-way of a two-way voice conversation, and there exists also a homologue voice stream that holds the other side of the conversation. Our objective is to efficiently reveal the relationship of two-way conversing parties. For example, assume S 2 is actually involved in a conversation with S 5 . We aim at finding all relationships S i  X  S j cluding the example S 2  X  S 5 , such that streams S i and S j correspond to each one-way voice stream of the same conversation. Our approach does not require an even num-ber of voice streams and we also do not assume each voice stream to have a matching pair. Any voice stream without a corresponding counterpart is referenced to henceforth as a singleton stream. At the end of the pairing process some streams may remain unmatched. These will be the voice streams for which the algorithm either does not have ad-equate data to identify a match, or is not in a position to discriminate with high confidence a conversational pair.
The key intuition behind our approach is that convers-ing parties tend to follow a  X  X omplementary X  speech pat-tern. When one speaks, the other listens. This  X  X urn-taking X  of conversation [13] represents a basic rule of communica-tion, well-established in the fields of psycholinguistics, dis-course analysis and conversation analysis, and it also mani-fests under the term of speech  X  X oordination X  [4]. Needless to say, one does not expect a conversation to follow strictly the aforementioned rule. A conversational speech may well include portions where both contributers speak or are silent. Such situations are indeed expected, but in practice they do not significantly  X  X ollute X  the results, since given conver-sations of adequate length, coordinated speech patterns are bound to dominate. We will show this more explicitly in the experimental section, where the robustness of the pro-posed measures are tested also under conditions of network latency.

Using the above intuitions, we will follow the subsequent steps for recognizing pairs of conversations: 1. First, voice streams are converted into binary streams, 2. Second, we leverage the power of complementary sim-3. Using the derived complementary similarity, we will
A schematic of the above steps is given in Figure 1. In the following section we will first place our approach within the context of related work.
Recent work that studies certain VoIP vulnerabilities and has attracted a lot of media attention has appeared in [14]. The authors present techniques for watermarking VoIP traf-fic, with the purpose of tracking the marked VoIP packets. For accomplishing that, however, initial access to a user X  X  device or computer is required. In this work we achieve a different goal; that of identifying conversational pairs, however we do not assume any access to a user X  X  device. The only requirement of our approach (more explanations will be provided later) is the provision of a limited number of network sniffers , which will capture the incoming (en-crypted) VoIP traffic.

Relevant to our approach are also recent techniques for clustering binary streams [11, 10]. These consider clus-ters of objects and not pairs of streams, which is one of the core requirements for the application that we examine. The algorithm presented in this work has the additional ad-vantage of being progressive in nature, returning identified pairs of streams before the complete execution of the al-gorithm. In [6], Cormode et al., study the use of binary similarity measures for comparison streams, and focus on sketch approximations of the Hamming Norm. This work examines the use of complementary binary similarity mea-sures between streaming data.

The methods presented in this work, exploit and adapt data-mining techniques for depicting inherent vulnerabili-ties in VoIP streams, which can potentially compromise the users X  anonymity. It is interesting to note, that much of re-cent work in data-mining [9, 5] has focused on how to em-bed or maintain privacy for various data-mining techniques, such as clustering, classification, and so on.

In the sections that follow we will provide a concise de-scription of a Voice Activity Detector. We will also present intuitive coordination measures for quantifying the comple-mentary similarity between binary streams. We put forward a lightweight pairing technique based on adaptive soft deci-sions for reduce the pairing errors and avoiding the pairing of singleton streams. Key requirements include lightweight processing, quick and accurate identification of the relation-ships, and resilience to both noise and latency.
The goal of a Voice Activity Detection (VAD) algorithm is to discriminate between voiced versus unvoiced sections of a speech stream. We provide only a high-level descrip-tion of a typical VAD algorithm for reasons of complete-ness, since it is not the focus of the current work. The VAD process computes the energy of small overlapping speech packets (also called frames , with each frame be-ing 20-30msec in length), and employs an adaptive energy threshold that will differentiate the voiced from the un-voiced frames. The threshold is typically deduced by esti-mating the average energy of the unvoiced portions, taking also into consideration a background noise model, based on the characteristics of the data channel. The output of the VAD algorithm will be  X 1 X  when there is speech detected and  X 0 X  in the presence of silence. A simple schematic of its operation is provided in Fig. 2.

As will be explained later, the voice activity detection is inherently provided by the VoIP protocol.
After voice activity detection is performed, each voice stream S i is converted into a binary stream B i . The result-ing binary stream only holds the necessary information that indicates the speech/no-speech patterns. The objective now is to quantify the complementary similarity (which we call cimilarity ) between two binary streams.

As already mentioned, the basic insight behind detect-ing conversational pairs is to discern voice streams that ex-hibit complementary speech behavior. That is, given a large number of binary streams B 1 ,B 2 ,...,B N , and a query stream B q (which indicates the voice activity of user q ), we would like to identify the stream B j that is most comple-mentary similar to stream B q , or in other words, has the largest cimilarity.

We present different versions of cimilarity measures ( Cim ) and we later quantify their performance in the ex-perimental section. Let us consider two binary streams, B and B j . By abstracting B i and B j as binary sets, an intu-itive measure of coordination between users i and j consists in computing the intersection between B i and the binary complement of B j normalized by their union. We denote by Cim-asym ( i, j, T ) this measure computed over streams B i and B j after T units of time. One can readily verify that it can be written as: where B k ( t )  X  X  0 , 1 } is the binary value for user k t , and the symbols  X  ,  X  , and  X  denote the binary AND, OR and NOT operators, respectively.
Note that Equation 1 asymmetrically measures the amount of coordination between speakers i and j . That is, in general, Cim-asym ( i, j, T ) = Cim-asym ( j, i, T to the binary complement operator. This measure can be seen as the asymmetric extension of the well-known Jac-card coefficient [3]. Thus, we also refer to this measure as Jaccard-Asymmetric .

Computing Cim-asym between two binary streams is computationally very light. The computation lookup ta-ble for the numerator and the denominator is provided in Figure 3. The numerator is increased when B i =1 and B j =0 , while the denominator is not increased when B i =0 and B j =1 .So Cim-asym ( B i , B j ) only rewards the presence of non-speech of user j , when user i speaks. Example: Given B 1 = 11100110 and B 2 = 00010001 then cim-asym ( B 1 , B 2 ) = 0.833 and cim-asym ( B 2 , B 0.6667.

The Cim-asym measure is also easily amenable to in-cremental maintenance as time T progresses. Indeed, let V ( i, j ) and V  X  ( i, j ) denote the running values of the nu-merator and the denominator, respectively. The value of Cim-asym ( i, j, T ) for any elapsed time T is given by the ra-tio V  X  ( i, j ) /V  X  ( i, j ) . Therefore, given n binary streams, in-crementally computing Cim-asym requires keeping 2 times n ( n  X  1) values in memory. For example, when monitoring n = 1000 streams and assuming each value is stored as an int16 , only 4 MBytes of memory are needed for tracking all the required statistics.

We also consider a symmetric extension of Cim-asym de-noted by Cim-sym and referred to as Jaccard-Symmetric . This intuitive extension is written as: Cim-sym ( i, j, T )=
This metric is even simpler than its asymmetric ver-sion. Moreover, given n binary streams, incrementally computing Cim-sym requires keeping only n 2 values in memory thanks to its symmetric nature. Using the exam-ple above, memory requirements drop to approximately 1 Mbytes given the same assumptions. The Cim-sym is gen-erally more aggressive than its asymmetric counterpart, be-cause it also rewards the presence of speech patterns when the user in question does not speak. However, our experi-ments indicate that the most conservative asymmetric ver-sion ultimately achieves the best detection accuracy.
Finally we consider the Mutual Information (MI) as a measure of coordination between conversing parties [1]. This is a measure of how much information can be obtained about one random variable B i by observing another B j . Let p and marginal running averages for users i and j after T units of time. For example, The amount of Mutual Information (MI) between streams B i and B j is written as:
The mutual information measure requires higher processing power but exhibits symmetry. Note that while at first it seems that one needs to store 8 statistics for up-dating the Mutual Information, in fact only 3 statistics are required. For example p i,j (0 , 0) , p i,j (0 , 1) and are sufficient to restore the remaining ones, since: and so on.

So, given n binary streams, it can be shown that incre-mentally computing MI requires keeping 3 times n 2 values in memory thanks to its symmetric nature. Thus, approx-imately 3 MBytes of memory are required for the above example.

In the following section, we illustrate how any of the above metrics can be used in conjunction with a progres-sive clustering algorithm for identifying conversing pairs.
In order to get insights about the pairing algorithm we first plot how the complementary similarity of one voice stream progresses over time against all other streams (Fig-ure 4). Similar behavior is observed for the majority of voice streams.

One can notice that voice pairing is extremely ambiva-lent during the initial stages of a conversation, but the un-certainty decreases as conversations progress. This is ob-served, first, because most conversations in the beginning exhibit a customary dialog pattern ( X  X i, X   X  X ow are you, X  etc.). However, conversations are bound to evolve in differ-ent conversational patterns, leading to a progressive decay in the matching ambiguity. Second, some time is required to elapse, so as the Law of Large Numbers can come to effect.
A simple solution for tackling the conversation pairing problem would be to compute the pairwise similarity ma-trix M after some time T , where each entry provides the complementary similarity between two streams: where Cim is one of the cimilarity measures that we pre-sented in Section 4.
 Then we can pair users i and j if we have and
We call this approach hard clustering, because at each time instance it provides a rigid assignment of pairs, without providing any hints about the confidence or ambiguity of the matching.

There are several shortcomings that can be identified with the above hard clustering approach:  X  First, it provides no concrete indication when the pair- X  In order to achieve high accuracy, sufficient data need  X  Different streams will converge at different rates to
In the stream-pairing algorithm that we describe below, we will address all the previous issues, allowing the early pairing of streams, while imposing minimal impact on the system resources.

Using as a guide the aforementioned behavior which governs the progression of cimilarity, we construct the clus-tering algorithm as an outlier detection scheme . What we have to examine is whether the closest match is  X  X ufficiently distant X  from the majority of streams. Therefore, when comparing a stream (e.g. stream 1) against all others, the most likely matching candidate should not only hold the maximum cimilarity, but also deviate sufficiently from the cimilarity of the remaining streams.
Figure 5 contains a pseudocode of the pairing algorithm, while Figure 6 depicts the steps behind its execution. We maintain the same matrix M as in the hard-clustering ap-proach, which is updated as time progresses. Then, at every step of the algorithm, for every stream that has not been matched, we perform the following actions. Suppose that at any time T we start with the binary stream B 1 : 1. We perform a k -Trim for removing the k most distant 2. We compute the average cMass (center of mass) of the 3. We record the cimilarity of the two closest matches 4. If the above criterion does not hold we cannot make
Notice that the outlier detection criterion adapts accord-ing to the current similarity distribution, being more strict in the initial phases (wider ( max 2  X  cMass ) ) and becoming more flexible as time passes.

Furthermore, the algorithm does not need to know a pri-ori a bound on the required time steps for execution. As soon as there is sufficient information, it makes use of it and it identifies the likely pairs. In the next section we analyze the performance of the algorithm.
Compared to the hard-clustering approach that needs to recompute the pairwise similarity matrix M for every time step, the progressive algorithm reduces the computational cost by progressively removing from the distance computa-tion the streams that have already been paired, although the initial stages of the algorithm are somehow more expensive, since in every iteration there are more operations performed than just the update of the similarity matrix M .

So, let us analyze the time and space that our algorithm requires. Initially there are n streams, so the size of ma-trix M is n 2 , hence the space requirement is O ( n 2 ) .
For the time complexity, assume that at time step t there are S t streams available. Then the running time required to execute the t th step is O ( S 2 t ) . To see that, notice that line 5, where we update the cimilarity matrix M , requires O (
S 2 t ) time steps. The foreach loop at line 6, where we process each stream, is executed at most S t times and each of the commands inside the loop can be computed in linear (in S t ) time. (The most involved is line 9 for computing the k -trim, which can be done with a variation of a linear al-gorithm for computing the median.) Therefore, the running time of every time step of the algorithm is O ( S 2 t ) , in other words there exists a constant  X  such that the time per step is bounded by  X   X  S 2 t .
 Therefore, if T r is the total running time, we have where  X  is the constant hidden in the asymptotic notation. It is therefore clear that in order to analyze the running time we have to evaluate how the values S t decrease, and in par-ticular when S t becomes 0. Our experimental results, de-picted in Figure 15, indicate that a candidate function for is given by the sigmoidal function for some constants c 1 and c 2 , which in our case we esti-mated as 15 and 20 , respectively. In Figure 8 we show the sigmoidal function that matches the observed data.
Having this in mind, we can estimate and, therefore, T r  X  c 1  X   X   X  n 2 ln n + O ( n 2 ) . Notice that we can obtain a similar bound (with worse constants) by noticing (after some calculations) that after time t =( c c )ln n we have S t &lt; 1 , so we can bound the running time by ( c 1 + c 2 )  X   X  n 2 ln n .

Therefore, the algorithm is efficient, since it only intro-duces an O ( n log n ) complexity per data stream by pro-gressively removing paired matches. In Figure 9 we depict the lifecycle of various streams for an experiment with 280 voice streams. Each line represents a voice stream and is extended only up to the point that the stream is paired. Note that this analysis is based on our observed data. A more rigorous approach can consider some underly-ing probability space to model the streams generations. Then T r and S t are random variables and we can study quantities such as the expected running time and variance, or give large-deviation bounds. For example, for the ex-pected running time of the algorithm, we have since the S t  X  X  are nonnegative. This gives the interesting conclusion that the expected running time depends on the variance of the number of streams that remain unpaired throughout the execution of the algorithm.
We explain how the previous model of pairing voice con-versations can be extended to work on a voice-over-IP net-work. In what follows we describe the structure and trans-mission protocol of a typical VoIP network and we illustrate the steps for reconstructing the binary voice activity stream from a sequence of VoIP packets.
 We consider the framework depicted in Figure 10. N VoIP subscribers are connected to the Internet either di-rectly via their ISP providers, or behind VoIP gateways on traditional PSTN networks. Those VoIP subscribers may use a low-latency anonymizing service composed of a set of overlay network nodes. Each VoIP stream traverses a possi-bly distinct set of IP routers, a subset of which are assumed to have VoIP sniffing capabilities. Each sniffer preprocesses the incoming VoIP traffic and forwards the resulting data to a central processing unit.

A voice signal captured by a communication device goes through a series of steps in preparation for streaming. Fig-ure 11 summarizes some of the following concepts. A voice signal is continually captured by the microphone of a com-munication device. The digital signal is segmented and fed to a Voice Activity Detection (VAD) unit. This feature al-lows VoIP devices to detect whether the user is currently speaking or not by analyzing voice activity. Whenever the voice activity is below a certain adaptive threshold, the cur-rent segment is dropped. Note that if the VAD algorithm is not sophisticated enough, actual voiced segments may get wrongly filtered out [12]. The filtered signal is then passed through a voice codec unit (e.g., G.729.1 or GSM) that com-presses the input voice segments to an average bit rate of approximately 10 Kbps. Those compressed segments are encrypted using 256-bit AES [2] and packetized using the Real-time Transport Protocol (RTP). Each RTP packet con-sists of a 12-byte header followed by 20 ms worth of en-crypted and compressed voice. It is important to note that all RTP headers are in the clear [2]. Various RTP header fields are of great interest for our purpose. In particular, the Payload Type (PT) field enables easy spotting of VoIP streams, the Synchronization Source (SSRC) field uniquely identifies the stream of packets, and the Timestamp field reflects the sampling instant of the first byte in the RTP payload. Finally, each RTP packet is written to a network socket.
For recasting the problem into the scenario that we previ-ously studied, we need first to reconstruct the binary streams indicating the voice activity of each one-way communica-tion. Given the above transmission protocol a VoIP sniffer that gathers incoming internet traffic can identify and sepa-rate the different voice streams and also convert them into binary streams that indicate periods of activity or silence as follows: 1. The RTP PT field is used to segregate VoIP packets 2. Each different voice stream can be tracked by its 3. Finally, the binary stream indicating the presence of
Several are the advantages of the presented approach:  X  A very important first outcome of the presented ap- X  A surprising second observation, is that the presented  X  Finally, the presented algorithm is very robust to jitter
Lastly, we briefly elaborate on certain issues or questions that may arise given the dynamic nature of the system: a) We do not assume that the network sniffers are able to track all voice streams. Singleton streams can be present. This does not pose a problem for our algorithm since we do not enforce pairing of all streams. b) The cardinality of voice conversations captured by the sniffer changes over time as calls start and/or terminate. Therefore, one should pair streams that commence at ap-proximately the same time (within twice the assumed worse network latency). This gives rise to multiple cimilarity ar-rays formed by voice streams with similar arrival times. In the experiments we do not consider this scenario, but we experiment with k voice streams that begin simultaneously for illustrating better the scalability and accuracy of our ap-proach under the maximum possible load. c) Finally, it is worth noting that the RTP Sequence Num-ber field together with the Timestamp values help avoid blindly concluding a packet has been filtered out by the VAD unit while, in fact, it has been dropped by the network. However losses are seldom in commercial VoIP networks and in this work we do assume a lossless VoIP framework.
As our experimental testbed we used real telephony con-versations from switchboard data [8], which contained 500 pairs of conversations for a total of 1000 voice streams and consisted of multiple pairs of users conversing on diverse topics. Such datasets are typically used in many speech recognition contests for quantifying the quality of differ-ent speech-to-text processes. The specific dataset that we used, consisted actually of quite noisy conversational data and the length of each conversation is 300 sec. The original voice data have been converted to VoIP packets (using the protocol described in the VoIP section), then fed onto a lo-cal network using our custom made workload generator and recaptured by the data sniffers.
In this initial experiment we compare the pairing accu-racy of the three presented complementary similarity mea-sures. We utilize the hard clustering approach which does not leave any unassigned pairs, therefore it introduces a larger amount of incorrectly classified pairs. However, since the hard clustering follows a more aggressive pairing strat-egy, this experiment essentially showcases the best possible convergence rate of the various similarity measures.
Figure 14 presents the pairing accuracy of the Mutual In-formation (MI), Jaccard Asymmetric and Jaccard Symmet-ric measures. Every 10 seconds we calculate the recogni-tion accuracy by pairing each of the voice streams with the stream that depicts the maximum complementary similarity. Notice than in this way we do not necessarily impose a 1-to-1 mapping of the streams (hence, a stream may be paired with more than one streams). We report the results using the 1-to-n mapping, since we discovered that it consistently achieves more accurate results than the 1-to-1 mapping. On the figure we can observe that the Asymmetric-Jaccard measure is the best overall performer. It achieves faster convergence rate than the Mutual Information (90% accuracy after 120sec, instead of 150sec for the MI) and also a larger amount of correctly classified pairs at the end of the experiment. The Symmetric-Jaccard measure appears to be quite aggressive in its pairing decisions in the be-ginning, but flattens out fairly quickly, therefore it cannot compete in terms of accuracy with the other two measures. Since different measures appear to exhibit diverse conver-gence rates, as possible future work it would be interesting to explore the possibility of alternating use for the various measures at different stages of the execution, in order to achieve even faster pairing decisions.

In general, the results of this first experiment are very en-couraging, since they indicate that the use of simple match-ing measures (like the Asymmetric Jaccard) can achieve comparable or better pairing accuracy than more complex measures (such as the Mutual Information). For the remain-der of the experiments we will focus on the Asymmetric-Jaccard measure, and specifically on its performance using the progressive pairing algorithm.
The progressive algorithm presented in the paper has two distinct advantages over the hard clustering approach: 1. It avoids the continuous pairwise distance computa-2. It eliminates almost completely the incorrect stream
The second goal is achieved by reducing the aggressive-ness of the pairing protocol, which in practice will have a small impact on the convergence rate (compared to the hard clustering approach). Recall that the progressive al-gorithm classifies the stream with the maximum cimilarity value ( max 1 ) as a match, if
The value f essentially tunes the algorithm X  X  conver-gence rate. Smaller values of f mean that the algorithm is more elastic in its pairing decisions, hence achieving faster convergence, but possibly introducing a larger amount of in-correctly classified pairs. By imposing larger f values, we restrict the algorithm in taking more conservative decisions. This way fewer mistakes are made, at the expense of more prolonged convergence times.
 In Figure 15 we present the accuracy of the Asymmetric-Jaccard using values of f =1 / 2 , 2 / 3 , 1 . The darker part of the graph indicates the correctly classified pairs, the medium gray the incorrect pairing, and the white part are the remaining streams for which no decision has yet been made. From the graph, one can observe that for the ex-amined dataset f =2 / 3 represents the best compromise between convergence rate and false pairing rate. The final pairing results after 300sec are: correctly paired = 972 , incorrectly paired =6 , undecided =24 . Contrasting this with the hard clustering results at 300sec (correctly paired = 982 , incorrectly paired =18 ), we see that we can achieve fewer false assignments, while being quite competi-tive on the correct assignments and at the same time accom-plishing a progressive clustering that is computationally less demanding.
We conduct experiments which indicate that the match-ing quality is not compromised by potential end-to-end net-work delay. For simplicity of exposition we assume an end-to-end delay for each stream that remains constant as time passes (even though on a real network delay will vary over time).

For this experiment we assume that each stream expe-riences a different global latency, drawn randomly from a uniform distribution within the range [0 , 2  X  ] , where  X  observed one-way network latency. We conduct 4 sets of experiments with values  X  =40 , 80 , 160 , 240 msec, there-fore the maximum possible synchronization gap between 2 pairing streams can be up to 2  X  .

Figure 16 displays the pairing accuracy using the two clustering parameters that produce the least amount of mis-classifications, f =2 / 3 and f =1 . The 3D areas indi-cate the number of correctly paired streams, while on top of the surface we also indicate in parenthesis the number of incorrect pairings. We report the exact arithmetic val-ues for the mid-point of the experiment (150sec) and at the end of the experiment (300sec). Generally, we observe that the clustering approach is robust even for large end-to-end latency. The accuracy of the pairing technique is not com-promised, since the number of misclassified pairs does not increase. For latency of 40 X 80msec the correctly classified pairs still remain approximately around 970 / 1000 . This number drops slightly to 960 / 1000 for 240msec of latency, but still the number of misclassified pairs does not change. Therefore, latency affects primarily the convergence rate , since ambiguity is increased, however accuracy is not com-promised.

One can explain these results by noting that comple-mentary similarity is most dominantly affected by the long speech and silence segments (and not by the very short ones). The long speech and non-speech patterns between conversing users are not radically misaligned by typical net-work end-to-end latencies, therefore the stream similarities in practice do not deviate significantly from their expected values.

Summarizing the experiments, we have shown that the progressive algorithm can achieve pairing accuracy that reaches 96 X 97%, while it can be tuned for faster conver-gence or minimization of false classifications. More sig-nificantly, we have demonstrated that the clustering perfor-mance is not affected by the network latency, since latency does not significantly affect the dominant temporal dynam-ics between conversational patterns. We have presented results indicating that intercepted VoIP data can potentially reveal private information such as pairs of conversing parties. Careful analysis of the voice packets coupled with an effective complementary pairing of voice activities can achieve high accuracy rates. We have also demonstrated that data encryption schemes can-not throttle the pairing of conversations. While we have attempted to examine the current problem from multiple as-pects, many avenues are still open for investigation. Areas that that we are currently exploring are the provision for distributed execution of our pairing algorithm, as well as the fusion of multiple distance measures at different execu-tion stages of the algorithm. The ultimate objective of such efforts are to provide a pairing algorithm that exhibits fast convergence, in addition to being robust and accurate. We believe that our algorithms and pairing models could be of independent interest, for general pairing of binary streaming data. Closing, we would like to point out that the main ob-jective of this paper was not to suggest ways of intercepting VoIP traffic for malicious reasons, but merely to raise the awareness that privacy on Internet telephony can be easily compromised.

