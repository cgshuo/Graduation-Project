 The application a smart phone user will launch next intu-itively depends on the sequence of apps used recently . More generally, when users interact with systems such as shop-ping websites or online radio, they click on items that are of interest in the current context. We call the sequence of clicks made in the current session interactional context . It is desirable for a recommender system to use the context set by the user to update recommendations. Most current context-aware recommender systems focus on a relatively less dynamic representational context defined by attributes such as season, location and tastes. In this paper, we study the problem of collaborative filtering with interactional con-text, where the goal is to make personalized and dynamic recommendations to a user engaged in a session. To this end, we propose the iConRank algorithm that works in two stages. First, users are clustered by their transition behav-ior (one-step Markov transition probabilities between items), and cluster-level Markov models are computed. Then per-sonalized PageRank is computed for a given user on the corresponding cluster Markov graph, with a personalization vector derived from the current context. We give an in-terpretation of the second stage of the algorithm as adding an appropriate context bias , in addition to click bias (or rating bias), to a classical neighborhood-based collabora-tive filtering model, where the neighborhood is determined from a Markov graph. Experimental results on two real-life datasets demonstrate the superior performance of our algorithm, where we achieve at least 20% (up to 37%) im-provement over competitive methods in the recall level at top-20.
 H.2.8 [ Database Management ]: Database Applications X  Data mining ; H.3.3 [ Information Storage and Retrieval ]: Information Search and Retrieval X  Information filtering  X  Collaborative Filtering, Interactional Context, Markov Model, Personalized PageRank, Context-Aware
The problem of recommending an item to a user given a sequence of items that the user recently interacted with arises in many systems. The problem is best understood by considering a smart phone user navigating through various applications (apps) on the mobile device. Mobile apps are often used in conjunction with other relevant apps. For ex-ample, if a user launches the  X  X ontacts X  app, the next app is likely to be the  X  X ail X  or the  X  X essages X  app. The cur-rent context of the user can be characterized from recently launched apps. Recommending the  X  X ight X  app to use next based on the context of the user X  X  actions would improve user experience and multitasking efficiency.

Based on the classification presented in [8], we call the context that arises from user X  X  activity within a session inter-actional context. In contrast, most of the existing context-aware recommender systems focus on representational con-text, usually defined before the user interacts and provided as attributes such as location, weather and interests [1].
The problem differs from traditional collaborative filter-ing settings, such as the Netflix rating prediction problem, in many respects. First, user interaction with items such as apps is brief and repetitive in nature, whereas items like movies are usually watched/rated once. Second, the user feedback is inherently implicit in the form of item clicks, as opposed to explicit feedback like ratings or comments. Ad-ditionally, we have a temporal ordering of clicks within user sessions. Third, recommendations must be made available dynamically as the user interacts with the system. That is, recommendations should be updated each time a user clicks an item. Finally, we have the notion of interactional context defined by the session in progress, to which the recommenda-tions are targeted. It is desirable for a recommender system to use the context set by the user to update its recommen-dations. It might be tempting to relate the aspect to that of online collaborative filtering systems [7], where systems could use newly available ratings to recompute predictions. However, there is a subtle difference. The interactional con-text should help better zero in on the apps that the user would launch next while she interacts with the system. It is therefore necessary to treat the current session differently from past sessions.

The problem is applicable in any setting where items are generally used repeatedly, such as listening to tracks from online music streaming services or browsing products in shop-ping websites. If a user has been listening to a series of rock music, she is more likely to prefer other rock music than tracks from a different genre. Note that in such general settings, the system should be able to recommend new or unseen items to the user. In the next app prediction setting, one could restrict the recommended apps to those that are already installed in the user device, or even recommend new apps that other users have used in similar context. 1 A less obvious but tangible benefit of predicting the next app is that the predicted apps can be pre-loaded to reduce both app launch latency and energy consumption [19].

In this paper, we propose a novel method, iConRank , for collaborative filtering with interactional context. The fun-damental observation is that we do not want to treat the sequence of item clicks as raw counts, but as ordered tran-sitions. We model users X  transition behavior between items as a Markov chain, where transition probabilities are em-pirically estimated. A single global Markov model would fall short of capturing diverse transition patterns. On the other hand, a fully personalized Markov model would suffer from extreme sparsity of observed transitions. So, we seek cluster-level Markov models, where the clusters themselves are behavioral . That is, we cluster users by their sparse one-step item transition probabilities and compute a rep-resentative Markov model per behavioral cluster. We de-velop our method by introducing a context bias to a classical neighborhood-based collaborative filtering model. Our for-mulation essentially leads to a personalized PageRank [10] on a particular Markov graph, where the so-called  X  X erson-alization X  vector is derived from interactional context.
Our contributions are as follows:  X  The problem of incorporating interactional context in col-laborative filtering is relatively unexplored (See Section 2).
Though the setting is motivated from app launch patterns of smart phone users, it is applicable in many click-based interactive systems.  X  We propose iConRank that makes personalized and dy-namic recommendations given the current session. Rec-ommendations are updated as the user interacts with the system. We show that the quality of recommendations made by our algorithm is superior to those of competitive methods on two real-life datasets.  X  Behavioral clustering of users allows the system to make recommendations using past item transitions of a given user as well as transitions from users with similar naviga-tional patterns.  X  Our method is scalable and can handle large problems efficiently. The clustering stage of our algorithm is done offline. Personalized PageRank can be computed in a scal-able manner, as detailed in Section 4.3, which enables im-plementation on devices with limited processing power. The remainder of the paper is organized as follows. In Section 2, we review some closely related work. We present a formal description of the problem setting in Section 3. In Section 4, we discuss important aspects of the problem that need to be addressed, and develop our algorithm iConRank . Experimental results on two real-life datasets are reported in Section 5. We conclude in Section 6.
Traditional collaborative filtering techniques use a history of item preferences by a set of users in order to recommend items of interest to a given user. Commonly used classes of methods are neighborhood-based and latent factor models. Neighborhood-based methods involve computing a measure of similarity between pairs of users or items, and obtaining predictions by taking a weighted average of ratings of similar users or items [17, 4]. Another family of model-based collab-orative filtering algorithms is based on latent factor models [12, 16], where user preferences are modeled as interactions between unobserved user and item factors.

Previous research has shown that contextual information can enhance the performance of recommender systems in various applications. Based on the classification of con-text introduced in [8], context can be distinguished into two types: representational and interactional . The majority of context-aware recommender systems have investigated the use of representational context, such as time, location and weather [1]. Some context-aware neighborhood-based mod-els [5, 13] incorporate such contextual information in the similarity measure between users. Another approach de-scribed in [3] introduces item splitting, where item ratings are split into two virtual items based on a given contextual condition. The virtual items are used instead of the orig-inal ones in different collaborative filtering algorithms and a rating is predicted for the virtual item corresponding to the current user X  X  context. The context-aware latent factor model in [2] includes attribute-based context variables as biases to appropriately learn the model parameters. In the tensor factorization method proposed in [15], additional di-mension for contextual information is added to the standard user-item ratings matrix.

There has been limited work on recommender systems that incorporate interactional context. Hariri, et. al [9] also consider the problem of recommending the next track given a sequence of tracks recently played. Each sequence of tracks in a hand-compiled playlist database is first represented as a sequence of latent topics (using topic modeling). Frequent patterns of topics are discovered from the topic sequences us-ing a pattern-mining algorithm. These sequential patterns are then used to predict relevant topics given a user session. The predicted topics are used to post-filter an initial ranking produced by a traditional recommendation algorithm. The method is applicable only when the number of topics is small or the maximum length of a session is short. Enumerating all possible sequences can be computationally infeasible oth-erwise. Moreover, recommendations are not personalized as sequential patterns are mined from the entire population. In the domain of mobile application, recent work on predicting app launch [19] uses both representational (location, time) and interactional (app launch) context information to engi-neer features. However, the approach in [19] uses only the first app in a given session, which is considered as the trig-ger. In contrast, our approach considers all apps launched in the current session.
Our problem setting is motivated by smart phone users who exhibit patterns of interaction with the device through mobile apps. The sequence of apps launched by a user de-fines the interactional context of the user X  X  actions. Interac-tional context arises from the user X  X  activity within a session and is dynamic. The setting is applicable to any click-based recommender system, where recommendations are updated as the users click on an item (Youtube, Spotify, etc).
We refer to the sequence of items accessed by a user over a certain contiguous period as a session . In practice, sessions are defined based on the type of activity (e.g. articles read by an online user when she is signed in). Note that we do not consider any temporal aspects of the session, other than the ordering of clicks. Existing context-aware recommender sys-tems focus on attribute-based representational context that is less dynamic and often fixed before the start of a session. A given user may have specified a set of preferences globally, but it is often the case that user preferences change between sessions. The goal of this paper is to present recommenda-tions to a given user based on her past sessions, sessions of other users in the system and the current session in progress . The key aspects of our problem setting are: 1. There are no explicit  X  X ikes X  or  X  X islikes X  of an item, un-like the case of Netflix ratings. We want to come up with a ranking of items that the user will click next in the current session. Following the recommender systems lit-erature, our setting relies on implicit feedback as against the Netflix prize setting that uses explicit feedback . 2. Users may be interested in multiple categories of items, but given the sequence of clicks made in the current ses-sion, there is an added context bias that needs to be ac-counted for. In general recommender systems, user bias and item bias are accounted for whereas context bias is either ignored or is not applicable.

We would like to emphasize here that though the first as-pect in isolation is well-known in the recommender systems community [14, 20], the second aspect has received little attention [9]. The item recommendation problem in the Collaborative Filtering with Interactional Context setting is formally stated as follows. Given a history of sessions S of users U = { u 1 ,u 2 ,...,u |U| } over a set of items I = { a 1 ,a 2 ,...,a and a specific user u  X  U with session in progress s =  X  a 1 ,a i 2 ,...,a i t  X  , for some t  X  1, we want to recommend the best candidate item a i t +1  X  I . Note that we want the recommendations to be (a) personalized to the user u , and (b) relevant to the context of the session s . The classical collaborative filtering systems (with implicit feedback) con-sider a specific case of the problem where the current session is ignored and the goal is to come up with a set of recom-mendations based on the click history.
In our problem setting, we work with implicit feedback in the form of click sequences. A widely-used collaborative fil-tering approach for implicit feedback data is to simply form a user-item count matrix, where an entry represents the num-ber of times 2 a user has clicked on an item in the past. Any of the collaborative filtering approaches for explicit feedback such as matrix factorization or similarity-based methods can then be applied on the count matrix. However, such a naive approach is not appropriate for reasons manyfold. Most im-portantly, we do not want to predict any exact rating  X  we just need a ranking of relevant items. It is inherently hard to gauge user preferences with clicks  X  lack of an es-tablished scale like star ratings makes it tricky to compute similarities between users or items. For a detailed discussion of what prevents a direct use of algorithms designed for ex-plicit feedback, see [14]. We will see later in the experiments (Section 5) that collaborative filtering methods on the count matrix perform poorly.

Some latent factor models for ratings data include biases due to attribute-based context variables such as location to appropriately learn the model parameters [2]. Other than the absence of explicit feedback, such context-aware models pose another immediate challenge  X  they rely on rating instances for different settings of context variables to learn the appropriate biases. In the case of interactional context, it is not obvious how to succinctly define context variables and obtain associated training examples. Also, it must be efficient to update model parameters as the current session progresses in order to provide dynamic recommendations.
In this section, we first describe how we model history in the form of click sequences. Then, we derive our PageRank-based method by incorporating interactional context in an existing collaborative filtering framework. Finally, we present our algorithm iConRank .
The fundamental observation is that we do not want to treat the session history as counts but as sequences instead. A simple and effective way to model sequences is to use Markov models. Ideally, we would want to know the proba-bility of user clicking on an item given the current session. To this end, we model the users as Markov. The set of items I corresponds to the state space of the Markov model, and the state transition probability M ij is the probability that item j is clicked immediately after item i . From the sessions data, we can estimate M ij as the fraction of times item j appears immediately after item i , whenever i appears.
Typically, a given user does not have enough training data to estimate |I| X |I| parameters of the Markov model. On the other hand, we do not need to determine a personalized Markov model for each user. The basic idea of collaborative filtering is to combine preferences from  X  X imilar X  users in order to make recommendations for a given user. One naive way to combine preferences in our setting is to use session data of all users to determine a single global Markov model. While the training data may be rich enough to estimate a global model, it is less likely to be a good characterization of the diverse transition behavior of users. The aforementioned fully personalized and fully global models fall short, and our approach is to use cluster-level Markov models. It is reasonable to suppose that there are different clusters of users exhibiting a common navigational pattern. To discover behavioral clusters using session data, we need to find a good representation of users, where users who have similar transition patterns are  X  X lose X  to each other than those that are not.
First, we note that the user-item count matrix itself can-not be used for clustering  X  we want the clusters to indicate how users click and not what users click. In particular, we want a feature map  X  u that encodes the fraction of times a particular transition was made, rather than the number of transitions. Let  X  : U  X  M , where M denotes the set of row-stochastic matrices, i.e. M = { M  X  R |I| X |I| : M ij 0 , P j M ij = 1 } . In particular,  X ( u ) = M ( u ) denotes the one-step Markov transition probability matrix estimated from the session history of user u . Now, we need a distance measure to cluster users in the space of transition probability matrices. An appropriate measure of distance between two probability distributions is the KL-divergence or the relative entropy. The KL-divergence d KL ( x,y ) be-tween two p -dimensional probability distributions x and y is defined as: The distance between two users u and v is in turn defined as: We have 3 d ( u,v )  X  0 since d KL ( .,. )  X  0 and d ( u,v ) = 0  X  X  X  M ( u ) = M ( v ) . For the actual clustering step, we optimize the k -means objective. The centroid of the cluster  X  k is computed as where |  X  k | denotes the number of users assigned to cluster k . Note that M k  X  X  and we use M k as the Markov model for the k th cluster.

In Figure 1, we show 4 three behavioral clusters discov-ered in one of our experimental datasets consisting of logs of artists played by users of an online radio station (see Sec-tion 5.1.2). The clusters are computed using k -means with the KL-divergence measure (1). Observe that different clus-ters of users exhibit distinct navigational patterns among the top-20 artists.
We motivate our approach from a classical memory-based collaborative filtering model. Memory-based algorithms pre-dict ratings for a given user based on past ratings of the user and other users in the system [17, 4]. The neighbor-hood models are a classical example, where the predicted rating of an item by a user is given by a weighted combina-tion of  X  k -nearest neighbor X  items (or users). The weights are proportional to the  X  X imilarity X  between items, which is represented by the vector of observed user ratings. The Pearson correlation coefficient and cosine similarity are two commonly used similarity measures. The similarities be-tween all item pairs are computed offline, and the predicted rating  X  r u,i for a user u and an item i is given by where N ( i ) denotes the  X  X eighborhood X  set of item i . For example, in the cosine similarity case, the top-k items with highest cosine similarity with item i constitute N ( i ). Typ-ically, a rating bias term b u,i is included to account for the user bias (some users are predisposed to rate higher in gen-eral) and item bias (some movies get higher ratings than others). The weights are usually normalized for rating pre-diction tasks.

Let us focus on the item recommendation problem in the interactional context setting, where the knowledge of the current session is available. First, we want to use the clus-ter Markov models computed using (2) to learn a ranking of items given the user u and the current session s . Second, we want to incorporate interactional context in (3). In particu-lar, we want to introduce a context bias term c u,i in addition to the rating bias b u,i . In the implicit feedback setting, we interpret b u,i as accounting for click bias rather than rating bias. To this end, we want a scoring function f u,i using both past sessions and current session s for the user u . Suitably modifying (3), we have, where the nonnegative weight  X  controls the tradeoff be-tween the current context and information from the past sessions. Notice the recurrence nature of the above equation  X  we want to estimate all user-item scores as the session progresses , as against the context-aware model suggested in [2] based on attribute-based context variables.

Define z u,i = f u,i  X  b u,i for all u  X  U and i  X  I , so that we can remove the click bias from the equation resulting in a simpler model: From the graph corresponding to the Markov model with transition probability matrix M , we set w ( i,j ) = M ji gives an intuitive interpretation that items that tend to tran-sition to i more often should receive higher similarity than items that do not. Given the choice of w ( i,j ), N ( i ) corre-sponds to items that are adjacent to i in the Markov graph. Estimating c u,i using the click sequences can be hard and expensive. However, it is easy to specify what items appear in the current session s . We let c u,i = 1 if the item a pears in s or 0 otherwise. Let c u denote the indicator vector with i th entry equal to c u,i , and let the vector of item scores for a given user u be z u . Rewriting (5) in matrix form: Letting 1 denote vector of all ones, and normalizing z u to sum to 1, the above equation can be rewritten as: The quantity z u is nothing but the personalized PageRank vector for user u , using the graph M and personalization vector c u . Thus we have an efficient way to estimate z Recall that the click bias b u,i was obviated to compute c So, the final score is given by f u,i = z u,i + b u,i . A standard way to estimate click bias is to average the launch count of item a i over users. 5 However, a better choice would be to use transition probabilities of item a i t to other items, where i is the index of the last item in s , since we focus on item transitions. We find in our experiments that M ( u ) i fective choice for click bias. The final score for the user-item pair ( u,i ), given the current session s =  X  a i 1 ,a i 2 where z u,i is the solution to (6).
We are now ready to give our algorithm iConRank for recommending items in the collaborative filtering with in-teractional context setting. Given a current session s =  X  a 1 ,a i 2 ,...,a i t  X  executed by a given user u , history of ses-sions S for all users in U , and number of behavioral clusters K , the iConRank algorithm is specified as follows: 1. ( Offline step ) Cluster U using the sessions history S into
K clusters by first forming the per-user transition matri-ces and then using the k -means algorithm as described in
Section 4.1.1. Compute the corresponding Markov tran-sition probabilities M k for each cluster k  X  [ K ] using (2). 2. Let  X  ( u ) denote the cluster to which user u belongs. Set c u to be the normalized indicator vector of items appear-ing in s . Compute the personalized PageRank z u by (6) with M = M  X  ( u ) and current c u . 3. Compute scores f u,i , for all i 6 = i t using (7). 4. Rank the items using the computed scores, and return the top-N items as recommendations for a i t +1 .
 A few remarks on iConRank algorithm are in order: Efficiency: Note that the clustering step is done offline as it is independent of current session s . Steps 2 through 4 are executed every time the user clicks, i.e. as session s progresses, so that the recommendations can be updated. Computing the personalized PageRank in Step 2 can be ex-pensive if |I| is of the order of tens of thousands, even if the matrices M k are sparse. Scalability is even more of a concern if the algorithm is to be implemented in real-time systems with small processing capabilities like mobile phones. The linearity property of personalized PageRank [10] stated be-low can be exploited to implement Step 2 in a scalable way. Let z u ( v ) denote the solution to (6) computed with the per-sonalization vector c u = v . Then: for nonnegative  X  and distributions v 1 and v 2 . We can pre-compute z u ( e i ) for i = 1 , 2 ,..., |I| , where e i i th column of the identity matrix. Then, for a given session s =  X  a i 1 ,a i 2 ,...,a i t  X  , and chosen c u = v we can compute z u efficiently as: It is easy to see why the above equality holds: Our choice of c u = v is such that it is non-zero only in the positions corresponding to items that appear in s , and is normalized to sum to 1.
 Cold-start: The algorithm can seamlessly deal with new users. In particular, we can choose c u to be the uniform distribution over items and use the global Markov model
In this section we present experimental results of our pro-posed algorithm, iConRank , on two real-life datasets: Apps and LastFM . We first give a detailed description of the two datasets and the experimental setting. Next we compare the recommendation performance of iConRank to a number of other successful methods. We also evaluate the methods on recommending existing and new items and study how performance is influenced by current session length.
For testing, we measure the accuracy of recommending the next item a i t +1 , given the current session s =  X  a i 1 of a user. Thus, there is only one correct item for each test case. A user is usually presented with a small list of rec-ommended items. Therefore, we measure recall at top-N (Recall@ N ) for N = 5 , 10 , 15 , 20. For the sake of complete-ness, we also report the ROC curve (recall vs. precision plot up to N = 1 , 000), which is the standard measure for com-paring the recommendation qualities of different methods for recommender systems. Recall and precision are measured in the standard way for top-N recommendation tasks [6].
The datasets used in this study consist of user event logs with timestamps, where the events are launching mobile apps or streaming tracks of an artist. Sessions are formed from the user logs. We note that consecutive uses of the same item are considered as a single interaction for methods using sequences, including ours. However, launch counts are retained for use by methods based on the user-item matrix.
Table 1: Statistics of Apps and LastFM datasets. (a) Item count distribution Figure 2: Item count and session length distributions Training data consists of all sessions before a chosen date. Table 1 shows relevant statistics of each dataset.
The Apps dataset is a proprietary dataset obtained from a manufacturer of mobile devices. It consists of mobile app usage patterns of smart phone users. 7 The dataset spans over a one year period and each log record consists of user, timestamp information and one of the two events, app launch and screen on/off . The screen on/off event is used as an indicator of a new session, i.e., a new session is started when the screen is on and the current session is ended when the screen is off and at least one minute has elapsed. 8 Figure 2(a) plots the distribution of item count, which corresponds to launch count of apps. Apps in the horizontal axis are ordered by their launch counts, with the most frequently launched app on the left. We can see in Figure 2(a) that top 1% of the most frequently launched apps cover about 85% of total launch counts. Figure 2(b) shows the CDF of the length of sessions. About 87% of sessions have at most length 10. Our statistics align with the findings in [18] that interactions with smart phones are mostly brief.
The LastFM ( last.fm ) dataset consists of listening habits of about 1,000 users, where each log contains user, track, artist and timestamp. It has been used in many studies [11, 20]. Here, the task is to recommend the next artist to listen to. Unlike the Apps dataset, the LastFM dataset lacks any explicit indication of start or end of a session. So, we mark sessions by periods of inactivity. We end a session if there is no other artist streamed within an hour from the last artist and start a new one with the next artist. 8 Listening to music is a more time consuming activity than using a smart phone. Furthermore, preference over artists is more diverse than the apps case, where pre-installed apps are more commonly used. These differences show up in Figure 2. Sessions in LastFM tend to be longer and more diverse  X  about 50% of sessions have at least length 10 and top 1% of the most frequent artists cover only about 55% of total counts.
We first analyze the behavioral clusters obtained. Then we compare the performance of iConRank to baseline and other context-aware collaborative filtering methods. Dataset Cluster Users nnz( M k ) Session Length Avg. Median
Apps
LastFM Table 2: Statistics of clusters in Apps and LastFM datasets. (contacts,phone) (phone,dialer) (phone,dialer) (message,contacts) ( search,browser ) (1,phone) ( contacts,settings ) ( phone,browser ) (message,mail) Table 3: Most frequent app transitions of each cluster.
We cluster the users as described in Section 4.1.1. In our experiments, we set the number of clusters k = 3. We note that there was no significant difference in terms of perfor-mance with larger k . To help characterize each cluster, we summarize some statistics of each cluster in Table 2. For the Apps dataset, the first cluster is smaller than the other two, but has longer sessions than the second cluster. The third cluster has the largest nnz( M k ), i.e., number of nonzeros in M k or the number of unique transitions. For the LastFM dataset, the clusters are of similar sizes, but the number of unique transitions is relatively distinct.

For the Apps dataset, we report the most frequent tran-sitions of each cluster in Table 3. As expected, transitions occur between related apps, such as contacts and phones, browser and search, etc., and it is apparent from Table 3 that each cluster represents a distinct type of app transi-tion behavior. For example, users in the first cluster can be viewed as power users who transition between apps like  X  X et-tings X ,  X  X ata X  and  X  X amera X . In contrast, the second cluster has shorter sessions as reported in Table 2, and transitions are concentrated on basic apps such as  X  X rowser X ,  X  X earch X  and  X  X alendar X . For the LastFM dataset, we visualize behav-ioral patterns for each cluster in Figure 1 (see Section 4.1.1).
We compare iConRank to the following collaborative fil-tering methods:  X  NNCosNgbr : Non-Normalized Cosine Neighborhood [6] is a neighborhood-based model using cosine similarity be-tween items (represented as vectors of launch counts).
The score for item a i for a given user is calculated as a weighted average of the k -nearest neighbor items of a i as in (3), where we set k = 5 and use cosine similarity as the weights.  X  SVD( r ) : The scores are computed as  X  R = U  X  V T where A  X  R |U| X |I| is the user-item count matrix, r is the number of latent factors, U  X  R |U| X  r , V  X  R |I| X  r are orthonormal matrices and  X   X  R r  X  r is a diagonal matrix of the top r singular values. Missing values of A are typically set to zero. The method has been shown NNCosNgbr 0.0691 0.1044 0.1328 0.1560 ContextNgbr 0.0597 0.0775 0.0884 0.0971
SeqPattern 0.0371 0.0536 0.0656 0.0748 and LastFM datasets, respectively. to achieve good performance in top-N recommendation tasks [6].  X  Markov : The recommended item a t  X  depends on the last item a t in the current session via the global Markov model.
Formally, t  X  = argmax j M tj , where M is the global tran-sition probability matrix estimated from the sessions of all users.  X  ContextNgbr : Identical to NNCosNgbr except that the k -nearest neighbors are computed from the set of items in the current session. We use k = 5 (include all items in the current session if its length is less than k ).  X  SeqPattern : Sequence mining algorithm used in [9]. 9 We use the last 10 items as the user X  X  active session. The last three methods are context-aware approaches that consider user X  X  current session. We note that ranking items by popularity (i.e. number of times an item is accessed in the training phase), which is known to perform reasonably well in recommendation tasks, does significantly worse in our setting than the methods we compare here.

Table 4 reports the Recall@ N of the methods on both datasets for N = 5 , 10 , 15 , 20. Our algorithm, iConRank , sig-nificantly outperforms all other methods with impressive re-call rates. It achieves the highest recall of 0.8632 for the Apps dataset, which means the app a i t +1 that a user will use has a probability of about 86% to be ranked in the top-20 results returned by iConRank . The next best performing method for the Apps dataset is SeqPattern followed by ContextNgbr , both of which use current context. However, they are the two worst performing methods for the LastFM dataset. This can be expected as the number of items is much larger than in the Apps dataset. SeqPattern suffers from the sheer diver-sity of artists and lack of adequate representative patterns in the training data. Among the two collaborative filtering based techniques, SVD performs better than NNCosNgbr in both the datasets confirming the findings of [6]. 10 Surpris-ingly, the simple Markov model performs better than col-laborative filtering based methods for the Apps dataset, but fails in the LastFM dataset conforming to our intuition that a single global Markov model is not enough. In evaluating the methods on the Apps dataset, the recommended candidate apps for a given user can contain apps that are not installed in the user X  X  device, which is consistent with the evaluation on the LastFM dataset. 11
The ROC curve (up to top-1,000 recommendations) is given in Figure 3. iConRank generally achieves the highest precision for any given recall. One exception is SeqPattern which achieves slightly better recall (about 0.05 higher) at top-1 for the Apps dataset. However, it immediately starts to degrade in performance falling below iConRank for N &gt; 1. We further study the performance in different categories: existing and new items. Specifically, evaluation is restricted to items that appeared at least once in the training data ( X  X xisting X ) or those that were not seen in the training data ( X  X ew X ) for each user. The results are presented in Figure 4. We can see that iConRank not only performs well on ex-isting items, but is also capable of recommending new items to users significantly better than the rest.

A desirable property of our algorithm is that it is able to make more accurate recommendations as more items are observed in a given session. We examine how iConRank per-Figure 3: ROC curve for Apps and LastFM datasets up to top-1,000 recommendations. iConRank achieves highest precision-recall rates. Figure 4: Recall@20 for existing and new items. iConRank performs the best in all cases. Figure 5: Recall@20 of different session lengths. Performance increases as the session length in-creases showing that iConRank effectively captures the current context. forms as more of the current session is revealed. In par-ticular, we measure Recall@20 when t (length of s ) varies as shown in Figure 5. As the session length increases, Re-call@20 also increases for both datasets, illustrating that iConRank effectively captures the current context of the ses-sion. Especially, the performance greatly increases after ob-serving just two items in a given session. However, we also find that recall rates can drop when t becomes very large (not shown in the figure)  X  the personalization vector tends to a uniform distribution and context ceases to have rele-vance. In practice, most of the sessions are short as shown in Figure 2(b).
In this paper we have considered the problem of collab-orative filtering with interactional context to recommend potential items of interest to a user already engaged in a session, using past sessions of the user and of other users. We are given implicit feedback in the form of clicks and a session that establishes the current context of a user. Our problem setting differs from the traditional setting of collab-orative filtering in crucial respects. We propose iConRank , a novel method that is motivated by introducing  X  X ontext bias X  in the neighborhood-based model. Our formulation es-sentially leads to the personalized PageRank, where context is captured by the personalization vector. Experimental re-sults on real-life datasets demonstrate that our algorithm achieves superior recommendation performance illustrating its ability to capture the context of a given session.
As part of future work, we plan to study how to combine both interactional context and representational context such as location and time. Exploring other collaborative and con-tent filtering methods to incorporate interactional context are promising research directions.
This research was supported by NSF grant CCF-1117055.
