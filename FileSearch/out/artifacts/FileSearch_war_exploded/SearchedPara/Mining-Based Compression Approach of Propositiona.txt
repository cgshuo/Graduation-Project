 In this paper, we propose a first application of data min-ing techniques to propositional satisfiability. Our proposed mining based compression approach aims to discover and to exploit hidden structural knowledge for reducing the size of propositional formulae in conjunctive normal form (CNF). It combines both frequent itemset mining techniques and Tseitin X  X  encoding for a compact representation of CNF for-mulae. The experimental evaluation of our approach shows interesting reductions of the sizes of many application in-stances taken from the last SAT competitions.
 F.4.1 [ Mathematical logic and formal languages ]: Math-ematical Logic X  Logic and constraint programming ; H.2.8 [ Database management ]: Database applications X  Data mining Compression; Data mining; Propositional satisfiability and modeling
Propositional satisfiability (SAT) i.e., the problem of check-ing whether a Boolean formula in conjunctive normal form (CNF) is satisfiable or not, became a core technology in many application domains, such as formal verification, plan-ning and various new applications derived by the recent im-pressive progress in practical SAT solving. SAT has gained a considerable audience with the advent of a new genera-tion of solvers able to solve SAT instances with millions of variables and clauses [9, 4]. Today, these solvers represent an important low-level building block for many important fields, e.g., SAT modulo theory, Theorem proving, Model checking, Quantified Boolean formulas, Maximum Satisfia-bility, Pseudo Boolean, etc. In addition to the traditional applications of SAT to hardware and software formal verifi-cation, this impressive progress led to increasing use of SAT technology to solve new real-world applications such as in bioinformatics, cryptography and data mining.

Propositional formulae in CNF is the standard input for-mat for propositional satisfiability. Indeed, most of the state-of-the-art SAT solvers are based on this normal form. Such convenient CNF representation is derived from a gen-eral Boolean formula using the well-known Tseitin encoding [14]. In practice, the general Boolean formula itself is usually derived from high level language in which problem structure is explicit.

Two important flaws were identified on the CNF form and largely discussed in the literature (e.g. [6]). First, it is often argued that by encoding arbitrary propositional formulae in CNF, structural properties of the original problem are not reflected in the CNF formula. Secondly, even if such transla-tion is linear in the size of the original formula, a huge CNF formula might result when encoding real-world problems. Some instances exceed the capacity of the available mem-ory, and even if the instance can be stored, the time needed for reading the input instance might be higher than its solv-ing time. The obstacle here is not the potential difficulty of the instance, but its size. The growing success obtained in solving real-world SAT problems highlights a real transition to industrial and commercial scale. This results in a rapid growth in the size of the CNF instances encoding real-world problems. Consequently, the design of new efficient models for representing and for solving SAT instances of very large sizes ( X  X ig X  instances) is clearly an important challenge.
To address this problem, developing a more compact rep-resentation of CNF formulae is an interesting research issue. By compact encoding of formulae, we have in mind a repre-sentation model which through its use of structural knowl-edge results in the most compact possible formula equivalent with respect to satisfiability. By structural knowledge, we mean patterns that can be recognized or discovered. To be useful, such algorithm must be incremental. Two promising models were proposed these last years. The first, proposed by H. Dixon et al [3], uses group theory to represent several classical clauses by a single clause called an  X  X ugmented clause X . The second model was proposed by M. L. Ginsberg et al [5], called QPROP ( X  X uantified proposi-tional logic X ), which may be seen as a propositional formula extended by the introduction of quantifications over finite domains, i.e. first order logic limited to finite types and without functional symbols. The problem rises in finding efficient solving techniques of formulae encoded using such models.

More recently, an original approach for compacting sets of binary clauses was proposed by J. Rintanen in [12]. Binary clauses are ubiquitous in propositional formulae that repre-sent real-world problems ranging from model-checking prob-lems in computer-aided verification to AI planning prob-lems. In [12], using auxiliary variables, it is shown how constraint graphs that contain big cliques or bi-cliques of binary clauses can be represented more compactly than the quadratic and explicit representation. The main limitation binary clauses whose constraints graph represents cliques or bi-cliques. Such particular regularities can be caused by the presence of an at-most-one constraint over a subset of Boolean variables, forbidding more than one of them to be true at a time.

In the data mining community, several models and tech-niques for discovering interesting patterns in large databases has been proposed in the last few years. The problem of mining frequent itemsets is well-known and essential in data mining, knowledge discovery and data analysis. Since the first article of Agrawal [1] on association rules and itemset mining, the huge number of works, challenges, datasets and projects show the actual interest in this problem (see [13] for a recent survey).

Our goal in this work is to address the problem of finding a compact representation of CNF formulae. Our proposed mining based compression approach aims to discover hidden structures from arbitrary CNF formulae and to exploit them to reduce the overall size of the CNF formula while preserv-ing satisfiability. It is the first application of data mining techniques to Boolean Satisfiability.

Recently, a first constraint programming (CP) based data mining framework was proposed by Luc De Raedt et al. in [11, 2]. This new framework offers a declarative and flex-ible representation model. It allows data mining problems to benefit from several generic and efficient CP solving tech-niques [8]. This first study leads to the first CP approach for itemset mining displaying nice declarative opportunities while opening interesting perspectives to cross fertilization between data-mining, constraint programming and proposi-tional satisfiability.

In this paper, we are particularly interested in the other side of this innovative connection between these two research domains, namely how data-mining can be helpful for SAT. We present the first data-mining approach for Boolean Sat-isfiability. We show that itemset mining techniques are very suitable for discovering interesting patterns from CNF for-mulae. Such patterns are then used to rewrite the CNF formula more compactly. We also show how sets of binary clauses can be also compacted by our approach. We also prove that our approach can automatically achieve similar reductions as in [12], on bi-cliques and cliques of binary
Table 1: An example of transactions database D clauses. It is also important to note, that our proposed mining4SAT approach is incremental. Indeed, our method can be applied incrementally or in parallel on the subsets of any partition of the original CNF formula. This will be particularly helpful for huge CNF formula that can not be entirely stored in memory. Let I be a set of items . A set I  X  I is called an itemset . A transaction is a couple ( tid,I ) where tid is the transaction identifier and I is an itemset. A transactions database D is a finite set of transactions over I where for all two different transactions, they do not have the same transaction identi-fier. We say that a transaction ( tid,I ) supports an itemset J if J  X  I .

The cover of an itemset I in a transactions database D is the set of identifiers of transactions in D supporting I : C ( I, D ) = { tid | ( tid,J )  X  X  and I  X  J } . The support of an itemset I in D is defined by: S ( I, D ) = |C ( I, D ) | . Moreover, the frequency of I in D is defined by: F ( I, D ) = S ( I, D ) For example, let us consider the transactions database in Table 1. Each transaction corresponds to the favorite writers of a library member. For instance, we have : S ( { Hemingway,Melville } , D ) = |{ 2 , 4 }| = 2 and F ( { Hemingway,Melville } , D ) = 1 3 .
 Let D be a transactions database over I and  X  a minimal support threshold. The frequent itemset mining problem consists of computing the following set: FIM ( D , X  ) = { I  X  I |S ( I, D ) &gt;  X  } .

The problem of computing the number of frequent item-sets is # P -hard [7]. The complexity class # P corresponds to the set of counting problems associated with a decision problem in NP . For example, counting the number of mod-els satisfying a CNF formula is a # P problem.
Let us now recall two popular condensed representations of the set of all frequent itemsets: maximal and closed fre-quent itemsets.

Definition 1 (Maximal Frequent Itemset). Let D be a transactions database,  X  a minimal support threshold and I  X  FIM ( D , X  ) . I is called maximal when for all I  X  I , I 0 /  X  X IM ( D , X  ) ( I 0 is not a frequent itemset).
We denote by MAX ( D , X  ) the set of all maximal frequent itemsets in D with  X  as a minimal support threshold. For instance, in the previous example, we have MAX ( D , 2) = {{ Joyce,Proust } , { Hemingway,Melville }} .
Definition 2 (Closed Frequent Itemset). Let D be a transactions database,  X  a minimal support threshold and I  X  FIM ( D , X  ) . I is called closed when for all I C ( I, D ) 6 = C ( I 0 , D ) .

We denote by CLO ( D , X  ) the set of all closed frequent itemsets in D with  X  as a minimal support threshold. For instance, we have CLO ( D , 2) = {{ Hemingway } , { Joyce,Proust } , { Hemingway,Melville }} . In particular, let us note that we have C ( { Hemingway } , D ) = { 2 , 4 , 6 } and C ( { Hemingway,Melville } , D ) = { 2 , 4 } . That explains why { Hemingway } and { Hemingway,Melville } are both closed. One can easily see that if all the closed (resp. max-imal) frequent itemsets are computed, then all the frequent itemsets can be computed without using the corresponding transactions database. Indeed, the frequent itemsets cor-respond to all the subsets of the closed (resp. maximal) frequent itemsets.

The number of maximal (resp. closed) frequent itemsets is significantly smaller than the number of frequent itemsets. Nonetheless, this number is not always polynomial in the size of the database [16]. In particular, the problem of counting the number of maximal frequent itemsets is # P -complete (see also [16]).

Many algorithm has been proposed for enumerating fre-quent closed itemsets. One can cite Apriori-like algorithm, originally proposed in [1] for mining frequent itemsets for association rules. It proceeds by a level-wise search of the elements of FIM ( D , X  ). Indeed, it starts by computing the elements of FIM ( D , X  ) of size one. Then, assuming the element of FIM ( D , X  ) of size n is known, it computes a set of candidates of size n + 1 so that I is a candidate if and only if all its subsets are in FIM ( D , X  ). This proce-dure is iterated until no more candidates are found. Ob-viously, this basic procedure is enhanced using some prop-erties such as the anti-monotonicity property that allow us to reduce the search space. Indeed, if I /  X  FIM ( D , X  ), then I 0 /  X  FIM ( D , X  ) for all I 0  X  I . In our experiments, we consider one of the state-of-the-art algorithms LCM for mining frequent closed itemsets proposed by Takeaki Uno et al. in [15]. In theory, the authors prove that LCM ex-actly enumerates the set of frequent closed itemsets within polynomial time per closed itemset in the total input size. Let us mention that LCM algorithm obtained the best im-plementation award of FIMI X 2004 (Frequent Itemset Mining Implementations).
We first introduce the satisfiability problem and some necessary notations. We consider the conjunctive normal form (CNF) representation for the propositional formulas. A CNF formula  X  is a conjunction of clauses, where a clause is a disjunction of literals. A literal is a positive ( p ) or negated (  X  p ) propositional variable. The two literals p and  X  p are called complementary . A CNF formula can also be seen size of the CNF formula  X  is defined as |  X  | = P where | c | is equal to the number of literals in c . A unit clause is a clause containing only one literal (called unit lit-eral ), while a binary clause contains exactly two literals. A formula containing only binary clauses is called 2-CNF for-mula. An empty clause , denoted  X  , is interpreted as false (unsatisfiable), whereas an empty CNF formula , denoted &gt; , is interpreted as true (satisfiable).

Let c 1 and c 2 be two clauses of a formula  X . We say that c subsumes c 2 iff c 1  X  c 2 . If c 1 subsumes c 2 , then the clause c can be deleted from  X  while preserving satisfiability. A CNF formula  X  is closed under subsumption iff  X  c  X   X , @ c 0 such that c 6 = c 0 and c 0 subsumes c . We denote by  X  s formula obtained from  X  by eliminating all the subsumed clauses.

We note  X  l the complementary literal of l . More precisely, that any propositional formula can be translated to CNF using Tseitin X  X  linear encoding [14]. We denote by V  X  the set of propositional variables appearing in  X , while the set of literals of  X  is defined as L  X  .

An interpretation B of a propositional formula  X  is a func-tion which associates a value B ( p )  X  { 0 , 1 } (0 corresponds to false and 1 to true ) to the variables p  X  X   X  . A model of a formula  X  is an interpretation B that satisfies the formula: B ( X ) = 1. The SAT problem consists in deciding if a given CNF formula admits a model or not.

We define  X  | x as the formula obtained from  X  by assigning x the truth-value 1. Formally  X  | x = { c | c  X   X  , { x,  X  x } X  c =  X  X  X  X  c \{ X  x } | c  X   X  ,  X  x  X  c } .  X   X  denotes the formula  X  closed under unit propagation , defined recursively as follows: (1)  X   X  =  X  if  X  does not contain any unit clause, (2)  X   X  if  X  contains two unit-clauses { x } and { X  x } , (3) otherwise,  X   X  = ( X  | x )  X  where x is the literal appearing in a unit clause of  X .

A CNF formula can be considered as a transactions database, called CNF database, where the items correspond to literals and the transactions to clauses. Note that complementary literals correspond to two different items.
 Definition 3 (CNF to D ). Let  X  = V 1 6 i 6 n c i be a CNF formula. The set of items I = L  X  and the transactions database associated to  X  is defined as D c  X  = { ( tid i 6 n } For instance, the CNF formula ( x 1  X  X  x 2  X  X  x 3 )  X  ( x x )  X  x 1  X  ( x 3  X  X  x 4 ) corresponds to the following transactions database:
In this context, a frequent itemset corresponds to a fre-quent set of literals: the number of clauses containing these literals is greater or equal to the minimal support threshold. For instance, if we set the minimal threshold  X  to 2, we get { x 1 ,  X  x 2 } as a frequent itemset in the previous database. The set of maximal frequent itemsets is the smallest set of frequent set of literals where each frequent set of literals is included in at least one of its elements. For instance, the unique maximal frequent itemset in the previous example is { x 1 ,  X  x 2 } (  X  = 2). Furthermore, the set of closed frequent itemsets is the smallest set of frequent set of literals where each frequent itemset is included in at least one of its ele-ments having the same support . For instance, the set of the closed frequent itemsets is {{ x 1 ,  X  x 2 } , { x 1 }} .
In the definition of a transaction database, we did not require that the set of items in a transaction to be unique. Indeed, two different transactions can have the same set of items and different identifiers. A CNF formula may contain the same clause more than once, but in practice this does not provide any information about satisfiability. Thus, we can consider a CNF database as just a set of itemsets (sets of literals).
In this section, we describe our mining based approach, called Mining4SAT, for reducing the size of CNF formulae. The key idea consists in searching for frequent sets of liter-als (sub-clauses) and substituting them with new variables using Tseitin X  X  encoding [14].
Tseitin X  X  encoding consists in introducing fresh variables to represent sub-formulae in order to represent their truth values. For example, given a Boolean formula, containing the variables a and b , and v a fresh variable, one can add the definition v  X  a  X  b (called extension) to the formula while preserving satisfiability. Tseitin X  X  extension principle is at the basis of the linear transformation of general Boolean for-mulae into CNF. Two decades later, after Tseitin X  X  seminal paper, Plaisted and Greenbaum presented an improved CNF translation that essentially produces a subset of Tseitin X  X  representation [10]. They noticed that by keeping track of polarities of sub-formulae, one can remove large parts of Tseitin translation. In the sequel, we use Plaisted and Greenbaum improvement. More precisely, as the disjunction a  X  b is a sub-clause with positive polarity, it is sufficient to add the formula v  X  a  X  b i.e. a clause (  X  v  X  a  X  b ).
Let consider the following DNF formula (Disjunctive Nor-mal Form: a disjunction of conjunctions): A naive way of converting such a formula to a CNF for-mula consists in using the distributivity of disjunction over conjunction ( A  X  ( B  X  C )  X  ( A  X  B )  X  ( A  X  C )): Such a naive approach is clearly exponential in the worst case. In Tseitin X  X  transformation, fresh propositional vari-ables are introduced to prevent such combinatorial explo-sion, mainly caused by the distributivity of disjunction over conjunction and vice versa. With additional variables, the obtained CNF formula is linear in the size of the original formula. However the equivalence is only preserved w.r.t satisfiability: ( t 1  X  t 2  X  t 3 )  X  ( t 1  X  ( x 1  X  X  X  X   X  x l ))  X  ( t 2  X  ( y  X  ( t 3  X  ( z 1  X  X  X  X   X  z n ))
Let us now describe in more details, how itemset min-ing techniques can be combined with Tseitin X  X  principle to compress CNF formula.

To illustrate the main ideas behind our mining based com-pression approach, we consider the CNF formula  X : where n &gt; 2, k &gt; n +1 n  X  1 and  X  1 ,..., X  k are clauses. As we can observe, the sub-clause ( x 1  X  ...,  X  x n ) appears in each clause of  X . Using Tseitin X  X  encoding, we can rewrite  X  as follows: where y is a fresh propositional variable. Indeed, n  X  k literals are replaced with k + n + 1 literals leading to a gain in terms of number of literals of ( n  X  k )  X  ( n + k + 1). Now, if we consider the CNF database corresponding to  X , { x 1 ,...,x n } is a frequent itemset where the minimal sup-port threshold is greater or equal to k . It is easy to see that to reduce the number of literals n must be greater or equal to 2. Indeed, if n &lt; 2 then there is no reduction of the num-ber of literals, on the contrary, their number is increased. Regarding the value of k , one can also see that such a trans-formation is interesting only when k &gt; n +1 n  X  1 . Thus, there are three cases : if n = 2, then k &gt; 4, else if n = 3 then k &gt; 3, k &gt; 2 otherwise. Therefore, the number of literals is always reduced when k &gt; 4.

Obviously, a boolean interpretation is a model of the for-mula obtained after reduction if and only if it is a model of  X .

In the previous example, we illustrate how the problem of finding frequent itemsets can be used to reduce the size of a CNF formula. One can see that, in general, it is more interesting to consider a condensed representation of the fre-quent itemsets (closed and maximal) to reduce the number of literals. Indeed, by using a condensed representation, we consider all the frequent itemsets and the number of fresh propositional variables and new clauses (in our example, y and ( x 1  X  X  X  X  X  x n  X  X  y )) introduced is smaller than that of those introduced by using all the frequent itemsets. For instance, in the previous formula, it is not interesting to introduce a fresh propositional variable for each subset of { x 1 ,...,x n } .

Example 1. Let us consider a formula  X  containing the following 8 clauses:
Suppose that the minimal support threshold is less than 4, then the sub-clause ( x 4  X  x 5  X  x 6 ) is frequent. Using our approach, the formula  X  can be rewritten as:
In this simple example, the original formula contains 27 literals, while the new formula involves only 23 literals. Closed vs. Maximal.

In Section 2.2, we introduced two condensed representa-tions of the frequent itemsets: closed and maximal. The question is, which condensed representation is better? We know that the set of maximal frequent itemsets is included in that of the closed ones. Thus, a small number of fresh variables and new clauses are introduced using the maximal frequent itemsets. However, there are cases where the use of the closed frequent itemsets is more suitable. For example, let us consider the following formula: where k &gt; 2, m,m 0 &gt; 4 and n &gt; k . We assume that the frequent itemsets are only the subsets of { x 1 ,...,x Therefore, { x 1 ,...,x n } is the unique maximal itemset and the closed itemsets are { x 1 ,...,x n } and { x 1 ,...,x us start by using the closed frequent itemset { x 1 ,...,x the reduction of the number of literals: Now, by using { x 1 ,...,x k } , we get the following formula: In this example, it is more interesting to consider the closed frequent itemsets in our Mining4SAT approach.
 In fact, a (closed) frequent itemset I and one of its subsets I (which can be closed) are both interesting if S ( I 0 )  X  X  ( I ) &gt; | I 0 | X  1  X  1. Indeed, if we apply our transformation using I , then the support of I 0 in the resulting formula is equal to S ( I 0 )  X  X  ( I ) + 1, and we know that I 0 is interesting in the resulting formula if its support is greater to | I 0 | +1 Overlap.

Let  X  be a set of itemsets. Two itemsets I and I 0 of  X  overlap if I  X  I 0 6 =  X  . Moreover, I and I 0 are in the same overlap class if there exist k itemsets I 1 ,...,I k of  X  such that I = I 1 ,I k = I 0 and for all 1 6 i 6 k  X  1, I i and I overlap.

In our transformation, one can have some problems when two frequent itemsets overlap. For example, if { x 1 ,x 2 and { x 2 ,x 3 ,x 4 } are two frequent itemsets (3 is the minimal support threshold) such that S ( { x 1 ,x 2 ,x 3 } ) = 3, S ( { x x } ) = 3 and S ( { x 1 ,x 2 ,x 3 ,x 4 } ) = 2, then if we apply our transformation using { x 1 ,x 2 ,x 3 } , then the support of { x 2 ,x 3 ,x 4 } is equal to 2 (infrequent) in the resulting for-mula and vice versa. Thus, we can not use both of them in the transformation.

Le us note that the overlap notion can be seen as a general-ization of the subset one. Let I and I 0 be frequent itemsets such that they overlap. They are both interesting in our transformation if: 1. S ( I )  X  X  ( I  X  I 0 ) &gt; | I | +1 | I | X  1  X  1 or S ( I Mining4SAT algorithm.

We now describe our compression algorithm, called Min-ing4SAT, using the set of closed frequent itemsets. Let us note that the optimal transformation using the set of all the closed frequent itemsets can be obtained by an optimal transformation using separately the overlap classes of this set. Actually, since any two distinct overlap classes do not share any literal, the reduction applied to a given formula using the elements of an overlap class does not affect the supports of the elements of the other classes. Moreover, one can easily compute the set of all the overlap classes of the set of the closed frequent itemsets: let G = ( V,E ) be an undi-rected graph such that V is the set of the closed frequent itemsets and ( I 1 ,I 2 ) is an edge of G if and only if I overlap; C is an overlap class if and only if it corresponds to the set of vertices of a connected component of G which is not included in any other connected component of G . For this reason, we restrict here our attention to the reductions that can be obtained using a single overlap class. The whole size reduction process can be performed by iterating on all the overlap classes.

Let I be a closed frequent itemset, we denote by  X  ( I ) the value S ( I )  X  ( | I | X  1)  X  X  I | X  1 that corresponds to the number of literals reduced by applying our transformation with I on a CNF formula.

Algorithm 1 takes as input a CNF formula  X  and an overlap class C , and returns  X  after applying size-reduction transformations. It iterates until there is no element in C . In each iteration, it first selects one of the most interesting elements in C (line 2): an element I of C such that there is ement is not necessarily unique in C . This instruction means that Algorithm 1 is a greedy algorithm because it makes a locally optimal choice at each iteration. Then, it applies Algorithm 1 Size Reduction Require: A formula  X  , an overlap class of closed frequent 1: while C 6 =  X  do 2: I  X  MostInterstingElment ( C ); 3: replace (  X ,I,x ); 4: Add (  X ,I,x ): 5: remove ( C,I ); 6: replaceSubset ( C,I,x ); 7: removeUninterestingElements ( C ); 8: updateSupports ( C ); 9: end while 10: return  X  our transformation using I = { y 1 ,...,y n } : it replaces the occurrences of I with a fresh propositional variable x (line 3); and it adds the clause y 1  X  ...  X  y n  X  X  x to  X  (line 4). It next removes I from C (line 5) and replaces I in the the other elements of C with x (line 6). The next instruction (line 7) consists in removing the elements of C that could increase the number of literals: the elements that overlap with I and are not included in I . As explained before, an el-ement of C overlapping with I does not necessarily increase the number of literals. Thus, by removing elements from C because only they overlap with I , our algorithm can remove closed frequent itemsets decreasing the number of literals. A partial solution to this problem consists in recomputing the closed frequent itemsets in the formula returned by Al-gorithm 1. The last instruction in the while loop (line 8) consists in updating the supports of the elements remaining in C following the new value of  X  : a support of an element I remaining in C changes only when it is included in I and its new support is equal to S ( I 0 )  X  X  ( I ) + 1. This instruction also removes all the elements of C becoming uninteresting because of the new supports and sizes.
Binary clauses (2-CNF formula) are ubiquitous in CNF formula encoding real-world problems. Some of them con-tain more than 90% of binary clauses. One of the main reason is that the encoding of several kinds of constraints to CNF leads to big sets of binary clauses. As an exam-ple, expressing that the variables x 1 ,...,x n must take dif-ferent values in { v 1 ,...,v m } can leads to n 2  X  m clauses (cliques of binary clauses) with a naive encoding. For n = 100 and m = 10, we get about one million of binary clauses or 10 Megabytes if each binary clause takes 10 bytes. Another example given by Rintanen in [12], concerns the en-coding of planning problem to SAT and particularly of some invariants such as the one expressing that an object cannot be in two locations at the same time. For n state variables there are n  X  ( n  X  1) 2 invariants that are binary clauses. In the case of a planning problem with n = 5000 state variables and a formula that encodes the search for plans of 100 time points, if only one of the state variables is true at any given time, the total size of the set of binary clauses is about 12 Gigabytes.

Table 2 illustrates the proportion of binary clauses on a sample of SAT instances (application category) taken from the last SAT competitions [17]. For each instance (first col-umn), we give the total number of clauses (#cls), the num-ber of binary clauses (#bin) and the ratio of binary clauses ((%)bin). Table 2: Ratio of binary clauses in some SAT in-stances
In our Mining4SAT general approach presented previously, binary clauses are not taken into account. Indeed, to reduce the size of a formula, we only search for itemsets of size at least two. The case where a binary clause representing a closed frequent itemset can be considered by our Min-ing4SAT algorithm is when it appears at least four times in a formula  X . For example, when  X  contains the following clauses c 1 = ( a  X  b ), c 2 = ( a  X  b  X   X  1 ), c 3 = ( a  X  b  X   X  c = ( a  X  b  X   X  3 ), where  X  i for 1 6 i 6 3 are clauses. In this case, the last three clauses are subsumed by the first binary clause. The clauses c 2 , c 3 and c 4 are redundant and can be eliminated from  X . Consequently, if we suppose that a for-mula is closed under subsumption, this case do not happen. Let us give a more general formulation of this particular case. Let  X  be the following formula: where  X  1 ,..., X  k are clauses. As we can see, the first clause subsumes all the remaining clauses. Then we obtain the formula closed under subsumption  X  s = ( x 1  X   X  X  X   X  x Suppose that I = { x 1 ,  X  X  X  ,x n } is a frequent closed itemset of D c  X  . Using I , we obtain the following formula  X  0 Applying unit propagation, we obtain  X  0 X  = ( x 1  X  X  X  X  X  x As we can remark  X  s =  X  0 X  . To summarize, our general Mining4SAT can derive unit literals ( y ). Then by applying unit propagation closure, some redundant clauses are elimi-nated automatically.
In this section, we first show how our mining based ap-proach can be used to achieve a compact representation of arbitrary set of binary clauses. Then, we consider two inter-esting special cases corresponding to sets of binary clauses representing either a clique or a bi-clique. It is important to note that, in [12], the authors investigated only these par-ticular cases.
In order to make strong reductions in terms of literals but also in terms of clauses, we propose a four step approach for the compression of a set of binary clauses. In the first step, we rewrite the set of binary clauses using another more suitable representation. Secondly, from this intermediary representation, we derive a new transactions database. Then we search for frequent closed itemsets. Finally, we apply the compression algorithm obtained by a slight modification to the compression Algorithm 1 on the set of binary clauses .
Let us first introduce a more convenient and equivalent representation of a set binary of clauses.
 Definition 4 (B-implication). A B-implication is a Boolean formula of the following from : x  X   X  ( x ) where  X  ( x ) is a conjunction of literals.

Let S be the following set of binary clauses: { ( x  X  y 1 y ) } , with k &gt; 1. Note that the B-implication B ( S ) = x  X  ( y 1  X  X  X  X   X  y k ) is equivalent to the conjunction of the elements of S . Hence, each 2-CNF formula  X  can be trans-formed into a set of B-implications, noted B [  X  (  X  )] ( X ). The original formula  X  can be obtained from B [  X  (  X  )] ( X ) by dis-tributing  X  over  X  . However, there exist several ways for rewriting a 2-CNF as a conjunction of B-implications. A naive way is to simply fix a complete order relation over L
We define a complete order relation over L  X  . Let f be a bijective mapping from L  X  to { 1 ... |L  X  |} . A literal x is smaller than a literal y , noted x y , iff f ( x ) 6 f ( y ). In this way, each literal of  X  is mapped to a unique natural number. is a complete order. Now, using this order, we get a unique way to rewrite a 2-CNF formula as a set of B-implications. Let  X  be a 2-CNF formula and ( x  X  y )  X   X , we conjunctively add y (respectively x ) to  X  ( x ) (respectively  X  ( y )), if x  X  y (respectively y  X  x ).

Algorithm 2 aims to compute the set of B-implications associated to a 2-CNF formula  X . It takes a 2-CNF formula  X  and a complete order over L ( X ) as inputs, and pro-vides a set of B-implications B [  X  (  X  )] ( X ) as output. In line 1, we initialize C ( x ) to the empty set for all the literals of  X . Following our order relation, in lines 2  X  9, we build the set  X  ( x ) for each literal x  X  X   X  . Indeed, for each binary clause ( x  X  y )  X   X , y is added to C ( x ) (respectively x is added to C ( y )) if x  X  y (respectively y  X  x ).

In lines 10  X  14, if according to the chosen ordering, we have x  X  y and  X  ( x ) contains only one literal, then we try to enhance the compression of the set of B-implications B [  X  (  X  )] ( X ). In this case, we add x to the set C ( y ), only if it contains at least one literal, and we set C ( x ) to the emp-tyset. In line 16, we return only the B-implications of the form [ x  X   X  ( x )] only when C ( x ) is not empty.

Assuming that adding an element to a set can be per-formed in constant time, the worst case complexity of the Algorithm 2 is in O ( |  X  | + |L ( X ) | ).

Now, we explain how a transactions database is associated to a 2-CNF formula, using a set of B-implications which we consider as an intermediate representation.

Definition 5 (2-CNF to D ). Let  X  be a 2-CNF for-mula. The transactions database associated to  X  is defined Mining4Binary algorithm.
 Let us describe our approach to compact a 2-CNF formula  X , called Mining4Binary (for reducing the size of a set of Algorithm 2 B-implications Require: A formula  X , a complete order over L ( X ) 1: C ( x ) =  X  ,  X  x  X  X  ( X ) 2: for c = ( x  X  y )  X   X  do 3: if x  X  y then 4: C ( x )  X  X  ( x )  X  X  y } 5: else 6: C ( y )  X  X  ( y )  X  X  x } 7: end if 8: end for 9: for x  X  X  ( X ) do 10: if C ( x ) = { y } and |C ( y ) | &gt; 1 then 11: C ( y )  X  X  ( y )  X  X  x } 12: C ( x )  X  X  X  13: end if 14: end for 15: return { [ x  X  ( V y  X  X  ( x ) y )] | x  X  X  ( X ) | C ( x ) 6 =  X  X  binary clauses). First, after rewriting  X  as B [  X  (  X  )] build the transactions database D b  X  . Then the set of closed frequent itemsets and its associated overlap classes C are computed. The last step aims to reduce the size of the 2-CNF  X  using a slightly modified version of the Algorithm 1. We only need to add two modifications. First, our 2-CNF compression algorithm takes as input B [  X  (  X  )] ( X ) and returns a compressed set of B-implications. Secondly, for an itemset I = { y 1 ,...,y n } , in line 4 of the Algorithm 1, we introduce a fresh variable x and we add a B-implication [  X  x  X  ( y  X  X  X  X  y n )] to B [  X  (  X  )] ( X ). This modified algorithm returns a set of compressed B-implications. The last step is a trivial translation of the obtained B-implications to 2-CNF.
Obviously, the compression rate depends on the chosen or-dering. Indeed, the intermediate representation (B-implications) is build according to a total order, and the transactions database depends on this intermediary representation. Example 2. Let us consider the following 2-CNF  X  : Using the complete order relation x 1  X  ...  X  x 7 over L  X  , we can rewrite  X  as the following set of B-implications B The transactions database representation D b  X  is built from B [  X  (  X  )] ( X ) by considering only  X  ( x 1 ) ,..., X  ( x 6
The itemset mining process is done on the conjunctive part of B 1  X  [  X  ] ( X ) represented in the transactions database. Setting the minimum support threshold to 4, we get as a frequent itemset { x 5 ,x 6 ,x 7 } . Using 2-CNF compression algorithm described above, we can rewrite B 1 [  X  (  X  )] ( X ) as B 2
Finally a simple encoding of B 2 [  X  (  X  )] ( X ) as CNF formula leads to following compressed 2-CNF formula:
The substitution of the itemset { x 5 ,x 6 ,x 7 } allows us to reduce the size of the 2-CNF formula  X  . Indeed, the resulting 2-CNF contains 5 binary clauses less.
In [12], J. Rintanen addressed the problem of represent-ing big sets of binary clauses compactly. He particularly shows that constraint graphs arising from practically inter-esting applications (eg. AI planning) contain big cliques or bi-cliques of binary clauses. An identified bi-clique in-volving the two sets of literals X = { x 1 ,x 2 ,...,x Y = { y 1 ,y 2 ,...,y m } expresses the propositional formula  X  = ( x 1  X  x 2  X   X  X  X   X  x n )  X  ( y 1  X  y 2  X   X  X  X   X  y m clique involving the literals X = { x 1 ,x 2 ,...,x n } expresses that at-most one literal from X is false .
 Let us explain how a bi-clique can be compacted with Mining4Binary method. Let  X  = [( x 1  X  y 1 )  X  ( x 1  X  y ( x 1  X  y m )] ... [( x n  X  y 1 )  X  ( x n  X  y 2 )  X  X  X  X  X  ( x n clique of n  X  m binary clauses (see Figure 1). Considering the complete order relation defined by: f ( x i ) = i,f ( y j Using this order relation B [  X  (  X  )] ( X ) corresponds exactly to { ( x i  X  [ y 1  X  y 2  X   X  X  X   X  y m ]) | 1 6 i 6 n } . Obviously, the transactions database D b  X  contains a single closed frequent itemset { y 1 ,y 2 ,...,y m } . Applying our algorithm leads to the following compact representation of  X  0 = [ V 1 6 i 6 n in [12] ( O ( n + m ) binary clauses and one additional variable). of n 2 binary clauses (see Figure 2). The set B [  X  (  X  )] defined by: f ( x i ) = i . If we take a closer look to D the closed frequent itemset I with the greatest value  X  ( I ) corresponds to { x n/ 2 ,...,x n } . In the first n 2 rows of D is substituted by a fresh variable x and a new set of binary clauses [ x  X  ( x n subproblems of size n 2 + 1. Obviously, the same treatment is done on the set B [  X  (  X  )] ( X ). Consequently, the number of variables is defined by the following recurrence equation: Figure 1: Bi-clique representation of the n  X  m clauses
The basic case is reached for n = 6, where the last fresh variable is introduced to represent the conjunction x 4  X  x x . For n &lt; 6 no fresh variable is introduced because no frequent closed itemset can lead to a reduction of the size of the formula. Consequently, from the solution of the previous recurrence equation, we obtain that our encoding is in O ( n ) auxiliary variables. Using the same reasoning, we also obtain the same complexity O ( n ) for the number of binary clauses. This corresponds to the complexity obtained in [12].
The two special cases of cliques and bi-cliques of binary clauses considered in this section, allow us to show that when a constraint is not well encoded, our approach can be used to correct and to derive a more efficient and compact encodings automatically.
In this section, we present an experimental evaluation of our proposed approaches. Two kind of experiments have been conducted. The first one deals with size reduction of arbitrary CNF formulas using Mining4SAT algorithm, while the second one attempts to reduce the size of the 2-CNF sub-formulas only, using Mining4Binary algorithm.

Both algorithms are tested on different benchmarks taken from the last SAT challenge 2012. From the 600 instances Table 3: Results of Mining4SAT : a general ap-proach of the application category submitted to this challenge, we selected 100 instances while taking at least one instance from each family. All tests were made on a Xeon 3.2GHz (2 GB RAM) cluster and the timeout was set to 4 hours.

In Table 3 and Table 4, we indicate the size in Kilobytes ( Kb ) or Megabytes ( Mb ) of each SAT instance before ( orig. ) and after reduction ( comp. ). We also provide % red , the reduction percentage.

Table 3 highlights the results obtained by Mining4SAT general approach. In this experiments, and to allow possible reductions, we only search for frequent closed itemsets of size greater or equal to 4. Consequently, binary clauses are not considered. As we can observe, our Mining4SAT reduction approach allows us to reduce the size more than 20% on the majority of instances. Let us also note that the maximum (67.14 %) is reached in the case of the instance abb313GPIA-9-c.*.sat04-317 : its original size is 21 Mb and its size after reduction is 6.9 Mb .
 In Table 4, we present a sample of the results obtained by Mining4Binary algorithm on compacting only binary clauses. We observe similar behavior as in the first experiment in terms of size reduction.

To study the influence of our size reduction approaches on the solving time, we also run the SAT solver MiniSAT 2.2 on both the original instance and on those obtained after reduction. As a summary, our approach achieve significant reductions in the size of instances without loosing solving effectiveness.

In our experiments, we have presented the two compres-sion algorithms, Mining4SAT (for clauses of arbitrary size) and Mining4Binary (for 2-CNF formulae). As the two algo-rithms can be applied independently, we have not presented the results using a two steps compression algorithm: appli-cation of the general Mining4SAT algorithm in the first step on the original formula, followed by the specialized Min-ing4Binary algorithm on the compressed formula derived in the first step. The results can be derived by cumulating the reductions obtained in both steps. For example, if we take the SAT instance 1dlx_c_iq57_a presented in both Table 3 and Table 4, the reduction by the two steps algorithm is Table 4: Results of Mining4Binary: a 2-CNF ap-proach computed as follows : (190  X  164) + (190  X  124) = 92 Mb . The reduction ratio is equal to 48 . 42%.
We thank the reviewers for their helpful comments. This work has been supported in part by the French ANR project  X  X AG: Declarative Approaches for Enumerating Interesting Patterns X  under the D  X efis program 2009.
In this paper, we propose the first data-mining approach, called Mining4SAT, for reducing the size of Boolean formu-lae in conjunctive normal form (CNF). It can be seen as a preprocessing step that aims to discover hidden structural knowledge that are used to decrease the number of literals and clauses. Mining4SAT combines both frequent itemset mining techniques for discovering interesting substructures, and Tseitin-based approach for a compact representation of CNF formulae using these substructures. Thus, we show in this work, inter alia, that frequent itemset mining techniques are very suitable for discovering interesting patterns in CNF formulae.

Since we use a greedy algorithm in our approach, the for-mula obtained after transformation is not guaranteed to be optimal w.r.t. size. An important open question, which we will study in future works, is how to optimally use the closed frequent itemsets ranging in an overlap class. For the special case of sets of binary clauses, finding a better com-plete ordering leading to an optimal compression is clearly an important challenge.

Finally, our framework can be extended to constraint sat-isfaction problems (CSP), Pseudo Boolean etc. [1] R. Agrawal, T. Imielinski, and A. N. Swami. Mining [2] E. Coquery, S. Jabbour, L. Sa  X   X s, and Y. Salhi. A [3] H. E. Dixon, M. L. Ginsberg, D. K. Hofer, E. M. [4] N. E  X en and N. S  X  orensson. An extensible sat-solver. In [5] M. L. Ginsberg and A. J. Parkes. Search, subsearch [6]  X  E. Gr  X egoire, R. Ostrowski, B. Mazure, and L. Sa  X   X s. [7] D. Gunopulos, R. Khardon, H. Mannila, S. Saluja, [8] T. Guns, S. Nijssen, and L. D. Raedt. Itemset mining: [9] M. W. Moskewicz, C. F. Madigan, Y. Zhao, L. Zhang, [10] D. A. Plaisted and S. Greenbaum. A [11] L. D. Raedt, T. Guns, and S. Nijssen. Constraint [12] J. Rintanen. Compact representation of sets of binary [13] A. Tiwari, R. Gupta, and D. Agrawal. A survey on [14] G. Tseitin. On the complexity of derivations in the [15] T. Uno, M. Kiyomi, and H. Arimura. Lcm ver. 2: [16] G. Yang. The complexity of mining maximal frequent [17] International sat competition.
