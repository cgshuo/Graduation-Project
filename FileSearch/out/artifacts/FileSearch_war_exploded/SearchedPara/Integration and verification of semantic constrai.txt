 1. Introduction
Due to steadily changing conditions at the global market, companies are forced to frequently adapt their agement technology in practice. Generally, process changes can take place at two levels  X  instance level (e.g., adapting a particular process instance to the needs of a customer) and process template level (e.g., adapting the process template due to legal changes) [5,6] . Thus, it is crucial for an adaptive process management system (PMS) to support both kinds of changes. However, it is still not sufficient to support process template and instance changes in an isolated manner. An adaptive PMS must also allow for the interplay between process template and instance changes [7] . A framework for the support of process template and instance changes as well as for their interplay (i.e., the support of change propagation to already individually modified instances) has been developed [3,8] . Within this framework the syntactical correctness of the process is always preserved after arbitrary process changes. For example, it is automatically checked by the PMS whether process changes will lead to structural errors, such as deadlock-causing cycles, not properly supplied input parameters, or to inconsistent instance states.

Ensuring syntactical correctness, however, is often not sufficient. In particular, for processes undergoing frequent changes performed by various staff members, mechanisms to ensure the semantic correctness of the processes become necessary. For this purpose, mechanisms to integrate semantic domain knowledge into adaptive PMS are required. In this paper, we introduce a framework for supporting semantic knowledge inte-gration and semantic process verification in the context of changes at process instance and at process template level as well as for their interplay. 1.1. Problem description and challenges
In many application domains, it is not possible to foresee and thus model all possible exceptions and nec-essary deviations at buildtime. Thus, frequent ad hoc modifications on process instances, for instance adding a special treatment for a particular patient, are the normal case in these domains. It is, therefore, an important requirement to support ad hoc changes in an user-friendly way such that even non-expert users (e.g., a nurse at a hospital workstation) are able to perform ad hoc process instance deviations if necessary. However, perform-ing ad hoc modifications of process instances can also be a source of semantic errors. Consider, for example, a suddenly arising headache, drug Aspirin is administered to patient Smith. This is achieved by inserting task Administer Aspirin into instance I in an ad hoc manner by, for example, a nurse at her workstation.
However, in this treatment process, the drug Marcumar, which is not compatible to Aspirin, is already admin-istered some tasks ahead ( semantic conflict ). Even if the process change is syntactically correct, it is not semantically.

In particular, if a process instance is often modified in an ad hoc manner (e.g., Administer Marcumar was previously inserted as an ad hoc modification) or if changes at process template level and at process instance level are merged (i.e., when propagating process template changes to individually modified process instances), it is likely that such semantic conflicts occur and that they remain undetected even by process experts. This leads to a contradictory situation: On the one hand, a lot of time and effort is spent on modeling structurally and semantically correct process templates at buildtime. On the other hand, however, due to per-forming semantically conflicting process changes, semantic errors creep in at runtime possibly affecting the success of the process.

If the PMS was aware of the incompatibility of the two tasks in the above mentioned example (cf. Fig. 1 ), it ument the reason for overriding the semantic constraint. Generally, documentation and traceability of violations of guidelines and best practices are highly relevant for many application domains (e.g., the medical or the automotive domain) since it becomes possible to trace back semantic conflicts which might cause, e.g., failures in the production.

In order to ensure the semantic correctness of processes  X  even across various changes  X  adequate mecha-nisms are required. Domain knowledge  X  e.g., knowledge about incompatible tasks  X  needs to be integrated within the process change framework in order to enable adaptive PMS to be semantic-aware . In this context, many challenging questions arise:  X  How to formalize and integrate domain knowledge (e.g., business rules [9] , medical guidelines [10,11] , etc.) within an adaptive PMS?  X  How to define a notion of semantic correctness for process templates and process instances and support its efficient verification?  X  How to determine whether changes on process templates, process instances, and the propagation of tem-plate changes to running process instances are semantically correct?  X  How to integrate semantic verification into the interaction scenarios of an adaptive PMS?
Integrating domain knowledge within adaptive PMS and ensuring semantic correctness of running pro-cesses at any time will mark a milestone in the practical application of such systems. 1.2. Contribution
In this paper, we present a framework for integrating domain knowledge into adaptive PMS and for per-forming semantic process verification in an efficient way. First of all, we provide a formalization for semantic constraints imposed on business processes. In particular, we introduce two fundamental kinds of semantic constraints (mutual exclusion constraints and dependency constraints) which serve as a basis for the following considerations. Both kinds of constraints have been identified as highly relevant for different application domains (i.e., the medical or the insurance domain). However, this basic set of semantic constraints can be easily extended as we will show in future work. Based on the notion of semantic constraints, a general criterion for the semantic correctness of business processes (independent from the underlying process meta model) is provided. Most of these results have been presented in [12] . In this paper, we refine the semantic correctness thermore, we extend our fundamental work by showing how semantic correctness of processes can be verified, ranging from verifying semantic correctness for process templates at buildtime to verifying semantic correct-ness of process changes. For this, we exploit the semantics of the applied change operations, for example when applying single change operations (e.g., ad hoc changes of process instances), or when applying concurrent changes (e.g., propagating process template changes to biased process instances). Afterwards, we discuss dif-on exploiting certain process meta model properties is discussed in more detail. Finally, we show how the semantic constraints can be organized within a domain repository.

In Section 2 , we present considerations on integrating semantics in adaptive PMS and motivate our approach. In Section 3 , a framework for the definition of semantic constraints and the notion of semantic cor-rectness are introduced. In Section 4 , we show how the semantic correctness of process templates and the semantic correctness of process changes can be verified. The migration of running instances to a new template a block-structured process model is used. In Section 7 , considerations on the integration of semantic verifica-tion in adaptive PMS as well as a framework for organizing semantic constraints are presented. Related work is discussed in Section 8 . Finally, Section 9 concludes with a summary and an outlook on future research. 2. On integrating semantics in adaptive PMS
As motivated in Section 1 , it is desirable to integrate (semantic) domain knowledge into the PMS in order to enable semantic-aware process management technology. Basically, it is possible to integrate even very complex domain knowledge into adaptive PMS. By connecting the PMS with a knowledge-based system or an expert system (e.g. [13] ), for instance, domain knowledge maintained in the external system can be used to avoid semantic conflicts. However, two aspects influence the possibilities of integrating domain knowledge into adaptive PMS. First, it is an important question how and by whom the knowledge base is maintained. The more domain knowledge, and in particular the more complex the knowledge, the greater is the effort to keep the knowledge base up-to-date. Thus, there is a risk that the knowledge, according to which the semantic checks are performed, is outdated. In fact, this might be even more dangerous than not performing semantic checks at all. Users might rely on the semantic checks to ensure the semantic correctness of the process not knowing that the knowledge base is outdated. As a consequence, it seems reasonable to only integrate such domain knowledge which is really important and which will really be kept up-to-date. Second, the goal of inte-grating domain knowledge is to enable the PMS to also perform correctness checks at the semantic level. How-ever, the effort to perform these semantic checks must not lead to a bottleneck, especially when changes on process templates are propagated to a multitude of running and possibly ad hoc modified instances (for some application domains, e.g., large hospitals, several thousands of instances may be active at the same time).
The two aspects mentioned above should be kept in mind when thinking about how to integrate domain knowledge into adaptive PMS. Therefore, we introduce two fundamental kinds of semantic constraints which can be imposed on processes: mutual exclusion constraints and dependency constraints. The reason is that these kinds of constraints are very common in practice as we know from preliminary case studies (e.g., [14] ). Exclusion and dependency constraints refer to tasks and impose certain conditions on how these tasks can be used in the process. By enabling the PMS to be aware of these constraints, many semantic errors, for example the ones depicted in Fig. 1 , can be avoided. Furthermore, the introduced kinds of constraints are still manageable regarding the effort for maintenance and semantic verification. We take these two kinds of con-straints as a starting basis in order to find out, how semantic constraints and semantic verification can be incorporated into the mechanisms of an adaptive PMS. In future work, we want to extend our approach step by step in order to further investigate on the right balance between expressiveness of constraints, effort for maintenance, and analyzability. 3. Semantic correctness for business processes
In this paper, we introduce two fundamental kinds of semantic constraints: mutual exclusion constraints and dependency constraints. Mutual exclusion constraints express that two tasks are not compatible and should not be executed together (e.g., administering two incompatible drugs). Mutual exclusion constraints are symmetric. Dependency constraints express that a task is dependent of another task, i.e., these tasks have to occur together in the process. In Fig. 1 , for instance, task Perform Surgery is added to the process. How-ever, in the treatment process the task Prepare Blood Bottles needs to be performed before and Make
Appointment for Follow-Up Examination needs to be performed after Perform Surgery . These semantic dependencies of Perform Surgery cause a semantic conflict, when only Perform Surgery is inserted into the process.
At buildtime, a set of semantic constraints can be assigned to a process template which the template itself as well as the process instances running according to this template have to comply with. Basically, it is pos-sible to extend or restrict the set of inherited semantic constraints for certain process instances. However, an extended or restricted constraint set at instance level has to be considered when checking semantic correct-ness accordingly. In the remainder of this paper we assume that process instances inherit the set of semantic constraints from their referenced process template. Furthermore, we assume the uniqueness of tasks in a process (i.e., each task may occur only once in a business process). In future work, we will extend our con-siderations to deal with other kinds of processes as well. In the following definition the structure of a seman-tic constraint is determined.

Definition 1 ( Semantic constraint ). Let A be a set of tasks. position , userDefined ) whereas  X  type 2 { Exclusion , Dependency },  X  source ; target 2 A , source 5 target ,  X  position 2 { pre , post , notSpecified },  X  userDefined is a user-defined parameter.

The parameter type denotes whether the semantic constraint is a mutual exclusion constraint or a depen-dency constraint. The second parameter source denotes the source task the constraint refers to while target denotes the target task related to the source task. Parameter position specifies in which order the source and target task are to be related to each other within the process (e.g., the surgery depends on the prep-aration of blood bottles and the bottles have to be prepared before the surgery ( pre )). According to Def-inition 1 , there are six possible constraint types. The last parameter userDefined can be used for several purposes, e.g., for additionally describing the constraint or to indicate the importance of the constraint.
In the latter case we can express if a constraint is merely a recommendation or if its violation leads to severe problems in the sequel. By exploiting such information the PMS is able to create an appropriate feedback for the user in case of violations. As an example, the constraint mentioned above would look like this: ( Dependency, Perform surgery, Prepare blood bottles, pre, Blood bottles need to be prepared for the patient and stored in the surgery room before the surgery can take place )
Based on the notion of semantic constraints a general criterion for semantic correctness is defined in the following. Basically, semantic correctness needs information on how tasks can be used within in a process and in which ordering relations they occur. All this information is captured within so called execution traces .
Therefore, we take execution traces as a basis for our formal criterion for semantic correctness. In addition, defining the semantics of the constraints based on execution traces allows for a meta model independent understanding of constraints. In Definition 2 , we define the notion of execution traces and some useful func-tions over them.

Definition 2 ( Execution trace ). Let A be a set of tasks which can be used to specify a process template S .An execution trace r := h e 1 , ... , e k i over S contains events e traces over S is denoted as Q S .

A process instance I is defined as a tuple I :  X  X  S ; r  X  where S denotes the process template which captures the structure of I 3 and execution trace r captures the current execution state of I . Then Q possible execution traces over process instance I with Q I
Useful functions over execution traces are:  X  Function traceTasks ( r ) returns the set of all tasks constituting the execution trace r . Formally: traceTasks : Q  X  S j I 7 ! 2 A with traceTasks  X h e 1 ; ... ; e instance I . Formally: possibleTasks  X  X  S j I  X  :  X  traceSucc : A Q  X  S j I 7 ! 2 A with traceSucc  X  t ; h e 1 j &lt; i , where i , j =1, ... , k }. tracePred : A Q  X  S j I 7 ! 2 A with tracePred  X  t ; h e 1 j &gt; i , where i , j =1, ... , k }.

In Fig. 3 , the execution traces of example process templates and process instances are depicted. For process template S 1 , two execution traces can be generated. This is because, for all instances of S executed (due to the XOR-split) resulting in two different kinds of instances of S cution trace of I 1 (which is empty) the same execution traces as over S possible execution traces of instance I 2 differs from the set of possible execution traces over S rent execution trace of I 2 .In I 2 , task B has been executed whereas task C has been skipped. Hence, B neces-sarily occurs in all possible execution traces over I 2 whereas C does not occur in any of them.
Based on the of notion execution traces, we can define a trace-based satisfaction criterion for semantic con-straints which we first want to motivate by means of some examples. Consider again the process template S Fig. 3 . Constraint c1 is violated when C and E are executed together, which is the case with trace ACDEFH .
Constraint c2 is violated if C is executed but not G . This is the case with both the possible traces over S straint c3 is violated if H is executed without B being executed previously. Since B is situated in an XOR-branch, this situation occurs if B is skipped and C is executed instead (reflected by trace ACDEFH ). In order to avoid all possible semantic conflicts, the semantic correctness has to be ensured for all possible executions (reflected by all possible execution traces) of a process template or a process instance. We refer to a semantic constraint as being violated over a process if there are possible execution traces of the process violating the constraint (cf. Definition 3 ). According to the set of possible execution traces over S c2 ,and c3 are not satisfied over S 1 (i.e., violated). For process instance I instance I 2 , however, none of the semantic constraints are violated according to the only possible execution trace over I 2 . Since task C is skipped, c1 as well as c2 can never be violated. Also constraint c3 cannot be violated since B is already executed.

These examples show that constraints might be satisfied over a process instance, but not over the corre-sponding template. This is because, generally, the traces which can be generated over a process instance at a certain execution state form a subset of the traces, which can be generated over its process template. The examples also show that the satisfaction of a constraint over a process template is constant over time (in case no conflicting changes are made (cf. Section 4 )), whereas the satisfaction of a constraint over a process instance may vary due to its ongoing execution. All these aspects are accounted for in the following definition of a satisfaction criterion for semantic constraints.

Definition 3 (Satisfaction criterion for semantic constraints). Let A be a set of tasks which can be used to specify process template S and let I be a process instance derived from S . Let further Q possible execution traces over S ( I ) and let a 1 , a 2 2 A be two tasks, a c =( type , source , target , position , userDefined ) with source = a formally: satisfied ( c ,[ S j I ]) = True  X  iff one of the following conditions holds:  X  type 2 { Exclusion , Dependency } and a 1 6 2 possibleTasks ([ S j I ])  X  type = Exclusion , position = pre and " execution traces r 2 Q tracePred ( a 1 , r )  X  type = Exclusion , position = post and " execution traces r 2 Q traceSucc ( a 1 , r )  X  type = Exclusion , position = notSpecified and " execution traces r 2 Q
Succ ( a 1 , r )and a 2 6 2 tracePred ( a 1 , r )  X  type = Dependency , position = pre and " execution traces r 2 Q tracePred ( a 1 , r )  X  type = Dependency , position = post and " execution traces r 2 Q traceSucc ( a 1 , r )  X  type = Dependency , position = notSpecified and " execution traces r 2 Q tracePred ( a 1 , r )or a 2 2 traceSucc ( a 1 , r )) Otherwise, c is violated over P ( I ), formally: satisfied ( c ,[ S j I ]) = False .

Based on the satisfaction criterion for semantic constraints, a semantic correctness criterion for process templates and process instances can be defined.
 a process instance on S . Let further C S be the set of all semantic constraints imposed on S . Then, S ( I )is semantically correct M " c 2 C S : satisfied ( c ,[ S j I ]) = True .
 Definitions 1 X 4 build the formal basis for semantic process verification and semantic change verification.
How the verification is conducted (in particular, how to avoid the calculation of all possible execution traces over a process which has exponential complexity) is discussed in the following. 4. Semantic verification of process templates and process instance modifications
Verifying the semantic correctness of a process template (instance) based on Definition 4 might be expensive depending on the number of semantic constraints imposed on the process template (instance) on the one hand and the number of possible execution traces on the other hand. The verification effort, however, can be decreased by restricting the set of semantic constraints to be checked as well as by avoiding a complete calcu-considerations on how to minimize the amount of constraints to be verified for a process template. In Section 4.2 , we show how to identify potentially violated constraints when ad hoc process adaptations are carried out. 4.1. On optimizing semantic verification of process templates
Basically, if a process template S specified over task set A is built by applying process changes to an  X  X  X mpty X  X  template the PMS might perform a semantic check each time a change operation is applied and check however, also important for an adaptive PMS to support the verification of a completely modeled process template S . This is, for instance, necessary when S was modeled with a tool not supporting stepwise semantic verification and S is imported into and executed by the PMS. In this case, it is necessary to verify whether the of constraints to be verified for the template S and its constraint base C 4.2. On checking semantic correctness after process instance changes
In our framework, an ad hoc process change is considered semantically applicable to a process instance I ,if of an instance I after a change is to verify the complete set of constraints C applied change operations (e.g., which task has been inserted at which position). Thus, depending on which change operation is requested, only a subset of constraints imposed on instance I needs to be verified. Consider cable, we can exploit the fact that I 1 was semantically correct before the modification (i.e., all constraints do not affect the task to be inserted ( G ). Hence, they cannot be violated by the insertion of G .
Table 1 gives an overview of change operations, their effects, and the set of semantic constraints to be ver-ified in order to verify the semantic applicability of the respective change operation. In the following, the results presented in the table are explained in more detail.
When inserting a task a into process instance I , all semantic constraints over I having a as source parameter symmetric, also mutual exclusion constraints with a as target parameter might be violated by the insertion of a . In our example, this applies to constraint c5 .

All other constraints are sure to be satisfied. Dependency constraints not having a as source parameter can-before applying the insertion. Hence, all constraints imposed on the process not related to a are supposed to be satisfied over I . These constraints, therefore, can be excluded from satisfaction checks.
Based on information on the process instance, the set of potentially violated exclusion constraints can be skipped) with target parameter corresponding to the inserted task a can be violated. That is because all exclu-sion constraints, whose source parameter are not included in the process or will not come to execution, are out whether the insert operation is semantically applicable.

When deleting a task a from process I , all semantic constraints over I with a as source parameter are sat-potentially interesting for correctness checks. However, mutual exclusion constraints with a as target param-eter cannot be violated by the deletion of a . Only dependency constraints with a as target parameter and whose operation and, therefore, need to be verified.

Moving a task a from its original position within process I to a new position pos can be understood as being equivalent of deleting a and inserting a at pos afterwards. lated after applying deletion and insertion operations need to be verified.

Generally, these considerations can also be applied in order to verify changes at template level. Note that changes might be applicable to a process instance which are not semantically applicable to the corresponding template. Due to the current execution trace of the instance, semantic constraints might be satisfied over the instance after a process change while not beeing satisfied over the corresponding template after the same pro-cess change (cf. Section 3 ). 5. On checking semantic correctness for process template evolution
In addition to ad hoc changes at the instance level, adaptive PMS must also support modifications of pro-cess templates. This becomes necessary, for instance, when changes in laws and policies need to be adopted in the business process (process optimization). In those cases, it is not only necessary to be able to modify the process template but also to propagate template changes to instances already running according to the old template (cf. Fig. 5 ). As mentioned, for semantically verifying the template change, the considerations made in Section 4.2 can be applied. The question of whether and how running instances can be migrated to the new template version is more challenging.

In order to be migrated to the new template version, it is important that instances are not only syntactically but also semantically compliant to the new template. In current literature, the problem of testing syntactical compliance of instances has already been tackled. In [8,15] , a change framework for efficient syntactical instance migration is introduced. Using this framework it can be checked, for example, whether migrating an instance to the new template would cause structural (e.g., deadlocks-causing cycles or not correctly sup-plied input parameters) or state-related inconsistencies. This has been accomplished for arbitrary running pro-The problem of testing semantic compliance, to our best knowledge, is novel in the context of adaptive PMS.
In general, a process instance I is semantically compliant with a new process template version S plate changes are semantically applicable to I as an ad hoc change. However, trying to apply the template change to each running process instance is not feasible in practice since there might be thousands of instances to be checked. In this paper, we present more efficient mechanisms to find out, whether instances can be migrated to the new template without violating any semantic constraints. For this purpose, first of all, it is determined which instances can be migrated to the new template version in a syntactically correct manner.
Then, the semantic checks are only applied to the set of syntactically compliant instances. For a better under-standing, some background information on the syntactical instance migration framework is provided in the next section. 5.1. Background information: syntactical instance migration
In the framework presented in [8,15] , instances to be checked for syntactical compliance are classified according to the relation between their individual changes and the template changes (cf. Fig. 6 ). The reason plate changes and if so which instance adaptions become necessary) is based on the degree of overlap between ance is useful for checking semantic compliance as well. This would be very beneficial since the classification has to be accomplished in any case and could be used for semantic verification at no extra costs. As shown in Fig. 6 , instances can be divided into two main classes: unbiased instances and biased instances.
Unbiased instances are instances, which have not been individually modified so far (cf. Fig. 7 ). Biased instances have already been individually modified. Depending on the degree of overlap between instance and template changes, they can be further divided into subclasses: instances with disjoint bias and instances with overlapping bias .

Informally, instance and template changes are disjoint if they affect different areas of the underlying process have changes partly or fully overlapping with the changes of the template. There are three subclasses to this essary for finding adequate migration strategies afterwards).

In the following, let D I be the instance changes on a process instance I and D S be the template changes on process template S .
Instances with equivalent bias have the same modifications as the template (cf. instance I Instances with subsumption equivalent bias can be further divided into two classes: D I subsumes D S and
D S subsumes D I . For instance I 3 in Fig. 7 , for example, the instance changes comprise the template changes plus a delete operation. Thus, I 3 belongs to the class D I subsumes D S whereas instance I
D S subsumes D I . Instances with partially equivalent bias have changes in common with the new template ver-sion. However, there are also changes on the template which do not correspond to the instance changes and vice versa. In Fig. 7 , instance I 5 belongs to this class.

Based on the classification presented in Fig. 6 it can be checked whether the instances are syntactically com-pliant or syntactically non-compliant with a modified process templated. Checking for semantic compliance of instances which are not syntactically compliant with the new template does not make sense. Therefore, in this paper, we focus on efficiently checking the semantic compliance of syntactically compliant instances. As already mentioned, the classification depicted in Fig. 6 can be used as input for semantic migration tests at no extra costs. In Section 5.3 , we show how this classification can be employed in order to reduce semantic verification efforts. 5.2. The basic scenario: semantic migration of unbiased process instances
In case a template change D S is semantically correct on S , it will also be semantically correct when being execution states. Thus, changes semantically applicable on a process template are a subset of changes seman-semantically compliant to the new process template version and can be migrated without any further checks.
In Fig. 7 , for example, instance I 1 can be migrated to S 5.3. The advanced scenario: concurrent process changes
Contrary to unbiased instances, applying template changes to biased instances may lead to semantic con-flicts between process template and process instance changes ( concurrent changes ). Fig. 8 gives an example of how merging the changes by migrating instance I 6 to the new template version S the template level, task G and H are inserted resulting in the new template S ified at runtime by inserting task K . Propagating template changes to I
This is because, the insertion of H is not semantically applicable to I
Even though the resulting instance would be syntactically correct, I cally correct way.

In Section 5.3.1 , we show how the amount of instances to be verified can be further reduced in order to reduce the effort for verifying biased instances. Then, in Section 5.3.2 , we present considerations on how to minimize the amount of constraints to be checked depending on the semantics of the change operations made at template and instance level. 5.3.1. Identifying semantically critical instances
As mentioned before, it only makes sense to migrate biased instances, which are syntactically compliant with the new template version. Depending on the ad hoc changes applied to the instance so far, however, it is not necessary to check all syntactically compliant instances for semantic compliance. Based on the classifi-cation of the syntactically compliant instances as presented in Section 5.1 , we provide different semantic migration strategies in order to reduce semantic verification efforts.

Equivalent bias: Since template and instance changes are equivalent, instances of this class are syntactically migrating these instances to the new template. As a consequence, it is not necessary to carry out any semantic migration checks for these instances. Instead, they can be migrated without any semantic checks. Subsumption equivalent bias: This class is further divided into two subclasses:
D I subsumes D S : Instances of this class can be semantically migrated to a new template version S any further semantic checks. This is because all template changes are already included (i.e., anticipated) in the set of changes on the process instance. For instance I tionally to the changes made at template level. The changes I has in common with S semantic conflict in case of a migration (this is comparable to instances in the class equivalent changes).
Furthermore, I is supposed to be semantically correct due to semantic verification of the ad hoc changes on I . Hence, also the additional changes on I (e.g., the insertion of N into I migrated without any semantic checks (cf. Fig. 9 ).

D S subsumes D I : Since D S subsumes D I , migrating I to S which are not included in D I . For I 4 in Fig. 9 , this would mean to propagate the insertion of H to I all instance changes D I are already anticipated by D S , a propagation cannot lead to a semantic conflict between the change operations. After a migration, I is structurally identical to S quence, instances of this class can also be migrated without any semantic checks.

Disjoint bias D S \ D I =  X : Contrary to the instances considered so far, migrating instances of this class to a new template version S 0 may cause semantic conflicts. Since the instance changes and the template changes are tasks at template and at instance level). Consequently, it has to be checked whether instances of this class are 5.3.2 ). Partially equivalent bias D S \ D I 5  X : Similar to instances with disjoint changes, instances whose changes are partially equivalent to the template changes may be semantically incorrect if migrated to the new template version. This is because the changes made on S but not on I (i.e., D S n D I ) may be conflicting with changes made on I but not on S (i.e., D I n D S ) when being propagated to I .In Fig. 7 , this applies to straint c3 ) but D has already been deleted from I 5 . Thus, instances with partially equivalent bias have to be verified. However, it is not necessary to check whether D S is semantically applicable to I as a whole (as for instances with disjoint changes). Since changes which D S and D I have in common are semantically applicable on I, these changes are compatible to other ad hoc changes made on I . In our example, the insertion of G has already been applied to I 5 . Thus, this change operation cannot conflict with other changes on I quently, instances of this class are semantically compliant with S as an ad hoc change (e.g., deletion of D for instance I 5
Using the considerations presented above unnecessary semantic migration checks can be avoided. As summed up by Table 2 , only instances of the classes partially equivalent bias and disjoint bias have to be checked for semantic compliance. For instances of the class partially equivalent bias , the verification effort can be reduced by minimizing the set of changes to be checked.

In the next section, we show how to minimize the set of constraints to be verified for instances of both these classes.
 5.3.2. Identifying potentially violated constraints
In this section, we present how the checks for semantic compliance necessary for instances with disjoint or to I as an ad hoc change, respectively. For applying this compliance criterion, the considerations for ad hoc changes in order to identify potentially violated constraints presented in Section 4.2 can be employed.
Take, for example, instance I 5 from Fig. 10 . Instance I result, it is semantically compliant with S 2 , if the insertion of H is semantically applicable to I the considerations for identifying critical constraints for ad hoc changes from Section 4.2 , the constraints c2 , c3 , and c4 are identified as potentially violated. However, different from verifying the applicability of ad hoc changes, more semantic information is available when verifying the semantic compliance of instances with a new template version. It is known that the template change is semantically applicable to the template and the instance change is semantically applicable to the instance. This information can be exploited to further narrow down the set of constraints potentially violated by only considering constraints which might be vio-lated by the interplay , i.e. the merge, of both the template and instance changes.

In Table 3 , for each combination of change operations at instance and template level the corresponding constraint types which might be violated by the interplay of both the changes are listed. If, for example, task a is inserted into instance I while task b is inserted into template S resulting in S affecting both of the inserted tasks can be violated when the I is migrated to S In Fig. 10 , only constraints need to be verified which can be violated by the application of both the changes
Insert(I 5 ,H,pos) and Delete(I 5 ,D) . According to Table 3 , only a constraint of type (Depen-dency,H,D,2 ... ) can possibly be violated. Only constraint c3 corresponds to this type and, therefore, has to be verified. In our example, c3 would be violated by the change propagation. Hence, I tically migrated to S 2 .

In Section 5 , we narrowed down the set of instances to be semantically verified based on the degree of over-lap between instance and template changes. Furthermore, we showed how to minimize the set of constraints to be verified by exploiting the semantics of the change operations. In the next section we consider how to opti-mize the verification of these constraints.
 6. On optimizing verification strategies based on process meta model properties
The trace-based satisfaction criterion for semantic constraints introduced in Section 3 is generic and can be applied to any process meta model (e.g., Petri Nets [1] or BPEL4WS Nets [16] ). For verifying the criterion, reachability analysis can be applied (i.e., by calculating all possible execution traces and checking them for certain order relations between tasks according to the semantic constraints) which might be very costly. There-
In this paper, we present an approach which makes use of certain properties of the underlying process meta model, namely block-structuring (e.g., WSM Nets [3] ). However, we intend to also develop model-indepen-dent methods in future work. 6.1. Background information
This section summarizes background information on WSM Nets [17,15] as process description formalism in order to present an optimized verification method for semantic correctness.

A process template is represented by a WSM Net which defines the process tasks as well as the control and data flow between them. When using WSM Nets the control flow template can be represented by attributed, serial X  X arallel graphs. In order to synchronize tasks from parallel paths additional links can be used [18] .In this paper we abstract from cyclic structures within the process meta model in order to provide a fundament for an optimized semantic correctness verification. Further on, a WSM Net comprises a set of data elements task or a write access. The total set of data edges constitutes the data flow template.
 Definition 5 ( WSM Net ). A tuple S =( N , D , NT , CtrlEdges , SyncEdges , DataEdges , BC ) is called a WSM
Net, if the following holds:  X  N is a set of process tasks and D a set of process data elements  X  NT : N # { StartFlow, EndFlow, Task, AndSplit, AndJoin, XOrSplit, XOrJoin, StartLoop,
EndLoop } NT assigns to each node of the process template a respective node type.  X  CtrlEdges N  X  N is a precedence relation definining the valid order of tasks (notation: n n dst ) 2 CtrlEdges )  X  SyncEdges N  X  N is a precedence relation between tasks of parallel branches  X  DataEdges N  X  D  X  {read, write} is a set of read/write data links between tasks and data elements D . BC ( n ) is undefined for nodes n with NT ( n ) 5 XOrSplit .

Which constraints have to hold such that a process template S is well-structured is summarized in [18,8] the block-structuring property is important, i.e., for all tasks of node type AndSplit ( XOrSplit ) there is a unique task of node type AndJoin ( XOrJoin ) and blocks (sequences as well as parallel and alternatives branchings) can be nested but must not overlap. 6.2. On exploiting process meta model properties
For each type of semantic constraint, we derived structural and state-related conditions on WSM Nets which ensure the trace-based constraint satisfaction criterion presented in Section 3 . Using these meta model be verified in an optimized way. Due to space restrictions, however, we abstain from presenting all conditions in this paper. Instead, we show how meta model specific conditions can be derived for one example constraint type. First, we focus on process templates. Later, we extend our considerations to process instances. Consider the following semantic constraint over the treatment process from Section 1 : set of tasks constituting the template. Due to the absence of at least one of the two tasks, no execution of the template is possible which violates the constraint. The only way target and source task can both occur in a be executed exclusively which ensures the semantic correctness of all of the template X  X  possible executions. In
Fig. 11 , c 1 is not satisfied over process template S 1 , since there are possible execution traces over S both of the incompatible tasks are executed.

From this example we conclude the following conditions for the satisfaction of exclusion constraints of type c ex =( Exclusion , source , target , notSpecified , ... ) over block-structured process templates:
A semantic constraint c ex imposed on a process template S represented by a WSM Net ( N , D , NT , ... )is satisfied if and only if one of the following conditions holds.  X  source 6 2 N (i.e. source does not occur in S );  X  target 6 2 N (i.e. target does not occur in S );  X  MinBlock ( S , source , target )=( blockStart , blockEnd )with blockStart = denotes a function which returns the start and end task of the minimal block surrounding the given tasks [19] .

In [12] , we presented the structural satisfaction conditions for dependency constraints and proved that they ensure the trace-based satisfaction criterion.

In general, the structural satisfaction criterion for process templates can also be applied to process execution states) but not over the corresponding process template (cf. Section 3 ). Take for example instance I in Fig. 11 . Constraint c 1 is satisfied over I 1 but not over S . This is because for I has already been skipped. Thus, for all possible execution traces of I ister Marcumar will not occur together, independently from whether Administer Marcumar will be exe-cuted later on or not. Since exclusion constraints are symmetric, the same applies if Administer Marcumar is skipped. Thus, for process instances the structural satisfaction criterion has to be complemented by addi-tional state-related satisfaction criterion in order to account for these situations.
 with S capturing the structure of I is satisfied if and only if one of the following conditions holds:  X  c ex is satisfied over S (structural condition)  X  ExState ( source )= SKIPPED , where ExState denotes a function which returns the execution state marking for the corresponding node  X  ExState ( target )= SKIPPED
The structural/state-related satisfaction conditions on block-structured process meta models derived can be out whether the respective constraint is satisfied or not.
 7. Architectural considerations
In this section, we present our ideas on integrating semantic verification into the verification mechanisms of an adaptive PMS. In addition, we present our ideas on organizing semantic constraints in order to facilitate constraint reuse. 7.1. Architectural integration
As pointed out previously, semantic verification is coupled with structural verification. In Fig. 12 , an exam-ple interaction for verifying an ad hoc change is depicted. At first, an ad hoc change is initiated be the user.
Since ad hoc changes are often performed by end-users, the workflow client needs to provide adequate fea-tures. The change request is then processed to the process engine. Internally, a module is required to coordi-change is not syntactically applicable, the change can be denied immediately. In our example, the change does not cause any syntactical errors. Thus, semantic verification is triggered. Depending on the results, the coor-dinator can allow or deny the change and provide an appropriate feedback. 7.2. Organization of constraints
In our approach, a set of semantic constraints is assigned to a process. However, several processes may share constraints. In this section, we present a framework for organizing semantic constraints for their easy reuse.
The three main components of the framework are the domain repository , the process repository , and the task are assigned to domains (e.g., domain Minimally invasive cardiac surgery ). Thus, a domain contains a set of constraints that are typical of this domain. The constraints presented in this paper refer to tasks which are organized in a task repository. For future work, we also plan to introduce constraints that refer to other abstraction levels, for instance abstraction levels in the task repository. Process templates are organized in a process repository. Each process template is assigned a domain of the domain repository. Thus, it is possible to assign a default set of domain constraints to a process. However, processes that are assigned to the same domain might still have different semantic constraints that are not captured in the domain. Therefore, for each process template, the process designer can specify additional semantic constraints for the process or leave out some unnecessary domain constraints. Thus, it is possible to tailor an individual set of constraints for each process template. 8. Related work
The discussion ranges from approaches which we consider as being most related to ours to related work which can be seen as orthogonal to our approach.

Rule/Constraint-Based Process Specification: In [20 X 22] , approaches dealing with the specification of inter-task interdepencies are introduced. One of the main concerns in [21,22] is to provide a scheduler which sched-ules the tasks (and their events like commit or abort) according to the specified dependencies. A workflow is considered a set of dependencies between tasks which are specified using different formalisms, e.g., computa-tional tree logic (CTL) [21] . Although focussing on inter-workflow dependencies, the basic ideas of the approach presented in [23] are quite similar to the approaches mentioned before. One of the main differences is that the approach in [23] uses an extension of regular expressions for expressing legal executions of workflows.

For verifying the runtime execution, a state automaton based approach is employed. Due to their transac-tional background, [20 X 23] focus on scheduling upcoming event requests (e.g., the start of a task) according to predefined dependencies whereas in our approach, violations of dependencies shall be detected as early as pos-declaratively specify process models using a graphical notation which can be mapped to formulas in Linear
Temporal Logic (LTL) is presented. In order to enact the process model, the LTL formulas can be synthesized into automatons.

Other approaches on constraint-based process specifications have been introduced, for example using Con-current Transaction Logic (CRT) [25] or path constraints [26] . These approaches aim at providing a formalism which allows for defining local and global dependencies (constraints) between tasks and also for verification of tically verifying a process template). In [27 X 29] workflows are modeled based on rules or constraints. However, these approaches do not aim at verifying semantic constraints.

Adaptive/flexible PMS: Current approaches on adaptive PMS mainly focus on structural aspects (e.g., [3,4,8,30] ) or have a different notion of semantic correctness (e.g., [31,1] ).

Some approaches (e.g., [32,33] ) aim at enabling more flexible process executions. The basic idea is to allow the execution of a partly defined process template (core process). At runtime, once the flexible parts of the process (predefined as a pocket of flexibility which is comparable to an unspecified subprocess) is reached, a process expert can complete the specification of the subprocess. The subprocess is then verified based on con-approaches rather aim at allowing for more flexibility they are very inspiring for our work, especially the con-straints they introduced. However, the verification of the subprocess can be compared to verifying a process template. Verification of real ad hoc changes at runtime are not addressed.

In [34,35] , an approach for ensuring the integrity of process instances based on rule-based process adapta-tion is introduced. Rules are applied, when certain conditions (e.g., too high blood pressure) apply. Using the
ADEPT framework [18] the process is adapted in an ad hoc manner according to the rule triggered. This rity of process instances at runtime.

Integration of heterogenous sources: Many related approaches focus on integrating heterogenous resources are often described using ontologies. When a process is composed, the PMS can check, whether the tasks and their parameters semantically fit together. However, these approaches do not consider semantic con-straints over processes.

Knowledge-based systems: Besides, there are also approaches which we consider as being orthogonal to our work. Interesting in this context are knowledge-based systems [13] . In such systems, expert knowledge can be deposited. Recently, knowledge-based systems became more popular in the form of Business Rule Manage-ment Systems (BRMS), e.g., commercially available systems like ILOG JRules [41] . BRMS provide conve-nient interfaces for managing and deploying business rules (e.g.,  X  X  X f credit risk &gt;50%, then refuse loan X  X ). By employing techniques known from knowledge-based systems, the rules can be evaluated in the Business
Rule Engine (BRE) of the BRMS. In the context of PMS, a BRE is primarily used for decision making (e.g., which outgoing paths of a task to follow). This is done by predefining decision making points in the pro-cess and business objects (e.g., a customer X  X  credit risk) used for passing data from the PMS to the BRE and vice versa. At runtime, the BRE is then invoked and can operate over the predefined business objects [9,41] .
Approaches concerning the integration of organizational memory information systems (OMIS) into process management (e.g., [42,43] ) can also be considered orthogonal to our work. In particular, [42,43] deal with pro-viding background information (e.g., former experience with a particular customer) based on context infor-mation (e.g., the customer) in order to support users when executing knowledge-intense tasks.
A Posteriori Verification: In [44] an approach for verifying properties of past processes by verifying execu-tion logs is introduced. This approach can help detecting constraint violations. However, being an a posteriori verification approach this approach is orthogonal to our work. These two approaches can complement each other. 9. Summary and outlook
Our objective is to enable adaptive PMS to perform semantic verification. However, semantic verification must not be conducted in an isolated manner. In fact, semantic verification must be incorporated into typical adaptive PMS interaction scenarios such as ad hoc changes and template evolution. In this paper, we intro-duced a framework for the integration of domain knowledge within an adaptive PMS by using semantic con-straints. Based on these constraints, a generic criterion for semantic correctness of processes has been provided. We have shown how this criterion can be generally ensured. Furthermore, we have addressed the issue of verifying semantic correctness of process changes and verifying the semantic compliance of individu-ally modified process instances with a modified template. Exemplarily for block-structured process meta mod-els, we have shown how semantic process verification can be realized in an efficient manner. Finally, an architecture for the integration of semantic constraints within an adaptive PMS has been presented.
Using our approach, all semantic conflicts caused by violation of dependency and mutual exclusion con-straints can be avoided. However, the expressiveness of the presented constraints is limited. Therefore, in future work we will extend our framework, e.g. by introducing context restrictions on constraints concerning level (e.g., data). Furthermore, we want to develop further methods to efficiently verify semantic correctness within an adaptive PMS. For example, we want to analyze how the information referred to by semantic con-straints can be organized (e.g., within an ontology) in order to decrease evaluation effort. All considerations are to be implemented within the adaptive PMS ADEPT2 ( www.aristaflow.com ).

References
