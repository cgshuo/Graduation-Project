 Despite of its widespread success in regression problems, Gaussian process (GP) has two limita-tions. First, it cannot handle data with multi-modality. Multi-modality can exist in the input dimen-sion (e.g., non-stationarity), in the output dimension (given the same input, the output has multiple modes), or in a combination of both. Secondly, the cost of training is O ( N 3 ) , where N is the size of the training set, which can be too expensive for large data sets. Mixture of GP experts models were proposed to tackle the above problems (Rasmussen &amp; Ghahramani [1]; Meeds &amp; Osindero [2]). Monte Carlo Markov Chain (MCMC) sampling methods (e.g., Gibbs sampling) are the standard approaches to train these models, which theoretically can achieve very accurate results. However, MCMC methods can be slow to converge and their convergence can be difficult to diagnose. It is thus important to explore alternatives.
 In this paper, we propose a new generative mixture of Gaussian processes model for regression prob-lems and apply variational Bayesian methods to train it. Each Gaussian process expert is described by a linear model, which breaks the dependency among training outputs and makes variational inference feasible. The distribution of inputs for each expert is modeled by a Gaussian mixture model (GMM). Thus, our gating network can handle missing inputs and is more flexible than single Gaussian-based gating models [2-4]. The number of experts and the number of components for each GMM are automatically inferred. Training using variational methods is much faster than using MCMC. The rest of this paper is organized as follows. Section 2 surveys the related work. Section 3 describes the proposed algorithm. We present test results in Section 4 and summarize this paper in Section 5. Gaussian process is a powerful tool for regression problems (Rasmussen &amp; Williams [5]). It ele-gantly models the dependency among data with a Gaussian distribution: P ( Y ) = N ( Y | 0 , K +  X  2 n I ) , Figure 1: The graphical model representation for the proposed mixture of experts model. It consists to predict output y from input x ; the gating network is a GMM for input x . Data can be generated as follows. Step 1, determine hyperparameters  X  . Step 2, sample parameters  X  . Step 3, to sample one data point x and y , we sequentially sample expert indicator t , cluster indicator z , x and y . Step 3 is independently repeated until enough data points are generated. where Y = { y 1: N } are N training outputs and I is an identity matrix. We will use y 1: N to denote y , y 2 , ..., y N . The kernel matrix K considered here consists of kernel functions between pairs of estimated from the data. However, Gaussian process has difficulties in modeling large-scale data and multi-modal data. The first issue was addressed by various sparse Gaussian processes [6-9, 16]. The mixture of experts (MoE) framework offers a natural solution for multi-modality problems (Jacobs et al . [10]). Early MoE work used linear experts [3, 4, 11, 12] and some of them were neatly trained via variational methods [4, 11, 12]. However, these methods cannot model nonlinear data sets well. Tresp [13] proposed a mixture of GPs model that can be trained fast using the EM algorithm. However, hyperparameters including the number of experts needed to be specified and the training complexity issue was not addressed. By introducing the Dirichlet process mixture (DPM) prior, infinite mixture of GPs models are able to infer the number of experts, both hyperparameters and parameters via Gibbs sampling [1, 2]. However, these models are trained by MCMC methods, which demand expensive training and testing time (as collected samples are usually combined to give predictive distributions). How to select samples and how many samples to be used are still challenging problems. Fig.1 shows the graphical model of the proposed mixture of experts. It consists of the local expert part and gating network part, which are covered in Sections 3.1 and 3.2, respectively. In Section 3.3, we describe how to perform variational inference of this model. 3.1 Local Gaussian process expert A local Gaussian process expert is specified by the following linear model given the expert indicator t = l (where l = 1 : L ) and other related variables: This linear model is symbolized by the inner product of the weight vector v l and a nonlinear feature vector  X  l ( x ) .  X  l ( x ) is a vector of kernel functions between a test input x and a subset of training M training samples. How to select I l will be addressed in Section 3.3; for now let us assume that 0 mean and inverse covariance U l . U l is set to K l +  X  2 hl I , where K l is a M  X  M kernel matrix consisting of kernel functions between training samples in the active set.  X  2 hl is needed to avoid linear model. Note that  X  l ( x ) depends on  X  l .  X  l is the inverse variance of this linear model. The It is easy to see that for each expert, y is a Gaussian process defined on x . Such a linear model was proposed by Silverman [14] and was used by sparse Gaussian process models [6, 8]. If we set  X  hl = 0 and  X  l = the same expert l , can be proved to be N ( Y | 0 , K l +  X  2 nl I ) . This has exactly the same form of a regular Gaussian process. However, the largest advantage of this linear model is that it breaks Q Gaussian processes feasible. 3.2 Gating network A gating network determines which expert to use based on input x . We consider a generative gating network, where expert indicator t is generated by a categorical distribution P ( t = l ) = p l . p = [ p Given expert indicator t = l , we assume that x follows a Gaussian mixture model (GMM) with C components. Each component (cluster) is modeled by a Gaussian distribution P ( x | t = l, z = In previous generative gating networks [2-4], the expert indicator also acts as the cluster indicator (or t = z ) such that inputs for an expert can only have one Gaussian distribution. In comparison, our model is more flexible by modeling inputs x for each expert as a Gaussian mixture distribution. One can also put prior (e.g., inverse Gamma distribution) on  X  x and  X  y as done in [1, 2, 15]. In this paper we treat them as fixed hyperparameters. 3.3 Variational inference Variational EM algorithm Given a set of training data D = { ( x n , y n ) | n = 1 : N } , the task of learning is to estimate unknown hyperparameters and infer posterior distribution of parameters. This problem is nicely addressed by the variational EM algorithm. The objective is to maximize log P ( D |  X  ) over hyperparameters  X  . Parameters  X  , expert indicators T = { t 1: N } and cluster indicators Z = { z 1: N } are treated as hidden variables, denoted by  X  = {  X  , T , Z } . It is possible to estimate all hyperparameters via the EM algorithm. However, most of the hyperpa-rameters are generic and are thus fixed as follows. m 0 and R 0 are set to be the mean and inverse covariance of the training inputs, respectively. We fix degree of freedom r = d and the scale matrix S = 100 I for the Wishart distribution.  X  x ,  X  y , C and L are all set to 10. Following Bishop &amp; Svens  X  en [12], we set a = 0 . 01 and b = 0 . 0001 . Such settings give broad priors to the parameters and make our model sufficiently flexible. Our algorithm is not found to be sensitive to these generic hyperparameters. The only hyperparameters remain to be estimated are  X  = {  X  1: L , I 1: L } . Note that these GP-related hyperparameters are problem specific and should not be assumed known. In the E-step, based on the current estimates of  X  , posterior probability of hidden variables P (  X  | D ,  X  ) is computed. Variational inference is involved in this step by approximating P (  X  | D ,  X  ) with a factorized distribution Each hidden variable has the same type of posterior distribution as its conjugate prior. To compute the distribution for a hidden variable  X  i , we need to compute the posterior mean of log P ( D ,  X  |  X  ) over all hidden variables except  X  i :  X  log P ( D ,  X  |  X  )  X   X  / X  omitted.
 Variational inference for each hidden variable takes linear time with respect to N , C and L , because the factorized form of P ( D ,  X  |  X  ) leads to separation of hidden variables in log P ( D ,  X  |  X  ) . If we switch from our linear model to a regular Gaussian process, one will encounter a prohibitive L = 10 represents the maximum number of clusters and experts. The actual number is usually smaller. During iteration, if a cluster c for expert l does not have a single training sample supporting Similarly, we remove an expert l if no Q ( t n = l ) &gt; 0 . These C and L choices are flexible enough for all our tests, but for more complicated data, larger values may be needed.
 In the M-step, we search for  X  which maximizes  X  log P ( D ,  X  |  X  )  X   X  . We employ the conjugate gradient method to estimate  X  1: L similarly to [5]. Both E-step and M-step are repeated until the algorithm converges. For better efficiency, we do not select the active sets I 1: L in each M-step; instead, we fix I 1: L during the EM algorithm and only update I 1: L once when the EM algorithm converges. The details are given after we introduce the algorithm initialization.
 Initialization Without proper initialization, variational methods can be easily trapped into local optima. Consequently, using pure randomization methods, one cannot rely on a single result, but has to run the algorithm multiple times and then either pick the best result [12] or average the results [11]. We present a new initialization method that only needs the algorithm to run once. Our method is based on the assumption that the combined data including x and y for an expert are usually distributed locally in the combined d + 1 dimensional space. Therefore, clustering methods such as k -mean can be used to cluster data, one cluster for one expert.
 Experts are initialized incrementally as follows. First, all training data are used to train one expert. Secondly, we cluster all training data into two clusters and train one expert per cluster. We do this four times and collect a total of L = 1 + 2 + 3 + 4 = 10 experts. Different experts represent different local portions of training data in different scales. Although our assumption may not be true in some cases (e.g., one expert X  X  data intersect with others), this initialization method does give us a meaningful starting point. In practice, we find it effective and reliable.
 Active set selection We now address the problem of selecting active set I l of size M in defin-ing the feature vector  X  l for expert l . The posterior distribution Q ( v l ) can be proved to be e  X  set to the full training set ( M = N ). But for large data sets, we have to select a subset with M &lt; N . The active set I l is randomly initialized. With I l fixed, we run the variational EM algorithm and obtain Q (  X  ) and  X  . Now we want to improve our results by updating I l . Our method is inspired by the maximum a posteriori probability (MAP) used by sparse Gaussian processes [6, 8]. Specifically, other hidden variables fixed. The justification of this choice is that a good I l should be strongly supported by data D such that Q ( v l ) is highly peaked. Since Q ( v l ) is Gaussian, v l is always at the optimal point and thus this optimization is equivalent to maximizing the determinant of the inverse covariance Note that if T nl is one for all n , our method turns into a MAP-based sparse Gaussian process. derived in previous MAP-based work [6, 8]. First, the denominator P ( D ) is ignored by previous methods. For these reasons, previous methods are not real MAP estimation but its approximations. Looking for the global optimal active set with size M is not feasible. Thus, similarly to many sparse Gaussian processes, we consider a greedy algorithm by adding one index to I l each time. For a candidate index i , computing the new e U l requires O ( N M ) ; incremental updating Cholesky factorization of e U l requires O ( M 2 ) and computing the new | e U l | needs O (1) . Therefore, checking one candidate i takes O ( N M ) . We consider selecting the best index from  X  = 100 randomly selected candidates [6, 8], which makes the total time for adding one index O (  X N M ) . For adding all M indices, the total time is O (  X N M 2 ) . Such a complexity is comparable to that of [6], but higher than those of [7, 8]. Note that this time is needed for each of the L experts. In a summary, the variational EM algorithm with active set selection proceeds as follows. During initialization, training data are clustered and assigned to each expert by the k -mean clustering algo-rithm noted above; the data assigned to each expert is used for randomly selecting the active set and then training the linear model. During each iteration, we run variational EM to update parameters and hyperparameters; when the EM algorithm converges, we update the active set and Q ( v l ) for each expert. Such an iteration is repeated until convergence.
 each x is a pseudo-input (Snelson &amp; Ghahramani [9]). In this way, these pseudo-inputs X can be viewed as hyperparameters and can be optimized in the same variational EM algorithm without resorting to a separate update for active sets as we do. This is theoretically more sound. However, it leads to a large number of hyperparameters to be optimized. Although overfitting may not be an issue, the authors cautioned that this method can be vulnerable to local optima.
 Predictive distribution Once training is done, for a test input x  X  , its predictive distribution P ( y  X  | x  X  , D ,  X  ) is evaluated as following: The first approximation uses the results from the variational inference. Note that expert indicators T and cluster indicators Z are integrated out. Suppose that there are sufficient training data. Thus, the posterior distribution of all parameters are usually highly peaked. This leads to the second ap-proximation, where the integral reduces to point evaluation at the posterior mean of each parameter. Eq.(4) can be easily computed using standard predictive algorithm for mixture of linear experts. See appendix for more details. For all data sets, we normalize each dimension of data to zero mean and unit variance before using them for training. After training, to plot fitting results, we de-normalize data into their original scales.
 Artificial toy data We consider the toy data set used by [2], which consists of four continuous functions covering input ranges (0 , 15) , (35 , 60) , (45 , 80) and (80 , 100) , respectively. Different levels of noise (with standard deviations std = 7 , 7 , 4 and 2 ) are added to different functions. This is a challenging multi-modality problem in both input and output dimensions. Fig.2 (left) shows 400 points generated by this toy model, each point with a equal probability 0.25 to be assigned to one of the four functions. Using these 400 points as training data, our method found two experts that fit the data nicely. Fig.2 (left) shows the results.
 In general, expert one represents the last two functions while expert two represents the first two functions. One may desire to recover each function separately by an expert. However, note the fact that the first two functions have the same noise level (std = 7 ); so it is reasonable to use just one GP to model these two functions. In fact, we recovered a very close estimated std = 1 / p  X   X  2  X  = 6 . 87 for the second expert. The stds of the last two functions are also close (4 vs. 2), and are also similar first function comparably well to that of expert two. However, the gating network does not support this: the means of the GMM for expert one does not cover the region of the first function. Ref.[2] and our method performed similarly well in discovering different modalities in different input regions. We did not plot the mean of the predictive distribution as this data set has multiple modes in the output dimension. Our results were produced using an active set size M = 60 . Larger active sets did not give appreciably better results.
 Motorcycle data Our algorithm was also applied to the 2D motorcycle data set [14], which contains 133 data points with input-dependent noise as shown in Fig.2 (right). Our algorithm yielded two experts with the first expert modeling the majority of the points and the second expert only depicting the beginning part. The estimated stds of the two experts are 23 . 46 and 2 . 21 , respectively. This appears to correctly represent different levels of noise present in different parts of the data. Figure 2: Test results for toy data (left) and motorcycle data (right). Each data point is assigned to an expert l based on its posterior probability Q ( t n = l ) and is referred to as  X  X ata for expert l  X . The means of the GMM for each expert are also shown at the bottom as  X  X  for expert l  X . In the right figure, the mean of the predictive distribution is shown as a solid line and samples drawn from the predictive distribution are shown as dots (100 samples for each of the 45 horizontal locations). We also plot the mean of the predictive distribution (4) in Fig.2 (right). Our mean result compares favorably with other methods using medians of mixtures [1, 2]. In particular, our result is similar to that of [1] at input  X  30 . At input &gt; 35 , the result of [1] abruptly becomes flat while our result is smooth and appears to fit data better. The result of [2] is jagged, which may suggest using more Gibbs samples for smoother results. In terms of the full predictive (posterior) distribution (represented by samples in Fig.2 (right)), our results are better at input  X  40 as more artifacts are produced by [1, 2] (especially between 15 and 25). However, our results have more artifacts at input &gt; 40 because that region shares the same std = 23 . 46 as the other region where input is between 15 and 40. The active set size of our method is set to 40 . Training using matlab 7 on a Pentium 2.4 GHz machine took 20 seconds, compared to one hour spent by Gibbs sampling method [1].
 Robot arm data We consider the two-link robot arm data set used by [12]. Fig.3 (left) shows the kinematics of such a 2D robot. The joint angles are limited to the ranges 0 . 3  X   X  1  X  1 . 2 and  X / 2  X   X  2  X  3  X / 2 . Based on the forward kinematic equations (see [12]) the end point position ( x 1 , x 2 ) has a unique solution given values of joint angles (  X  1 ,  X  2 ) . However, we are interested in the inverse kinematics problem: given the end point position, we want to estimate the joint angles. We randomly generated 2000 points based on the forward kinematics, with the first 1000 points for training and the remaining 1000 points for testing. Although noise can be added, we did not do so to make our results comparable to those of [12].
 Since this problem involves predicting two correlated outputs at the same time, we used an inde-pendent set of local experts for each output but let these two outputs share the same gating network. This was easily adapted in our algorithm. Our algorithm found five experts vs. 16 experts used by [12]. The average number of GMM components is 3. We use residue plots [12] to present results (see Fig.3). Compared to that of [12], the first residue plot is much cleaner suggesting that our errors are much smaller. This is expected as we use more powerful GP experts vs. linear experts used by [12]. The second residue plot (not used in [12]) also gives clean result but is worse than the first plot. This is because the modality with the smaller posterior probability is more likely to be replaced by false positive modes. The active set size was set to 100 . A larger size did not improve the results. DELVE data We applied our algorithm to three widely used DELVE data sets: Boston, Kin-8nm and Pumadyn-32nm. These data sets appear to be single modal because impressive results were achieved by a single GP. The purpose of this test is to check how our algorithm (intended for multi-modality) handles single modality without knowing it. We followed the standard DELVE testing framework: for the Boston data, there are two tests each using 128 training examples; for both Kin-8nm and Pumadyn-32nm data, there are four tests, each using 1024 training examples. Table 1 shows the standardised squared errors for the test. The scores from all previous methods are copied from Waterhouse [11]. We used the full training set as the active set. Reducing the active Figure 3: Test results for robot arm data set. Left: illustration of the robot kinematics (adapted from [12]). Our task is to estimate the joint angles (  X  1 ,  X  2 ) based on the end point positions. In region B, there are two modalities for the same end point position. In regions A and C, there is only one modality. Middle: the first residue plot. For a test point, its predictive distribution is a Gaussian mixture. The mean of the Gaussian distribution with the highest probability was fed into the forward kinematics to obtain the estimated end point position. A line was drawn between the estimated and real end point positions; the length of the line indicates the magnitude of the error. The average line length (error) is a very small 0 . 00067 so many lines appear as dots. Right: the second residue plot using the mean of the Gaussian distribution with the second highest probability only for region B. The average line length is 0 . 001 . Both residue plots are needed to check whether both modalities are detected correctly.
 Table 1: Standardised squared errors of different methods on the DELVE data sets. Our method (vmgp) is compared with a single Gaussian process trained using a maximum a posteriori method (gp), a bagged version of MARS (mars), a multi-layer perceptron trained using hybrid MCMC (mlp) and a committee of mixtures of linear experts (me) [11]. set compromised the results, suggesting that for these high dimensional data sets, a large number of training examples are required; and for the present training sets, each training example carries information not represented by others. We started with ten experts and found an average of 2, 1 and 2.75 experts for these data sets, respectively. The average number of GMM components for these data sets are 8.5, 10 and 9.5, respectively, indicating that more GMM components are needed for modeling higher dimensional inputs. Our results are comparable to and sometimes better than those of previous methods.
 Finally, to test how our active set selection algorithm performs, we conducted a standard test for sparse GPs: 7168 samples from Pumadyn-32nm were used for training and the remaining 1024 were for testing. The active set size M was varied from 10 to 150. The error was 0 . 0569 when M = 10 , but quickly reduced to 0 . 0225 , the same as the benchmark error in [7], when M = 25 . We rapidly achieved 0 . 0196 at M = 50 and the error did not decrease after that. This result is better than that of [7] and comparable to the best result of [9]. We present a new mixture of Gaussian processes model and apply variational Bayesian method to train it. The proposed algorithm nicely addresses data multi-modality and training complexity issues of a single Gaussian process. Our method achieved comparable results to previous MCMC-based models on several 2D data sets. One future direction is to compare all algorithms using high dimensional data so we can draw more meaningful conclusions. However, one clear advantage of our method is that training is much faster. This makes our method more suitable for many real-world applications where speed is critical.
 Our active set selection method works well on the Pumadyn-32nm data set. But this test was done in the context of mixture of GPs. To make a fair comparison to other sparse GPs, we can set L = 1 and also try more data sets. It is worthy noting that in the current implementation, the active set size M is fixed for all experts. This can be improved by using a smaller M for an expert with a smaller number of supporting training samples.
 Acknowledgments Thanks to Carl Rasmussen and Christopher Williams for sharing the GPML matlab package.
 Appendix
