 Regular path queries (RPQ X  X ) are given by means of reg-ular expressions and ask for matching patterns on labeled graphs. RPQ X  X  have received great attention in the context of semistructured data, which are data whose structure is irregular, partially known, or subject to frequent changes. One of the most important problems in databases today is the integration of semistructured data from multiple sources modeled as views. The well-know paradigm of computing first a view-based rewriting of the query, and then evaluat-ing the rewriting on the view extensions is indeed possible for RPQ X  X . However, computing the rewriting is computa-tionally hard as it can only be done (in the worst case) in not less than 2EXPTIME. In this paper, we provide prac-tical evidence that computing the rewriting is hard on the average as well. On the positive side, we propose automata-theoretic techniques, which efficiently compute and utilize instead the complement of the rewriting. Notably using the latter, it is possible to answer a query, and this makes the view-based answering of RPQ X  X  fairly feasible in practice. H.2.3 [ Information Systems ]: Database Management X  Languages Algorithms, Experimentation, Languages, Theory semistructured data, data integration, regular path queries
Regular path queries (RPQ X  X ) are in essence regular ex-pressions over a fixed database alphabet. They have received a great deal of attention in the recent years due to the well-known semistructured data model. Semistructured data is data whose structure is irregular, partially known, or subject to frequent changes [1]. They are commonly found in a mul-titude of applications in areas such as communication and traffic networks, web information systems, digital libraries, biological data management, etc.

Semistructured data are formalized as edge labeled graphs, and there is an inherent need to navigate these graphs by means of a recursive query language. As pointed out by seminal works in the field (cf. [7, 15, 4, 3, 6]), regular path queries (RPQ X  X ) are the  X  X inner X  when it comes expressing navigational recursion over graph data. These queries are in essence regular expressions over the database edge symbols, and in general, one is interested in finding query-matching database paths, which spell words in the (regular) query language. For example, the RPQ asks for all the pairs of cities connected by (possibly multi-hop) Air Canada routes, followed by a last optional segment serviced by the partner company Lufthansa. We can ob-serve that evaluating RPQ X  X  on semistructured databases amounts to [regular expression] pattern matching on graphs as opposed to strings.
 Now, suppose that we do not have a database available. Rather, what we have is a set of views on the possible data. These views represent partial information about the database and are expressed by regular expressions as well. For example, we could be given two views with definitions V 1 = AirCanada  X  AirCanada and V 2 = Lufthansa .No-tably, the view definitions are nothing else but regular path queries. Additionally, for each view, we are given a set of pairs that represent the answer to these views (considering them as RPQ X  X ).

This is the classical scenario in LAV ( X  X ocal-as-view X ) data integration (cf. [8, 4, 3, 13, 6, 2, 11]). The basic problem in this setting is to be able to answer a given query using only the available view information. This is a very impor-tant problem which emerges in a variety of situations both commercial (when two similar companies provide partial ac-cess to their data) and scientific (combining research results from different bioinformatics repositories). Data integration appears with increasing frequency as the volume and the need to share existing data explodes.

Answering queries using views is typically achieved by re-formulating the query in terms of the view definitions and then evaluating it on the provided view data. For example, the above query Q can be reformulated (or rewritten) as Q = V  X  1  X  ( V 2 + ). Then, if there are pairs ( a, b )and( associated with views V 1 and V 2 respectively, we produce ( a, c )asananswerto Q . Of course, had we a database in the classical sense, we would be able to also produce pairs of nodes connected by paths with an odd number of Air Canada segments followed by an optional Lufthansa segment. How-ever, for the given views (recall V 1 = AirCanada  X  AirCanada ) this is not possible.
 There are two lines of research for answering RPQ X  X  in LAV data integration. Works in the first line of research study the computation of rewritings, which are regular path queries over the view names (cf. [3, 9]). Having such rewrit-ings is desirable because they enable query answering in polynomial time with respect to the size of the data. On the other hand, works in the second line of research study the perfect (or certain) answering of RPQ X  X , which asks for all the answer tuples obtainable on every possible database consistent with the views (cf. [4, 5, 11]). However, obtaining all the certain answer is much more computationally expen-sive. As it has been shown in [4], to decide whether a tuple belongs in the certain answer is coNP-complete with respect to the size of data. Notably, the answer obtained by using a rewriting is a subset (sometimes strict) of the certain an-swer, and thus, by using a rewriting we get a lower approxi-mation, which might be an acceptable compromise given the data complexity of computing the full certain answer (see [6] for a discussion).

The most important cornerstone in the rewriting of RPQ X  X  using views is the work by Calvanese, De Giacomo, Lenz-erini, and Vardi [3], which shows that the rewriting is indeed possible by giving an algorithm for computing it. The com-plexity of computing the (maximal) view-based rewriting of a regular path query Q is shown to be in 2EXPTIME (in the size of the query) and this bound is also shown to be tight ([3]). Also, in [3] it is shown that the size of the au-tomaton for the rewriting can be doubly exponential in the size of the query Q as measured by the size of a simple NFA for Q .

It should be clear what the inherent problem complexity of 2 2 n (tight) faces us with in practice. If n , the query size, is just 6 for example, then only printing a doubly exponential rewriting would need about 2 2 6  X  18  X  10 18 instructions that is 18  X  10 18 / (30 , 000  X  10 6  X  60  X  60  X  24  X  365)  X  19 years for a modern Intel processor working at about 30 , 000 millions of instructions per second.

This illustrates that obtaining a view-based rewriting is computationally hard except for very small query instances. However, it is possible to argue that the analysis in [3] is worst-case and hence it might take only reasonable amount of time to compute rewritings on the average. Unfortu-nately, our experimental results indicate that this is not the case (see Section 6). Experimentally, we were unable to compute 1 the view-based rewriting, in reasonable time and space, for about one third of the time while working on  X  X andomly generated X  instances. This gives us evidence that computing rewritings is indeed hard on the average as well. We believe that this observation is an important con-tribution of our paper given the importance of the database problem being studied.

In order to make feasible the answering of RPQ X  X  using views, we examine each step in the method of [3]. Then, we show that we can in fact avoid the most expensive step
Using the method of [3] in the method by evaluating instead the complement of the rewriting on the view data. The complement is in the form of an NFA as opposed to a DFA for the rewriting (if the latter is fully computed). This might suggest that the eval-uation on the view data would be slower compared to the evaluation of the DFA for the rewriting. Of course, this is relevant only for the cases when the rewriting can be com-puted in reasonable time and space. Nevertheless, we show that even in such cases, by using a bitvector implementation of NFA X  X , we can achieve similar performance and sometimes even better. This is attributed to hardware parallelism and better hardware cache utilization.

We also found that a seemingly inexpensive polynomial step in the method of [3] was a serious performance bottle-neck. In order to overcome it, we show a simple optimization which gives more than six fold speedup.

In short, we show that by partially employing the method of [3], and using our techniques, the hard problem of an-swering regular path queries using views becomes practically (fairly) feasible.

This paper is the first to shed light on the practical feasi-bility of the very basic and important problem of answering RPQ X  X  in LAV data integration systems and to provide pos-itive results in this direction.

The rest of the paper is organized as follows. In Sec-tion 2, we formally define semistructured databases, regular path queries, and their semantics. In Section 3, we dis-cuss the query answering in LAV information integration systems. Next, in Section 4, we examine the algorithm of [3] for obtaining maximal view-based rewritings. Then, in Section 5 we present our optimization techniques. We show our experimental evaluations in Section 6. Finally, Section 7 concludes the paper.
We consider a database to be an edge labeled graph. This graph model is typical in semistructured data, where the nodes of the database graph represent the objects and the edges represent the attributes of the objects, or relationships between the objects.
 Example 1. We show in Figure 1 a database with informa-tion about an online store, which sells books and software products. A book has an author and covers some software product(s). A software product has a company and possibly other software subproducts. A company might recommend some books for its products. The database is semistructured because the schemas of its objects are not rigid. For exam-ple, a company can only optionally recommend books, or we might be missing information about what products a book might cover.

Formally, let  X  be a finite alphabet. We shall call  X  the database alphabet. Elements of  X  will be denoted R,S,... . As usual,  X   X  denotes the set of all finite words over  X . Words will be denoted by u,w,... . We also assume that we have a universe of objects, and objects will be denoted a,b,c,... .A database DB over  X  is a subset of N  X   X   X  N ,where N is a set of objects, that we usually will call nodes. We view a database as a directed labeled graph, and interpret a triple ( a, R, b ) as a directed edge from object to object b , labeled with R . company
If there is a path labeled R 1 ,R 2 ,...,R k from a to b ,we
A (user) query Q is a regular language over  X . For the ease of notation, we will blur the distinction between regular languages and regular expressions that represent them. Let Q be a query and DB a database. Then, the answer to Q on DB is defined as ans ( Q, DB )= { ( a, b ): a w  X  X  X  b in DB for some w  X  Q } . Example 2. Consider again the database in Figure 1. Sup-pose that the user would like to know for each software prod-uct, all the books that might have some useful information about the product. For this, the user can give the regular path query Q = covers  X  software  X  . This query, on the database DB in Figure 1, will have as answer ans ( Q, DB )= { (MS Office Plain &amp; Simple , MS Office) ,
The well-known method for answering RPQ X  X  on a given database (cf. [1]) is as follows. In essence, we create state-object pairs from the query automaton and the database. For this, let A be an NFA that accepts an RPQ Q .Starting from an object a of a database DB , we first create the pair ( p 0 ,a ), where p 0 is the initial state in A . Then, we create all the pairs ( p, b ) such that there exist a transition from p in A , and an edge from a to b in DB , and furthermore the labels of the transition and the edge match. In the same way, we continue to create new pairs from existing ones, until we are not anymore able to do so. In essence, what is happening is a lazy construction of a Cartesian product graph of the query automaton with the database graph. Of course, only a small (hopefully) part of the Cartesian product is really constructed depending on the selectivity of the query.
After obtaining the above Cartesian product graph, pro-ducing query answers becomes a question of computing reach-ability of nodes ( p, b ), where p is a final state, from ( where p 0 is the initial state. Namely, if ( p, b )isreachable from ( p 0 ,a ), then ( a, b ) is a tuple in the query answer.
Let V 1 ,...,V n be languages (queries) on alphabet  X . We will call them views and associate with each V i a view name v .

We call the set  X  = { v 1 ,...,v n } the outer alphabet ,or view alphabet .Foreach v i  X   X , we set def ( v i )= V i .The substitution def associates with each view name v i in the  X  alphabet the language V i . The substitution def is applied to words, languages, and regular expressions in the usual way (see e.g. [19]).

A view graph is database V over  X . In other words, a view graph is a database where the edges are labeled with symbols from  X . View graphs can also be queried by regular path queries over  X . However, as explained below these are not queries given by the user, but rather rewritings computed by the system.

In a LAV ( X  X ocal-as-view X ) information integration system [13], we have the  X  X lobal schema X   X , the  X  X ource schema X   X , and the  X  X ssertion X  def : X   X  2  X   X  . The only extensional data available is a view graph V over  X  (see also [4, 5, 6, 11]).

The user queries are expressed on the global schema  X , and the system has to answer based solely on the information provided by the views. In order to do this, the system has to reason with respect to the set of possible databases over  X  that V could represent. Under the sound view assumption, a view graph V defines a set poss ( V ) of databases as follows: poss ( V )= (Recall that V i = def ( v i ).) The above definition reflects the intuition about the connection between an edge ( a, v i ,b V with some path from a to b in the possible DB  X  X , labeled by some word in V i .
 Example 3. Consider the view graph in Figure 2 [left], and view definitions V 1 = def ( v 1 )= RS  X  , V 2 = def ( v 2
Figure 2: A view graph and a possible database. and V 3 = def ( v 3 )= S + . Then, a possible database is shown in the same figure [right]. Observe that the views are sound only. They are not required to be complete. For example, we do not have a v 2 -edge from f to b in the view graph. In fact, we do not even have an f object in the view graph. We remark that view soundness is usually the only  X  X uxury X  that we have in information integration systems, where the information is often incomplete.

The meaning of querying a view graph through the global schema  X  is defined as follows. Let Q be a query over  X . Then
There are two approaches for computing ans ( Q, V ). The first one is to use an exponential procedure in the size of the data (i.e. V ) in order to completely compute ans ( Q, V (see [4]). There is little that one can better hope for, since in the same paper it has been proven that to decide whether a tuple belongs to ans ( Q, V ) is co-NP complete with respect to the size of data.

The second approach is to compute first a view-based rewriting Q for Q , as in [3]. Such rewritings are regular path queries on  X . Then, we can approximate ans ( Q, V )by ans ( Q , V ), which can be computed in polynomial time with respect to the size of data ( V ). In general, for a view-based rewriting Q computed by the algorithm of [3], we have that with equality when the rewriting is exact ([4]). In the rest of the paper, we will assume that the data-integration system follows the second approach.
Our proposed techniques enhance the computation and use of maximal view-based rewritings given in [3]. Thus, we first examine these maximal view-based rewritings and the method of [3] for their computation.

Formally, for a given query Q , the maximal view-based rewriting Q ,isthesetof all words on  X  such that their substitution through def is contained in the query language Q , i.e.
 Interestingly, as shown in [3], the above set is a regular lan-guage on  X  and the algorithm of [3] for computing an au-tomaton for this language is as follows.
 Figure 3: Automata A [top], B [middle], and C [bot-tom].

Algorithm 1. 1. Construct a DFA A =( X  ,S,s 0 , X  A ,F ) such that 2. Construct automaton B =( X  ,S,s 0 , X  B ,S  X  F ) ,where 3. The rewriting Q is the  X  language accepted by an au-
Step 2 can also be expressed equivalently as: Consider each pair of states ( s i ,s j ). If in A there is a path from to s j , which spells a word in some view language V x ,then insert a corresponding v x -transition from s i to s j in Example 4. Let query be Q =( RS  X  ) 2 + S + and the view definitions be as in Example 3, i.e. V 1 = def ( v 1 )= RS  X  V 2 = def ( v 2 )= S  X  R ,and V 3 = def ( v 3 )= S + .TheDFA A for the query Q is shown in Figure 3 [top] and the cor-responding automaton B is shown in in Figure 3 [middle]. The resulting complement automaton C is shown in Figure 3 [bottom]. Note that the  X  X rap X  and unreachable states have been removed for clarity.

Observe that, if B accepts an  X -word v 1  X  X  X  v m , then there exist m  X -words w 1 , ..., w m such that w i  X  V i for i = 1 ,...,m and such that the  X -word w 1 ... w m is rejected by A . On the other hand, if there exists a  X -word w 1 ... w m that is rejected by A such that w i  X  V i for i =1 ,...,m then the  X -word v 1  X  X  X  v m is accepted by B .Thatis, B accepts an  X -word v 1  X  X  X  v m if and only if there is a  X -word in def ( v 1  X  X  X  v m ) that is rejected by A .Hence, C being the complement of B accepts an  X -word if and only if all  X -words w = w 1 ... w m such that w i  X  V i for i =1 ,...,m are accepted by A .

As mentioned in the previous section, the rewriting Q rep-resented by automaton C is evaluated on a view graph V ob-taining ans ( Q , V ) which is an approximation of ans ( Q, V Example 5. Consider the rewriting Q represented by the automaton C in Figure 3 [bottom], and the view graph V in Figure 2 [left]. It is easy to see that ans ( Q , V )= { ( a, b ) , ( a, c ) , ( c, b ) } .

Assuming that the user query is given by means of a reg-ular expression, [3] showed, using the algorithm above, that the complexity of computing the maximal view-based rewrit-ing is in 2EXPTIME. Moreover, this bound was shown to be tight by constructing a query instance Q , whose rewrit-ing has a doubly exponential size compared to the size of a simple NFA for Q .
The above 2EXPTIME bound tells us that to obtain a view-based rewriting is computationally hard except for very small query instances. While the first determinization [for obtaining automaton A ] is in practice quite tolerable for typ-ical user queries, the second determinization [for obtaining automaton C by complementing B ] is often prohibitively ex-pensive. However, it is possible to argue that the analysis in [3] is worst-case and hence Algorithm 1 might take only reasonable amount of time on  X  X ypical X  instances (or on the average). Our experimental results indicate that this is not the case (see Section 6). Experimentally, we were unable to compute automaton C , in reasonable time and space, for about one third of the time while working on  X  X andomly generated X  instances.

In this section, we first describe how to optimize the con-struction of automaton B in step 2, which is a significant bottleneck when the number of views is considerable. Then, we deal with step 3 of the algorithm, and propose a tech-nique which essentially eliminates this step.
We present an optimization technique for the step 2 of the above algorithm for computing automaton B .Inour experiments we observed that this step, although a poly-nomial one, is very time consuming if implemented in the straightforward manner.

Taking a closer look at step 2, let s i and s j be two arbi-trary states in automaton A . Now consider automaton A ij which is obtained by keeping all the states and transitions in A , but making state s i and s j initial and final respectively. All the other states in A ij are neither initial nor final.
In step 2 of the algorithm, we want to determine whether there should be transition v x between states s i and s j It is easy to see that this is in fact achieved by testing for the emptiness of the intersection L ( A ij )  X  V x . Namely, we insert a transition ( s i ,v x ,s j )in B iff L ( A ij )  X  V x = the intersection L ( A ij )  X  V x is obtained by constructing the Cartesian product A ij  X A V x ,where A V x is an automaton for V x .

However, the automata A ij for different i  X  X  and j  X  X  have the same states and transitions [namely those of automaton A ]. Only their initial and final states are different. Thus, we construct only one Cartesian product A X A V x for a given view V x . Then, we test emptiness on this Cartesian prod-uct automaton for |A| 2 different combinations of [one] initial and [one] final states. Although asymptotically there is no gain in doing this, experimentally, we found that for typical queries and views, the speedup achieved by this optimiza-tion is often more than 6-fold. This is explained by a better utilization of the CPU cache because there is only one Carte-sian product automaton to be constructed and examined.
In this subsection, we describe how to essentially eliminate step 3 of the algorithm of [3].

Recall that the  X  X iskier penalty X  in the algorithm of [3] is the computation of automaton C in step 3 by complement-ing the automaton B obtained in step 2. C might be doubly exponential in the size of the query. Once C is computed, the final step is to compute ans ( Q , V ) by constructing the Cartesian product of the automaton C and a viewgraph V . We ask if it still possible to compute ans ( Q , V ) directly with-out first computing the DFA for L ( B )? We achieve this by merging the underlying determinization procedure of step 3 and the subsequent computation of the Cartesian product graph into a single step. We illustrate this using an example. Example 6. Consider the NFA B and the viewgraph V shown in Figure 4 [top X  X eft] and [top X  X ight] respectively. To compute the set of all objects reachable, say from a in V following paths spelling words rejected by B , we will build a lazy Cartesian product graph, whose nodes are object X  bitvector pairs and edges are labeled with  X  symbols.
We start with the pair ( a, 100), where 100 is an abbre-viation for (1 , 0 , 0). This bitvector says that automaton is now in state s 0 . Next, we construct the pair ( b, 110) and put a v 1  X  X dge from ( a, 100) to ( b, 110). This is because when reading symbol v 1 , we hop to object b in V ,andinstates and s 1 in B . Continuing in this way, we obtain the Cartesian product graph shown in Figure 4 [bottom].

Building of the above bitvectors is reminiscent of the clas-sical subset construction for converting an NFA into a DFA. In fact, each bitvector corresponds to a state in a DFA for However, we only build those bitvectors, which are asked for by the input viewgraph. Thus, observe that in this example only 4 bitvectors are needed, namely 100, 110, 101, and 111. On the other hand, the minimum size DFA corresponding to B has 2 3 = 8 states (cf. [12] for this family of automata).
Now, once the Cartesian product graph is constructed, it is easily seen that b is reachable from a using a string not in L ( B ) but c is not.

In general, for a B automaton with set S of states, we use bitvectors of size | S | to keep track of the states that B can be when reaching some object of the viewgraph. As illustrated by the above example, the nodes of the (lazy) Cartesian product graph are of the form ( a, u )where a is an object in the viewgraph and u is a bitvector of size | S | Since the input is a graph as opposed to a string, there can be different bitvectors associated with the same given object (for instance with objects a and b in the example).
We want to stress that we build the Cartesian product graph starting from all the viewgraph objects. In the above example, for clarity we showed the Cartesian product con-structed starting from one object only. However, these Carte-sian products overlap, and thus, in order to not generate the same object X  X itvector pair twice, we maintain a hashtable of the pairs generated so far. In fact, even for a single Carte-sian product, the same pair might be needed more than once, and the hashtable is necessary for this case as well in order for the method to terminate.

The edge labels in the Cartesian product graph are of no importance when it comes to generating the query answers. The only thing that matters in this graph is pure reachabil-ity. Namely, we produce a pair ( a, b )asananswer,ifthere exists a path [in the Cartesian product graph] from ( a, u to ( b, w ), where u 0 is the initial bitvector 10 ... 0, and a bitvector having no bit set to 1 for any final state in Formally, our algorithm is as follows.
 Algorithm 2.
 Input: Automaton B and a viewgraph V .
 Output: ans ( Q , V ), where Q = L ( B ).
 Method: Implementation of Next ( u, v ) .

We optimize the amount of time taken to compute adja-cent bitvectors as follows.

Normally, each entry in the transition table of B is just a list of next possible states of the NFA given the current state and input symbol. Instead of storing this list, we store a bitvector  X  of | S | bits, that is the characteristic vector of this list of states. Using the various values of  X  in the transition table, given an object-vector pair of the form ( a, u )andan input symbol v , we can compute Next ( u, v )inonly O ( n time using a sequence of bitwise-OR operations [compared to the naive method of updating vectors that takes O ( n 2 in the worst case]. In particular, without loss of generality, suppose the set of indices in u which have a 1 is exactly { i ,i 2 ....,i k } .Thenitiseasytoseethat where  X  i j ,v is the bitvector  X  in the transition table corre-sponding to the state q i j and the input symbol v .
In the next section, we show that our ideas give substantial improvement in running time making it possible to solve the problem of view-based answering on much larger instances compared to the naive implementation.
We conducted experiments in order to assess the improve-ments offered by answering the query using automaton B over answering using automaton C .

First, we give some details on how we generated queries, views, and viewgraphs. For this we used a simple DataGuide (cf. [1]). DataGuides are essentially finite state automata capturing all the words spelled out by the database paths. In general, DataGuides are compact representations of graph databases. They are small automata presented to the user in order to guide her in writing queries. Each word in a DataGuide could possibly represent many paths that spell Figure 5: [Top] DataGuide corresponding to the database in Figure 1. [Bottom] Grammar for the given DataGuide. that word in a database. For example a DataGuide, captur-ing databases such as the one shown in Figure 1, contains aword software  X  company  X  recommends . Certainly, there are many such paths in databases about online stores.
In our experiments, we used the DataGuide given in Fig-ure 5 [top], where all the states are both initial and final.
For generating view language definitions, we obtained a right linear grammar from the DataGuide of Figure 5 [top]. The rules of this grammar are given in the same figure [bot-tom], where A , B , C , D ,and E are the non terminal symbols corresponding to the DataGuide states.

Then, we randomly generated partial derivations using the above grammar. Such a partial derivation is for exam-ple B  X  company  X  recommends  X  D . By randomly selecting such partial derivations, we created new right linear gram-mars. We kept only those grammars generating non-empty languages. Clearly, the grammars generated in this way cap-ture sublanguages of the DataGuide. By this random pro-cedure, we created 50 test sets of 40 view definitions each.
For each set of views, we created random queries as fol-lows. Let V = { V 1 ,...,V 40 } be a view set. Then, the outer-alphabet is  X  = { v 1 ,...,v 40 } . First, we randomly created a regular expression on  X  of length not more than 10. For in-stance such a regular expression could be re = v 1  X  v  X  13 Next, we set Q = def ( re ), which is a language on  X , and computed its view-based rewriting using set V of views.
We could certainly generate queries in a similar fashion as for generating view languages i.e. directly from the DataGuide. However, doing so generates many cases when the rewriting is empty, and the experiments would be uninteresting. On the other hand, generating queries as above guarantees that the rewritings will not be empty.

Regarding the generation of view graphs, we first ran-domly generated databases from the Data-Guide, and then evaluated on these databases each of the generated views. In this way, we obtained an  X  X nswer X  for each view. For in-stance, we could have { ( a, b ) , ( b, c ) ,... } as the answer for in some randomly generated database. Then, we inserted graph. For each of the 50 sets of views, we randomly gener-ated as above a viewgraph of more than 10,000 nodes.
Then, we computed automaton B for each set of views, and evaluated it [as described in Section 5] on the corre-sponding viewgraph. Also, we tried to compute automaton C accepting L ( B ). We used GRAIL+ (see [17]), which is a well-engineered automata package written in C++. As al-ready mentioned, computing C was not always possible. Out of our 50 cases, computing C timed out in 15 of them. We used a big timeout of 4 hours. Whenever we were able to obtain a DFA C , we evaluated it on the corresponding view-graph. For these cases, we compared the times of evaluating B versus evaluating C on the viewgraphs.

In all the test cases, we computed automaton B using the technique described in Subsection 5.1. It was this technique that made possible the computation of B in a reasonable amount of time for each test case (of 40 views each). As mentioned in Subsection 5.1, using our technique we were able to achieve a speedup of more that six-fold in computing B . Our times for computing the B automata range between 10 to 15 minutes.
 We have tabulated our time and size results in Figure 6. The results were obtained using a modern Sun-Blade-1000 machine with 1GB of RAM. In the following, we describe the column headers of our result table.
 ID: ID of test set.
 B-NFA-size: Size of automaton (NFA) B .
 C-DFA-size: Size of automaton (DFA) C .
 C-DFA-time: Time (in secs) to compute automaton (DFA) C . C-DFA-V-time: Time (in secs) to evaluate automaton (DFA) C-DFA-V-TTime: Total time (in secs) to compute and B-BitNFA-V-time: Time (in secs) to bitwise evaluate au-B-BitNFA-V-size: Size of the input-aware Cartesian prod-Ratio: Ratio of the time to obtain the answers using bit-We have sorted the results in ascending order of the B-BitNFA-V-time . The first part of the table contains the results for the cases when the computation of automaton C succeeded. The second part of the table contains the results for the cases when the computation of automaton C failed. As such, the second part of the table has results which relate to the use of automaton B only. The shaded area of this part of the table is marked by N/P (Not Possible) or (N/A) (Not Applicable) as appropriate.
 Also, we have graphed columns C-DFA-V-time , C-DFA-V-TTime ,and B-BitNFA-V-time in Figure 7 in order to the computation of automaton C was not possible. more clearly show the fractions of instances corresponding to different time ranges, as well as the fraction of instances for which the computation of rewritings is impossible in rea-sonable time and space.

Based on the table of results, we are able to draw the following natural conclusions. 1. Computing in full the view-based rewriting represented 2. Even when constructing C is possible, the performance 3. For all the test cases, the size of the input-aware bit-
From all the above, one can see that by employing our techniques, the view-based answering of RPQ X  X  becomes (fairly) feasible in practice.
In this paper, we examined the well-known problem of answering regular path queries (RPQ) using views in LAV information integration. This problem is particularly impor-tant because RPQ X  X  are part of virtually all the languages for semistructured data, which are very prevalent in infor-mation integration.

This paper makes two useful contributions towards a bet-ter understanding of this important problem. Firstly, it shows experimental evidence that the problem, known to have a worst-case lower bound of 2EXPTIME, also takes lot of time to be solved on the average. Secondly, it proposes automata-theoretic techniques, which make it fairly feasible to obtain the answer for large query instances. In particular, we would like to emphasize the usefulness of the  X  X nswering through rewriting complement X  that we have used in this paper. We hope that this paper will lead to further study of this very important problem. [1] Abiteboul S., P. Buneman, and D. Suciu. Data on the [2] Bravo L., and L. Bertossi. Disjunctive Deductive [3] Calvanese D., G. Giacomo, M. Lenzerini and M. Y. [4] Calvanese D., G. Giacomo, M. Lenzerini and M. Y. [5] Calvanese D., G. Giacomo, M. Lenzerini, and M. Y. [6] Calvanese D., G. Giacomo, M. Lenzerini, and [7] Consens M. P, A. O. Mendelzon. GraphLog: A Visual [8] Grahne G., and A. O. Mendelzon Tableau Techniques [9] Grahne G., and A. Thomo. An Optimization [10] Grahne G., and A. Thomo. Algebraic Rewritings for [11] Grahne G., A. Thomo, and W. Wadge. Preferentially [12] Hopcroft J. E., and J. D. Ullman. Introduction to [13] Lenzerini M. Data Integration: A Theoretical [14] Levy A. Y., Mendelzon A. O., Sagiv Y., Srivastava D. [15] Mendelzon A. O., and P. T. Wood, Finding Regular [16] Mendelzon A. O. G. A. Mihaila and T. Milo.
 [17] Raymond R. D., and D. Wood. Grail: A C++ Library [18] Ullman J. D. Information Integration Using Logical [19] S. Yu. Regular Languages. In: Handbook of Formal
