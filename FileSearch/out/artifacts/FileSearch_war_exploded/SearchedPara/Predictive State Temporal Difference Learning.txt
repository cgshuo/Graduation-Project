 We wish to estimate the value function of a policy in an unknown decision process in a high dimen-sional and partially-observable environment. We represent the value function in a linear architec-ture , as a linear combination of features of (sequences of) observations. A popular family of learning algorithms called temporal difference (TD) methods [1] are designed for this situation. In particular, least-squares TD (LSTD) algorithms [2, 3, 4] exploit the linearity of the value function to estimate its parameters from sampled trajectories, i.e., from sequences of feature vectors of visited states, by solving a set of linear equations.
 both model-free and model-based reinforcement learning [5]. The model-free approach (which includes TD methods) estimates a value function directly from sample trajectories. The model-based approach, by contrast, first learns a model of the process and then computes the value function from the learned model. Parr et al. demonstrated that these two approaches compute exactly the same value function [5]. In the current paper, we build on this insight, while simultaneously finding a compact set of features using powerful methods from system identification.
 First, we look at the problem of improving LSTD from a model-free predictive-bottleneck perspec-tive: given a large set of features of history, we devise a new TD method called Predictive State Temporal Difference (PSTD) learning. PSTD estimates the value function through a bottleneck that preserves only predictive information (Section 3). Second, we look at the problem of value function estimation from a model-based perspective (Section 4). Instead of learning a linear transition model in feature space, as in [5], we use subspace identification [6, 7] to learn a PSR from our samples. Since PSRs are at least as compact as POMDPs, our representation can naturally be viewed as a value-directed compression of a much larger POMDP. Finally, we show that our two improved methods are equivalent. This result yields some appealing theoretical benefits: for example, PSTD features can be explicitly interpreted as a statistically consistent estimate of the true underlying sys-tem state. And, the feasibility of finding the true value function can be shown to depend on the linear dimension of the dynamical system, or equivalently, the dimensionality of the predictive state representation X  not on the cardinality of the POMDP state space. Therefore our representation is naturally  X  X ompressed X  in the sense of [8], speeding up convergence.
 We demonstrate the practical benefits of our method with several experiments: we compare PSTD to competing algorithms on a synthetic example and a difficult optimal stopping problem. In the latter problem, a significant amount of prior work has gone into hand-tuning features. We show that, if we add a large number of weakly relevant features to these hand-tuned features, PSTD can find a predictive subspace which performs much better than competing approaches, improving on the best previously reported result for this problem by a substantial margin. The theoretical and empirical results reported here suggest that, for many applications where LSTD is used to compute a value function, PSTD can be simply substituted to produce better results. We start from a discrete time dynamical system with a set of states S , a set of actions A , a distribution We seek a policy  X  , a mapping from states to actions. For a given policy  X  , the value of state s is defined as the expected discounted sum of rewards when starting in state s and following policy  X  , J ( s ) = E [ P  X  t =0  X  t R ( s t ) | s 0 = s, X  ] . The value function obeys the Bellman equation If we know the transition function T , and if the set of states S is sufficiently small, we can find an optimal policy with policy iteration : pick an initial policy  X  , use (1) to solve for the value function J , compute the greedy policy for J  X  (setting the action at each state to maximize the right-hand side of (1)), and repeat. However, we consider instead the harder problem of estimating the value function when s is a partially observable latent variable, and when the transition function T is unknown. In this situation, we receive information about s through observations from a finite set O . We can no longer make decisions or predict reward based on S , but instead must use a history (an ordered sequence of action-observation pairs h = a h 1 o h 1 ...a h t o h t that have been executed and of all possible histories. H is often very large or infinite, so instead of finding a value separately for each history, we focus on value functions that are linear in features of histories Here w  X  R j is a parameter vector and  X  H ( h )  X  R j is a feature vector for a history h . So, we can rewrite the Bellman equation as where h X o is history h extended by taking action  X  ( h ) and observing o . 2.1 Least Squares Temporal Difference Learning In general we don X  X  know the transition probabilities Pr[ h X o | h ] , but we do have samples of state We can thus estimate the Bellman equation (Here we have used  X  H 1: k to mean the matrix whose columns are  X  H t for t = 1 ...k .) We can can immediately attempt to estimate the parameter w by solving this linear system in the least squares is biased [3], since the independent variables  X  H t  X   X  X  H t +1 are noisy samples of the expected dif-parameters w is an error-in-variables problem.
 The least squares temporal difference (LSTD) algorithm finds a consistent estimate of w by right-multiplying the approximate Bellman equation (Equation 4) by  X  H t T : Here,  X  H t T can be viewed as an instrumental variable [3], i.e., a measurement that is correlated with the true independent variables but uncorrelated with the noise in our estimates of these variables.  X  matrix to be inverted in (5) is consistent. So, as long as this matrix is nonsingular, our estimate of the inverse is also consistent, and our estimate of w converges to the true value with probability 1. number of features is large relative to the number of training samples, then the LSTD estimate of w is prone to overfitting. This problem can be alleviated by choosing a small set of features that only contains information that is relevant for value function approximation. However, with the exception of LARS-TD [9], there has been little work on how to select features automatically for value function approximation when the system model is unknown; and of course, manual feature selection depends on not-always-available expert guidance. We approach the problem of finding a good set of features from a bottleneck perspective. That is, given a large set of features of history, we would like to find a compression that preserves only relevant information for predicting the value function J  X  . As we will see in Section 4, this improvement is directly related to spectral identification of PSRs. 3.1 Finding Predictive Features Through a Bottleneck In order to find a predictive feature compression, we first need to determine what we would like to predict. The most relevant prediction is the value function itself; so, we could simply try to predict total future discounted reward. Unfortunately, total discounted reward has high variance, so unless we have a lot of data, learning will be difficult. We can reduce variance by including other prediction tasks as well. For example, predicting individual rewards at future time steps seems highly relevant, and gives us much more immediate feedback. Similarly, future observations hopefully contain information about future reward, so trying to predict observations can help us predict reward. We call these prediction tasks, collectively, features of the future . We write  X  T t for the vector of Now, instead of remembering a large arbitrary set of features of history, we want to find a small subspace of features of history that is relevant for predicting features of the future. We will call this subspace a predictive compression , and we will write the value function as a linear function of only the predictive compression of features. To find our predictive compression, we will use reduced-rank regression [10]. We define the following empirical covariance matrices between features of the future and features of histories: Let L H be the lower triangular Cholesky factor of b  X  H , H . Then we can find a predictive compression of histories by a singular value decomposition (SVD) of the weighted covariance: write UDV T  X  b  X 
T , H L  X  T H for a truncated SVD [11], where U contains the left singular vectors, V contains the right singular vectors, and D is the diagonal matrix of singular values. (We can tune accuracy by keeping more or fewer singular values, i.e., columns of U , V , or D .) We use the SVD to define a mapping b U from the compressed space up to the space of features of the future, and we define b V to be the optimal compression operator given b U (in a least-squares sense, see [12] for details): By weighting different features of the future differently, we can change the approximate compression constant factor results in a value-directed compression  X  X ut, unlike previous ways to find value-another example, let L T be the Cholesky factor of the empirical covariance of future features b  X  T , T . Then, if we scale features of the future by L  X  T T , the SVD will preserve the largest possible amount of mutual information between history and future, yielding a canonical correlation analysis [13, 14]. 3.2 Predictive State Temporal Difference Learning Now that we have found a predictive compression operator b V via Equation 7, we can replace the features of history  X  H t with the compressed features b V  X  H t in the Bellman recursion, Equation 4: The least squares solution for w is still prone to an error-in-variables problem. The instrumental variable  X  H is still correlated with the true independent variables and uncorrelated with noise, and so we can again use it to unbias the estimate of w . Define the additional covariance matrices: gives us the Predictive State Temporal Difference (PSTD) learning algorithm: So far we have provided some intuition for why predictive features should be better than arbitrary features for temporal difference learning. Below we will show an additional benefit: the model-free algorithm in Equation 10 is, under some circumstances, equivalent to a model-based method which uses subspace identification to learn Predictive State Representations [6, 7]. A predictive state representation (PSR) [15] is a compact and complete description of a dynami-cal system. Unlike POMDPs, which represent state as a distribution over a latent variable, PSRs represent state as a set of predictions of tests . Just as a history is an ordered sequence of action-observation pairs executed prior to time t , we define a test of length i to be an ordered sequence of action-observation pairs  X  = a 1 o 1 ...a i o i that can be executed and observed after time t [15]. the test observations  X  O = o 1 ...o i , given that we intervene [16] to execute the test actions  X  Q ( h ) = (  X  1 ( h ) ,..., X  n ( h )) T for the corresponding vector of test predictions. Formally, a PSR consists of five elements  X  A,O,Q,s 1 ,F  X  . A is a finite set of possible actions, and O is a finite set of possible observations. Q is a core set of tests, i.e., a set whose vector of predictions Q ( h ) is a sufficient statistic for predicting the success probabilities of all tests. F is the set of functions f  X  which embody these predictions:  X  ( h ) = f  X  ( Q ( h )) . And, m 1 = Q ( ) is the initial prediction vector. In this work we will restrict ourselves to linear PSRs, in which all set Q is minimal if the tests in Q are linearly independent [17, 18], i.e., no one test X  X  prediction is a linear function of the other tests X  predictions.
 Q ( h ) instead of h itself. After action a and observation o , we can update Q ( h ) recursively: if we write M ao for the matrix with rows r T ao X  for  X   X  Q , then we can use Bayes X  Rule to show: where m  X  is a normalizer, defined by m T  X  Q ( h ) = 1 for all h . In addition to the above PSR param-eters, for reinforcement learning we need a reward function R ( h ) =  X  T Q ( h ) mapping predictive states to immediate rewards, a discount factor  X   X  [0 , 1] which weights the importance of future rewards vs. present ones, and a policy  X  ( Q ( h )) mapping from predictive states to actions. Instead of ordinary PSRs, we will work with transformed PSRs (TPSRs) [6, 7]. TPSRs are a gener-alization of regular PSRs: a TPSR maintains a small number of sufficient statistics which are linear combinations of a (potentially very large) set of test probabilities. That is, a TPSR maintains a small number of feature predictions instead of test predictions. TPSRs have exactly the same predictive abilities as regular PSRs, but are invariant under similarity transforms: given an invertible matrix S, we can transform m 1  X  Sm 1 , m T  X   X  m T  X  S  X  1 , and M ao  X  SM ao S  X  1 without changing the corresponding dynamical system, since pairs S  X  1 S cancel in Eq. 11. The main benefit of TPSRs over regular PSRs is that, given any core set of tests, low dimensional parameters can be found using spectral matrix decomposition and regression instead of combinatorial search. In this respect, TPSRs are closely related to the transformed representations of LDSs and HMMs found by subspace identification [19, 20, 14, 21]. 4.1 Learning Transformed PSRs Let Q be a minimal core set of tests, so that n = | Q | is the linear dimension of the system. Then, let T be a larger core set of tests (not necessarily minimal), and let H be the set of all possible histories. of features of the future at time t . Since T is a core set of tests, by definition we can compute any test prediction  X  ( h ) as a linear function of T ( h ) . And, since feature predictions are linear combinations of test predictions, we can also compute any feature prediction  X  ( h ) as a linear function of T ( h ) . We define the matrix  X  T  X  R `  X |T| to embody our predictions of future features: an entry of  X  T is the weight of one of the tests in T for calculating the prediction of one of the features in  X  T . Below we define several covariance matrices, Equation 12(a X  X ), in terms of the observable quantities  X  T t ,  X  t , a t , and o t , and show how these matrices relate to the parameters of the underlying PSR. These relationships then lead to our learning algorithm, Eq. 14 below.
 k samples, we can approximate this covariance: As k  X  X  X  , b  X  H , H converges to the true covariance  X  H , H with probability 1. Next we define  X  S , H , the cross covariance of states and features of histories. Writing s t = Q ( h t ) for the (unobserved) data, but this matrix will appear as a factor in several of the matrices that we define below. Next derivations): where row  X  of the matrix R is r  X  , the linear function that specifies the prediction of the test  X  given the predictions of tests in the core set Q . By do (  X  ) , we mean to approximate the effect of executing all sequences of actions required by all tests or features of the future at once. This is not difficult in our experiments (in which all tests use compatible action sequences); but see [12] for further discussion. Eq. 12b tells us that, because of our assumptions about linear dimension, the matrix  X 
T , H has factors R  X  R |T| X  n and  X  S , H  X  R n  X  ` . Therefore, the rank of  X  T , H is no more than n , the linear dimension of the system. We can also see that, since the size of  X  T , H is fixed, as the number of samples k increases, b  X  T , H  X   X  T , H with probability 1.
 Next we define  X  H ,ao, H , a set of matrices, one for each action-observation pair, that represent the covariance between features of history before and after taking action a and observing o . In the following, I t ( o ) is an indicator variable for whether we see observation o at step t . b Since the dimensions of each b  X  H ,ao, H are fixed, as k  X   X  these empirical covariances converge to the true covariances  X  H ,ao, H with probability 1. Finally we define  X  R , H , and approximate the covariance (in this case a vector) of reward and features of history: Again, as k  X  X  X  , b  X  R , H converges to  X  R , H with probability 1.
 We now wish to use the above-defined matrices to learn a TPSR from data. To do so we need to make a somewhat-restrictive assumption: we assume that our features of history are rich enough to We discuss how to relax this assumption in [12]. We also need a matrix U such that U T  X  T R is invertible; with probability 1 a random matrix satisfies this condition, but as we will see below, there are reasons to choose U via SVD of a scaled version of  X  T , H as described in Sec. 3.1. Using our assumptions we can show a useful identity for  X  H ,ao, H (for proof details see [12]): This identity is at the heart of our learning algorithm: it states that  X  H ,ao, H contains a hidden copy of M ao , the main TPSR parameter that we need to learn. We would like to recover M ao via Eq. 13, M we can use U T  X  T , H as a stand-in, since this matrix differs only by an invertible transform (Eq. 12b). We now show how to recover a TPSR from the matrices  X  T , H ,  X  H , H ,  X  R , H ,  X  H ,ao, H , and U . Since a TPSR X  X  predictions are invariant to a similarity transform of its parameters, our algorithm only recovers the TPSR parameters to within a similarity transform [7, 12]. Our PSR learning algorithm is simple: replace each true covariance matrix in Eq. 14 by its empirical estimate. Since the empirical estimates converge to their true values with probability 1 as the sample size increases, our learning algorithm is clearly statistically consistent. 4.2 Predictive State Temporal Difference Learning (Revisited) Finally, we are ready to show that the model-free PSTD learning algorithm introduced in Section 3.2 is equivalent to a model-based algorithm built around PSR learning. For a fixed policy  X  , a PSR b b V as in Eq. 7, and let U = b U as suggested above in Sec. 4.1. Then U T b  X  T , H = b V b  X  H , H , and Eq. 15 is exactly Eq. 10, the PSTD algorithm. So, we have shown that, if we learn a PSR by the subspace identification algorithm of Sec. 4.1 and then compute its value function via the Bellman equation, we get the exact same answer as if we had directly learned the value function via the model-free PSTD method. In addition to adding to our understanding of both methods, an important corollary of this result is that PSTD is a statistically consistent algorithm for PSR value function approximation X  X o our knowledge, the first such result for a TD method. 5.1 Estimating the Value Function of a RR-POMDP We evaluate the PSTD learning algorithm on a synthetic example derived from [23]. The problem is to find the value function of a policy in a partially observable Markov decision Process (POMDP). The POMDP has 4 latent states, but the policy X  X  transition matrix is low rank: the resulting belief distributions lie in a 3-dimensional subspace of the original belief simplex (see [12] for details). Figure 1: Experimental Results. Error bars indicate standard error. (A) Estimating the value func-tion with a small number of informative features. All three approaches do well. (B) Estimating the value function with a small set of informative features and a large set of random features. LARS-TD is designed for this scenario and dramatically outperforms PSTD and LSTD. (C) Estimating the value function with a large set of semi-informative features. PSTD is able to determine a small set of compressed features that retain the maximal amount of information about the value function, outperforming LSTD and LARS-TD. (D) Pricing a high-dimensional derivative via policy iteration. The optimal threshold strategy (sell if price is above a threshold [24]) is in black, LSTD (16 canon-ical features) is in blue, LSTD (on the full 220 features) is cyan, LARS-TD (feature selection from set of 220) is in green, and PSTD (16 dimensions, compressing 220 features) is in red.
 We perform 3 experiments, comparing the performance of LSTD, LARS-TD, and PSTD when dif-ferent sets of features are used. In each case we compare the value function estimated by each algorithm to the true value function computed by J  X  = R ( I  X   X T  X  )  X  1 . In the first experiment we execute the policy  X  for 1000 time steps. We split the data into overlapping histories and tests of length 5, and sample 10 of these histories and tests to serve as centers for Gaussian radial ba-sis functions. We then evaluate each basis function at every remaining sample. Then, using these features, we learned the value function using LSTD, LARS-TD, and PSTD with linear dimension 3 (Figure 1(A)). Each method estimated a reasonable value function. For the second experiment, we added 490 random, uninformative features to the 10 good features and then attempted to learn the value function with each of the 3 algorithms (Figure 1(B)). In this case, LSTD and PSTD both had difficulty fitting the value function due to the large number of irrelevant features. LARS-TD, designed for precisely this scenario, was able to select the 10 relevant features and estimate the value function better by a substantial margin. For the third experiment, we increased the number of sampled features from 10 to 500. In this case, each feature was somewhat relevant, but the number of features was large compared to the amount of training data. This situation occurs frequently in practice: it is often easy to find a large number of features that are at least somewhat related to state. PSTD outperforms LSTD and LARS-TD by summarizing these features and efficiently estimating the value function (Figure 1(C)). 5.2 Pricing A High-dimensional Financial Derivative Derivatives are financial contracts with payoffs linked to the future prices of basic assets such as stocks, bonds and commodities. In some derivatives the contract holder has no choices, but in more complex cases, the holder must make decisions, and the value of the contract depends on how the holder acts X  X .g., with early exercise the holder can decide to terminate the contract at any time and receive payments based on prevailing market conditions, so deciding when to exercise is an optimal stopping problem. Stopping problems provide an ideal testbed for policy evaluation methods, since we can collect a single data set which lets us evaluate any policy: we just choose the  X  X ontinue X  action forever. (We can then evaluate the  X  X top X  action easily in any of the resulting states.) generates payoffs that are contingent on the prices of a single stock. At the end of each day, the holder may opt to exercise. At exercise the holder receives a payoff equal to the current price of the stock divided by the price 100 days beforehand. We can think of this derivative as a  X  X sychic call X : the holder gets to decide whether s/he would like to have bought an ordinary 100-day European call option, at the then-current market price, 100 days ago. In our simulation (and unknown to the investor), the underlying stock price follows a geometric Brownian motion with volatility  X  = 0 . 02 and continuously compounded short term growth rate  X  = 0 . 0004 . Assuming stock prices fluctuate only on days when the market is open, these parameters correspond to an annual growth rate of  X  10% . In more detail, if w t is a standard Brownian motion, then the stock price p t evolves as  X  p t =  X p t  X  t +  X p t  X  w t , and we can summarize relevant state at the end of each day as a vector x x and x t +100 are independent and identically distributed. The immediate reward for exercising the option is G ( x ) = x (100) , and the immediate reward for continuing to hold the option is 0. The discount factor  X  = e  X   X  is determined by the growth rate; this corresponds to assuming that the risk-free interest rate is equal to the stock X  X  growth rate, meaning that the investor gains nothing in expectation by holding the stock itself.
 Our goal is to calculate an approximate value function V ( x ) = w T  X  H ( x ) , and then use this value function to generate a stopping time min { t | G ( x t )  X  V ( x t ) } . To do so, we sample a sequence of 1,000,000 states x t  X  R 100 and calculate features  X  H of each state. We then perform policy iteration on this sample, alternately estimating the value function under a given policy and then using this value function to define a new greedy policy  X  X top if G ( x t )  X  w T  X  H ( x t ) . X  Within the above strategy, we have two main choices: which features do we use, and how do we estimate the value function in terms of these features. For value function estimation, we used LSTD, LARS-TD, or PSTD. In each case we re-used our 1,000,000-state sample trajectory for all iterations: we start at the beginning and follow the trajectory as long as the policy chooses the  X  X ontinue X  action, with reward 0 at each step. When the policy executes the  X  X top X  action, the reward is G ( x ) and the next state X  X  features are all 0; we then restart the policy 100 steps in the future, after the process has fully mixed. For feature selection, we are fortunate: previous researchers have hand-selected a  X  X ood X  set of 16 features for this data set through repeated trial and error (see [12] and [24, 25]). We greatly expand this set of features, then use PSTD to synthesize a small set of high-quality combined features. Specifically, we add the entire 100-step state vector, the squares of the components of the state vector, and several additional nonlinear features, increasing the total number of features from 16 to 220. We use histories of length 1, tests of length 5, and (for comparison X  X  sake) we choose a linear dimension of 16. Tests (but not histories) were value-directed by reducing the variance of all features except reward by a factor of 100.
 Figure 1D shows results. We compared PSTD (reducing 220 to 16 features) to LSTD with either the 16 hand-selected features or the full 220 features, as well as to LARS-TD (220 features) and to a simple thresholding strategy [24]. In each case we evaluated the final policy on 10,000 new ran-dom trajectories. PSTD outperformed each of its competitors, improving on the next best approach, LARS-TD, by 1.75 percentage points. In fact, PSTD performs better than the best previously re-ported approach [24, 25] by 1.24 percentage points. These improvements correspond to appreciable fractions of the risk-free interest rate (which is about 4 percentage points over the 100 day window of the contract), and therefore to significant arbitrage opportunities: an investor who doesn X  X  know the best strategy will consistently undervalue the security, allowing an informed investor to buy it for below its expected value. In this paper, we attack the feature selection problem for temporal difference learning. Although well-known temporal difference algorithms such as LSTD can provide asymptotically unbiased es-timates of value function parameters in linear architectures, they can have trouble in finite samples: if the number of features is large relative to the number of training samples, then they can have high variance in their value function estimates. For this reason, in real-world problems, a substantial amount of time is spent selecting a small set of features, often by trial and error [24, 25]. To remedy this problem, we present the PSTD algorithm, a new approach to feature selection for TD methods, which demonstrates how insights from system identification can benefit reinforcement learning. PSTD automatically chooses a small set of features that are relevant for prediction and value func-tion approximation. It approaches feature selection from a bottleneck perspective, by finding a small set of features that preserves only predictive information. Because of the focus on predictive infor-mation, the PSTD approach is closely connected to PSRs: under appropriate assumptions, PSTD X  X  compressed set of features is asymptotically equivalent to TPSR state, and PSTD is a consistent estimator of the PSR value function.
 We demonstrate the merits of PSTD compared to two popular alternative algorithms, LARS-TD and LSTD, on a synthetic example, and argue that PSTD is most effective when approximating a value function from a large number of features, each of which contains at least a little information about state. Finally, we apply PSTD to a difficult optimal stopping problem, and demonstrate the practical utility of the algorithm by outperforming several alternative approaches and topping the best reported previous results.
