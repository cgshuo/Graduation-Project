 Knowledge-based recommender systems are applications that support users in the process of retrieving items from a com-plex product assortment (e.g. computers, holiday pack-ages, and financial services). Recommendations are deter-mined on the basis of explicitly defined user requirements which can be interpreted as constraints to be fulfilled by the items stored in a product table. If no solution (item) can be found, existing knowledge-based recommenders propose non-personalized query relaxations and repair actions for the given set of customer requirements that support a recovery from the dead-end. This paper points out how the usability of knowledge-based recommender systems can be improved by introducing the concept of personalized query relaxations and repair actions.
 I.2.1 [ Artificial Intelligence ]: Applications and Expert Systems Algorithms, Design, Experimentation Recommender Systems, Model-Based Diagnosis, Personal-ization
Recommending items such as financial services, comput-ers, or holiday packages in most cases requires an inter-active process where the customer repeatedly specifies re-quirements and the recommender application tries to iden-tify corresponding solutions. In such scenarios the wide-spread recommendation approaches of collaborative filter-ing [6] and content-based filtering [9] are not the best choice [1]. Compared to the mentioned filtering approaches [6], presentation). Finally, arguments which explain the reasons for the recommendation are calculated and presented to the user for each product (Step 4 -result explanation).
The remainder of the paper is structured as follows: Sec-tion 2 introduces the concept of personalized repair actions and shows how this concept can be used to solve the  X  X o so-lution could be found X  dilemma. First, a basic algorithm is introduced, and then different already developed extensions are discussed. A first performance and empirical evaluation is presented that clearly shows the applicability of the pre-sented approach. An outline of relevant topics for future work is given in Section 3. With Section 4 the paper is concluded.
The recommendation of one or more products based on consistent user requirements is relatively easy: all products from the product table that fulfill all requirements can be recommended. In contrast, if the user constraints are too narrow, no product can be found that satisfies all requests. State-of-the-art systems improve the  X  X o solution could be found X  dilemma by using model-based diagnosis. Existing approaches to help the user adapting his requirements focus on low cardinality sets of diagnosis [2], [8] and representative explanations [8] -in both cases, minimal sets of requirements are prosed that -if deleted from the original set of require-ments -allow the calculation of a solution (recommenda-tion). These diagnoses and explanations identify potential areas (requirements) that need to be changed, but none of those approaches suggests concrete repair actions for incon-sistent requirements to the user, i.e., concrete proposals for changing the original set of requirements.

Typically the set of possible repair actions is large and the upper bound for the number of repair actions is defined by the number of items in the product table. A product table typically consists of 1000 to 8000 items or even more. For a user it is definitely not possible to evaluate all the the-oretically possible repair actions. To tackle this challenge we propose a personalized approach to calculate query re-laxations and corresponding repair actions on the basis of methods from case-based recommendation [1] and model-based diagnosis (MBD) [10]. In the following sub-section we will present the basic algorithm to calculate personalized query relaxations.
The algorithm to calculate personalized query relaxations is based on a product table and a set of requirements which are normally collected within the scope of a dialog with the user. A simple example product assortment from the domain of financial services is shown in Table 1. Let us assume that the user has specified the following requirements: R = { r 1 : runtime  X  3, r 2 : return-rate  X  5, r 3 : risk-level = 1, r : minimal-investment &lt; 500 and r 5 : accessibility = yes } . When calculating a recommendation for these requirements on the basis of the items in Table 1, we can easily see that no item (product) fulfills all the requirements. Consequently, we need to calculate repair actions that provide an indication of how to get out from the dead-end.

Every product represents a basic a set of repair actions (those attribute values that are not fulfilling the set of given requirements), but we only want to identify those repair actions which are minimal and most valuable for the user. similarity 0.52 0.52 0.72 0.44 0.74 0.72 0.71 is in our case r 1 . If we delete r 1 from the original set of requirements, the remaining set { r 2 , r 3 , r 4 , r 5 } is still in-consistent with the given products. Consequently, further conflicts are induced by the remaining requirements and the next conflict set returned in our case is { r 3 , r 5 } . The HS-DAG construction is continued this way until the conflict detection algorithm 2.1 is not able to detect a further con-flict. In such a situation, a corresponding diagnosis has been identified.

The similarity is a crucial measure for the acceptance of the algorithm. Figure 3 presents three different ways to calculate the similarity [7]. This distinction is necessary due to unequal characteristics of the attributes. For attributes such as the price or the risk level a lower value is more satisfactory for the user. In contrast the customer would be more pleased with a higher value when it comes to the return-rate. Table 2 presents the similarities for all products of Table 1 according to the sample user requirements { r 1 ,... , r 5 } .
 Figure 3: Formulas to calculate similarity measures
In our working example we found the diagnosis { r 1 , r 3 } as shown in Figure 2. Based on this diagnosis we are able to propose a personalized query relaxation: runtime = 5 AND risk-level = 2 . The repair actions possible for the diagnosis r , r 3 are {{ runtime = 5 AND risk-level = 2 } and { runtime = 6 AND risk-level = 2 }} since querying the database table with the criteria R-{ r 1 , r 3 } results in P 1 , P 5 and P 6 . A more detailed discussion of the algorithm for determining personlized repair actions can be found in [3].
An empirical evaluation was performed in order to demon-strate the improvements achieved. In this study we com-pared the cardinality-based approach; repair alternatives are ranked according to their cardinality with the personalized repair approach discussed in this paper. 493 subjects took part in this study where each subject was confronted with a conflict where a repair alternative had to be selected out from 5 given different alternatives. Our hypothesis was that  X  X ubjects will select higher ranked repair actions significantly more often if the personalized repair algorithm was used X . We could corroborate our hypothesis. More details of this study can be found in [3]. Figure 5: Runtime evaluation for the calculation of 1-10 diagnoses with a satisfaction rate of 50%, where the | NN | = number of items in interactive settings, since the highest runtime (for 10 re-quirements, 8000 items and a satisfaction rate of 30%) is close to 0.43 seconds -which is still acceptable for the user.
There are a couple of additional challenges that we want to tackle within the scope of future work.

Prediction quality of repair selection: In follow-up studies we will compare different similarity measures, diver-sity metrics and probabilistic methods with regard to predic-tion quality, i.e., how good are those measures in predicting which repair actions will be of interest for the user.
Performance of conflict detection: The performance of the algorithm to calculate personalized query relaxations highly depends on the performance of the algorithm that is used to identify minimal conflict sets. As our work in [11] shows the performance of the state-of-the-art algorithm QuickXplain [5] can be improved for settings where a knowl-edge base is simply represented by a set of enumerated items.
Configurable products and services: In this paper we introduced a simple knowledge-based recommendation sce-nario, where items are predefined and stored in a correspond-ing item table. In more complex scenarios the set of items which can be recommended to a user is defined implicitly in the form of a configuration knowledge base. The empirical evaluation of our approach with more complex knowledge bases is within the scope of future work.
In this paper we presented a basic algorithm to address the  X  X o solution could be found X  dilemma in knowledge-based recommender systems. State-of-the-art algorithms [2], [4] use model-based diagnosis to identify possible query relax-ations. As the amount of possible query relaxations is nor-mally too big to be presented to the user, a personalized approach to calculate repair actions (algorithm sketched in section 2.1) has been presented. Providing intelligent solu-tions for the personalized repair of inconsistent requirements is crucial for a successful application of knowledge-based rec-ommendation technologies. In future work we will focus on a detailed evaluation of different strategies useful for maxi-mizing prediction quality.
