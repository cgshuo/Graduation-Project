 Service-oriented Architect ures (SOA) allow developers to create flexible and agile composite applications by reusing existing and loosely coupled Web services [5]. Such Web services can be roughly grouped into two categories: public and cor-porate Web services. On the one hand, there is a large body of public Web services currently available on the Web (cf. seekda 1 ). These Web services are typically scattered across various domains (e.g. finance, weather etc.) with het-erogeneous service definitions solely based on the service provid er X  X  preferences. On the other hand, modern Enterprise Applications, e.g. Enterprise Resource Planing (ERP), are often based on the SOA paradigm enabling organizations using these applications to expose internal data and functionality as (mainly proprietary) Web Services. In this con text, Web services are referred to as En-terprise Service (ES) [11]. In contrast to public We b services, Enterprise Services are mostly offered through internal 2 and centralized UDDI-like repositories, e.g., SAP X  X  Enterprise Service Repository 3 . Their service design process is typically standardized and aligned to some kind of business modeling [21], endorsing a close cooperation and coordination of an organization X  X  business and IT depart-ments [27]. In order to manage a great number of ESs, which can easily be in the thousands for real-world enterprise applications [13], some application providers apply governance processes to manage their SOA  X  summarized un-der SOA Governance  X  to cover various area of service design, implementation, and provisioning. We herein focus on the design aspect, where SOA Governance often defines best practices to foster high reuse and avoid duplication of Enter-prise Services. This includes guidelines to unambiguous naming of interfaces and operations for an increasing number of E nterprise Services. However, the gains in manageability for organizations developing services comes at the price of de-creased understandability for service consumers. To demonstrate this point, we refer the reader to the examples of Enter prise Service operation names as shown in Table 1. These have been returned as part of a keyword search for ESs related to  X  X ales Order X  on SAP X  X  ESR. From the perspective of less professional and non SAP-educated developers, these examples of Enterprise Services interfaces may be perceived as (i) long, (ii) technical and (iii) similar sounding. The au-thors in [3] demonstrated that these characteristics  X  among others  X  impose additional difficulties to cognitively understand and locate Enterprise Services. In order to facilitate techniques, e.g. discovery, that can be built on top of Enterprise Services, it is beneficial to augment the description of Enterprise Services as described hereinafter. In mos t cases, Enterprise Services are defined in terms of a standardized description language, e.g. WSDL 4 , that defines what operations can be invoked using which parameters. Description languages like WSDL are, however, not well suited to sufficiently and formally describe the meaning of Enterprise Services. In such cases, semantic languages, e.g. RDF 5 , allow to add and relate semantic concepts (e.g. defined by means of ontologies) to parts of the service description. Although semantic approaches have been shown to effectively improve e.g. servic e discovery and composition, they still require mostly manual effort to create re quired ontologies an d generate related annotations.
In this work, we address the latter point by utilizing service design method-ologies from a SOA Governance process to automatically annotate Enterprise Service descriptions. Our approach can be regarded as deriving semantic anno-tations from ESs to make their discovery easier. We therefore propose a solution to automatically augment the descriptio n of Enterprise Ser vices with concepts stemming from such a design methodology. Using the example of an SAP ser-vice design process, we first identified this service design methodology as well as naming conventions used as part of a SOA Governance process (cf. Figure 1 -Conceptual Layer). Second, we used RDF/S 6 to describe and represent this service development methodology, abstractly. We formally defined this represen-tational schema as a hierarchy of terminological and factual concepts, referred to as service knowledge base (cf. Figure 1 -Logical Layer). Concepts in that knowl-edge base  X  among others  X  are used to define signatures of Enterprise Services. We then use non-deterministic automata to formally define a language of Enter-prise Service signatures derived from available naming conventions (cf. Figure 1 -Logical Layer). We refer to the knowledge base and automaton as service an-notation framework. Third, we applied our framework to the example of SAP to automatically annotate Enterprise Services (cf. Figure 1 -Physical Layer). That is, an Enterprise Service signat ure that is accepted b y the automaton is a valid concatenation of words (i.e. factual concepts) that relate to terminological concepts in the service knowledge bas e. The set of detected concepts is then used to annotate the respect ive Enterprise Service. Th e corresponding steps are illustrated as dashed lines in Figure 1. Our prototypical implementation shows that a majority of available Enterprise Services can be annotated automatically. An evaluation of generated annotations in fact demonstrates a high degree of completeness, accura cy and correctness.
 In the remainder, we explain an example of SOA Governance in Section 2. We then describe the service annotati on framework in Section 3. In Section 4, we present a solution and evaluate gener ated annotations in Section 5. Finally, we refer to related work in Section 6 an d provide a conclusion in Section 7. Organizations use SOA Governance to better manage their SOA development. This has been ascertained by [16], predicting a considerably high risk of failures for midsize to large SOA projects of m ore than 50 Web Services without any applied SOA governance mechanism. Large companies such as SAP, IBM and Oracle employ SOA Governance mechanisms to ensure a consistent, effective and business aligned development of SOA-based applications. We refer to SOA Governance as policies to make consistent decisions on how to build usable and long-living services. SOA Governance, si milar to IT Governance, typically covers multiple phases of a service life-cycle, e.g. service planning, design, definition, implementation etc. [10]. In terms of se rvice design, developers are guided in their task to create interfaces of future En terprise Services. Governance applied during the design phase typically encompasses guidelines and best practices to effectively create services that are (idea lly) mutually exclusive and exhaustive regarding coverage of functionality. It also creates a common agreement and se-mantic alignment of concep ts used during the service development. For instance  X  X ales Order X  is a business entity defining a contractual order that is commonly understood by developers, customers and partners across corporate boundaries. 2.1 SOA Governance -A Service Design Example As a motivating example, we describe one possible way to abstract and utilize information used as part of SAP X  X  service development methodology for creating Enterprise Services. Specifically the definition of Enterprise Service signatures can be quite versatile, encompassing the use of multiple (i) concepts arranged by some kind of (ii) naming convention [2 ,21]. We herein refer to concepts as ter-minological concepts and to its instance data as factual concepts . The schema in Figure 2 shows an example of such concepts as part of our definition of a knowl-edge base . Particularly, the schema illustrates  X  but is not restricted to  X  the application of two main terminological concepts: a domain-specific data model and service development pattern . We used RDF/S to describe the hierarchy of both types of concepts in a single schema focusing only on a minimal example of terminological concepts, i.e. data model and pattern, and naming conventions used to describe Enterprise Services. We r efer to the Enterprise Service (S1) as an end-to-end example to illustrate used design principles as well as our approach:
Signature (S1) defines an incoming request operation (invoked by a seller) to change the schedule line of an item contained in an existing sales order of a spe-cific customer. From this signature, we c an recognize factual concepts that have been modeled as part of our schema. On the one hand, the terms  X  X ales Order X ,  X  X tem X  and  X  X chedule Line X  refer to factual concepts belonging to terminologi-cal concepts listed under data model (cf. Fig. 2). On the other hand, the terms  X  X hange X ,  X  X equest X  and  X  X n X  represent factual concepts of a particular service development pattern, also a terminological concept. In a final step, these terms are arranged according to a specific order that is defined by a set of naming conventions. Next, we explain terminological concepts of the data model and pattern and show how they are utilized to create Enterprise Service signatures using naming conventions.
 A domain-specific data model. Typically, Enterpris e Services are built on key entities of a domain-specific data model. For instance, signature (S1) is specified according to the factual concept  X  X ales Order X ,  X  X tem X  and  X  X chedule Line X  as inferred from the data model defined as part of the knowledge base (cf. Fig. 2). This model represents an abstract and trimmed-down version of an existing information model used by SAP. Such an information model de-scribes, in more detail, the relationship of business-related entities used by an organization to realize internal operations. Each terminological concepts has fac-tual concepts associated with it. Applying this to our example, the terminolog-ical concept  X  X usiness Object Node X  ( BO Node) belongs to  X  X usiness Object X  (BO), which implies that the factual con cept  X  X tem X  belongs to  X  X ales Order X : SalesOrderItem ScheduleLineChangeRequestConfirmation In Service development patterns. Apart from the data model, the service knowledge base also describes develo pment patterns recurrently used by de-velopers to uniformly define Enterprise Services. These patterns can further be separated into access, communication and d irection pattern (cf. Fig. 2). Firstly, the access pattern specifies predefined ways on how to access objects in the data model, e.g.  X  X reate X  or  X  X hange X . Secondly, the communication pattern describes the type of interaction to be e.g.  X  X equest-confirmation X  to define a request operation that causes some action and a confirmation message being returned. Thirdly, the direction pattern describes a service operation to be ei-ther  X  X nbound X  (e.g. incoming request to create a sales order) or  X  X utbound X  (e.g. outgoing credit card authorization request). We derived these patterns di-rectly from available SOA Governance information. Referring to (S1), the sig-nature employs factual concepts  X  X hange X ,  X  X equest-confirmation X  and  X  X n X  be-longing to terminologica l concepts access, communica tion and direction pattern respectively: SalesOrderItemScheduleLineChangeRequestConfirmation In Naming Conventions. The examples (N1)-(N3) below illustrate that naming conventions already come in a pre-structured way (cf. [21]) and are used to guide the creation of Enterprise Service sign atures. The showcased syntax is defined on the basis of non-terminal symbols, i.e. terminological concepts, and terminal symbols, i.e. factual concepts.
 In terms of signature definition, (N1) for instance describes that any factual concept related to a BO Node has to be po sitioned after the factual concept of a particular BO. Finally, to receive a singl e (possibly incomplete) building rule, we consolidated naming conventions (N1), (N2) and (N3) based on documentation that outlines how to combine them. We f urther substitute d the access pattern for the terminal words in (N2). As a result, the building rule (B1) represents one possible way of (partially) describing our Enterprise Service signature (S1):
BR = &lt;BO&gt;&lt;BO Node&gt;&lt;AccessPattern&gt;&lt;CommunicationPattern&gt; In this section, we formally describe th e two components used in our framework to automatically annotate Enterprise Services, i.e. the service knowledge base and the non-deterministic automaton. These components are based on our mod-eling of SOA Governance as described in t he previous Section. Therefore, we first define the service knowledge base as an abstract model and data that represents a given service design methodology (cf. data model and pattern in Section 2.1). Second, we define a non-deterministic automaton describing a formal language of Enterprise Service signatures. To illustrate this procedure, we will use the naming conventions from Section 2.1. 3.1 Service Knowledge Base In the following, we formally define the service knowledge base as KB = D, F . We refer to D as a set of terminological concepts describing an abstract repre-sentation of a service development methodology. With F , we describe a set of factual concepts that are mapped to related terminological concepts in D . Definition 1 (Methodology Representation D ). We define the abstract representation D as a directed graph D =( T,R,E ) with T representing a set of terminological concepts T = { t 1 ,...,t n } , R denoting a set of relationships R = { r 1 ,...,r m } and E a set of directed edges between two terminological concepts belonging to a specific relationship such that E = { e 1 ,...,e k } with e =( t o ,r y ,t p ) , 0  X  i  X  k , 0  X  o, p  X  n , 0  X  y  X  m .
 Example 1 (Methodology Representation D ). We use the example of termino-logical concepts as described in Sect ion 2.1 to define the conceptual part D = ( T,R,E ) of the service knowledge base KB = D, F . As such, the representa-tion D describes a child-relationship of the concept  X  X usiness Object Node X  to the concept  X  X usiness Object X .
 T := { t 1 ,t 2 } = { Business Object , Business Object Node } , R := { r 1 } = { containsBON } , E := { e 1 } with e := ( t 1 ,r 1 ,t 2 )=( Business Object , containsBON , Business Object Node ) Definition 2 (Factual Concepts F ). We define F as a set of factual concepts F = { f 1 ,f 2 ,...,f m } . We further define a mapping  X  : F  X  T ,  X  ( f )= t for f  X  F, t  X  T , such that  X  f  X  F :  X  t  X  T :  X  ( f )= t . Furthermore, for each t  X  T we denote the (possibly empty) subset F t  X  F such that  X  f  X  F t :  X  ( f )= t . Obviously these subsets are distinct for different t , i.e.  X  t i ,t j  X  T : t i = t j  X  F Example 2 (Factual Concepts F ). Referring to the examples of factual concepts asshowninSection2.1,weuse F to represent a set of factual concepts, i.e.  X  X ales Order X ,  X  X urchase Order X  and  X  X tem X . We further have distinct subsets F t 1 and F 2 of F , whereas  X  X ales Order X  and  X  X urchase Order X  represent F t 1 and  X  X tem X  forms F t 2 . The mapping  X  describes the relationship of factual concepts in F t 1 and F t 2 to T , which practically relates  X  X ales Order X  and  X  X urchase Order X  to  X  X usiness Object X  and  X  X tem X  to  X  X usiness Object Node X .
 F := { f 1 ,f 2 ,f 3 } = { Sales Order , Purchase Order , Item } ,  X  ( f 1 ):= t 1  X   X  ( Sales Order )= Business Object  X  ( f 2 ):= t 1  X   X  ( Purchase Order )= Business Object  X  ( f 3 ):= t 2  X   X  ( Item )= Business Object Node F 3.2 Service Signature Automaton In this section, we use the notation of a non-deterministic finite automaton (NFA) with  X  -moves to formally define a language of accepted Enterprise Services signatures. We use previously defined terminological concepts T (Def. 1) as the set of input symbols (i.e. alphabet) to initiate state changes. A path through this automaton, i.e. a finite sequence of connected states, ending in a final state represents a concatenation of terminological concepts that defines a language of Enterprise Service signatures.

Furthermore, we decided for an NFA- X  and against a DFA (deterministic finite automaton) for the following reason. Although we expect SOA governance-compliant Enterprise Services to correct ly employ naming conventions, we can-not assume them to be exhaustive to comple tely describe any Enterprise Services signature. This means that the automaton should be able to ignore parts of the signature that are unknown, i.e. not defined by a naming rule or where concepts are not recognized. For this, we included empty-word transitions (  X  -moves). Definition 3 (Automaton A ). We define the NFA- X  as A =( Q, T, M, q 0 ,Z ) with Q denoting a finite set of states, T used as input symbols, M : Q  X  ( T  X  {  X  } )  X  P ( Q ) as the transition function (including  X  -moves) to a powerset of Q , q  X  Q representing the start state and Z  X  Q denoting a (possibly empty) set of final states. We further define the powerset of a particular state P ( { q } ) , q  X  Q as the set of states that can be reached from q with input t  X  T and  X  such that P ( { q } )= { p  X  Q : q t, X   X  X  X  p } (  X  -closure). The powerset of all states is defined as aunion P ( Q )= q  X  Q P ( { q } ) .
 Example 3 (NFA- X  ). In Figure 3, we depicted an example of an automaton consisting of nine states Q = { q 0 ,...,q 8 } , an alphabet of nine symbols T = { t 1 ,...,t 8 , X  resented as edges in Figure 3. We further refer to the following examples of Enterprise Service signatures (S1) and (S2) that are accepte d by this automaton using the set of transitions M S 1 and M S 2 . Moreover, Enterprise Service signature (S2) illustrates the need for  X  -moves. (S1) SalesOrderItemScheduleLineChangeRequestConfirmation In q0 (S2) SalesOrderCRMItemSimpleByIDQueryResponse In In this section, we briefly describe the c onstruction of autom ata and an accepting algorithm used to detect concepts for the service annotation. 4.1 Automaton Construction Automata, as defined in the previous s ection (cf. Def. 3), are generated from a set of rules that represent naming conventions. As referred to in Section 2.1, these rules consist of the following two parts. Firstly, there are non-terminal and terminal elements, e.g., &lt;BO&gt; and SalesOrder respectively, representing condi-tions for automata transitions as shown in (N1) -(N3) in Section 2.1. Each rule is transformed into a regular expression, which is abstractly defined using termi-nological terms t  X  T ,e.g. /&lt;BO&gt;/ . Subsequently we replace the terminological concepts with the respective set of factual concepts f  X  F from the knowledge base  X  for instance /&lt;BO&gt;/  X  /(SalesOrder|PurchaseOrder|...)/ .
Secondly, concatenation instructions define the automaton X  X  structure as shown in (B1) in Section 2.1. These instru ctions specify the actual states. For each of these states, we assign potential input transitions, from the just created transition set, that need to be satisfied to enter this state. Furthermore, these rules define the states that are subsequently reachable.

Based on these constructed automata, Enterprise Service signatures are re-ceived as input to start the annotation procedure as described hereinafter. 4.2 Annotation Procedure The actual annotation of Enterprise Services is realized by Algorithm 1, which accepts Enterprise Service signature s by detecting used concept. This accept-ing algorithm works recursively, starting with state q 0 . Each state checks its incoming state transition, i.e. compares its own regular expression against the input provided. If the input transition is satisfied (line 1), i.e. a valid concept was found, the matched part is stored (line 2) and removed from the beginning of the input and passed on to its subsequent states (line 5). In case of an empty-word transition, obviously the same input is pa ssed on to its subsequent states. When the base case has been reached in form o f an accepting state (line 3), it returns its matched concept to its predecessors ( line 13). For each of its preceding states, a set of matched concepts, i.e. their own p lus previously matched concepts (line 10), is returned to their predecessors and so forth. The choice on what match results are returned depends on the quality of matched concepts. Therefore, the result with the largest number of different concepts covering most of the input is chosen (line 6 and 7). Eventually, the recursive algorithm terminates, detecting a maximum number of concepts used to annotate Enterprise Services.
 We implemented this algorithm in Java with roughly 2000 lines of code. The knowledge base and generated annotations are stored as RDF triples. The Algorithm 1. Annotate Enterprise Service: annotate ( q, i ) Sesame framework in version 2.3.2 7 has been used for RDF storage, querying, and inferencing. In this section, we evaluate our automated annotation approach using our pro-totypical implementation ( cf. Section 4) based on a set of Enterprise Services. We then analyze the annotation results in terms of completeness , accuracy and correctness , which we define throughout the section. These criteria allow a di-rect evaluation of our annotation approach; a more exhaustive user study will be conducted once we devised a fully-fledged search. 5.1 Evaluation Environment We conducted our evaluation using 1654 Enterprise Service signatures taken from SAP X  X  ARIS Designer from various SAP applications, such as ERP, CRM, etc. These services are from the group of so-called A2X (Application-to-Unknown) ESs, as they have a coherent naming sch eme. Based on our representational model, i.e. terminological concepts and their relationships, we automatically ex-tracted the corresponding instance data, i.e. the factual concepts, from semi-structured sources to populate the service knowledge base. Examples of these sources are Web pages from SAP X  X  Enterprise Service Workplace that provide documentation for each Enterprise Serv ice as well as internal documents (Excel sheets and the like) exported from SAP X  s ARIS platform. To extract and store this information as RDF triples, we developed extractors for each source of infor-mation (i.e. HTML/XML/Excel extracto r). As a next step, we used documents describing naming conventions [21] to define the corresponding automaton as described in Definition 3. Finally, we used the 1654 Enterprise Services as the input to the algorithm as described in the previous section. The resulting set of detected concepts has been stored as anno tations in form of RDF triples refer-encing the original Enterpr ise Service. This is the basis of the analysis below. 5.2 Annotation Completeness The annotation completeness represents the number of Enterprise Services that have been partially or fully annotated. For this, we calculated the expected maximal number of annotations for each Enterprise Service operation by taking advantage of their Camel Case notation. We refer to the annotation accuracy as the ratio of actual number of generated annotations compared to the expected number of annotations. To determine the annotation completeness, we only con-sidered Enterprise Services with an accu racy greater than n ull. As a result, we achieved an overall annotation completeness of 1583 out of 1654 Enterprise Ser-vices, which is equivalent to 95.7%. The missing 4.3% stem from Enterprise Service signatures that did not comply with existing naming conventions. 5.3 Annotation Accuracy In this part of the evaluation, we only considered the 1583 fully or partially anno-tated Enterprise Services from above. To determine the accuracy of annotations, we grouped them into categories of 100% to 40% annotation accuracy (using a 10% scale). In terms of annotation accuracy, we refer to the ratio of actual vs. expected annotations from the previous section. We set the lower margin to 40% based on the lowest accuracy of all 1583 annotated Enterprise Services. For that level of accuracy, we only found four Enterprise Services. In fact, less than 1% of Enterprise Services have been annota ted with less than 50% accuracy. On the other hand, the majority of Enterprise Services, i.e. 73.0%, have been fully anno-tated as illustrated in Figure 4. For an annotation accuracy of 80% or more, the percentage of annotated Ent erprise Services increase s to 91.4%. The whole pro-cedure on the entire data set took less t han5minutesonanIntel(R)Core(TM)2 Duo Processor T7300 machine @ 2GHz CPU and 3GB of RAM. These numbers lead to two observations: (i) the naming conventions were largely followed in the tested sample of ESs, and (ii) our approach delivered an effective annotation. 5.4 Annotation Correctness To the best of our knowledge, there is no obvious solution to automatically validate the correctness of any generated annotation; the baseline therefore is manual verification. Therefore, we first selected a 10% sample of the completely annotated Enterprise Servi ces to evaluate their correct ness. Half of these services were strategically selected by a domain expert to cover various applications as well as a variety of design concepts and naming conventions. The other half was randomly selected to avoid any biased d ecision regarding the selection of con-cepts. In a second step, an independent expert in SOA Governance has been briefed on the workings of the service annotation approach. He then manually performed the annotation based on the technical names of these 10% sample Enterprise Services. In a final step, the expert X  X  manual annotations have been analyzed and compared to the automatically generated annotations by one of our developers. As a result, we confirmed that approximately 94% of automated annotations match the manual annotations in terms of number of annotations and annotated concepts. We further investigated the 6% range of annotation mismatches, which we separated into two categories: governance violation and missing record. The former ca tegory describes Enterprise Services that, for what-ever reason, did not fully comply with the SOA Governance design methodology. The latter denotes that the specific con cept is missing in the service knowledge base and has been wrongly annotated as a different concept. While mismatches resulting from governance violations are out of our control, mismatches stem-ming from missing records can be fixed by extending the knowledge base. Either way, we believe that mismatches of less than 6% can be considered acceptable. Before we examine related work on proposed annotation techniques, we first outline some fundamental approaches that have been proposed to add addi-tional knowledge (metadata) to the technical description of services, e.g WSDL. For instance, linguistic approaches using clustering techniques  X  as done in the Woogle search engine [8]  X  aim to derive meaningful concepts from the techni-cal description of Web Services using W SDL. Although it effectively improves the search, the approach lacks certainty about generated concepts making an automatic solution less feasible. In contrast, semantic approaches [4,25,23,26,1,18] are based on an explicit modeling of ontologies which capture a specific domain knowledge in a generic way using concepts that are commonly agreed and under-stood [9]. As a consequence, machines b ecome more able to interpret data and documents that are annotated with concepts from ontologies requiring less or no human intervention. In general, resear ch communities distinguish between two types of metadata, i.e. ontological concepts and annotations encoding references to concepts.

In terms of ontological concepts, we d escribed what can be seen as a rather closed ontology derived from a given methodology. Such an ontology can be considered nearly co mplete with respect to the universe of discussion. However, we did not focus on the semi-automatic creation of ontologies [15,6,12] such as generating ontologies from natural language text or automatic reuse of existing ontologies, e.g. based on the context of a document [22]. In fact, reusing public ontologies, e.g. TAP [7] or others, are less applicable in context of our work as design methodologies in an enterprise context rather describe proprietary concepts (e.g. data model ) that cannot be necessarily expressed with public or community-contributed [24] ontologies.

In terms of annotations, existing approaches can be first categorized into degrees of automation, i.e. fully-automated, semi-automated [9,15] or manual [14,19]. Second, the annotation level of detail depends on the type of represen-tation ranging from e.g. entire service descriptions, operation or input/ouptut parameters, non-functional requirements etc. Third, annotations can be used for different fields of applications, e.g. human or automatic service discovery [17], invocation, composition [22] etc. In this work, we proposed a fully-automated approach to annotate a large set of Enterprise Services based on their signa-tures, i.e. interface and operation names. Ultimately, we currently see the main purpose of the service annotation approach in improving the service discovery specifically for business users and non-professional developers. In this context, using automata can more precisely resolve disambiguities by determining correct concepts based on their expected positi on within the respective signature. As a result, we can increase th e accuracy of generated annotations compared to other approaches, e.g. using similarity functions [7] (SemTag), natural phrase process-ing [9] (via SMES) or detecting association of concepts by confidence level [15]. Note, this is particularly feasible as we only focus on a small portion of explicitly defined text, i.e. Enterprise Service signatures, rather than a large body of text, i.e. Web pages.

For reasons of simplicity, we used RDF(/S) over OWL-S or WSMO to store our ontology and annotations. We consider RDF(/S) sufficient for our purpose to represent additional knowledge as we do not require sophisticated logical reasoning. The results of the annotation could, e.g., be stored in SAWSDL [25,23] format, where annotations are directly added to WSDL. However, at this point we are not entitled to change Enterprise Service descriptions, and decided to keep annotations independent from any specific Web Service standard.
 In this paper we presented an approach for the automatic annotation of Enter-prise Services, based on a SOA Governan ce design methodology. We described a concrete methodology used at SAP, but presented a generic and formal model for capturing the structure of SOA Governance design methodologies. The model consists of terminological concepts and factual concepts, and automata for cap-turing naming conventions built from th ese concepts. Naming rules are specified using a (typically very small) set of terminological concepts; from those we con-struct a consolidated automaton and populate it with the respective factual concepts. Using the detailed automaton, we can automatically annotate service names that (at least partially) adhere to the naming conventions.
 We evaluated the work on a set of more than 1500 Enterprise Services from SAP, and obtained highly encouraging results: more than 90% of the services could be annotated with more than 80% correctness. This was largely verified in a small experiment with an independent expert. We observed that some of the mismatches came from ESs that did not adhere to naming conventions. As such, our approach can also be used to check adherence to naming conventions, and thus, improve the management of SOA Governance. In terms of the annotation procedure, this is an one-off operatio n that only needs to be executed when the concepts or the service na mes change. All the above services were annotated in a matter of minutes. Hence, perfor mance is unlikely to be a problem.
In an earlier instance of this work [20], we used a strongly simplified model, yielding significantly lower accuracy: o nly parts of the data model and patterns could be annotated. However, we there also showed how these annotations can be used in discovery of Enterprise Servi ces for business users and developers who are unfamiliar with the set of services. As such, we can use our approach to facilitate an effective search by further reaching out into areas of automatic query extension and query suggestion.

Future work will build on the presented approach as follows. Firstly, we will attempt to evaluate the applicability of the approach on services from other sources; there is, however, a high risk that we might not be able to obtain detailed access to naming rules. Secondly, we will in vestigate improved s earch algorithms and other application scenarios making use of the produced annotations.
