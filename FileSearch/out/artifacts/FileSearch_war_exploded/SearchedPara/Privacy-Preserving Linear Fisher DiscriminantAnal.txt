 Data mining is a powerful tool to discover interesting, useful, and even hidden patterns that has been applied to various domain such as business intelligence, bioinformatics, and homeland security. While conventional data mining assumes that the data miner has full access rights t o data that are collected from different sources or that are distributed among multiple parties, privacy or security issues render this assumption infeasible when the parties cannot be fully trusted, as some parties may have malicious intent. How to collaboratively perform data mining without compromising the data privacy of the participating parties has become an interesting topic of research in the data mining community.
Privacy-preserving data mining (PPDM) is a response from the data mining community to address data privacy issues. Approaches in PPDM are generally based on Secure Multi-party Computations (SMC) [12] and/or randomization techniques [1]. The former uses speciali zed, proven protocols to achieve various types of computation without losing data privacy. The latter introduces noise to the original private data to achieve s ecurity but lose accuracy. As the former approach achieves a higher degree of accuracy, we focus on SMC in this paper. To date, various data mining algorithms have been enhanced to incorporate privacy preservation based on SMC techniques.

In machine learning and data mining, Fisher Discriminant Analysis (FDA) is one of the widely used discriminant algorithms that seeks to find directions so that data in the same classes are projected near to each other while ones in duction. It has wide applications in face recognition [13], speech recognition [11], and digit recognition [2]. In this paper, we enhance Fisher Discriminant Analy-sis to incorporate the privacy-preserving feature. To the best of our knowledge, there has not been any work that extends privacy preservation to FDA.
Our contributions in this paper are summarized as follows: 1. We propose two protocols X  X he Secure Matrix Multiplication protocol and 2. Based on the two secure building blocks, we propose protocol for privacy-We have evaluated the computational complexity and scalability of the pro-posed protocols both analytically and empirically and show that the protocols are efficient and scalable for small to medium size data. We also addressed some specific implementation issues such as me thods to handle real numbers and neg-ative numbers in cryptography. We believe this work is significant as it serves as a guide to the investigation of extending data privacy preservation to re-lated methods such as Principal Component Analysis, Independent Component Analysis, and so on.

The organization of this paper is as follows: In Section 2, we present an overview of background knowledge abo ut linear FDA and related work. Section 3 proposes two secure building blocks of matrix computation. We also present pro-tocols for Privacy-Preserving FDA (PPFDA) over horizontally partitioned data and vertically partitioned data in Sect ion 4. In Section 5, we perform experi-ments to evaluate the proposed secure building blocks and protocols. Finally, Section 6 concludes the paper. 2.1 Linear Fisher Discriminant Analysis Fisher Discriminant Analysis (FDA) as i ntroduced by Fisher [5] seeks to separate different classes as much as possible using some criterion function (Eq. 1). As the technique of applying FDA on a two-class dataset is used repeatedly for the analysis of any pairs of data in a multi-class dataset, we focus on the two-class problem using FDA in this paper. It is non-trivial to extend the two-class problem approach to multi-class problems. This will be part of our future work. This section provides an overview of background knowledge about linear FDA. We present the conventional mathemat ical model of linear FDA for two-class data [4]. Suppose we have a set of two-class n data samples of d dimensions: { x 1 , x of the projection from X to y = { y 1 ,y 2 ,...,y n } ,wehave y = w T X .The d -dimensional sample mean m i for class i is m i = 1 n i n i j =1 x i j .
Fisher Discriminant Analysis aims to maximize between-class separability and minimize within-class variability. Formally, the criterion function in Eq. 1 is to be maximized for the function w T X : where is the within-class scatter matrix .

The objective of FDA is to find a projection vector w such that J ( w )inEq.1 is a maximum. The solution for such w can be obtained by differentiating J ( w ) with respect to w yielding We note that only the direction, not the length of w ,isimportant.

To incorporate the privacy-preserving feature to linear FDA, the challenge is to securely compute S  X  1 W and m 1  X  m 2 so that w can be securely computed. Clearly, what we need is a method to perform matrix multiplication and ma-trix inverse securely. In Section 4, we p ropose a secure approach to address the problem. 2.2 Secure Building Blocks Various data mining algorithms have been enhanced to incorporate privacy preservation, including classification using decision tree [12], association rule mining [16], clustering using k -means [10], and so on. Recently, the approach has been extended to several machine learn ing algorithms such as linear regres-sion [3], gradient descent methods [17], self-organizing maps [8], and genetic algorithms [7]. Many of these privacy-enabled algorithms rely on secure building blocks to enforce privacy. Secure building blocks are basic common operations that underly many algorithms. Examples include secure sum, secure comparison, secure scalar product, secure matrix multiplication, and so on.

Fisher Discriminant Analysis X  X he fo cus of this paper X  X equires two secure building blocks: Secure matrix multiplication and secure inverse of matrix sum. Du et al. [3] has proposed a secure protocol for secure matrix multiplication using linear algebraic methods. It uses a random and invertible matrix to disguise the original matrices to achieve priva cy. For security, a concept called  X  k -secure X  was introduced to generate the random matrix. Assuming that Party B wants to attack private matrix A of Party A, a k -secure matrix M (jointly generated by both parties) means that (1) any equation from MA includes at least k +1 unknown elements of A ,and(2)any k combined equations include at least 2 k unknown elements of A . Therefore, it is impossible to know any elements of matrix A as there are infinite possible solutions due to insufficient equations.
An issue with Du X  X  approach is that constructing such a matrix is a complex process [3]. More importantly, Du X  X  approach may have a security problem. If Party A and the same Party B or different Party Bs (a group of colluding parties) perform secure matrix multiplication more than once, more M s(moreequations) are available for attacking the fixed unknown elements matrix A .Inresponseto this problem, we propose another more secure and efficient protocol for matrix multiplication in this paper. In this section, we propose the Secure Matrix Multiplication protocol and Secure Inverse of Matrix Sum protocol to support the secure computation of Eq. 3, which we have identified to be the key to in corporating privacy preservation in FDA. Our proposed protocols are based on cryptographic techniques and are improvements over existing protocols [3] for secure matrix multiplication and inverse of matrix sum. 3.1 Secure Matrix Multiplication Parties A and B each hold private d  X  N matrix A and private N  X  n matrix B respectively. They want to securely com pute matrix multiplication so that at the end of the computation, party A and B each only holds a portion of the product matrix M a and M b respectively such that their matrix sum M a + M b = AB is the desired product matrix, which is unknown to both parties.

Given any m  X  n matrix H ,its i th row vector h ( i, :) = ( h i, 1 ,h i, 2 ,...,h i,n ) and j th column vector h (: ,j )=( h 1 ,j ,h 2 ,i ,...,h m,j ). By definition of matrix multiplication M = AB ,wehave Clearly, each element of M above is a scalar product of two vectors. To securely perform the matrix multiplication AB , we may apply the Secure Scalar Product Protocol 1. Secure Matrix Multiplication Protocol protocol [6] so that each scalar product is the sum of two portions as follows: In this way, we securely obtain the matrix multiplication (which is unknown to both parties) as the sum of two private portions M a and M b held by Party A and B respectively. The details are shown in Protocol 1.

This method is more straightforward and less complex than the secure matrix multiplication protocol by Du et al. [3]. Moreover, the execution of secure scalar product of each matrix element can be per formed concurrently to increase effi-ciency. In Section 5, we show that the approach is efficient for computing the product of two small and medium size matrices. 3.2 Secure Inver se of Matrix Sum Party A and B each hold a private d  X  d matrix A and B respectively. They want to securely compute the inverse of A + B . At the end of the secure computation, Party A and B each only holds a portion of the inverse matrix M a and M b respectively such that their sum M a + M b =( A + B )  X  1 ; the inverse matrix is not known to both parties.

The steps to securely perform the inverse of matrix sum by two parties are shown in Protocol 2. In Steps 1 to 3, Party B uses a random, non-singular matrix P to hide its private matrix B before sending it to Party A. In Steps 4 and 5, both both parties securely compute the inverse of ( A + B ) P and then the product P ( P  X  1 ( A + B )  X  1 ), essentially eliminating the random matrix P in the process. This yields the desired result ( A + B )  X  1 in the form of two private portions M a and M b held by each party respectively.

In the case when the sum matrix A + B is singular, a simple perturbation can be introduced to the sum matrix to make it non-singular. For instance, the Protocol 2. Secure Inverse of Matrix Sum Protocol perturbation method proposed by Hong and Yang [9] can be used to stabilize A + B by adding a small perturbation matrix to A or B .
 In contrast to the secure inverse of matrix sum protocol by Du et al. [3], Protocol 2 is more efficient and accurate as it uses only one random matrix P instead of two matrices in Du X  X  protocol. Clearly, less (one random matrix less) algebraic operations yields more accurate computations results as less errors are introduced due to roundoff errors. 4.1 PPFDA over Horizontally Partitioned Data In this scenario, we have n data samples of d dimensions held by two parties. Let Party A hold the first n 1 data samples and Party B hold the remaining n 2 data samples; n = n 1 + n 2 .

In Protocol 3, we show how m 1  X  m 2 and S  X  1 W can be securely computed so as to yield w in a secure manner. In addition to using Protocols 1 and 2, we also make use of the random shares technique by Jagannathan and Wright [10]. In this technique, all numerical intermediate results are splitted into two random portions where each party holds one portion so that neither party is able to speculate anything about the intermediate results using only its private portion. In Step 1, we show how m 1  X  m 2 can be splitted into two random portions. As Party A holds n a data samples (with n a i data samples of class i )andPartyB vector of class i as computed by Party A using only its private data samples is m i . Likewise, the mean vector of class i i computed by Party B using its private data samples is m b i . Hence, we have Protocol 3. PPFDA over Horizontally Partitioned Data (Eq. 2). The secure manner to compute S W is to obtain two portion matrices S
W and S using the two for loops as shown in the protocol.

In Step 5, if x i j belongs to Party A, then we have performed if x i j belongs to Party B.

Step 10 shows the secure manner to split the resultant product matrix of two vectors ( u a + u b )( u a + u b ) T into two portions such that The element m i,j of matrix M is computed as follows: After securely computing the scalar pr oduct of vectors in Eq. 5, each element of matrix M is splitted into two portions. Hence, the matrix M is splitted into two private matrices. Overall, S W is securely splitted into two private portions S
W and S
Using Protocol 2, ( S W )  X  1 = S a W + S b W and S b such that ( S W )  X  1 = S a + S b . Therefore Using Protocol 1, we securely compute S a t b and S b t a .Thus,weareableto securely compute w .
 Analysis: Two parities are assumed to be semi-honest who strictly follow the protocol but collect all intermediate results during the execution of protocols to attack the private data of honest parties. As we observe, Protocol 3 applies two main secure building blocks: Secure Matrix Multiplication protocol and Secure Inverse of Matrix Sum protocol. Both protocols depend on the Secure Scalar Product protocol that is provably secure [6]. Based on random share technique, we actually split all the intermediate results into two random shares (portions) except the final w in Protocol 3. The private variables of one party are protected by the equivalent numbers of random portions known by itself only. Therefore we claim data privacy of honest parties are preserved.

We derive computational complexity of Protocol 3 here. As in Steps 3 to 13, the Secure Scalar Product protocol is invoked once to compute the scalar product of two vectors (2  X  1) (in Eq. 5), then one element of matrix M ( d  X  d ) is securely split. As we know, there are n 1 + n 2 = n data. Therefore, the Secure Scalar Product protocol is invoked n  X  d 2 times in Steps 3 to 13 for computing the scalar product of two vectors (2  X  1).

In Step 14, the Secure Inverse of Matrix Sum protocol is invoked once for tion protocol twice (Step 2 and 5 in Protocol 2). In Step 14, the Secure Matrix Multiplication protocol is invoked twice for splitting items S a t b ( d  X  1) and S t a ( d  X  1) securely. In the Secure Matrix Multiplication protocol, it requires to perform the Secure Scalar Product protocol once to split one element of the desired matrix. The overall number of invoking Secure Scalar Product protocol in Step 14 and 15 is (2 d 2 +2 d ) for computing the scalar product of two vectors ( d  X  1).

Therefore, the overall com putational complexity is O ( nd 2 + d 3 ) as the compu-tational complexity of the Secure Scalar Product protocol is O (  X  ) for two vectors of length  X  [6].

The communication of Protocol 3 between two parties mainly comes from depends on Secure Scalar Product protocol invoked in the protocol. Based on the analysis above, the the communication complexity of Protocol 3 depends on the overall number of the Secure Scalar Product protocol invoked, which is O ( nd 2 + d 3 ) as the communication complexity of the Secure Scalar Product protocol is O (  X  ) for two vectors of length  X  [6].

In Section 5, we experimentally evaluate the efficiency and scalability of the secure building blocks. 4.2 PPFDA over Vertically Partitioned Data In this scenario, d dimensions of data are distributed between two parties. Party Aholds d 1 dimensions and Party B holds d 2 dimensions; d = d 1 + d 2 .Weshow how w can be securely computed in such a scenario.

In vertically partitioned data, we assume the first d 1 dimensions of data sample show that Party A and Party B may extend their vertical data partitions with empty dimensions so that both parties have d dimensional partitions. In this way, the problem of vertically partitioned data is transformed to a horizontally partitioned problem so that the method in Section 4.1 can be applied to securely compute w .
 The transformation is as follows: For each d 1 dimension data sample x a of Party A, additional d 2 zeroes can be appended so that the data sample has d dimension: Likewise, data samples of Party B can be prepended with d 1 zeroes to become d dimensional: After the transformation, we have a total of 2 n data samples of d dimensions rather than n data samples of d 1 held by Party A and n data samples of d 2 held by Party B.
 In this section, we discuss the implementation issues and evaluate the perfor-mance of the proposed protocols. All protocols were implemented in the C# language running under Microsoft Visual Studio 2005 environment. All experi-ments are performed on the Window XP operating system with 3.40GHz CPU and 1GB memory. As network performance mainly depends on the network speed and physical distance of two parties, we simply implemented parties as threads that exchange data directly by shared memory.
 The dataset used is the Iris Plants Database from the UCI Machine Learning Depository. There are 150 data samples in three classes:  X  X ris Setosa X ,  X  X ris Versicolour X , and  X  X ris Virginica X  . As the latter two classes are not linearly separable, we select them as our analysi s data. There are 4 numeric predictive attributes:  X  X epal length X ,  X  X epal width X ,  X  X etal length X , and  X  X etal width X .
The Paillier cryptosystem [14] was selected as our choice in the implementa-tion. As the Paillier cryptosystem only encrypts non-negative integers, we have to deal with issues when real numbers and negative numbers occur. For real numbers, two parties multiply some large constants (e.g., 1000) to transform the real numbers to integers. We remov e the effects of the constants by divid-ing the (intermediate) results by the constants. For negative numbers, the basic property of congruence a + kn = a mod n is applied to transform negative integer a to positive integers by adding multiples of n . Accuracy: To show the accuracy of performing FDA with privacy preservation using Protocol 3, we evaluated horizontally partitioned data where data instances of data set are uniformly distributed between two parties. The first figure in Fig. 1 was obtained by performing FDA using MATLAB. The second figure was obtained by Protocol 3. We clearly obs erve that accuracy is not reduced when we preserve the data privacy of the participant parties.
 Scalability: We investigate the scalability of the two protocols proposed in this paper. For the Secure Matrix Multiplication protocol, we observe that the bulk of its operations are secure scalar products. Hence, we evaluated the scalability of the Secure Scalar Product protocol as shown in the first figure in Fig. 2. The running time is linear to the length of vectors as expected. Some random numbers in our implementation were generated offline. The time for two vectors of length 100,000 was estimated at 41 seconds, which is sufficiently low for small and medium data sets. The second figur e in Fig. 2 shows the efficiency of the Secure Inverse of Matrix Sum protocol. We observe that the time to execute the protocol for more than 10  X  10 dimensions matrices becomes impractical. From Table 1, it is shown that the matrix inverse algorithm we used is time consuming due to the computation of matrix inverse and not due to overhead of the Secure Matrix Multiplication protocol. In our experiment, we use adjoint method [15] to perform matrix inverse as follows: A  X  1 =(1 / det) A (adjoint of A )whichis very computationally slow, comparing with other methods, such as Gauss-Jordan elimination and LU decomposition.

In these experiments, we only evaluated privacy-preserving FDA over horizon-tally partitioned data for low dimension (4  X  4). To apply the proposed protocol to higher dimension data would be part of our future work. In this paper, we have proposed the privacy-preserving version of Fisher Dis-criminant Analysis over horizontally and vertically partitioned data. We have also proposed two basic secure building blocks for matrix computation: the Se-cure Matrix Multiplication protocol and Secure Inverse of Matrix Sum proto-col. Finally, we have conducted experiments to demonstrate the scalability of the proposed secure building blocks and overheads to achieve the privacy when performing FDA. Our future work includes applying the proposed protocol to high-dimensional data and extending the proposed protocols to multiple parties.
