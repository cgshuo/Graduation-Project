 We address the problem of retrieving chess game positions similar to a given query position from a collection of archived chess games. We investigate this problem from an informa-tion retrieval (IR) perspective. The advantage of our pro-posed IR-based approach is that it allows using the standard inverted organization of stored chess positions, leading to an efficient retrieval. Moreover, in contrast to retrieving exactly identical board positions, the IR-based approach is able to provide approximate search functionality. In order to define the similarity between two chess board positions, we encode each game state with a textual representation. This textual encoding is designed to represent the position, reachability and the connectivity between chess pieces. Due to the ab-sence of a standard IR dataset that can be used for this search task, a new evaluation benchmark dataset was con-structed comprising of documents (chess positions) from a freely available chess game archive. Experiments conducted on this dataset demonstrate that our proposed method of similarity computation, which takes into account a combina-tion of the mobility and the connectivities between the chess pieces, performs well on the search task, achieving MAP and nDCG values of 0 . 4233 and 0 . 6922 respectively.
 H.3.1 [ INFORMATION STORAGE AND RETRIE-VAL ]: Content Analysis and Indexing X  Abstracting meth-ods Query by Example, Similar Chess Positions
It is beneficial for a chess player during a live game to know whether previously archived chess games lead to po-sitions approximately similar to the position considered at present. A knowledge about the successive moves from these (a) Karjakin vs. Nakamura, position after move 20. Figure 1: Two similar (not identical) chess positions. retrieved games can then be used to devise a winning or a game saving strategy in general, and even decide a sequence of the next best moves in particular. Kotov, the Soviet chess grand master, opines that if one can recall similar positions from earlier games, then it is  X  X asier to reach an assessment of how things stand, and to hit upon the correct plan or analyze variations X  [8].

Existing chess search systems equipped with a query-by-example (QBE) [19] search interface are limited to search only the exact matches in response to a given query position. However, the strict requirement of an exact match may fail to retrieve any matching board position This is because it is highly unlikely for a position in the middle or end stages of a game to exactly match another position from a previously played game due to the massive combinatorial state space of a chess game (the number of possible board positions in a chess game has been estimated to be 10 43 [16]).

To illustrate with an example, let us take the board posi-tion arising after the 20 th move in a game between Karjakin vs. Nakamura as a sample input query shown in Figure 1a. The online search interface 365Chess 2 performs a known-item search by retrieving this very position from this game itself. It however fails to retrieve a very similar position as shown in Figure 1b occurring in a different game. In addition to the obvious visual similarity with regard to the position of the chess pieces, one can also notice a few other thematic or structural similarities, e.g. the black bishop plays an impor-tant defensive role on black X  X  kingside, and that the white
Section 3 briefly reviews chess notations and terminologies. http://www.365chess.com/search position.php queen has limited reachability on the opponent X  X  half due to the presence of two centrally located pawns etc. An inter-esting observation is that both games resulted in a win for white. This example clearly shows that the strategy adopted by white in the subsequent course of one of the games might have been used to devise a similar strategy in the other.
The underlying approach of a QBE chess position exact search system primarily involves storing each position of ev-ery game in a hash organized file. Retrieval is then simply a computation of the hash function of the query board po-sition and returning the board positions from the collection which hash to the same value as the query. The hash func-tion mostly used is the Zobrist hashing [20]. While this approach is highly efficient and scalable for very large game collections, the major disadvantage is that it does not allow provision for approximate search, the importance of which has already been discussed (c.f. Figure 1). The search sys-tem CQL 3 (Chess Query Language) alleviates this problem of exact item search by allowing for approximate matches with the help of wild-card queries [4]. However, there are three important limitations in CQL, as follows. Firstly, in CQL a user has to meticulously formulate the query text in a complex query language for a given board position. Sec-ondly, in order to allow for more relaxed matches, instead of using a simple hash-based lookup, CQL employs a position filter constructed from the query to each position of every game in the collection and reports the ones which evaluate to true when applied to this query position filter. For ex-ample, the CQL query  X (position [RQ]b2 bg8) X  matches any position with a white rook or a white queen on b 2 and a black bishop on g 8. For reporting the results against this query, CQL checks if there is a white rook or a white queen on the square b 2 and a black bishop on the square g 8 and reports the ones which satisfy this constraint. This imple-mentation of the matching phase in CQL leads to a slow runtime even for moderate sized game databases. The third limitation of CQL is that it suffers from the classical prob-lem of Boolean retrieval, i.e. it has no way of ranking the search results because it applies a Boolean filter instead of computing a similarity score. The order in which relevant game positions are presented to the searcher can save a con-siderable amount of time in the analysis of the current query position. Returning to our example query of Figure 1a (re-produced in Figure 2a), the position shown in Figure 2b, in spite of being visually quite similar to the query, may not quite provide useful insights into the analysis of the current game position. This can be seen from a few contrasting ob-servations such as: i) the strategy for white in Figure 2b would be to develop attack along the centre of the board because the king is not castled and stays in the e 8 square, whereas the most rewarding line of attack for white in the query position would be along the kingside; and ii) the white queen has more mobility along the f file in comparison to the white queen of the query position.

To alleviate the above limitations of existing chess posi-tion search systems, this paper approaches the problem from an IR perspective, which can, in theory, overcome the prob-lems of the existing approaches. This is because a standard IR-based approach a) is not limited to identical match find-ing such as in the 365Chess interface; b) uses a standard inverted list file structure to efficiently constitute a list of http://www.rbnn.com/cql/ (a) Karjakin vs. Nakamura, after move 20. Figure 2: An example of a chess position which may not be relevant to the analysis of the query position. candidate documents for retrieval in contrast to the sequen-tial approach of CQL; and c) involves the computation of a similarity score between the documents in the collection and the query so that the documents in the retrieved list can be ranked unlike an arbitrarily ordered list of results returned by CQL. The problem however cannot simply be solved di-rectly using an off-the-shelf IR system as a black-box.
The critical questions in this case are: i) How can a chess board position be encoded as a string the constituent terms of which can be indexed by a standard text-based IR sys-tem? ii) How can the structural relationship between the chess pieces be represented in the index, and how can the similarity computation function make use of this during the retrieval, e.g. with reference to the query position shown in Figure 1a, how can the fact that the restricted mobility of the white queen due to the presence of the white pawns at e 4 and f 4, be utilized to predict that the position (in Figure) 1b is more relevant to the query than the position 2b?
In the subsequent sections of this paper, we describe how these questions are addressed towards developing an IR-based chess position retrieval system. The rest of the pa-per is organized as follows. Section 2 surveys previous work related to this research. In Section 3, we provide a short in-troduction to the chess terminologies and notations relevant for reading the rest of the paper. Section 4 formally defines the chess position search problem. Section 5 discusses vari-ous approaches towards encoding a chess board position as a text string so that the similarity between two chess board positions can be computed with the help of a standard IR model. This is followed by Section 6 which describes the complete algorithm for the search problem. Section 7 de-scribes the experiments conducted to evaluate our proposed approach. Finally, Section 8 concludes the paper by sum-marizing the observations and providing directions for future research and generalizing this approach for other domains.
Due to the novelty of the search task itself, the authors, to the best of their knowledge, are not aware of any pre-vious IR-based approach towards solving the chess position search problem. The search problem, however, is closely related to the problem of retrieving approximately match-ing entities (typically non-text) from a collection, given a query entity (typically also non-text) as an example. Exam-ples of this class of search tasks include content-based image search [18], mathematical equations search [7], searching for the least edit distance reference sentence for example-based machine translation (EBMT) [10], etc. These search tasks differ widely from standard text search in the following ways. Firstly, in contrast to key-word type queries used in ad-hoc IR, these search problems often use the QBE paradigm [19] to avoid the user inconvenience of manual query formulation. As a result of this the queries themselves are comparable in size to the documents in the collection. Secondly, since the queries and the documents are comparable in size, the simi-larity measure often used in these search tasks is that of the edit distance (inverse similarity), i.e. the minimum number of operations needed to transform a document to the query and vice-versa. For example, the similarity between two mathematical expressions can be computed by the inverse of the edit distance between their parse tree structures [7]. The edit distance metric can, in principle, be applied to the chess position search problem as well, where the distance (inverse similarity) between two positions could be com-puted by the number of operations required to transform one board position to another. However, the edit distance based approach, although effective in practice, may lead to inefficient retrieval because the edit distance values cannot be computed by utilizing the standard inverted list indexing framework. Consequently, the main disadvantage of the edit distance method is the inefficiency involved in computing the edit distance values between each document in the collection and the given query [7]. A solution which overcomes this in-efficiency was proposed in [10]. Instead of computing the true edit distances this method approximates the relative ordering of documents by edit distance values with the help of an IR-based approach. In the context of mathematical equation retrieval, [12] proposed a text-based encoding of mathematical expressions to the accomplish search task by a standard inverted index based IR approach, which is more efficient compared to computing edit distances between each mathematical expression in the collection and the query. We propose a similar textual encoding for representing the chess board positions so that the board pos they can be indexed and retrieved under the framework of a standard text re-trieval system.

In relation to the chess game playing research, we find the following relevant to our work in this paper. De Sa [15] applies logistic regression to predict the likelihood of a win from a given board position. Cognitive aspects of  X  X imilar-ity X  between two chess positions have been reported in [17]. Automatic chess playing programs select the next best move by selecting the best branch in the game tree generated from the present board state [2]. The evaluation function of a board state is estimated by making use of the mobility of and the connectivity between the chess pieces [2], which we also use in our work to compute the similarity between two chess positions.
This section provides a brief introduction to the chess spe-cific terminologies such as the algebraic notation and the most widely used file formats for storing chess games.
Chess Algebraic Notation . Chess is a two player game played on a 8x8 board. Each square of the chess board can thus be represented by a coordinate pair. The standard al-gebraic notation (SAN) prescribes the use of a letter and a number for this. The columns from white X  X  left are num-bered from a to h, whereas the rows are marked from 1 to 8 bottom-up. The coordinate of the bottom left square (the origin in this coordinate system) is thus a1. For example, the white king of Figure 2a is placed at the square c 1.
PGN Notation . The PGN (Portable Game Notation) [5] format is used to encode the moves of a chess game. The string encoding of a move comprises of the piece name being moved (in case of a pawn the piece name is empty) and the coordinate of the destination square of the move. Taking an opponent piece as a part of the move is represented with an additional character  X  X  X  before the destination square coor-dinate. For example, the next three moves from the position depicted in Figure 2a are  X 20... Bxc3 21. bxc3 Qf6 X , which implies black takes the knight on the c 3 square with his bishop, following which white takes black X  X  bishop with his pawn after which black moves his queen to the f 6 square. In our work, we use the PGN encoded move sequences of a game to compute and store the textual encoding of each intermediate board position matrix in an index.

FEN Notation . In contrast to the PGN notation (which encodes a move), the FEN (Forsyth-Edwards Notation) no-tation encodes a particular position encountered during a chess game. A FEN string can be decoded into a board po-sition matrix. In our search system, a user can specify a query with the help of a FEN encoded string.
In this section, we define the chess position retrieval prob-lem as an ad-hoc search problem. The task of the chess search problem is to retrieve a list of chess positions most similar to a given query position. The intention is to use the associated information from similar positions in the analysis of the current game position.

The underlying scenario of this search problem is some-what analogous to the content-based image retrieval (CBIR) problem, where the intention is to retrieve the top-most sim-ilar images, given a query image [18]. Conceptually speak-ing, the chess position search problem can be visualized as a CBIR problem, in which the intention is to retrieve a ranked list of snapshot images of chess positions ordered by decreas-ing values of similarities with respect to the query snapshot image. However, one important aspect in which the chess position search differs from other standard search tasks is due to the presence of an additional constraint that it is de-sirable to retrieve only a single board position (the one which best matches the query) from each game, instead of retriev-ing more than one position from a single game. The search objective in this case is somewhat analogous to detecting the best entry point (the best matching chess position) from which a user should start reading a document (a chess game) so as to satisfy his information need [13].

It is reasonable to apply this additional constraint for the chess position search because sets of consecutive positions in the same game tend to be more similar to each other than to other positions in different games. Consequently, retrieving this whole set of consecutive positions from a single game does not allow similar positions from other games to be re-trieved at top ranks. According to the objective of the search task, it is desirable to retrieve a single best matching posi-tion from each unique game, so that the current game can then be analyzed by extracting information from the sub-sequent moves following the best matching position of this game. Each retrievable unit in this case thus has to be asso-ciated with a parent element, that is the game in which this position has occurred, and the system must ensure that the parent of each retrieved position is unique. We now define the chess position search problem formally as follows.
Given a chess game collection of N chess games, where each game g i = { g i 1 , . . . , g i m i } , i = 1 . . . N (each game g list of m i positions), a query chess position q from a game Q , and a similarity function sim ( p 1 , p 2 ) denoting the similarity between two chess positions p 1 and p 2 , return a list of chess positions L = 1. g k 6 = g k 0  X  k, k 0  X  { 1 , .., K } , i.e. all games are distinct 2. sim ( g i j , q )  X  sim ( g i j 0 , q )  X  j 0  X  { 1 , .., m
The crucial part in the problem definition is designing a suitable similarity function sim ( p 1 , p 2 ), which should be able to determine how similar two chess positions p 1 and p 2 are to each other. For computing this similarity, one needs to encode a chess position as a feature vector so that the similarity between these vectors can be computed by the standard dot product. The features themselves need to be carefully chosen so as to represent the key factors in a game position, such as the position, mobility and connectivity of the pieces [2].
This section addresses the problem of encoding chess board positions. We first start with a naive feature encoding ap-proach and then progressively work towards enhancing it with more contextual information.
A very simple and naive approach of encoding a chess board state is through a feature vector f  X  { 0 , 1 } a Boolean vector of 64 (8  X  8) dimensions where f i if the square is empty or 1, if it is occupied. We adapt the convention that the component f 1 corresponds to the top left square, i.e. a 8 whereas the component f 64 sponds to the square h 1. Under such an encoding scheme, the chess board of Figure 3a (reproduced from Figure 1a) is { 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , . . . } .
This method does not take into account the type or the colour of the pieces. It is easy to see that the dot product would falsely lead to a very large number of high similarity values based only on the occupancy factor of the squares. For example, a rook at the c 8 square of the position in Figure 3a may match with a knight at c 8 in another board position. An easy solution is to use a higher number of dimensions to correspond to the piece type and colour. Since there are a total of 6 piece types and 2 colours, f can be represented as a vector of 64  X  12 dimensions, where the i th component is 1 if the square corresponding to the component is occupied by a piece of the type and the colour which the component corresponds to [15].

This notation of the feature vectors is very inconvenient to use in practice. Adopting the IR convention from now on, we can think of each dimension as a term representing a (a) Karjakin vs. Nakamura, after move 20. Figure 3: An example to illustrate the limitation of exact matching inherent in naive encoding. particular piece of a specific colour in a specific location. For example, the two terms N c 3 and bg 7 indicate the presence of a white knight at c 3 and a black bishop at g 7, where we use uppercase characters for the white and lowercase ones for the black, respectively. A chess board feature vector can thus be represented as a document with constituent terms. An advantage of the textual representation is that chess board positions can simply be thought of as text documents and hence standard IR similarity measures, such as cosine or BM25 [14], can directly be applied on the board positions as well. The constituent terms of the textual representation of the board position of Figure 3a is represented as follows.
The problem with the naive encoding is that it does not allow for an approximate match by a relaxation of the piece positions, e.g. Figure 3b shows an artificially created board position with a positional transformation on a majority of the pieces. By positional transformation , we mean shifting a piece to another square according to the rules of the game. For example, the white queen has been moved from f 3 to e 2, which is a valid move. It can be seen clearly that the similarity value between the textual representation of the board positions will be considerably lower because of a large number of term mis-matches. However, this artificially con-structed board position, if it had occurred in a real game, would have potentially acted as a relevant board position with the capability of providing valuable insights into the current game analysis. This is because even if the pieces have been transformed, the structural relationship between the pieces remains very similar, e.g. the mobility of the white queen is still restricted, the black bishop is still a threat on the white kingside and so on.

We now describe additional pieces of information to repre-sent the structural relationship between the pieces of a chess board, namely the set of squares reachable by a piece and the set of pieces being attacked and defended by a piece.
Informally speaking, every chess piece has got its own  X  X c-tive zone X  which is the set of squares reachable from the current position of the piece. The role played by the piece during the game is largely restricted to this zone. For exam-ple, the set of squares reachable by the white rook on d 1 is { d 2 , d 3 , d 4 , d 5 } . The idea is analogous to  X  X ropagating X  the influence of a term to adjacent positions in a document by a proximity-based kernel density function, which is maximum at the current position and decreases gradually with increas-ing distances from the current position [11]. In the case of a document, the position of a term refers to the offset (mea-sured in terms of the number of words) from the starting word of the document. For example, Figure 4a shows that the weight function of a term is maximum at its true posi-tion (which in this example is the Gaussian curve centred at offset 3). The weights with which the term contributes in the rest of the document progressively decrease on both sides of its true position.

In our case, we apply a similar approach with some nec-essary modifications. In standard positional-based term in-dexing, a term can (in theory) exist at all positions with progressively decreasing weights. In the case of chess search, the term (which is equivalent to a chess piece) can only exist in one of the set of squares reachable from its current posi-tion. Assuming the bottom left corner square is (1 , 1) and the top right corner is (8 , 8), let us formally define the set of squares reachable by a piece p from its current position ( x, y )  X  X  1 , 8 } 2 as follows. r -closure ( p, x, y ) = { ( x, y ) } X  X  ( x 0 , y 0 ) : ( p, x, y ) | = ( p, x, y ) | = R ( p, x 0 , y 0 ) denotes that the piece p can be placed from the square ( x, y ) to the empty square ( x 0 , y 0 ) move according to the rules of the game. Thus, while a positional-based text indexing approach [11] considers all integer offset positions of a term, we simply need to restrict the positions to the set r  X  closure as defined in Equation 1.
Figure 4b illustrates the r -closure for the white queen present at the square f 3 of the chess board of Figure 3a. The figure highlights the set of reachable squares for the piece Qf 3. Note that in this clarifying example, we make a simplifying assumption that there are no other pieces on the board to obstruct the reachability of the queen. As a distance measure, we use the Chebyshev distance (also known as the chess board distance ) has been widely used in the game of chess, and is defined as the minimum number of
Possible moves to a non-empty square following the capture of an opponent piece are not considered here. These moves are handled in Section 5.3.1 moves a king requires to move between the source and the destination positions. Figure 4b shows these distance values of the reachable squares measured from the square f 3.
The weight function of a chess piece (i.e. the likelihood with which it can occur in other positions in addition to its true position) is now defined for all points in the r -closure set of that piece. Similar to the approach shown in Fig-ure 4a, these weight values are derived from a function of the current position and the distance to the destination po-sition. More specifically, for a piece p located in ( x, y ), we define the following weight function for each member ( p, x 0 , y 0 )  X  r -closure ( p, x, y ). where d (( x, y ) , ( x 0 , y 0 )) is the chess board distance between positions ( x, y ) and ( x 0 , y 0 ). Note that the slope of the weight function ensures a minimum value of 1 8 maximum possible distance value 8, and a maximum value of 1 at distance 0, i.e. at the true position of the piece. Figure 4 shows the plot of the weight function, defined in Equation 2. Note that the maximum intensity of the weight function can be seen by the white surface at (6 , 3), i.e. at the square f 3, and that the values gradually decrease along the horizontal, vertical and diagonal lines. For squares outside the set r -closure ( Q, 6 , 3), the weight function is zero as can be seen by the black patches of surfaces in Figure 4. The weight function that we use in our study is a linear function instead of the more complex Gaussian function used in [11], so as to avoid tuning of additional parameters.

This process of computing the reachable squares and then weighting them by the function w is performed for all pieces present in a board position. The weight function obviously depends on the piece for which it is computed because of the variation in the rules of allowable moves, e.g. the weight function plot for a rook, which only moves vertically and horizontally, is different from that of a bishop which only moves diagonally. The reachable positions of a piece along with their weights are stored as delimiter separated values in the textual representation of the document. 5 As an ex-
Storing the weights as delimiter separated values was purely a Lucene specific implementation decision to utilize ample, we show a part of the textual encoding of our earlier example, i.e. the board of Figure 3a, as follows.
Note that the additional terms (shown in italics) represent the reachable positions of the pieces. The advantage of this encoding is illustrated by the fact that it enables the board position depicted in Figure 3b to be retrieved from the index, due to the presence of the matching terms Qe 2 etc. The weight function ensures that, during retrieval with a query term (say Qf 3), a board position (document) in which the white queen is at f 3 will get a higher score than a document where the white queen is at e 2.
In the previous section, we have seen that the limitation of the exact match can be overcome by incorporating the reachability information for each piece on the board. This section explores the integration of structural relationships between the pieces into the encoding.
Two board positions are more likely to be similar to each other if the same piece is found to attack similar squares of the opponent. Let us illustrate this with an example. The boards of Figures 1a, 1b and 2b have been reproduced in Figures 5a, 5b and 5c respectively. One of the reasons that the board in Figure 5b is more relevant to the query board of Figure 5a than the board of Figure 5c, is that both the boards in Figure 5a and 5b have the white knight at c 3 under a threat by the black bishops at g 7 and f 6 respectively (even though f 6 and g 7 are distinct squares, f 6 is reachable from g 7). On the other hand, the bishop of the board in Figure 5c is passive (blocked by two of its own pieces) not attacking the knight at c 3 or any other of white X  X  pieces. Such observations about the active or passive nature of the pieces can be crucial in determining the relevance of board positions in game analysis [9].

Following the above reasoning, the textual encoding of the board state is thus appended with terms corresponding to a list of attacking positions for each piece. More formally speaking, we define a -closure ( p, x, y ) = { ( p, p 0 , x 0 , y 0 ) : ( p, x, y ) | = the class  X  X elimitedPayloadTokenFilter X . See Section 6 for the implementation details. Hence, the a -closure ( p, x, y ) of a piece p at ( x, y ) contains an opponent piece p 0 at square ( x 0 , y 0 ). For example, the set a -closure ( b, g, 7) of Figure 5a comprises of the tuple ( b, N, c, 3). Note that we do not put the source position in the member tuples of the set a -closure to allow for the flex-ibility that the corresponding piece in a retrieved board po-sition can attack an opponent piece from one of the squares reachable from the position which that piece occupies in the query. For example, storing the square g 7 would not have allowed a match between the positions of Figures 5a and 5b.
A part of the textual encoding of Figure 5a, with addi-tional terms corresponding to those of the attacking squares, is shown in italics as follows (we use an arbitrary delimiter  X  &gt;  X  to separate the current piece and the attacked piece).
Analogous to the attacking squares, for each piece we also keep track of the pieces it defends. This again helps to de-termine the critical pieces and their connectivity across two board positions that need to be matched. For example, both the white queens at f 3 of boards Figure 6a and Figure 6b defend a knight, a rook and two pawns at identical positions, whereas the queen in Figure 6c has only two matching de-fended pieces ( Rd 1 and P e 4) with respect to the query (Fig-ure 6a). Similar to the a -closure we formally define the set of defended squares as follows. d -closure ( p, x, y ) = { ( p, p 0 , x 0 , y 0 ) : ( p, x, y ) | = Hence, the d -closure ( p, x, y ) of a piece p at ( x, y ) contains all those tuples ( p, p 0 , x 0 , y 0 ) such that the piece p defends an opponent piece p 0 at square ( x 0 , y 0 ).
In chess, a ray attack or an X-ray attack [3] occurs when a piece attacks an opponent piece  X  X hrough X  other pieces in its way. Although the opponent piece cannot be taken in the next move, but still these situations often lead to threaten-ing attacks on the opponent piece being ray-attacked. For example, rf 8 in positions of Figure 7a and 7b ray-attacks the white queen on f 3. Note that Qf 3 of board 7c is not under a ray-attack by any of the opponent pieces, as a re-sult of which this criteron can also play a crucial part in comparing the relevance of one board position to the query over another. Similar to the attack and defense closures of Equations 3 and 4 respectively, the ray-attacking squares of a piece are defined as follows. x -closure ( p, x, y ) = { ( p, p 0 , x 0 , y 0 ) : ( p, x, y ) | =
A part of the textual representation for the board position of our earlier example, with additional terms correspond-ing to the defense and the ray-attack squares (using delim-iters  X  &lt;  X  and  X = X  for defense and ray-attack respectively), is shown below.
In this section, we combine the ideas of Sections 4 and 5 to devise an algorithm for indexing the chess positions for a given collection of chess games. Our algorithm can use a standard text IR system to store the game positions in an inverted file structure. The pseudo-code for indexing and retrieval is presented in Algorithm 1. In Step 3 of Algo-rithm 1, the parameter numskip is used to skip a number of initial moves. This is important because the opening of a chess game follows a preset sequence of moves chosen from a few standard opening move sequences. There is thus a high probability of board positions to be exactly identical to one another during the opening stages of a game, which is not particularly interesting for this search task. Moreover, not skipping the first few moves can contribute to an unneces-sary increase in the size of the index due to the presence of a large number of pieces during the initial stages of a game. In particular, we set numskip to 12 in our experiments, i.e. we skip the first 12 rounds of moves. Each board position after a move in a game is encoded as a string constituted of a list of encodings for each piece computed in the loop from Steps 7-16. The storage of a text encoded board position in Step 18 of the algorithm is achieved by the use of Lucene (version 4.6) 6 , which is a freely available widely used text retrieval system.

The query to the system is an FEN encoding of a board position. The FEN encoding of the query board state is transformed to an internal encoding (achieved by execut-ing the procedure  X  X etrieve X  of Algorithm 1). This query string is then used to retrieve similar board positions from the index. The query board position, in contrast to an in-dexed document board position, does not need to contain the terms corresponding to the reachable squares. To illus-https://lucene.apache.org/core/4 6 0/index.html Algorithm 1 Chess Games Indexing and Retrieval 1: procedure IndexGames( G ) 2: for each game g  X  G do 3: Skip the first numskip moves. 4: for each move m  X  moves ( G ) do 5: brdenc  X  X  X  6: board  X  board matrix on applying move m 7: for each piece ( p,x,y )  X  board do 8: brdenc  X  brdenc  X  ( p,x,y ) 11: end for 12: for each  X   X  X  a,d,x } do 15: end for 16: end for 17: end for 18: Add document brdenc to index 19: end for 20: end for 21: end procedure 22: procedure Retrieve( Q ) 23: brdenc  X  X  X  24: board  X  board matrix of Q 25: for each piece ( p,x,y )  X  board do 26: brdenc  X  brdenc  X  ( p,x,y ) 27: for each  X   X  X  a,d,x } do 30: end for 31: end for 32: end for 33: Retrieve from index by executing query brdenc 34: end procedure trate with an example, it is possible to retrieve a document (say D ) containing the term Qf 3 in response to a query term Qf 2 (because D also contains the term Qf 2 along with an associated weight of 0 . 89 computed by Equation 2). The implication is that it is possible to conduct an approximate search, e.g. retrieve a board position where the white queen is at f 3 in response to a query position where the white queen is at f 2, without needing to add the query term Qf 3.
The IR model selected for use in retrieval was BM25 [14] with the default parameters of Lucene 7 , which is K = 1 . 2 and b = 0 . 75. Retrieval is carried out in two steps. Firstly, we retrieve a list of 1000 board positions by using the BM25 model. Secondly, we refine this list by retaining the best matching board position from each game. This ensures that consecutive board positions from a single game (which are likely to be similar to each other) are not reported in the final result-list.
In this section, we describe the experiments conducted to evaluate our proposed approach of chess position retrieval.
A standard IR test collection is comprised of three compo-nents, namely a document collection, a set of queries and a set of relevance judgments for these queries. Freely available chess game archives in the PGN format can be used as the document collection in this particular search task. However, http://lucene.apache.org/core/4 6 0/core/org/apache/ lucene/search/similarities/BM25Similarity.html due to the novelty of the search task itself, sets of relevance assessed queries are not available, to the best of our knowl-edge. To proceed with the evaluation, we therefore needed to construct a set of queries and relevance assessments.
As a first step towards building up the test dataset for evaluation, we indexed a set of freely available PGN game archive files named ICOfY (version 13.2.1 to 13.2.5) 8 accord-ing to the method outlined in Section 6. Each PGN file in the document collection was parsed with the help of a free-ware PGN parser pgnparse 9 . The parameter numskip was set to 12, i.e. we ignored the first 12 rounds of moves from each game. Table 1 outlines the index statistics. The num-ber of documents in this table refers to the number of chess positions indexed, which indicates that on average almost 78 positions are indexed per game. The number of unique terms refers to the number of unique piece configurations. On average each game position contributes 1 . 8 unique terms, which suggests that there is a significant overlap in the piece configurations across the index.
In order to test the hypothesis that the mobility and the structural relationship of the pieces can play a vital role in chess position search, we set up baseline approaches where we selectively do not use one or more of these attributes during the retrieval time similarity computation. The ap-proaches are outlined in Table 2. The run  X  X ruePos X  uses the naive encoding of a chess board during the similarity com-putation, whereas the subsequent approaches aim to test the benefit of applying more information in the similarity com-putation, such as the weighted reachability ( X  X chblePos X ), attacking squares information ( X  X ttk X ) and so on. The last approach ( X  X ombAll X ) uses a combination of all the features.
Queries and relevance assessments were formulated by crowd-sourcing using an approach similar to [7]. The chess position retrieval system was made available as a web service so that the users could formulate arbitrary chess position queries and provide relevance assessments for each retrieved board position. Participants for this task were recruited by http://icofy-base.de/1321PGN.7z http://sourceforge.net/projects/pgnparse/
Figure 8: Screen-shot of the search results page. distributing a  X  X all for participation X  email among our col-leagues, which contained detailed instructions for using the web interface. The email asked recipients to sign up for the experiment only if his familiarity with chess was higher than 2 in a scale of 1 to 5. Note that this experiment did not require the participation from professional chess players. However, a basic knowledge of chess was required for correct relevance judgments. Each participant from the set of 5 reg-istered ones, were asked to use the web interface to search for chess positions. The interface allowed the user to play a valid sequence of chess moves in order to formulate a search query. For the purpose of the experiment however, the users were instructed to cut-and-paste sequences of moves from real games because the board positions encountered in real games, when used as queries, have somewhat higher likeli-hood of retrieving relevant positions from the game database than when using queries from fictitious board positions.
We used a different PGN game archive ICOfY (version 13.1.4) comprising of 3970 games to formulate our query set. Each participant was provided with unique chunks of 300 games from this file, and was asked to formulate a query by randomly selecting a sequence of moves of size at least numskip + 1 (which in this case is 13), because positions from the 13 th move onwards were indexed into the system. The fact that each participant was provided with a different chunk ensured that the set of queries were non-duplicates. Each participant contributed 5 queries each, as a result of which the evaluation set comprised of a total of 25 queries. A screen-shot of the web interface is shown in Figure 8. The system returns a ranked list of at most 200 best match-ing positions from unique games. The pool of 200 retrieval results was formed by a combination of different retrieval approaches outlined in Table 2. The similarity scores of the documents from each run were normalized (divided by the maximum score for that run). The pool was then con-structed by selecting 200 documents with most normalized scores from the union of these runs.

In each row of the search results page, the first (left-most) column displays the query board position, while the second one displays a retrieved board position, alongside of which a five point relevance scale (ranging from non-relevant to ex-tremely relevant) is displayed. The participants were asked to provide relevance assessments for each retrieved board position in response to a query. In addition to the visual similarity between two positions, the participants were in-structed to also consider the usefulness of the retrieved game in the analysis of the current query position, i.e. to take into account the similarities in the key features of the positions. Note that we relied on a five-point relevance scale rather than on strict binary relevance judgments. This is because in the case of chess position search, the relevance judgments need to accommodate for the different levels of importance that a retrieved board position may have in analyzing the current game situation.

Our evaluation is based on manual judgments because it is not possible to apply a computational model of relevance for evaluation of the search effectiveness. For instance, a computational approach of relevance estimation might take into consideration the next moves and the outcome of the retrieved and the query board positions. However, such a model would assume that the next moves of the query board position are known, which in turn does not conform to the search use-case.
In this section, we first report the effectiveness of our search method in terms of standard evaluation metrics. We then select the best performing approach and study the ef-fect of varying the BM25 parameters on the retrieval effec-tiveness. This is followed by an investigation of the effect of the query length on retrieval behaviour.
A standard metric for graded relevance judgments is the nDCG[6], which we use as one of the evaluation measures. To measure the ability of the system to retrieve documents at top ranks, we also measure nDCG@5. Additionally, we also transform each graded relevance judgment into a binary one by considering a document as relevant if the graded rel-evance judgment value is at least 2 and non-relevant oth-erwise. We then report the standard metrics of MAP and P@5 using these binary relevance values.

Note that the values for metrics such as MAP and nDCG cannot, in practice, be computed exactly because some rel-evant documents for a query may not exist in the pool of manually judged documents. However, in the case of chess IR, the number of board positions relevant to a query board position is expected to be small, as a result of which, it is less likely for a relevant document to be left out of the pool.
Table 3 shows that the approach  X  X ruePos X , which only uses the true positions of pieces, does not produce satisfac-tory results. This is expected because many relevant posi-tions may not be retrieved due to the fact that the position Table 3: Evaluation of the chess position search nDCG of each individual piece in a board position of the collec-tion may be slightly different from that of the query (see Figure 3). Retrieval results are improved when the reacha-bility information is included in the run  X  X chblePos X . The results are further enhanced by the addition of connectivity information between the pieces. Both attack and defense connectivities improve the results in comparison to  X  X ch-blePos X .  X  X ayAttk X  alone does not produce an improve-ment over  X  X chblePos X . However, results are significantly improved when all the three connectivity types are used to-gether in the approach  X  X ombAll X , as shown in the last row.
The best performing run  X  X ombAll X  used the default BM25 parameter settings of Lucene, i.e. K = 1 . 2 and b = 0 . 75. Figure 9 shows the effect of varying these parameters for this run. The figure shows that the nDCG can further be improved to 0 . 7083 (from 0 . 6922 of Table 3) by using K = 1 and b = 0 . 7. A value of K close to zero indicates more em-phasis on inverse document frequency (idf) and less on term frequency (tf), which in the case of chess position search, produces poor results. This is expected because for textual representation of a chess board, the presence of a term (tf is always 1 in this case) bears more importance than the idf.
The iso-b lines of Figure 9 show that document length normalization plays an important role in retrieving relevant documents, as can be seen from the relatively lower values of nDCG for low values of b less than 0 . 5. Length normal-ization is important here because a board position with ap-proximately identical set of pieces with respect to the query position is more likely to be relevant rather than a longer document representing a board position containing a higher number of additional pieces not present in the query.
To determine the effect of query length on retrieval effec-tiveness, we categorized the queries by their lengths, which in this case refers to the number of chess pieces present in the query board position. The results are shown in Figure 10.
It can be observed that the average precision and the av-erage nDCG values for queries in the range [11 , 13], i.e. the queries where the number of positions is between 11 and 13 (inclusive), are the highest indicating that our proposed Figure 10: Average retrieval quality for each query group categorized by length (the number of pieces). algorithm works particularly well for short queries. This finding can be explained as follows. A short query typically represents the ending stage of a game when only a small number of pieces remain. A match in a term (piece position or connectivity) towards the ending stages of a game is as-sociated with more importance than a match in the middle stages of a game; e.g. towards the end stages of a game a match in two board positions where a king or a queen is at-tacked by the same piece almost certainly ensures that one position is relevant to the other.
This paper has explored the novel search task of retriev-ing top-most approximately matching chess game positions given a query position, so that the subsequent moves from the retrieved games may be useful in analyzing the current game and hence in predicting the next best move. In order to ensure effectiveness and efficiency, we have approached the search task from an IR perspective, in contrast to existing chess retrieval systems which are either restricted to provide the functionality identical matches or allow approximate re-trieval of positions at the cost of heavy run-time overhead. In our IR-based approach, each position in a chess game is encoded as a set of terms, where each term is used to rep-resent the following: a) the true position of a piece, b) the reachable positions of a piece with weights inversely propor-tional to the distances from its true position, and c) the structural relationships between the pieces, such as the ones being attacked and defended. Empirical evaluation of our proposed approach demonstrates that a combination of all these features produces satisfactory retrieval results. The conclusion of our study is that the chess position search problem can be solved effectively and efficiently by employ-ing an IR-based approach. This observation can, in effect, lead to developing more effective chess playing algorithms, where the automatic process of game tree exploration for se-lecting the next-best move can be supplemented with infor-mation extracted from closely matching positions retrieved from previously played games. The system can also be useful in manual analysis of a current chess game.

Since a chess board position can be represented as a graph (piece configurations as nodes and inter-piece relationships as edges), we believe that the methodologies proposed in this paper can, in future, be generalized to conduct approximate search of graph objects. A practical application of graph search could be retrieval of chemical compounds which are structurally most similar to a given query compound.
