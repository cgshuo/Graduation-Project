 In mobile object database systems, both query issuers and queried objects are subject to location privacy intrusion. One solution to this problem is to have users reduce their location resolution when making location update. Such loca-tion cloaking allows mobile objects to achieve a desired level of protection, but may not produce accurate query results. Alternatively, one can apply cryptography techniques such as secure multiparty computation to compute the spatial re-lationship among mobile objects without having mobile ob-jects to disclose their location at all. This strategy produces high quality query results, but in general are computation-intensive, especially when a large number of mobile objects are involved. In this paper, we present a hybrid approach that mitigates the above dilemma. Our idea is to compute approximate query results based on cloaked location infor-mation and then refine query results by applying homomor-phic encryption. We demonstrate that this approach can be used for efficient and privacy-preserving processing of KNN queries and evaluate its performance through simulation. H.2.0 [ DATABASE MANAGEMENT ]: General X  Secu-rity ; H.2.8 [ DATABASE MANAGEMENT ]: Database Applications X  Spatial databases and GIS KNN query, location privacy, cloaking region, homomorphic encryption
A typical mobile object database (MOD) system consists of a number of mobile objects that communicate with a cen-tral server through wireless means. The mobile objects are position-aware and report their location to the server. The server manages this location information and allows users to query the spatial properties of these objects. Examples of such queries include range query ( X  X etrieve the objects inside some geographic region X ) and KNN query ( X  X etrieve the K objects that are nearest to my position X ).

MOD systems have many important applications, but lo-cation privacy has been a major concern. When mobile ob-jects report their location to the server, they are subject to location privacy intrusion because the server may not be trustworthy in keeping such information in confidential. Users may choose to use pseudonyms for self-protection, but their location information itself may be correlated with re-stricted spaces such as office and house to find out their real-world identities. In addition to queried objects, query issuers suffer the same problem when they disclose their lo-cation.

One solution to mitigate the privacy problem is using lo-cation cloaking. The idea put in a simple way is to reduce location resolution to achieve a desired level of privacy pro-tection. When a mobile object needs to report its location, it reports a cloaking region which contains its current position and satisfies other constrains. For example, the cloaking re-gion may need to have at least K  X  1 other users currently inside (e.g., [1, 2]) or have been visited by K  X  1 other peo-ple in the past (e.g., [3, 4]). Location cloaking provides K -anonymity protection to a subject, but may not allow the server to produce precise query results.

Another way to tackle the location privacy issue is to ap-ply cryptography techniques. For example, private informa-tion retrieval was explored in [5] to allow users to retrieve stationary location-based information such as gas station and hotel without having them to report their location. In [6], a homomorphic encryption-based solution was proposed to find nearby friends while preserving their location privacy. A more recent work [7] uses secure multiparty computation. These techniques protect users X  location privacy to its max-imum extent, but usually incurs high communication and computation costs which may not be feasible to mobile ob-jects.

Our research addresses the above dilemma with a hybrid approach. In this approach, mobile objects report their cloaked location to the server. When processing a query, the server uses this information to find out approximate query results and then refines these results using homomorphic en-cryption. We present the design of this encryption-based re-fining process and show how it can be used to process KNN queries.
We assume the mobile objects register themselves to the server which does query processing. During the registration process, each object selects a unique ID and a pair of public key and privacy key. The unique ID and public key are reported to the server. The public key will be used for user authentication later. The server also chooses a pair of public key and private key, and notifies every mobile object of this public key.

The server knows mobile objects X  location by their cloak-ing regions. In other words, when an object reports its lo-cation, it reports a cloaking region. Many location cloaking techniques have been developed in the past decade to com-pute a cloaking region (either a circular region or a rectan-gular box) for a given level of privacy protection. Here we simply assume mobile objects can compute their cloaking regions without concerning ourselves about what technique they use. Moreover, we assume mobile objects know when to make a location update in order for the server to track their movement. Wireless communication consumes a sig-nificant amount of energy, so frequent location update may quickly exhaust a mobile object X  X  battery power. A simple solution to avoid this problem is for a mobile object to mon-itor its movement against its cloaking region and report a new cloaking region when it moves out of the current one.
To issue a KNN query, a user U reports its ID and cloaking region R to the server. The server processes the query in two phases. In the first phase we generate an approximate query result and in the second phase, we obtain the accurate query result. Details will be discussed as follows.
This phase generates approximate query results based on mobile objects X  cloaking regions. Let U be the user who is-sues a KNN query and R the user X  X  cloaking region. The server computes its minimal distance and maximal distance to every other user X  X  cloaking region. Let R i and R j be two cloaking regions. We will use min ( R i , R j ) and max ( R to denote the corresponding minimal distance and the max-imal distance between R i and R j . The server uses Algo-rithm 1 to find the approximate results.
 Algorithm 1 Compute Approximate Results 1: For every object O i , compute max ( R, R i ), where R 2: Find the object, say O k , whose cloaking region X  X  maxi-3: L min = max ( R k , R ), where R k is O k  X  X  cloaking region; 4: For every object O i , compute min ( R, R i ), where R 5: Output object O c as a candidate if min ( R c , R ) &lt; L
We explain the above algorithm using Figure 1, which shows four objects (i.e., A , B , C , and D ) and their corre-sponding cloaking regions. The maximal and minimal dis-tances between A and D are labeled with colored lines. Sup-pose A issues a 1-NN query. The server first computes A  X  X  maximum distances to the other three objects and finds the one whose maximum distance is smallest. In this case, this object is C . The minimal distance from C to A is L Then the server computes A  X  X  minimum distances to the other three objects and outputs the objects whose minimum distances are less than L min . Here B and C satisfy this cri-teria and thus are query result candidates.

Note that the approximate query results generated by the above algorithm include all possible query results. To prove this, we just need to show that those mobile objects whose minimal distance to the query issuer is larger than L cannot be in the KNN results. This is due to the fact that L min is O k  X  X  maximal distance to U , so there are at least K mobile objects whose exact distances to U are less than L min . If a mobile object X  X  minimal distance to query issuer U is greater than L min , its exact distance to U must be greater than L min and therefore cannot be a KNN result.
In this phase, we refine the approximate query results gen-erated in the first phase. Refining approximate query results was considered in [8], where the approximate results of ren-dezvous query are refined with an aggregator. The proposed technique, however, allows malicious users or the aggregator to infer the locations of others when they collude. Here we propose to refine approximate query results using homomor-phic encryption.

We choose to use an additive homomorphic encryption called Paillier cryptosystem , although other encryptions may be used as well. The additive homomorphic property means that E ( m 1 ) L E ( m 2 ) = E ( m 1 + m 2 ), where L is an arith-metic operation in the encrypted domain that is equivalent to the addition operation in the plaintext domain. In other words, the total of the encrypted m 1 and the encrypted m is equal to the encrypted m 1 + m 2 . Details about Paillier cryptosystem can be found in [9] and we will not discuss here.

To apply the Paillier cryptosystem , the server needs to generate a public key P U B and a corresponding private key P RI . The public key is made known to all mobile objects. Without loss of generality, let { O 1 , O 2 , ..., O n } be the set of candidate query results generated in the first phase. We now consider how to refine these candidates.
 First of all, the server sends the IDs of all candidates to U , the query issuer. U generates a signature SIG ( U ) of its ID U and time stamp T with its own private key prikey U by the following equation.
 Many asymmetric cryptographic algorithms such as RSA can be used to generate this signature. In this work, we use RSA as the signature function.

We assume that mobile objects can communicate with each other (e.g., through wireless cellular networks and/or the Internet). U and each candidate O i execute the following protocol.

First, U sends SIG U to O i . O i then verifies U  X  X  identity by asking the server for U  X  X  public key pubkey U and ID U decodes SIG U with pubkey U and gets ID U and T . If ID U doesn X  X  match the ID obtained from the server or the request is timeout, O i terminates the process. Otherwise, O i con-tacts U for its encrypted location information which contains E ( x 2 U ), E (  X  2 x U ), E ( y 2 U ), and E (  X  2 y U ), where x are U  X  X  location coordinate. O i then proceeds to calculate the encrypted distance between U and itself E ( Dis ( U, O using Algorithm 2, which preserves their privacy without having them to disclose their locations.
 Algorithm 2 Compute Encrypted Distance Require: User O gets its location Loc O and obtains E ( x 1: O calculates E ( x 2 O ) and E ( y 2 O ), where x O and y 2: O calculates E (  X  2 x U x O ) and E (  X  2 y U y O ) by the follow-3: O calculates E (( x U  X  x O ) 2 ) and E (( y U  X  y O ) 4: O calculates E ( Dis ( U, O )): O i sends the encrypted distance it calculates to U . When U receives the encrypted distance from each candidate, it selects a secret random number r and adds a noise to each distance: U permutes the noise-added distances and sends them to the server. The server decrypts the encrypted numbers with private key P RI and sends the indexes of K-least distances back to U . Finally, U would restore the IDs of the KNN re-sult by the indexes. These IDs are guaranteed to correspond to the real KNN users of U .

Note that in the above process, none of mobile objects disclose their location to other or the server, thus having their location privacy preserved.
For performance evaluation, we have implemented a de-tailed simulator of a mobile object database management system in Java. The number of mobile objects N in the sys-tem varies from 10,000 to 30,000 and the K in KNN queries varies from 1 to 9. We partition the entire network domain into a number of cells, each being a basic unit of a cloaking region. In other words, when each cloaking region reported by a mobile object consists of a number of adjacent cells.
Location cloaking protects a user X  X  privacy by reducing its location resolution. As mentioned in the introduction, there are several different approaches to compute a cloaking region. Given a same cloaking region, there are also dif-ferent metrics to measure the privacy level it can achieve. For example, the privacy level can be measured by the num-ber of users currently inside the cloaking region. Or it can be measured by the number of users who have visited the region in some historical time period. Despite the differ-ences, a larger cloaking region is usually required in order to achieve a higher level of privacy. As such, here we simply define the privacy level of a cloaking region as where AREA R is the total number of cells covered by a user X  X  cloaking region. As for the result quality of a KNN query, we define it as K K 0 where K 0 is the number of candi-dates of the KNN query. Figure 2(a) shows the relationship between privacy level and result quality with different user numbers but fixed K value of KNN queries (i.e., K = 5) and Figure 2(b) shows the same relationship with different K values but fixed user number (i.e., N = 30 , 000). Both figures show that when the privacy level(i.e., area of cloaking region) increases, the result quality decreases. This is not surprising because a larger cloaking region naturally result in less accurate query results. In the extreme case, when every mobile object reports the entire network domain as its cloaking region, the result quality will be K N . This phase refines the approximate result of a KNN query. Figure 3(a) shows relationship between privacy level and running time with different user numbers and fixed K value of KNN queries (i.e., K = 5) and Figure 3(b) shows the same relationship with different K and fixed user number (i.e., N = 30 , 000). Both figures show that running time increases when privacy level increases. In this phase, run-ning time is mainly spent on two steps: candidate finding and encrypted distance computation. As the time spent on candidate finding is dependent on user number N , we can see from Figure 3(a) that a larger user number N results in more computation time. As distance computation time is dependent on the number of candidates, we can see running time increases when the number of candidates increases (i.e., privacy level increases or K is larger).

We have presented a hybrid approach for privacy-preserving processing of KNN queries in mobile object databases. The essence of our mechanism is to combine two different tech-niques, cloaking technique and homomorphic encryption, to overcome the shortcomings of these two individual tech-niques. We have implemented the proposed technique in a simulated mobile object database management system and evaluated it performance in terms of result quality and com-putation cost. We have collected some preliminary perfor-mance data and reported in this paper. [1] Marco Gruteser and Dirk Grunwald. Anonymous Usage [2] B. Gedik and L. Liu. A Customizable k-Anonymity [3] T. Xu and Y. Cai. Exploring Historical Location Data [4] T. Xu and Y. Cai. Feeling-based Location Privacy [5] Gabriel Ghinita, Panos Kalnis, Ali Khoshgozaran, [6] Ge Zhong, Ian Goldberg, and Urs Hengartner. Louis, [7] Igor Bilogrevic, Murtuza Jadliwala, K  X  ubra Kalkan, [8] Tanzima Hashem, Lars Kulik, and Rui Zhang. Privacy [9] Pascal Paillier. Public-Key Cryptosystems Based on
