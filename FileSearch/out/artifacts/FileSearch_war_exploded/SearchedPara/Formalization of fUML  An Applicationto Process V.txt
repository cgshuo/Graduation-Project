 With the increasing complexity of processes, whatever their kind (i.e. business, software, medical, military), process modelers need adequate tooling support to simulate and to ensure their correctness before to use them in a real context. Recent studies reported a significant rate of errors in industrial process mod-els [1,2]. Typical errors are deadlocks, unreachable activities, inefficient use of resources and timing problems.

UML Activity Diagrams (AD) are well-known for describing dynamic behav-ior and have been extensively used as a process modeling language (PML) [3,4,5]. UML is a standard with a good tooling support and AD allow the expression of most of the workflow patterns as identified by [6]. In order to verify UML-based process models, current stat e-of-the-art has already proposed some formaliza-tions of the way an AD operates [7,8,9]. These formalizations are mandatory to apply model-checking techniques enabling an exhaustive and an automatic verification of their models. However, in the current UML specification [10], the operational semantics remains unclear, i mprecise and ambiguous. This semantics is explained in natural language and dispersed through the specification. Due to this fact, the authors of these formalizations have done some assumptions on the precise operational semantics. A s a consequence, the same process might be executed and verified differently from one tool into another, implying a gap between the semantics adopted respectively by each tool.
 Recently, the OMG released fUML (Semantics of a Foundational Subset for Executable UML Models) [11], a new standard that precisely defines the ex-ecution semantics for a subset of UML 2.3 in a form of an Execution Model implemented in a virtual machine. However, even if the semantics is now clear and not subject to human interpretatio n, the semantics is not given in a for-mal way but in the form of pseudo Java-code. Therefore, it is not possible to straightforwardly apply model checking techniques.
 In this paper, we define a formal model of fUML using first-order logic (FOL). The formalization addresses a subset of fUML encompassing only the concepts required for process modeling as identified in [3]. Current formalizations pro-posed in the literature focus mainly on the control-flow aspects of the process preventing to verify many kinds of properties related to data-flow, resources and timing constraints [12]. Therefore, our formalization covers both control and data-flow of the process through the use of the AD notations, and takes into account the associated organizational data such as resources and timing constraints. Then, we implement our formalization by using the Alloy modeling language [13] and we build a graphical tool on top of the implementation. The result of the verification is then graphically displayed on the process.
The rest of this paper is organized as follows. Section 2 presents the fUML standard and its execution semantics. S ection 3 presents our FOL formalization of fUML. Section 4 gives an overview of i nteresting proper ties supported by our formalism. The implementation of the formalization and a case study are presented in Section 5. Finally, related work is addressed in Section 6 and Section 7 concludes by sketching some future perspectives of this work. fUML is an OMG standard that precisely defines the execution semantics of a subset of UML 2.3. The standard defines a virtual machine in the form of pseudo Java-code, enabling compliant fUML models (i.e., UML models using only el-ements comprised in the fUML subset ) to be executed. It can be decomposed in three main parts: (i) the abstract syntax represented by a subset of UML, mainly composed by the Class Diagram and most of the Activity Diagram ; (ii) the Execution Model which defines the execution semantics of the abstract syntax and (iii) the model library which defines primitive types and behaviors (e.g. integer type and addition between tw o integers). In this section we give an overview of the Execution Model. 2.1 Execution Model The Execution Model is itself a model, written in fUML, that specifies how fUML models are executed. The execution semantics adopted by fUML is quite similar to Coloured Petri Nets (CPN) and is based on the principle of offering and consuming object or control tokens betw een the different activity constituents.
To illustrate this concept, Figure 1 shows a simple process represented with an AD composed of one InitialNode ,two Action nodes and an ActivityFinalNode . Each of these nodes are connected with a ControlFlow edge. The sequence diagram shows the corresponding calls between the nodes in the Execution Model. The diagram is a simplified version of what really hap-pens during the execution and focuses on the interaction between elements. ActionActivation and ActivityEdgeInstance are the instantiation of the cor-responding abstract syntax.

When the fUML virtual machine invokes this activity, it starts by inserting a token in each InitialNode . Then, the nodes with a token (i.e., the InitialNode in our example) fire (i.e., execute their own behavior) and sendOffer on each of their outputs ControlFlow .The ControlFlow is then able to call on its target node A to receiveOffer . When the node  X  A  X  receives an offer, it first checks if the prerequisites for its execution are satisfied, if yes, takes the offered tokens from the input control flows and fires. At the end of the firing operation, the node directly sendOffer on its outputs ControlFlow . The execution of an activity is then an extended chain of sendOffer -receiveOffer -fire -sendOffer calls between the activity constituents. When an ActivityFinalNode is reached or if there are no nodes still able to execute, the activity is terminated. Each abstract syntax element of an activity diagram has its own semantics. For example, a DecisionNode will offer a token only on one of its output edges determined during its fire execution.

Similarly to CPN, tokens positions and contents on the system represent the actual execution state. Since the goal of this paper is mainly on the verification of fUML-based process models, we focus on the formalization of the tokens game between the semantics elements of an UM L AD. Note that we call  X  X okens game X  the rules and conditions on which a token may pass through an edge to another node to form a complete execution. In the following, we present our formalization of the fUML tokens game by defining the syntax of the langage and its semantics. 3.1 Syntax Figure 2 shows an excerpt of the UML class diagram handled by our formal-ization. Here we concentrate only on t hose elements that are part of the fUML standard and useful for the definition of a process as identified in [3]. An Activity is a graph with three kinds of ActivityNode s: ObjectNode , ControlNode and ExecutableNode .An ObjectNode represents the data in a process, a ControlNode coordinates the execution flow and an ExecutableNode represents a node that can be executed, i.e. process action. There are two kinds of ActivityEdge to link the nodes: ObjectFlow and ControlFlow . ObjectFlow edges connect ObjectNode s and can have data passing along it. ControlFlow edges constrains the desired order of execution of the ActivityNode s. ControlNode can be used for parallel routing ( ForkJoin ), conditional routing ( DecisionNode ), synchronization ( JoinNode ) and merging multiple alternate flows ( MergeNode ). InitialNode and AcitivityFinalNode represent respec-tively the beginning and the end of an Activity while FlowFinal terminates aflow. InputPin and OutputPin are anchored to Action storepresentthe required input data and the output data produced by the action. Similarly, an Activity can have multiple ActivityParameterNode to represent its data input and output. Thus, an Activity can represent a process by defining a coordinated sequencing set of actions using both control-and data-flow.
Formally, we consider three basic elements: Control , Executable ,and Object .  X  Control = { fork,join,decision,merge,initial,activityFinal,flowFinal }  X  Executable = { action } represents the ExecutableNode type,  X  Object = { activityParameter, outputPin, inputPin } represents the  X  Types = Control  X  Executable  X  Object represents the set of all types. Thus, we introduce the notion of diagram as a vertex-labeled graph:
For a Diagram D =( V, E, Types, lab, lower, upper ), we introduce the follow-ing auxiliary functions that will help us to define formally an AD.  X  Vlab : Types  X  2 V is the function that returns all the vertices of a type:  X  incoming/outgoing : V  X  2 E are functions that return, respectively, the  X  source/target : E  X  V are functions that return, respectively, the source  X  input/output : V  X  2 V are functions that return, respectively, the input
Now,wecandefinethenotionof Activity Diagram .Actually,itisa Dia-gram with some additional structural constraints.

Generally, a process is characterized by two main parts: the workflow and the associated organizational information. Here, the workflow is represented using UML AD. The organizational information is attached directly to the actions to give insight about the execution. This information is domain dependent. For instance, software processes might focus on the number of agents and their skills, while medical processes require instrumentation and drugs. Therefore, we define a process as an AD extended with most commonly used organizational information: resources and time. Note that the definition can be easily extended to take into account other domain dependent information.
 3.2 Semantics The semantics of our model follows the newly defined fUML standard [11]. We formalize the way the tokens transit bet ween the nodes and edges that compose an fUML AD model. Moreover, to be able to reason about the timing constraints of the process, we extend the formalization with discrete clocks representing the time spent during the process execution.

The semantics of our formalism is based on the notions of states , enabling and firing of transitions (similar to those used in CPN).
 State. A state formalizes the configuration on which the process is at any time of its execution.
 Transition. The dynamic of a process, i.e. its execution, is defined through the notion of transition . To move from a state to another one, a transition is first enabled then fired . Therefore, the enabling notion corresponds to a pre-condition while the firing notion corresponds to a post-condition. We first define the enabling notion, and then formalize the firing concept.
 Transition enabling. A transition is said to be enabled when some preconditions are met (to allow the firing of the transition). By abstracting the way the fUML Execution Model executes an AD, two cases can be distinguished: (i) a node is ready to execute; (ii) a node is ready to terminate. In our framework, these are represented by predicates eStart and eFinish , respectively. Also, note that the system can progress through time elapsing using the eTime predicate. Let us consider a process P =( V, E, Types, lower, upper, lab, Resource, Use, Timing ) and a state s =( m, gc, lc ). To simplify our notation, we assume that s is implicitly available in the following enabling predicates. 1. eStart is the predicate that determines if a node v is ready to be executed. 2. eFinish is the predicate that determines if a node is ready to terminate and 3. eTime determinates if the clocks can be increased. The clocks can be in-Transition firing. The firing of a transition and the effect it has on a state can be defined as follows. Also here, two cases have to be distinguished: (i) firing a transition on a node that can start; (ii) firing a transition on a node that can terminate and (iii) firing a transition to represent the elapsing time. Let us consider a second state s =( m ,gc ,lc ). fStart , fFinish and fTime express the constraints that must be satisfied to ensure that s is a successor of s . fStart is a constraint related to a staring node (a node that satisfies the enabling predicate eStart ), fFinish is a constraint related to a finishing node (a node that satisfies the enabling predicate eFinish ), and fTime is a constraint related to the increasing of the clocks (if the current state satisfies the enabling predicate eTime ). For simplification, we assume that s and s are implicitly available in the following firing predicates.

We first introduce the predicate fz that constrains to equality the marking of all the vertices and edges of s and s , except the one given as parameter p : 1. fStart is based on the following auxiliary predicates. 2. fFinish is based of the following auxiliary predicates. 3. fTime increases the local clock of each action currently executing and in-
At this point we are able to define the complete transition (successor relation between states). Basically, when an activ ity final node is executed, or when there is no other node that can either start o r terminate, the execution is over. Thus, to represent a process execution, we define the notion of trace: To study the properties of the modelled process using our formalization we need a formal logic. Many logics exist and can express different kind of properties: Computation Tree Logic (CTL), Linear Temporal Logic (LTL), etc. In our case, almost all our properties can be handled using LTL.

LTL formulae are constructed from atomic propositions, logical operators  X  ,  X  ,  X  , and temporal operators X (meaning  X  X ext X ), G ( X  X lobally X ), U ( X  X ntil X ) and F ( X  X ventually X ) [14]. In our formalism, atomic propositions are statical (related to the structure of the process) or dynamical, of the form m ( n ) op v or gc op v where n  X  V  X  E , op  X  X  = , = ,&lt;,  X  ,&gt;,  X } and v  X  N .
Given a process P =( V, E, Types, lower, upper, lab, Resource, Use, Timing ) andanLTLproperty  X  ,wesaythat P | =  X  ,iff  X   X   X  Traces , X  | =  X  .Itisworth noting that LTL semantics is defined over infinite traces. To treat the case of finite traces, we just used the so-called stuttering principle to extend a trace to an infinite one.

In the following, we give an overview o f interesting properties that can be verified on a process and give some examples. Due to space restriction, we choose only some relevant constraints from e ach aspect of the process dimension. The goal here is to show the ability of our formalism to deal with a wide variety of process constraints rather than presenting them exhaustively.
 Control-Flow. Control-flow analysis deals with questions like  X  X oes the pro-cess terminate? X ,  X  X s ther eanydeadlock? X , X  X oes TaskA ever happen? X , etc. These properties are often referred as soundness properties [12] in the litera-ture. Soundness tends to check some desirable properties such that a started process can always complete ( option to complete ).  X  Option to complete can be checked by verifying that at least one Data-Flow. The goal of data flow analysis [15] is to validate the process against different data problems such as missing data , i.e. when a data element needs to be accessed, but either it has never been created or it has been deleted without having been created again.  X  Missing data can be checked by ensuring that when a node has offers on its Resources. Resources properties deal with resource problems like missing re-source , i.e., when an activity requires a resource which may not be available.  X  Missing resource canbecheckedbyverifyingthatwhenanactionisreadyto Time. The goal of timing properties is to answer questions like  X  X s it possible to finish the process on time whatever the path taken? X .  X  To check that the process can terminate before max time unit can be ex-Business. While the other categories specify properties that must hold for all processes, business properties rep resent specific properties tailored to a given process. They play an important role since a process could be syntac-tically correct and valid agai nst the precedent properties but still violates some business constraints. Business properties deal with questions like  X  X oes the ImportantAction is executed whatever the choi ce made during the execution? X  or  X  X s ImportantArtefact (i.e., the goal of the process) always available at the end of the process? X .  X  Let P =( V, E, Types, lower, upper, lab, Resource, Use, Timing )be We implement our formalization using the Alloy language [13]. It is is a declara-tive modeling language based on FOL and relational calculus for expressing com-plex structural and behav ioral constraints. It is associated to a tool, called Alloy Analyzer : a constraint solver that provides fully automatic simulation and check-ing based on model-finding through SAT-solving (Satisfiability-solving).
On top of the formal framework implemented using Alloy, we have developed a prototype currently provided as an Eclipse EMF plugin. The main intent of this prototype is to assist the modeler by automatically verifying fUML-based processes in the form of XMI Instances. It comes with a library of predefined properties ready to be checked, but also allows to add some common business properties through a graphical int erface. The user only has to check in the in-terface the desired properties, and fill the parameter if required (e.g., maximum time to terminate the process). The business properties can be added through pre-defined templates, e.g. select the ActionA which must always be executed before ActionB . Figure 3 shows a screenshot of our tooling for process model-ing and enactment emphasizing the process view and its analyzer. When the verification is performed, the path leading to the counter-example (if any) is highlighted in green for reachability properties, and in red otherwise. 5.1 Case Study This section presents a case study on the Alloy implementation by checking the properties presented in section 4 on the ProcessOrder process from the UML specification [10]. This process simply p roceeds the arrival of a new order and is visible on Figure 4.

To perform the verification, the process and the properties are translated into an Alloy specification. Then, this specification is given as input to the Alloy Analyzer which reduces the verification to a SAT problem. It is presented to a SAT solver (MiniSat among others) in a Conjunctive Normal Form (CNF) for-mat. A CNF is a conjunction of clauses. Each clause represents a disjunction of variables. A satisfying assignement to a SAT problem consists of a boolean affec-tation to the variables such that all clauses are satisfied. Usually, the complexity of a SAT problem is measured by the number of clauses and variables.
Let P =( V, E, Types, lower, upper, lab, Resource, Use, Timing )be the process from Figure 4 where ( V,E,Types,lab ) are displayed on the figure, Resource = { BankConnector } , Use = { AcceptPayment  X  X  BankConnector }} and Timing = { ReceiveOrder  X  1 , FillOrder  X  2 , SendInvoice  X  1 , MakePayment  X  1 , AcceptPayment  X  2 , ShipOrder  X  3 , CloseOrder  X  1 } . Generally, these pieces of information are available with the model through UML Profiling [10] or as direct extension of the UML AD metamodel [3]. For sake of clarity, we do not propose some graphical representation of these data ( Resource , Use and Timing ) but directly give their formal representation.

Table 1 summarizes the obtained results. Column 1 represents the analyzed property from Section 4. For the  X  (4) time X  property, we are using max =4. Concerning the  X (5) business X  property, we choose the two actions FillOrder and SendInvoice ,and max = 6. Columns 2 specifies if we are using the timed semantics for the verification. Due to the presence of the global and local clock ticks, a lot of extra states are introduced to support the properties related to the time. For efficiency reason, we also implemented a version of the semantics without these clocks on each state for the properties which are not relying on it. Columns 3 and 4 represent, respectively, the number of generated variables and clauses. Columns 5 and 6 represent, resp ectively, the time to generate the CNF and to solve the SAT problem. Columns 7 specifies the result of the verification, if there is any counter-example. All ana lyses were performed on a MacBook Air 2011 with Intel Core i5 processor and 4GB of RAM with Mavericks as OS. These results highlight the effectivenes s of our tool w.r.t. a concrete example. Actually, even if the whole generated SA T problems present a relatively high complexity (over 1 million clauses and over 410 thousand variables), the solv-ing time is less than 1 minute for the untimed properties. The timed-related properties have a similar ratio in terms of clauses and variables but require few minutes due to the presence of extra stat es. Interested readers can download the complete Alloy formalization with the case study from our website 1 . There is an extensive literature on verifyi ng process models. A complete overview of the related work would be beyond the sc ope of this paper (see [12]). Therefore, we focus on the work directly relevant to this paper, namely formal verification approaches of UML AD.

Generally, the verification is based on mapping the process model into math-ematical formalisms used to model systems such as automata, Petri Nets or process algebra. All of thes e formalisms have been investigated for the verifica-tion of UML AD. Jung et al. [16] propose a transformation from UML AD to Colored Petri Nets. Dong et al. [7] presents an approach for formalizing UML AD using  X  -calculus, a kind of computing mod els for representing concurrent systems and express the inte ractions between evolving processes. Eshuis et al. [8] check UML AD in the context of workflow modeling by translating the ac-tivity into the input language of NuSMV, a symbolic model checker. Guelfi et al. [9] propose a translation of UML AD extended with timing constraints into Promela (Process or Protocol Meta Langu age) in order to check behavioral prop-erties with the model-checker SPIN. How ever, these works are not based on the new fUML standard and have done some assumptions on the precise operational semantics which creates tool-interoperability problems. Moreover, the semantics richness of these approaches are less complete than fUML, many simplifications have been carried out. While all of these approaches propose to check control-flow related properties, data-flow are not always considered and only [9] supports the timing constraints. Properties relat ed to the resources are never supported.
Montogna et al. [17] propose an approach allowing the definition of a virtual machine for fUML in the K -Framework, enabling the execution of models on a more formal definition than the current Java-based implementation. To the best of our knowledge, there is no temporal logic verification proposed.
Abdelhalim et al. [18] present an approach to manually map an fUML models into the process algebraic specification language CSP (Communicat-ing Sequential Processes) and use the FDR (Failures-Divergences Refinement) model-checker to check if the model is deadlock free. When a deadlock is found, a counter-example trace which led to the deadlock is generated. Their formal-ization focuses only on the asynchronous communication between objects within fUML which has been guided by their case study.

To the best of our knowledge, our work is the first attempt to formalize the tokens game of the fUML standard to verify process models. If a comparison is made between the above-mentioned work, our approach is not relying on the semantics and concepts of the targeted formal language in terms of expressive-ness, e.g. Petri Nets, instead of the modeling language. In these approaches, the assumption is made that the semantics choices made in these formal techniques are valid as well for UML AD. This paper proposes a first-order logic formalization of the newly defined fUML specification to verify fUML-based proces s models. The formalization is able to deal with the control-and data-flow, resources, and timing aspects of the process in a unified way. A tool implementation based on the Alloy modeling language has been successfully integrated in an Ec lipse-based process environment. The tool is able to verify automatically a wide range of properties without the user X  X  intervention and allows one to verify some business properties. Currently, the tool is under evaluation within the European MERgE project, which main goal is to develop and demonstrate innovative concepts and design tools addressing both  X  X afety X  and  X  X ecurity X  concerns in development processes.

The case study and the tool proved the feasibility of our approach, how-ever some improvements are already under realization. The first one consists in covering the formalization of mor e UML AD concepts that can be of in-terest for the modeling of more complex processes. Examples of such concepts are DataStoreNode (a buffer for non-transient data), AcceptEventAction and SendSignalAction (for dealing with events) and StructuredActivity (expan-sion, loop, conditional nodes). Moreover, we are working on extending the for-malization to be data-aware . Currently, the contents of the tokens within the ObjectNode s are not taken into account. This prevents, for example, to ex-press guard on edge to determine if the edge can be traversed. Some formal-izations have taken some of these concepts into accounts [8]. However, much simplification has been done in comparison of the way fUML operates and only integers are considered. In fUML, each tokens can have a simple value type (in-teger, string, natural, boolean) or more complex Classifier type defined in a Class Diagram. Then, tokens are manipulated using the action nodes from the IntermediateActions package. This package defines the classical actions to create, read, suppress and modify tokens at runtime within the AD and formal-izing such concepts is a non-trivial task. Finally, we are exploring optimizations techniques to treat the properties rela ted to time in a more efficient way based on the expertise of well-known approaches such as timed automata.
 Acknowledgments. This work was funded by the MERgE project (ITEA 2 Call 6 11011).

