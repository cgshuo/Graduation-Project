 1. Introduction
The Web Services Business Process Execution Language (WS-BPEL) [1] is a language for describing the behavior of business processes based on web services. A WS-BPEL process or process for short can be seen as a workflow enhanced by an interface description specifying the interactional behavior of this process with other processes, its partners . The interaction between processes may be nontrivial. Thus, it is a challenging task to decide whether all processes interact properly ; that is, the interaction is free of deadlocks and there are no messages being sent that cannot be received any more. There are two main reasons for improper interaction: (1) A process may have an erroneous design. For instance, the process may contain an internal choice relevant for the expected behavior of a partner, but the partner is not informed which decision is actually made. (2) The interactional behaviors of two processes exclude each other. For example, the processes run into a situation where one process waits for a message of the other one and vice versa. Therefore, tool support is needed to assist process designers during the modeling.

In [2] , we presented a technology chain that starts out with a BPEL4WS [3] process, Petri net model, and finally analyzes this model. We introduced two tools: BPEL2oWFN and Fiona. BPE-
L2oWFN translates a process into an open workflow net (oWFN), a special class of Petri nets modeling the interactional behavior of its corresponding BPEL process. Fiona then analyzes whether this oWFN is control-lable . An oWFN is controllable [4,5] if there exists a partner such that both can interact properly. Fiona can also calculate the operating guideline of a given oWFN. The operating guideline characterizes all properly interacting partners in a compact way [6] . In addition, BPEL2oWFN also supports the translation into Petri nets modeling the internal behavior only. These nets can be analyzed by common model checkers.

In this paper, we improve the proposed technology chain presented in Fig. 1 . Firstly, BPEL2oWFN is no longer restricted to processes specified in BPEL4WS. It now also translates processes compliant to the current WS-BPEL specification. To the best of our knowledge, this is the only formal semantics for WS-BPEL 2.0.
Compared to the BPEL4WS specification, WS-BPEL 2.0 contains many new activities and other constructs, and clarifies the semantics of several complex scenarios such as compensation. Secondly, we further improved the translation to generate compact Petri net models. We introduce our concept of a flexible model generation that was only sketched in [2] . The idea is to have, for each WS-BPEL construct, several patterns that are appli-cable in different contexts. Using static analysis on the WS-BPEL code, information is derived to select the most abstract pattern applicable in a given context. With the help of data abstraction, the complexity of WS-BPEL processes of realistic size is reduced in such a way that they can be efficiently analyzed.
It is worthwhile to mention that the concepts of this paper are not restricted to analyze WS-BPEL processes only. The concept of flexible model generation as implemented in BPEL2oWFN can be applied to any other process description language and likewise to any other target formalism. Our presented model, open workflow nets, is a general formalism that can be used to model various kinds of interacting processes. Since the algo-rithms of Fiona are based on oWFNs we are not restricted to a specific process description language like WS-BPEL.

The paper is organized as follows. In Section 2 , we introduce the general concepts of WS-BPEL and our model, open workflow nets. We also explain controllability of oWFNs and the operating guideline of an oWFN. A WS-BPEL example process, an online shop, is presented in Section 3 . Our main contribution is pre-sented in Section 4 , where we explain the concepts of our advanced translation and especially flexible model generation. It is exemplified by translating the online shop into an oWFN. The resulting oWFN is then ana-lyzed in Section 5 . We present a slightly modified version of that process in Section 6 and analyze it, too. In
Section 7 , we describe related work. Finally, we conclude with some directions for future research. 2. Background 2.1. WS-BPEL
The Web Services Business Process Execution Language (WS-BPEL) [1] is a language for describing the behavior of business processes based on web services. For the specification of a business process, WS-BPEL provides activities and distinguishes between basic and structured activities. A basic activity can communicate with the partners by messages ( invoke , 2 receive , reply ), manipulate or check data ( assign , vali-date ), wait for some time ( wait ) or just do nothing ( empty ), signal faults ( throw ), or end the entire process instance ( exit ).

A structured activity defines a causal order on basic activities and can be nested in another structured activ-ity itself. The structured activities are sequential execution ( sequence ), parallel execution ( flow ), data-dependent branching ( if ), timeout-or message-dependent branching ( pick ), and repeated execution ( while , repeatUntil , forEach ). The most important structured activity is a scope . It links an activity to a transaction management and provides fault, compensation, event, and termination handling. A process is the outmost scope of the described business process.

Activities embedded in a flow can be further ordered by links . A link connects a source activity with a target activity. The source may specify a Boolean expression, the status of the link. The target may also specify a Boolean expression (the join condition) which evaluates the status of all incoming links. The target activity is only executed when its join condition holds. WS-BPEL provides dead-path elimination ; that is, the status of all outgoing links of a skipped source activity (e.g., due to an unchosen pick branch) are set to false.
A Fault handler is a component of a scope that provides methods to handle faults which may occur during the execution of its enclosing scope. Moreover, a compensation handler can be used to reverse some effects of successfully executed activities. Compensation of a process is started with the compensate activity which calls the compensation handlers of completed scopes in reverse execution order. With the help of event han-dlers, message events and specified timeouts can be handled. Finally, a termination handler controls the behavior during the termination of a scope. 2.2. Open workflow nets
Open workflow nets (oWFNs) [7] are a special class of Petri nets and can be seen as a generalized version of van der Aalst X  X  workflow nets [8] . As a substantial difference, in an oWFN the interface of a process is explic-itly represented as sets of input and output places. In our model, we assume asynchronous message passing.
We concentrate on control flow aspects of processes and abstract from data like the content of messages, for instance. For data with finite domain, however, important message content can be represented by unfolding the data domain. Hence, oWFNs provide a simple but formal representation of processes, still preserving suf-ficient information to analyze proper interaction of such processes. We will describe our approach in a section later on.

We assume the usual definition of Petri nets. An open workflow net is a Petri net N =( P , T , F ), together with then ( t , p ) 6 2 F (( p , t ) 6 2 F ); a distinguished marking m markings, called the final markings . The places in in ( out ) are called input ( output ) places. The inner of an oWFN N can be obtained from N by removing all interface places, together with their adjacent arcs. As a convention, we label a transition t connected to an input (output) place x with ? x (! x ). As an example, consider the oWFN N 1 depicted in Fig. 2 .

The interplay of two oWFNs N and M is represented by their composition , denoted by N M . Thereby, we assume that the nets only share input and output places such that an input place of N is an output place of M and vice versa. Then, N M can be constructed by merging joint places and merging the initial and final markings.

A marking (also called a state ) m of N is called a deadlock if m enables no transition. An oWFN in which each deadlock is a final state is called weakly terminating . Obviously, the net N terminating. N 1 requires a partner who sends and receives messages. N [ p6,p7 ] on its own. Given an oWFN N , we call an oWFN S a strategy for N iff N S is weakly terminating. A weakly terminating oWFN can still contain livelocks. In a livelock, the net changes its state without progress-ing and eventually terminating. oWFNs can be canonically extended to high-level oWFNs to model data. However, during our analysis only low-level oWFNs are used. Throughout this paper we restrict ourselves to oWFNs N and S where
N S can reach only a finite number of states. Technically, we demand that the inner of N and the inner of S have finite state spaces and that there exists a number b , called message bound , such that any message exchanged between N and S is only sent at most b times. 2.3. Controllability of oWFNs
Intuitively, controllability of an oWFN N means that N can properly interact with some other net. For-mally, N is controllable iff there exists a strategy for N . Like the soundness property for workflow nets (cf. [8] ), controllability is a minimal requirement for the correctness of an oWFN.

In [5] , we developed an algorithm to efficiently decide the controllability of an oWFN N . Intuitively, the algorithm tries to construct (synthesize) a strategy (i.e., an oWFN S ), which imposes the weak termination property of S N . If the construction fails, N is not controllable. If it succeeds, N is controllable and we have constructed a strategy S . This construction is, in fact, a problem known in the literature as controller synthesis (see [9] ). Technically, we do not construct a strategy S , but an automaton that reflects the interactional behav-ior of S instead. To avoid confusion, we call the constructed automaton controller , but denote it with S as well.
The idea of the construction algorithm is as follows. A node of the controller S represents the set of all states that N can reach by consuming (already present) messages or by producing messages itself. The actual state of N is hidden for S . S knows the history of sent and received messages only. From that information, in each node, S can deduce a set of states of N which contains the state that N is really in. Thus, a node of S represents a hypothesis of S with respect to the actual state of N . If a hypothesis contains a (nonfinal) dead-lock, then S has to resolve that deadlock by receiving or sending messages.

As an example, a controller for the oWFN N 1 (see Fig. 2 ) is depicted in Fig. 3 . It is easy to see that each deadlock in any node (except for the final marking in the last node) is resolved. Hence, a controller could be constructed and we conclude that N 1 is controllable. There are many other controllers for N be found.

As a last step, a controller could be transformed into an oWFN by using the theory of regions [10] , for instance. This oWFN is then a strategy by construction. 2.4. Operating guidelines of oWFNs While controllability aims at constructing one strategy for a given oWFN N , the operating guideline (OG) of before, we do not directly represent the strategies as oWFNs, but represent their behaviors as automata. With the help of the OG of N , it can easily and efficiently be predicted whether or not an oWFN S is a strategy for N before actually composing S and N .

The construction idea is as follows. The basis of the OG is again a controller, denoted by S . As the main difference to the controller which is constructed to decide controllability, S must be most permissive . That means, S must contain all possible controllers of N . Therefore, we first construct a full automaton F that performs each event at any node. This automaton is finite since N has only a finite number of states. This is bounded by b . S is now constructed from F by removing X  X n an iterative process X  X uch nodes that contain (nonfinal) deadlocks which are not resolved. In [11] , we have shown that the resulting S is indeed most per-missive and well-suited as a basis for the OG. In a last step, we add Boolean annotations to the nodes of S that describe how we can obtain other controllers from S [11] . The most permissive controller together with the annotations is called the operating guideline of N .

Fig. 4 shows the operating guideline of the oWFN N 1 depicted in Fig. 2 . In a node of the OG, the corre-sponding annotation is depicted. The reachable states of N
Given a controller representing an intended partner X  X  behavior, we developed an algorithm to check whether it is characterized by a given OG or not [11] . 3. Example process: online shop
In this section, we present an online shop as our example process. It is a nontrivial extension of the process presented in [2] . The online shop X  X  WS-BPEL process consists of 25 activities, a fault handler, an event han-dler, and a compensation handler. The shop is depicted in Fig. 5 in a common graphical notation.
When the online shop receives the login information from a customer, its business strategy distinguishes between premium and standard customers (upper if statement). The premium customer gets a special offer from the shop, for example a discount for the items to be purchased. The standard customer, however, receives a confirmation message ( confirm ) and has to accept the terms of payment first and does not get any kind of offer. Then, either customer can buy goods at the shop. This is modeled with a repeatUntil loop which initially demands the user to place an order ( please _ order ). As the customer chooses an item to buy ( order ), all the necessary information is stored in a database. This procedure is not modeled in our WS-BPEL process. If the ordered item is available, the shop sends out a notice that the order has been accepted ( order _ accepted ). The customer may then choose another article to add to his cart or he may finish shopping (modeled by the
Boolean choice message). In the end, the shop concurrently sends out the invoice and delivers the goods pur-chased ( deliver ).

In case an item is out of stock , the shop throws the out _ of _ stock _ fault to its fault handler. Now the fault handler first informs the customer ( out _ of _ stock ) and gives him the possibility to cancel the whole order or order is compensated ( compensate ) by the shop, meaning that the respective database entries are deleted.
To model this procedure, we scoped the order process and linked it to a compensation handler attached to it. That way, we make sure that each order will be compensated. In case the customer would like to get all chosen items ( deliver _ rest ), an invoice is generated and the articles are sent out ( deliver ) concurrently.
The customer may send an abort message at any time. We modeled this as an event handler that receives the abort message and then terminates ( exit ) the whole process. 4. Translating WS-BPEL to open workflow nets 4.1. Open workflow net semantics for WS-BPEL
We aim at formally analyzing WS-BPEL processes. To achieve this aim, we translate a WS-BPEL process into an oWFN. The translation is guided by the syntax of WS-BPEL. In WS-BPEL, a process is built by plug-ging instances of WS-BPEL constructs together. Accordingly, we translate each construct of the language separately into an oWFN. Such a net forms a pattern of the respective WS-BPEL construct. Each pattern has an interface for joining it with other patterns as it is done with WS-BPEL constructs. The semantics aims at representing all properties of each WS-BPEL construct within its respective pattern. An example for an oWFN pattern is depicted in Fig. 6 . As the semantics itself is not the focus of this paper, we only summarize the main ideas of it.

The collection of patterns forms our oWFN semantics for WS-BPEL. The semantics is complete ; that is, it covers all the standard and exceptional behavior of WS-BPEL such as fault, compensation, event, and termi-nation handling, including arbitrarily nested scopes and repeatable constructs such as loops. In addition, all data aspects of WS-BPEL are modeled. Furthermore, the semantics is formal , meaning it is suitable for com-a WS-BPEL process can be translated into an oWFN model. Thus, partner links cannot be dynamically chan-ged. Secondly, time (e.g., for the wait activity) is not modeled.

The original semantics [12] was designed to formalize BPEL4WS rather than to create compact models that are necessary for computer-aided verification. Some patterns were easy to understand yet made use of quite  X  X  X xpensive X  X  constructs such as reset arcs. We improved these patterns and replaced them by less intuitive pat-terns with simpler structure. In particular, the complex interplay of the fault, compensation, event, and termi-nation handlers was condensed. As the main extension, the new semantics [13] covers all features of WS-BPEL 2.0, the successor of BPEL4WS 1.1. 4.2. Flexible model generation in BPEL2oWFN
The extended semantics is implemented in the tool BPEL2oWFN. other file formats (e.g., PNML, PEP, LoLA, INA, SPIN) and thus supports a variety of analysis tools. In con-trast to its predecessor BPEL2PN [14] , it does not follow a brute-force mapping approach which resulted in huge models for processes of realistic sizes. This enables a more efficient analysis.

The main reason for a vast model size is the translation of dead code; that is, parts of the WS-BPEL process that are unreachable. Furthermore, aspects that are not necessary for the analysis goal (e.g., controllability, deadlock-freedom) can be skipped. To scale down the model size, BPEL2oWFN employs flexible model gen-eration , an approach to generate a compact model tailored to the analysis goal. The model is minimized both during and after the translation process. In contrast, similar tools (e.g., WofBPEL [15] ) only apply structural reduction rules after performing a brute-force translation. Fig. 7 presents an overview of our proposed framework.

Firstly, the input WS-BPEL process is parsed and an abstract syntax tree (AST) is built. It contains infor-mation about the syntax of the process such as structure, contained activities, and used attributes, for instance.
All information gained from further analysis steps will be annotated to the AST. Later on the annotated AST is used to generate the oWFN model. The AST is also used to apply implicit transformation rules specified in the WS-BPEL specification to WS-BPEL constructs. Those transformation rules are a short-hand notation, that will be extended as the process is interpreted. For example, a scope can be specified without handlers. Then, an implicit transformation rule demands, that the standard handlers have to be added to this scope .
Another example is that an invoke activity my have a nested fault handler. Here an additional scope has to be added according to a transformation rule.

However, the AST is not suitable for more sophisticated analysis steps as it only represents the syntactical structure of the input process. To this end, BPEL2oWFN builds a control flow graph (CFG) of the process. This graph represents all execution paths (i.e., all orders of activities) the process might traverse. Hence,
CFG analysis results can be safely mapped back to the original process. All obtained results are annotated to the AST and affect the subsequent translation process.

On the CFG, standard static analysis techniques (see [16] for an overview) are applied. Among others, the scope hierarchy and the link dependencies can be derived from the CFG and used for further analysis. In addi-tion to the control flow, we also add the data flow between activities and variables to the CFG. In our current work, we only model the data flow , and do not take data values into account. However, storing information about the data flow, for example from a receive to a variable and then to a reply allows to detect read access to uninitialized variables. The CFG with annotated data flow is the data structure for the following static analysis techniques.

On the CFG, we can estimate the control dependency relation which describes the partial execution order of the activities. This relation is used to calculate the compensation order of scopes. WS-BPEL provides the concept of dead-path elimination which is applied if an activity is skipped (e.g., due to an unchosen pick branch). In this case, all directly or indirectly embedded links have to be set to false. Instead of setting theses links to false recursively one by one, the control dependency relation allows to set these links to false imme-diately when the considered activity is skipped. Replacing the recursive setting of links to one step avoids many intermediate states in the resulting model.

It is also possible to detect dead code. The scope hierarchy together with the control flow allows to identify compensation handlers that will never be called since an according compensate activity is missing. Similarly, termination and fault handlers can be marked unreachable. Thus, they will be skipped during the subsequent translation process. Moreover, the CFG is also used to optimize the resulting model. For example, the flow of faults from their source (e.g., a throw activity) to the fitting fault handler can be explicitly modeled, avoiding unnecessary intermediate states or routing constructs.
So far we only gained context information and used this information to annotate the AST. In the next step, the AST together with the user-defined analysis goal is used to generate the most abstract model fitting to this analysis goal. For this purpose, we implemented a pattern repository which contains X  X n addition to a generic pattern X  X everal patterns for each activity or handler, each designed for a certain context. As an example, con-sider the scope activity: For this activity we provide a pattern with all handlers, a pattern without handlers, a pattern with an event handler only, etc. In general, specific patterns are much smaller than a generic pattern where the absent aspects are just removed. In addition, each pattern usually has diverse variants according to the user-defined analysis goal. For example, a certain analysis goal demands the modeling of the negative con-trol flow or the occurrence of standard faults, whereas another goal does not. In the translation process, for each node of the AST, a Petri net pattern is selected from this pattern repository according to the annotations. The process is finally translated by composing all selected patterns to a single oWFN.

Currently, the implemented patterns abstract from data since variables in WS-BPEL have an infinite data domain in general. If we would translate the process to a high-level oWFN, it may have an infinite state space which makes subsequent analysis impossible. On this account, BPEL2oWFN abstracts from time and instances due to the limitations of the oWFN semantics and it also abstracts from data. As a result, models generated by BPEL2oWFN are low-level oWFNs. Messages and the content of variables are modeled by undistinguishable black tokens. Data-dependent branches (e.g., WS-BPEL X  X  if ) are modeled by nondetermin-tunately, the skeleton net only weakly preserves controllability: if the skeleton net is controllable, so is the high-level oWFN and therefore the WS-BPEL process is controllable, too. The converse does not hold in gen-eral. The proof of weak preservation is subject of current research. In case a process has a finite data domain (e.g., data of type Boolean), the resulting high-level oWFN net can be unfolded into a low-level oWFN with-out loss of information. Fig. 8 d illustrates this.

After the translation process, structural reduction rules are applied to further scale down the size of the generated oWFN model. For each user-defined analysis goal (e.g., controllability or reachability), adequate reduction rules (adapted from [18] ) preserving the considered property are selected. Combined with a removal of structurally dead nodes, the rules are applied iteratively. In addition, the information gathered by static analysis allows for further removal of oWFN nodes that are not affecting the analysis. For example, we remove places that model the negative state of a link which will never be set to true.
The annotation of the AST with the information gained by static analysis introduces domain knowledge into the translation process. In contrast, only domain independent X  X nd thus usually weaker X  X eduction tech-niques such as structural reduction are applicable once the model is generated. We claim that flexible model generation combining domain-dependent and domain-independent reduction techniques is able to generate very compact models especially tailored to the considered analysis task. Furthermore, the concept of flexible model generation is independent from the output formalism, and can be adapted to other formalisms, for example process algebras or finite state machines. In addition, also the input language is not restricted to WS-BPEL.

The generated model can now be analyzed according to the analysis goal. In this paper, we focus on the analysis of the communicational behavior of WS-BPEL processes and introduce the tool Fiona in Section 5 . However, detection of unreachable activities by using model checkers such as LoLA is possible, too. In addition to the presented CFG-based algorithms, BPEL2oWFN also uses the CFG to check 44 of the 94 static analysis requirements 5 proposed by the WS-BPEL specification. They enable BPEL2oWFN to statically detect cyclic control links, read access to uninitialized variables, conflicting receive activities (two concurrent receive activities are waiting for the same input message), or other faulty constellations. 4.3. Translating the online shop
Using BPEL2oWFN, we now translate the online shop example process into an oWFN. Since we want to calculate the operating guideline of the process, we use patterns preserving all strategies. The translation gen-erates a skeleton net except for the input message choice and its associated variable choiceVar (cf. Fig. 8 a), which are unfolded as depicted in Fig. 8 d. Thus, the loop can be controlled by the customer by sending mes-sages to the unfolded input places choice . true and choice . false , respectively.

The flexible model generation approach especially optimizes the translation of several handlers of the online shop. For example, the scope has a standard fault and termination handler that are added when building the
AST. However, CFG analysis marks these handlers unreachable, as the scope can neither throw a fault nor can it be forced to abort due to a fault. Thus, a very compact pattern can be chosen from the pattern repos-itory to translate this scope.

Table 1 compares the sizes of the resulting oWFNs of the different translation approaches. Flexible model generation with subsequent structural reduction rules yields the smallest oWFN. Also the state space of the inner of the resulting oWFN is affected: The number of reachable states is reduced from 6358 (brute force, no structural reduction) to 543 (flexible model generation, structural reduction). As the nodes of the IG consist of subsets of reachable states, this reduction rigorous for the analysis of WS-BPEL processes of realistic size. 5. Analyzing the interaction of oWFNs 5.1. The tool Fiona
Fiona 6 is a tool to automatically analyze the interactional behavior of a given oWFN N . The input format of Fiona is the oWFN output format of BPEL2oWFN. Hence, we can easily analyze WS-BPEL processes.
Fiona provides two techniques: it checks for the controllability of N or it calculates the operating guideline of N .
 The algorithm to construct the OG as described in Section 2.4 performs three steps: first, a full automaton F is constructed, then, nodes with unresolved deadlocks are iteratively removed from F to get the controller
S , and finally, the annotations are computed from the state information in the nodes of S . Since F is a the-oretical construct which is enormously big for practical processes, the implemented algorithm in Fiona is different: (1) The construction of F is based on a depth-first approach, with the three steps of the theoretical algo-(2) Static analysis information of the process calculated by BPEL2oWFN can be used to suppress events at (3) In some cases we can conclude that a node has to be removed later on before knowing all of its succes-(4) To speed up the computation, the nodes that contain (nonfinal) deadlocks are not removed. They are (5) To compute the reachable states of N inside a node of the IG, we use techniques and data structures that
If Fiona is used to decide controllability, it is sufficient to construct a much smaller controller. Thus, several further reductions can be applied while the IG is constructed [5] . For example, if it is possible to receive one message or to send another message at one particular node, it is sufficient to only consider the receiving event and to skip the sending event.
 5.2. Analyzing the online shop model
We now analyze our online shop example from Section 3 . Firstly, we use Fiona to calculate the IG of the corresponding oWFN which we got from Section 4.3 . The computed IG consists of 14 nodes and 14 edges (see
Fig. 9 ). Since the controller is nonempty, the online shop is controllable. The IG reflects one particular con-troller that orders exactly one item.

The controller of Fig. 9 reflects the intended behavior of a customer. First, he sends a login ( !login ). After-wards, he must be able to either receive the confirmation ( ?confirm ) in case he is a standard customer or to receive the shop X  X  offer ( ?offer ) in case he is a premium customer. If he has received the confirmation, he must send a terms of payment message ( !terms ). In either case the customer receives a message from the shop that he can start ordering ( ?please _ order ). After placing the order, the customer has to be able to receive an out of After the order has been accepted, this customer finishes by sending an appropriate message ( !choice. false ). celed ). If he wants to receive the order, he gets the items and the invoice.

We let Fiona compute the OG of the shop, too. The OG consists of 67 nodes and 146 edges and includes customers that buy multiple items (bounded by the message bound b ). The graph is too big to be depicted in this paper. Compared to the IG of Fig. 9 , the OG also contains more interleavings of sending or receiving messages. For instance, a customer may reverse the order of sending the login and the order message. 6. The online shop revised
Let us take a look at the online shop presented in Section 3 once again. The shop now slightly modifies its business strategy: every premium customer may choose a gift after login. The modified online shop is depicted in Fig. 10 a.

The changes only affect the left branch of the first if -statement. The shop sends a login confirmation ( con-firm ) first and then expects the customer to choose a gift . The rest of the process is as in Fig. 5 . The analysis with Fiona reflects that this simple change has a crucial effect on the behavior of the process.
Our algorithm concludes that the process is controllable, too. The IG of the revised online shop has only 5 nodes and 4 edges, which is less than the controller for the original shop. However, the reflected strategy is not an expected one. The controller in the IG represents a customer who sends an abort message during the interaction.
 The IG represents only one customer X  X  behavior. For further information we need Fiona to calculate the
OG. It is depicted in Fig. 10 b. Independent from the message bound it consists of the same 5 nodes and the same 4 edges as the IG. The OG reveals that actually every customer of the modified shop must eventually send an abort message. This surely means that the process is controllable. However, the way this is done is obviously not intended. There is no way that a customer can order an item and gets an item delivered.
Let us take a look at what went wrong when we modified our online shop from Section 3 . We can see that the shop does not communicate its inner decision about which branch (premium customer, standard customer) is chosen. In the original online shop ( Fig. 5 ) the controller received an offer from the shop or a confirmation message according to which branch the shop has chosen before. That way, the controller can conclude which branch the shop is actually in and hence knows how to continue. In contrast in the modified shop, the con-troller receives undistinguishable confirmation messages in either case. The modified shop expects a choice of a gift in case it decided for the premium customer branch. In the other case it expects the terms of payment. The controller, however, does not know about the decision of the shop. That means, it does not know which mes-sage to send. This is reflected by the OG of the new shop (see Fig. 10 b): in the situation, where a partner receives the confirmation he does not know whether the shop decided for the left or the right branch. Hence, he could choose either to send a gift choice or the terms of payment. In either case it is not guaranteed that the message will always be consumed, and therefore it should not be sent in the first place. However, sending an abort is always correct.

This simple example shows that even a small modification of a process may result in an unintended inter-actional behavior. The effect on the interactional behavior of a process is not obvious. Since this is not obvious in our shop example, it is even more challenging for processes from industry. In general, processes may have a complex structure that it is not possible to detect such erroneous structures in the process manually. With the help of the operating guideline, we can see if there exists a controller that interacts with our process as we have expected it during the process design.
 7. Related work
Several groups have proposed formal semantics for BPEL4WS 1.1. Among them, there are semantics based on finite state machines [20,21] , the process algebra Lotos [22] , abstract state machines [23,24] , and Petri nets [25,12] . However, to the best of our knowledge, the Petri net semantics proposed in this paper is the only for-mal semantics for WS-BPEL 2.0.

The groups of van der Aalst and ter Hofstede also follow a Petri net-based approach [25] . Their semantics, however, is restricted to BPEL4WS and does not cover the communication of processes. Furthermore, they do not consider data and, as in our approach (see Section 4.1 ), time is not modeled and only a single process instance is translated. Thus, the resulting models are (low-level) workflow nets [8] . The translation is auto-mated by the tool BPEL2PNML. In contrast to the concept of a flexible model generation implemented in
BPEL2oWFN, BPEL2PNML provides only a single pattern for each BPEL4WS construct and the resulting net is only minimized after the translation by applying structural reduction rules. The semantics enables sev-eral analysis methods including the detection of unreachable activities and design flaws such as conflicting receive activities. Further, it is possible to perform a reachability analysis for the garbage collection of incon-sumable messages later on. Those methods are implemented in the tool WofBPEL [15] . However, WofBPEL does neither analyze the interactional behavior of processes (due to the restrictions of the semantics) nor does it support static analysis techniques.
 Martens et al. [26] translate BPEL4WS processes into an annotated subset of oWFNs, BPEL annotated
Petri nets (BPNs). The translation is based on a modified version of our old semantics in [12] and does not include most of the fault and compensation handling. For BPNs, a technique for analyzing the controllability has already been introduced in [27]  X  X he communication graph . It is similar to our proposed IG. As a main difference, this graph performs communication steps , where each step consists of a (possibly empty) sending phase followed by a (possibly empty) receiving phase. Therefore, the communication graph tends to be more complex than our IG (cf. [5] ). Finally, Martens X  analysis tool Wombat does not support the construction of operating guidelines, but it can visualize the analysis results both in the Petri net and in the BPEL4WS code. 8. Conclusion and further work
We presented a framework to formally analyze the interactional behavior of WS-BPEL processes. Both the translation from WS-BPEL into compact Petri net models as well as the further analysis of controllability and the computation of the operating guideline are implemented which allows for a fully-automatic analysis. The results show that we can detect nontrivial model flaws of interacting WS-BPEL processes that would have been hard or impossible to find manually.

In BPEL2oWFN, we have implemented the concept of a flexible model generation (see Section 4.2 ). This approach tries to reduce the Petri net model during and after the translation with respect to the property to be analyzed. For this purpose, for each WS-BPEL activity, several Petri net patterns with different degree of abstraction are available in a pattern repository. Using static analysis on the WS-BPEL code, we select the most abstract pattern applicable in a given context. Static analysis is further used to provide additional infor-mation for the analysis. Furthermore, to deal with the complexity of WS-BPEL X  X  data, we unfold finite data domains (e.g., Boolean) and construct the skeleton net to abstract from data. Flexible model generation results in compact models preserving the user-defined analysis goal. That way, it is possible to analyze WS-BPEL pro-cesses of realistic size.

In ongoing research we are working on abstraction techniques that allow to map an infinite data domain to a finite domain while preserving more properties than the skeleton net. For that purpose, we adapt state-of-the-art data abstraction techniques such as predicate abstraction [28] and integrate them into our translation approach. Furthermore, we are also planning to enhance our Petri net semantics to cover multiple instances.
To analyze interactions consisting of more than two interacting processes, existing theoretical results have to be integrated into Fiona. We are further working on more efficient reduction techniques, both for IG and
OG. We also aim at supporting the redesign of erroneous (e.g., non-controllable) processes. For this purpose, the analysis results (e.g., counter-examples) have to be translated back into WS-BPEL source code. This will be extremely helpful to assist process designers during the modeling.
References
