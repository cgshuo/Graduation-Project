
In this paper, we introduce the concept of  X  -orthogonal patterns to mine a representative set of graph patterns. In-tuitively, two graph patterns are  X  -orthogonal if their sim-ilarity is bounded above by  X  . Each  X  -orthogonal pattern is also a representative for those patterns that are at least similar to it. Given user defined  X ,  X   X  [0 , 1] , the goal is to mine an  X  -orthogonal,  X  -representative set that minimizes the set of unrepresented patterns.

We present ORIGAMI , an effective algorithm for mining the set of representative orthogonal patterns. ORIGAMI first uses a randomized algorithm to randomly traverse the pat-tern space, seeking previously unexplored regions, to retu rn a set of maximal patterns. ORIGAMI then extracts an  X  -orthogonal,  X  -representative set from the mined maximal patterns. We show the effectiveness of our algorithm on a number of real and synthetic datasets. In particular, we show that our method is able to extract high quality pat-terns even in cases where existing enumerative graph min-ing methods fail to do so.
Increasingly, today X  X  massive data is in the form of com-plex graphs or networks. Examples include the physi-cal Internet, the world wide web, social networks (includ-ing blogs, chat rooms, phone networks, and networking web-sites), biological networks (including protein inter ac-tions networks and bio-chemical compounds). Mining such databases for graph patterns has attracted a lot of interest in recent years.

Typical graph mining methods follow the combinatorial pattern enumeration paradigm, and aim to extract all fre-quent subgraphs, perhaps subject to some constraints. In many real-world applications arising in bioinformatics an d social network analysis, the complete enumeration of all patterns is practically infeasible, due to the combinatori al explosion in the number of mined subgraph patterns. For example, on a set of six proteins taken from the HOM-STRAD database of homologous protein structures (see dataset PS in Section 5), a typical enumerative graph min-ing method (we used gSpan [14]) did not finish running in even 2 days. These six graphs contain common motifs of size over 50-60 residues, thus any method that tries to enu-merate all subgraphs is simply unable to mine this dataset. In fact, mining only the closed or even the maximal patterns in such domains can be untenable.

Aborting the mining process prematurely does not help either, as there is no guarantee that the resulting set of pat -terns is representative in any sense. Typically, one can ex-pect that the patterns cover only a small region of the out-put search space (e.g., a breadth-first search approach will have seen patterns only up to some level, and a depth-first method may have seen patterns covering branches up to some point). For example, we ran a depth-first graph min-ing algorithm [5] on a protein-interaction dataset consist ing of three graphs (see dataset PI in Section 5), each graph having 2154 nodes, and on average 81607 edges, with total database size 3MB. The mining process was aborted after a day of running, at which point it had generated a 7GB output file containing over 8 million subgraphs. The largest mined graph had only 22 edges; there were 57 such sub-graphs, but these had a similarity of over 95% (differing in only a few edges), indicating that only a small fraction of the possible output space had been seen.

Note also that in many real-world cases, enumerating all frequent patterns is not necessarily the primary objective . Rather, mined patterns are likely to be used as inputs for a subsequent analysis/modeling step, and as such, a rela-tively small representative set of patterns may suffice. For example, mining frequent motifs in protein structures sets the stage to solve problems like structural alignment, ho-mology detection, etc. Recurring patterns in a social net-work can be used for link prediction, de-duplication, hidde n group identification, etc. Frequent patterns obtained from network log data can be used to build classification model that can predict network intrusion and other anomalous be-havior. None of these applications requires the entire set o f frequent patterns. Note also, that the lack of interpretabi lity and the curse of dimensionality due to a large set of redun-dant patterns can cause problems for subsequent steps like clustering and classification. Many successful applicatio ns of pattern mining for solving real-life problems thus requi re the result-set to be a summary , rather than a complete set of the frequent pattern space.

In this paper, our goal is to address all of the above limi-tations that prevent graph mining to be applied in real-worl d problems. Instead of enumerating all graph patterns, we aim to mine a relatively small set of representative pattern s that share little similarity with each other. More specifi-cally, given user-defined parameters  X ,  X   X  [0 , 1] , our goal is to find an optimal  X  -orthogonal  X  -representative set of patterns. Two patterns are said to be  X  -orthogonal if their similarity is at most  X  , and a pattern is said to be a least  X  . Instead of enumerating the entire set of subgraph patterns, we employ a randomized (but principled) search over the partial order of subgraph patterns, to obtain a rep-resentative sample of the possible output space (of maxi-mal patterns). The aim is to cover, or traverse, different unexplored parts of the partial order yielding potentially representative patterns. In a second step, a locally optima l orthogonal representative pattern set is extracted from th e output sample. The main contributions of our paper are as follows:  X  We propose a new paradigm for mining a summary  X  We introduce a randomized approach for mining max- X  We formulate the  X  -orthogonal  X  -representative set
Our algorithm that finds the  X  -orthogonal  X  -representative set is called ORIGAMI (which stands for O rthogonal R epresentat I ve G r A ph MI ning). We demonstrate the effectiveness of ORIGAMI on a variety of synthetic and real dataset, and show that it is able to mine good quality orthogonal representative sets, especially for datasets where traditional enumerative methods fail completely.
Many recent methods have been proposed for graph min-ing; these include [4, 8, 9, 14, 6, 10]. The focus of these methods is to mine all frequent subgraph patterns, rather than finding orthogonal or representative patterns. There i s also an increasing interest in using the mined graph pattern s for indexing [16].

There are several works guided towards finding a subset of frequent patterns that are most informative, compressed , discriminative and non-redundant [1, 13, 12, 3]. However, all these previous works handle itemset patterns only. In th e graph domain, we did not find any work on compressed fre-quent patterns, except, works on closed frequent graphs [15 ] and maximal frequent graphs [11, 7]. Even though these two approaches generate a smaller set of patterns, the num-ber of patterns in both cases can still be very large. More-over, many patterns in the resulting sets can be very similar , hence, they may not be appropriate as a summary or repre-sentative pattern set.

We present a set of frequent graphs that are representa-tive of the entire frequent graph partial order. Each elemen t in representative set is more than  X  distant from the oth-ers. Moreover, since graphs represent the most general type of patterns, a solution to this problem in the graph setting automatically covers the other pattern types like itemsets , sequences and trees. Graphs and Subgraphs: A graph G = ( V, E ) , consists of a set of vertices V = { v vertex and edge labels, respectively, and let V : V  X  L and E : E  X  L to each vertex and edge. The size of a graph G , denoted | G | is the cardinality of the edge set (i.e., | G | = | E | ). A graph of size k is also called a k -graph. A graph is connected if each vertex in the graph can be reached from any other vertex. All graphs we consider are undirected, connected and labeled.

A graph G G 2 = ( V 2 , E 2 ) 1 mapping f : V plies ( f ( v isomorphism from G G G set of graphs, then we write G  X  D if  X  D is said to be a maximal common subgraph of D iff G  X  D , and 6  X  H  X  G , such that H  X  D .
 Graph Support: Let D be a database (a set) of graphs, and let each graph D note by t ( G ) = { i : G  X  D set (gidset) , which consists of all graphs in D that contain a subgraph isomorphic to G . The support of a graph G in D is then given as  X  ( G, D ) = | t ( G ) | , and G is called frequent if support ( minsup ) threshold. A frequent graph is closed if it has no frequent super-graph with the same support. A fre-quent graph is maximal if it has no frequent super-graph. Denote by F , C , M the set of all frequent, all closed fre-quent, and all maximal frequent subgraphs, respectively. B y definition, F  X  C  X  M . The set of all maximal frequent subgraphs M is also known as the positive border . Note that the set of all (frequent) subgraphs forms a partial or-der with respect to the subgraph relationship, and associat ed with each graph in the partial order is its gidset. Orthogonal and Representative Graphs: Define sim : F  X  F  X  [0 , 1] to be a symmetric binary function that returns the similarity between two graphs. For example, the similarity based on the maximum common subgraph [2] is given as: sim ( G maximum common subgraph of G
Given any collection of graphs G , and given a similarity threshold  X   X  [0 , 1] , we say that a subset of graphs R  X  G is  X  -orthogonal 1 with respect to G iff for any G a , G b  X  R sim ( G a , G b )  X   X  and for any G i  X  G \ R there exists a G j  X  R Given a collection of graphs G , an  X  -orthogonal set R  X  G , and given a similarity threshold  X   X  [0 , 1] , we say that R represents a graph G  X  G , provided there exists some G a  X  R G :  X  G a  X  R , sim ( G, G a )  X   X  } , then we say that R  X  -representative set for  X ( R , G ) .

Finally, given G , and its  X  -orthogonal,  X  -representative set R , define the residue set of R to be the set of un-represented patterns in G , given as  X ( R , G ) = G \ {R  X   X ( R , G ) } . The residue of R is defined to be the cardinality of its residue set, |  X ( R , G ) | . Define the average residue similarity as follows: ars ( R , G ) = Lemma 1  X  &lt; ars ( R , G ) &lt;  X  .
 P
ROOF : For any G a  X   X ( R , G ) , we have sim ( G a , G b  X  for all G G \ R ,  X  G a  X  R , such that sim ( G a , G b ) &gt;  X  . Thus the numerator is always in the range (  X ,  X  ) .
 Problem Definition: In this paper we are interested in find-ing the  X  -orthogonal,  X  -representative set for the set of all maximal frequent subgraphs, i.e., when G = M . In gen-eral, one can find orthogonal representative sets for any col -lection of patterns G . Since the maximal patterns provide a synopsis of the frequent patterns, and since they are gener-ally a lot fewer than the sets of all frequent and closed fre-quent patterns, it seems reasonable to try to find a orthog-onal representative set among those. However, since even mining all the maximal graphs can be infeasible in many real-world domains, we try to find orthogonal representa-tive sets for a subset of the maximal patterns c M  X  M .
Given a graph database D , user-defined similarity thresh-olds  X ,  X   X  [0 , 1] , and a minimum support threshold  X  min , the problem of mining  X  -orthogonal  X  -representative graph patterns can now be formulated as follows: 1. Mine a (diverse) sample of maximal frequent patterns 2. Mine an  X  -orthogonal  X  -representative set R , that Note that an alternative objective can be to maximize ars ( R , c M ) . In this paper we focus on minimizing the residue ( |  X ( R , c M ) | ).

A solution to the above problem provides a small set of maximal frequent graph patterns that are non-redundant or orthogonal (for the  X  constraint) and also representative (for the  X  constraint). Depending on the value of  X  , the follow-ing two cases make interesting variants of the problem: case I (  X   X   X  ): By definition of  X  -orthogonal set, for any case II (  X  &gt;  X  ): This is the general case, for which the
As an example, assume that we are given the pair-wise similarities between a set of graphs c M , as shown in Fig-ure 1. If  X  = 0 . 2 , then there are two possible  X  -orthogonal sets, namely R as illustrated in Figure 1(b). If  X   X   X  , both of these will be optimal in terms of the residue. However, if  X  = 0 . 6 then  X ( R |{ M 4 }| = 1 . This is illustrated in Figure 1(b), which shows that M  X ( R 2 , c M ) = { M 1 , M 3 } , yielding |  X ( R 2 , c M ) | = | X  X  = 0 . Thus in this case R representative set.

The intuition behind our definition of  X  -orthogonal  X  -representative set should now be clear. The orthogonality constraint ensures that the resulting set of frequent patte rns has controlled redundancy. For a given  X  , several sets of (maximal) patterns qualify as feasible  X  -orthogonal sets. Besides redundancy control, we also want to achieve repre-sentativeness, i.e., for every maximal frequent patterns n ot
Figure 1. Similarity Matrix &amp; Graph: In the graph, sim  X   X  = 0 . 2 is denoted by bold edges, and sim  X   X  = 0 . 6 by dotted edges. reported, we want it to have a representative similar to it (based on the  X  threshold). Some patterns may still remain unrepresented, which make up the residue set. For a given  X  and  X  , the size of the residue set becomes an objective function to minimize when choosing the orthogonal repre-sentative sets. 1. EM = Edge-Map ( D ) 2. F 3. c M =  X  4. while stopping condition() 6 = true 5. M = Random-Maximal-Graph( D , F 6. c M = c M  X  M 7. R = Orthogonal-Representative-Sets ( c M ,  X ,  X  ) representative patterns. The first step finds a subset of fre-quent maximal patterns c M . The second step refines c M obtain an orthogonal representative set. The pseudo-code for ORIGAMI is shown in Figure 2. The algorithm accepts a graph database D , a minimum support value  X  min , and values for the parameters  X  and  X  . ORIGAMI first computes two global data structure that are used to generate maximal frequent patterns (lines 1-2). The edge-map (EM) stores for each vertex label l with edge label l of all frequent 1 -graphs (i.e., single edges). ORIGAMI then computes an approximation or sample of the set of maxi-mal patterns c M , by generating random maximal graphs un-til the stopping condition is met (lines 4-6). The stopping condition mainly ensures that the partial order of frequent graph patterns has been sufficiently explored. Once c M is obtained, ORIGAMI computes one or several  X  -orthogonal  X  -representative sets (line 7). Details of the various steps appear below.
The first step in ORIGAMI finds a sample c M of the set of all maximal frequent graphs M . Our goal is to find a sample that itself has as diverse a collection of maximal patterns a s possible. In other words we want to avoid generating maxi-mal patterns that are very similar to other maximal patterns already found. This necessitates a deviation from traditio nal enumerative pattern mining approaches.

Enumerative graph mining methods either explore the pattern space in a breadth-first (level-wise) or depth-first manner. The approaches work by extending an existing graph S of size k by adding one more edge to obtain a ploration of the pattern space is that longer patterns may never be reached, due to the combinatorial explosion in the number of subgraphs. On the other hand, depth-first explo-ration can produce some large maximal patterns, however it is likely to explore only a limited portion of the positive border, and most of the maximal pattern it enumerates will be very similar.
 Random Walks over Chains: ORIGAMI adopts a ran-dom walk approach to enumerate a diverse set of maximal patterns from the positive border. Each run of Random-Maximal-Graph (Figure 2, line 5) outputs one random max-imal pattern M by starting at the empty pattern and succes-sively adding a random edge during each extension, until no extensions are possible. Each run of the method thus walks a random chain in the partial order (recall that a chain in a partial order is a path composed of subgraph to immedi-ate supergraph edges). Figure 3 gives an illustration of thi s process. Each intermediate pattern is denoted by a star, and there exists an edge between two graphs G partial order if | G patterns or the positive border is denoted by the bold curve. Each random walk starts at the empty pattern  X  , and follows a random chain until it hits the positive border. Different runs of Random-Maximal-Graph produce an approximate set of maximal patterns c M .

Ideally the random chain walks would cover different regions of the partial order, and would produce dissimilar maximal patterns. However, in practice, this may not be the case, since duplicate patterns can be encountered in the fol -lowing ways: (i) multiple iterations following overlappin g chains, or (ii) multiple iterations following different ch ains, both leading to the same maximal pattern.
 Let X  X  consider a maximal frequent graph M of size n . Let e corresponding to a random chain walk, leading from the empty graph to the maximal graph M . Corresponding to the edge sequence is a series of intermediate graphs on the walk:  X  = S the intermediate obtained by extending S probability of a particular edge-sequence leading from  X  to M is given as: In general, any permutation,  X  , of an edge sequence, i.e., (  X  ( e 1 )  X  ( e 2 )  X  ( e n )) can also generate the same graph, M ; however, all n ! permutations may not be valid, since we require all intermediate graphs to be connected. For ex-ample, for a k -edge star graph, the number of valid edge-sequences is k ! , but for a linear k -edge graph (a sequence), the number of valid edge-sequences is 2 k  X  1 .

Denote by ES ( M ) the set of all valid edge-sequences for a graph M . The probability that a graph M is generated in a random walk is proportional to:
The probability of obtaining a specific pattern depends on the number of chains or edge sequences leading to that pattern and the size of the pattern. As we can see from Equation 1, if a graph grows larger, the probability of an edge sequence gets smaller, though a larger graph typically has more chains leading to it. So, our approach, in general, favors a maximal pattern of smaller size over a maximal pat-tern of larger size. We circumvent this problem by aborting a walk that is likely to generate duplicates or very similar patterns.
 Termination Condition: The iterative loop (Figure 2, line 4) that generates the maximal graphs terminates when an appropriate stopping condition is satisfied. The simplest case is to stop after a given number of walks k . We also implemented a dynamic termination condition, based on an estimate of the collision or hit rate of the patterns. Intu-itively the collision rate keeps track of the number of dupli -cate patterns seen within the same or across different ran-dom walks. As each chain is traversed, ORIGAMI maintains in a bounded-size hash-table, the signature of the interme-diate patterns. As each intermediate or maximal pattern is seen, its signature is added to the hash-table and the colli-sion rate is updated. If the collision rate exceeds a thresho ld  X  , this information can be used in two different ways: i) Within a given random walk, we can abort further exten-sions along the current path and force the method to back-track and choose another path (randomly). ii) Across dif-ferent walks it can trigger the terminating condition, sinc e a collision rate exceeding  X  implies that same parts of the partial order are being re-visited. An advantage of this dy-namic approach is that the user need not explicitly specify k (though  X  is now the new parameter).
 Random Maximal Graph Generation: As mentioned above the Random-Maximal-Graph method performs a ran-dom walk along a chain in the subgraph partial order. Start-ing from the empty pattern it adds random edges to obtain a succession of intermediate graphs leading to some max-imal pattern M  X  M . To extend an intermediate pattern, say S v , from where the extension will be attempted. Then, we choose a random edge e ( i, j )  X  EM from the edge-map, where i and j are the vertex labels of edge, e ; the edge can, optionally, have an edge label. Note that i must be equal to the label of vertex v for a proper extension. The edge map data structure can provide all such edges efficiently. If no such e is found, no extension is possible from the vertex v and v is inserted in a list of expired vertices. When all vertices in an intermediate graph S breaks and the pattern S if an edge e is found, we randomly choose the other end of this edge. If that is already in the graph S a back-extension, otherwise, it is a forward extension. An edge is added between this node, and the candidate pattern, S is infrequent, we insert the following map entry, ( v  X  e another data structure called the failed-map , to ensure that the edge e shall not be attempted at vertex v for extension of S counting via a vertical data representation are essentiall y the same as the graph mining method in DMTL [5].
 Figure 4 shows an example of the Random-Maximal-Graph algorithm, while finding a random maximal graph from a graph database of size 3 (Fig. 4 a-c) with  X  min = 2 The edge map (Fig. 4 d) records all the possible extensions for a given vertex label, recording the labels of the vertice s on the other end of that edge. If the edges have labels, they also become part of the possible other labels. For simplic-ity, we ignore edge labels in this example. The edge map also remembers the highest frequency of an edge within any graph in the database, so that some candidates which are not frequent shall never be attempted. For instance, con-Figure 4. (a-c) A graph database with 3 graphs. (d) sider the candidate frequent graph A X  X  X  X , which is not maximal (Fig. 4 e). But, the graph already has one A X  X  edge, with vertex ids (vid) 1 and 2, respectively. Since the maximum frequency of the A X  X  edge is 1, the edge exten-sion A X  X  shall never be attempted from vid 1 or 2. The failed list that we maintain along with every iteration of th e maximal graph generation process is also shown (Fig. 4 f). Note that for vid 1, all possible labels for the other end are in the failed list, i.e., they had been attempted and found to produce infrequent graphs. So, vid 1 is marked as expired (denoted by *). When all the vertices are expired the pro-cess terminates and we obtain a maximal graph. For this particular example, adding an edge A X  X  at vid 2, yields the maximal graph with support 2 (in graphs G
Given a set of maximal patterns c M , ORIGAMI extracts an  X  -orthogonal  X  -representative set from it.
 Theorem 4.1 Given c M , let  X ( c M ) be the graph with V = c M and E = { ( M a , M b ) | sim ( M a , M b )  X   X  } . Then any  X  -orthogonal set R is a maximal clique in  X ( c M ) , and vice-versa.
 P
ROOF : If R is an  X  -orthogonal set, then for any M a , M R , sim ( M ists M  X  -orthogonal set must be maximal. Since  X ( c M ) has edges only for  X  -orthogonal graphs, it follows that every maximal clique in  X ( c M ) is  X  -orthogonal set, and vice-versa. As mentioned earlier, the  X  -orthogonality controls the amount of redundancy allowed among the output patterns. For a given  X  , several maximal cliques can exist in the graph  X ( c
M ) , each a feasible solution to the orthogonal set prob-lem. The  X  -representative condition allows each element of the orthogonal to represent similar graphs, and also allows us to rank the maximal cliques in terms of their residue (or average residue similarity).

There are several challenges in finding the optimal orthogonal  X  -representative set. At the outset it should be noted that the orthogonal set is a representative set only fo r the sample c M . If sufficient number of maximal patterns were not sampled (for example, if the stopping condition were too restrictive), then c M may not approximate the set of all maximal patterns M very well, and the quality of c M would suffer. Another challenge is that, depending on the size of the maximal set c M , it may not be reasonable to compute the full pair-wise similarity matrix between all elements of c M , since it has O ( c M 2 ) time and space com-plexity. That is, it may not be reasonable to compute the full graph  X ( c M ) . Even if  X ( c M ) were available, the challenge is that finding the optimal maximal clique that minimizes the residue is an NP-hard problem.
 Theorem 4.2 Finding the optimal  X  -orthogonal  X  -repre-sentative that minimizes the residue is NP-hard.
 P
ROOF : This is easy to show, since the general problem con-tains an NP-hard sub-case. For  X  = 1 , each element in the  X  -orthogonal set represents only itself, giving the residue for any R as |  X ( R , c M ) | = c M \ R . Thus minimizing the residue for  X  = 1 corresponds to solving the maximum clique problem, which is known to be NP-hard.

Given the hardness result, instead of enumerating the op-timal maximal clique, we resort to approximate algorithms to solve the problem efficiently. Since, the optimal solu-tion is a maximal clique of the similarity graph, we adopt maximal clique finding as a heuristic. Using this approach, ORIGAMI finds a maximal clique without computing the full similarity matrix. Given the set c M it randomly selects one element M  X  c M , and adds it to R . The idea is to itera-tively add one element from c M \ R to the current R set until no more elements can be added, which would yield a maximal clique. At any intermediate step, we compute the similarities for all M there exists M for all M until a maximal clique is obtained. The complexity of find-ing a single clique is O ( | c M||R| ) , but in general we expect |R|  X  | c M| , so that the time is closer to O ( | c M| ) obtain multiple cliques ORIGAMI simply starts with differ-ent initial maximal graphs. Finally the best clique is chose n based on the residue size.

We also designed an approximate solution, which is bet-ter than the above heuristic approach and also guarantees lo -cal optimality. The neighborhood structure of the local opt i-mal formulation uses maximal clique in a meta-heuristic ap-proach. The algorithm starts with a random maximal clique. At each state transition, another maximal clique which is a local neighbor of the current maximal clique, is chosen. If the new state has a better solution, the new state is accepted as the current state and the process continues. The pro-cess terminates when all neighbors of the current state have equal or higher residue size. Two maximal cliques of size m and n (where, m  X  n ) are considered neighbors, if they share exactly n  X  1 vertices. The state transition procedure selectively removes one vertex from the maximal clique of current state and then expands it to obtain another maximal clique, which satisfies the neighborhood constraints.
Figure 5 shows an example state transition for the local-optimal algorithm. In Figure 5(a) we show a toy similarity graph, where the solid lines represent low similarity (  X   X  ) and broken lines represent high similarity (  X   X  ) between corresponding elements. Figure 5(b) shows an initial cliqu e (1 , 2 , 3) which has residue = 2 (since element 4 and 6 are not covered). Figure 5(c) shows a neighboring clique ( 2 , 3 , 4 having 2 common nodes (2 and 3), that has a better residue value (residue = 1; since only element 1 is not covered). Thus, the local optimal algorithm will accept the new clique in Figure 5(c) and will continue. For this toy example, this clique is also optimal. In the experimental section we show the performance superiority of the local optimal method over the random clique approach.
 Different Similarity Measures: Computing similarity be-tween graphs is one of the significant tasks in finding the  X  -orthogonal graph set. Similarity can be measured by us-ing features in the pattern space or in the transaction space (the gidset) or a combination of both of the above. In the case of pattern space, the most common way to compute similarity is using the edit distance between two patterns. Depending on the pattern complexity, the cost of edit dis-tance computation varies. For complex patterns like graphs , the computation is usually costly. On the other hand, the similarity in the gidset space is very easy to compute. A ratio of intersection-set and union-set can represent a sim i-larity. For two patterns G for similarity since, two very different patterns can have a very similar set of transactions. We did not use this measure in our work. But, for simpler patterns, like itemsets, it pla ys an important role in finding distances between patterns. We used the graph similarity measure proposed by Bunke et al. [2] that computes the similarity between two patterns by finding the relative size of their common sub-patterns. For the case of graphs, this is equivalent to finding the relative size of the maximal common sub-graph of two graphs. If G is the maximum common sub-graph between these two graphs, then the following equation computes the similar-ity: sim
For our purpose, we computed the similarity by using a maximal graph mining algorithm [7], that takes two graphs as input and mines for maximal graph patterns with 100% support. The frequent maximal graph of maximum size is used to compute the size of the maximal common subgraph in the similarity equation.

However, computing the exact similarity by solving the maximal common subgraph can be costly, and for the  X  -orthogonal graph problem, most often, we can compute a lower bound on the graph-distance by considering a graph as a labeled edge-multiset. We define the edge-multiset similarity as follows: Let G similarity between them as computed using sim E fined by an ordered triple of its vertex labels and edge label: h v lemma always holds.
 Lemma 2 sim P
ROOF : sim em  X  sim mc , unless | G mc | &gt; | E G But this is impossible, since all the edges in G in both the sets E
In computing similarity between two patterns, we first compute the sim to Lemma 2, sim sponding patterns satisfy the  X  -orthogonal constraints. Oth-erwise, we compute sim Chemical Compound Datasets (DTP and CM: The chemical dataset is obtained from the DTP AIDS Antiviral Screen test. The dataset can be retrieved from DTP web-pounds: confirmed active (CA), confirmed moderately ac-tive (CM) and confirmed inactive (CI). Each chemical com-pound is modeled as a graph where atoms represent the la-beled vertices and bonds represent the labeled edges of the graph. There are 3 bond types and 61 vertex types. The full DTP database has 40942 graphs, with average graph size 45 edges and 43 vertices. The CM subset has 1084 graphs with average 31 vertices and 34 edges.
 Protein Structure Dataset (PS): Given a protein struc-ture, we create a protein graph as follows. Each amino acid residue is treated as a vertex (labeled by one of the 20 amino acids), and there exists an edge between two vertices v and v between the C t = 7  X  A ). We created a database of 100 proteins (10 struc-tural families, with 10 proteins from each family), from the HOMSTRAD ( http://www-cryst.bioc.cam.ac. uk/  X  homstrad/ ) database of structurally-aligned ho-mologous proteins. The protein graphs have on average 165 nodes and 734 edges. The goal is to discover the orthogonal representative structural motifs for each protein family. Protein Interaction Dataset (PI): Data on pairs of inter-acting proteins was collected from three different sources . This dataset contains only 3 large graphs, with an average tion graph is created using one source: the first graph has an edge if the proteins involved are known to interact (via bi-ological experiments), the second graph has an edge if the proteins are part of a known pathway, and the third graph has an edge if the proteins have correlated gene expression values.
 Synthetic Implanted Dataset (SI): We wrote a graph gen-erator that accepts seed graphs and implants them in larger graphs to create a database D . First, we restrict the seeds to be  X  -orthogonal. The | S |  X  -orthogonal seeds can be gener-ated randomly or they may be extracted from a real dataset. We generate |D| graphs with the average graph size taken from a Poisson distribution with mean T . Seeds are se-lected to be added to the current graph D at random; as each seed is added we ensure that the graph D dition of a new seed to D of adding the seed, we make up the differential by adding edges/vertices randomly to existing nodes in D and edge labels are chosen randomly from L labels) and L All experiments were run on a 2.75Ghz PowerPC G5 Machine with 4GB Memory and 400GB disk. Since ORIGAMI is randomized, we perform several runs (typically between 3 to 5). Each run generates an approximate maxi-mal set c M . We next extract several orthogonal representa-tive sets (typically 10) using our primary algorithm that re -ports the best clique found. All numbers reported in the ex-periments below are the averages over the best results over all the runs. Wherever possible we tried to run state-of-the-art graph mining methods like gSpan [14], and DMTL [5] (which mine all frequent subgraphs) and SPIN [7] (which mines maximal graph patterns). The local optimization al-gorithm was used only in the result that compares against the random maximal clique algorithm. 5.2.1 Protein Interaction Mining First we evaluate our random walks approach to mining maximal patterns. As mentioned in the introduction, we ran a depth-first graph mining algorithm from DMTL [5] to mine the protein interaction dataset (PI), looking for fr e-quent graphs at  X  min = 100% (3 out of 3). The method was running for over a day before we terminated it. Dur-ing this time it had generate a 7GB output (from an initial 3MB database), containing 8 million subgraphs. SPIN was not able to run on this dataset; it terminated with a segment fault. Utilizing the fact that each protein appears only onc e in a given graph, we converted each graph into an itemset of edges, and we were then able to mine the maximal edge-sets. At  X  min = 100% this yields 90 maximal frequent graphs.
Next, we ran ORIGAMI on the original PI dataset. Fig-ure 6 shows the number of unique maximal patterns found versus the number of random walks. The figure shows that all 90 maximal patterns were found after 1400 random walks, and it took under 300s running time! This illustrates the effectiveness of our random walks maximal pattern min-ing approach. In this particular example, it was able to re-turn the exact set of maximal patters (i.e., c M = M ). 5.2.2 Protein Structure Mining
Table 1 shows the time taken to mine the protein struc-ture dataset at different values of minimum support. It also shows the number of maximal and  X  -orthogonal pat-terns found (for  X  = 0 . 2 ). Also shown is the average entropy of the patterns in c M and in R . Note that for a set of graphs G , the average entropy is given as H ( G ) = fraction of occurrences of G in protein family i . For ex-ample, if  X  min = 8 , and the protein subgraph appears in 8 different HOMSTRAD families, then its entropy will be  X  8 1 8 ln( 1 8 ) = 2 . 079 . The maximum possible entropy for a pattern with support exactly  X  min is also shown. We can see that in general ORIGAMI produces relatively good patterns that have about half the entropy compared to the maximum entropy. An example of a low entropy pattern in the Im-munoglobulin family from HOMSTRAD is shown in Fig-ure 7.
 5.2.3 Chemical Compound Mining Next we mined the chemical compound datasets. Note that neither gSpan nor SPIN were able to run on the full 40942 graph DTP dataset. On the other hand, we were able to successfully run ORIGAMI on DTP, using as the stopping criteria for c M , the number of unique maximal patterns gen-erated. We next extracted orthogonal representative sets f or different values of  X  and  X  .
The results are shown in Figure 8. In (a)-(c) we plot three curves, corresponding to increasing number of unique maximal patterns found, i.e., for different | c M| values. Fig-ure 8(a) plots the effect of  X  on the average residue, which is average residue shrinks to under 10% indicating that the  X  orthogonal  X  -representative set has left unrepresented less than 10% of the mined maximal patterns c M . Figure 8(b) plots the size of the orthogonal representative set (or maxi -mal clique) for different  X  . We see that, as expected, bigger cliques are found for larger  X  . Figure 8(c) shows the effect of  X  on average residue. As  X  increases, we find that aver-age residue increases, since the more stringent (i.e., high er) the representativeness threshold, the fewer the patterns t hat are represented.

Whereas SPIN was not able to run on the full DTP dataset, we were able to run it on the smaller 1084 CM dataset at a minimum support of  X  min = 25 / 1084 = 2 . 3% At this support level it output 1227 maximal patterns in about 181s. Thus for this smaller dataset we know the true set of maximal patterns M . Figure 8(d) plots the average residue with respect to the true maximal set M , and the time for mining as a function of the size of c M . The observed trend is that as | c M| increases, the average true residue also decreases, since the orthogonal set is able to represent mor e true maximal graphs.

Figure 8(e) shows a comparison of random maximal clique method and the local optimization method for dif-ferent  X  values using the CM dataset. In every case, the residue of the local optimal method is 30% to 50% smaller than that of the random maximal clique method. 5.2.4 Implanted Seed Mining
The goal of this experiment is to recover implanted seeds. We generated a set of seeds from the full DTP dataset as follows: Initially | c M | = 3550 maximal patterns were generated from DTP using ORIGAMI . Next an orthogonal set R is mined at  X  = 0 . 6 , which yielded a maximal clique of size |R| = 9 . These 9 seed graphs, containing on average 6.4 edges and 7.4 nodes, were fed into the graph generator to create varying datasets, as shown in Table 2.

Once the datasets were generated we mined them at dif-ferent  X  min values, and used  X  = 0 . 8 to extract the orthogonal sets. The first three rows show results for vary-ing dataset size. As the dataset size increases the number of seeds found increases, since the odds of the graphs contain-ing the 9 implanted seeds increases. Rows 4 and 5 in the table show results for varying the minimum support on a dataset with 20000 transactions. The number of seeds cap-tured does not change in this case. Rows 6-9 show the effect of varying the average size ( T ) of a graph in D . The results confirm our intuition that as the average size increases, the number of seeds in a graph increases, resulting in greater number of seeds being captured.
In this paper we proposed a new paradigm for mining a summary representation of the set of frequent graphs. This is a very difficult problem to solve, as it consists of indi-vidually hard problems: i) computing similarity between graphs, ii) random sampling from the set of frequent max-imal graphs, and iii) finding maximal cliques. ORIGAMI employs effective techniques to tackle these challenges, a s demonstrated empirically on a variety of datasets. Unlike previous techniques that focus on the distance in the trans-action space to obtain representatives, our approach cap-tures representatives by considering the distances in the p at-tern space. We introduced a randomized approach for min-ing maximal subgraph patterns. The method is designed to cover the partial order of subgraphs, so that orthogonal maximal patterns are obtained quickly. We formulated the  X  -orthogonal  X  -representative set finding as an optimiza-tion problem. We show that the optimization problem is NP-Hard and we thus propose a local optimization solu-tion that is efficient and practically feasible. We demon-strate that ORIGAMI is able to mine good quality orthogonal representative sets, especially for datasets where tradit ional enumerative methods fail completely.

