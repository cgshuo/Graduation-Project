 As location-based social network (LBSN) services become increas-ingly popular, trip recommendation that recommends a sequence of points of interest (POIs) to visit for a user emerges as one of many important applications of LBSNs. Personalized trip recommenda-tion tailors to users X  specific tastes by learning from past check-in behaviors of users and their peers. Finding the optimal trip that maximizes user X  X  experiences for a given time budget constraint is an NP hard problem and previous solutions do not consider two practical and important constraints. One constraint is POI avail-ability where a POI may be only available during a certain time window. Another constraint is uncertain traveling time where the traveling time between two POIs is uncertain. This work presents efficient solutions to personalized trip recommendation by incorpo-rating these constraints to prune the search space. We evaluated the efficiency and effectiveness of our solutions on real life LBSN data sets.
 H.2.8 [ Database Applications ]: Data mining; I.2.8 [ Problem Solv-ing, Control Methods, and Search ]: Scheduling Trip plan; location-based social network; recommender systems
With the emerging development of location-based social net-work (LBSN) services such as Yelp and Foursquare, users are able to  X  X heck in X  at a certain point of interest (POI), such as restau-rant/museum/park, via their mobile devices. A user may rate and make comments after visiting a POI and other users may consider those ratings and comments to select the POIs for their visits at a later time. The availability of such rating data and LBSN services open up an array of new research problems in both academia and industry, such as user behavior analysis, movement pattern study [5, 15], and various real-world applications [6, 32, 34]. Among them, POI recommendation and trip recommendation [14, 28] are hot topics and require a location sensitive solution. For example, recommending a highest rated Chinese restaurant in Beijing to a user who is currently visiting New York City will fail, even if the user loves Chinese food. Recommending a nearby Chinese restau-rant with a reasonable rating score makes more sense in this case.
In this paper, we focus on the personalized trip recommendation problem. In this problem, a user travels to a new region (e.g., on a business trip to a new city) and wants to visit several POIs within a limited amount of time. The goal is to recommend a trip route vis-iting several POIs according to not only the temporal-spatial con-straints (more details shortly), but also the user specific preferences on POIs.
The trip recommendation is not trivial because of the following challenges:  X  ( Personalization ) First, while a user has its own interests, ex-plicitly soliciting this information does not work in large scale ap-plications because the user often does not know what POIs are available and where they are. Modeling user preferences by learn-ing from historical rating and check-in behaviors of users and their peers to predict the user X  X  preferences on unvisited POIs would be a preferred solution.  X  ( Sequence of POIs ) Second, the traditional POI recommenda-tion recommends individual POIs with highest scores, such POIs may not form a feasible trip due to the spatial and time constraints.  X  ( POI availability and uncertain traveling time ) Third, the tra-ditional trip recommendation assumes that POIs are always avail-able any time and the traveling time between two POIs are known in advance, but in practice, a POI may be available only at certain times (say, due to opening hours and closing hours) and traveling time is uncertain due to traffic conditions at the time of travel. As a result, whether a POI can be visited will depend on its available time and predictability of the time traveling to the POI. If the time-more predictable traveling time would be preferred. For example, the user may give up one more POI to visit in order to ensure a high probability of visiting another more preferred POI or arriving at the specified destination on time.  X  ( Large search space ) Finally, the POI availability and uncer-tain traveling time imply each order of visiting a set of POIs may have a different consequence, thus, a brute-force search of all can-didate trips is prohibitive. For example, with 150 POIs in total, the number of trips that consist of 5 POIs can reach billions (i.e., 150!). Most of these candidate trips do not follow the POI availability or match user X  X  preferences, or cannot be finished within a given time limited. A strategy that prunes such infeasible and non-optimal trips based on user preferences, POI availability, traveling time un-certainty is essential for scaling a solution to large applications.
Trip recommendation has been studied recently. [17] analyzed the characteristics of travel packages and proposed a graphical model to extract the topics conditioned on tourists, areas and travel sea-sons for personalized travel package recommendation. [3] devel-oped a Bayesian learning model to extract travel paths from photos and conducted personalized travel recommendation according to user-specific profiles. All these works, however, adopt probabilis-tic models to generate a possible travel package or path but do not consider the objective function to maximize the user X  X  happiness under the trip and other constraints.

The recent work [9] formulated the trip recommendation as a constrained objective function and presented a dynamic program-ming solution. Their assumption is that POIs can be grouped into several types or categories and the user knows the order of visiting POI types and likes to visit POIs of each type exactly once in a pre-determined order. The restriction of visiting each type exactly once in a pre-determined order significantly reduces the search space. For example, for 150 POIs falling into 5 types equally, the origi-nal 150! possible routes are reduced to 30 5 if the order is fixed. In real world applications, however, the user may not provide this order either because she does not care about the order or because she is concerned that such a fixed order may restrict her options. In addition, their work does not consider the POI availability and the uncertainty of traveling time.

A detailed review of related work is presented in Section 8.
In this paper, we address the trip recommendation by taking into account the following information and constraints: (1) the user X  X  personalized preferences on POIs; (2) the user X  X  time budget that constrains the total traveling and visiting time; (3) the time window for the POI availability; (4) the uncertainty of traveling time be-tween POIs. We formulate the above requirements in our TripRec problem. The goal of the problem is to find an optimal trip that maximizes user happiness under the constraint that all the POIs in the trip can be visited and the trip can be completed within the user time budget with a probability not less than a user specified thresh-old. This problem is NP-hard as it is a special case of either the Knapsack problem [11] or the Orienteering problem [25].

We solve this problem by using the information and constraints in (1)-(4) to prune unpromising candidate trips. Our algorithm has an offline step and an online step. In the offline step , we apply col-laborative filtering adopted to items with features to estimate user X  X  preferences on unvisited POIs based on available check-in data. This step is performed only once as it applies to all users. In the on-line step where the user X  X  time budget constraint and start/destination locations are provided, we search for the optimal trip route under the various constraints discussed above. We present two optimal solutions that guarantee to find the optimal trip if it exists. One is based on a state expansion approach and one is based on a pre-fix based depth-first search strategy. We also present two heuristic solutions that find  X  X ood trips X  with a significantly better runtime than the optimal solutions. We evaluated all solutions on two real life LBSN data sets, Yelp and Foursquare, and demonstrated the superiority over previous trip recommendation algorithms.
The rest of the paper is organized as follows: Section 2 defines the problem. Section 3.1 presents the personalized rating estima-tion for POIs, which corresponds to the offline step, and Section 3.2-3.3 presents our modeling of POI availability and uncertain traveling time. These are the key factors that distinguish our model-ing of trip recommendation from previous ones. Section 4 presents the optimal solution based on the state expansion approach, and the state relaxing strategy which scarifies optimality for efficiency. Section 5 introduces the second optimal solution based on the pre-fix based depth-first search strategy. We present an efficient heuris-tic solution in Section 6. Section 7 presents experimental evalua-tion of all solutions. Section 8 presents a review of related works. Finally, we conclude the paper with a discussion on extension to other scenarios of trip recommendation.
This section describes our data model and the trip recommenda-tion problem.
POI map: We assume that there are n POIs in a (virtual) com-plete directed graph G = ( V,E ) . V = { 1 ,  X  X  X  ,n } is a set of POIs. Each POI i  X  V is associated with the following informa-tion: a touring time m i , indicating the typical or average staying time for users, and opening hours [ O i ,C i ] , indicating that i opens at time O i and closes at time C i . Each edge e ij  X  E represents the route from i to j , where i,j  X  V , and associates with a traveling time t ij following a distribution with probability density function f (  X  ) . We assume that these functions f ij (  X  ) are given and that traveling times for different routes e ij are independent.
Rating matrix: We consider a set of users where a user u may rate a POI i after visiting i . A rating matrix R contains all observed ratings r ui . The rating matrix is usually extremely sparse with most entries undefined since a user may only rate a few POIs. Besides, a user u could leave comments on POI i when rating i , represented by a bag of words B ui (If a user u does not rate a POI i , B The  X  X ontent X  of POI i is defined as B i = S u B ui . Based on the matrix R and comments, we could estimate a user u  X  X  rating for an unvisited POI j , denoted as r  X  uj .

A trip route: For a specified source location x and a destination location y , and a departure time T 0 , where x and y are not neces-sarily distinct, a trip route has the form x  X   X  X  X  i  X  X  X   X  y , that starts from x at the time T 0 , visits each POI i listed in the route in order, and ends at y . We assume that the probability density func-tions f xi (  X  ) and f iy (  X  ) are known for any POI i , and we set r r uy = 0 , m x = m y = 0 , O x = O y = T 0 , C x = C y = +  X  . Such settings ensure that visiting x and y does not cost time be-cause they serve only as the departure and destination locations for a trip. The score of a trip route P for a user u is defined by an ad-ditive function F ( P ,u ) = P i  X  X  r  X  ui . This function simply sums up the estimated ratings r  X  ui for all POIs in the route, which models the happiness of u with respect to the route P .

Constraints on a trip route: POI availability constraint: a user is considered to visit a POI i only if the user spends m i during the opening hours [ O i ,C i ] . Therefore, if a user arrives at i before O i , she has to wait until the opening hour, and the user should arrive at i no later than C i  X  m i to gain the happiness score. Time budget constraint: the whole trip is completed within a period of time b , including traveling time and touring time at POIs. Com-pletion probability constraint: the probability that a trip finishes at the destination y by the time T 0 + b is not less than a user specified threshold  X   X  [0 , 1) .
P ROBLEM 1 ( T RIP R EC ). Given a user u with the source x and the destination y , a departure time T 0 , a time budget b , and a threshold  X   X  [0 , 1) , we want to find an optimal trip route P that maximizes user happiness F ( P ,u ) under the following con-straints: (1) The route starts at location x and ends at location y . (2) The route satisfies the POI availability constraint, the time budget constraint and the completion probability constraint.
In the rest of the paper, we first model the user X  X  personalized preferences and the trip constraints; then, we present several ap-proaches to search the optimal trip route according to the estimated preferences for TripRec .
In this section, we discuss our modeling of user preference and trip constraints.
Most existing POI recommendation methods either consider no content information of POIs or treat content information as side in-formation (more discussion in Section 8). We believe that content information of POIs should play a more central role in user pref-erence in that a user likes a POI because of certain features of the POI. To this end, we adopt the feature-centric collaborative filter-ing proposed in [33]. Unlike the traditional collaborative filtering on POIs, this approach performs collaborative filtering on the fea-tures of POIs and determines the rating on a POI using the predicted ratings on the features of the POI.

First, we transform the original user-POI rating matrix R into a user-feature matrix R 0 , where each row represents a user u and each column represents a feature f in S i B i for POIs i . An entry ( u,f ) in R 0 stores the aggregated rating on the feature f over the POIs i such that B i contains f and i are rated by u : In this work, agg ( X ) returns the average of the values in X , but other aggregation operations are possible. agg ( X ) is undefined if X is empty.

Then, we apply matrix factorization [12] to R 0 to extract the la-tent user vectors p u for users u and the latent feature vectors q features f . To predict the rating of user i on a POI i , we aggregate the predicted ratings p T u q f over all the features f in B We will use r  X  ui as the estimated rating of a user u on a POI i . Thus, if the user is estimated to rate highly most features of a POI, the user is estimated to rate highly the POI. Note that the estimation of user ratings is performed offline and only once.
The basic idea of trip planning is to extend the route P grad-ually. Suppose that i is the last POI of P , which satisfies the time budget and POI availability constraints, and  X  i is the start-ing time of visiting i . We may extend the route by adding a new POI j after visiting i . We use the Sat function to test if the POI availability and the time budget constraints are satisfied af-ter the extension. Sat ( i,j, X  i ) returns true if  X  j + m  X  + m j + t jy  X  T 0 + b , where  X  j = max {  X  i + m i + t ij indicates the starting time of visiting j . This testing ensures that destination y within the time budget.
The above assumes that traveling time t ij for a sub-route i  X  j is deterministic. However, even the traveling time can be estimated from historical data and external resources [20], the real traveling time remains uncertain due to many uncertain factors that could affect the traffic. To model this uncertainty, we shall treat the trav-eling time t ij as a random variable following a certain distribution with probability density function f ij (  X  ) . In this case, the best one can guarantee is that the probability that a trip P can be finished within a given time budget b is above some specified threshold  X  . This probability, called completion probability , is denoted by  X  ( P ) so that  X  ( P )  X   X  .

We can modify the above constraint testing function Sat for un-certain traveling time as follows. Let E [ t ij ] denote the expectation of t ij . Sat ( i,j, X  i ) returns true if  X  j + m j  X  C j E [ t jy ]  X  T 0 + b , and  X  ( P )  X   X  , where  X  j = max {  X  E [ t ij ] ,O j } indicates the expected starting time of visiting j .
Let us derive  X  ( P ) for a route P . Consider a sub-route i  X  j , we assume that the probability density function f ij (  X  ) is known. For simplicity, we also assume that t ij are independent for different pairs ( i,j ) . Let  X  denote the traveling time of the sub-route. The probability of the traveling time less than t is given as follows: Suppose that we extend i  X  j by a POI k , the probability of travel-ing time of i  X  j  X  k less than t is given by the multiple integral: where the domain D = { (  X , X  )  X  R 2 &gt; 0 : 0 &lt;  X  +  X  &lt; t } and R &gt; 0 means positive real number. In general, for any route P : i  X  j  X  X  X  j 0  X  k with c sub-routes, the probability of the total traveling time  X  less than t is estimated by P (  X  &lt; t ) = where D = { (  X  1 ,  X  X  X  , X  c )  X  R c &gt; 0 : 0 &lt;  X  1 This probability can be computed given all the probability density functions f ij  X  X  X  f j 0 k .
 T HEOREM 1 ( C OMPLETION PROBABILITY BASED PRUNING ).
 Let  X  be the total traveling time of a route P : i  X  X  X  X  X  X  j and let  X  be the total traveling time of another route P 0 : i  X   X  X  X  j  X  k obtained by adding a new POI k . Assume that both routes start at i at the same time. P (  X  0 &lt; t )  X  P (  X  &lt; t ) .

P ROOF . For simplicity, we consider a route i  X  j and the ex-tension i  X  j  X  k , but the proof for the general case is sim-ilar. Due to the independence of traveling time at different sub-routes, P (  X  0 &lt; t ) = RR D f ij (  X  ) f jk (  X  ) d X d X  , so P (  X  R
In other words, the probability of finishing a route within the time budget is never increased by extending the route with one more POI at the end. This is because adding a POI at the end of a route does not affect the traveling time between the previous POIs of the route, but reduces the chance of completing the route within the time budget due to the additional time of traveling to and visit-ing the new POI. We shall use this property to prune the trips that have their completion probability below the specified threshold  X  .
Various studies and methods have been proposed to estimate travel time distributions in the literature. See [31] for a compari-son of these methods. Our method does not depend on the choices of such distribution, provided that the probability P (  X  &lt; t ) can be computed for a route P . For concreteness, we adopt the log-normal distribution in [27]. The traveling time t z on the z th sub-route in a route independently follows the log-normal distribution with pa-rameter  X  z , X  z , that is, t z  X  LN (  X  z , X  2 z ) . The expected travel-ing time E [ t z ] is given by exp(  X  z +  X  2 z / 2) . The total traveling time  X  of a route P made of multiple sub-routes is the sum of the traveling time t z of each sub-route, i.e.,  X  = P z t z . According to [19],  X  can be approximated by another log-normal distribution LN (  X   X  , X  2  X  ) with the following parameters:
With this distribution for the total traveling time  X  , the probabil-ity of completing a trip P is  X  ( P ) = P (  X  &lt; t ) , where t is the time available for traveling, that is, t = b  X  P m j . For the log-normal distribution, where erf( t ) = 2  X   X  R t 0 e  X   X  2 d X  [27].
In this section, we present a state expansion algorithm that guar-antees to find an optimal route if it exists. The idea is to consider each partially generated route as a state associated with some end-ing POI i , representing a feasible trip route x  X   X  X  X   X  i  X  y that has i as the ending POI before reaching the specified destina-tion y . Each state is labeled by s = ( K,T,H, X ,i ) , where K is the set of POIs already visited, excluding x and y . T is the starting time of visiting at i (i.e.,  X  i ), H is the overall happiness collected (i.e., F ( K,u ) ),  X  is the current route x  X   X  X  X   X  i (without the sub-route i  X  y ) and i is the ending POI. These parameters are de-one state s 0 = (  X  ,T 0 , 0 ,x,x ) , representing the trip route x  X  y .
At the  X  th iteration (  X  &gt; 0 ), the state expansion algorithm ex-tends each state of size  X   X  1 into a new state of size  X  by adding a new POI. Specifically, a state s = ( K,T,H, X ,i ) is extended into a new state s 0 associated with POI j 6 X  s K  X  X  x,y } according to the following rules: A new state s 0 is feasible if Sat ( i,j,s T ) returns true . Intuitively, this means that the partial route of the state can be extended to j and then finished at the destination y within the time budget with the completion probability no less than the threshold  X  .
It is possible that the same ending POI s i could be reached by different states s of the same POIs s K , corresponding to different visiting orders. Not all such states need to be maintained because some do not lead to the optimal solution.

We say that a state s dominates a state s 0 if ( s i = s 0 i )  X  ( s K = s 0 K )  X  ( s T  X  s 0 T )  X  (  X  (  X  s where  X   X  forms the complete trip by adding y into the route, say  X   X  =  X   X  y . Note that s K = s 0 K implies s H = s 0 H s give the same user happiness. Intuitively, s dominates s of the following conditions hold: the two states s and s two routes  X   X  y and  X  0  X  y containing the same set of POIs, the starting visit time of i in s is no later than that in s 0 pletion probability of s is no less than that of s 0 . We assume that the procedure Check tests the dominance: Check( s,s 0 ) returns true if s dominates s 0 (i.e., Eqn 9) and false otherwise.
L EMMA 1. If a state s dominates a state s 0 and let s e and s denote the states obtained from extending s and s 0 with a new POI j at the end, respectively, then s e dominates s 0 e .

P ROOF . Suppose that s and s 0 represent the routes  X   X  y and  X   X  y . Then s e and s 0 e represent the routes  X   X  j  X  y and  X   X  j  X  y . It is easy to see that the first three conditions in Eqn (9) remain true for s e and s 0 e . To see the last condition, since s dominates s 0 , both  X  and  X  0 have the same ending POI i . If we regard i as the new source of the following identical trip i  X  j  X  y for both s e and s 0 e , the completion probability of this trip in s no less than that in s 0 e because it starts earlier in s the previous trip  X  and  X  0 , this condition still holds. By repeatedly applying Lemma 1, we have the next theorem.
T HEOREM 2 ( D OMINANCE BASED PRUNING ). Assume that a state s dominates a state s 0 . If s 0 can be extended into an optimal trip by a sequence of POIs, so is s by the same sequence of POIs.
From the above theorem, it suffices to consider only non-dominated states. We will use this property to remove all dominated states without affecting optimality.
Algorithm 1 summarizes the state expansion for TripRec . Start-ing at the initial state S = { s 0 } , the algorithm extends the current set of states, S , by adding one new POI at the end of a route in S . If the states in S have the size  X  , the new states in S the size  X  + 1 . The two for loops extend each state in S with an unvisited POI and only feasible states are kept. Meanwhile, Line 9-10 conducts the dominance test and removes dominated states. Line 12-13 records the optimal route with the maximal user hap-piness. The time complexity of Algorithm 1 is O ( n 2 2 n is exponential but much faster than the brute-force search O ( n !) . However, due to the time budget and POI availability constraints, each trip typically consists of only a small fraction of all POIs. If the maximum number of POIs in a trip is  X  , where  X  n , 2 replaced with C ( n, X  ) in the above complexity.
The above dominance based pruning applies only to two states that have exactly the same set of POIs, i.e., s K = s 0 K willing to sacrifice optimality for efficiency, it is possible to have a more aggressive pruning by replacing the condition s K = s with | s K | = | s 0 K | (i.e., visiting the same number of POIs) and s
H  X  s 0 H (i.e., s representing a more preferred route than s the dominance test condition in Eqn (9) is relaxed into ( s i = s 0 i )  X  ( | s K | = | s 0 K | )  X  ( s T  X  s 0 T )  X  ( s Intuitively, with this relaxed dominance relationship, the route for s takes less time and generates a higher happiness than the route for s 0 , while reaching the same ending POI i . In other words, the route represented by s gives the user more happiness and more re-maining time than the route represented by s 0 , thus, is preferred. We call the pruning based on this relaxed dominance relationship state relaxing . State relaxing applies to all states ending at the same
Algorithm 1: State expansion input : POI map G , user u  X  X  specific preferences r  X  ui output : optimal TripRec trip route, P 1 s 0  X  (  X  ,T 0 , 0 ,x,x ) , s  X   X  s 0 ; 2 S  X  X  s 0 } , S 0  X  X  X  ; 3 while S 6 =  X  do 4 for s  X  S do 5 for j  X  V \ s K do 6 if Sat( i,j,s T ) then // i  X  s i 7 s 0 T  X  max { s T + m i + E [ t ij ] ,O j } ; 8 s 0  X  ( s K  X  X  j } ,s 0 T ,s H + r  X  uj ,s  X   X  j,j ); 9 if  X  s 00  X  S 0 : Check( s 0 ,s 00 ) =true then 10 remove s 00 from S 0 ; 11 add s 0 to S 0 ; 12 if s 0 H &gt; s  X  H then 13 s  X   X  s 0 ; 14 S  X  S 0 ,S 0  X  X  X  ; 15 return s  X   X   X  y as P POI through visiting the same number of POIs which significantly reduces the size of the set of states S in Algorithm 1 as each ending POI may only be associated with a few states. So the time com-plexity is decreased from O ( n 2 2 n ) to O ( cn 2 ) for some constant c .

However, due to the POI availability constraint, state relaxing loses the optimality in some cases. For example, suppose A  X  D  X  C dominates A  X  B  X  C according to Eqn (10) (we omit the source x and destination y for simplicity), so the former is kept and the latter is eliminated. Now suppose that B only opens in the morning and D opens until midnight. Then the route A  X  D  X  C  X  B may be infeasible due to the late visit to B while the route A  X  B  X  C  X  D could be the optimal solution, but it cannot be generated because A  X  B  X  C was pruned. Section 7 will study experimentally the trade-off between efficiency and user happiness for the state relaxing strategy.
If the states of size  X  are represented by the nodes at level  X  in a tree structure (with the root at level 0), Algorithm 1 generates the states in a breadth-first manner in that the states at level  X  are generated before any state at level  X  +1 is generated. For loose time budget and POI availability constraints, this approach may have to keep many  X  X pen X  states in memory (i.e., all states of the same size), which imposes a bottleneck on the memory requirement.
To address this limitation, we present a prefix based depth-first enumeration of states in which a tree structure representing the states is searched in the depth-first manner so that only the cur-rent branch at any level is searched at any time. First, for the given user u , we order all POIs i by the estimated rating r  X  ui der together with our tree enumeration strategy below ensures that POIs with larger ratings are considered before those with smaller ratings in the construction of a route. For presentation, we consider V = { A,B,C,D,E } of five POIs, excluding the source x and destination y , and we assume that these POIs are ordered in the descending order of estimated ratings for u . The prefix of a POI i refers to the set of POIs that precede i in this order.

Figure 1 shows the tree structure for enumerating all the subsets of V with POIs arranged in the above order. The nodes in the tree are generated from left to right in a specific depth-first order, as in-dicated by the numbers aside the nodes. Each node is labeled by a set of visited POIs arranged in the above order, and the root is labeled by the empty set  X  . Intuitively, a node with the label K rep-resents all the non-dominated feasible routes that visit exactly all the POIs in K . These routes are divided into | K | groups according to each ending POI in K . To grow the tree, for a node v with a la-bel ending at a POI i , a child node is generated by appending some POI j that precedes i in the above order to the front of the label of v . For example, Node 7 with the label ABC is generated as a child node of Node 6 with label BC by appending A to the front of BC .
Subset first property . An important property of the above depth-first enumeration is that a label K is always enumerated before any of its supersets . For example, the proper subsets of ABC are enu-merated at Nodes 0-6 and ABC is enumerated at Node 7. This property ensures that, when computing the feasible routes at the node for a label K with the ending POI i , the feasible sub-routes visiting all the POIs in K \ i have already been computed at the node with the label K \ i , so we can retrieve the stored informa-tion for such feasible sub-routes to construct the feasible routes at the node for K , by checking the time budget and POI availability constraints and pruning dominated states.

For example, Node 15 with the label ABCD is a child node of Node 14 with the label BCD . There are 4! possible routes at Node 15, but many can be pruned since they either violate the time budget and POI availability constraints, which can be tested by the procedure Sat , or are dominated by other routes, which can be tested by the procedure Check . The feasible routes at Node 15 can be divided into 4 groups corresponding to the ending POIs A , B , C , and D , respectively. The group for the ending POI A can be constructed by retrieving the feasible sub-routes from the already computed Node 14 and appending A to the end by checking the constraints. With the dominance pruning discussed in Section 4 (i.e., Eqn 9), only the non-dominated routes will be kept for this group. The groups for the ending POIs B , C , D can be constructed similarly, by retrieving the feasible sub-routes from the nodes with the labels ACD,ABD,ABC , i.e., Node 13, Node 11, Node 7. Note that these nodes were already computed because their labels are subsets of ABCD .

The next theorem lays the foundation for our prefix based depth-first enumeration algorithm for computing the optimal route.
T HEOREM 3. (1) Every non-dominated feasible route stored at a node with the label K and ending POI i must have a prefix that is a non-dominated feasible route stored at the node with the label
Algorithm 2: PrefixDFS ( U , K ) 1 for j  X  U in order do 2 U  X   X  prefix of j in U ; 3 K +  X  K  X  X  j } ; 4 if | K + | = 1 then 5 if Sat ( x,j,T 0 ) = true then 6  X [ K + ] H  X  r  X  uj ; 7 add ( j,x  X  j, max { E [ t xj ] + T 0 ,O j } ) to 8 PrefixDFS( U  X  , K + ) ; 9 else 10 for k  X  K + do 11 K  X   X  K + \ k ; 12 if  X [ K  X  ] is not empty then 13 find l = ( i, X ,T ) in  X [ K  X  ] L such that 14 if l is found then 15 T 0  X  max { T + m i + E [ t ik ] ,O k } 16 if  X [ K  X  ] H + r  X  uk &gt; H then 17 update P and H ; 18  X [ K + ] H  X   X [ K  X  ] H + r  X  uk ; 19 add ( k, X   X  k,T 0 ) to  X [ K + ] L ; 20 if  X [ K + ] is not empty then 21 PrefixDFS( U  X  , K + ) ; K \ i . (2) The node with the label K \ i is enumerated prior to the node with the label K .

P ROOF . (1) Consider a non-dominated feasible route at a node with the label K , written as  X  0 =  X   X  i , where  X  is the prefix containing the POIs in K \ i . From Theorem 1,  X  must satisfy all the constraints, and from Theorem 2, it suffices to consider only non-dominated feasible route  X  at the node with the label K \ i . This proves Part (1). Part (2) follows from our discussion on the prefix based depth-first enumeration.
Based on the above discussions, we design a hash map  X  to store the computed results for each node in the tree, whose key is the label K of the corresponding node, and whose value,  X [ K ] , con-tains the information about the non-dominated feasible routes for the node.  X [ K ] has two components, H and L . H is the total hap-in L has the form ( i, X ,T ) and represents a non-dominated feasible route  X  for the node. i  X  K is the ending POI of  X  and T is the starting time of visiting i . Essentially,  X [ K ] is a compact represen-tation of all the states that have the same POI set K in Section 4. Let  X [ K ] H and  X [ K ] L denote the H and L components of  X [ K ] .
We implement the above prefix depth-first search in Algorithm 2 as a recursive procedure PrefixDFS( U,K ) with a set U of ordered POIs and a node label K as the parameters. Intuitively, PrefixDFS( U,K ) enumerates the subtree at the node with the label K and U is the set of POIs available for extending the la-bel K within the subtree. The inputs to the algorithm are the POI map G , the departure time T 0 , the time budget b and user-specific preferences r  X  ui . The output is the optimal route and its happiness, stored in the global variables P and H . The main algorithm is the call PrefixDFS( V,  X  ) with the set of POIs V in the POI map G . The algorithm extends the label K by each available POI j in U , creating the child node with the label K + = K  X  { j } and U  X  being the prefix of j in U . If K is empty, Line 4-8 adds the route x  X  j  X  y to the hash entry for K + and recursively calls PrefixDFS ( U  X  ,K + ). If K is not empty, Line 10-19 adds all non-dominated feasible routes having the POI set K + to the hash entry for K + . In particular, for each k  X  K + , Line 13 searches for the non-dominated feasible route for the POI set K + and end-ing at k . This route consists of a non-dominated feasible route l = ( i, X ,T ) for the POI set K  X  = K + \ k and the ending POI k (The-orem 3) such that it satisfies all the constraints, i.e., Sat ( i,k,T ) = true , and the the route  X   X  k is non-dominated (by the conditions in Eqn (9)). From Theorem 3, all non-dominated feasible routes for K  X  are stored at the node K  X  and were computed already. If there exists such an l , ( k, X   X  k,T 0 ) for the extended route  X   X  k is added to  X [ K + ] L . After considering every k  X  K + , if  X [ K not empty, the algorithm calls PrefixDFS ( U  X  , K + ) recursively.
Note that the algorithm does not actually materialize the entire enumeration tree; instead, it enumerates the nodes in the tree in the depth-first order. The result at each node is stored in the hash map.
In this section, we propose a simple heuristic algorithm that is essentially linear in the total number of POIs while maintaining the quality of the route. The idea is intuitive: starting with the initial trip route x  X  y , we insert one POI at a time between two adjacent POIs in the current trip route so that (i) the insertion preserves the satisfaction of all the constraints and (ii) some score of the route is maximized (to be discussed shortly). For example, inserting a POI A into x  X  y gives the route x  X  A  X  y , then inserting a POI B before A gives x  X  B  X  A  X  y , and so on. To avoid the local optimum, we generate some small number of routes (say 2-3) by applying this method to the set of remaining POIs not contained in the previously generated routes, and we choose the best route from all the routes generated. The time complexity of this algorithm is O ( cn ) , where n is the number of POI and c is a constant, because each insertion considers at most n unvisited POIs. Note that the length of a route is usually small due to the time budget and POI availability constraints.

A remaining issue is to check whether inserting a POI k between two adjacent POIs i and j (i.e., the sub-route i  X  j already exists in the trip) preserves the satisfaction of the time budget constraint, the POI availability constraint and the completion probability con-straint. We focus on the POI availability constraint because it is easy to check the other two constraints. We assume  X  ij = 1 , that is, a visit to POI i is followed by a visit to POI j . Before the in-sertion of k , the arrival time at POI j , denoted by a j by where  X  i is the starting time of visiting at POI i . The wait time at POI j , w j , is computed by The maximum allowed delay time at i to preserve the satisfaction of constraints, denoted by v i , is computed by where C i  X   X  i  X  m i is the maximum allowed delay time to keep the visit to i available (before it closes), and w j + v j is the maximum allowed delay time to keep the visit to j available.
For example, if  X  i = 10 am,C i = 2 pm,m i = 1 h , the maxi-mum allowed delay time for i itself is 3 h , i.e., the user can at most delay to arrive at 1 pm . However, a delay at i may affect the visit to the next POI j . If w j + v j = 2 h , that is, the visit to j can be delayed at most 2 h , then the maximum allowed delay time at i is v = min { 3 h, 2 h } = 2 h .

The insertion of k between i and j is possible only if the new route satisfies the probability constraint according to Eqn (7) and the extra time caused by the insertion does not exceed the maxi-mum allowed delay time at j , i.e., w j + v j . The extra time  X  inserting POI k is given by If  X  k  X  w j + v j , k can be inserted between i and j and the insertion transforms i  X  j into i  X  k  X  j , thus,  X  ik =  X  kj = 1 , X 
To determine the score of the insertion of k , we calculate the ratio  X  k as follows: This ratio measures the gain of happiness per unit of extra time of visiting k . The square of r  X  uk places more emphasis on the rating. Since a smaller  X  k has less effect on the feasibility of the whole route, the POI k with a larger ratio  X  k is preferred. We try every adjacent ( i,j ) in the current route to find the best  X  k
After each insertion, the arrival time, wait time, and maximum allowed delay time of all affected POIs in the route should be up-dated according to Eqn (11-13). For example, if k is inserted to form a new route x  X  i 1  X  i 2  X  X  X   X  k  X  j 1  X  j 2  X  X  X   X  y , the arrival time, the wait time and the maximum allowed delay time of any POIs after k ( j 1 ,j 2 ,  X  X  X  ) should be updated, and the maxi-mum allowed delay time of any POIs before k ( i 1 ,i 2 ,  X  X  X  ) should be updated. Moreover, the updates must follow the orders imposed by the dependency in Eqn (11-13). For example, Eqn (13) requires first updating a later POI before updating an early POI in a route.
This section presents the empirical evaluation of the proposed methods. We adopt the Yelp 1 and Foursquare 2 data sets in our experiments. Both data sets were previously used for recommendation evaluation in [10]. The Yelp data set contains 45,981 users, 229,906 ratings of 1-5 scales, 11,537 POIs, plus text reviews on POIs. We prepro-cessed the reviews by removing stop words and infrequent words occurring in &lt; 100 reviews, and using the remaining 8,519 key-words as the features. The feature set or content of a POI, B consists of all keywords contained in the reviews about the POI. The Foursquare data set contains 20,784 users, 153,477 binary 0/1 ratings, 7,711 POIs, and user published tweets when checking-in at a POI. We obtained 1,377 features after preprocessing the tweets.
For each POI i , the touring time m i is set to 1 hour, and the opening hours were generated from a Gaussian distribution, ( C O )  X  N (  X , X  ) with the mean  X  = 5 hours and the standard error  X  = 1 . The open time O i was generated using a uniform distribu-tion, O i  X  U (8 , 12) . We set the departure time T 0 to 8 am . The expected traveling time E [ t ij ] for a pair of POIs ( i,j ) is estimated using Google Maps 3 with the driving mode. All the experiments were run on a PC with 2.53 GHz Quad-Core CPU and 12G mem-ory. http://www.yelp.com/dataset_challenge/ https://foursquare.com/ https://www.google.com/maps
First, we evaluate the first step of our approach, that is, the ac-curacy of estimated ratings of POIs produced by the feature-centric collaborative filtering. For both data sets, we keep 90% rating data for training to conduct matrix factorization and use the remaining 10% rating data for testing the accuracy of estimated ratings. As in the literature [22], we use the standard RMSE (root mean squared error) and MAE (mean absolute error) as the accuracy metrics for POI recommendation. The smaller these values are, the better the result is.

Many POI recommendation approaches are based on topic mod-eling, for example, STM [10] and LCA [29] predict the probabil-ity of visiting a POI, for which the error specific metrics such as RMSE/MAE are incomputable because probabilities are not com-parable with ratings. For this reason, we evaluate the following methods.

Probabilistic matrix factorization (denoted PMF): This is the classic matrix factorization on the user-item rating utility matrix [21] where POIs are treated as items. In PMF, matrix factorization is generalized as a probabilistic model where a latent user vector p u  X  X  (0 , X   X  1 p I D ) , a latent item vector q i  X  X  (0 , X  predicted user u  X  X  rating on item i is given by r  X  ui = p adopt the default settings in [21] and set D = 10 , the dimensional-ity of user and item latent factors.

Collaborative topic regression (denoted CTR): This is the ma-trix factorization with topic modeling applied to the content of items described in [26]. For our data sets, items are POIs and content of user reviews on POIs. LDA is employed on POI i  X  X  content to learn the latent topic vector  X  i , which is incorporated into the PMF framework to confine the search of latent item vectors by setting q  X  N (  X  i , X   X  1 q I D ) . We adopt the default settings in [26] and set D = 10 .

Feature centric collaborative filtering (denoted FCF): This is the proposed algorithm in Section 3.1. All the parameter settings are the same as in PMF.
 Table 1 shows the results of accuracy of the above three methods. FCF achieves the best performance and has a clear improvement in terms of RMSE/MAE on both data sets. So we believe that the estimated rating by FCF is closer to the true rating. In the rest of the experiments, we study the performance of trip recommendation with the estimated rating r  X  ui being generated by FCF.

In this section, we evaluate the trip route P found by TripRec under the fixed traveling time model where the traveling time t for a pair of POIs i and j is fixed, because all the baselines consider fixed traveling time. In this deterministic setting, a feasible route always satisfies the completion probability constraint. The model for uncertain traveling time will be considered in Section 7.4.
We focus on three major cities for trip planning, Phoenix (PX) in Yelp, New York city (NY) and Los Angeles (LA) in Foursquare, and choose Central City, Central Park, and Hollywood as both the source and the destination in these cities respectively. For each city, we randomly pick up 100 users from the testing data, and for each user, we select the top n = 150 unvisited POIs, ranked by their estimated ratings, for trip recommendation. This n is a suggested number in [1]. Even with this restriction, the number of trips that consist of 5 POIs can reach billions, which is certainly infeasible for a brute-force search. We compare the following methods in terms of user happiness F ( P ,u ) and runtime. All the methods adopt the personalized estimated ratings for each POI, learnt by FCF as input.

Greedy algorithm (denoted Greedy): This is the greedy algo-rithm from the operation research literature [24], which iteratively picks up a POI j with the highest ratio of r  X  j /t ij , where i is the location selected at the last step. Note that we have added the POI availability constraint, which is not considered by [24].
Dynamic programming (denoted DP): This is the dynamic pro-gramming approach proposed in [9]. We adapt to the order con-straint by setting a  X  X lobal X  type to each POI and fix the visiting order that is from  X  X lobal X  type to  X  X lobal X  type. However, the dynamic programming by filling up a 2-dimensional array [9] still cannot deal with the POI availability constraint.

Heuristic approximation (denoted HA): This is the heuristic algorithm proposed in Section 6. HA is designed for fast approxi-mation and does not guarantee the optimality of solution. State expansion (denoted SE): This is Algorithm 1 proposed in Section 4. Let SE-SR denote SE with state relaxing. SE guarantees the optimality of solution, but SE-SR does not.

Prefix based depth-first search (denoted PDFS): This is Algo-rithm 2 in Section 5 that uses the prefix based depth-first enumera-tion of POIs. PDFS guarantees the optimality of solution.
Figure 2 (left column) presents the user happiness score of the trips found by all methods, with y -axis being the happiness score averaged over all testing users and x -axis being the time budget b of a trip (hours). Note that SE and PDFS generate exactly the trips of the same happiness score due to their optimality.

Overall, the number of POIs in the recommended route varies from 3 to 7 depending on the setting of the time budget b . As the time budget increases, the happiness of users generally increases. PDFS/SE is the best performer since they guarantee the global op-timum. Interestingly, SE-SR yields a nearly optimal solution as the happiness is only slightly ( &lt; 1% ) lower than that of the optimal PDFS/SE.

HA performs in the third place and there is an obvious gap be-tween HA and the best two. This is because HA only maintains one route during search, which makes it easy to fall into a local op-timum. We will further explain this in the case study below. Greedy performs about 10% worse than HA, as its search strategy is rather simple. DP performs poorly on on all the testing cities, because it cannot deal with the POI availability constraint. In fact, only par-tial happiness is gained for such routes that some of the POIs are already closed when the user arrives, thus, leading to the low hap-piness scores for many users. Meanwhile, DP cannot guarantee a better result for a larger time budget.
Figure 2 (right column) presents the average runtime per user, with y -axis being the runtime (seconds) and x -axis being the time budget of a trip b (hours). HA and Greedy have a fast and sta-ble runtime because both HA and Greedy only maintain one route, but this feature also overlooks other possible combinations of POIs, thus hardly finding optimal solutions. SE suffers the out of memory Figure 2: The fixed traveling time model: (left) happiness of trip routes found ( y -axis) vs time budget ( x -axis); (right) average run-time ( y -axis) vs time budget ( x -axis). problem when the time budget is over 7 hours because there are too many  X  X pen X  states in each iteration, which exhausts the memory when the time budget is large. PDFS avoids this problem by the prefix based depth-first enumeration. Although it takes the longest time at b = 5 h , PDFS finds the optimal solution without having the steep increase of runtime encountered by SE. SE-SR takes sub-stantially less time than SE by trading optimality for efficiency.
For a randomly selected user with b = 8 h , Figure 3 shows the trip routes designed by PDFS and HA, on the local map of LA, where Location 1 is the source and the destination. The visit fol-lows the increasing order 1  X  2  X  X  X  X  X  X  1 . PDFS and HA share many POIs in their recommended trip routes (e.g., POIs 2, 3, 6, 7 for PDFS) due to that both methods adopted the personalized pref-erences. However, HA maintains only one route and easily falls into a local optimum. For example, while POIs 1 and 3 are spa-tially far away from POIs 2 and 6 in Figure 3(b), HA visits these POIs in the order 1  X  2  X  3  X  6  X  1 , in which every sub-route is between two POIs that are far away, thus, too much time is spent on traveling. In contrast, PDFS designs the route in a circle, which reduces the number of sub-routes with long traveling time and al-lows the user to visit one more POI than HA within the same time budget.

In summary, PDFS finds the optimal solution with less runtime than SE; SE-SR is a very good trade-off for efficiency at a slightly lower happiness than the optimal solution; HA is very efficient but sometime has a significantly lower happiness. Overall, PDFS and SE-SR are two best performers considering both quality and effi-ciency. Figure 3: Case study of recommended trip routes for LA. The num-ber in bracket is the happiness of the trip.
In this section, we study the effect of the uncertain traveling time on SE-SR and PDFS. For the traveling time distribution of t a sub-route i  X  j , we adopt the log-normal distribution t LN (  X  ij , X  2 ij ) in Section 3.3. Note that E [ t ij ] = exp(  X   X  ij is generated from a uniform distribution to introduce the uncer-tainty, i.e.,  X  ij  X  X  (0 . 5 , 2) .

Figure 4 (left column) presents the happiness scores of SE-SR and PDFS with various threshold  X  on completion probability. A color represents a method and a pattern represents a threshold  X  on completion probability. Compared to the case for the fixed traveling time in Section 7.3, the happiness of both methods become lower given the same time budget. For example, there is about 20%-40% reduction of happiness from the fixed time cases at  X  = 0 . 9 and b = 5 h . This is because the route designed in the previous section, although having a higher happiness, may violate the completion probability constraint due to the variance of traveling time, and a more strict constraint (i.e., higher threshold) results in less happi-ness. In practice, if the user prefers a more reliability of a trip, a route with higher completion probability but a bit less happiness is acceptable.

The uncertain traveling time model also accelerates the runtime of both methods, as shown in Figure 4 (right column). As the com-pletion probability threshold  X  increases, there are fewer feasible routes and both methods prune the routes with the probability be-low the threshold earlier. A cross examination with Figure 2 indi-cates that at  X  = 0 . 7 , the runtime of these methods with modeling uncertain traveling time is close to that with the fixed traveling time model. However, it is almost an order of magnitude less in runtime at  X  = 0 . 9 .
Most location-based recommendation falls into this category, which scores each POI individually and recommends top-k POIs to a user. Some examples in this category include [4], [13], which consider no content information, [10], [16], and [29], which consider con-tent as side information. The key difference between trip recom-mendation and POI recommendation is that POI recommendation considers neither the order of visiting POIs nor the time budget of users and the POI availability constraint. Recommending a visiting order of several POIs to maximize user satisfaction under such time constraints is the main focus of trip recommendation. Travel package or itinerary recommendation focuses on a tour of POIs instead of isolated POIs, which is similar to trip recommen-dation. [14, 30] applied spatio-temporal streams such as tagged Figure 4: The uncertain traveling time model: (left) happiness of trip routes found ( y -axis) by SE-SR and PDFS vs time budget b ( x -axis); (right) average runtime ( y -axis) vs time budget b ( x -axis). photo streams or GPS trajectories to seek for a feasible path by topic modeling or Markov models. [8, 17] developed several prob-abilistic models to generate possible packages by considering cost, season, area, etc. [1] used user feedback to improve results on in-teractive tour recommendation. None of these works focus on the objective to maximize user X  X  happiness. [7, 9, 18] maximized user X  X  happiness in travel recommendation. [9] assumes a fixed order on the types of POIs visited, which is not suitable in the presence of constraints such as opening hours of POIs. The greedy algorithm proposed in [7] cannot guarantee the global optimality. [18] adopted memory-based collaborative filtering to estimate user specific preferences, which are dynamical with time. All these works do not consider the POI availability and probability constraints. The first two works do not consider user specific preferences, thus, generate the same itinerary to all users.
The orienteering problem (OP) [25] studied in operation research and theoretical computer science is related to our problem. In OP, a set of vertices is given, each with a score. The goal is to determine a path, limited in length, that visits some vertices and maximizes the sum of the collected scores. However, there are some important differences between trip recommendation and OP. First, OP does not consider personalized user preferences so only a global trip is planned. Second, OP has no touring time for each location, which is an important factor affecting the number of POIs visited. Finally, we consider the uncertain traveling time between POIs through the completion probability constraint, which is absent in OP. While most works on OP focus on heuristic approaches [23, 24] to es-timate the global optimum of OP, we present an optimal solution to trip recommendation through a prefix based depth-first search strat-egy with a focus on efficiency through incremental reconstruction and dominance based pruning of routes.

Other works on real life scheduling problem are related to our modeling of the uncertain traveling time. For example, [2] con-sidered multiple types of transport within a single trip and adopted Monte-Carlo simulation to estimate the probability of catching the trip in non-deterministic transport networks. [27] introduced a Bayesian model to estimate the distribution of ambulance traveling time on the road in a city.
We formulated the personalized trip recommendation problem, which is NP-hard, to retrieve a sequence of POIs that maximizes user X  X  satisfaction according to user X  X  historic activities with vari-ous constraints including user X  X  time budget, POI availability and uncertain traveling time. We presented both optimal solutions and heuristic solutions to this problem. Our evaluation on real life data sets suggested that PDFS is the most efficient algorithm for optimal solutions and SE-SR improves efficiency at a slightly lower quality than optimal solutions.

Several variations are possible in the presented trip recommen-dation model. One variation is to factor the touring time of a POI in the happiness score, that is, it is more important for a POI with a longer staying time to be preferred by the user than a POI with a shorter staying time. We can also factor the completion probability of a trip in the score, in addition to a threshold on the probability. Another variation is adding a financial budget constraint of a user, in addition to the time budget, assuming a cost for traveling and a cost for visiting a POI. If the type of a POI is given and if the diversity of POIs is a desirable goal, we can enforce the specific types of POIs in a trip, or a minimum number of different types in a trip, on a feasible state to prune the search space. These varia-tions or extensions require only a minor modification to our current algorithms.

