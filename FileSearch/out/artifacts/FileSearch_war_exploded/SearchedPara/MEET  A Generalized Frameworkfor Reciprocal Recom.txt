 Reciprocal recommender systems refer to systems from which users can obtain recommendations of other individuals by satisfying preferences of both parties being involved. Differ-ent from the traditional user  X  item recommendation, recip-rocal recommenders focus on the preferences of both par-ties simultaneously, as well as some special properties in terms of  X  X eciprocal X . In this paper, we propose MEET  X  a generalized fra M ework for r E ciprocal r E commenda T ion, in which we model the correlations of users as a bipartite graph that maintains both local and global  X  X eciprocal X  util-ities. The local utility captures users X  mutual preferences, whereas the global utility manages the overall quality of the entire reciprocal network. Extensive empirical evalua-tion on two real-world data sets (online dating and online recruiting) demonstrates the effectiveness of our proposed framework compared with existing recommendation algo-rithms. Our analysis also provides deep insights into the special aspects of reciprocal recommenders that differenti-ate them from user  X  item recommender systems.
 Categories and Subject Descriptors: H.3.3[Information Search and Retrieval]: Information filtering General Terms: Algorithms, Design, Experimentation Keywords: Reciprocal Recommender, Global and Local Regularization, Bipartite Graph
Recommender systems have been intensively studied in both academia and industry, following a paradigm of pro-viding a target user with a list of items that the user might prefer, i.e., the user  X  item recommendation. In recent years, a special class of recommender systems  X  reciprocal recom-menders  X  have emerged, and are tailored for applications that focus on recommending people to people, in which the preferences of both parties involved in the recommendation need to be satisfied. For instance, in an online recruiting system, a job seeker would search jobs that match his/her preference, e.g., the special skills and the salary; and a re-cruiter might seek suitable candidates to fulfil the job re-quirement. Other illustrative examples of reciprocal rec-ommenders include online dating services, online mentoring systems, customer-to-customer marketplaces, etc.

Obviously, the major challenge of reciprocal recommender systems is how to satisfy the needs of both users in a rec-ommended match. This requires modeling the bilateral re-lations between users by considering the double-sided pref-erences. However, simply considering the bilateral relations is insufficient in the reciprocal community. In practice, re-ciprocal recommenders, such as online dating and online re-cruiting, possess special characteristics differentiating them from traditional user  X  item recommender systems. Figure 1 illustrates some challenges in these systems. We summarize the challenges as follows: Figure 1: A toy example in an online dating system.
The aforementioned challenges are essential to a success-ful reciprocal recommender system. Previous studies either focus on handling the main reciprocity of the recommender, or delve into a specific issue that exists in reciprocal recom-menders. Little research work has been proposed to address the challenges in a principled and unified manner. In our work, we model the bilateral relations of users as a bipar-tite graph that maintains both local and global utilities in a reciprocal community. The local utility captures users X  mu-tual preferences by considering reciprocity , limitedness and passiveness ,whereasthe global utility manages the overall quality of the entire reciprocal network in order to resolve the sparsity problem. The bipartite graph is constructed based on the users X  self-descriptive and preference features, andthenisrefinedbyusers X  X nteractiveactivities.

In summary, the contribution of our work is three-fold: 1. We propose a generalized reciprocal recommendation 2. We define a novel quality metric (Set Vitality) to in-3. We perform empirical evaluation on two real-world re-
The rest of the paper is organized as follows. Section 2 presents a brief summary of prior work relevant to recipro-cal recommenders. In Section 3, we formalize the problem. Section 4 presents an overview of the generalized framework. In Section 5, we describe the feature space generally used in reciprocal recommenders. We then present the algorithmic details of our framework in Section 6, and discuss the gener-alization in Section 7. Empirical evaluation of our method compared with different baselines is reported in Section 8. Finally Section 9 concludes the paper.
Reciprocal recommenders provide platforms for people to achieve a win-win situation. A couple of interesting methods have been proposed to address issues of reciprocal recom-mendation from both mathematical and practical perspec-tives. In the following, we highlight the previous research that are most related to our work.

In mathematics, reciprocal recommendation can be mod-eled as the well-known stable marriage problem [10], which aims at finding an optimal matching between two sets of el-ements given a set of preferences for each element. Similar problems include stable roommates and college admissions problem. In our problem setting, we do not require to pro-vide an optimal matching for any pair of users, as we need to consider other properties of a reciprocal recommender, e.g., to enhance the vitality of the entire reciprocal network.
In practice, reciprocity in a recommender system refers to the bilateral relations between people. This reciprocity is often considered in social matching in a broader sense [19]. Several existing methods [2, 13] focus on people-to-people recommendation in social networks, in which people have a dual role as both  X  X sers X  and  X  X tems X . Although the reci-procity is emphasized in these methods, they failed to con-sider other important properties of a reciprocal recommender, as we discussed in Section 1.

Pizzato et al. analyzed the characteristics of reciprocal recommenders in detail [15], by providing a comparison of the reciprocal recommender against traditional recommender systems. However, they did not address all the concerns of the reciprocal recommender in a unified way. In their follow-up works [1, 16, 17], they focused on how to capture the bi-lateral preference of users and presented different strategies to model the reciprocity between users in an online dating environment. Beside the online dating, there are a couple of works focusing on other reciprocal domains, e.g., online recruiting [21] and expertise management [18, 12]. Unfortu-nately, the special issues of reciprocal recommendation are not properly handled in previous works. These issues render the recommender not effective (as demonstrated in the ex-periment). Different from these previous works, in our study we shed light on not only the bilateral correlations between users, but also the passiveness and limitedness of users, and the sparsity of the reciprocal network, and provide a unified solution for reciprocal recommenders.

Reciprocity has also been investigated in Information Re-trieval (IR) community. In [6] the problem of match-making is modeled as the retrieval and ranking of candidate matches for a given user. To this end, a series of features are ini-tially extracted from user profiles, and then the correlation between the queries and the candidate is formalized in a feature level. The ranking function is learned via gradient boosted decision tree [9] over the extracted features. Our problem setting is more general than theirs since the search can be regarded as an explicit recommendation process.
In this section we formally state our problem. We consider the reciprocal recommendation scenario consisting of two sets of users U and V , in which each user maintains a self-description, F s , about himself/herself and a preference, towards users in the other set. For example, in an online dating system, the two sets of users correspond to men and women; in an online recruiting system, they correspond to recruiters and job seekers. F s and F p are composed of a set of descriptive attributes, which might be scalar, categorical or free texts. Given a user u  X  X  , our goal is to recommend u a list of users Q u  X  X  such that F p u of u and F p v of any v  X  X  u are both satisfied, i.e., the reciprocity .
Definition 1. An Optimal Match: Given two users u  X  X  and v  X  X  , the pair (u,v) is said to be an optimal match iff F s u maximally satisfies F p v and F s v maximally sat-isfies F p u .

Ideally, we expect that all the recommended pairs ( u, v ) are optimal matches. However in practice, the optimality cannot be fully achieved. In general, the capacity of a user receiving and responding recommendations in the scenario of reciprocal recommenders is quite dissimilar to the one of traditional user  X  item recommenders. For example, a boy cannot date with ten girls simultaneously. Therefore, in reciprocal recommenders, it is imperative to consider the limited capacity of users, i.e., the limitedness .
Definition 2. Availability: Given a budget b ,auser u  X  X  is said to be available if the number of recommen-dations that u receives is less than b within a time range We use  X  ( u ) to indicate the number of times that u has been recommended to other users within t , e.g., one week.
Definition 3. A Successful Match: Given two users u  X  X  and v  X  X  ,thepair( u , v ) is said to be a successful match iff F s u suboptimally satisfies F p v and F s v suboptimally satisfies F p u , w.r.t. the availability of u and v .Wedenotea successful match as u  X  = b v or v  X  = b u .

A user-oriented recommender should be capable of getting all users involved in an interactive community. In practice, a user might often interact with other users through different channels. For example, in an online recruiting system, a job seeker often sends resumes to recruiters and a recruiter often makes interviews with job seekers. Similarly, in an online dating system, people often send messages to whom they prefer. However, there are still a great number of users that passively receive such interactions from other users, i.e., the passiveness , which to some extent violates the reciprocal property of the entire community. Therefore, we need to consider the passiveness of a user in order to enrich the vitality of the reciprocal community.

Definition 4. Vitality : Given a user u and his/her in-teractive activities with other users, u is said to be vital if theaveragenumberof u  X  X  interactions, avg ( | u  X  | ) , reaches the average number of interactions within the entire recipro-cal community.

In a reciprocal recommender system, a vital user is pos-sible to improve the engagement of passive users, e.g., by sending messages to a shy boy to ask him for a date. By recommending passive users to vital users and vice versa, the overall vitality of the recommendation community would increase to some extent. It is possible that considering the vitality of users might deviate the definition of a successful match. However, the success of a recommendation is not solely determined by the match. The engagement of users after receiving the recommendation is also an important in-dicator to a successful recommendation.

We are expected that all the recommendations are suc-cessful matches in a reciprocal recommender, by considering both the bilateral preferences of individuals and the vitality of users. We now define our technical problem of reciprocal recommendation as follows.

PROBLEM (Reciprocal Recommendation) : Given auser u  X  X  (or v  X  X  ) and a budget b (the availability), recommend for u (or v) a list of users Q u  X  X  (or Q v  X  X  ), such that  X  v  X  X  u (or u  X  X  u ), u  X  = b v (or v  X  = b u ), and also the vitality of u (or v) should have potential to increase.
The essence of reciprocal recommendation, including reci-procity , limitedness and passiveness , has been well captured in the above problem formation. We will discuss our solution to the problem of reciprocal recommendation in Section 6.
Figure 2 shows an overview of our proposed reciprocal recommendation framework, MEET . It consists of three in-terrelated components:
Graph Construction and Updating (Section 5 and 6.3): The reciprocal community is represented as a bipartite graph based on the bilateral preference of users. MEET au-tomatically analyzes the feature space of users and calculates the relevance between users from different sets. In addition, MEET treats the profiles of users who have successfully ob-tained their preferred information (e.g., jobs or friends) as the basis to learn the weights of features, and consequently improves the quality of the generated bipartite graph.
Bipartite Graph Partition (Section 6.1): To provide reasonable results and expedite the recommendation pro-cess, MEET first partitions the bipartite graph into differ-ent pieces, and then performs the recommendation on sub-graphs. The subgraphs obtained by graph partition contain more specialized structures of the community, and therefore provide an elegant base for further inference.

Recommendation Inference (Section 6.2): Besides the relevance between users, MEET also considers the interac-tive activities within the community, and refines the sub-graph based on such information. In each refined bipartite subgraph, the recommendation problem is modeled as an op-timization problem, and the result is obtained by performing the inference over different sets of users.
In our problem setting, the profile of a user is composed of two types of features: a self-description, F s , and a prefer-ence, F p .Givenauser u  X  X  , we are interested in finding a relevant user v  X  X  , such that ( u , v ) is a successful match. In Definition 3, we relax the condition of the perfect reciprocal match and allow partial matches of the users X  preferences. By relevance ,wemeanthat F s v matches F p u , and meanwhile, u matches F p v . Therefore, the relevance includes two com-ponents, rel ( u  X  v )and rel ( v  X  u ). Here, the relevance cannot be regarded as the affinity between users, but a quan-titative measure that describes how matchable the two users from different user sets are. Both rel ( u  X  v )and rel ( are calculated using the same set of attribute-value pairs for any user pair, and hence the relevance is comparable.
To calculate the relevance, we consider three groups of features that we believe have the predictive power of rele-features, whereas the others are the self-description features. vance, including scalar features, categorical features and free texts. The features used in online dating data set are listed in Table 1. For scalar features, we first categorize them into different ranges, e.g., the length of working experience in-cludes 0-3 years, 3-5 years, 5-10 years and 10-years. We then encode these ranges as binary features, e.g., if a user X  X  working experience falls into the range of 0-3 years, then this feature (0-3 years) would be set to true (1), and all other ranges would be set to false (0). With categorical attributes, we use the same strategy of dealing with working experiences ranges. For free text features, we transform the text into an l -normalized TF.IDF-based term vector, and then combine this vector with the vector obtained based on other types of attributes. We can also specify the importance of each attribute. Finally, rel ( u  X  v )or rel ( v  X  u ) is computed using the cosine similarity of the two corresponding vectors.
Once we obtain the relevance scores of both rel ( u  X  v ) and rel ( v  X  u ), we integrate these two scores as the final relevance between u and v , described in Eq.(1): We use the product of these two scores instead of the linear combination to eliminate the condition of unilateral prefer-ence, e.g., a job position is preferred by an applicant but the applicant is not suitable for this job. In addition, the relevance model is simplified since no parameter is involved.
In MEET , a reciprocal network is represented by a bi-partite graph based on the mutual relevance of users. The recommendation is achieved by first partitioning the graph into multiple subgraphs, and then performing label inference on a specific subgraph with respect to the target user.
A reciprocal community involves two different sets of users interacting with each other. It is intuitive to represent the community as a bipartite graph, where each set of users can be denoted as a set of nodes in the graph, and the rele-vances between users can be described by the edges in the bipartite graph. Note that the relevance quantifies the de-gree of match between two users, and hence the edges in the graph are not directional. The relevance score is filtered by a threshold  X  to reduce the probability of a dense graph. A toy example can be found in Figure 1.

The recommendation can be achieved by analyzing the properties of the bipartite graph and the special character-istics of the target user. However in practice, the number of users involved in such a bilateral community might be large, which renders direct analysis on the entire bipartite graph inefficient. Taking into account the scalability issue, we pro-pose to simultaneously separate the two sets of users in the graph into several groups, such that within each subgraph, the focus of users are more specialized, e.g., users that are all in the community of engineering in an online recruiting system. In this way, the generated subgraph contains less users with more similar preferences.

A simple way of partitioning the data into groups is to cat-egorize the data by the attributes. However, the data con-sidered in our problem setting is not fully structured, with text descriptions involved. Even if the text description can be transformed to quantitative values, the values of other at-tributes might be missing, which results in the difficulty of attribute selection for partitioning. The way we represent the data as a bipartite graph and use graph-partitioning methods to regroup users helps resolve the issues mentioned above.

Formally, given a bipartite graph G =( U , V ,E, w )where w : E  X  R , our goal is to partition the vertex sets U and V into k disjoint clusters, i.e., U = {U 1 , U 2 ,  X  X  X  , U k V = {V 1 , V 2 ,  X  X  X  , V k } . Clearly the  X  X est X  clustering would correspond to a partitioning of the graph such that the cross-ing edges between clusters have minimum weight, denoted as cut , cut ( U 1  X  X  1 ,  X  X  X  , U k  X  X  k )= min where G 1 ,  X  X  X  , G k is any k -partitioning of the graph
The problem defined in Eq.(2) is essentially a co-clustering problem, which can be solved by many existing methods [5, 20]. In this paper, we will not focus on how to resolve the co-clustering problem. We employ a graph partitioning method [4] as the solution. The method proposes a spectral co-clustering algorithm that uses the second left and right singular vectors of an appropriately scaled user-user matrix to yield good bi-partitions, which is essentially suitable to our partitioning task.

By partitioning, we can obtain a list of subgraphs that embrace specialized information about each small recipro-cal community, which can be well explained under different real-world cases. Let us take the online recruiting system as an example. For each subgraph, it may represent dif-ferent areas of work, e.g., computer engineering , chemical engineering and finance . Such a subgraph characterizes the special properties of the area of work, and therefore provides us a reasonable and effective base to perform reciprocal rec-ommendation.
Given a specialized community represented by a bipar-tite subgraph, our goal is to recommend for each user an attractive list of users from the other user set. By consider-ing the characteristics of the reciprocal recommendation, we employ the bipartite graph inference to obtain the recom-mendation result. Besides the relevance between users, we have the interactive activities, e.g., messages and chatting in online dating, and adding favorite jobs and sending inter-views to applicants in online recruiting. We also take into account the availability of the users. We refine the bipar-tite subgraph based on these information. After refinement, each vertex has its vertex attribute, i.e., the availability, and also has two sets of edges, including the relevance edges and the activity edges. The relevance edge is undirected, and the activity edge is directed, indicating which vertex is the initiator of the activity.

A natural question is why we do not consider the activity information when partitioning the bipartite graph. Within the reciprocal community, not all the users have sufficient activities; if we incorporate the activities into the partition-ing process, the generated results might isolate users with few activities from more active users, which may render the recommendation for these inactive users not reasonable.
Formally in our problem setting, a bipartite graph G  X  = ( U , V ,E r ,E a , w r , w a ) consists of two sets of vertices, V , and two sets of edges, E r ,E a  X  X  X V .Eachedgein E r is an undirected pair of nodes weighted by rel ( u, v ), i.e., w r : U X V X  R r .Eachedgein E a is an ordered pair of nodes [ u, v ] representing the activity connection from u weighted by the ratio of the activities toward the end node and all the activities of the initial node, i.e., w a : U X V X  R . Given a vertex v in G  X  (either v  X  X  or v  X  X  ), the in-degree p ( v ) and out-degree q ( v ) are defined as p ( v )= Let H ( G  X  ) denote the space of functions f : U , V X  R ,which assigns a real value f ( v )toeachvertex v .
Given a bipartite graph representing the relevance struc-ture of the reciprocal network , a simple solution to the rec-ommendation is to select top relevant users that directly link to a given user as the recommended result. However, the specific properties (availability and vitality) of users in a reciprocal community would be ignored if we follow such a simple paradigm. For example, a job seeker u has been recommended to multiple job recruiters; if we recommend u to a new job recruiter v ,then u will have little chance to respond v , even if they are relevant in some sense. In such a situation, it would be more reasonable to recommend for v other job seekers who are similar to u ,whichises-sentially collaborative filtering. Yet, both directional and non-directional information on the bipartite graph cannot be easily incorporated into traditional collaborative filtering algorithms. A much more natural solution to this problem is to perform graph inference on the bipartite graph to obtain the recommendation list.

Our inference paradigm is motivated by [23], in which the graph inference is performed on a directed bipartite graph to solve the problem of classification. The problem setting in their method is similar to ours. However, they only con-sider the directional information within the bipartite graph, i.e., the in-degree and out-degree of nodes, but fail to con-sider the rationality of the connectivity between nodes, i.e., why the two nodes are connected with each other, which is essential in the problem of reciprocal recommendation. In our work, we explicitly model the rationality of the con-nectivity of nodes as the relevance between users, by which the connectivity can be naturally explained, and the final recommendation result is more reasonable and explainable.
Formally, if two distinct vertices u 1 and u 2 in U are co-linked by vertex v in V , it indicates that the properties of both u 1 and u 2 are likely to be similar, e.g., both job seekers are similar in profile-wise since they are all preferred by the same job recruiter. The co-linkage strength induced by v between u 1 and u 2 canbemeasuredby c v ( u 1 ,u 2 )= w r ( u 1 ,v )  X  w r ( u 2 ,v )  X  With such a similarity measure, we not only consider the interactive activities of users ( w a ( v,u 1 )and w a ( v,u also emphasize the relevance between users ( w r ( u 1 ,v w ( u 2 ,v )). It can be naturally understood in the context of online dating. If two boys are simultaneously contacted by a girl, then it indicates that both boys have similar charac-teristics that are preferred by the girl. Moreover, the more girls contact both boys, the more significant the similarity. A natural question arising in this context is why the simi-larity measure is further normalized by out-degree of v .It can be easily interpreted if we use the previous example. A girl who sends messages to a lot of boys may not have clear preference on what boy characteristics, and therefore the induced similarity of two boys by this girl is not significant.
In Eq.(3), we penalize the influence of active users by nor-malizing the similarity score using q ( v ). It should be clari-fied that the vitality of the community cannot be reflected by flooded messages without definite purposes. The way we formalize the similarity considers the importance of dedi-cated users, e.g., if a girl is interested in a boy, she will not send too many messages to other boys but focus on build-ing the relationship with this boy. Such an observation is beneficial to construct a vibrant reciprocal community.
Let f denote a function defined on one vertex set U .Then the inference cost of function f canbemeasuredbythe following functional: In Eq.(4), we penalize large differences in function values for vertices in U . Notice that the function values are nor-malized by in-degrees of the corresponding vertices. In the context of online dating, the explanation is similar to the one given before. Many girls will prefer a handsome and success-ful man, which does not mean that these girls have similar preferences over the characteristics of the man. However, if two girls are sending messages to a boy without handsome appearance and strong background, it is likely to express a common interest of both girls. We also consider the avail-ability of users using the reverse of  X  ( u ). If the user has been recommended to other users many times within a time range, e.g., one week, then the possibility of this user being recommended to the target user should be small.

Similarly, the inference cost of function f on the vertex set V canbemeasuredby: Convexly combining together the two cost functionals Eq.(4) and Eq.(5), we can obtain an inference cost measure of func-tion f over the bipartite graph G  X  :
 X   X  ( f )=  X   X   X  U ( f )+(1  X   X  )  X   X  V ( f ) , s.t. 0  X   X   X  where the parameter  X  indicates the relative importance be-tween  X  U ( f )and X  V ( f ).
 X   X  ( f ) captures the inference cost of labeling nodes in a bipartite graph. For recommendation, the intuitive idea is to minimize the inference cost, since we want to find the set of users closely relevant yet not recommended to the target user, by making use of the co-linkage of nodes. Besides the inference, we have additional information about users in re-ciprocal communities, i.e., the interactive activities, which can be regarded as a user X  X  engagement profile for recom-mendation. Formally, given a user in u  X  X  , we can define a function y in H ( G  X  )inwhich y ( v  X  X  )=1ifvertex v has interaction with u ,or0if v has never interacted with Then the recommendation problem can be regarded as the problem of finding a function f , which infers new vertices for u while reproducing the target function y to a sufficient degree of accuracy [22, 7]. A formalization of this idea leads to the following optimization problem: where  X &gt; 0 is the regularization parameter. The first com-ponent measures the inference cost of function f ,andthe second component indicates the closeness of f with respect to the given function y . The trade-off between these two competitive terms is captured by  X  . The solution of Eq.(7) can be found in [22].

After obtaining the result of f  X  ( u )foruser u ,wecantake sign f  X  ( u ) to select the vertices in V whose labels are 1, and then rank the selected users based on the mutual relevance of users, i.e., rel ( u, v ). The final recommendation result is obtained by selecting the top ranked ones without consid-ering the users who have already interacted with u and the users whose availabilities e xceed the availability budget Further, if the target user is a vital user, then the recom-mended list will be ranked via the vitality of users in an ascend order; otherwise, the list will be ranked in a descend order of the vitality. In this way, the engagement of passive usersispossibletobeimprovedtosomeextent.
In the context of reciprocal recommendation, e.g., online dating and online recruiting, users will not return to the sys-tem during a long time period if they obtain their preferred friends or jobs. In this case, the system will not recommend them any further information. However, such users X  profiles are good indicators showing that the recommendation of the system is successful, and therefore they have great potential to improve the quality of the reciprocal network. In MEET , we filter out the profiles of these  X  X uccessful X  users, and then analyze their properties in order to facilitate the construc-tion of the bipartite graph.

Specifically, we use feature weighting algorithms to cap-ture the relative importance among different user features. Feature weighting has already been extensively explored [3, 8]. In our framework, we choose the Passive-Aggressive (PA) algorithm [3] to learn the weights for different features. The goal of PA is to change the model as little as possible to correct for any mistakes and low-confidence predictions it encounters, with the following optimization: Updates occur when the inner product does not exceed a fixed confidence margin, i.e., y t ( w t  X  x t ) &lt; 1. The closed-form update for all examples is as follows: details.) The PA algorithm has been successfully applied in practice because the updates explicitly incorporate the no-tion of classification confidence. Once we obtain the weights for each feature in the feature repository, we feed them into the relevance model described in Section 5, and then use the refined relevance to construct the bipartite graph.
The reciprocal recommendation framework we propose is quite general. In this section, we show the connections and differences between our framework and various exist-ing methods for reciprocal recommendation. The methods discussed in this section include gradient boosted decision trees (GBDTs) [6], reciprocal recommender for online dat-ing (RECON) [15] and content-collaborative reciprocal rec-ommender (CCR) [1].

GBDTs and MEET : GBDTs considers the relevance be-tween the query and the candidate by integrating the match-ing attributes and post-presentation (activities) features into a unified feature vector. Based on this vector, GBDTs cal-culates the relevance score between two single users. MEET considers a more general problem  X  recommendation, in which a user might have no definite preference on the in-formation and therefore no explicit query is specified. Also the post-presentation features might not be available to new users. Moreover, MEET formalizes the reciprocal commu-nity as a dynamic network, whereas in GBDTs, the users are treated individually.

RECON and MEET : RECON calculates the compatibil-ity scores between users from different sets by considering the self-description attributes and the activities. However, it fails to consider the other special characteristics of recipro-cal recommendation, e.g., the sparsity ,the limitedness and the passiveness . Insuchsense,RECONcanberegardedas a special case of our proposed generalized framework.
CCR and MEET : CCR computes the users X  similarity based on the content of user profiles, and then performs recommendation from collaborative-wise. It considers the a single-step diffusion of  X  X ike X  and  X  X islike X  of users towards other users. Such a diffusion is also incorporated into MEET by the inference on the refined bipartite graph. Therefore, CCR can also be treated as a special case of MEET .
Online Dating Data : This data set is collected from a dat-ing web site from Oct, 2008 to Mar, 2011, with anonymized user information. The original feature space is described in Table 1. We transform the features using the strategy de-scribed in Section 5, and then calculate the user relevance based on the new feature space. We set U as the male set and V as the female set. The statistics of this data set is depicted in Table 2(a).

Online Recruiting Data : This data set is provided by Xi-amen Talent Service Center 1 , a popular online recruiting platform in China. We collected the profiles and activities for anonymized users from Jan, 2008 to Oct, 2011. The fea-ture set is not listed due to the space limit. We set U as the job seeker set and V as the recruiter set. We use the same strategy to process this data set. The statistics of the data after processing is described in Table 2(b).
For experiments, we split the two data sets into training and testing sets. Each set includes two sets of users, asso-ciated with their interactive activities. Since a reciprocal recommender system may suffer from the sparsity problem, we treat users who do not have activities within 3 continued months as  X  X uccessful X  users and feed their profiles into the learning module for feature weighting. These profiles will not be included in the bipartite graph. Table 3 summarizes the details of training and testing datasets for both online dating and online recruiting data.
 Table 3: Statistics of training and testing datasets.
Foreachuserinthetestingset,werecommendtopranked users (top@10, top@20 and top@30) to the user at each week of the testing range. Within the testing set, each user has a series of activities, e.g., sending messages to other users. Based on such activities, we use different evaluation metrics to verify the quality of the recommended user list.
Set Evaluation : For comparison, we compute the averaged precision and recall based on users X  activities over weeks. Specifically, the ground truth of a user u  X  X  activities, includ-ing who have been clicked or contacted by u , is denoted by M , and the recommended user list by algorithms is denoted http://www.xmrc.com.cn. by N . Then the precision ( P )andrecall( R )canbecom-puted as We then compute the F 1 -score of the recommendation re-
Ranking Evaluation : We employ Normalized Discount Cu-mulative Gain (NDCG) to evaluate the ranking quality of the recommended list based on a user X  X  actual activity se-quence. NDCG at position n is defined as where N ( n )istheNDCGat n of the ideal ranking list, and r i is the relevance rating of item at rank i .Inour scenario, r i = 1 if the user has clicked on or contacted with the recommended users and 0 otherwise.

Vitality Evaluation : The vitality of a user is an important feature within the reciprocal community. It defines how ac-tive the user is, e.g., how often the user sends messages to other users. By explicitly considering the vitality for rec-ommendation, a vital user improve the engagement of other passive users, which renders the reciprocal network more healthy and energetic. To measure how active that users within the recommended list are, we define the set vitality measurement as the average activeness of all the users in the list. Specifically, given a recommended user set S ,as-sociated with each user X  X  interactive activities u i  X  ,the set vitality of S is calculated as where V u i is the set of users that have been clicked or con-tacted by u i , | u i  X  j | denotes the number of clicks on u and messages that u i has sent to v j and | u i  X  j | represents the total number of interactions between u i and v j .
In this subsection, we first evaluate the effects of local rec-ommendation (recommending users within a bipartite sub-graph) and global recommendation (recommending users within the entire bipartite graph); We then investigate the impact of different reciprocal properties to the recommendation re-sult; Further, we demonstrate the effectiveness of our frame-work on improving the vitality of the reciprocal network. We also provide comprehensive comparisons with recently pub-lished approaches discussed in Section 7.
In our framework, there are several parameters for tuning, including the availability threshold b , the relevance threshold  X  to construct the bipartite graph, the number of clusters k in Section 6.1, the importance factor  X  in Section 6.2.2 and the regularization parameter  X  in Section 6.2.3. For b ,we empirically set it as 30 for online dating and 50 for online recruiting. For  X  , we empirically set it as 0.01 for both online dating and online recruiting data. For k , we empirically set it as 10 for online dating and 20 for online recruiting. We will evaluate the performance of the algorithm with different k in the next section. To explore the effect of the parameters  X  and  X  towards the recommendation result, we use F 1 -score as the evaluation metric to compare the quality of the recommended list (top@10, top@20 and top@30). Note that the optimal parameter setting is obtained by performing cross-validation on the training data .

Figure 3 shows the performance curve with different pa-rameter settings. We first empirically fix  X  as 0.1 and evalu-ate  X  . Figure 3(a) shows the F 1 -score measured as a function of  X  . The optimal value of  X  for online dating is obtained when  X  =0 . 5, meaning that the two sets of users have ap-proximately equal importance towards the development of the online dating environment. However, for the online re-cruiting dataset, the optimal  X  is 0.7, indicating that within the online recruiting system, the inference cost of recommen-dation for job seekers is dominating. Such an observation is consistent with the actual situation since in practice the number of job seekers is superior to recruiters. We then fix  X  as 0.5 for online dating and 0.7 for online recruiting, and evaluate the changing of  X  . Figure 3(b) shows the F 1 -score measured as a function of  X  . The best result is achieved when  X  =0 . 1. In the following experiments, we set  X  as 0.1,  X  as 0.5 for online dating and  X  as 0.7 for online recruiting. Figure 3: Parameter Tuning. Remark: thinner  X  online dating; thicker  X  online recruiting.
For reciprocal recommendation, our proposed framework first partitions the bipartite graph into multiple subgraphs (with specialized information), and then recommends users to the target user within the specific subgraph that embraces this target user. Such a paradigm can not only expedite the recommendation (since we only consider partial bipartite graph), but also improve the quality of the recommendation list. In the experiment, we choose different values of k (the number of clusters defined in Section 6.1) and compare the results with the one using the entire bipartite graph (Global, for short). The comparison is reported in Figure 4.
With different k , the performance of our proposed frame-work varies. MEET achieves the optimal performance when k = 20 for online recruiting dataset. By partitioning the en-tire bipartite graph into multiple subgraphs, the information within each subgraph is more specialized, and therefore the reciprocity within each subgraph becomes considerably dense . However, the performance on online dating is not quite sen-sitive to the number of clusters k .When k = 10, the results are slightly better than the other settings. The reason be-hind this might be that the populations within the online dating community are more general, whereas the ones within the online recruiting community are mostly related to some specific areas. Another interesting finding is that the over-all performance of local recommendation is better than the one of global recommendation, especially for online recruit-ing. This could benefit from the fact that the local presenta-tion of the reciprocal network could help specialize the local community, and therefore facilitate the candidate matching within particular domains .
In our generalized framework, we comprehensively con-sider the special properties of reciprocal recommendation, i.e., reciprocity , limitedness , passiveness and sparsity .To examine the influence of different properties on the recom-mendation results, we evaluate several alternatives of MEET as follows: We compare these alternatives with the comprehensive MEET in terms of F 1 -score and NDCG. Figure 5 shows the com-parison results on two datasets.

It is evident that the generalized model MEET signifi-cantly outperforms the alternatives from both accuracy and ranking perspective. The reason behind this is quite straight-forward: in the generalized model, the special characteristics of reciprocal community are well captured , rendering the rec-ommendation results derived from such unified model more reasonable. Besides this, we observe that: (1) The reci-procity is the dominant aspect in the reciprocal network, since only considering the relevance between users can signif-icantly improve the quality of the recommendation results; and (2) The limitedness , passiveness and sparsity are also important properties of the reciprocal community, by which the performance of MEET can achieve slight improvement.
Our proposed framework is designated to reciprocal rec-ommendation, which cannot be easily tackled by traditional collaborative filtering approaches. To verify this claim, we choose two recently published collaborative filtering meth-ods [11, 14] as our baselines. [11] (CFIF for short) pro-posed treating the data as indication of positive and neg-ative preference associated with vastly varying confidence levels, which is a pure collaborative filtering approach. [14] (OCCF for short) exploited the rich user information avail-able in community-based interactive information systems, and incorporated user information into modeling the rec-ommendation. For this method, we use the neighborhood model as the baseline. We also implement GBDTs [6], RE-CON [15] and CCR [1] (in Section 7) for comparison. We (c) F1 on recruiting.

Figure 4: Performance comparison of local recommendation with different (c) F 1 on recruiting.
 use F 1 -score and NDCG to compare these algorithms with MEET for both online dating and online recruiting datasets. The feature set used in the baselines are identical to the one in our proposed method, and also the parameters in the baselines are optimally tuned.

The results are shown in Table 4. It is evident that MEET significantly outperforms the baselines on both F 1 -score and NDCG. The two collaborative filtering based methods can-not effectively handle the reciprocal task. We investigated the recommendation results of both methods and found that users in most recommended matches are relevant. However, there are two reasons that both users in a match have few or even no interactions :(1) The recommended user has been recommended to multiple users, and therefore he/she has limited availability ;and(2) Both users are not vital, and hence they do not contact with each other .Thethreerecip-rocal methods being compared can slightly improve the rec-ommendation performance; however, they only focus on dif-ferent aspects of the reciprocal community. Instead, MEET provides a comprehensive overview of the reciprocal net-work, and therefore achieves the best.
The recommended user list provided by MEET exhibits a great vitality, which is originated from the sparkle that we intentionally consider the passiveness of users. We as-sume that passive users can be spurred by active users, and formalize the activeness of users in Eq.(3). Such activeness is beneficial to construct an energetic reciprocal network, in which users are willing to proactively contact with each other, and therefore improve the vitality of the network.
To evaluate the vitality of the recommended results, we use the set vitality measurement defined in Eq.(12), and compare MEET with GBDTs, RECON and CCR. These three methods consider the interactive activities of users from different perspectives. We also compare MEET with an alternative MEET 3 that does not consider the passive-ness of users. Note that the recommended list are ranked based on the activeness of users. The ranking quality of the recommended list has been verified in Section 8.2.4, and therefore we put our concern on the overall vitality of the list. We report the comparison results in Table 5. Table 5: Evaluation on the set vitality of the rec-ommended results. (Bold indicates the best per-formance. * indicates the statistical significance at p&lt; 0 . 01 .)
From the comparison, we observe that the set vitality of results from different methods varies a lot. Since our frame-work explicitly formalizes the interaction between users into Eq.(3), it achieves the best performance. An interesting phe-nomenon is that when the number of recommended results increases, most methods show a decreasing trend in terms of the set vitality . Take CCR as an example for further analy-sis. CCR generates the results by considering the users who have interactions with users that are similar to the target user (based on the profile). The user ranking is based on the reciprocal interests. When recommending more users to the target user, the reciprocal interests of users with lower rankings will decrease significantly, and therefore the set vi-tality of the recommended list deceases. Comparatively, in our framework, we prefer dedicated users, i.e., the users who have a lot of interactions with several other users but do not send flooded messages . Based on this intuition, MEET out-performs other candidates. significance at p&lt; 0 . 01 .)
In this paper, we study the problem of reciprocal rec-ommendation. We comprehensively investigate the special properties of a reciprocal community, including reciprocity , limitedness , passiveness and sparsity .Weproposeagen-eralized reciprocal framework, MEET ,inwhichtheafore-mentioned properties are seamlessly integrated. Specifically, MEET first constructs a bipartite graph based on the mu-tual relevance of users, and then performs graph inference on the resulted subgraphs to obtain the recommendation list for individuals. The inference model formalizes the properties of the reciprocal network and elegantly casts the recommen-dation as an optimization problem.

Bilateral reciprocal recommendation discussed in our work might not cover all possible reciprocal recommendation tasks in a broader perspective. For example, friend recommenda-tions on Facebook and colleague recommendations on LinkedIn exhibit different characteristics, since the recommendation activities on these two platforms might involve multiple par-ties instead of two. In the future, we plan to expand our reciprocal framework to tackle more reciprocal tasks. The work is partially supported by NSF grants DMS-0915110 and CNS-1126619 and DHS grants 2009-ST-062-000016 and 2010-ST-062-000039. We would like to thank Xiamen Uni-versity and Xiamen Talent Service Center for providing us with the online recruiting data set used in the paper.
