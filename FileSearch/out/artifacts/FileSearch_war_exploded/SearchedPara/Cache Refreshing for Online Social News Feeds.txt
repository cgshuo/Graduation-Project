 Several social networking applications enable users to view the events generated by other users, typically friends in the social network, in the form of  X  news feeds  X . Friends and events are typically maintained per user and cached in mem-ory to enable e cient generation of news feeds. Caching user friends and events, however, raises concerns about the fresh-ness of news feeds as users may not observe the most recent events when cache content becomes stale. Mechanisms to keep cache content fresh are thus critical for user satisfac-tion while computing news feeds e ciently through caching.
We propose a novel cache scheme called SOCR (Social On-line Cache Refreshing) for identifying and refreshing cache entries. SOCR refreshes the cache in an online manner and does not require the backend data store to push updates to the cache. SOCR uses a utility-based strategy to accurately identify cache entries that need to be refreshed. The basic idea is to estimate at the time of each request to generate news feed whether refreshing would lead to di  X  erent results for a news feed. To make such estimation, we model the rates of changes to social networks and events, and assess the per-formance of SOCR by analyzing datasets from Facebook and Yahoo! News Activity. Our experimental evaluation shows that the utility-based strategy ensures fresh news feeds (43% fewer stales) and e cient news feed responses (51% fewer false positives) compared to the TTL-based strategy. SOCR also reduces data transmission between the backend data store and the cache by 27% compared to a hybrid push-pull cache refreshing scheme.
 H.3.5 [ Online Information Services ]: Data sharing Design, Performance, Experimentation Social networking systems, news feed, cache refreshing
Applications based on online social networks have become very popular in the past few years. Users in social network-ing websites like Facebook, Twitter, and Google+ connect to each other for sharing user-generated content. More special-ized services like Yahoo! News Activity leverage existing so-cial networks like Facebook to share information about news articles. Typically, content shared by users can be viewed as a stream of  X  events  X . For instance, Facebook users can view the recent status updates of their friends; Yahoo! News Ac-tivity users can view the articles that their Facebook friends have recently read at the Yahoo! News site.

We use  X  news feed  X  to denote such a stream of events. To update the news feed a given user observes, the user interface (typically a Web browser or a smartphone application) issues a request to the service backend on behalf of the user. The service backend returns changes to the user news feed and the application updates the visualization of the results. Due to the interactive nature of these applications, it is critical to have low latency when updating news feeds.

A common technique to reduce latency is to store user friends and the events they generate in an in-memory cache [7, 8, 9]. This is especially important for online companies that build their services on top of the data from a third party, e.g. , Facebook. We consider in this work producer-pivoted cache [9], in which cache entries map to users and each user has typically one cache entry for her list of friends and one cache entry for the events she generated. To process a request to update a news feed like  X  get the k most recent events produced by my friends  X , such a system aggregates cached entries, and it only fetches data from the backend if the content necessary to fulfill the request is not cached. A cache also reduces the workload on the backend data store.
Given the online nature of social applications, news feed requests need to be processed in near real-time to include the latest relevant events in the news feeds. To ensure that the content in a news feed is fresh, one approach is to eagerly push every change to the friend list and every new event to the cache when it is inserted to the backend data store [7, 8]. This approach has a few drawbacks, such as inducing operations to update the cache that lead to no change to news feeds and requiring changes to the interface between the cache and the backend to enable pushing events. An im-provement over the push-only approach is to selectively push updates to the cache for users whose friend lists or events are dominated by read to reduce redundant operations [9]. This approach still requires the interface between the cache and the backend. The pushing side needs information about users to be able to make right choices, which introduces even more complexity into the interface.

An e  X  ective alternative to ensure the freshness of news feeds is to refresh the cache lazily, only upon a news feed request and when refreshing is likely to improve freshness. In this approach, it is important to estimate at request time whether the request-related friends and events in the cache have changed and need to be refreshed before being used to generate the news feed.

Accurately assessing whether to refresh the cache is not trivial, however. If we conservatively under-predict changes in the cache and rarely refresh, we risk serving stale news feeds to users. In contrast, if we aggressively over-predict changes in the cache and frequently refresh, we may perform a large number of unnecessary refreshing operations, which indeed fetch data from the backend data store, but add no new event to the news feeds. Ideally, only the cache entries leading to fresher news feeds are refreshed, and those having no impact on news feeds are directly served from the cache.
A natural strategy is to rely on a Time-To-Live (TTL) scheme to expire cache entries. Expired friends and events entries need to be refreshed. By ignoring user behavior, the TTL-based strategy leads poor user experience, poor system performance, or both.

For e ciently refreshing cache content in social network-ing applications, we propose a scheme called SOCR (Social Online Cache Refreshing). SOCR enables both e cient gen-eration and fresh content for news feeds. SOCR adopts a utility-based strategy to refresh cache entries, where util-ity is per-user and a function of user behavior. Unlike the TTL-based strategy, we make each assessment based on the likelihood of the refresh introducing new events or evicting unexpected events.

Contributions. This work makes the following contri-butions:
Roadmap. The remainder of this paper is organized as follows. Section 2 defines the problem and overviews our on-line cache refreshing scheme. Section 3 details the proposed cache refreshing strategies and Section 4 presents their ex-perimental performance. Section 5 concludes the work by discussing related work.

We aim to implement e cient and fresh  X  news feeds  X  for social networking applications that allow users to view a set of  X  events  X  generated by their friends. To generate a news feed, the application running on the user side issues a re-quest to the service backend. Such a request can either be generated periodically and automatically by the application or be initiated by the user. The service backend is com-prised of one or more data stores and it is responsible for aggregating events on behalf of the user.

In this work, we focus on news feeds that contain the k most recent events from the friends of a user. To ensure the diversity of the news feed, and avoid that active friends generating events at a high rate prevent a user from seeing events of other friends, we preferentially select the most re-cent event of k di  X  erent friends to form the news feed of k events. Multiple events of a friend are selected only if the user issuing the news feed request has fewer than k friends who have generated an event until the request time.
Figure 1 illustrates the SOCR system architecture. Data relevant to news feeds are maintained both in a persistent data store for availability and in an in-memory cache for e cient news feed generation.

The persistent data store maintains a friendship store and an event store . In the friendship store, each user u i has a set of friends of the form h u i , tf ij ,u j i , where tf when u j becomes a friend of u i . A friendship entry is added or removed from the friendship store if u i adds or removes a friend. In the event store, each user u i has a set of events with elements of the form h u i , te il , event l ( u i ) i , where te the timestamp when u i generates event l ( u i ). An event entry is added to the event store when u i generates an event. The news feed of user u i at time tr i is obtained by joining the event and friendship entries of u i in both stores.
To avoid querying the persistent data stores at each re-quest to update a news feed, we process requests against an in-memory cache. Data in the cache is maintained on a per-user basis in a friendship cache and an event cache . The friendship cache maintains, for each user u i , a list of her friends of the form h u i , tcf i , flist ( u i , tcf i ) i . flist ( u list of u i  X  X  friends at time tcf i , which consists of all users u the timestamp when u i  X  X  friendship entry is updated in the friendship cache. The event cache maintains, for each user u , the most recent events h u i , tce i , te il , event l ( u tce i is the timestamp when u i  X  X  event entry is updated in the event cache and te il  X  tce i . Generating the news feed from the caches simply requires finding the event entries with the k maximum te jl for u i  X  X  friends in flist ( u i fact, event l ( u i ) of the entry h u i , tce i , te il , event event cache can be replaced by a list of events from u i in the case that multiple events from a friend are used to form the news feed. We consider a single event and use event l throughout this paper to simplify the presentation.
As social networks evolve and users generate events, it is important to refresh both the friendship cache and the event cache to reflect the most recent events in news feeds. We improve the freshness of news feeds through a novel scheme that we call SOCR (Social Online Cache Refreshing), imple-mented in the cache refreshing module in Figure 1.
Specifically, once user u i issues a news feed request to the system, the cache refreshing module first checks if u friend list exists in the friendship cache. If it does not exist, a refreshing request will be sent to the friendship store to fetch u the friendship cache as flist ( u i , tcf i ). Based on flist ( u the cache refreshing module can assess if the events available in the cache represent u i  X  X  most recent news feed. If it is not the case, the cache refreshing module sends a refreshing request to the persistent data store. The news feed can then be computed based on the refreshed entries in the cache and be returned to user u i .

The performance of the news feed application highly de-pends on the refreshing decision, i.e., refreshing friendship cache, event cache, or both. One main goal of this work is to derive an accurate cache refreshing strategy that only refreshes the cache entries leading to fresher news feed while the cache entries that have no impact on news feed are di-rectly served from the cache.
We present in this section two cache refreshing strategies for e cient generation and fresh content of social news feeds. They di  X  er from each other on whether they rely on user behavior in social networking systems to assess whether to refresh the caches.
A simple strategy to refresh a cache is to bound the time an entry can be served from the cache by associating a time-to-live (TTL) value to it. Since the system maintains a friendship cache and an event cache, each cache has its own TTL and maintains timestamps per cache entry for TTL verification. We use  X  f and  X  e to denote the TTL for the friendship cache and the event cache respectively.
When user u i issues a news feed request at time tr i , the cache refreshing module first gets the friends of u i , i.e. , flist ( u i , tcf i ), from the friendship cache. If it does not ex-ist, the friendship cache is refreshed for u i . Otherwise, the cache refreshing module compares the age of the entry h u to be refreshed. If tr i tcf i &gt;  X  f , the entry is considered expired and is refreshed. Once it has a fresh list of u i friends, the cache refreshing module checks, for each friend u in this list, if its corresponding event is in the event cache and if it is fresh. If an entry h u j , tce j , te jl , event not exist in the event cache, it is refreshed. Otherwise, its age is compared to its TTL value  X  e . If tr i tce j &gt;  X  entry of user u j is considered expired and is refreshed.
There is a hit on the friendship cache if the friend list of user u i in the friendship cache is fresh, and there is a hit on the event cache if the events of all u i  X  X  friends in the event cache are fresh. The TTL-based cache refreshing strategy is easy to implement. However, the decision to refresh the cache is independent of user behavior. This may incur un-necessary refreshing or serve stale news feeds to users.
In order to accurately assess whether to refresh the caches with respect to user behavior, we propose a utility-based strategy. We first present in Section 3.2.1 how we model user behavior and then present in Section 3.2.2 how we assess whether to refresh the caches based on this model.
In this work, we rely on the social news feed application provided by the Yahoo! News Social Activity to model the user behavior and design the utility-based cache refreshing strategy accordingly. Figure 2 gives an example of news feed we consider in this work. By clicking on the tab  X  X our Friends X , user can view the k news articles that have been recently read by her social network friends.

Two types of user behavior are involved in the generation of a news feed: (i) the behavior of generating events ( e.g. , reading articles in Yahoo! News) and (ii) the behavior of updating social friends ( e.g. , adding or removing friends in Facebook). We model both types of behavior by analyzing a sample of logs of the Yahoo! News Social Activity (Sec-tion 4.1).

Figure 3(a) depicts the total number of events that users generate each minute. We observe that users present di  X  er-ent behavior during a day and their behavior shows a daily pattern. Hence, we model user u i  X  X  rate of generating events eRate ( u i ), on a daily basis, and compute a rate for each pe-riod t j of a day as eRate ( u i ,t j ). Given u i  X  X  behavior in a number of days, starting at time T 0 , eRate ( u i ,t j )iscom-puted as the average number of events per unit of time that are generated by u i during the period t j of these days.
We observe from Figure 3(b) that the number of new friends and removed friends each minute remains relatively stable. Therefore, we model each user X  X  rate of adding friends fRate a ( u i ) as the average number of new friends per unit of time during the entire observed period. Similarly, we model each user X  X  rate of removing friends fRate r ( u i ) as the aver-age number of removed friends per unit of time during the entire observed period.

In the next section, we explain how to assess whether to refresh the caches based on the above user behavior models. To this end, the cache refreshing module maintains, for each user u i , a vector for her rate of generating events eRate ( u a value for her rate of adding friends fRate a ( u i ), and a value for her rate of removing friends fRate r ( u i ).
We propose a utility-based strategy that leverages user behavior to refresh the caches. Ideally, a cache entry should only be refreshed if aggregating the entries in the friendship and event caches does not provide the same news feed as if some of the entries are refreshed. In fact, cache refreshing is necessary if at least one of the following cases hold:
In order to assess, at the time of each news feed request, if cache refreshing is necessary, we compute a utility of re-freshing for each request. The utility estimates how many events that do not exist in the last news feed could be ob-tained from the persistent data store for the current news feed ( i.e. , Case 1 and Case 2), and how many events that exist in the last news feed would be evicted from the current news feed ( i.e. ,Case3).

Given user u i  X  X  news feed request at time tr i , the utility of refreshing the caches for u i at time tr i is defined as UtilityFC ( u i , tr i ) is the utility of refreshing the friendship cache for u i , which estimates the number of events that would be included to u i  X  X  news feed by Case 1 and that would be evicted from u i  X  X  news feed by Case 3. UtilityEC ( u is the utility of refreshing the event cache for u i  X  X  friend u which estimates the number of events that can be included to u i  X  X  news feed by Case 2.

To compute UtilityFC ( u i , tr i ) , the cache refreshing mod-ule knows user u i  X  X  rate of adding friends fRate a ( u i refreshing the friendship cache, u i is expected to obtain fRate a ( u i )  X  ( tr i tcf i ) new friends from the friendship store. We assume these new friends have the same rate of gener-ating events ( i.e. , average of all the rates available to the cache refreshing module avgERate ). Hence, since u i  X  X  last news feed request, each new friend is expected to generate avgERate  X  ( tr i tcf i ) events. By refreshing the friendship be included to u i  X  X  news feed.

User u i is expected to remove fRate r ( u i )  X  ( tr i tcf from the friendship store since her last news feed request. Figure 4: Example of computing UtilityEC ( u j ,tr i ) . last news feed are from k di  X  erent friends ( i.e. the diversity constraint in Section 2.1), the expectation of the number of events each friend of u i contributes to her last news feed u allows detecting the eviction of fRate r ( u i )  X  ( tr i
Finally, the utility of refreshing the friendship cache can be computed as
To compute UtilityEC ( u j , tr i ) , the cache refreshing module knows user u j  X  X  rate of generating events eRate ( u i ) . Figure 4 illustrates the division of the period between the last update of u i in the event cache (at tce i ) and the current news feed request (at tr i ) with respect to the rate of generating events. Suppose the black star corresponds to the last update of u in the event cache, and the red star is a news feed request issued to the system later. Let T 0 be the same starting time and { t 1 ,t 2 ,t 3 ,t 4 } be the time intervals in a day of length d for computing eRate ( u j ) (Section 3.2.1), the period be-tween the black star and the red star, i.e. , p 0 = { t 0 is mapped to the time intervals p = { t 2 ,t 3 ,t 4 } , where t t may only cover part of t 2 and t 4 .

According to the mapping of time intervals, if tce i and tr do not fall into the same time interval, UtilityEC ( u j , tr be computed by summarizing the number of events that are expected to be generated by u j in each time interval, i.e. , t and t e are the first and the last time interval in p . s =
If tce j and tr i fall into the same time interval t l of the same day, i.e. , ( tce j T 0 ) modd =( tr i T 0 ) modd and tr i UtilityEC ( u j , tr i ) can be computed as
Higher utility indicates more benefits of refreshing the caches. If the utility is larger than a pre-defined thresh-old, denoted as  X  , cache refreshing is performed. Otherwise, a news feed will be generated from the caches. Algorithm 1 presents the utility-based cache refreshing strategy. In the case that Utility ( u i , tr i ) is larger than  X  ,if UtilityFC ( u 0, only the event cache will be refreshed for the friends with positive UtilityEC ( u j , tr i ) (line 15-18). If none of u has positive UtilityEC ( u j , tr i ) , only the friendship cache will be refreshed (line 12-14). Otherwise, both the friendship and event caches will be refreshed. Algorithm 1 Utility-based cache refreshing
Datasets. In the experiments, we use a sample of logs from Yahoo! New Social Activity in February 2012 to sim-ulate a workload of users generating events and updating friends. The first half of the logs is used to compute eRate ( u fRate a ( u i ) and fRate r ( u i ). The second half of the logs is used to simulate the arrival of events, the addition and removal of friends that may impact the freshness of news feeds.
The news feed requests are obtained from the same sample logs. We focus on users who issued at least 10 news feed requests in the second half of the logs, as news feed requests are user dependent and we especially expect to accurately refresh the caches for regular users. There are 194,791 such users and they issued 3,805,084 news feed requests.
Each of the 194,791 users has on average 292 friends, while only 10 of these friends generate at least one event in the first half of the logs. We refer to the friends who generate at least one event as active friends and focus on them in the ex-periments. The 2,044,436 active friends generate 11,983,744 events in the first half of the logs.

Setup and methodology. We conduct the experiments using a simulator written in Java. We examine the TTL-based and utility-based cache refreshing strategies over a dynamic cache of  X  X nlimited X  size.

Both TTL-based and utility-based strategies are pull-based since the caches are lazily refreshed at the time of news feed requests. We compare them against a hybrid push-pull strat-egy [9] that relies on push to refresh the caches for selected users and pull to refresh the caches for other users, depend-ing on the threshed that measures the ratio between the consumption and production rates of each user.

We replay the news feed requests with their original tim-ing in the logs. For each request, the system computes the news feed of 10 recent events with either the entries in the caches or the data in the logs ( i.e. , the persistent data store) according to the cache refreshing decisions. Whether a cache refreshing decision is accurate or not is determined by com-paring this news feed to its ground truth that is computed solely relying on the data in the logs.

Parameter setting. The per user rate of generating events is modeled on a daily basis (Section 3.2.1). We set the length of the time interval t to 10 minutes in the exper-iments. We determined this length by analyzing the time di  X  erence between consecutive requests and events of users.
In SOCR, the cache refreshing module assesses whether to refresh the caches each time a news feed request is issued. We use false negative to denote a decision of not refresh-ing while the persistent data stores contain fresher data. A false negative results in a stale news feed and a  X  ects the quality of the news feed the user perceives. We use false positive to denote a decision of refreshing while the news feed computed with cached data is fresh. A false positive has no impact on the quality of the news feed but it results in unnecessary refreshing of cache entries and increases the latency of computing a news feed. We assess the accuracy of cache refreshing by measuring the stale ratio ( i.e. , false neg-ative ratio) and false positive ratio . Low stale ratio and false positive ratio indicate high accuracy of cache refreshing.
Figure 5 compares the quality of the TTL-based, utility-based and push-pull cache refreshing strategies through the relationship between stale ratio and false positive ratio. The ratios are obtained at the end of each experiment, i.e. , after all the 3,805,084 news feed requests have been processed.
For the TTL-based strategy, we only show the case in which the TTLs are the same for the friendship cache and event cache, i.e. ,  X  f =  X  e , for the sake of figure readability. The points from the left to the right in Figure 5 correspond to increasing values of TTL, i.e. ,  X  f and  X  e are set to 1 second, 5 minutes, 10 minutes, 20 minutes, 30 minutes, 1 hour, 2 hours, 4 hours, 6 hours, 12 hours, 1 day, 2 days and 3 days respectively. Increasing the value of TTL in-creases the stale ratio and reduces the false positive ratio as fewer refreshes are made due to the long-lived entries in both caches. The best accuracy of cache refreshing is ob-tained when  X  f =  X  e = 6 hours. Here we refer to the case with the minimum total number of false negatives and false positives as the best case. In the best case, the stale ratio is 0.128 and the false positive ratio is 0.119.

For the push-pull strategy, the news feeds can not be stale since all the new friends and events are either pushed or pulled according to the value of the push threshold . That is why we observe a vertical line in Figure 5. The points from the bottom to the top correspond to increasing values of , i.e. , is set to 0, 1, 2, 3, 4, 5, 10, 15, 20 and 1 respec-tively. = 0 is the extreme where all the friend and events are pushed to the caches, and = 1 is the other extreme where all the friends and events are pulled at request time. We observe that increasing the value of increases the false positive ratio, since more users X  friends and events have to be pulled at request time. Although = 0 and = 1 ensure negligible false positive ratios, we will see in Figure 6(a), (a)False positive vs. transmission. they incur very high data transmission between the persis-tent data stores and the caches. In the case of = 3, which ensures the best trade-o  X  between false positive ratio and data transmission, the false positive ratio is 0.095.
For the utility-based strategy, we vary the value of the threshold of utility  X  to show its accuracy of cache refresh-ing. The points from the left to the right correspond to increasing values of  X  , i.e. ,  X  is set to 0.005, 0.01, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 7.5 and 10 respectively. We observe that increasing the value of  X  increases the stale ratio and reduces the false positive ratio. This is because increas-ing the threshold makes it more demanding to refresh the caches. Importantly, we observe that the overall accuracy of the utility-based strategy is better than that of the TTL-based strategy. For the same stale ratio, the false positive ratio of the utility-based strategy is lower than that of the TTL-based strategy. Similarly, for the same false positive ratio, the stale ratio of the utility-based strategy is lower than that of the TTL-based strategy. For the utility-based strategy, the best accuracy is obtained when  X  = 1, where the stale ratio is 0.073 and the false positive ratio is 0.058. This configuration outperforms the best case of the TTL-based strategy by reducing the stale ratio and false positive ratio by 43% and 51% respectively. It also reduces the false positive ratio of the push-pull strategy with =3by39%.
We measure the amount of data (in bytes) transmitted between the persistent data stores and the caches as the load that di  X  erent cache refreshing strategies put in the system.
We use 64-bit integer as user identifier (same as a Face-book ID), 64-bit long as timestamp, and 128-bit MD5 as event identifier. Figure 6(a) shows, for the three cache re-freshing strategies, the trade-o  X  between the false positive ratio and the amount of data transmitted to the caches for processing all the news feed requests in the experiments. The amount of transmission is normalized by that of the ex-treme case where all the friends and events relevant to new feed requests are pulled from the persistent data stores.
We observe that for both TTL-based and utility-based strategies, the transmission increases with the false posi-tive ratio. This observation justifies our goal of minimizing false positives when deciding whether to refresh the caches. For the push-pull strategy, the leftmost point corresponds to = 0 (push for all users) and the rightmost point corre-sponds to = 1 (pull for all users). We observe that the minimum transmission occurs when = 3. When =0, several updates of friends or new events are transmitted to the caches before they are requested, but only the last friend list or the last event before a request serves to form a news feed. When is larger than 3, more user friends or events are pulled at the request time while those in the caches may not change, causing redundant transmission. Figure 6(b) shows the actual transmission for the best-cases of the three strategies. We observe that the transmission is dominated by that of friends. The utility-based strategies incurs 8% less transmission than the TTL-based strategy and 27% less transmission than the push-pull strategy.
Preceding persistent data store with in-memory cache is an e cient way to generate news feeds in on-line social net-working systems [5, 6, 9]. However, enlarging the cache increases the risks of serving stale news feeds to users.
We proposed in this paper the on-line cache refreshing scheme SOCR to e ciently serve fresh news feeds. Di  X  er-ent from the push-based approaches [4, 10] that put all the new data to the caches in real-time and the push-pull ap-proach [9] that refreshes some data on-line and fetches other data in real-time, SOCR only refreshes the caches lazily upon news feed requests. As reported in Section 4.3, SOCR significantly reduces the data transmission of the push-pull approach.

The utility-based strategy of SOCR is inspired from the approaches used in Web search engines that take into ac-count the user behavior related to refresh the caches [1, 2, 3]. Yet, it is di  X  erent from these approaches as the cache refreshing module in SOCR does not communicate with the persistent store to keep track of the fresh data but only uses pre-computed statistics to estimate the potential changes of news feeds. This is key to its scalability as no additional communication overhead is imposed to the system.
 This work was supported by the LEADS project (ICT-318809), funded by the European Community, and the Torres Quevedo Program from the Spanish Ministry of Science and Innova-tion, co-funded by the European Social Fund.
