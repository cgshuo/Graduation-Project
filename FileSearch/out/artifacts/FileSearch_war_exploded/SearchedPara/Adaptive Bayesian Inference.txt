 Toyota Tech. Inst.
 umut@tti-c.org Graphical models [14, 8] are a powerful tool for probabilistic reasoning over sets of random vari-ables. Problems of inference, including marginalization and MAP estimation, form the basis of statistical approaches to machine learning. In many applications, we need to perform inference un-der dynamically changing conditions, such as the acquisition of new evidence or an alteration of the conditional relationships which make up the model. Such changes arise naturally in the experi-mental setting, where the model quantities are empirically estimated and may change as more data are collected, or in which the goal is to assess the effects of a large number of possible interven-tions. Motivated by such applications, Delcher et al. [6] identify dynamic Bayesian inference as the problem of performing Bayesian inference on a dynamically changing graphical model. Dynamic changes to the graphical model may include changes to the observed evidence, to the structure of the graph itself (such as edge or node insertions/deletions), and changes to the conditional relationships among variables.
 To see why adapting to dynamic changes is difficult, consider the simple problem of Bayesian infer-ence in a Markov chain with n variables. Suppose that all marginal distributions have been computed in O ( n ) time using the sum-product algorithm, and that some conditional distribution at a node u is subsequently updated. One way to update the marginals would be to recompute the messages computed by sum-product from u to other nodes in the network. This can take  X ( n ) time because regardless of where u is in the network, there always is another node v at distance  X ( n ) from u . A similar argument holds for general tree-structured networks. Thus, simply updating sum-product messages can be costly in applications where marginals must be adaptively updated after changes to the model (see Sec. 5 for further discussion).
 In this paper, we present a technique for efficient adaptive inference on graphical models. For a tree-structured graphical model with n nodes, our approach supports the computation of any marginal, updates to conditional probability distributions (including observed evidence) and edge insertions and deletions in expected O (log n ) time. As an example of where adaptive inference can be effec-tive, consider a computational biology application that requires computing the state of the active site in a protein as the user modifies the protein (e.g., mutagenesis). In this application, we can represent the protein with a graphical model and use marginal computations to determine the state of the ac-tive site. We reflect the modifications to the protein by updating the graphical model representation and performing marginal queries to obtain the state of the active site. We show in Sec. 5 that our approach can achieve a speedup of one to two orders of magnitude over the sum-product algorithm in such applications.
 Our approach achieves logarithmic update and query times by mapping an arbitrary tree-structued graphical model into a balanced representation that we call a cluster tree (Sec. 3 X 4). We perform an O ( n ) -time preprocessing step to compute the cluster tree using a technique known as tree con-traction [13]. We ensure that for an input network with n nodes, the cluster tree has an expected depth of O (log n ) and expected size O ( n ) . We show that the nodes in the cluster tree can be tagged with partial computations (corresponding to marginalizations of subtrees of the input network) in way that allows marginal computations and changes to the network to be performed in O (log n ) ex-pected time. We give simulation results (Sec. 5) that show that our algorithm can achieve a speedup of one to two orders of magnitude over the sum-product algorithm. Although we focus primarily on the problem of answering marginal queries, it is straightforward to generalize our algorithms to other, similar inference goals, such as MAP estimation and evaluating the likelihood of evidence. We note that although tree-structured graphs provide a relatively restrictive class of models, junction trees [14] can be used to extend some of our results to more general graphs. In particular, we can still support changes to the parameters of the distribution (evidence and conditional relationships), although changes to the underlying graph structure become more difficult. Additionally, a number of more sophisticated graphical models require efficient inference over trees at their core, includ-ing learning mixtures of trees [12] and tree-reparameterized max-product [15]. Both these methods involve repeatedly performing a message passing algorithm over a set of trees with changing param-eters or evidence, making efficient updates and recomputations a significant issue.
 Related Work. It is important to contrast our notion of adapting to dynamic updates to the graph-ical model (due to changes in the evidence, or alterations of the structure and distribution) with the potentially more general definition of dynamic Bayes X  nets (DBNs) [14]. Specifically, a DBN typically refers to a Bayes X  net in which the variables have an explicit notion of time, and past observations have some influence on estimates about the present and future. Marginalizing over un-observed variables at time t  X  1 typically produces increased complexity in the the model of variables at time t . However, in both [6] and this work, the emphasis is on performing inference with current information only, and efficiency is obtained by leveraging the similarity between the previous and newly updated models.
 Our work builds on previous work by Delcher, Grove, Kasif and Pearl [6]; they give an algorithm to update Bayesian networks dynamically as the observed variables in the network change and com-pute belief queries of hidden variables in logarithmic time. The key difference between their work and ours is that their algorithm only supports updates to observed evidence, and does not support dy-namic changes to the graph structure (i.e., insertion/deletion of edges) or to conditional probabilities. In many applications it is important to consider the effect of changes to conditional relationships be-tween variables; for example, to study protein structure (see Sec. 5 for further discussion). In fact, Delcher et al. cite structural updates to the given network as an open problem. Another difference includes the use of tree contraction: they use tree contractions to answer queries and perform up-dates. We use tree contractions to construct a cluster tree, which we then use to perform queries and all other updates (except for insertions/deletions). We provide an implementation and show that this approach yields significant speedups.
 Our approach to clustering factor graphs using tree contractions is based on previous results that show that tree contractions can be updated in expected logarithmic time under certain dynamic changes by using a general-purpose change-propagation algorithm [2]. The approach has also been applied to a number of basic problems on trees [3] but has not been considered in the context of statistical inference. The change-propagation approach used in this work has also been extended to provide a general-purpose technique for updating computations under changes to their data and applied to a number of applications (e.g. [1]). Graphical models provide a convenient formalism for describing the structure of a function g de-fined over a set of variables x 1 , . . . , x n (most commonly a joint probability distribution over the x ). Graphical models use this structure to organize computations and create efficient algorithms for many inference tasks over g , such as finding a maximum a-posteriori (MAP) configuration, marginalization, or computing data likelihood. For the purposes of this paper, we assume that each variable x i takes on values from some finite set, denoted A i . We write the operation of marginalizing over x i as P x Factor Graphs. A factor graph [10] is one type of graphical model, similar to a Bayes X  net [14] In particular, suppose that g decomposes into a product of simpler functions, g ( X ) = Q j f j ( X j ) , for some collection of real-valued functions f j , called factors , whose arguments are (index-ordered) sets X j  X  X . A factor graph consists of a graph-theoretic abstraction of g  X  X  factorization, with vertices of the graph representing variables x i and factors f j . Because of the close correspondence between these quantities, we abuse notation slightly and use x i to indicate both the variable and its associated vertex, and f j to indicate both the factor and its vertex.
 Definition 2.1. A factor graph is a bipartite graph G = ( X + F, E ) where X = { x 1 , x 2 , . . . , x n } factor graph G where G is a tree. The neighbor set N ( v ) of a vertex v is the (index-ordered) set of vertices adjacent to vertex v . The graph G represents the function g ( X ) = Q j f j ( X j ) if, for each factor f j , the arguments of f j are its neighbors in G , i.e., N ( f j ) = X j .
 Other types of graphical models, such as Bayes X  nets [14], can be easily converted into a factor graph representation. When the Bayes X  net is a polytree (singly connected directed acyclic graph), the resulting factor graph is a factor tree.
 The Sum-Product Algorithm. The factorization of g ( X ) and its structure as represented by the graph G can be used to organize various computations about g ( X ) efficiently. For example, the marginals of g ( X ) , defined for each i by g i ( x i ) = P X \{ x sum X  X roduct algorithm.
 Sum-product is best described in terms of messages sent between each pair of adjacent vertices in the factor graph. For every pair of neighboring vertices ( x i , f j )  X  E , the vertex x i sends a message  X  i  X  f j as soon as it receives the messages from all of its neighbors except for f j , and similarly for the message from f j to x i . The messages between these vertices take the form of a real-valued The message  X  x i  X  f j sent from a variable vertex x i to a neighboring factor vertex f j , and the mes-sage  X  f j  X  x i from factor f j to variable x i are given by Once all the messages ( 2 | E | in total) are sent, we can calculate the marginal g i ( x i ) by simply multiplying all the incoming messages, i.e., g i ( x i ) = Q f  X  X  ( x thought of as selecting an efficient elimination ordering of variables (leaf to root) and marginalizing in that order.
 Other Inferences. Although in this paper we focus on marginal computations using sum X  X roduct, similar message passing operations can be generalized to other tasks. For example, the operations of sum X  X roduct can be used to compute the data likelihood of any observed evidence; such com-putations are an inherent part of learning and model comparisons (e.g., [12]). More generally, sim-ilar algorithms can be defined to compute functions over any semi X  X ing possessing the distributive property [11]. Most commonly, the max operation produces a dynamic programming algorithm ( X  X ax X  X roduct X ) to compute joint MAP configurations [15]. In this section, we describe an algorithm for constructing a balanced representation of the input graphical model, that we call a cluster tree . Given the input graphical model, we first apply a clus-tering algorithm that hierarchically clusters the graphical model, and then apply a labeling algorithm that labels the clusters with cluster functions that can be used to compute marginal queries. Clustering Algorithm. Given a factor graph as input, we first tag each node v with a unary cluster cluster the tree hierarchically by applying the rake , compress , and finalize operations. When applied to a leaf node v with neighbor u , the rake operation deletes the v and the edge ( u, v ) , and forms unary cluster by combining the clusters which tag either v or ( u, v ) ; u is tagged with the resulting cluster. When applied to a degree-two node v with neighbors u and w , a compress operation deletes v and the edges ( u, v ) and ( v, w ) , inserts the edge ( u, w ) , and forms a binary cluster by combining the clusters which tag the deleted node and edges; ( u, w ) is then tagged with the resulting cluster. A finalize operation is applied when the tree consists of a single node (when no edges remain); it constructs a final cluster that consists of all the clusters with which the final node is tagged. We cluster a tree T by applying rake and compress operations in rounds. Each round consists of the following two steps until no more edges remain: (1) Apply the rake operation to each leaf; (2) Apply the compress operation to an independent set of degree-two nodes. We choose a ran-dom independent set: we flip a coin for each node in each round and apply com-press to a degree-two node only if it flips heads and its two neighbors flips tails. This ensures that no two adjacent nodes apply compress simultaneously. When all edges are deleted, we complete the clustering by applying the finalize operation.
 Fig. 1 shows a four-round clustering of a factor graph and Fig. 2 shows the corre-sponding cluster tree . In round 1, nodes f 1 , f 2 , f 5 are raked and f 4 is compressed. In round 2, x , x 2 , x 4 are raked. In round 3, f 3 is raked. A finalize operation is applied in round 4 to produce the final cluster. The leaves of the cluster tree correspond to the nodes and the edges of the factor graph. Each internal node  X  v corresponds a unary or a binary cluster formed by deleting v . The children of an internal node are the edges and the nodes deleted during the operation that forms the cluster. For example, the cluster  X  f 1 is formed by the rake operation applied to f 1 in round 1. The children of  X  f 1 are node f 1 and edge ( f 1 , x 1 ) , which are deleted during that operation. Labeling Algorithm. After building the cluster tree, we compute cluster functions along with a notion of orientation for neighboring clusters in a second pass, which we call labeling . 1 The cluster function at a node  X  v in the tree is computed recursively using the cluster functions at  X  v  X  X  child partial marginalization of the factors contained in cluster  X  v .
 Since each cluster function is defined over a subset of the variables in the original graph, we re-quire some additional notation to represent these sets. Specifically, for a cluster  X  v , let A (  X  v ) be the arguments of its cluster function, and let V (  X  v ) be the set of all arguments of its children, case, the leaf nodes of the cluster tree correspond to nodes v in the original graph, and we define c v v is a variable node x i , A ( v ) = x i and c v = 1 . For nodes of the cluster tree corresponding to edges ( u, v ) of the original graph, we simply take A ( u, v ) =  X  and c u,v = 1 .
 The cluster function at an internal node of the cluster tree is then given by combining the cluster functions of its children and marginalizing over as many variables as possible. Let  X  v be the internal at v  X  X  removal it had two neighbors u and w , then c  X  v is given by neighbor u at its removal, c  X  v (  X  ) is calculated in the same way with A ( w ) =  X  . We also compute an orientation for each cluster X  X  neighbors based on their proximity to the cluster tree X  X  root. This is also calculated recursively using the orientations of each node X  X  ancestors. For and out(  X  v ) =  X  w .
 We now describe the efficiency of our clustering and labeling algorithms and show that the resulting cluster tree is linear in the size of the input factor graph.
 Theorem 1 ( Hierarchical Clustering). A factor tree of n nodes with maximum degree of k can be clustered and labeled in expected O ( d k +2 n ) time where d is the domain size of each variable in the factor tree. The resulting cluster tree has exactly 2 n  X  1 leaves and n internal clusters (nodes) and expected O (log n ) depth where the expectation is taken over internal randomization (over the coin flips). Furthermore, the cluster tree has the following properties: (1) each cluster has at most k + 1 is the parent of  X  v .
 Proof. Consider first the construction of the cluster tree. The time and the depth bound follow from previous work [2]. The bound on the number of nodes holds because the leaves of the cluster tree correspond to the n  X  1 edges and n nodes of the factor graph. To see that each cluster has at most k + 1 children, note that the a rake or compress operation deletes one node and the at most k edges incident on that node. Every edge appearing in any level of the tree contraction algorithm is represented as a binary cluster  X  v = ( u, w ) in the cluster tree. Whenever an edge is removed, one of also an ancestor of  X  v follows from an induction argument on the levels.
 Consider the labeling step. By inspection of the labeling algorithm, the computation of the ar-guments A (  X  ) and V (  X  ) requires O ( k ) time. To bound the time for computing a cluster function, if  X  v is a binary cluster. Therefore, |V (  X  v ) | X  k + 2 . The number of operations required to compute time. Although the running time may appear large, note that the representation of the factor graph takes O ( d k n ) space if functions associated with factors are given explicitly. We give algorithms for computing marginal queries on the cluster trees and restructuring the cluster tree with respect to changes in the underlying graphical model. For all of these operations, our algorithms require expected logarithmic time in the size of the graphical model.
 Queries. We answer marginal queries at a vertex v of the graphical node by using the cluster tree. At a high level, the idea is to find the leaf of the cluster tree corresponding to v and compute the messages along the path from the root of the cluster tree to v . Using the orientations computed during the tagging pass, for each cluster  X  v we define the following messages: the message in this case to be 1 .
 Theorem 2 ( Query). Given a factor tree with n nodes, maximum degree k , domain size d , and its cluster tree, the marginal at any x i can be computed with the following formula where S  X  x i is the set of children of  X  x i , in O ( kd k +2 log n ) time.
 Messages are computed only at the ancestors of the query node x i and downward along the path to x ; there are at most O (log n ) nodes in this path by Theorem 1. Computing each message requires at most O ( kd k +2 ) time, and any marginal query takes O ( kd k +2 log n ) time.
 Dynamic Updates. Given a factor graph and its cluster tree, we can change the function of a factor and update the cluster tree by starting at the leaf of the cluster tree that corresponds to the factor and relabeling all the clusters on the path to the root. Updating these labels suffices, because the label of a cluster is a function of its children only. Since relabeling a cluster takes O ( kd k +2 ) time and the cluster tree has expected O (log n ) depth, any update requires O ( kd k +2 log n ) time. To allow changes to the factor graph itself by insertion/deletion of edges, we maintain a forest of factor trees and the corresponding cluster trees (obtained by clustering the trees one by one). We also maintain the sequence of operations used to construct each cluster tree, i.e., a data structure which represents the state of the clustering at each round. Note that this structure is also size O ( n ) , since at each round a constant fraction of nodes are removed (raked or compressed) in expectation. Suppose now that the user inserts an edge that connects two trees, or deletes an edge connecting two subtrees. It turns out that both operations have only a limited effect on the sequence of clustering operations performed during construction, affecting only a constant number of nodes at each round of the process. Using a general-purpose change propagation technique (detailed in previous work [2, 1]) the necessary alterations can be made to the cluster tree in expected O (log n ) time. Change propagation gives us a new cluster tree that corresponds to the cluster tree that we would have obtained by re-clustering from scratch, conditioned on the same internal randomization process. In addition to changing the structure of the cluster tree via change propagation, we must also change the labeling information (cluster functions and orientation) of the affected nodes, which can be done using the same process described in Sec. 3. It is a property of the tree contraction process that all such affected clusters form a subtree of the cluster tree that includes the root. Since change propagation affects an expected O (log n ) clusters, and since each cluster can be labeled in O ( kd k +2 ) time, the new labels can be computed in O ( kd k +2 log n ) time.
 For dynamic updates, we thus have the following theorem. Theorem 3 ( Dynamic Updates). For a factor forest F of n vertices with maximum degree k , and domain size d , the forest of cluster trees can be updated in expected O ( kd k +2 log n ) time under edge insertions/deletions, and changes to factors. We have implemented our algorithm in Matlab 2 and compared its performance against the standard two-pass sum-product algorithm (used to recompute marginals after dynamic changes). Fig. 3 shows the results of a simulation experiment in which we considered randomly generated factor trees be-tween 100 and 1000 nodes, with each variable having 5 1 , 5 2 , or 5 3 states, so that each factor has size between 5 2 and 5 6 . These factor tree correspond roughly to the junction trees of models with between 200 and 6000 nodes, where each node has up to 5 states. Our results show that the time required to build the cluster tree is comparable to one run of sum-product. Furthermore, the query and update operations in the cluster tree incur relatively small constant factors in their asymptotic running time, and are between one to two orders of magnitude faster than recomputing from scratch. A particularly compelling application area, and one of the original motivations for developing our al-gorithm, is in the analysis of protein structure. Graphical models constructed from protein structures have recently been used to successfully predict structural properties [17] as well as free energy [9]. These models are typically constructed by taking each node as an amino acid whose states represent their most common conformations, known as rotamers [7], and basing conditional probabilities on proximity, and a physical energy function (e.g., [16]) and/or empirical data [4].
 Our algorithm is a natural choice for problems where various aspects of protein structure are allowed to change. One such application is computational mutagenesis , in which functional amino acids in a protein structure are identified by examining systematic amino acid mutations in the protein struc-ture (i.e., to characterize when a protein  X  X oses X  function). In this setting, performing updates to the model (i.e., mutations) and queries (i.e., the free energy or maximum likelihood set of rotameric states) to determine the effect of updates would be likely be far more efficient than standard methods. Thus, our algorithm has the potential to substantially speed up computational studies that examine each of a large number local changes to protein structure, such as in the study of protein flexibility and dynamics. Interestingly, [6] actually give a sample application in computational biology, al-though their model is a simple sequence-based HMM in which they consider the effect of changing observed sequence on secondary structure only.
 The simulation results given in Fig. 3 validate the use of our algorithm for these applications, since protein-structure based graphical models have similar complexity to the inputs we consider: proteins range in size from hundreds to thousands of amino acids, and each amino acid typically has relatively few rotameric states and local interactions. As in prior work [17], our simulation considers a small number of rotamers per amino acid, but the one to two order-of-magnitude speedups obtained by our algorithm indicate that it maybe be possible also to handle higher-resolution models (e.g., with more rotamer states, or degrees of freedom in the protein backbone). We give an algorithm for adaptive inference in dynamically changing tree-structured Bayesian net-works. Given n nodes in the network, our algorithm can support updates to the observed evidence, conditional probability distributions, as well as updates to the network structure (as long as they keep the network tree-structured) with O ( n ) preprocessing time and O (log n ) time for queries on any marginal distribution. Our algorithm can easily be modified to maintain MAP estimates as well as compute data likelihoods dynamically, with the same time bounds. We implement the algorithm and show that it can speed up Bayesian inference by orders of magnitude after small updates to the network. Applying our algorithm on the junction tree representation of a graph yields an in-ference algorithm that can handle updates on conditional distributions and observed evidence in general Bayesian networks (e.g., with cycles); an interesting open question is whether updates to the network structure (i.e., edge insertions/deletions) can also be supported. Figure 3: Log-log plot of run time for naive sum-product, building the cluster tree, computing queries, updating factors, and restructuring (adding and deleting edges). Although building the clus-ter tree is slightly more expensive than sum-product, each subsequent update and query is between 10 and 100 times more efficient than recomputing from scratch.
 References
