 Pascal Vincent vincentp@iro.umontreal.ca Hugo Larochelle larocheh@iro.umontreal.ca Yoshua Bengio bengioy@iro.umontreal.ca Pierre-Antoine Manzagol manzagop@iro.umontreal.ca Recent theoretical studies indicate that deep architec-tures (Bengio &amp; Le Cun, 2007; Bengio, 2007) may be needed to efficiently model complex distributions and achieve better generalization performance on challeng-ing recognition tasks. The belief that additional levels of functional composition will yield increased repre-sentational and modeling power is not new (McClel-land et al., 1986; Hinton, 1989; Utgoff &amp; Stracuzzi, 2002). However, in practice, learning in deep archi-tectures has proven to be difficult. One needs only to ponder the difficult problem of inference in deep directed graphical models, due to  X  X xplaining away X . Also looking back at the history of multi-layer neural networks, their difficult optimization (Bengio et al., 2007; Bengio, 2007) has long prevented reaping the ex-pected benefits of going beyond one or two hidden lay-ers. However this situation has recently changed with the successful approach of (Hinton et al., 2006; Hinton &amp; Salakhutdinov, 2006; Bengio et al., 2007; Ranzato et al., 2007; Lee et al., 2008) for training Deep Belief Networks and stacked autoencoders.
 One key ingredient to this success appears to be the use of an unsupervised training criterion to perform a layer-by-layer initialization: each layer is at first trained to produce a higher level (hidden) represen-tation of the observed patterns, based on the repre-sentation it receives as input from the layer below, by optimizing a local unsupervised criterion. Each level produces a representation of the input pattern that is more abstract than the previous level X  X , be-cause it is obtained by composing more operations. This initialization yields a starting point, from which a global fine-tuning of the model X  X  parameters is then performed using another training criterion appropriate for the task at hand. This technique has been shown empirically to avoid getting stuck in the kind of poor solutions one typically reaches with random initializa-tions. While unsupervised learning of a mapping that produces  X  X ood X  intermediate representations of the input pattern seems to be key, little is understood re-garding what constitutes  X  X ood X  representations for initializing deep architectures, or what explicit crite-ria may guide learning such representations. We know of only a few algorithms that seem to work well for this purpose: Restricted Boltzmann Machines (RBMs) trained with contrastive divergence on one hand, and various types of autoencoders on the other.
 The present research begins with the question of what explicit criteria a good intermediate representation should satisfy. Obviously, it should at a minimum re-tain a certain amount of  X  X nformation X  about its input, while at the same time being constrained to a given form (e.g. a real-valued vector of a given size in the case of an autoencoder). A supplemental criterion that has been proposed for such models is sparsity of the representation (Ranzato et al., 2008; Lee et al., 2008). Here we hypothesize and investigate an additional spe-cific criterion: robustness to partial destruction of the input , i.e., partially destroyed inputs should yield almost the same representation. It is motivated by the following informal reasoning: a good represen-tation is expected to capture stable structures in the form of dependencies and regularities characteristic of the (unknown) distribution of its observed input. For high dimensional redundant input (such as images) at least, such structures are likely to depend on evidence gathered from a combination of many input dimen-sions. They should thus be recoverable from partial observation only. A hallmark of this is our human ability to recognize partially occluded or corrupted im-ages. Further evidence is our ability to form a high level concept associated to multiple modalities (such as image and sound) and recall it even when some of the modalities are missing.
 To validate our hypothesis and assess its usefulness as one of the guiding principles in learning deep architec-tures, we propose a modification to the autoencoder framework to explicitly integrate robustness to par-tially destroyed inputs. Section 2 describes the algo-rithm in details. Section 3 discusses links with other approaches in the literature. Section 4 is devoted to a closer inspection of the model from different theo-retical standpoints. In section 5 we verify empirically if the algorithm leads to a difference in performance. Section 6 concludes the study. 2.1. Notation and Setup Let X and Y be two random variables with joint prob-ability density p ( X,Y ), with marginal distributions p ( X ) and p ( Y ). Throughout the text, we will use the following notation: Expectation: EE p ( X ) [ f ( X )] = R p ( x ) f ( x )d x . Entropy: IH ( X ) = IH ( p ) = EE p ( X ) [  X  log p ( X )]. Conditional entropy: IH ( X | Y ) = EE p ( X,Y ) [  X  log p ( X | Y )]. Kullback-Leibler divergence: ID EE mation: I ( X ; Y ) = IH ( X )  X  IH ( X | Y ). Sigmoid: s ( x ) = 1+ e  X  x and s ( x ) = ( s ( x 1 ) ,...,s ( x d )) tribution with mean  X  : B  X  ( x ). and by extension B ( x ) = ( B  X  1 ( x 1 ) ,..., B  X  The setup we consider is the typical supervised learn-ing setup with a training set of n (input, target) pairs D to be an i.i.d. sample from an unknown distribution q ( X,T ) with corresponding marginals q ( X ) and q ( T ). 2.2. The Basic Autoencoder We begin by recalling the traditional autoencoder model such as the one used in (Bengio et al., 2007) to build deep networks. An autoencoder takes an input vector x  X  [0 , 1] d , and first maps it to a hid-den representation y  X  [0 , 1] d 0 through a deterministic mapping y = f  X  ( x ) = s ( Wx + b ), parameterized by  X  = { W , b } . W is a d 0  X  d weight matrix and b is a bias vector. The resulting latent representation y is then mapped back to a  X  X econstructed X  vector z  X  [0 , 1] d in input space z = g  X  0 ( y ) = s ( W 0 y + b with  X  0 = { W 0 , b 0 } . The weight matrix W 0 of the reverse mapping may optionally be constrained by W 0 = W T , in which case the autoencoder is said to have tied weights . Each training x ( i ) is thus mapped to a corresponding y ( i ) and a reconstruction z ( i ) . The parameters of this model are optimized to minimize the average reconstruction error :  X  ? , X  0 ? = arg min where L is a loss function such as the traditional squared error L ( x , z ) = k x  X  z k 2 . An alternative loss, suggested by the interpretation of x and z as either bit vectors or vectors of bit probabilities (Bernoullis) is the reconstruction cross-entropy :
L IH ( x , z )= IH ( B x kB z ) Note that if x is a binary vector, L IH ( x , z ) is a negative log-likelihood for the example x , given the Bernoulli parameters z . Equation 1 with L = L IH can be written where q 0 ( X ) denotes the empirical distribution asso-ciated to our n training inputs. This optimization will typically be carried out by stochastic gradient descent. 2.3. The Denoising Autoencoder To test our hypothesis and enforce robustness to par-tially destroyed inputs we modify the basic autoen-coder we just described. We will now train it to recon-struct a clean  X  X epaired X  input from a corrupted , par-tially destroyed one. This is done by first corrupting the initial input x to get a partially destroyed version  X  x by means of a stochastic mapping  X  x  X  q D (  X  x | x ). In our experiments, we considered the following corrupt-ing process, parameterized by the desired proportion  X  of  X  X estruction X : for each input x , a fixed number  X d of components are chosen at random, and their value is forced to 0, while the others are left untouched. All information about the chosen components is thus re-moved from that particuler input pattern, and the au-toencoder will be trained to  X  X ill-in X  these artificially introduced  X  X lanks X . Note that alternative corrupting noises could be considered 1 . The corrupted input  X  x is then mapped, as with the basic autoencoder, to a hid-den representation y = f  X  (  X  x ) = s ( W  X  x + b ) from which we reconstruct a z = g  X  0 ( y ) = s ( W 0 y + b 0 ) (see figure 1 for a schematic representation of the process). As before the parameters are trained to minimize the av-erage reconstruction error L IH ( x , z ) = IH ( B x kB z a training set, i.e. to have z as close as possible to the uncorrupted input x . But the key difference is that z is now a deterministic function of  X  x rather than x and thus the result of a stochastic mapping of x . Let us define the joint distribution where  X  u ( v ) puts mass 0 when u 6 = v . Thus Y is a deterministic function of e X . q 0 ( X, e X,Y ) is param-eterized by  X  . The objective function minimized by stochastic gradient descent becomes: So from the point of view of the stochastic gradient de-scent algorithm, in addition to picking an input sam-ple from the training set, we will also produce a ran-dom corrupted version of it, and take a gradient step towards reconstructing the uncorrupted version from the corrupted version. Note that in this way, the au-toencoder cannot learn the identity, unlike the basic autoencoder, thus removing the constraint that d 0 &lt;d or the need to regularize specifically to avoid such a trivial solution. 2.4. Layer-wise Initialization and Fine Tuning The basic autoencoder has been used as a building block to train deep networks (Bengio et al., 2007), with the representation of the k -th layer used as input for the ( k + 1)-th, and the ( k + 1)-th layer trained after the k -th has been trained. After a few layers have been trained, the parameters are used as initialization for a network optimized with respect to a supervised train-ing criterion. This greedy layer-wise procedure has been shown to yield significantly better local minima than random initialization of deep networks , achieving better generalization on a number of tasks (Larochelle et al., 2007).
 The procedure to train a deep network using the de-noising autoencoder is similar. The only difference is how each layer is trained, i.e., to minimize the crite-rion in eq. 5 instead of eq. 3. Note that the corrup-tion process q D is only used during training, but not for propagating representations from the raw input to higher-level representations. Note also that when layer k is trained, it receives as input the uncorrupted out-put of the previous layers. Our training procedure for the denoising autoencoder involves learning to recover a clean input from a cor-rupted version, a task known as denoising . The prob-lem of image denoising, in particular, has been exten-sively studied in the image processing community and many recent developments rely on machine learning approaches (see e.g. Roth and Black (2005); Elad and Aharon (2006); Hammond and Simoncelli (2007)). A particular form of gated autoencoders has also been used for denoising in Memisevic (2007). Denoising us-ing autoencoders was actually introduced much ear-lier (LeCun, 1987; Gallinari et al., 1987), as an alter-native to Hopfield models (Hopfield, 1982). Our ob-jective however is fundamentally different from that of developing a competitive image denoising algorithm. We investigate explicit robustness to corrupting noise as a novel criterion guiding the learning of suitable in-termediate representations to initialize a deep network. Thus our corruption+denoising procedure is applied not only on the input, but also recursively to interme-diate representations.
 The approach also bears some resemblance to the well known technique of augmenting the training data with stochastically  X  X ransformed X  patterns. E.g. augment-ing a training set by transforming original bitmaps through small rotations, translations, and scalings is known to improve final classification performance. In contrast to this technique our approach does not use any prior knowledge of image topology, nor does it pro-duce extra labeled examples for supervised training. We use corrupted patterns in a generic (i.e. not spe-cific to images) unsupervised initialization step, while the supervised training phase uses the unmodified orig-inal data.
 There is a well known link between  X  X raining with noise X  and regularization: they are equivalent for small additive noise (Bishop, 1995). By contrast, our cor-ruption process is a large, non-additive, destruction of information. We train autoencoders to  X  X ill in the blanks X , not merely be smooth functions (regulariza-tion). Also in our experience, regularized autoencoders (i.e. with weight decay) do not yield the quantitative jump in performance and the striking qualitative dif-ference observed in the filters that we get with denois-ing autoencoders.
 There are also similarities with the work of (Doi et al., 2006) on robust coding over noisy channels. In their framework, a linear encoder is to encode a clean input for optimal transmission over a noisy channel to a de-coder that reconstructs the input. This work was later extended to robustness to noise in the input, in a pro-posal for a model of retinal coding (Doi &amp; Lewicki, 2007). Though some of the inspiration behind our work comes from neural coding and computation, our goal is not to account for experimental data of neu-ronal activity as in (Doi &amp; Lewicki, 2007). Also, the non-linearity of our denoising autoencoder is crucial for its use in initializing a deep neural network. It may be objected that, if our goal is to handle missing values correctly, we could have more naturally defined a proper latent variable generative model, and infer the posterior over the latent (hidden) representation in the presence of missing inputs. But this usually requires a costly marginalization 2 which has to be carried out for each new example. By contrast, our approach tries to learn a fast and robust deterministic mapping f  X  from examples of already corrupted inputs. The bur-den is on learning such a constrained mapping during training, rather than on unconstrained inference at use time. We expect this may force the model to capture implicit invariances in the data, and result in interest-ing features. Also note that in section 4.2 we will see how our learning algorithm for the denoising autoen-coder can be viewed as a form of variational inference in a particular generative model. The above intuitive motivation for the denoising au-toencoder was given with the perspective of discover-ing robust representations. In the following, which can be skipped without hurting the remainder of the paper, we propose alternative perspectives on the algorithm. 4.1. Manifold Learning Perspective The process of mapping a corrupted example to an uncorrupted one can be visualized in Figure 2, with a low-dimensional manifold near which the data con-centrate. We learn a stochastic operator p ( X | e X ) that maps an e X to an X , p ( X | e X ) = B g corrupted examples will be much more likely to be outside and farther from the manifold than the uncor-rupted ones. Hence the stochastic operator p ( X | e X ) learns a map that tends to go from lower probability points e X to high probability points X , generally on or near the manifold. Note that when e X is farther from the manifold, p ( X | e X ) should learn to make big-ger steps, to reach the manifold. At the limit we see that the operator should map even far away points to a small volume near the manifold.
 The denoising autoencoder can thus be seen as a way to define and learn a manifold. The intermediate rep-resentation Y = f ( X ) can be interpreted as a coordi-nate system for points on the manifold (this is most clear if we force the dimension of Y to be smaller than the dimension of X ). More generally, one can think of Y = f ( X ) as a representation of X which is well suited to capture the main variations in the data, i.e., on the manifold. When additional criteria (such as sparsity) are introduced in the learning model, one can no longer directly view Y = f ( X ) as an explicit low-dimensional coordinate system for points on the manifold, but it retains the property of capturing the main factors of variation in the data. 4.2. Top-down, Generative Model Perspective In this section we recover the training criterion for our denoising autoencoder (eq. 5) from a generative model perspective. Specifically we show that training the denoising autoencoder as described in section 2.3 is equivalent to maximizing a variational bound on a particular generative model.
 Consider the generative model p ( X, e X,Y ) = p ( e X | X ) = q D ( e X | X ). p ( Y ) is a uniform prior over Y  X  [0 , 1] d 0 . This defines a generative model with pa-rameter set  X  0 = { W 0 , b 0 } . We will use the previ-ously defined q 0 ( X, e X,Y ) = q 0 ( X ) q D ( e X | X )  X  (equation 4) as an auxiliary model in the context of a variational approximation of the log-likelihood of p ( e
X ). Note that we abuse notation to make it lighter, and use the same letters X , e X and Y for different sets of random variables representing the same quan-tity under different distributions: p or q 0 . Keep in mind that whereas we had the dependency structure X  X  e X  X  Y for q or q 0 , we have Y  X  X  X  e X for p . Since p contains a corruption operation at the last generative stage, we propose to fit p ( e X ) to corrupted training samples. Performing maximum likelihood fit-ting for samples drawn from q 0 ( e X ) corresponds to min-imizing the cross-entropy, or maximizing Let q ? ( X,Y | e X ) be a conditional density, the quan-bound on log p ( e X ) since the following can be shown to be true for any q ? : Also it is easy to verify that the bound is tight when q ( X,Y | e X ) = p ( X,Y | e X ), where the ID KL becomes 0. We can thus write log p ( e X ) = max q ? L ( q ? , e X ), and consequently rewrite equation 6 as where we moved the maximization outside of the ex-pectation because an unconstrained q ? ( X,Y | e X ) can in principle perfectly model the conditional distribu-tion needed to maximize L ( q ? , e X ) for any e X . Now if we replace the maximization over an unconstrained q ? by the maximization over the parameters  X  of our q 0 (appearing in f  X  that maps an x to a y ), we get Maximizing this lower bound, we find Note that  X  only occurs in Y = f  X  ( e X ), and  X  0 only occurs in p ( X | Y ). The last line is therefore obtained entropy is constant, irrespective of (  X , X  0 ). Hence the entropy of q 0 ( X,Y | e X ) = q 0 ( Y | e X ) q 0 ( X | e vary with (  X , X  0 ). Finally, following from above, we obtain our training criterion (eq. 5): where the third line is obtained because (  X , X  0 ) we chose p ( Y ) uniform, i.e. constant, nor on EE q 0 ( X, e X ) [log p ( e X | X )], and the last line is obtained by inspection of the definition of L IH in eq. 2, when p ( X | Y = f  X  ( e X )) is a B g 4.3. Other Theoretical Perspectives Information Theoretic Perspective: Consider X  X  q ( X ), q unknown, Y = f  X  ( e X ). It can easily be shown (Vincent et al., 2008) that minimizing the expected reconstruction error amounts to maximizing a lower bound on mutual information I ( X ; Y ). Denois-ing autoencoders can thus be justified by the objective that Y captures as much information as possible about X even as Y is a function of corrupted input. Stochastic Operator Perspective: Extending the manifold perspective, the denoising autoencoder can also be seen as corresponding to a semi-parametric model from which we can sample (Vincent et al., 2008): where x i is one of the n training examples. We performed experiments with the proposed algo-rithm on the same benchmark of classification prob-lems used in (Larochelle et al., 2007) 3 . It contains different variations of the MNIST digit classification problem (input dimensionality d = 28  X  28 = 784), with added factors of variation such as rotation ( rot ), addition of a background composed of random pixels ( bg-rand ) or made from patches extracted from a set of images ( bg-img ), or combinations of these factors ( rot-bg-img ). These variations render the problems par-ticularly challenging for current generic learning al-gorithms. Each problem is divided into a training, validation, and test set (10000, 2000, 50000 examples respectively). A subset of the original MNIST prob-lem is also included with the same example set sizes (problem basic ). The benchmark also contains addi-tional binary classification problems: discriminating between convex and non-convex shapes ( convex ), and between wide and long rectangles ( rect , rect-img ). Neural networks with 3 hidden layers initialized by stacking denoising autoencoders (SdA-3), and fine tuned on the classification tasks, were evaluated on all the problems in this benchmark. Model selection was conducted following a similar procedure as Larochelle et al. (2007). Several values of hyper parameters (de-struction fraction  X  , layer sizes, number of unsuper-vised training epochs) were tried, combined with early stopping in the fine tuning phase. For each task, the best model was selected based on its classification per-formance on the validation set.
 Table 1 reports the resulting classification error on the test set for the new model (SdA-3), together with the performance reported in Larochelle et al. (2007) 4 for SVMs with Gaussian and polynomial kernels, 1 and 3 hidden layers deep belief network (DBN-1 and DBN-3) and a 3 hidden layer deep network initialized by stack-ing basic autoencoders (SAA-3). Note that SAA-3 is equivalent to a SdA-3 with  X  = 0% destruction. As can be seen in the table, the corruption+denoising train-ing works remarkably well as an initialization step, and in most cases yields significantly better classification performance than basic autoencoder stacking with no noise. On all but one task the SdA-3 algorithm per-forms on par or better than the best other algorithms, including deep belief nets. Due to space constraints, we do not report all selected hyper-parameters in the table (only showing  X  ). But it is worth mentioning that, for the majority of tasks, the model selection procedure chose best performing models with an over-complete first hidden layer representation (typically of size 2000 for the 784-dimensional MNIST-derived tasks). This is very different from the traditional  X  X ot-tleneck X  autoencoders, and made possible by our de-noising training procedure. All this suggests that the proposed procedure was indeed able to produce more useful feature detectors.
 Next, we wanted to understand qualitatively the ef-fect of the corruption+denoising training. To this end we display the filters obtained after initial training of the first denoising autoencoder on MNIST digits. Fig-ure 3 shows a few of these filters as little image patches, for different noise levels. Each patch corresponds to a row of the learnt weight matrix W , i.e. the incoming weights of one of the hidden layer neurons. The benefi-cial effect of the denoising training can clearly be seen. Without the denoising procedure, many filters appear to have learnt no interesting feature. They look like the filters obtained after random initialization. But when increasing the level of destructive corruption, an increasing number of filters resemble sensible feature detectors. As we move to higher noise levels, we ob-serve a phenomenon that we expected: filters become less local, they appear sensitive to larger structures spread out across more input dimensions. We have introduced a very simple training principle for autoencoders, based on the objective of undoing a corruption process. This is motivated by the goal of learning representations of the input that are robust to small irrelevant changes in input. We also motivated it from a manifold learning perspective and gave an interpretation from a generative model perspective. This principle can be used to train and stack autoen-coders to initialize a deep neural network. A series of image classification experiments were performed to evaluate this new training principle. The empirical re-sults support the following conclusions: unsupervised initialization of layers with an explicit denoising crite-rion helps to capture interesting structure in the input distribution. This in turn leads to intermediate rep-resentations much better suited for subsequent learn-ing tasks such as supervised classification. It is possi-ble that the rather good experimental performance of Deep Belief Networks (whose layers are initialized as RBMs) is partly due to RBMs encapsulating a simi-lar form of robustness to corruption in the represen-tations they learn, possibly because of their stochas-tic nature which introduces noise in the representation during training. Future work inspired by this observa-tion should investigate other types of corruption pro-cess, not only of the input but of the representation itself as well.
 We thank the anonymous reviewers for their useful comments that helped improved the paper. We are also very grateful for financial support of this work by NSERC, MITACS and CIFAR.

