 1. Introduction
Sequential pattern mining is a fundamental problem in knowledge discovery and data mining with broad applications, including those in the analysis of customer purchase behavior, web access patterns, sci-enti fi c experiments, disease treatment, natural disaster prevention, and protein formation. Sequential pattern mining includes two main stages: frequent pattern mining and rule mining. Many studies have modi fi ed the AprioriAll algorithm ( Agrawal and Srikant, 1995 )formin-ing frequent sequential patterns. Unlike the general mining of frequent sequences, the mining of frequent closed sequences has not been extensively studied. Although some algorithms have been proposed, such as CloSpan ( Yan et al., 2003 ), CLOSET  X  ( Wang et al., 2003 ), and BIDE ( Wang et al., 2007 ), their performance is poor for large databases. BIDE detects frequent sequences, not closed ones, and prunes candi-dates early, instead of using maintenance-and-test patterns.
Recently, many authors have proposed techniques that present data in a vertical format ( Song et al., 2005 ), use projection databases operation ( Pei et al., 2001 ), use bit vector data structures ( Song et al., 2008 ), all of which have been shown to be effective. However, the storage space and execution time can be further reduced in the mining process for large sequence databases.

The present study proposes the CloFS-DBV algorithm, which uses a vertical data format and data compression, and divides the transactions of D , denoted as sup D  X  S a  X  . The support of a sequence is given in the notation sequence : support . For example, a sequence AB with support 3 is represented as AB : 3.

Given a minimum support threshold minSup , a sequence S a is a frequent sequence on D if sup D  X  S a  X  Z minSup . If sequence S a is frequent and there exists no proper supersequence S b of S a with the same support, S a is called a frequent closed sequence, i.e., there does not exist S b such that S a D S b and sup D S a  X  X  X  sup D  X  S b  X  . The problem of mining frequent closed sequences is to fi nd a complete set of frequent closed sequences for an input sequence database D and a given minimum support threshold minSup .

Example 1. Consider the sequence database in Table 1 . The database has fi ve unique items I  X  A ; B ; C ; D ; E fg and four transac-tions, i.e., j D j X  4. Assume that the minimum support threshold is minSup  X  2  X  50 %  X  . If all frequent sequences of D are mined with the given minSup , the following 32 sequences are obtained: S  X  { A : 4, AA : 4, AB :3, AC :4, (AC) :2, AAB :2, AAC :2, A(AC) :2, ABA :3, ABB :3, ABC :3, A(BC) :3, ACA :2, ACB :2, ABAB :2, AB(BC) :2,
A(BC)A :2, A(BC)B :2, B :3, BA :3, BB :3, BC :3, (BC) :3, BAB :2, B(BC) :2, (BC)A :2, (BC)B :2, C :4, CA :3, CB :2, CC :2, CAC :2}. In contrast, mining the frequent closed sequences yields S FCS  X  { AA :4, AC :4, AAC :2, A (AC) :2, ABA :3, ABB :3, ABC :3, A(BC) :3, ABAB :2, AB(BC) :2, A(BC)A :2, A (BC)B :2, CA :3, CAC :2}, which has only 14 sequences.

Frequent closed sequences S FCS are thus more compact than general frequent sequences S FS . This is due to subsequence S a with the same support as that of supersequence S b being absorbed by S b without affecting the mining results. For example, sequence  X  BC  X  A : 2 is absorbed by sequence A  X  BC  X  A : 2because  X  BC  X  A D A  X  BC  X  A and sup D  X  X  BC  X  A  X  X  sup D  X  A  X  BC  X  A  X  X  2.

At fi rst, the frequent sequences with length 1 are mined from a sequence database. After that, these frequent sequences will com-bine (or extend) each other to form new candidates with length 2.
This process is repeated until there are no new generated frequent sequences. In general, the sequences with length k are used to generate sequences with length k  X  1. Besides the generation of candidates, the checking of frequent closed sequences is applied in each process. The following de fi nitions are used in the process of extending sequences and checking frequent closed sequences.
De fi nition 1. ( substring of a sequence ). Let S be a sequence. sub  X  S  X  X  i r j  X  is de fi ned as a substring of length  X  j i  X  1  X  from position i to position j of S . For example, sub 1 ; 3  X  BABC  X  is BAB and sub  X  BABC  X  is C .

De fi nition 2. ( extending a sequence from a 1-sequence ). Let  X  and  X  tions and positions of sequences  X  and  X  , respectively. There are two forms of sequence extension
De fi nition 3. ( extending a sequence from a k-sequence ). Let  X  and  X  using techniques such as Common Pre fi xandBackwardSub-Pattern to reduce the search space. The ClaSP ( Gomariz et al., 2013 )algorithm uses a vertical database format strategy, as done by the SPADE algorithm, and a heuristic to prune non-closed sequences, as done by the CloSpan algorithm. However, the algorithm maintains previous candidates to test the closure of sequences and removes them later. The maintenance of candidates increases memory consumption, and the number of test candidates increases with the number of gen-erated frequent closed sequences.

In order to overcome these problems, the BIDE algorithm ( Wang et al., 2007 ) does not keep track of historical frequent closed sequences for checking the closure of new patterns. Instead, it uses bi-directional extension techniques to examine frequent closed patterns as candidates before extending a sequence. Moreover, the algorithm uses a BackScan process to determine candidates that cannot be extended to reduce mining time. The algorithm uses pseudo projection techniques to reduce database storage space and is ef fi cient for low support thresholds. However, in the process of mining, it has to project and scan databases many times for each pre fi x, making it inef fi cient. 4. Proposed algorithm
This section describes the proposed CloFS-DBV algorithm, which uses a dynamic bit vector (DBV) structure combined with location information in the structure of the transaction CloFS-DBVPattern to mine frequent closed sequences. 4.1. DBV data structure
Sequence mining algorithms based on a vertical data format have proven to be more ef fi cient than those based on a horizontal data format. Typical algorithms that use a vertical format include SPADE ( Zaki, 2001 ), DISC-all ( Chiu et al., 2004 ), HVSM ( Song et al., 2005 ), and MSGPs ( Pham et al., 2012 ). These algorithms scan the database only once and calculate the support of the sequence quickly. However, the disadvantage is that they consume much more memory to store additional information. BitTableFI ( Dong and Han, 2007 ) and Index-BitTableFI ( Song et al., 2008 ) have solved this problem by compressing data by using a bit table (BitTable).
The main drawback of the bit vector structure is a fi xed size, which depends on the number of transactions in a sequence database.  X  1  X  indicates that the item appears in the transaction and  X  0  X  indicates otherwise. In practice, there are usually many  X  0  X  bits in a bit vector, i.e., items in sequence database often random appear in the sequence database. In addition, during the extending process of sequences (using bitwise AND) the  X  0  X  bits will more appear. Thus increases the required memory and processing time. In order to overcome this problem, dynamic bit vector architecture is used ( Vo et al., 2012 ). Let A and B be two bit vectors. p 1 and p 2 are the probabilities of  X  1  X  bits in two bit vectors A and B , respectively. Assuming k is the probability of  X  0  X  bits after joining A and B to get AB by the extending process of sequence. Therefore, the probability of  X  the minimum value of p 1 and p 2 . Obviously, the probability of  X  1  X  in AB will decrease in contrast the probability of  X  0  X  in that increase. Moreover, the gap between p 1 and p 2 will be larger quickly after several sequence extensions.

Suppose there are 16 transactions in a sequence database. An item i exists in transactions 7, 9, 10, 11, and 13. The bit vector for position is 1, thus 1 : f 1 ; 4 g is stored. Table 5 presents the CloFS-DBVPattern for sequence A in Table 1 .
 The CloFS-DBV tree is used to store CloFS-DBVPattern. The
CloFS-DBV tree is an extension of the pre fi x tree. The pre fi x tree can be constructed in the following way. The root node of the tree is at the top level and labeled NULL . Recursively, each node X at level k in the tree can be extended by adding one item to get a child node X 0 at level k  X  1. The children of node X are generated and arranged in lexicographical order. By using the pre fi x tree, the generation of sequence rules becomes more ef fi cient. Typical algorithms for building a pre fi x tree include CloGen ( Pham et al., 2013 ), IMSR_PreTree ( Van et al., 2014 ), and MNSR_PreTree ( Pham et al., 2014 ). In the CloFS-DBV tree, each node is a CloFS-
DBVPattern: a sequence, a DBV, and a list of positions of the sequence in each transaction. Each node in the tree is extended in two forms: sequence extension and itemset extension. Fig.1 shows candidates for the database in Table 1 obtained using the CloFS-
DBV algorithm. 4.3. CloFS-DBV algorithm Proposition 1. (checking sequence closure). If there exists a sequence
S that is a forward-extension or backward-extension of sequence S a , sequence S a is not closed, and S a can be safely absorbed by S b . Considering the above example, suppose that S a  X  CC : 2 and
S  X  CAC : 2 .Then,CC : 2 will be absorbed by CAC because CC D CAC and sup D  X  CC  X  X  sup D  X  CAC  X  X  2.
 the transactions containing S p in sequence database D, the extension can be pruned by pre fi xS p . For example, consider the database D in
Table 1 . There is no need to extend pre fi x B because there exists a
Table 6 shows the pseudo code of proposed CloFS-DBV algo-rithm. The algorithm fi rst scans database D to fi nd frequent 1-sequences and stores them in fcs 1 as CloFS-DBVPattern (line 2). Then, the items in fcs 1 are sorted in ascending order (line 3) to reduce the steps in the extension phase of the itemsets. On line 6, the algorithm performs the sequence extension according to the child nodes of FCS : root .
 Table 7 shows DBV-Pattern-Extension algorithm called by the CloFS-DBV algorithm. The sequence extension in two forms: sequence minSup  X  2  X  50 %  X  . After line 2 ( Table 6 ) is executed, three frequent 1-sequences are stored, i.e., fcs 1  X f A : 4 ; B : 3 ; C : 4 g ( Table 8 ).
In this example, pre fi x A is not a closed sequence after the backward-extension process and pre fi x B can be pruned after the pruning pre fi x process. The algorithm performs sequence extension to create new frequent closed 2-sequences. Starting with pre fi x A ,the extension proceeds with sequences A , B ,and C in the forms of sequence extension ( Table 9 a) and itemset extension ( Table 9 b). N10kD10k. First, experiments were conducted to compare the execution time of the three algorithms. The results are shown in Fig. 2 . Fig. 2 a shows the runtimes for minSup values of 6% to 10% for the C6T5S4I4N1kD10k database, Fig. 2 b shows those for minSup values of 3.5% to 5.5% for the T10I4D100k database, and Fig. 2 c shows those for minSup values of 5  X  9% for the N10kD10k database. When decreasing the minSup , there are more obtained frequent sequences. The result is the number of checking frequent closed sequences also increase. So the execution time of algo-rithms increases quickly.

Fig. 2 shows the execution time of three algorithms increases with decreasing minSup , CloFS-DBV being faster in all cases. For example, Fig. 2 a shows the mining time of CloFS-DBV, CloSpan, and BIDE. With minSup  X  6 % , the mining time of BIDE is 7432 ms, that of CloSpan is 7825 ms, and that of CloFS-DBV is 5040 ms. Almost the execution time of CloFS-DBV occurs in the fi rst stage of the mining process, i.e., CloFS-DBV fi rst scans a sequence database to construct a CloFS-DBVPattern structure for each item. After that stage, this algorithm takes very little time due to its operation mostly works on bit manipulation.

Next, experiments were conducted to compare the total mem-ory usage (MBs) of the three algorithms. Fig. 3 shows the memory usage of the three algorithms for various minSup values. Fig. 3 a  X  c shows the memory usage for C6T5S4I4N1kD10k, T10I4D100k and N10kD10k database respectively. With decreasing minSup , the number of generated candidates and required memory increases for the three algorithms. CloFS-DBV requires less storage space than does BIDE or CloSpan due to its use of a compressed data structure. For example, Fig. 3 c shows the total memory usage of CloFS-DBV, CloSpan, and BIDE for the N1kD10k database. With minSup  X  5 % , the total memory usage of BIDE is 29.5 MBs, that of CloSpan is 60.2 MBs, and that of CloFS-DBV is 7.37 MBs. The total memory usage of CloFS-DBV less than that of BIDE or CloSpan because CloFS-DBV uses a DBV data structure and stores the needed information in the mining process. In the mining process, CloFS-DBV neither uses a hash table nor uses database projection as CloSpan or BIDE does. Moreover, while extending sequences, counting support of sequences, and other operations of CloFS-DBV are mainly based on bit manipulation. So that it consumes less memory usage in the process. 6. Conclusion and future work This paper proposed the CloFS-DBV algorithm, which uses DBVs and transaction information to mine frequent closed sequences. The CloFS-DBV algorithm is divided into two main stages: (1) the original sequence database is transformed into a vertical data format called CloFS-DBVPattern, where each CloFS-DBVPattern stores the position of frequent closed sequences which appear in the database; (2) frequent closed sequences are gener-ated and tested, and pre fi xes are pruned early. The CloFS-DBV algorithm scans the database only once and calculates the sup-ports based on the DBV to generate new patterns. Due to its use of a compressed structure, the CloFS-DBV algorithm is more ef fi cient than the BIDE and CloSpan algorithm in terms of memory usage and runtime.

The CloFS-DBV algorithm has a few limitations that will be addressed in the future. Frequent closed inter-sequences will be mined to reduce the number of redundant patterns. Based on mining frequent closed inter-sequences, the generation of rules will be made more compact and ef fi cient. In addition, mining maximal frequent sequences has been proposed in recent years ( Guan et al., 2005; Garc X a-Hern X ndez et al., 2006; Lin et al., 2007; Fournier-Viger et al., 2013 ). The DBV data structure will be applied for the ef fi cient mining of such sequences.

