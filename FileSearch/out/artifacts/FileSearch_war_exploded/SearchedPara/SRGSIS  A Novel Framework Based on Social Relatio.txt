 Tag-based social image search predominately focus on us-ing user-annotated tags to find out the results of user query. However, the performance of tag-based social image search is usually unable to satisfy the needs of users. In this pa-per, we propose a novel framework based on Social Rela-tionship Graph for Social Image Search (SRGSIS), which involves two stages. In the first stage, we use heterogeneous data from multiple modalities to build a social relationship graph. Then, for the given query keywords, we execute an ef-ficient keyword search algorithm over the social relationship graph and obtain top-k candidate results based on relevance score. We model these results as the answer trees connect-ing keyword nodes that match keywords in the query. In the second stage, for refining the candidate results, each im-age in social relationship graph is represented as a region adjacency graph by using the visual content of image. We further model these region adjacency graphs as a closure tree and compute approximate graph similarity between the candidate results and the closure tree to obtain more de-sirable results. Extensive experimental results demonstrate the effectiveness of the proposed approach.
 H.3.3 [ Information Storage and Retrieval ]: Information Search and Retrieval Algorithms, Measurement, Experimentation, Performance Social relationship graph, Multimodality, Keyword search, Closure-tree
Tag-based social image search enables users to formulate queries using keywords and provides beneficial image search results to users in response to queries. However, the perfor-mance of existing tag-based social image search methods is usually not satisfactory. This can be mainly attributed to the following three facts. First, user-annotated tags are usu-ally noisy. Second, there lacks a good ranking strategy to order the images that contain query keywords. Furthermore, most studies only focus on exploiting the tags of image, but ignore the other multiple interactive information sources in social networks.

To solve these issues, in this paper, we propose a novel framework based on social relationship graph for social im-age search (SRGSIS), which involves two stages. Firstly, the heterogeneous data from multiple modalities are used to build a social relationship graph, which is an undirected graph with weight of edge. Then, for the given query key-words, we execute an efficient keyword search algorithm over the social relationship graph. Answers to a user query are modeled as rooted answer trees connecting keyword nodes that match keywords in the query. Each answer tree is as-signed a relevance score and presented in a decreasing order of that score.

For building a social relationship graph, specifically, we take Flickr as the social media platform in our study. Flickr contains rich user-generated contents, including shared im-ages, user-annotated tags, comments, and so on. Besides these explicit information about images, the relationship amongst users can also be leveraged to improve the per-formance of social image search. For example, Flickr user can create and join interest groups where users share images of common interests and comments with each other.
Secondly, we refine the results of keyword search. All im-ages from social relationship graph are represented as the region adjacency graphs by using visual content of images. We further model these region adjacency graphs as a closure tree by neighbor biased graph mapping with edit distance. The closure tree captures the similar structural information of each region adjacency graph. As a result, we compute approximate graph similarity between the region adjacency graphs based on closure tree, to obtain more desirable re-sults.
In this section, we describe an overview of building the social relationship graph. We use a method based on kernel-based learning for inferring the social relationship of Flickr users [3] . Firstly, the multiple modalities in Flickr are repre-sented as proximity graphs which are built by defining var-ious kernel function { K } 1  X  5 on each modality (Note that there are five different modality in our work, which are im-ages, tags, comments, contact list of user and interest groups respectively). All proximity graphs are weighted by the ker-nel target alignment principle [4]. We combine these multi-ple proximity graphs by learning the optimal combination. Secondly, a kernel-based learning to rank approach is used to model the social relationship with the optimal kernel learned from the first stage.
In recently, many efforts have been conducted to improve social image search by exploiting the tags associated images and visual content of images. Generally, social images are usually associated with a set of user-annotated descriptors called tags, and thus tag-based image search can be easily accomplished by using these tags as index terms. Existing social image search approaches can be classified into two main categories: relevance-based ranking by using the tags and the visual content of images [1, 3, 6], tag-based query expansion to generate the image tag recommendation by exploiting the users X  feedback [2].
Generally, given the social relationship graph and a user query q = ( k 1 , ..., k m ) which contains m search terms, the first step is to locate nodes matching search keywords, which are called keyword node . For each search keyword k i in the query, we find a set of nodes S i that are relevant to k i
An answer to a query is a rooted answer tree containing at least one node from each S i . Figure 1 demonstrates an example of query and answer trees. Figure 1 ( a ) shows a social relationship graph with each node attached some at-tributes (tags, images, comments, contact list, group), i.e., Flickr user node 8 containing the tag cat, cute . For sim-plicity, we only indicate the tags of node which contain the query keyword, such as keyword nodes 3, 4, 6, 8 respec-tively. Each edge weight represents the social relationship strength amongst users. Figure 1 ( b ) shows the answer trees corresponding to the given query q = ( cute, cat ).
Each answer tree has to be assigned a relevance score, which is presented in a decreasing order of that score. The score of an answer tree is a function of edge score , and we normalize the relevance score in the range [0 , 1]. We obtain the normalized edge score Escore ( e ) of an edge by dividing the edge weight by w min , w min is the minimum edge weight in the social relationship graph. Thus, the edge score of e is defined as Esocre ( e ) = log(1 + w ( e )/ w min ). The overall relevance score of an answer tree is then defined as 1  X  1 + mum edge weight w min is 0 . 2. Thus, the relevance score of answer tree in Figure 1 ( b ) is 0.5 and 0.4 respectively.
In this section, we present an outline of an efficient key-word search algorithm which offers a heuristic solution for incrementally finding the best answer trees.

For each query keyword, we can obtain corresponding the set of keyword node ( S 1 , ..., S m ). Let S = the keyword search algorithm concurrently runs | S | copies of Dijkstra  X  X  single source shortest path algorithm, one for each keyword node v in S with node v as the source. The | S | copies of Dijkstra  X  X  algorithm run concurrently using it-erators. All the Dijkstrs  X  X  single source shortest path algo-rithms traverse the social relationship graph G in a reverse direction. The nodes visited by each copy of Dijkstra  X  X  al-gorithm are called a cluster. The shortest path information (pre-compute) is used to guide the iterators. Specifically, the keyword search algorithm use a cursor to traverse each keyword node and gives the equi-distance expansion order in each cluster, which guarantees an optimal (very fast) key-word search. When an iterator for keyword node v visits a node u , it finds a shortest path from u to the keyword node v . The idea of concurrent keyword search is to find a common node in social relationship graph from which there exists a shortest path to at least one node in each set S Such paths will define a rooted answer tree with the com-mon node as the root and the corresponding keyword nodes as the leaves. Note that these keyword nodes contain the im-ages associated with the tags which match the query terms.
We extract the visual features of images from social re-lationship graph and divide these images into homogeneous color regions by using region segmentation algorithm called EDISON [5]. The relationships among segmented regions can be represented as a Region Adjacency Graph (RAG). Figure 2: Example of RAG closure and closure-tree
Given two RAGs and a mapping between them, if we take an elementwise union of the two graphs, then we get a new graph where the attribute of each vertex and each edge is a union of the constituent attribute value. This generalized graph captures the structural information of each graph, and serves as a bounding container. This leads to the concept of a graph closure. The RAGs of each closure are very similar with each other. We model these RAGs closure as a closure-tree by neighbor biased graph mapping with edit distance. Figure 2 shows an example of five RAGs and their closure tree.
In our work, when all region adjacency graphs are merged into the closure-tree by finding the graph mapping, we exe-cute the task of refinement over closure-tree. In the closure-tree, each node of closure-tree is a RAG closure of its chil-dren; the leaf node of closure tree correspond to all RAGs. The common ancestor of RAGs correspond to the closure which defined the similarity of RAGs. Specifically, we let C be a common ancestor node of RAG G 1 and RAG G 2 , if the distance (height) from C to its leaf nodes (RAG G 1 and RAG G 2 ) is smaller, then the RAGs have a greater similar-ity, vice versa.

Given the returned image results (Here are also repre-sented as RAGS) and generated closure-tree by all RAGs.
The steps of refinement over closure-tree are as follows: (1) We firstly locate RAGs (the returned image results of each answer tree) correspond to the leaf node of in the closure-tree. (2) To obtain more desired results, we solve three cases in the refining procedure. Three cases are True Positive , False Negative , False positive respectively. Specifically, we set a threshold  X  , which use to judge the similarity of the returned results. That means to decide whether the returned image results will be used as the final results. Note that the threshold  X  can be seen as the height from a RAG G (leaf node) to closure of RAG G (common ancestor node). Figure 3: Example of three cases. Given Top-3 an-swer trees, for each answer tree, such as Top-1 , there are three cases corresponding to the Closure-tree.
As shown in Figure 3, given Top-3 answer trees, for each answer tree, such as Top-1, we assume that G 1 and G 2 are the returned image results from the keyword nodes of Top-1 answer tree. When two RAGs G 1 and G 2 are located correspond to the leaf node of closure-tree, we mark them with red and green respectively.
 True Positive : For the Top-1 answer tree, if G 1 and G 2 Table 1: The statistics of the collected Flickr data. belong to a a common ancestor closure and satisfy d ( G 1  X  , then, the images corresponding to the G 1 and G 2 can be used as the final results which will be returned to the users. between RAGs G 1 and G 2 with the minimum edit distance under all possible mappings  X  . The true positive case can be observed in Figure 3 ( b ).
 False Negative : For the Top-1 answer tree, if G 1 and G 2 not belong to a common ancestor closure, but satisfy max { d min ( G 1 , closure ( G 1 )) , d min ( G 2 , closure ( G then G 1 and G 2 can be returned to the user. At the same time, G 3 and G 4 are also used as the final results, as shown in Figure 3 ( c ).

In the false negative case, G 3 and G 4 are also returned to the users. Because G 1 and G 4 belong to a common ancestor closure C 1 , which means the images correspond to G 1 and G 4 has a high similarity. Likewise, G 2 and G 3 are able to be interpreted in the same way. Thus, if G 1 and G 2 are the final results, then the G 3 and G 4 are also the final results. This case demonstrate that the images correspond to the G and G 4 are not be found by keyword search in the first stage, but they are indeed the results which should be returned to the users.

False Positive : For the Top-1 answer tree, if d ( G 1 , G  X  , then we discard the G 1 and G 2 , as shown in Figure 3 (d).
The false positive case shows that G 1 and G 2 are actually not satisfy the request of the user X  X  query, even though they are used as the returned image results by keyword search. In this case, we can solve the problem caused by the imprecise user-annotated tags.

For the Top-k answer trees, we refine these answer trees by using the principle of three cases to obtain more desirable results.
We evaluate our approach on a set of real social images that are collected from Flickr. Table 1 shows the statis-tics of the collected Flickr data. To model the region ad-jacency graph, we extract 225-dimensional block-wise color moment features and 75-dimensional edge distribution his-togram features. All the experiments are executed on Intel Core4 2.8GHz CUP, 4GB RAM and 500GB hard disk.  X  Evaluation set for social image search . We select 20 diverse tags which are all time most popular query tags by statistics of Flickr, as the query keywords to execute the keyword search over social relationship graph. The queries include cat, sky, mountain, automobile, water, flower, bird, tree, sunset, sea, airplane, beach, boat, bridge, tiger, dog, lion, butterfly, horse, street respectively.  X  Method comparison . For simplicity, three methods are denoted as DRR-V [7], DRR-S [8], and JoL [6] respec-tivel y. We denoted our method as SRGSIS, specifically, the first stage of our framework as SRGSIS-1, and the entire framework (including the refinement stage) as SRGSIS-2.
We conduct experiment with 10 out of 20 query compar-ison between three method, DRR-s , JoL, and SRGSIS, re-spectively. As shown in Table 2, for some queries DDR-s is on a par with JoL, such as airplane . However, our method superiors to DDR-s and JoL by observing the MAP. On av-erage, compared with the DDR-s , we obtain a relative im-provement in terms of precision@20 by 28.8% and 24.3 % in terms of MAP. Compared with the JoL, we obtain a relative improvement in terms of precision@20 by 15.3% and 19.9% in terms of MAP. Figure 4: The comparison of MAP measurement of different approaches for 10 out of 20 queries.

Figure 4 shows the comparison of MAP measurement of five approaches for another 10 out of 20 queries. We observe that SRGSIS-2 outperforms the other methods by improving the performance 30.8% in terms of MAP. For the SRGSIS-1, it also superiors to DDR-s and JoL, even though SRGSIS-1 do not refine the returned results in our framework.
In this paper, we use heterogeneous data of multiple modal-ities to build a social relationship graph. Then, we execute an efficient keyword search algorithm over social relation-ship graph, the answers to query are modeled as the rooted answer trees, these answer trees are present in a decreasing order correspond to the relevance score of answer trees. Fur-thermore, we refine the results from keyword search based on closure tree to obtain more desirable results. Our frame-work with a high extensibility, it not only solve query key-word but the image sample. Extensive experimental results demonstrate the effectiveness of the proposed approach.
This research are supported by the NSFC (Grant No. 61025007, 60933001 and 61100024), National Basic Research Program of China (973, Grant No. 2011CB302200-G), Na-tional High Technology Research and Development Program of China (863, Grant No. 2012AA011004) and the Funda-mental Research Funds for the Central Universities (Grant No. N110404011). [1] L. Wu, X. S. Hua, N. H. Yu, W. Y. Ma, S. P. Li. [2] Z. J. Zha, L. Yang, T. Mei, M. Wang, and Z. Wang. [3] J. F. Zhuang, T. Mei, Steven C. H. Hoi, X. S. Hua, S. [4] C. Cortes, M. Mohri, and A. Rostamizadeh.
 [5] D. Comanicu and P. Meer. Mean shift: A robust [6] Y. Gao, M. Wang, H. B. luan, J. L. Shen, S. C. yan, [7] M. Wang, K. Yang, X. S. Hua, and H. J. Zhang. [8] K. Yang, M. Wang, X. S. Hua, H. J. Zhang. Tag-based
