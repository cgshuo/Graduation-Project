 Queries on the web can easily result in a large number of results. Result Diversification, a process by which the query provides the k most diverse set of matches, enables the user to better under-stand/explore such large results. Computing the diverse subset from a large set of results needs a massive number of pair-wise distance computations as well as finding the subset that maximizes the total pair-wise distance, which is NP-hard and requires efficient approx-imate algorithm.

The problem becomes more difficult when querying semi-structured data, since diversity can occur not only in the document content but also (and more importantly) in the document structure; thus one needs to efficiently measure the structural differences between results. The tree edit distance is the standard choice but, is too ex-pensive for large result sets. Moreover, the generalized tree edit distance ignores the context of the query and also the content of the documents resulting in poor diversification. We present a novel al-gorithm for meaningful diversification that considers both the struc-tural context of the query and the content of the matched results while computing pair-wise distances. Our algorithm is an order of magnitude faster than the tree edit distance with an elegant worst case guarantee.

We also present a novel algorithm that finds the top-k diverse subset of matches in time linear on the size of the result-set. We experimentally demonstrate the utility of our algorithms as a plug-in for standard query processors without introducing large error and latency to the output.
 H.2.m [ Database Management ]: Miscellaneous Algorithms,Experimentation diversity, semi-structured data, XML
Vast repositories of semi-structured data exist on the web and are accessed by user queries typically using an XML query language (such as XPath and XQuery. It is typical for such queries (espe-cially when searching the web) to return a large answer set, making it quite a challenge for the user to capture/view the whole result space. Result Diversification has been recently introduced for re-lational datasets [3][6], as an approach to ease interpreting a mas-sive result set by returning the k most diverse results. Algorithms for XML result diversification have also been proposed recently [2][4] but, they only consider the data content (i.e. keywords) of the query.

What makes the problem challenging is that diversity can oc-cur not only in the content of the documents but also (and more importantly) in the structure of the documents. Since the XML-based query can contain ancestor-descendent(//) or wildcard(*) re-lationships, there maybe significant structural differences (e.g., ad-ditional nodes in a matched path) among the returned results. Such diversity will not be explored by the content-only based diversifi-cation; instead we need an approach that takes into account differ-ences both in the structure and content of the results.
To elaborate, let us consider an example document of biblio-graphic records shown in figure 1. The document has three records: two PhD theses and a paper written by two different authors. An ex-ample XPath query  X //Bib//Faloutsos X , with one ancestor-descendent relationship describing  X  X ind all bibliographic entries of Falout-sos X , has three exact matches shown by the thick lines in figure 1. Assume instead that we want to present the user with the two most diverse results. We should then provide the pair of matches (among the three possible pairs) that exhibits the highest diversity. Among the three matches, the one on the right (match 3) is struc-turally different from the other two because it is a record of a paper whereas the others are records for PhD theses. The matches on the left (match 1) and in the middle (match 2) are different because of the contents of the  X  X hDThesis X  records (match 1 is a record for  X  X ichalis X  while match 2 is a record for  X  X hristos X ). Ideally, we would like to return to the user matches 2 and 3, since they are different both in content and in st ructure. Therefore, we need a di-versification method that combines both the structural and content-based differences of the results.

A naive way to find the most diverse k -subset from a set of N returned results, is to take the maximum of the total pair-wise dis-tance as a measure of diversity for all of the N k subsets. Typically N and k are thousands and tens, respectively. Such an instance of the problem requires 100 2 distance computations. The distance measure, therefore, must be very efficient to keep the computation time tolerable. In addition to that, the number of times distances are computed must be reduced. a Paper of Michalis Faloutsos.

For structural query processing, a popular choice [1] of distance measure is the tree edit distance [7]. We focus on extending the tree edit distance in two ways (section 3). First, we consider the contents of the nodes and also the structural context of the query to perform well in presence of both types of differences and thus, provide meaningful diversification. Second, we leverage off the known skeleton (i.e. the query) of the results to compute the dis-tance measure faster. We present a novel algorithm to achieve both of them. Our distance measure is comprehensive and our algorithm is at least an order of magnitude faster than the generalized tree edit distance with O ( n 2 ) worst case time complexity, where n is the number of nodes in the comparing trees.

Diversification is an NP-hard [6] problem. Therefore, enumer-ating all of the subsets to measure their goodness is necessary for exactness but prohibitive even if we have the best distance mea-sure. For efficiency, we need an approximate algorithm that checks only a tiny fraction of the number of subsets the naive algorithm checks (section 4). In reality, the approximate algorithms still re-quire orders of magnitude more time to do the diversification than it is required to produce the answer set. Therefore, the total latency for a user since the query is given becomes intolerable as the size of the result set increases. We present a novel algorithm to mitigate such imbalance between the query processor and the diversification algorithm.
An XML document is an ordered labeled tree T . T is a graph with vertices V ( T ) and edges E ( T ) . An edge ( u , v ) resents a parent child relationship where u is the parent of v .Only the root has no parent. A node u can have zero or more children in a strict left to right order. Nodes with zero child are leaves. anc defines the set of ancestors of node u . Every node has a label de-noted by label ( u ) . A postorder traversal of a tree visits the children of a node from left to right before visiting t he node. For example, the postorder traversals of the trees in figure 1 are shown by the numbers beside each node. We denote the nodes of a tree by the postorder sequence t 1 ,t 2 ,...,t n ,where n = | T | is the number of nodes in T . The subtree rooted at node t i is denoted by T postorder sequence of T i is a subsequence of T ending at t starting at l ( t i ) . l ( t i ) is the leftmost node of the tree T ple, l (9) = l (6) = 5 and l (14) = 10 in figure 1(c).

We are given a query Q which is also an ordered labeled tree where edges represent XPath axes. We are also given a set of XML documents D , in which we find matches for the query.

A map between a node s i in a tree S and a node t j in a tree T is an ordered pair ( s i ,t j ) . We define a relation M : V or simply a mapping M : S  X  T such that M maps some nodes of S to some nodes of T with the following conditions. Note that M is not a function and, therefore, is not defined for all nodes in S and T . Nodes mapped by M capture similar structure in both S and T . M : T  X  S is the inverse mapping of M such that for all ( s, t )  X  M , ( t, s )  X  M .If M is defined for every node s  X  S ,then M is a complete mapping. If M is complete, M is not guaranteed to be complete. If both M and M are complete, they are called maximal mappings.

M is called an outer mapping if (i) for every leaf s in S , M is a leaf in T and (ii) root ( T )= M ( root ( S )) . If both M and M are outer then they are called minimal mapping. Figure 2(b) shows an example of minimal mapping between S and T .

A match of a query Q is another ordered labeled tree T , such that there is a complete and minimal mapping M : Q  X  T and for all ( q,t )  X  M , label ( q )= label ( t ) . There has been many algorithms proposed for finding all of the exact matches of query Q in D [5]. There is also algorithm [1] that finds approximate matches where query Q may not have complete mappings. We consider an exact matching algorithm A is given and A ( D , Q ) is the set of matches denoted by T = { T 1 ,T 2 ,...,T n } . We denote a distance measure by d ( ., . ) , which computes the dissimilarity between two matches T and T j .

Aset R  X  X  of size k is the most diverse if the total pair-wise distance T i ,T j  X  R d ( T i ,T j ) is the maximum. The matches in R are said to be the top-k diverse matches for the query Q in the doc-ument set D . [T OP-k D IVERSE M ATCHES ]. For a given Q and D , find the k -subset R of the set of matches T such that the total pair-wise distance of R (i.e. T i ,T j  X  R d ( T i ,T j ) ) is the maximum over all such subsets.

The optimal algorithm to find the top-k diverse matches requires enumerating all the k -subsets of the set T and selecting the one with maximum pair-wise distance. This algorithm has O ( |T | time complexity and therefore, too slow for interactive queries. To solve the problem efficiently there are two lines of attack; speeding up the distance measure and considering only a fraction of the sub-sets heuristically. In section 3, we describe our approach of com-puting distance very fast by taking both the structure and content of the query into account. In section 4, we describe our heuristic approach to find the diverse subset efficiently.
To diversify a set of matches for an XML query, we need a dis-tance measure that can compare two trees. The tree edit distance [7] is the most widely used distance measure for tree structures. The idea is to transform one tree to the other such that the total cost of the sequence of edit operations performed for the transformation is minimum and hence the distance between the two trees.
There are three types of edit operations. The delete operation removes a node n from the tree and connects the children of n as the children of the n  X  X  parent preserving the sibling order of the children. The insertion operation on a node n adds an edge from some node p to n and makes a subsequence of children of p the children of n .The rename operation changes the label of a node.
For every operation, an associated cost is defined. The cost can depend on the operation, the label of the node(s) being operated on as well as the context at which the operation is being performed. The simplest cost model assumes equal cost for all of the three operations: insertion, deletion and rename.

Any valid mapping M : S  X  T can be translated to a sequence of edit operations to convert one tree to another. The sequence of operations is (i) delete all non-mapped node in S , (ii) rename all mapped nodes that do not have the s ame label and, (iii) insert all non-mapped nodes in T . Since, M preserves the structural similar-ity by the three conditions described in the definition of mapping, at any intermediate stage of the sequence of operations M remains valid. The converse is also true. If we are given a sequence of edit operations, there exists a mapping M : S  X  T that has cost no higher than that of the sequence of edit operations[7]. Therefore finding the least costly sequence of edit operations is the same as to finding the least costly mapping as defined below.

D EFINITION 1. Given a mapping M : S  X  T and a equal cost for the operations, we define the cost ( M ) as where M m = { ( s, t )  X  M | label ( s ) = label ( t ) } .
The term | S | X  X  M | denotes the number of non-mapped nodes in the tree S and this is the number of deletions we need to perform. Similarly, | T | X  X  M | is the number of insertions and | M number of rename operations.
 D EFINITION 2. Tree edit distance between S and T , TED ( is the smallest cost over all mappings M : S  X  T .

Tree edit distance finds the best possible mapping preserving the structural similarity. But while computing the distance between two matches, TED does not utilize the information that both the matches have complete-minimal mapping from the query. In the next two subsections, we modify TED to use these two mappings for computing distances. We start with adding the structural context sensitivity in the distance measure and, add the content sensitivity in the later subsection.
In this section, we describe a new algorithm to compute the mod-ified tree edit distance that considers the query mappings as con-textual information. We denote the modified distance measure as Seeded Tree Edit Distance (STED) .

Consider the set of matches T of a given query Q .Let S, T be any two matches for the query Q as shown in figure 2 and M and M T are the complete minimal mappings from Q to S and T .
We define a new mapping M : S  X  T where ( s i ,t j )  X  M for all ( q,s i )  X  M S and ( q,t j )  X  M T . Note that, M may not be complete but always minimal. We call M a seed map. From now, M always refers to a minimal mapping and, therefore, the direction of the map is not important at any point.
 Figure 2: An example query ( Q ) on the left with two matches S and T . The induced minimal mapping between S and T is shown by the dashed lines.

Note that, if  X  M : S  X  T is a super mapping such that  X  M then cost (  X  M )  X  cost ( M ) under equal costs of edit operations. Because we want to preserve the seed mapping M as the context, we modify the tree edit distance to find a super mapping of M that minimizes the total cost instead of any mapping.

D EFINITION 3. The seeded tree edit distance, STED ( S, T, M between S and T given a minimal mapping M : S  X  T ,isthe smallest cost over mappings  X  M  X  M .

To compute STED using existing algorithms for computing tree edit distance, we can just change the cost model trivially. More precisely, if ( s, t )  X  M then cost of deleting s , inserting t and mapping s (or t ) to a different node x = t (or s )israisedtoinfinity. This change in cost model guarantees that ( s, t ) would be in the optimal mapping.

The classic algorithm for tree edit distance is a dynamic pro-gramming algorithm which computes a matrix of size | S | X | where a cell ( i, j ) denotes the tree edit distance between S For example, figure 3(a) shows the matrix for trees in figure 2 when the change in the cost model is adopted. Clearly most of the entries are invalid and contribute nothing to the final distance value. This motivates us to develop an efficient algorithm for finding STED for two trees when the seed map is given. Figure 3: (a) Tree edit distance matrix of S and T (b) Mapped chunks of S , T and corresponding STED
Let U T = { x | x  X  V ( T ) and  X  y [( x, y )  X  M or ( y,x be the set of mapped nodes in a tree T . Note that all of the leaves and the root of T are in U T . If the tree is divided at every node in U T by keeping two copies in the two halves, we will get chunks from T .Let C ( T,M ) or C T in short denote the set of chunks found in tree T and C T u denote the chunk rooted at a node u  X  U T . For example, figure 3(b) shows the chunks of S and T from figure 2 1 . The reader may wonder why defining the leaves as tiny chunks. In reality, they have inconsequential effect on the performance but, helps to simplify the description by far.
Since M : S  X  T is a one-to-one mapping, every chunk C S u from tree S has a mapped chunk C T M ( u ) in the tree T . The submap-ping M u : C S u  X  C T M ( u ) induced from M is minimal by defini-tion. Note that no internal node in C S u is mapped by M . Moreover, no internal node in C S u will be mapped by the optimal mapping to a node in C T M ( v ) where u = v . The following lemma describes the fact more formally.

L EMMA 1. Optimal mapping  X  M for STED ( S, T, M ) will not map any node from one chunk C S u to another chunk C T M ( v ) that there are u, v  X  U S and u = v .

Using the above lemma, we can now say that finding optimal mappings for every pair of mapped chunks is sufficient. If we only find the mappings for the mapped pairs of chunks, compute the editing distance for these mappings and then, sum these distances for all of the mapped pairs of chunks; it is the same as the optimal editing distance between S and T . Mathematically,
To find the mapping between C S u and C T M ( u ) ,wepresentan O algorithm where n is the number of nodes in C S u and C T detailed description of the algorithm is available at http://www.cs.ucr.edu/ hasanm/cikm12long.pdf
In the previous section, we have described how the mapping in-duced by the query can be used to compute accurate and efficient distances for diversification. If we use STED for the matches in figure 1, both (1, 3) and (2, 3) produce distance values of 1 and, consequently, result in a tie. Because (1,3) involves the same per-son (i.e.  X  X ichalis X ) while (2,3) does not, the obvious choice for the diverse pair is (2,3). Now the question is, how we can modify STED to capture true diversity by breaking such tied situation.
The answer is, by taking the contents (i.e. nodes in the docu-ment that are structurally unrelated to the query) into consideration. Contents can create different levels of differences between matches even if the matches are structurally similar to each other. For exam-ple, in figure 1 the first two matches are PhDThesis records linked to Faloutsos, but their authors are different.

When two nodes of a map ( s i , t j ) have the same label (i.e. label ( s i )= label ( t j ) ), under the equal cost model no cost is added to the total. There can be differentiating features in the branches of the subtrees S i and T j that are not matched to the query and, hence are ignored by STED. For example, First Name/Michalis is a branch of Author in match 1 which is not matched to any part of the query. Let S R i and T R j are the two trees rooted at s contain the remaining branches unmatched to the query. We add a correction cost c  X  [0 , 1] as a cost of the map ( s i , t the amount of mismatch present in S R i and T R j .

The correction cost c can trivially be computed by simply tak-ing the TED ( S R i ,T R j ) and normalizing by the maximum possible distance between a pair of matches. However, TED is too costly to use for computing the fractional contributions from the contents just to break the ties. We develop a novel approach to obtain the correction cost c efficiently.

At first, we classify nodes of an XML document in one of the four categories: value, attribute, entity and connector .
Similar classification has been proposed in [4] when the Docu-ment Tree Descriptor (DTD) is not available. We scan the docu-ments once to identify the type of every node. For example in fig-ure 1, there are four attributes; School, First Name and Last Name, Title and, three entities; PhDThesis, Author and Paper.
The four classes of nodes are defined keeping the usual structure of an XML document in mind. In general, an attribute (similar to a  X  X ariable X  in programming languages) has exactly one value and no other child. Therefore, attributes do not require the above men-tioned correction cost as their values are always compared. In con-trast, entities generally have multiple attributes and may need some correction cost. Since connectors have no attribute/value, having correction cost for them is not meaningful.

To compute the correction cost for entities, we only consider the number of mismatched attributes. Two attributes are mismatched if they have the same label but different values. For example, in fig-ure 1 the entity Author in all the documents has two attributes First Name and Last Name. While comparing the two Author nodes in 1 and 2, the number of mismatched attributes is 1 because of the different first names. If an attribute is present in only one entity and absent in the other, it does not confirm any difference between the entities and, th erefore, these attribut es are not counted as mis-match [4]. For example, had there be a Middle Name attribute for the Author entity in match 1, the number of mismatched attributes would still be 1.

We define the correction cost for entities as below. Here, the total number of attributes is a normalization constant. Examples of correction costs for entities: c Author =0 . 5 match pairs (1, 2) and (2, 3).

Let us revisit the problem of breaking ties for the matches in figure 1. (1, 3) has a distance of 1 and (2, 3) has a distance of 1.5 when the above defined correction costs are used with the equal cost model. Thus, adding content awareness breaks the tie meaningfully in favor of the true diverse set of matches.
Result set diversification is an NP-hard problem. Many heuris-tics [3] have been proposed to find approximate diverse result set (greedy heuristic, interchange heuristic, clustering heuristic, etc.). In this paper we utilize the greedy heuristic algorithm [3] which selects a seed of one or two matches, and then finds the next ob-ject to add in the final result set that maximizes the total distance of the current result set. The algorithm stops once k matches are added to the result set. The algorithm computes linear number of editing distances on the number of matches ( | ( T ) | )as k&lt;&lt; We consider two methods Diameter Seed [3], and Random Seed for selecting the seeds.
As seen in section 5, diameter-seed diversification algorithm pro-duces better quality diverse results, but requires quadratic running time because of the quadratic number of distance computations for seed selection. The random-seed algorithm improves the running time but degrades the quality, which motivates to propose a new and fast heuristic for seed selection, so to have similar time com-plexity as random-seed while improve the overall quality of diverse result set.
 We propose a new scoring technique for selecting the initial seed. Instead of a random seed, we want to start from one of the matches which have an extreme value for a relevant but low cost feature. One such feature is the count of nodes in a match. Counting nodes for every match and selecting the one with the maximum count takes one linear scan over the matches. Note that, this process does not require any distance computation. We name this selec-tion method as QMax .
To experimentally demonstrate the utility of our algorithms, we have used the Treebank dataset 2 because of its rich structural vari-ations. We have selected seven queries (table 1). The queries are structurally different from each other to cover several extreme cases. The experiments are performed in a standard unix system on a 2.10 GHz processor and 4GB of RAM.

Our first experiment is to evaluate the performance of STED in comparison with the generalized tree edit distance that uses a mod-ified cost model to preserve the seed map. We also use an interme-diate algorithm which divides the trees into chunks as STED but, computes regular tree edit distances (with the modified cost model) for every pair of chunks. Figure 4(a) shows the average time taken to compute the distance between two results for the queries in table 1. Note that all three methods compute the same distance as out-put, thus the quality of the distance measures are equal. However, STED performs at least two orders of magnitude faster than the tree edit distance while the chunk-only version achieved notable amount of speedup demonstrating the importance of the our chunking ap-proach.

Our next experiment are to evaluate the scalability of the diver-sification algorithms, Diameter Seed ( Dia ), Random Seed ( Rand ), and our proposed algorithm, QMax . Note that, Dia requires quadratic number of distance computations for seed selection, while the Rand http://www.cs.washington.edu/research/xmldatasets/ and QMax need no distance computation for seed selection. We have shown the experiments for the query Q 3 , since it is compli-cated in structure and can generate a wide range of structurally di-verse results.

In figure 4(b), we show the running times of the algorithms to produce top-25 diverse results for different sizes of result sets. Clearly QMax outperforms the quadratic algorithm Dia . The curve for Rand is skipped for visual clarity as it overlaps the curve for QMax .
In figure 4(c), the total pair-wise distances of the top-25 diverse matches are shown for different algorithms. As seen from the fig-ure, QMax achieves insignificantly less accurate results compared to Dia . Reader may interpret this little loss on accuracy as the price paid for the huge speedup shown in figure 4(b). In practice, the small difference in the total distance does not add subjectively noticeable changes in the reported output.
We have modified the standard tree edit distance to consider the query-context and the contents for XML result diversification. We have also given a novel heuristic technique for speeding up the ex-isting algorithms. We have experimentally validated our contribu-tions.

Our algorithms assume exact matches of the query as input which often limits the size of the result set. For flexible and large result sets, we plan on considering approximate matches in future.
This research was partially supported by NSF IIS grant 0910859. [1] N. Augsten, D. Barbosa, M. Bohlen, and T. Palpanas. Tasm: [2] E. Demidova, P. Fankhauser, X. Zhou, and W. Nejdl. Divq: [3] M. Drosou and E. Pitoura. Diversity over continuous data. [4] Z. Liu, P. Sun, and Y. Chen. Structured search result [5] S. Tatikonda, S. Parthasarathy, and M. Goyder. Lcstrim: [6] M. R. Vieira, H. L. Razente, M. C. N. Barioni, [7] K. Zhang and D. Shasha. Simple fast algorithms for the
