 We propose and study a new type of facility location selection query, the top-k most influential location selection query . Giv-en a set M of customers and a set F of existing facilities, this query finds k locations from a set C of candidate locations with the largest influence values, where the influence of a candidate lo-cation c ( c  X  C ) is defined as the number of customers in M who are the reverse nearest neighbors of c . We first present a naive algo-rithm to process the query. However, the algorithm is computation-ally expensive and not scalable to large datasets. This motivates us to explore more efficient solutions. We propose two branch and bound algorithms, the Estimation Expanding Pruning (EEP) algo-rithm and the Bounding Influence Pruning (BIP) algorithm. These algorithms exploit various geometric properties to prune the search space, and thus achieve much better performance than that of the naive algorithm. Specifically, the EEP algorithm estimates the dis-tances to the nearest existing facilities for the customers and the numbers of influenced customers for the candidate locations, and then gradually refines the estimation until the answer set is found, during which distance metric based pruning techniques are used to improve the refinement efficiency. BIP only estimates the number-s of influenced customers for the candidate locations. But it uses the existing facilities to limit the space for searching the influenced customers and achieve a better estimation, which results in an even more efficient algorithm. Extensive experiments conducted on both real and synthetic datasets validate the efficiency of the algorithms. H.2.8 [ Database Management ]: Database Applications X  Spatial databases and GIS Algorithms, Performance, Theory Location Selection, Top-k Query, Reverse Nearest Neighbors A common problem many businesses and organizations share is finding a suitable place for the establishment of a new facility. For example, McDonald X  X  may want to add a new restaurant to com-pete with other restaurants; a wireless service provider may want to add a hotspot to a densely populated area to improve the qual-ity of service. In most cases, there is a set of candidate locations to select from (e.g., real estate agents have databases of places for lease or sale). Then, an important business decision (for McDon-ald X  X  or a wireless service provider) is to select a location that at-tracts as many customers as possible. Sometimes, one may want to first have a number ( k ) of such locations and then make decisions with further considerations. In this paper, we investigate this prob-lem of finding the top-k candidate locations that attract the largest numbers of customers, where k is a user input parameter. These k candidate locations can then be fed to further decision making procedures for selecting an overall best location for the new facili-ty. Here, we assume a customer is attracted by her nearest facility and the business has the knowledge of customer distribution from surveys or past sales records.

In urban development simulation, very often urban planners need to simulate the above facility location selection procedure, so that the influence of establishing a new public facility or business cen-ter on the residents can be observed. Figure. 1 gives an example, where circles, pentagons and stars denote customers, existing fa-cilities and candidate locations (labeled as c 1 ; :::; c First, for every candidate location c i , we compute the number of customers c i can attract. For example, if a new facility is estab-lished at c 1 , then it will attract 4 customers. Similarly, we can com-pute the numbers for c 2 ; c 3 ; c 4 ; c 5 and c 6 , which are 6, 3, 5, 2 and 1, respectively. Suppose now we want to have the top-3 candidate locations that attract the largest numbers of customers, i.e., k = 3 . Then, c 2 , c 4 and c 1 are returned as the answer set.

The above location selection problem aims at maximizing the  X  X nfluence X  of the candidate locations, where the influence of a can-didate location c denotes the number of customers whose respective nearest facility will be c if a new facility is established at c . This problem is frequently raised in applications like urban development simulation. Thus, we formulate it as the top-k most influential lo-cation selection query. We propose algorithms to process this query efficiently and make the following contributions.  X  We formulate the top-k most influential location selection query.  X  We analyze the properties of the query and propose pruning  X  Based on the proposed pruning techniques, we propose two al- X  We perform an extensive experimental study. The results con-
The rest of the paper is organized as follows.  X  2 reviews previ-ous studies on related topics.  X  3 defines the problem and presents the naive algorithm.  X  4 and 5 describe our EEP algorithm and BIP algorithm, respectively.  X  6 presents the experimental results and  X  7 concludes the paper. The studied problem is based on the concept of reverse nearest neighbor (RNN) query [10], which finds for a query object o a set of objects, who perceive o as their nearest neighbors. Since it was proposed, various techniques [14, 16, 1] have been proposed to pro-cess this type of query and its variants under different settings. For example, a most relevant RNN variant, the reverse k nearest neigh-bor (R k NN) query, extends the answer set to include objects who perceive the query object as among their k nearest neighbors. Wu et al. [16] study the R k NN query on continuously moving object-s, which correlates two sets of moving objects according to their closeness. The continuous join query on moving objects [18] al-so correlates multiple sets, but it focuses on intersection of objects with a time constraining technique rather than closeness. While these studies work well for processing a single R( k )NN query, they are not designed to compute R( k )NNs for large amount of objects at the same time, which is one of the key difficulties in our study.
Regarding to facility location problems, the most relevant study [8] ranks the candidate locations according to their influence values. However, the proposed solution cannot find the top-k locations and then early terminates the algorithm. Therefore, it does not solve our problem, while our proposed algorithms can be used to rank the lo-cations by setting k to the number of candidate locations. Other studies on facility location problems have quite different problem settings. Cabello et al. [2] propose a facility location problem based on the MAXCOV optimization criterion, which is to find regions in the data space to maximize the numbers of RNNs for the points in these regions. The study gives a theoretical analysis, but no ef-ficient algorithm is presented. Chen et al. [4] study this problem further and propose an efficient solution for finding the nearest fa-cilities. Xia et al. [17] propose the top-t most influential sites prob-lem, which finds the top-t most influential existing sites within a given region Q . Unlike our study, they do not consider any candi-date locations. Du et al. [5] propose to find a point from a contin-uous candidate region that can maximize the influence value. They use L 1 as the distance metric and have a strong assumption that all the roads are either horizontal or vertical. We consider L tance, which is a more general problem setting. More importantly, we consider a candidate location set instead of a candidate region. This is a more practical problem setting because in many real ap-plications, we can only choose from some candidate locations (e.g. a McDonald X  X  restaurant can only be opened at a place for lease or sale rather than anywhere in a region). Cheema et al. [3] propose to find an influence zone for a query location c , where customers inside this zone form exactly the R k NN query result of c . They compute Voronoi cells on the fly for the query location to obtain its R k NNs. Similarly, Wong et al. [15] propose to find the optimal region in which all query objects are of the maximum influence. Compared with this problem, our problem focuses on the number-s of RNNs of the candidate locations instead of specific locations of the RNNs. These problems use different settings from ours. Therefore, their solutions do not apply. 3.1 Problem Definition We assume three object sets, namely, a set of customers M , a set of existing facilities F and a set of candidate locations C . All the data objects (customers, existing facilities or candidate locations) are represented by points in an Euclidean space. We may refer to a data object as a data point or simply as a point. The distance between two points p 1 and p 2 is denoted as d ( p 1 ; p 2
Given a customer m  X  M , we denote her nearest existing fa-cility as nf ( m ) , and call the distance between m and nf ( m ) , d ( m; nf ( m )) , the nearest facility distance (NFD) of m . We say that customer m is attracted by a candidate location c  X  C if the distance between m and c is less than the nearest facility distance of m , i.e., d ( m; c ) &lt; d ( m; nf ( m )) . In this case, if we add a facility at c , it will become the new nearest facility of m .
 A candidate location c  X  C may attract multiple customers. The number of these attracted customers defines the influence of c , inf ( c ) . Formally, inf ( c ) = |{ m  X  M | d ( m; c ) &lt; d ( m; nf ( m ))
The top-k most influential location selection query is to find k candidate locations that attract the largest numbers of customers. D EFINITION 1. Top-k Most Influential Location Selection (TILS) Query: Given a constant k , a set of points M as customers, a set of points F as existing facilities and a set of points C as candidate locations, the top-k most influential location selection query finds a set C  X   X  C with k points, so that  X  c i  X  C  X  ; c j  X  C inf ( c i )  X  inf ( c j ) :
We call the subset C  X  the top-k most influential location set and denote it as T OP I NF ( K ,M,F,C) 1 . Next, we present a naive algo-rithm to find this subset. 3.2 A Naive Algorithm A naive algorithm (NA) to process the TILS query is to first com-pute the nearest facility distance for every m  X  M , which is done by scanning F to find m  X  X  nearest existing facility. Then, for every candidate location c  X  C , we scan the customer set M . If the dis-tance between c and a customer m , d ( c; m ) , is less than the nearest facility distance of m , i.e., c attracts m , then we increment the in-fluence value of c . After we have scanned every pair of c and m , we obtain the influence value for every c . We then sort the candidate locations according to their influence values, and output the first k candidate locations in the sorted result as the query answer set.
The NA algorithm is inefficient in that it has to scan every pair of customer and existing facility to find customers X  nearest exist-ing facilities, and every pair of candidate location and customer to compute candidate locations X  influence values. This motivate us
Note that there may be ties in the influence values. To simplify our discussion, we always return the first k candidate locations found that have the largest influence values. to explore effective pruning techniques to reduce the search space. We assume that the datasets are maintained in spatial indexes propose two algorithms utilizing different geometric properties to achieve effective pruning. In what follows, we present the overall ideas of these two algorithms. Technical details are omitted due to space limit and they are given in a technical report [9]. In this section, we propose an algorithm that estimates the distances to the nearest existing facilities for the customers and the numbers of influenced customers for the candidate locations, and gradually refines these estimations to obtain k candidate locations with the largest influence values. We use two R-trees and an R-tree variant to index the three datasets. The estimations and the refinement are performed during a traversal on the trees ( expanding tree nodes), where the importance value is introduced to help achieve a best first tree traversal while branch and bound techniques are introduced to prune the search space. We call this algorithm the Estimation Expanding Pruning (EEP) algorithm.

EEP indexes the set of existing facilities F and the set of can-didate locations C with two R-trees tr F and tr C , respectively. It indexes the set of customers M with an R-tree variant called the aggregate R-tree (aR-tree) [11] tr M , where a tree node stores the number of data objects that are enclosed by its MBR in addition to what is stored in a regular R-tree node. These three trees are tra-versed simultaneously. The traversal is managed using three auxil-iary lists L M , L F and L C , which store objects (either nodes or data objects) from tr M , tr F and tr C , respectively. For an object O in an auxiliary list, we define its importance value with its estimated distance to its nearest existing facility (if O is an object in the cus-tomer tree tr M ) or estimated number of influenced customers (if O is an object in the existing facility tree tr F or the candidate location tree tr C ). We use the importance value to determine which objects should be accessed first, and which objects should be pruned. Ev-ery object in these lists stores some influence relation information that indicates its position relation with the objects in other lists and will be used for importance value computation. Initially, each of these three lists contains only the root node of the corresponding tree. Then, these three lists are accessed repeatedly in the order of L M , L F and L C .

Every time a list L is accessed, EEP computes the importance value imp ( O ) for every object O contained in L . The object in L with the largest importance value is accessed first. If the ac-cessed object O is a node, the following 5 steps are performed: (i) O  X  X  child objects (either nodes or data objects) use O  X  X  influence relation information to compute their own influence relation infor-mation according to their positions; (ii) EEP prunes a child object O  X  of O if the influence relation information of O  X  indicates that the data objects enclosed in O  X  will not influence or be influenced by the data objects enclosed in the objects of other lists; (iii) if O is a node in tr C , we compute an influence value upper bound for each of its child objects O  X  , denoted by maxinf ( O is an upper bound of the influence value for all the candidate lo-cations enclosed by O  X  . We prune O  X  if maxinf ( O  X  ) &lt; inf where inf pr is an influence threshold value used for pruning ob-jects in tr C from further consideration. (iv) the unpruned child objects are used to update the influence relation information of the objects in other lists and further prune some of the objects. (v) EEP removes O and inserts the unpruned child objects of O into L . If the accessed object O is a candidate location c  X  C , EEP com-putes the maximum and minimum possible influence values for c ,
W e assume the R-tree [6] (or its variant), although our algorithms apply to any hierarchical index. denoted by maxinf ( c ) and mininf ( c ) , and compare mininf ( c ) with the largest maxinf value, inf mx , for all the objects in L If mininf ( c )  X  inf mx , then c is put in the query answer set T
OP I NF ( K ,M,F,C) and the pruning influence value inf pr ed to mininf ( c ) . If O is an existing facility or a customer, there is no computation required for processing O . However, we cannot simply remove O because there are objects in other lists that are re-lated to O . Therefore, EEP skips it and continues to access objects in other lists. The algorithm terminates when T OP I NF ( is filled with k candidate locations and no other candidate location can have larger influence values than those obtained so far. This section proposes a second strategy to estimate and refine the influence values for candidate locations. This strategy employs the concept of influencing region , which is a region computed from the existing facilities near a candidate location c to enclose all the cus-tomers who are influenced by c . The number of customers in this region forms an upper bound for c  X  X  influence value. By gradually refining the influencing region ( pruning customers), we reduce c  X  X  influence value upper bound until we get c  X  X  exact influence value. We present a branch and bound algorithm called the Bounding Influence Pruning (BIP) algorithm that utilizes the above strategy to process the TILS query. Like the EEP algorithm, the BIP algo-rithm also indexes the set of candidate locations C and the set of existing facilities F with two R-trees tr C and tr F . It indexes the set of customers M with an aR-tree tr M . BIP also takes a best first approach. The algorithm uses a priority queue Q C to perform a best first traversal on tr C , where each queue element is a node N from tr C , associated with a set of relevant F nodes N C tr F for influencing region computation, a set of relevant M nodes N
C :R M from tr M for influence value estimation, and an estimat-ed upper bound for the influence values of the candidate locations enclosed by the MBR of N C as N C  X  X  priority. To simplify the dis-cussion, we call this upper bound the influence value upper bound of N C . Initially, Q C only contains the root node of tr root C , with root C :R F = { root F } and root C :R M = { where root F and root M denote the root nodes of tr F and tr
Every time Q C is accessed, the first node N C in Q C is popped out. If N C is a non-leaf node, the algorithm (i) retrieves N nodes, (ii) constructs their own sets of relevant nodes according to N
C :R F and N C :R M , (iii) computes their influencing regions and influence value upper bounds, (iv) removes a child node if its influ-ence value upper bound is less than the smallest influence value of the candidate locations in T OP I NF ( K ,M,F,C), inf pr , and (v) push-es the unpruned child nodes into Q C . If N C is a leaf node, the algorithm (i) retrieves the candidate locations indexed in N computes their own influencing regions and exact influence values using N C :R F and N C :R M , (iii) inserts a candidate location into T
OP I NF ( K ,M,F,C) if its influence value is larger than inf (v) updates inf pr . The algorithm stops when Q C =  X  . 6.1 Experimental Settings All experiments were conducted on a PC with a 2GHz CPU and 2GB RAM. R-trees and aR-trees are used to index the datasets. With practical cardinalities of the three datasets, the total data size is less than 100MB. Given the current computer memory size, it is reasonable to assume that all the datasets reside in the memory and our performance measurement focuses on the total response time. We also measure the number of distance metric computations of the algorithms, which is a good indicator of their pruning power.
We conduct experiments on both synthetic and real datasets. Syn-thetic datasets are generated in a space domain of 1000  X  dataset cardinalities range from 1,000 to 2,000,000. To simulate real-life scenarios, where residents and facilities X  distributions are skewed while candidate locations X  distribution is relatively unifor-m, we generate M and F with Zipfian distribution with = 1 : 2 , and C with uniform distribution. To verify the effect of the value of k , we use values ranging from 10 to 5,000. As previous stud-ies [13, 7, 19] on main memory databases show, the tree node size of main memory index has a significant impact on the index per-formance. Therefore, we vary the node size ranging from 1K to 4K to study the effect of node size. By default, we use k = 10 and 2K as the tree node size. The real dataset we use is the North East dataset [12]. which contains 123,593 postal addresses repre-senting three metropolitan areas of the USA. We uniformly sample from this dataset to generate M, F and C, with dataset cardinalities ranging from 500 to 100,000. 6.2 Effect of Dataset Cardinality Figure 2 shows the results of the experiments varying the dataset cardinalities on the synthetic datasets. When varying the cardinali-ty of one dataset, we set the cardinalities of the other two datasets to their default values. The default values used are | M |
F | =50K and | C | = 10K.

From the figure, we can see that both the EEP and BIP algorithms consistently outperform the NA algorithm in terms of the total re-sponse time and the number of distance metric computations. This is because of the pruning techniques used by EEP and BIP to reduce the search space. We can also make other observations as follows. (i) With the increase in the customer set cardinality, EEP and BIP keep relatively stable performance, while NA X  X  performance deteri-orates drastically (please note the logarithmic scale in the figures). The reason is that NA sequentially scans all the datasets, and the dataset cardinality directly affect the number of distance compu-tations. In contrast, EEP and BIP use pruning techniques to keep relatively small search spaces and thus achieve much better perfor-mance. (ii) With the increase in the number of existing facilities, the number of distance metric computations of BIP becomes small-er. This is because BIP uses the set of F to prune some of the nodes in tr F as well as tr M . More existing facilities means larger search space can be pruned and BIP achieves better performance.
We have also performed similar experiments on real datasets, experiments on the effect of tree node size, and experiments on the effect of the value of k . The comparative performance of the different methods are very similar to the above experiments. We omit presenting the results due to space limit. We formulated the top-k most influential location selection query and conducted a comprehensive study on processing this query. We first analyzed the basic properties of this query type and proposed a naive algorithm (NA) to process the query. However, the NA algo-rithm is inefficient due to repeated scanning on datasets. Motivated by this, we explored geometric properties of spatial data objects, and proposed techniques to prune the search space. This resulted in two algorithms, the EEP algorithm and the BIP algorithm. Ex-perimental results show that the proposed pruning techniques are effective and the proposed algorithms outperform the naive algo-rithm significantly. In most cases, BIP performs better than EEP. We thank Google for funding a travel award that enabled Jianzhong Qi to attend the conference. This work is supported by the Aus-tralian Research Council X  X  Discovery funding scheme (project num-ber DP0880250). Zeyi Wen is supported by the Commonwealth Scientific and Industrial Research Organization (CSIRO).
