 With an exponential growth of information available on the Internet, it has become increasingly important to help p eople get personalized services. Recom-mendation systems, which are designed to solve the problem by analyzing users X  preference, are studied extensively in prior research.

The most widely used recommendation techniques are collaborative filtering-based (CF) and content-based (CB) methods. In the user-based CF [2], target user is recommended new items that are ra ted by his similar-minded neighbors. While in the item-based CF [3], the items similar to target user X  X  historical records will be recommende d. User-based CF tends to recommend popular items, which, however, harms the overall diver sity for all users. Item-based CF can boost long-tail items, but decrease indi vidual diversity. CB usually calculates the similarity between constructed user p rofile and item contents, which is often used to help improve the performance of CF methods. By considering both the collaboration and the cont ent, hybrid recommendation technology can achieve the benefits of different methods. But a simple linear combination of two factors in the user similarity calculation or the results adjustment can not perform effectively, which even decreases t he precision for specific users.
Graph-based recommendation model [12, 14] is flexible, which can make a good integration of varieties of contextual information. A recommendation list is generated by using personalized random walk(RWR) or hitting time in the graph. However, in the existing graph-based methods, random walk is usually conducted in the whole graph. Even a subgraph constructed from depth-first or breadth-first search is still very large. This practice not only causes high computational complexity, but also introduces too m uch noise, affecting the performance.
In this paper, we propose a hierarchical graph model for hybrid recommenda-tion, in order to combine different techni ques together appropriately and main-tain small computational complexity. When recommending for the target user, we only select relevant information from each factor to construct a concise graph. Thus the running time is greatly reduced and irrelevant noises are avoided. On the other hand, as the collaboration and content factors are combined more naturally by using topic modeling and iterative interaction in the well-defined structure, our accuracy is highly improved. Finally, we can alleviate the data sparsity as random walk-based ranking allows us to utilize indirect relationships between graph nodes. And we can boost long-tail items, as long as they contain the same topics target user prefers.

In conclusion, our main contributions are listed as follows:  X  We propose a novel hierarchical graph model for hybrid recommendation,  X  Our method can alleviate the data sparsity and boost long tail recommen- X  We conduct enough experiments on two datasets. Results show that our The rest of this paper is organized as fo llows. Section 2 presents some related work on recommendation. We give a detailed description of our proposed method RWR-UIC in section 3. Experiments an d analysis are included in section 4. Finally we conclude the paper with remarks of our work in section 5. Recommendation systems are basically di vided into two categories: CF-based and content-based(CB). CF [1] explores user-item rating matrix and can be further classified into user-based CF and item-based CF. User-based CF [2] as-sumes that similar users express similar interests in future items. Items rated by similar-minded neighbors are recommende d to the target user. User similarities are calculated based on ratings. [3] pro posed an item-based method. They rec-ommend new items which are similar to the items target user has rated. Items similarities are also calculated using rating matrix. In CF, usually a small subset of users or items are used as neighbors. CF is simple in training phase and can be used in many domains such as news and multimedia. The most important feature of CF is content-independent [11]. But if ratings are sparse, Standard CF methods result in poor results. Content-based methods [6] try to construct user X  X  profile using items X  contents. To generate recommendations, Similarity between candidate item X  X  contents and the constructed user profile is calculated. CB does not suffer from rating sparsity, but a big drawback is that it ignores the implicit associations between users, which leads to poor results purely using CB. Hybrid recommendation methods [10] can obtain the advantages of both methods by considering collaboration and content at the same time, but, usually a simple weighted combination of two fact ors cannot perform effectively.

Latent factor models have been succe ssfully applied to recommendation. For example, [8] proposed a three-layer asp ect model in which ratings and contents are combined in a probabilistic way, to address the cold-start problem. Matrix factorization was developed in [9,20]. It decomposes user-item rating matrix into low latent space. To predict the missing sc ore, we just need to multiply the latent vectors of candidate item and target user. However the latent space doesn X  X  have evident interpretation for human beings. Additionally, if training set is rather sparse, factorization may suffer from overfitting.

Graph-based methods ar e getting more and more attention recently. By set-ting a biased probability of jumping to the starting nodes, RWR is very use-ful for personalized recommendation [13]. [14] studied a click-through bipartite graph for a series of applications including recommendation task. [16] proposed a novel recommendation method which performs random walk on an items X  graph, where the edges denote similarities be tween items. [7] adopted a multi-layer graph model for personali zed query-oriented refere nce paper recommendation, but incorporating too many terms may make the graph extremely large. [12] proposed a random walk-based model which combines users, items, tags, social relationship into the whole graph. There is one thing in common in the above graph-based recommendation models: To generate recommendations, random walk is usually conducted in the whole graph. This practice not only leads to high computational complexity but also brings unnecessary noise. In this work, we just construct a sub-graph, which contains information mostly related to target user. collaboration and content more integrated more naturally and fully. The framework of our proposed method RWR-UIC ( R andom W alk with R estart which combines U ser-based, I tem-based and C ontent-based factors ) is shown in Fig.1. In the bottom part, concept mining on items X  contents and similarity calculation between users and items are done offline to save online response time. In the online procedure, when a user request recommendations, we firstly construct a concise graph as illustrated in Fig.3 for him, then top-N list is generated by using p ersonalized random walk. 3.1 Concept Mining A document may involve multiple topics. Using the words alone, we may fail to find conceptually related documents that use different wordings. Topic models like PLSI [4] and LDA [5] treat document as a probabilistic mixture of topics and estimate the doc-topic distributions from a collection of documents unsuper-visedly. When the corpus is not particula rly large, LDA can effectively prevent overfitting because it adds priors to the parameters. In this work, we adopt LDA topic model and use gibbs sampling [18] to infer the topic distributions.
In our rating corpus, items contents are not available. However, annotation tags in the social media websites, such as lastfm and imdb, are good descrip-tions of artists X  musical style or films X  storyline. By crawling these tags, we can construct items X  contents. However, the uncontrolled tagging behavior in web-sites results in tag redundancy and ambiguity. So LDA is used to help us capture the co-occurrence between related tags an d extract the items X  topic distributions p( t k | i). The results of this step are used for both user profiling and recommenda-tion graph construction. A sample tag cloud is generated by using top 30 terms of an topic. We can see that words are related to  X  X rime X , as illustrated in Fig.2. 3.2 User Profiling Formally, suppose that there exist a set of users U= { u 1 ,u 2 , ..., u M } and a set available with the corresponding rating R u,i . To generate recommendations, we start with constructing user X  X  preference profile as a two-attribute tuple {
T,L } . T represents u X  X  interest d istributions in content topics, in the format that u has shown interest in. We update T by the following procedure. T is firstly initialized to  X   X  u , we use Eq.(1) to calculate user similarity.  X   X  [0 , 1].
 Similarity is usually calculated by cosine Eq.(2) or Pearson correlation Eq.(3).  X   X  r a and sim a,b is the similarity between To calculate Pearson, we need to isolate co-occured items of two vectors in ad-vance. Additionally, if the number of co-occured items between two vectors is small, penalizing the correlation score o btained from very few evidence can im-prove prediction accuracy. Mor e specifically, set a threshold .Ifthenumberof co-rated items  X  is less than , we multiply the score by  X  [12]. In our experi-ments, sim ( T  X   X  u Eq.(2) in movielen and Eq.(3) in lastfm for getting better performance. It is also common to use only a subset of users for both performance and accuracy when making predictions. In our exper iments, A constant number is set. 3.3 Recommendation Graph Construction Algorithm 1 describes the process of gra ph construction by using selected in-formation which is highly related to target user. The graph has four layers which combine user-based, item-based and content-based factors together as il-lustrated in Fig.3. Neighbor layer contains the target user labeled with blue and his similar-minded neighbors. In candidate layer: On one hand, we add items rated by those similar-minded users(user-based); On the other hand, we also add items labeled with blue that are similar to target user X  X  historical records from steps 8 to 14(item-based). Namely , we treat target user himself as a fake neighbor with candidate items whose number is equal to the average rated items of all real neighbors. Items similarities are calculated using Eq.(2) based on con-tent tags. Tags X  importance are weighted by classical TF  X  IDF .Itiseasyto see that the items from two factors may be overlapped. In candidate layer, we remove the items target user has rated and set them as history layer labeled with yellow(content-based) . Every connection in graph G is bi-directional.
In the graph, the left part acts as collaboration factor; while the right part represents content factor. Collaboration factor influences candidate items by direct rating link. Since simple term matching is not precise for linking items because of existing synonyms and polysemants. We use intermediate topic layer to help content factor propagate its influence to the candidate items. Top-N recommendation list is finally generated from the candidate items in the second layer by using personalized random walk. Algorithm 1. Recommendation Graph Construction 3.4 Random Walk-Based Recommendation To generate the top-N recommended items in the proposed graph, we use per-sonalized random walk with restart(RWR). By setting a biased probability of jumping to the starting nodes that are highly related to target user, RWR al-lows us to calculate the relatedness between candidate items and target user X  X  preference. In our graph, neighbor nodes and history nodes are highly related to the target user, thus they are regarded as the starting nodes.

RWR works as follows: From the starting nodes, RWR is performed by ran-domly jumping to another linked node at each step, the jumping probability is proportional to the weight of outside links. Additionally, in each step there also exist probability  X  to force random walk restart at the starting nodes. Formally it is defined by Eq.(4). M is the transition matrix. M i,j denotes the probability of j being the next state given that the current state is i . q is the initial query vector in which the elements corresponding to the starting nodes are set to 1, others are set to zero. r t records the visiting probability of each node at step t .Updatethe values of vector r iteratively until convergence at step l . Finally r l i represents the relatedness between node i and the starting nodes.
 In our setting, q =( q N ,q C ,q T ,q H ), and the elements represent the four layers. Based on the starting nodes, we set q =(  X q N , 0 , 0 , (1  X   X  ) q H ).  X  controls the tradeoff between collaboration and content. q u N denotes the similarity between neighbor u and target user. Considering that target user is also put into the neighbor layer, we set his similarity equal to 1. q j H denotes the importance of item j in the content factors. Here, we define q j H = R u,j  X  IDF ( j )where IDF ( j )= normalized to 1 separately. r (0) is the initial visiting probability which is set equal to q . To get transition probability of each node, we need to normalize each row of M to 1, as illustrated in Fig. 4. In order to stop CN(ratings) from suppressing CT(topic distributions), we co nsider to give equal contributions from candidate layer to its two sides. Namely we firstly normalize CN and CT to 1 for each row respectively. Then CT an d CN are normalized to 1 together for each row. After getting the stable visiting probability of each node, we select the top-N items from candidate layer by sorting their values in descending order. 3.5 Complexity Analysis The main computation of random walk-based methods is updating the values of each node in the graph. Assuming that the number of average rated items per user is P, then there are N users, (N+1)P items, and K topics nodes in our recommendation graph. For updating user nodes, the computational complex-ity is O(NP). The computational complexities for candidate, topic and history nodes are O(NP(N+K)), O(K(NP+P)) and O(KP) respectively. Therefore, the total complexity in one iteration is O(P( N 2 +2NK+2K+N)). Usually K and N are small fixed values, which indicates that the running time of our method is proportional to the number of average rated items per users. In a long period, average ratings of the whole users will not change so much, so the complexity of our proposed method possesses good stability. 4.1 Experiment Settings Datasets . For experimentation, we use two different datasets 1 :Lastfmand Movielen. In order to get enough tags to construct items X  contents, we crawl the tags of the corresponding artists from last.fm 2 website, and the plot key-words of movies from imdb 3 website respectively. After that, we filter out items with less than 20 tags and items whose tags are not available. In fact the num-ber of filtered items in this step is very small. The statistics of two datasets are listed in Table 1. Movielen is relatively dense whose average ratings per user is almost 400, while Lastfm is rather sparse. The density of user-item rating matrix denotes the percentage of non-zero values.
 Compared Methods . To better understand our proposed method, We com-pared with five representative algorithms. (1)UCF: User-based collaborative fil-tering [15]; (2)ICF: Item-based collaborative filtering [15]; (3)UICF: Hybrid col-laborative filtering, which combines the predicted score from both UCF and ICF to generate the final rankings. To cons ider the content-based factors, users similarities are calculated by using Eq.(1) described in section 3.2.  X  =0 . 5; (4)PureSVD: An algorithm based on Matrix Factorization. [19] conducted ex-tensive experiments to suggest that PureSVD outperforms all other powerful models such as AsySVD , SVD++ [20]; (5)RWR-FULL: Personalized random walk in graph which contains all the users and items [12]. They use target user and his already rated items as the starting nodes.
 Further Study . To further explore the rationality of the way in which we fuse different factors. We compared a set of variants of our proposed method: RWR-U only considers the user-based factor; RWR-UI considers user-based and item-based factors; RWR-UC considers user-based and content-based factors. Their respective parameters are set in the same way as RWR-UIC.
 Evaluation Metrics . To measure the performance, we adopt the following met-rics to cover various aspects of our consideration. Additionally, we randomly split each user X  ratings into five parts equally. 20% of the items in each user X  X  profile are put aside as T u for testing. As default, we focus on the performance of top 200 recommendations. (a). Accuracy . We use precision, recall and MAP curves to measure accuracy. (b). Coverage . Obviously, accuracy is not enough for evaluation. Recommen-(c). Novelty . It is trivial to recommend popular items which are so apparent to Parameters Setting . The threshold of similar users or similar items in our proposed method, is set equal to UCF and ICF, so that we can compare the performance between basic CF and our method fairly. In experiments, we set them as 30 in both datasets for default.  X  controls the balance between col-laboration and content, and we tested its sensitivity on a set of limited values  X  probability of jumping to the starting nodes. We set  X  =0.8 as proposed in RWR-FULL [12], because we also find that when  X  increases, MAP, precision and recall all increase. This can be explained as a m ore personalized model as increasing  X  makes the model go back to the initial query vector q more frequently. The number of topics, K is set 30 in movielen and 40 in lastfm by cross validation. It-eration of all the random walk-based methods is set 100. The reduced dimension of PureSVD is set 50 as analyzed in [19] for getting better performance. 4.2 Results and Analysis  X  controls the tradeoff between collabora tion and content in query vector, so we firstly conducted a series of experiments to study its influence on final perfor-mance. If  X  = 1, we just regard neighbors as the starting nodes; while if  X  =0, starting nodes are only history items. Because of a limitation of space, we only give the findings. We find that spreading out from only one side can not perform well. The optimal  X  is 0.01 in movielen and 0.05 in lastfm, which are very small. Because in the right graph part, nodes are fully connected by dense edges, while the left is rather sparse. As the transmitted values to other nodes need to be di-vided by outdegrees, to make the influence from history layer enough significant, we must give higher weight to q H , which means a lower  X  for q N .
 Then we compared our method with existing algorithms using two datasets. From Fig.5, we see that UCF Performs better than ICF especially in lastfm. Because the number of users is much smaller than that of items and we can get more information for each user than each item. However, UICF does not gain much better performance than UCF, though it considers both content and collaboration. This phenomenon verifies our discussion that a simple weighted combination of several factors in the user similarity calculation and ranking ad-justment can not perform effectively. Bu t, our method RWR-UIC always outper-forms other algorithms. The reason is that: On one hand, the random walk of our method matches people X  X  decision-makin g process. Normally, people start with considering items: (1) similar to their history records (2) their similar-minded neighbors also like (3) contain the topi cs they prefer. The above three aspects are considered in our method at the same time in deciding an item X  X  relatedness. And the interaction between different fa ctors are not done once, but by iterative updates, so different factors are integrated fully. On the other hand, graph-based structure allows us to calculate the sim ilarity between different items, even they have no direct connections. Namely, some extra latent relationships are explored.
Although both RWR-UIC and RWR-FULL use the graph-based ranking to generate top-N lists, RWR-UIC performs much better than RWR-FULL in both datasets. We argue that incorporating too much information brings some irrele-vant noise which reduces the opportunity of transmitting to really related nodes, as RWR-FULL do. In contrast, We just retain the most relevant users and items in the graph and consider useful content factors apart from rating links. Another finding is that graph-based methods perform better in sparse dataset. In Lastfm whose density is 0 . 39%, RWR-UIC and RWR-FULL both perform much better than all the other methods. While in the dense Movielen, RWR-FULL drops a lot in precision and recall. The advantage of our method RWR-UIC is not as significant as that in Lastfm. We explain it as follows: On one hand, graph-based methods can utilize indirect relationships to calculate similarity, which is rather useful in alleviating the sparsity of ratings; On the other hand, when density increases a lot from Lastfm to Mo vielen, Precision and Recall increase correspondingly. But introduced noise also weakens the growth rate.

PureSVD performs better than our method in the dense movie dataset, which suggests the good performance of utilizing latent rating patterns based on matrix factorization. However, in the sparse music dataset, PureSVD performs the worst of all. It is evident that PureSVD suffers from overfitting when the rating matrix is very sparse. In general, our method has stable performance in both datasets.
From Table 2, we see that our method performs better in novelty. Because we also consider items gen erated by item-based tec hnique, as long as they are similar to user X  X  history records. More importantly, content-based factor further boosts similar items, if they contain the topics target user prefers. If we just consider rating links, more popular items will be recommended as RWR-FULL. So we can recommend not so  X  X pparent X  items.

From Fig.5(c) 5(d) and Table.2. We find that considering more factors such as item-based or content-based techniqu es always improves the performance of RWR-U. But RWR-UIC performs the best. It is verified again that the intuition of our random walk reflects people X  X  deci sion-making process. People can judge an item X  X  relatedness more accurately based on all the three aspects. Meanwhile the graph structure is suitable and effective to fuse different factors.
As random walk is conducted in a concise sub-graph which only contains carefully selected relevant informatio n. Our method has a fast speed of conver-gence. We tested our method(written by JAVA) in a server with 32 GB RAM. In movielen, our running time is 220 ms, while RWR-FULL needs 1.94s; In lastfm, we just need 40 ms. RWR-FULL needs 174ms. The complexity of our method is greatly reduced compar ed to existing graph-based methods. PureSVD can be run fast online, but SVD decomposition is rather time-consuming offline. In this paper, we propose a graph-based method for hybrid recommendation, which can combine different factors iteratively. Our method can alleviate the data sparsity and boost long tail items. Experimental results show that our method performs well especially in sparse dataset. In the future, we plan to explore more relationship in the same layer to further improve the performance. Acknowledgement. This research is supported by the 863 project of China (2013AA013300), National Natural Science Foundation of China (Grant No. 61375054 and 61402045) and Tsinghua University Initiative Scientific Research Program (20131089256), and Cross fund of Graduate School at Shenzhen, Ts-inghua University (JC20140001).

