 Current internet search engines have a number of deficiencies. First, these search cause these search engines use keyword-based indexing techniques to index Web-Pages. Although this approach assist users in finding information on the Web, many of the returned results are irrelevant to the user X  X  intent. This is due to the  X  X emantic-gap X  between the meanings of the keywords that are used to index WebPages and the meanings of the terms used by the user in his query. Second, the web-coverage by a single search engine may be limited. A study conducted by [2] showed that the index intersection between the largest available search engines (Google, Yahoo!, MSN and ASK) is estimated to be 28.8%. Therefore, combing results returned from multiple search engines can be seen as an effective solution to this problem. In this paper, we introduce Multi-Search, a meta-search engine for retrieving, merging and ranking results returned by several individual search engines. The proposed system employs knowledge represented by multiple ontologies to derive the semantic aspects of both the user query and returned search results. In addition, statistically-based semantic relatedness measures are utilized to compensate for missing background knowledge in the exploited ontologies. In our approach, we believe that users must be considered as the center of the search process. Therefore, in Multi-Search, users can filter and rank the results by giving them weights according to their relevancy to the query intent. To overcome the low coverage problem, the proposed system operates on top of several search engines such as Google (www.google.com), Yahoo! (www.yahoo.com), Bing (www.bing.com), and it can be easily extended by plugging additional search engines. We summarize our contributions as flows:  X  Unlike traditional keyword-based indexing approaches, Multi-Search employs  X  Multi-Search combines semantic and statistical based techniques to compensate related work. A general overview of the proposed meta-search engine is given in periments carried out to evaluate our meta-search engine. The final section presents the conclusions and outlines the future work. 2.1 Ontology-Based Semantic Translation (OBST) tent-based information retrieval systems. Several OBST systems have been proposed main. Among the first systems that used ontology for this purpose is OntoSeek [3]. This system is designed for content-based information retrieval from online yellow pages and product catalogs. It uses the Sensus ontology which comprises a simple taxonomic structure of approximately 70,000 nodes to represent queries and resource descriptions. The system proposed by [4] uses subject hierarchies provided by online portals such as Yahoo.com and About.com as reference ontology for personalized web search. The authors of [5] propose to use multiple ontologies in specialized do-mains for information extraction purposes. Their experimental results show that by using multiple ontologies precision can be improved. In Multi-Search , we are not interested in a particular domain; therefore, we propose to use general-purpose on-tologies that cover knowledge in multiple domains. 2.2 Meta-search Engine Construction For example, GIOSS [6] uses an approach called metaindex to select databases that are likely to contain the desired information. This approach has been proven not flexible or rather ignorant towards the newly added databases. Therefore, re-training is needed; and it is not very effective as the process of re-training is time consuming [7]. This paper X  X  idea is that these search engines index a big part of the web so the likely hood of users search engine is results merging. Traditionally, a linear combination (LC) of score results are achieved in specific cases, this technique has not yet been shown to produce reliable improvement [9]. MetaCrawler [10] is a popular meta-search engine that em-ploys LC scheme. [11] introduces a meta-search engine called iXmetafind which uses Mearf instead of the traditional LC scheme. It is stated by the authors of [11] that Mearf outperforms LC scheme because it takes advantage of several observations like: pres-common themes, in addition to personalization and clustering methods. As shown in Figure 1, when a user submits a query, the query analyzer first tokenizes the query into uni-gram, bi-gram and tri-gram tokens. Then, it checks whether each of the ontologies, semantic networks that represent the query terms and relations be-tween them are constructed. In this context, an ontology may produce zero, one or more semantic networks. Therefore, a merging mechanism is required to merge the produced semantic networks into a single coherent network. This network represents a cooperative decision made by multiple ontologies on the semantics of the query. 
Although using multiple ontologies provides broader domain coverage, we may still have some query terms that are not defined in any of the ontologies. In this case, merged semantic network. On the other hand, Multi-Search dispatches the user query into several search engines. At this step, different results may be returned by different search engines. Each returned result is an alyzed using the same technique that we used to analyze the user query. As such, semantic networks are constructed from the returned search results. In this context, a returned search result may produce zero, one or more semantic networks. Therefore, Multi-Search merges these networks by em-ploying the same technique used to merge the query semantic networks. To filter and rank the results, a scoring function is employed to match the query semantic network considered relevant to the query intent. Fina lly, the user is provided with a decision-oriented mechanism that allows him to contribute in the ranking process. Before we detail the methods of the proposed system, we formalize the use of the terms  X  X ntology X ,  X  X emantic Network X ,  X  X emantic Network Merging X ,  X  X emantic Network Enrichment X , and  X  X ormalized Retrieval Distance (NRD) X : Definition 1: Ontology: An ontology  X  is quintuple,  X  :=  X  C, P, I, V, A  X  where:  X  C is the set of concepts of the ontology. The concept hierarchy of  X  is a pair ( C,  X  P is the set of properties.  X  I is the set of instances or individuals  X  V is the set of property values  X  A is the set of axioms (such as constraints) Definition 2: Semantic Network: A semantic network  X  :=  X  T, R, A  X  where:  X  T is the set of terms in the network. These terms are query terms that are defined  X  R is the set of relations between the query terms. These relations are derived from  X  A is the set of axioms defined on the query terms and relations. Definition 3: Semantic Network Merging: A semantic network merging algorithm merged semantic network  X  merged as output. Definition 4: Semantic Network Enrichment: A semantic network enrichment { w  X  S (t) is the set of suggested enrichment candidates for t. A suggested candidate w  X  The set of suggested enrichment candidates S (t) can be obtained using the Normalized Retrieval Distance (NRD) function and based on a threshold value v using equation 1. Definition 5: Normalized Retrieval Distance (NRD): is a general case of the Normal-ized Google Distance (NGD) [12] functio n that measure the semantic relatedness tance between T mis and T in can be obtained as follows: where,  X  T  X  T  X  f(T  X  f(T  X  f(T  X  M is the number of web pages indexed by the search engine 4.1 Query Translation and Re turned Search Results Merging 4.1.1 Multiple Ontology-Based Query Translation First, we apply several Natural Language Processing (NLP) steps on the user query such as stop word removal, n-gram query tokenization, and part-of-speech tagging. whether they are defined in them or not. Tokens that are defined in the ontologies are considered as meaningful query terms and thus, semantic networks that represent these terms and relations holding between them are constructed. As a consequence of this step, different number of semantic networks may be produced according to dif-ferent ontologies. Therefore, we utilize the ontology merging algorithm to merge these networks into a single coherent network. The next example illustrates the NLP steps and the semantic networks construction and merging techniques. Example1: Query =  X  X ava or jawa the island of Indonesia X  In this example, we use WordNet [13] and OpenCyc [14] ontologies. First, the stop word removal function removes stop words based on a pre-defined list. For example, the words (the, of) are removed from the query. Then, the n-gram tokenization algo-rithm tokenizes the query into unigram, bigram and trigram tokens. After this step, each token is submitted to each of the ontologies to check whether it is defined in it or not. The algorithm returns that the terms {Java, Island, Indonesia} exist in both WordNet and OpenCyc ontologies. For this set of terms, semantic networks are con-structed based on both ontologies as shown in Figure 2. 
As we can see from figure 2, it is not necessarily that the used ontologies produce the same semantic networks. Therefore, due to the semantic heterogeneity between the produced networks, we utilize the merging algorithm described in section 4. In this algorithm, we used the merging techniques proposed in our previous work [15]. The result of merging the semantic networks is shown in figure 3 below. 
The rest of n-gram tokens such as  X  X awa X  are considered as missing background knowledge from the ontologies. However, we don X  X  ignore such tokens because we enrich the merged query semantic network. 4.1.2 Statistically-Based Semantic Relatedness Measures We utilize statistically-based semantic relatedness measures to compensate for the lack of domain coverage in the used onto logies. For query terms that are not defined enrich the merged query semantic network. To do this, first we utilize the NRD func-tion described in section 4. This function measures the semantic relatedness between the query terms in the merged query semantic network and other terms that are not defined in any of the used ontologies. As different semantic relatedness measures are returned according to severa l search engines, we sum up all NRD values for each candidate term. This summation represents a cooperative decision made by several search engines on the semantic relatedness measurers. Table 1 shows the obtained semantic relatedness measures for the term  X  X awa X . 4.1.3 Semantic Relations Extraction Obtaining semantic relatedness measures is a prior step towards deriving the actual semantic relation(s) that may hold between semantically related terms. To do this, we defined a list of lexico-syntactic patterns to derive synonymy, hypernymy and hy-ponymy relations. These types of relations can be automatically obtained by utilizing the Semantic Relation Extractor (SRE) function. For each pair of semantically related several search engines. As shown in Algorithm 1 below, for each pattern, the makeQuery function (Line 6) submits exact match queries including both terms. We considered both singular and plural forms of the terms. Patterns that include negation operators such as  X  X o T _missing is a(n) T _in  X  are excluded. For instance, to find the relation between the terms  X  X awa X  and  X  X sland X , we utilize the SRE function by sub-land X , which outputs 80,700 hits result, Q2 = X  X awa is a part of island X , which outputs 0 hits result, and Q3= X  X awa is same as island X , which outputs 0 hits result. patterns are suggested to be used to enrich the semantic network with the term  X  X awa X . 4.2 Returned Results Processing To process the returned results by individual search engines we utilize the query translation techniques explained in section 4.1. First, each returned result page is processed using the NLP steps. At this step, tokens of the result page are matched to the terms in the merged query semantic network. To do this, we employ the Jaro-Winkler distance function [16] which is a simple technique that measures the similar-semantic network. If the similarity measure is above than a threshold value v=0.92, then both strings are considered as equivalent. For example, if we have the term  X  X b-ject Oriented Programming X  in the query semantic network and the term  X  X b-ject_Oriented Programming X  in one of the result pages, then using the string distance that didn X  X  match the terms of the merged query semantic network, we utilize the ranked according to the similarity between the obtained set of its terms and the terms in the query semantic network. Finally, Multi-Search provides users with a decision-results and filter out those results that are not semantically related to his query. This section describes the experiments carried out to evaluate the performance of the proposed meta-search engine. All solutions are implemented in Java and experiments are performed on a PC with dual-core CPU (3000GHz) and 2 GB RAM. The operat-ing system is OpenSuse 11.1. The developed prototype operates on top of big search engines such as (Bing, Google, and Yahoo!). We carried out experiments using WordNet [13], OpenCyc [14], and Yago [17] ontologies. Additional experimentations through a focused study with the help of ten computer science students were carried out to see the significance of the developed system. 5.1 Experiments Using Query Samples queries (15 per domain) from different domains. We evaluated the precision of the proposed system by comparing human judgments to the automatically returned results when using a single ontology and multiple ontologies. As shown in Table 2, the preci-sion of using multiple ontologies is higher than using a single ontology. 5.2 Focused Study Experiments Phase 1: Multi-Search and the search engines that ar e used in the prototype are dis-guised so that the users don X  X  not know which one is  X  Multi-Search  X . Several queries were pre-defined and submitted to these search engines. The interviewees were asked to show which one gives the most relevant results. Among the queries that were given are:  X  X ava Beverage X ,  X  X lood Pressure Vital Sign X  and  X  X ree plant X .
 Phase 2: Given the following scenario, the user has to provide the query: Let X  X  say you are looking for information about states in the world, you type  X  X tate X  as your query, but the search engines went off by mixing up your results with  X  X tate of mind X ,  X  X tate of health X ,  X  X tate to express X ,  X  X hemical state X , etc. How would you construct a query, so that it will give you, not the list of the states, but specific infor-mation about instances of state? The feedbacks from the 10 students were closely considered. Feedbacks were then compiled to gether to reflect how does the prototype perform. After the interviews, every interviewee had to answer a set of questions: 1. From scale 1 to 5 (1 = Worst, 5 = Best), how would you rate the results relevancy? 2. From scale 1 to 5 (1 = Worst, 5 = Best), how precise it defines the query semantics? 3. From scale 1 to 5 (1 = Worst, 5 = Best), how close it is in defining ambiguous term? 4. How many average links you had to click before you found the desired result? 5.3 Evaluation of the Study The study results are compiled and shown in Figure 4. For overall performance, the average rate that was given by the users is= 3.7 . As it is previously discussed in section results. However, some people were confused by the way queries are converted into semantic networks. One argument was that, in most cases, users think of search by submitting keywords instead of actual query semantics. 
From the table above, we can see that Bing and Multi-Search are favored among the other search engines. Although at this phase of experiments Bing was given high priority, Multi-Search is distinguished by the way it involves users in the search proc-ess as it provides them with a mechanism for filtering and ranking the results. Phase 2 Results: To narrow down the results, the interviewee usually added a word before and/or after the term  X  X tate X . For example:  X  X tate Country X ,  X  X ountry State X ,  X  X tate of  X  X NSTANCE_NAME X  X  like  X  X tate of Malaysia X  and  X  X tate of Mississippi X , etc. For this scenario, the students were not expecting the search engine to understand the meanings of the queries, but they were expecting that keywords of the queries would be exactly matched to their equivalent keywords in Web pages. The reason is because most conventional search engines search the web based on keywords match-ing. This approach has influenced the way people search for information over the internet. For instance, when searching for something, some people will put all the keywords that they think will appear in a web page. However, as Multi-Search com-bines ontology-based query translation and semantic relatedness measures, it was able to better understand queries by filling the  X  X emantic-gap X  between the meanings of keyword used to index WebPages and keywords used by the user. Therefore, in this case, Multi-Search was favored among the other search engines.
 In this paper, we proposed Multi-Search , a meta-search engine that employs knowl-edge represented by multiple ontologies and combines semantic and statistical based techniques to derive the semantic aspects of both the user query and the returned search results. Based on these semantic aspects, relevancy rates are given to the user so that he can filter and rank the results. In the developed prototype experimentations were done with the help of 10 computer science students and evaluations were carried out based on the experimental results. Students agree that the prototype has success-fully considered semantics of the query instead of matching keywords. Some of the feedbacks that were given stated that the search engine is very useful for people who sure broader domain coverage and more precise query translation. In addition, instead of manually defining the lexico-syntactic patterns, we plan to use automatic pattern acquisition techniques. The benefits of using these techniques are (i) saving the time tions other than synonymy and hyponymy. 
