 XML has recently emerged as a standard for data representation and inter-change on the Internet [18, 1]. While providing syntactic flexibility, XML pro-vides little semantic content and as a result several papers have addressed the topic of how to improve the semantic expressiveness of XML. Among the most important of these approaches has been that of defining integrity constraints in XML [7, 6]. Several different classes of integrity constraints for XML have been defined including key constraints [6, 5], path constraints [8], and inclu-sion constraints [9, 17], and properties such as axiomatization and satisfiability have been investigated for these constraints. Following these, some other types of constraints such as functional dependencies [2, 4, 3, 15, 12, 16], multivalued de-pendencies (XMVDs) [14], axioms, and normal forms have also been investigated. Once such constraints have been defined, one important issue that arises is to develop efficient methods of checking an XML document for constraint satisfac-tion, which is the topic of this paper. In this paper we address the problem of developing an efficient algorithm for checking whether an XML document sat-isfies a set of XMVDs. The problem is addressed in several aspects. Firstly, we propose an algorithm that is based on a modification of the extensible hashing technique. Another key idea of the algorithm is an encryption technique which reduces the problem of checking XMVD satisfaction to the problem of checking MVD satisfaction. Secondly, we show that this algorithm scans a document only once and all the information required for XMVD checking can be extracted in this single scan, even when there are multiple XMVDs to be checked. At the same time, we show that the algorithm runs in linear time in relation to the number of tuple of the XML document. The number of tuples of a document is different (though related) to the size of the XML document and is the number of combinations (we call them tuples) of the path values involved in the XMVDs. In this section we review some preliminary definitions.
 Definition 2.1. Assume a countably infinite set E of element labels (tags), a countable infinite set A of attribute names and a symbol S indicating text. An XML tree is defined to be T =( V, lab, ele, att, val, v r ) where V is a finite set of nodes in T ; lab is a function from V to E  X  A  X  X  S } ; ele is a partial function from V to a sequence of V nodes such that for any v  X  V ,if ele ( v ) is defined then lab ( v )  X  E ; att is a partial function from V  X  A to V such that for any v  X  V and l  X  A ,if att ( v, l )= v the root of T and we define lab ( v r )= root . Since node identifiers are unique, a consequence of the definition of val is that if v 1  X  E and v 2  X  E and v 1 = v 2 ments of v . For any l  X  A ,if att ( v, l )= v 1 then v 1 is called an attribute of v . The set of ancestors of a node v , is denoted by Ancestor ( v ) and the parent node of v is denoted by parentV ( v ) where the suffix V means that the parent is a vertex (node).
 Definition 2.2 (path). A path is an expression of the form l 1 .  X  X  X  .l n , n  X  1, then endL ( p )= l n .
 root, root.Dept, root.Dept.Section, root.Dept.Section.Project, root.Section.Emp.S are all paths.
 Definition 2.3. Let p denote the path l 1 .  X  X  X  .l n and the function parentP ( p ) Two paths p and q are equal, denoted by p = q ,if p is a prefix of q and q is a prefix of p . The path p is said to be a strict prefix of q , denoted by p  X  q ,if p is a prefix of q and p = q . We also define the intersection of two paths p 1 and p , denoted by p 1  X  p 2 , to be the maximal common prefix of both paths. It is clear that the intersection of two paths is also a path.
 Definition 2.4. A path instance in an XML tree T is a sequence v 1 .  X  X  X  .v n v v = v i for all i, 1  X  i  X  n . The set of path instances over a path p in a tree T is denoted by instances ( p ).Foranode v ,weuse instnodes ( v ) to denote all nodes of the path instance ended at v .
 Definition 2.5. A set P of paths is consistent if for any path p  X  P ,if p 1  X  p then p 1  X  P .
 generated from a DTD will be consistent. We now define the notion of an XML tree conforming to a set of paths P .
 Definition 2.6. An XML tree T is said to conform to a set P of paths if every path instance in T is a path instance over a path in P .
 Definition 2.7. Let P be a consistent set of paths, let T be an XML tree that conforms to P . Then T is defined to be complete if whenever there exist paths p 1 and p 2 in P such that p 1 p 2 in T such that v 1 . root.Dept.Section.Emp, root.Dept.Section.Project } then the tree in Figure 1 conforms to P and is complete.
 p in T .
 Definition 2.8. Let P be a consistent set of paths, let T be an XML tree that conforms to P . The function endnodes ( p ), where p  X  P , is the set of nodes defined by endnodes ( p )= { v | v 1 .  X  X  X  .v n  X  instances ( p )  X  v = v n } . under a given node. It is a restriction to endnodes ( p ).
 Definition 2.9. Let P be a consistent set of paths, let T be an XML tree that conforms to P . The function branEndnodes ( v, p ) (meaning branch end nodes), where v  X  V and p  X  P , is the set of nodes in T defined by branEndnodes ( v, p )= { x | x  X  endnodes ( p )  X  v  X  instnodes ( x ) } { follows. We use the same symbol for both orderings but this causes no confusion as they are being applied to different sets.
 Definition 2.10. The partial ordering &gt; on the set of paths P is defined by p 1 &gt;p 2 if p 2 is a strict prefix of p 1 , where p 1 ordering &gt; on the set of nodes V in an XML tree T is defined by v 1 &gt;v 2 iff v In this section, we present the XMVD definition and then give two examples. Definition 3.1. Let P be a consistent set of paths and let T be an XML tree that conforms to P and is complete. An XMVD is a statement of the form p p (i) val ( v i n ) = val ( w i n ); (ii) there exists a r j , 1  X  j  X  s, and two nodes z 1 ,z 2 , where z 1  X  (iii) for all p l , 1  X  l  X  k, there exists two nodes z 3 and z 4 , where then: x y x { v | v  X  X  w i { { w i 1 ,  X  X  X  ,w i n } X  v  X  instnodes ( endnodes ( p l  X  r j  X  q i )) } . ways defined and is a single node. Similarly for y i j ,x i j We also note that the definition of an XMVD is symmetrical, i.e. the p some examples.
 Example 3 1. Consider the XML tree shown in Figure 2 and the XMVD C : root.A.Course  X  X  X  root.A.B.Teacher.S | root.A.C.Text.S . Let v i 1 .  X  X  X  .v i n v and z 4 = v 1 then z 3  X  branEendnodes ( x 1 1 1 , root . A . Course ) and z 4  X  since the path instances are the same we have that x 1 1 = x 1 1 and x 1 1 1 = x 1 1 val ( z 2 ) and if we let z 3 = v 1 then z 3  X  branEndnodes ( x 1 1 and val ( z 3 )= val ( z 3 ). So part (a) of the definition of an XMVD is satisfied. z z 4 = v 1 then z 4 Hence part (b) on the definition of an XMVD is satisfied and so T satisfies the XMVD C .
 found in [14]. In this section, we present our algorithm for checking XMVD satisfaction. of paths i nvovled in the XMVD. To check this XMVD against a document, we firstly parse the document to extract values for s i , 1  X  i  X  n . These values are path s i . Finally, the tuples are used to check the satisfaction of the XMVD. For parsing a document, we need to define a control structure based on the paths involved. 4.1 Defining Parsing Control Structure We sort S = P  X  Q  X  R by using string sorting and denote the result by S o =[ s 1 , ..., s n ]. We call the set of end elements of the paths in S o prime end elements and denoted by PE , i.e., PE = { endL ( s ) | s  X  S } where endL () is defined in Definition 2.2. Note that S o being a list can simplify the calcu-lation of all the intersections of path in S o as shown below. Consider the ex-and PE = { B, E, F } .
 in S o where h i = s i  X  s j ,( i =1 ,  X  X  X  ,m ), j = i + 1 and m = n  X  1. We call the elements ending the paths in H intersection end elements and denote the set by IE . We call both intersection end elements and prime end elements key end elements and denote them by KE . In Figure 3, H = { r . A , r . A . C } , IE = { A, C } , KE = { A, C, B, E, F } .
 ements. Let iE be the intersection end element of a intersection path h ,i.e., iE = endL ( h ). The contributing elements of iE , denoted by CE ( iE ), are de-fined to be all key end elements of S o and H under h but not contributing elements of any other intersection end elements. To calculate the contributing elements, we first sort the paths in H by applying string sorting and put the contributing elements.
 Algorithm 4 1 (calculation of contributing elements) Inpput: S o =[ s 1 ,  X  X  X  ,s n ] and H o =[ h 1 ,  X  X  X  ,h m ] Do: For h = h m ,  X  X  X  ,h 1 in order, Output: CE ( endL ( h )) for all h  X  H o .
 CE ( C )= { E, F } and CE ( A )= { B, C } . 4.2 Parsing a Document We define the function val ( k ) to mean the value set of a key end element. Note that if k is a prime end element, val ( k ) will be accumulated if there are multiple presences of the same elements under a same node. If k is an intersection end value sets of contributing elements of k . We call each element of the production a tuple . Obviously, val ( k ) changes as the parsing progresses. We now show some examples of val ( k ) w.r.t Figure 3. When parsing reaches tag &lt; C &gt; in Line 3, &lt;  X  e 2 X  ,  X  f 2 X  &gt; } .
 refer to the element currently at the top of the stack. For simplicity, we define e  X  X , where e is an element and X is a path set, to be true if there exists a path x  X  X such that endL ( x )= e . With all these definitions, we present the algorithm that parses a document. Also for simplicity, we use val ( h ) to mean val ( endL ( h )) where h is a path.
 Algorithm 4 2 (parsing documents) Inpput: S o , H o , CE , PE , an empty stk , and a document
Do: Foreach element e in the document in the order of presence
Output: val ( h 1 ) where h 1 is the first element in H o -the Note that the algorithm scans the document only once and all tuples are gener-ated for the XMVD.
 structure group. If there are multiple XMVDs to be checked at the same time, we create a structure group for each XMVD. During document parsing, for each element e read from the document, the above algorithm is applied to all structure groups. This means for checking multiple XMVDs, the same document is still scanned once. 4.3 Tuple Attribute Shifting and XMVD Checking For each tuple t in val ( h 1 ), where h 1 is the first element in H o -the shortest intersection path, it contains a value for each paths of the XMVD, but the values are in the order of their presence in the document. This order is different from the order of paths in the XMVD. For example in Figure 3, the tuple &lt; rearrange the order of values of t so that the values for the paths in P are moved to the beginning of t , the values for the paths in Q are moved to the middle of t , and the values for the paths in R are at the end of t . The shif tAttr () shif tAttr ( val ( h 1 )).
 tuples in T sa and we denote the returned set as T dist . Thus, the following algo-rithm checks whether an XML document satisfies an XMVD and this algorithm is one of the main results of our proposal. The basic idea of checking is to group all the tuples for the XMVD so that tuples with the same P value is put into one group. In each group, the number of distinct Q values, | Q | , and the number of ber of distinct tuples in the group, the group satisfies the XMVD; otherwise, it violates the XMVD. If all the groups satisfy the XMVD, the document satisfies the XMVD.
 Algorithm 4 3 (checking mvd) Do: violated =0 Output: if ( violated == 0 ) return TRUE; otherwise return FLASE.
 same P value. To satisfy this assumption, one has to group tuples in T dist so that tuples with the same P value can be put together. A quick solution to this is not direct as show in the next section and therefore the way of achieving the assumption greatly affects the performance of whole checking algorithm. In this section, we present the performance results of our tests using an adapted hashing implementation. The tests were done on a Pentium 4 computer with 398 MB of main memory. The tests used XMVDs involving 12 paths, 9 paths, 6 paths, and 3 paths respectively. The XML documents used in the tests have random string values of about 15 characters for each path. This means that if there are three paths involved in an XMVD, the length of a tuple is about 45 characters while if there are twelve paths in an XMVD, the length of a tuple is around 180 characters.
 value are grouped together. At the same time, in each group, the number of distinct Q values and the number of distinct R values need to be calculated. To obtain these numbers, we choose to use an adapted hashing technique which is based on the standard extensible hashing [11]. In the standard extensible hashing technique, each object to be hashed has a distinct key value. By using a hash function, the key value is mapped to an index to a pointer, pointing to a fixed size basket, in a pointer directory . The object with the key value will then be put into the pointed basket. Every time a basket becomes full, the directory space is doubled and the full basket is split into two. In our implementation, we use the digests, integers converted from strings, of P values of tuples as the key values of the standard extensible hashing. Our modification to the standard extensible hashing technique is the following.
 not fixed. We allow only the tuples with the same key value to be put into a basket. We call the key value of the tuples in the basket the basket key . Tuples with different keys are said conflicting. If placing a tuple into an existing basket causes a conflict, a new basket is created and the conflicting tuple is put into the new basket. At the same time, the directory is doubled and new hash codes are calculated for both the existing basket key and the new basket key. The doubling process continues until the two hash codes are different. Then the existing and the new baskets are connected to the pointers indexed by the corresponding hash codes in the directory.
 space doubling, a basket may be referenced by multiple pointers. In the diagram, p stands for the basket key, the three spaces on the right of p are lists storing distinct Q values, distinct R values and distinct Q and R combinations. On top of the lists, three counters are defined. nq stands for the number of distinct Q values, nr the number of distinct R values and nqr the number of distinct Q and R combinations. After hashing is completed, the three counters are used to check the XMVD as required by Algorithm 43. When a new tuple t = &lt; p,q,r &gt; , where p, q and r are values for P, Q and R respectively, with the same p value is inserted to a basket, q is checked against all existing values to see if it equals to one of them. If yes, the q value is ignored; otherwise, the q value is appended to the end of the list and the counter is stepped. Similar processes are applied to insert r and the combination &lt;q,r&gt; .
 hash codes to find baskets for tuples is linear in relation to the number of tuples. When a tuple t = &lt; p,q,r &gt; is put into a basket that has already has tuples, then comparisons are needed to see if q , r and the combination &lt;q,r&gt; are already in the lists. The performance of the comparison relates to the number of distinct existing values. Generally, if we need to put n values into a list that has had m distinct values, then the performance is O ( n  X  m ) comparisons. implementation and the results are given in Figure 5. In this experiment we plotted the time taken for checking XMVD satisfaction against the number of tuples in the document, for varying numbers of paths in the XMVD (we used 6, 9, and 12). In the cases of 3 paths and 6 paths, we see that the former has a higher cost. This can be explained because the overall performance contains the time for parsing documents. To have the same number of tuples in the cases of 3 paths and 6 paths, the 3 path case has a much larger file size, about 70 times of that of 6 paths and therefore the parsing time used is much larger in contrast to that of 6 path case. It is the parsing time that makes performance for 3 paths worse than that for 9 or 12 paths.
 the performance of this hashing based approach. The result of the sorting im-plementation and its comparison with the hashing based approach are given in the full version of this paper [10]. In this paper we have addressed the problem of developing an efficient algorithm for checking the satisfaction of XMVDs, a new type of XML constraint that has recently been introduced [13, 14]. We have developed an extensible hash based algorithm that requires only one scan of the XML document to check XMVDs. At the same time its running time is linear in the size of the application which is proved to be the number of tuples. The algorithm can check not only the cases where there is only one XMVD, but also the cases involving multiple XMVDs.
