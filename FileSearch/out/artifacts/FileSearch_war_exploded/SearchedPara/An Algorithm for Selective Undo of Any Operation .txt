 Selective undo allows users to undo any operation in the his-tory and is considered a key feature in collaborative appli-cations. Operational transformation (OT) is a powerful tool for implementing selective undo because it can be used to re-arrange operations in a history in arbitrary orders. Despite the significant progress over the past two decades, however, there is still a space for improvements. Most existing works take time quadratic or even exponential in the size of the operation history H to undo an operation. Although this might be acceptable for real-time collaboration, it would be suboptimal in mobile and asynchronous collaborative appli-cations in which a long history may accumulate. In addi-tion, it is important to prove an algorithm with regard to the correctness criteria it assumes. This paper proposes a novel OT-based algorithm that provides integrated do and selective undo. The algorithm achieves time complexity of O ( | H | ) in both do and undo by keeping the history in a spe-cial operation effects relation order. Its correctness is for-mally proved with regard to formalized, provable conditions that are extended from a recent theoretical framework. C.2.4 [ Computer-Communication Networks ]: Distributed Systems X  Distributed applications ; H.5.3 [ Information In-terfaces and Presentation ]: Group and Organization Interfaces  X  Collaborative computing Algorithms, Theory The work is supported in part by National Natural Science Foundation of China under G rant No. 60736020, National Grand Fundamental Research 973 Program of China under Grant No. 2005CB321905, Shanghai Science &amp; Technology Committee Key Fundamental Research Project under Grant No. 08JC1402700 and Shanghai Leading Academic Disci-pline Project unde r Grant No. B114. Bin Shao is currently with Microsoft Research Asia.
Undo is a key feature in interactive applications. Many fa-miliar single-user applications, including text editors, word processors, design tools and even Web browsers, allow the user to undo operations in a chronological order. Undo is often used for user-level error recovery, e.g., to fix typos. It can also encourage users to explore unfamiliar capabili-ties in an application provided that the effects of erroneous operations can always be undone.

In collaborative applications, undo is significantly more challenging [9, 2, 14]. When the users are distributed and work in parallel, local and remote operations could be in-terleaved arbitrarily due to concurrency. A user request to undo could mean to undo a local operation or a remote op-eration. To undo a remote operation is even trickier because there can be multiple operations by several remote users and it is important to unambiguously specify which operation by which user. Otherwise, the undo action could be inter-preted arbitrarily at different sites, leading to unpredictable consequences in the system. Therefore, in a distributed en-vironment, it becomes necessary to support selective undo at the algorithm level, i.e., to undo the effects of any selected operations in the history.

Operational transformation (OT) [3, 15] is an optimistic consistency control technique that lies in the heart of many modern collaborative applications such as collaborative edit-ing systems 1 and Google Wave 2 . Those applications have gone far beyond the pure textual group editors in which OT was originated [3]. In particular, it has been shown that OT is a powerful tool for implementing selective undo [9, 14] mainly because it is able to transform any pair of op-erations to commute. This property makes it possible to remove the effects of any operations and rearrange the his-tory arbitrarily, e.g., to simulate any order of execution and explore numerous possible versions of the data under differ-ent permutations and combinations of operations.

Despite the great research progress in the topic of OT-based selective undo, e.g., [9, 10, 14, 4, 18, 17], two im-portant issues deserve further investigation: First, how to make an undo solution efficient for real-time as well as non-realtime collaborative applications. For example, approaches in [9, 4] take time quadratic and that in [17] takes time expo-nential in the size of history H to undo an operation. There is a room for improvement when | H | grows long, e.g., in mo-bile and asynchronous settings in which the collaborators often have to work in isolation before sync [12]. Secondly, http://www.ntu.edu.sg/home/czsun/ http://www.waveprotocol.org/ how to formally prove the correctness of an undo solution with regard to certain conditions if they are assumed in the solution. For example, the so-called transformation proper-ties TP1/TP2 [9, 11] are assumed in many OT works as con-ditions for achieving convergence, and most OT algorithms are developed under the framework of [16] which includes a condition called intention preservation.

In this paper we propose an alternative OT-based algo-rithm with integrated support for do and selective undo. This work makes the following two major contributions: 1. It can do as well as undo any operation in O ( | H | )time. 2. It is based on formalized conditions and its correctness
This work builds on a recent theoretical framework in this area, Admissibility-Based Transformation or ABT [6]. Originally, ABT is proposed for developing and proving OT-based do algorithms. It includes two formalized conditions, causality and admissibility preservation, which together im-ply convergence. Conceptually, admissibility means (1) that the invocation of any operation does not violate the relative position of objects that has been established by admissible operations invoked earlier, and (2) that every operation is admissible when it is generated.

This paper will extend the a dmissibility t heory to undo and give a new algorithm (called ABT-Undo or ABTU) with integrated support of do and selective undo. The correctness of ABTU will be formally proved. Furthermore, the relative position (called the operation effects relation  X  ) is utilized to keep operations in the history H in  X  order so as to achieve O ( | H | ) time of both do and undo. Note, however, that our work does not need an extra step to order the history.
The rest of this paper is organized as follows: Section 2 will first explain the basic ideas of OT. Section 3 surveys related previous works. Section 4 discusses the consistency model and Section 5 presents the ABTU algorithm. Sec-tion 6 proves and analyzes ABTU. Section 7 concludes.
To explain the basic ideas of OT-based do and selective undo, consider the scenario as shown in Figure 1. Suppose that two users, Alice and Bob, are collaboratively editing a shared document with an initial string  X  X  X . The data is replicated at both sites so that the users can work in parallel. Following the conventions [3], we model the shared data as a linear string of characters (or atomic objects). Let the position of the first object be zero. Alice changes her data to  X  X b X  by operation o 1 = ins (0,a). Concurrently, Bob changes his data to  X  X c X  by operation o 2 = ins (1,c).

When Alice receives o 2 ,if o 2 were executed as-is, her doc-ument would become  X  X cb X , which would violate the original intention of o 2 to insert  X  X  X  after  X  X  X  [16]. The basic idea of OT [3] is to transform o 2 (i.e., to shift its position) into an appropriate form that can be correctly executed in current document state. Here we should transform o 2 to a new form o = ins (2,c) to account for the effect of o 1 that is concurrent to o 2 and has been executed earlier. However, when Bob receives o 1 , o 1 can be executed as-is because the execution of o 2 does not invalidate o 1  X  X  position.

Now the two sites converge in state  X  X bc X . Then, Al-ice issues o 3 = del (0,a). After o 3 is executed, Bob issues o = del (0,b). The states at both sites become  X  X  X . Figure 1: A scenario of OT-based do and undo: Op-erations can be invoked in any orders and any oper-ations in the history can be selected for undo.

At this point, the history of Alice is [ o 1 ,o 2 ,o 3 ,o undoes her last step o 3 by operation o 5 to restore object  X  X  X , and concurrently Bob selectively undoes his last step o by operation o 6 to restore object  X  X  X . The states of the two sites become  X  X c X  and  X  X c X , respectively. Note that the two undo operations, o 5 and o 6 , are concurrent and defined on the same document state  X  X  X .

In general, we cannot disregard the inherent dependency between an undo and its corresponding do operation. Oth-erwise, e.g., in this scenario, if we naively interpreted o o 6 as to insert two new objects  X  X  X  and  X  X  X , respectively, it would be equally possible to get either result,  X  X bc X  or  X  X ac X , depending on the tie-breaking policies. However, if we knew that the intentions of the two undo operations are to restore objects originally in state  X  X bc X , the correct result would be  X  X bc X  without ambiguity.

Therefore, the problem of providing an integrated do/undo solution is manifold: (1) what the correctness criteria are, (2) how to design the algorithm and prove its correctness, and (3) how to scale the algorithm with the size of the his-tory. We will address these three issues in ABTU.
The topic of undo and recovery has been well studied in databases with the main purpose to maintain the ACID properties of transactions. In traditional distributed sys-tems, convergence is usually the key constraint to satisfy. In the literature of interactive and collaborative applications, many undo approaches are proposed that are not based on OT, e.g., [1, 2]. Those works usually consider read/write op-erations and an approach is correct as long as it converges, e.g., by finding a serializable schedule of operations.
OT-based works in general consider two primitives, insert and delete, in place of writes, to avoid overwriting of inter-action results. Any pair of operations can be transformed to commute and operations can execute in arbitrary orders at different sites. As a lock-free, nonblocking optimistic tech-nique, OT trades consistency for local responsiveness and extra constraints are imposed on convergence, such as in-tention preservation [16] and the effects relation [5, 6].
Traditionally, most OT works focus on supporting do, e.g., [3, 16, 15, 11, 13, 5, 6, 12]. Here we focus on OT-based selective undo. We first survey related previous works and then summarize the novel contributions in this work. [Prakash and Knister 1994] DistEdit [9] is the first OT-based selective undo solution. To selectively undo oper-ation o in the history H ,itfirsttransposes o to the end of H and generates its inverse o .Then o is executed and appended to H as normal. An operation o cannot be undone if it can-not be transposed with some operation executed later. This happens when the two operations are considered as conflict-ing, i.e., their effect objects are in adjacent or overlapping positions. Because DistEdit needs to recursively remove the do-undo pairs in H that affect this conflict detection, its time complexity is O ( | H | 2 ). [Ressel et al. 1999] adOPTed [10] only supports undo of local operations in chronological order. They interpret undo( o )asaninverse o generated in the state immediately after executing its original operation o , concurrent with all operations executed after o in the history. To undo the last local operation o in history H , it first generates its in-verse o andthentransposes o to the end of H .Afterthat, o is executed in current state as normal and appended to H . Their work achieves convergence by assuming that the transformation functions satisfy two transformation proper-ties (known as TP1 and TP2 [9, 11]). However, this is not really achieved, due to a counterexample given in [16]. [Ferri  X  e et al. 2004] The approach in [4] supports selec-tive undo while resembling [10] in its interpretation of undo. Their transformation functions are based on SOCT2 [13], in which TP2 is assumed but not really satisfied due to a counterexample given in [8]. Because they transpose H to extract concurrent operations when processing an operation, both do and undo take O ( | H | 2 )time. [Weiss et al. 2008] The selective undo approach of UNO [18] resembles that of [4]. Their transformation functions are based on TTF [7]. The time complexity of UNO is claimed as linear in the size of the shared document. The convergence of UNO also relies on TP1 and TP2. For verification they resort to theorem prover. Its correctness also relies on the intention preservation condition, which is specified similarly as in [5] yet not formally proved. [Sun et al. 2009] Both GOTO [14] and COT [17] sup-ports integrated do and selective undo. They also interpret undo as concurrent inverse as in [10] except that they cou-ple o and o such that a do-undo pair behaves as an identity operation during transformation. They only mark the orig-inal operation o , without saving its inverse o in the history. In COT [17], they propose a new context relation theory to model the special relations between normal operations, inverse operations, and their transformed forms.

By their own analyses [17], the time complexity for undo in both GOTO and COT is exponential in the size of H . The time complexity for do in GOTO is exponential in the size of H ; COT achieves a time complexity of O ( | H | )fordo by a buffering scheme which saves up to N versions of every operation, where N is the number of sites.

Comparisons: Early works [9, 10] do not support full-featured selective undo. Works in [11, 4, 18, 14] assume TP1/TP2, which results in transformation functions that are often intricate and difficult to develop formal proofs. Moreover, [4, 18] and [14, 17] are developed under the frame-work of [16] with three conditions, namely, convergence, causality and intention preservation. To our best knowl-edge, COT [17] is the latest work in selective undo.
ABTU is based on formalized conditions and its correct-ness is formally proved. The two formal conditions, causality and admissibility preservation, together imply convergence [6]. Hence it no longer needs to assume TP1/TP2 for con-vergence. When processing undo( o ), we treat o as one that happens after all operations in H yet contextually equiva-lent with all those in H that are ordered after o . As will be explained in Section 5.5, we can flexibly interpret the semantics of undo similarly as in either [9] or [10].
ABTU provides integrated support for do and selective undo, with the following unique properties: (1) operations in history H are kept in the order of their relative position, i.e., the effects relation  X  ; (2) operations with the same effect objects are ordered by their happens-before relation, e.g., o immediately follows o in the history; (3) its space complexity is O ( | H | ) and, due to the  X  order of H ,thetime complexity of both do and undo is O ( | H | ). Note that ABTU keeps all operations in one history whereas previous works [6, 12] keep insert/delete operations in separate histories.
We will first explicate some general guidelines for pro-viding integrated support of do and undo. Then we will formalize the correctness criteria.
Due to concurrency, undo is more challenging in a collab-orative application than in a single-user application. The following principles have been used implicitly or explicitly in previous works, e.g., [1, 9, 2, 14]. We also adopt them as guidelines in our work without making novelty claims: (a) Undo is an operation that can also be undone. (b) An operation can be undone exactly once. (c) Given any operation o , if there are operations that (d) The effects of undo operations should be consistent
Now, we discuss why these principles are relevant. (a) Like normal operations, an undo is just a request from the user to achieve certain effect, i.e., to remove the effect produced by some action requested by this or another user earlier. Not surprisingly, the undo action is also subject to a later undo request, i.e., to redo the original operation. (b) The effect of any operation o cannot be undone more than once. In a collaborative environment, multiple users may concurrently request to undo the effect of the same op-eration. For example, after one user inserts a object, several other users request to undo the insertion. In this case, only one undo request should be honored. Otherwise, if the in-verse (delete) operation were executed multiple times, some other objects could be deleted by mistake. This would vio-late the intention of undo, i.e., to restore the data to some state as if o had never been executed. (c) Undo as a user operation is to restore the data to a previous state. Often another normal do operation may well serve the same purpose. For example, after o 1 inserts an object  X  X  X , to remove this effect, we may choose to either undo o 1 by operation o 2 or just delete  X  X  X  by operation o The latter case can be considered as a type of implicit undo . Either operation, o 2 or o 3 , depends on the effect of o either one is executed, any later request to undo o 1 should be ignored. This is compatible with principle (b). (d) For any do/undo operation o , undo( o ) not only hap-pens after o but also inherently depends on the effect of o . Hence we cannot look at undo( o ) naively as a new do op-eration to execute o ,theinverseof o . The effect of o must be somehow correlated to that of o . In other words, the ef-fects of the undo operations must be consistent with those of their corresponding do operations. The question is how to formulate the notion of  X  X onsistency X  in this context.
We will formalize two consistency (or correctness) crite-ria, namely, causality and admissibility preservation, for for-mally proving algorithms that provide integrated support of do and undo. These two conditions are first proposed in the ABT framework [6] which only treats do operations. Here we extend them to treat both do and undo. Note, how-ever, that for space reasons here we only explain the part for undo that is not presented in [6]. We say that an in-tegrated do/undo solution is correct (or consistent) if these two conditions are always satisfied.

Following established notations [3, 15], for any two opera-tions o 1 and o 2 , their temporal relation is denoted as o if o 1 happens before o 2 ; or it is denoted as o 1 o 2 if they are concurrent, i.e., neither o 1  X  o 2 nor o 2  X  o 1 .
Definition 4.1. Causality Preservation : Given any two (do/undo) operations, o 1 and o 2 ,if o 1  X  o 2 ,then o is invoked before o 2 at any site in the system.

The condition of causality preservation is compatible with the above principles (a)-(c). Since undo is treated as a nor-mal operation by principle (a), it must observe the cause-effect relation. Further, the concurrent and dependency relation in principles (b) and (c) are easy to detect if the happens-before relation is observed in the system.
Definition 4.2. Admissibility Preservation :Thein-vocation of any (do/undo) operation does not violate the ef-fects relation  X  that has been established in the system.
According to [5, 6], objects that ever appear in the same (linear) document state can be totally ordered by their rela-tive positions. Consistently with this total order, operations can also be totally ordered by the relation of the objects they insert or delete. We use notation  X  to denote this total order and the operation relation (called effects relation ). The core notion of effects relation  X  has been formally elab-orated in [6]. Intuitively, the admissibility condition can be restated as follows: an invocation of any operation is admis-sible if it does not violate the effects relation established by other admissible invocations in the system; and any oper-ation is admissible when it is generated. It is proved that these two conditions, causality and admissibility preserva-tion, together imply convergence [6]. That is, after all oper-ations are invoked at all sites, the data replicas will converge with all objects in the order of the effects relation  X  .
Here we use an example to explain the concepts here, as illustrated in the scenario in Figure 2. We focus on concep-tually explaining what the X  X orrect X  X esults must be, without involving any specific do/undo algorithms.

Suppose that the three sites start from the same initial state  X  X b X . The left site issues operations o 1 and o 2 to delete the objects  X  X  X  and  X  X  X , respectively. Concurrently, the mid-dle site issues o 4 to insert  X  X  X  after  X  X b X . After these three Figure 2: A scenario to illustrate the effects relation  X  and admissibility. dle site must be  X  X  X . Consider that concurrently the right site issues o 6 to insert  X  X  X  before  X  X b X . When o 6 is invoked at the middle site, since its current state is  X  X  X , the result could be either  X  X y X  or  X  X x X , depending on the specific algorithm and its tie-breaking policies.

Using the notion of effects relation, the initial relation is a  X  b .When o 4 is generated, it becomes a  X  b  X  x .And when o 6 is generated, it is y  X  a  X  b . By transitivity, it must be y  X  a  X  b  X  x .Operations o 1 and o 2 are to delete objects that are already there and should not change the effects relation. Hence the state of the middle site must be  X  X x X  without ambiguity after invoking o 4 , o 1 , o 2 and o Furthermore, after undo operations o 5 and o 3 are invoked to restore the deleted objects  X  X  X  and  X  X  X , respectively, its state must be  X  X abx X  without ambiguity according to the effects relation. Note that the effects relation is determined when operations are generated and hence inherent.
We will first overview the algorithm structure, introduce some basic notations and transformation functions, and then discuss involved functions. As will be shown, the entire algo-rithm is specified in four functions. Our approach maintains ahistory H at each site, operations in which are kept in the effects relation order. Undo X  X  are treated similarly as do X  X  and correlated with the effects of their corresponding do X  X . ABTU allows for selective undo of any operation in H . When an undo command is issued by a user (in context of current local history H ), we denote the command as undo ( i ) which means to undo H [ i ], or the i -th operation in H .
On top of our selective undo algorithm, more intuitive in-terfaces can be provided for human users to pick the right operations to undo, e.g., as in [1]. For example, the history can be visualized to help users understand the implications of operations; a user is allowed to undo operations in chrono-logical order, either the last local operation or the last oper-ation executed locally; or the user can choose operations to undo by their positions in the document, as in Emacs. It is always possible to translate commands in those approaches into an undo ( i ) command relative to our history H .Inany approach, once the id of the target operation o is known, we just need to compare the operation ids to locate the right H [ i ], with overheads no more than O ( | H | ).
 In our algorithm, two threads run at every site, namely, Thread L and Thread R , which processes local and remote operations, respectively. Any (do/undo) operation gener-ated by a user is first executed at local site and recorded in the local history by Thread L before it is propagated to remote sites. When a remote operation is received, it is first appended to a receiving buffer RB .Thread R each time processes one (do/undo) operation o from RB that is causally-ready, i.e., all operations that happen before o have already been executed at current site. Every executed oper-ation is added into H by the effects relation order. There is no extra step or cost to reorder H in our algorithm.
For the purposes of this paper, we assume that all oper-ations are eventually received and processed at every site; and all sites start from the same version of the shared data.
Each site is assigned a unique id and maintains a state vector sv with N elements, where N is the number of sites in the system. Each element in sv is an integer that is initialized to zero. As will be shown, at each site, Threads and R advance sv when executing operations, and Thread L timestamps new operations by sv .

We define two primitives, ins ( p, c )and del ( p, c ), which insert and delete object c at position p , respectively. Each operation o is a nine-tuple (id, t, p, c, v, dv, tv, ov, uv) with the following properties: o.id is the id of the site that gen-erates o ; o.t is the operation type, either ins or del ; o.p is the position at which o is applied; o.c is the object that o inserts or deletes (also called the effect object); the other five properties are timestamps explained as follows:
We use these timestamps to denote the correlation be-tween operations. For example, if o undoes operation o , then o.uv = o .v and o .ov = o.v ; meanwhile, o is stored right after o , their effect objects tie, and o .tv = o.v ;if o deletes the object o inserts, o .dv = o.v . If multiple opera-tions delete the same object or they undo the same opera-tion, they will be combined into one operation o in H and o.v is a set of timestamps of those operations.

Besides the two primitives ins ( p, c )and del ( p, c ), we define aspecial do-nothing operation or identity operation , denoted as  X  . The document state remains as-is after executing the operation  X  on any document state.

Based on our notations, we adapt the established happens-before relation  X  and concurrent relation as follows. Given any two operations o 1 and o 2 ,if  X  vt 1  X  o 1 .v and  X  vt such that vt 1 &lt;vt 2 , 3 then o 1  X  o 2 . If neither o o  X  o 1 ,then o 1 o 2 .

Due to [16], o.p is always defined relative to some state s . The state obtained by applying o to state s is denoted vt 1 &lt;vt 2 iff  X  i : vt 1 [ i ]  X  vt 2 [ i ]and  X  j : vt as s  X  o . Given any two operations o 1 and o 2 ,if dst ( o dst ( o 2 ), we say that o 1 and o 2 are contextually equiva-lent , denoted as o 1 o 2 ;if dst ( o 1 )= s and dst ( o 2 we say that o 1 and o 2 are contextually serialized ,de-noted as o 1  X  o 2 . If two contextually serialized operations are ordered by their effects relation , then we say that the two operations are in effects relation order .

A list of operations, [ o 1 ,o 2 ,...,o n ], is a sequence if o o  X  ...  X  o n . Notation s  X  L denotes the state obtained by applying sequence L to state s ,where L is defined in state s or dst ( L )= s .Givenanytwosequences L 1 and L 2 ,where dst ( L 1 )= dst ( L 2 )= s or L 1 L 2 ,if s  X  L 1 = s  X  L L 2 are effects-equivalent , denoted as L 1
We use o to denote the inverse of operation o .Weinterpret the semantics of o as o  X  o , o.t = o.t and o.p = o.p .Inthe if o = del ( p, c ), then o = ins ( p, c ).
In the literature (e.g., [15, 6]), the following three trans-formation functions, IT , ET and SWAP are often defined.
Inclusion Transformation ( IT ): Given two operations o 1 and o 2 that satisfy o 1 o 2 , IT ( o 1 ,o 2 ) transforms o such that o 2  X  o 1 , incorporating the effect of o 2 into o if o 1 and o 2 are defined in the same document state, then o = IT ( o 1 ,o 2 )= del (4 ,x ).

Exclusion Transformation ( ET ): Given two operation o 1 and o 2 that satisfy o 1  X  o 2 , ET ( o 1 ,o 2 ) transforms o o 2 such that o 1 o 2 , excluding the effect of o 1 from o 2 For example, after serially executing two operations o 1 =
Swap Transformatioin ( SWAP ): Given two operations o 1 and o 2 that satisfy o 1  X  o 2 , SWAP ( o 1 ,o 2 ) transforms o and o 2 into o 1 and o 2 such that o 2  X  o 1 . SWAP exchanges the execution order of two operations while preserving their effects. For example, given two serially executed operations o = del (1 ,x )and o 2 = ins (3 ,y ), then o 1 = del (1 ,x ) while o = ins (4 ,y )after SWAP ( o 1 ,o 2 ).

Conceptually, SWAP( o 1 ,o 2 ) is equivalent to first doing o =ET( o 1 ,o 2 )andthen o 1 =IT( o 1 ,o 2 ). As will be shown, we mainly use SWAP and the usage is implicit, i.e., we do not call the SWAP function explicitly. We can do so because we keep operations in the effects relation order. As in the above example for SWAP, for instance, if o 1  X  o 2 and o 1  X  o after exchanging their execution order by SWAP( o 1 ,o 2 ), o will remain as-is. That is, executing o 2 first does not affect the effect of o 1 . Generalizing this observation, we establish the following properties of SWAP without proofs.

P1 Given two operations o 1 and o 2 ,if o 1  X  o 2 and o 1
P2 Given two operations o 1 and o 2 ,if o 1  X  o 2 and o 2
P3 Given a non-empty sequence sq whose operations are
P4 Given any operation o and a non-empty sequence sq
In spirit of the effects relation  X  , we introduce three op-relation, which will simplify presentation and proofs of the algorithm. When all operations are ordered in the same his-tory, there are cases in which operations are effects-identical and must be handled differently from previous works [6, 12].
Operator &lt; e : Given any two operations o 1 and o 2 ,where o 1 o 2 ,wesay o 1 &lt; e o 2 if one of the following three con-ditions holds: (1) o 1 .p &lt; o 2 .p ;(2) o 1 .p = o 2 .p , o o .t = del ;or(3) o 1 .p = o 2 .p , o 1 .t = o 2 .t = ins , o o .id .Inthecaseof o 1  X  o 2 ,wesay o 1 &lt; e o 2 if one of the following two conditions holds: (1) o 1 .p &lt; o 2 .p ;or(2) o .p = o 2 .p , o 1 .t = o 2 .t = del .

Operator &gt; e is symmetric to operator &gt; e .Givenanytwo operations o 1 and o 2 ,where o 1 o 2 ,wesay o 1 &gt; e o the three conditions holds: (1) o 1 .p &gt; o 2 .p ;(2) o o .t = del , o 2 .t = ins ;or(3) o 1 .p = o 2 .p , o 1 .t = o o .id &gt; o 2 .id .Inthecaseof o 1  X  o 2 ,wesay o 1 &gt; e if one of the two conditions holds: (1) o 1 .p &gt; o 2 .p ;or(2) o .p = o 2 .p , o 1 .t = o 2 .t = ins .

Operator &lt; e determines the precedence relation between the effects of two operations. When o 1 .p &lt; o 2 .p ,either o or o 1  X  o 2 , o 1 .c must precede o 2 .c (or o 1 .c  X  o state after o 1 and o 2 are invoked.

When o 1 o 2 , o 1 .t = ins , o 2 .t = del and o 1 .p = o o .c  X  o 2 .c must hold because o 2 .c is an existing object in dst ( o 1 ). For example, let the common definition state be  X  X  X , o 1 = ins (0 ,y ), o 2 = del (0 ,x )and o 1 o 2 . Obviously, after executing o 1 , the state is  X  X x X , the effect object  X  X  X  of o precedes that of o 2 ( X  X  X ).

When o 1 o 2 , o 1 .p = o 2 .p and both o 1 and o 2 are inser-tions, they insert new objects that are not present in the definition state. In this case, we impose an order between them by some priority policy. In ABTU, if o 1 .id &lt; o 2 then o 1 .c will precede o 2 .c after both are invoked.
When o 1  X  o 2 , o 1 .t = o 2 .t = del and o 1 .p = o 2 .p ,the two operations delete at the same position in a row and hence o 1 .c  X  o 2 .c must hold. For example, consider state  X  X y X , in which a user first performs o 1 = del (0 ,x )andthen o 2 = del (0 ,y ). The relation o 1 .c  X  o 2 .c exists even before the two operations are invoked.

Operator = e : Given any two operations o 1 and o 2 ,we say o 1 = e o 2 if neither o 1 &lt; e o 2 nor o 2 &lt; e o o 1 = e o 2 if o 1 .p = o 2 .p and one of the two conditions holds: (1) o 1 o 2 , o 1 .t = o 2 .t = del ;or(2) o 1  X  o 2 , o
Condition (1) means that o 1 and o 2 (concurrently) delete the same object in a common definition state. They are effects-identical and neither o 1 &lt; e o 2 nor o 2 &lt;
The condition of o 1  X  o 2 and o 1 .t = o 2 .t covers three cases: (1) o 1 .t = ins , o 2 .t = del and both are normal opera-tions. In this case, o 2 deletes the object inserted by o o .t = del , o 2 .t = ins and both are normal operations. In this case, o 2 inserts a object at the same position where o deletes. Unless o 1 .c and o 2 .c appear in some state simulta-neously, their relation is neither o 1 &lt; e o 2 nor o 2 o 2 undoes o 1 or o 2 = o 1 .If o 1 .t = ins , it is similar to case (1); or if o 1 .t = del , it is similar to case (2).
Discussions: When any two operations are contextually equivalent or serialized, the above definitions cover all possi-ble cases. Otherwise, we design the algorithm such that any two operations can be transposed to be contextually equiv-alent or serialized. As a result, for any two operations in order the set of operations in the system. For any two opera-tions L [ i ]and L [ j ] in sequence L ,where i&lt;j ,if L [ i ] always holds, then we say that L is in ER (Effects Relation) order. This is how we order history H . Algorithm 1 Thread L : process local operation o at site k 1: if o is a normal operation then 2: o  X  o 3: sv [ k ]  X  sv [ k ]+1 4: o .v  X  sv 5: else // o = undo ( i ) 6: if H [ i ] .uv =  X  or H [ i ] .dv =  X  then 7: exit //undo request invalid 8: else 9: o  X  H [ i ] 10: sv [ k ]  X  sv [ k ]+1 11: o .v  X  sv 12: o .ov  X  H [ i ] .v 13: H [ i ] .uv  X  o .v 14: end if 15: end if 16: execute o 17: o  X  integrateL ( o ) 18: propagate o
In ABTU, any local operation o is either a normal (do) operation or an undo operation. In either case, Thread L is activated to process the submitted o ,asspecifiedinAlgo-rithm 1 in which site k is the local site.

If o is a normal operation, it is directly executed on the local data replica. The element in sv for site k is advanced to indicate that site k has executed a new operation. Then o is timestamped by sv . After being integrated into the local history H , o is propagated to remote sites. Procedure integrateL ( o ) adds o into H by the effects relation order.
On the other hand, if the submitted o is an undo oper-ation undo ( i ), we first check its original operation H [ i ]to see whether it has been undone or is depended on by other operations (line 6). If so, Thread L will abort this undo request. Otherwise, we generate the inverse of H [ i ], ad-vance sv , and timestamp the inverse o .Tokeeptrackof the do-undo relationship, o .ov is set to the timestamp of the original operation (line 12) and the uv property of the original operation H [ i ]issetto o .v (line 13). After that, o is processed as a normal operation, i.e., it is executed locally, integrated into H , and propagated to remote sites.
Note that the inverse o in our work can be interpreted either as in [9] or as in [10], which are followed in other works as analyzed in Section 3. This flexibility in our work comes from that our history is in the effects relation order.
Using the strategy in [9], we first transpose H [ i ]totheend of H and then generate the inverse in current state. Because H is ordered by the effects relation, by Property P3, after the transposition, H [ i ] remains as-is and the resulting inverse as defined in current state is just H [ i ].

Using the strategy in [10], we first generate the inverse o = H [ i ] that is contextually serialized after H [ i ]. Then o is considered as concurrent (or more accurately contex-tually equivalent) with all operations that follow H [ i ]in H . We could make o defined in current state by transforming o with those concurrent operations. Similarly, however, be-cause H is in effects relation order, those operations do not affect o during the transformation and consequently o re-mains as-is after the transformation. Hence the resulting inverse as defined in current state is also just H [ i ]. Algorithm 2 Thread R : remote operation o from site r 1: if o.ov =  X  then // o is undo 2: find H [ i ] such that H [ i ] .v  X  o.ov =  X  3: if ( H [ i ] .uv =  X  ) then 4: find H [ j ] such that H [ j ] .v  X  H [ i ] .uv =  X  5: H [ j ] .v  X  ( H [ j ] .v )  X  ( o.v ) 6: sv [ r ]  X  sv [ r ]+1 7: return 8: else 9: H [ i ] .uv  X  o.v 10: o.ov  X  o.ov  X  H [ i ] .v 11: end if 12: end if 13: o  X  integrateR ( o ) 14: sv [ r ]  X  sv [ r ]+1 15: if o =  X  then execute o When the system is not busy processing local operations, Thread R processes one causally-ready (do/undo) remote operation o at a time. If o.ov =  X  ,then o is an undo opera-tion. Otherwise, it is a normal (do) operation.

If o is a normal operation (lines 13-15), it will be pro-cessed by function integrateR ( o ): First, it transforms o to incorporate the effects of concurrent operations and obtain a resulting version of o that can be safely executed in current state. Second, it adds o to H by the effects relation. Af-ter the transformation, if the resulting o is not an identity operation  X  , it will be executed in current state.
If o is an undo operation, we first scan H to find the orig-inal operation H [ i ] such that H [ i ] .v  X  o.ov =  X  . Then, we check whether H [ i ] has been undone by other concurrent operations. If H [ i ] has already been undone, then we find its undo operation H [ j ] such that H [ j ] .v  X  H [ i ] .uv = combine timestamp o.v into the timestamp H [ j ] .v .Inthis case, o will not be really executed because the original oper-ation can only be undone once. However, the local sv is still advanced to acknowledge the fact that the effect of o has al-ready been reflected in the data replica of this site. On the other hand, if H [ i ] has not been undone yet, we set H [ i ] .uv to o.v and combine H [ i ] .v into o.ov .Then o is transformed and integrated into H similarly as a normal operation.
Algorithm 3 integrateL( o ) is called by Thread L to add anewlocaloperation o to H by the effects relation order. Note that when a local operation is generated in current statewehave H  X  o . There are two cases to consider: First, if o is a normal operation, then o.ov =  X  must hold. Since H  X  o ,weswap o with the operations in H from right to left until we find an operation H [ i ] such that H [ i ] the effect of o into H [ i ] (lines 5-7). If H [ i ] &lt; we must insert o right after H [ i ]. We break with current k carrying the target position.
 Algorithm 3 integrateL ( o ): o 1: o  X  o ; k  X  X  H | 2: offset  X  ( o .t = ins )?1 :  X  1 3: if o .ov =  X  then // o is a normal do operation 4: for ( i  X  X  H | X  1; i  X  0; i  X  X  X  ) do 5: if H [ i ] &gt; e o then 6: k  X  i 7: H [ i ] .p  X  H [ i ] .p +offset 8: else if H [ i ] &lt; e o then 9: break 10: else // H [ i ]= e o 11: o .tv  X  H [ i ] .v 12: if o .t = del then H [ i ] .dv  X  o .v 13: break 14: end if 15: end for 16: else // o is undo 17: find H [ i ] such that H [ i ] .v  X  o .ov =  X  18: o .tv  X  H [ i ] .v 19: k  X  i +1 20: for ( j  X  k ; j&lt; | H | ; j ++) do 21: H [ j ] .p  X  H [ j ] .p +offset 22: end for 23: end if 24: insert o into H at position k 25: return o
If H [ i ]= e o ,thepositionsof H [ i ]and o tie, we set o.tv to H [ i ] .v to flag this tie. Moreover, if o.t = del ,itmust be that o deletes the object inserted by H [ i ]. That is, o depends on H [ i ]. Hence we set H [ i ] .dv to o.v to indicate this dependency such that H [ i ] will not be undone.
Second, if o is an undo operation, we only need to find the target operation H [ i ] such that H [ i ] .v  X  o.ov =  X  .Thenwe these two operations have the same effect objects, we set o.tv to H [ i ] .v to flag this tie. Furthermore, to accommodate the effect of o , we shift the positions of all the operations in H after the target position k (lines 19-22).
Algorithm 4 integrateR( o ) is called by Thread R with dual purposes: the first is to transform o such that its resulting form o canbeexecutedincurrentstate;thesecondistoadd o at an appropriate position k in H such that the resulting H remains in the effects relation order. Consider two cases: (1) Case o.tv =  X  : There is no operation that happens before o and whose effect ties with that of o .

Since o is causally-ready, all operations that happen before o must have been included in H . Conceptually, as in [15, 13], we need to transpose H into two subsequences, sq h and sq c , that are contextually serialized, where all operations in sq h happen before o and all operations in sq c are concurrent with o .Then sq h  X  o and o sq c must hold. To serve the first purpose, o must be transformed with sq c .Toservethe second purpose of adding o into H by the effects relation order, we also have to examine operations in sq h .
The fact that H is in the effects relation order could sim-plify the algorithm. As analyzed in [12], because H is in the effects relation order, by Property P4, the above transposi-tion of H does not shift any operation in sq c at all. Here we achieve the two purposes without transposing H . Algorithm 4 integrateR ( o ): o 1: o  X  o ; k  X  X  H | 2: if o .tv =  X  then 3: for ( i  X  0; i&lt; | H | ; i ++) do 4: if H [ i ] o then 5: offset  X  ( H [ i ] .t = ins )?1 :  X  1 6: if H [ i ] .tv =  X  or H [ i ] &lt; e o then 7: o .p  X  o .p +offset 8: else if H [ i ] &gt; e o then 9: k  X  i ; break 10: else // H [ i ]= e o 11: o  X   X  12: H [ i ] .v  X  H [ i ] .v  X  o .v 13: break 14: end if 15: else if H [ i ] &gt; e o then // H [ i ]  X  o 16: k  X  i 17: break 18: end if 19: end for 20: else // o .tv =  X  , covering the undo case 21: find H [ i ] such that H [ i ] .v  X  o .tv =  X  22: o .p = H [ i ] .p ; k  X  i +1 23: while H [ k ] .tv  X  H [ i ] .v =  X  do // H [ k ]= e H [ i ] 24: if H [ k ] &lt; e o then 25: o .p  X  o .p +offset 26: else if H [ k ] &gt; e o then 27: break 28: else // H [ k ]= e o 29: o  X   X  30: H [ k ] .v  X  H [ k ] .v  X  o .v 31: break 32: end if 33: k  X  k +1 34: end while 35: end if 36: if o =  X  then 37: offset  X  ( o.t = ins )?1 :  X  1 38: for ( j  X  k ; j&lt; | H | ; j ++) do 39: H [ j ] .p  X  H [ j ] .p +offset 40: end for 41: insert o into H at position k 42: end if 43: return o
To explain the ideas, consider a history in ER order, H = [ h the initial state is s 0 and that o should be inserted between h 2 and h 3 . After transposition, the history becomes H = [ h 1 , h 2 , h 3 , c 1 , c 2 , c 3 ]and H o with [ c 1 , c 2 , c 3 ], let the result be o .Thendst( o )= s  X  [ h 1 ,h 2 ,h 3 ,c 1 ,c 2 ,c 3 ]. If now we transpose H back to H ,wehavedst( o )= s 0  X  [ h 1 , c 1 , c 2 , h 2 , h 3 , c H  X  = H .Thatis,wecantake H  X  o after transforming o with all concurrent operations. Also because H is ordered, by Property P3, transposing any h i to the end of H does not shift h i . However, after the transposition, the relation h  X  o holds. In other words, we can not only transform o with any c i but also compare any h i with o in place!
Back to the algorithm, first consider concurrent opera-effect of H [ i ]into o (line 7). Note the condition H [ i ] .tv = (line 6), which means that there exists some operation H [ j ], where j&lt;i , that has been examined (i.e., H [ j ] &lt; whose effect ties with H [ i ]. In this case, H [ j ] &lt; H [ j ]= e H [ i ] and hence H [ i ] &lt; e o holds implicitly.
Meanwhile, to serve the second purpose of keeping H in order, similarly to Algorithm 3, we scan H until some H [ i ] such that H [ i ]  X  e o .When o = e H [ i ], it must be that o and H [ i ]deletethesameobject;wetransform o into an identity operation  X  and combine H [ i ] .v with o.v .
Now consider operations that happen before o .Wescan H andthenadd o at position i . This suffices because we do not need to transform o with operations that happen before it, which means those with effects preceding o are simply skipped; and those with identical effects are handled in the case of o.tv =  X  (line 20). (2) Case o .tv =  X  : There must exist some H [ i ] such that H [ i ]  X  o and H [ i ]= e o , which covers undo operations. To keep the effects relation order, o is added right after H [ i ]. If we knew that there are no operations that are con-current with o and whose effects objects tie with that of H [ i ], we could just set o.p to H [ i ] .p and add o at position i + 1, as in line 22. Otherwise, we need to transform o with those operations (lines 23-34). Similarly to the steps in lines 3-19, we scan H until some H [ k ] such that H [ k ]  X  e o . When H [ k ]= e H [ i ], if o .t = ins ,itmustbethat o and H [ k ] concurrently insert at the same position where H [ i ] must be that H [ k ]and o concurrently delete the same effect object; o is combined into H [ k ] and an identity operation  X  is returned, which is not added to H nor executed. We first show how well-known undo puzzles are solved in ABTU, which also serve as examples. Then we will present formal proofs with regard to conditions formalized in Sec-tion 4. After that, we will analyze the complexities of ABTU. We consider four representative undo puzzles given in [14]:
Case 1: Given state  X  X  X , first execute o 1 = del (0 ,a )and o = ins (0 ,b ), where o 1  X  o 2 . Then undo o 1 .

After executing o 1 and o 2 , the history is H =[ o 1 , o [ del (0 ,a ), ins (0 ,b )], where o 1 = e o 2 .Theinverseof o o 1 = ins (0 ,a ). After executing o 1 , the state is  X  X b X . The history becomes [ del (0 ,a ), ins (0 ,a ), ins (1 ,b )].
Case 2: Given state X  X  X , invoke two concurrent operations o = del (0 ,a )and o 2 = ins (0 ,b ). Then undo o 1 .
Since o 1 o 2 and o 1 o 2 , o 2 &lt; e o 1 holds and the ef-fect object of o 2 should precede that of o 1 in the final re-sult. After executing o 1 and o 2 , the history is H =[ o =[ ins (0 ,b ) ,del (1 ,a )]. Undo o 1 is to execute its inverse ins (1 ,a ), resulting in state  X  X a X .

Case 3: Given state  X  X b X , first execute o 1 = del (0 ,a ) and o 2 = del (0 ,b ), where o 1  X  o 2 . Then undo o 1 and o concurrently, i.e., undo( o 1 ) undo( o 2 ).

The history is [ del (0 ,a ) ,del (0 ,b )] after executing o o . There are two cases depending on the undo order. 1) Undo( o 1 ) is executed before undo( o 2 ): Executing the del (1 ,b )]. Now undo o 2 by executing its inverse operation ins (1 ,b ). The state becomes  X  X b X  and the history [ del (0 ,a ), ins (0 ,a ), del (1 ,b ), ins (1 ,b )]. o3=undo(o1) o1=del(0,a)
Figure 3: An undo puzzle scenario for Case 4. 2) Undo( o 2 ) is executed before undo( o 1 ): After execut-ing the inverse of o 2 , ins (0 ,b ), we get state  X  X  X  and his-ins (0 ,a ), del (1 ,b ), ins (1 ,b )].

Case 4: Given state X  X  X , first invoke two concurrent oper-Then undo o 1 and/or o 2 .

A scenario of this case is illustrated in Figure 3. Take site 1 for example: After executing o 1 and o 3 , the state becomes ceiving o 2 , it is transformed into a  X  operation. The state When o 4 arrives, we find that its original operation o 2 already been undone. The state remains unchanged and cess at site 2 is similar and omitted. Therefore, undo o and/or o 2 yields a unique result  X  X  X  in our approach.
Note that we interpret undo effects not exactly the same as in [14, 10]. In case (4), they take o 1 and o 2 as two differ-ent operations, and the character  X  X  X  will be restored only if o 1 and o 2 are both undone. However, o 1 and o 2 are in-terpreted as the same operation in our correctness model and combined during the transformation. Hence  X  X  X  will be restored as long as o 1 and/or o 2 are undone. Theorem 6.1. ABTU satisfies Causality Preservation.
Proof. In ABTU, vector timestamps are used such that any remote operation o can be invoked by Thread R only if it is causally ready, that is, all operations that happen before o have been invoked.

Lemma 6.2. Given a history H that is in ER order and any local operation o that is generated in the context of H , suppose the history becomes H after Thread L invokes o . Then H  X  = H  X  o and H is in ER order.

Proof. First consider the case in which o is a normal operation. Algorithm 3 adds o into H by the effects relation order, say at position k . By the algorithm, o is always in-Hence, the resulting history H is in ER order.

Meanwhile, o is transposed with every operation in H from right to left until the target position k . By the algorithm, o&lt; e H [ j ]holdsforevery H [ j ] that is transposed with o . By Property P2, the position of o remains as-is while the position of H [ j ] is shifted. Because H  X  o ,eachtransposi-tion step is effects-equivalent. Hence, after the integration, H  X  = H  X  o .
 Next consider the case in which o is to undo operation Otherwise, it must be H [ i +1]= e H [ i ] and, by definition of = , H [ i +1] .t = del and H [ i +1] .p = H [ i ] .p ,whichmeans that H [ i ] has already been undone explicitly or implicitly. Then o would have aborted.

On the other hand, if H [ i ] .t = del , H [ i +1] &gt; e hold. Otherwise, if H [ i +1]= e H [ i ], then H [ i +1] .t = ins must hold. If H [ i + 1] were to undo H [ i ], then o would have aborted. If H [ i + 1] is just a normal insert operation, H  X  o and, by Property P3, H [ i + 1] remains as-is if it is transposed to the end of H . Then, the three conditions H [ i +1]  X  o , H [ i +1] .p = o.p and H [ i +1] .t = o.t = ins imply H [ i +1] &gt; e o by definition of &gt; e .
Therefore, when an undo operation o is integrated at po-sition k ,  X  i&lt;k : H [ i ]  X  e o and  X  j  X  k : H [ j ] &gt; Furthermore, Algorithm 3 shifts the positions of those op-erations after o in H to incorporate the effect of o .Hence, after the integration, H  X  = H  X  o .

Lemma 6.3. Given a history H that is in ER order and a remote operation o , suppose that the history is H after Thread R integrates o into H and transforms o into o .Then H  X  = H  X  o and H is in ER order.

Proof. Consider the following three cases: 1) o.tv =  X  and  X  H [ i ]: H [ i ]= e o . It must be that o and H [ i ] concurrently delete the same object, and o will be transformed into an identity operation  X  by Algorithm 4. In this case, o is combined into H [ i ]. The resulting H remains in ER order and H  X  = H  X  o because o =  X  . 2) o.tv =  X  and  X  H [ i ]: either H [ i ] &lt; e o or H [ i ] &gt; this case, o will be inserted at some position k such that  X  i&lt;k : H [ i ] &lt; e o and  X  j  X  k : H [ j ] &gt; e o .Hencethe resulting H is in ER order. Furthermore, all effects of the concurrent operations whose effect objects precede that of o have been included into o during the integration (line 7 of Algorithm 4). The operations after the insert position k have included the effect of o after the integration (lines 37-40 of Algorithm 4). Hence, H  X  = H  X  o . 3) If o.tv =  X  ,theremustbeone H [ i ] that happens before o and H [ i ]= e o . Consider the following two cases: (3.a) If H [ i +1] = e H [ i ], it must be H [ i +1] &gt; case, o will between H [ i ]and H [ i +1] with o .p = H [ i ] .p . Hence,  X  k  X  i : H [ k ]  X  e o and  X  j&gt;i : H [ j ] &gt; the effect of o will be included into the operations that follow o in H after the integration. Therefore, H is in ER order and H  X  = H  X  o . (3.b) There exists some operation whose effect object ties with that of H [ i ]. On one hand, if o.t = del , o will be trans-formed into  X  and, similarly to case 1), after the integration, H is in ER order and H  X  = H  X  o . On the other hand, if o.t = ins , o will be integrated by some tie-breaking policy. And the effect of o will be included into the operations that follow o in H . Hence, after the integration, H is in ER order and H  X  = H  X  o .

Theorem 6.4. The invocation of any operation in ABTU satisfies Admissibility Preservation.
Proof. According to Lemmas 6.2 and 6.3, given any his-tory H that is in ER order and any operation o ,theinte-gration of o into H does not violate the ER order that is already established between operations in H .Thatis,the invocation of any o is admissibility preserving.

After all generated operations are invoked in the system, the histories at all sites will consist of the same set of opera-tions that are in the same ER order. Note that this does not contradict the fact that operations are allowed to be invoked in arbitrary orders at different sites, as long as the causality preservation condition is observed. Applying these histories to the same initial state produces the same final state. With-out loss of generality, assume that the initial state is empty and all objects are produced by user operations. Then all objects in the final state must be in the same ER order.
Corollary 6.5. After all generated operations are in-voked at all sites, all the data replicas converge in the same final state in which objects are in the ER order.
Since we do not need to save extra information other than the history H , the space complexity of ABTU is O ( | H | The processing of any local operation in Thread L (and Al-gorithm 3) takes time O ( | H | ) because it only needs to scan the history once. The processing of any remote operation in Thread R (and Algorithm 4) takes time O ( | H | )becauseit can be done by scanning H only once.

Note that the current algorithm presentation is for concep-tual clarity and our actual implementation is more efficient. For example, in line 4 of Algorithm 2, it seemingly requires to scan H . However, H [ j ] must be following H [ i ]because H [ j ]= e H [ i ]. Hence it only needs to scan from H [ i +1]. That is, Algorithm 2 only needs to scan H once.
This paper presents a novel approach to OT-based se-lective undo for distributed collaborative applications. The proposed algorithm ABTU achieves O ( | H | )spaceandtime complexities for both do and undo under a unified frame-work, which drastically improves the latest result [17] that is exponential-time in undo. Moreover, the correctness of ABTU is formally proved with regard to two formalized conditions, causality and admissibility preservation. Due to simplicity of the effects relation based approach, both the algorithm and the proofs are simple.

In the journal version of this paper, we will prove ABTU with regard to transformation properties such as TP1/TP2 [9, 11] as well as IP1/IP2/IP3 [9, 14]. In future research, we will focus on studying user interface and usability issues of selective undo in context of specific applications. Our ongoing work is further optimizing the presented algorithm, which is fully replicated, for the Web (client/server) archi-tecture to support Google Wave like Web 2.0 services. [1] Thomas Berlage. A selective undo mechanism for [2] Rajiv Choudhary and Prasun Dewan. A general [3] C. A. Ellis and S. J. Gibbs. Concurrency control in [4] Jean Ferri  X  e, Nicolas Vidot, and Mich` ele Cart. [5] DuLiandRuiLi.Preserving operation effects relation [6] Du Li and Rui Li. An admissibility-based operational [7] G  X  erald Oster, Pascal Molli, Pascal Urso, and [8] G  X  eald Oster, Pascal Urso, Pascal Molli, and [9] Atul Prakash and Michael J. Knister. A framework for [10] Matthias Ressel and Rul Gunzenh  X  auser. Reducing the [11] Matthias Ressel, Doris Nitsche-Ruhland, and Rul [12] Bin Shao, Du Li, and Ning Gu. A sequence [13] Maher Suleiman, Mich` ele Cart, and Jean Ferri  X  e. [14] Chengzheng Sun. Undo as concurrent inverse in group [15] Chengzheng Sun and Clarence Ellis. Operational [16] Chengzheng Sun, Xiaohua Jia, Yanchun Zhang, Yun [17] David Sun and Chengzheng Sun. Context-based [18] St  X  ephane Weiss, Pascal Urso, and Pascal Molli. An
