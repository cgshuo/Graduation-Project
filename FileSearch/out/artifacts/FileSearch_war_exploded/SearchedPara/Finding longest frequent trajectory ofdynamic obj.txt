 Department of Computer Applications, National Institute of Technology, Thiruchirappalli, Tamil Nadu, India 1. Introduction
During the last two decades frequent pattern mining is the key area of research for number of appli-cations aiming to find out the common phenomena which occur in dynamic objects. This results large number of applications being built on the knowledge of moving objects. Frequent trajectory coordi-nates play an essential role in many data mining tasks that try to find interesting patterns from trajectory databases consists of coordinates either two dimensions or three dimensions. Frequent patterns are item sets, subsequences, or sub-structures that appear in a data set with frequency greater than a user specified threshold value [9]. Similarly frequent trajectory patterns are coordinate sets, coordinate sequences, or coordinate subsequences that appear in a trajectory data set with frequency greater than a user specified threshold value. Among the frequent trajectory patterns there exists a longest frequent trajectory. Aim of this approach is to find the longest frequent trajectory from the set of trajectories. Finding the longest frequent patterns can be done with the help of an important role by mining associations, correlations, and many other interesting relationships among data. With the advancements in Science and Commu-nication technology from the sensors and control equipments data accrual of dynamic objects is made so easy and from these huge volume of data, knowledge about the longest frequent trajectory can be generated and observed. Data collected from such devises are spatial, temporal or spatial-temporal may be accumulated in databases [13] and used to derive knowledge by mining and finding useful patterns has focused increasing attention recently. Knowledge thus observed can be applied in different domains to predict the future movements of objects.

Frequent pattern mining was first proposed by Agrawal et al. [2] for market basket analysis in the form of association rule mining. It analyses customer buying habits by finding associations between the different items that customers place in their  X  X hopping baskets X . Since from its inception, hundreds of new algorithms or improvements on the existing algorithms have been evolved to solve the mining problems more efficiently and according to the user requirements. In this paper the existing Apriori Algorithm is modified to suit trajectory coordinates and applies the technique to the trajectory datasets to find the longest frequent path. It is portrayed as the first method in Section 3.

In order to overcome the shortcomings of Apriori algorithm, Han et al. [6] proposed the frequent pat-tern growth method to mine complete set of frequently occurring item sets without candidate generation. This method works in a divide and conquers way and requires only two database scans. This algorithm is modified and is applied in the trajectory data set to find the longest frequent path. It is specified as the second method in Section 3. In the initial scan it derives a list of frequently occurring coordinates and based upon this frequency in the second scan each coordinates in the transaction are ordered in descend-ing order. From this frequency descending list, a frequent coordinate pattern tree is formed. Starting from length one coordinate pattern to length n coordinates pattern are mined from the tree by construct-ing its conditional pattern base, which consists of the set of prefix path in the tree co-occurring with the suffix pattern, then constructing its conditional frequent pattern tree and do mining recursively on it. Frequent pattern growth is achieved by the concatenation of suffix pattern with the frequent patterns generated from the conditional frequent pattern tree. Once a pattern is generated its length is compared with the already generated one. Largest one is retained and the process is repeated until all the patterns are generated. Performance wise this method is the best method for finding frequently occurring paths of moving objects [18,19].

This concept can be adopted to find the frequent paths of flights, more frequently used roads by commuters, frequent paths of migratory birds and so on. This concept may be applied in some games, to find the path of a frequent ball movement. It is done by getting the trajectory coordinates of the ball moved out from the bat of a player X to a destination. These coordinates can be collected for a player X for a set of games. Using this coordinates, discover a frequent trajectory pattern will yield the most frequent path of the ball movement for player X. Based on this knowledge the opponent player or team may get adjust to it; tackle the situation face the ball from player X and have more probability to win.
As a remainder, this paper is organized as follows. Related works in the Apriori algorithm, frequent pattern tree algorithm, frequent pattern mining and frequent trajectory mining are reviewed in Section 2. Preliminaries and problem description based on the proposed modified Apriori algorithm and frequent pattern tree algorithm based methods to find frequent trajectory patterns are described in Section 3. An example is given to illustrate the methods is in the same section. Experimental results for showing the performance of the proposed methods are provided in Section 4. Conclusions and future works are given in the Section 5. 2. Related works This work is mostly related to pattern discovery from sequential data, which has spatial data and event sequences of trajectories. Mining frequent item sets is one of the fundamental problems in the active research area of data mining. An item set is considered to be frequent if its support is greater than a user-specified minimum support threshold, where the support of an item set is defined as the percentage of transactions in the database that contain the item set. Agrawal et al. [2] pioneered to mine frequent item sets from transactional databases and proposed an Apriori approach. After this approach many other item set mining algorithms [3,6,10] have been proposed for mining the frequent item sets in a database. Sequential pattern mining algorithms [7,16,21] have also been proposed. Yun [24] efficiently mine se-quential patterns in large sequence databases by using the weight constraints. Garofalakis et al. [4] proposed an approach, called SPIRIT, to mine sequential patterns with regular expression constraints. Many graph mining algorithms [11,12,22,23] have been proposed for mining frequent substructure pat-tern from graph data. AGM [12] uses an Apriori-based approach to combine frequent sub-graphs mined at the previous level to generate all candidates at the next level. In the gSpan [22] generates the frequent sub-graphs without candidate generation in a depth-first search manner. The breadth-first and depth-first algorithms have a high-level similarity and SPADE by Zaki [25], do a checking at the maximum extent to which a sequence is supported by a source requires an expensive computation, and major modifications are needed to achieve good performance.

Some other alternative approaches to overcome the shortcomings of Apriori algorithm by Agarwal et al. [1], one among them is the frequent pattern growth by Han et al. [8] follows a depth-first generation of frequent item sets; a hyper structure mining of frequent patterns H-mine by Pei et al. [17]. Building alternative trees and exploring top-down and bottom-up traversal of such trees in patterns-growth mining by Liu et al. in 2002 and 2003 respectively [14,15]. An array based implementation of prefix-tree-structure for efficient pattern growth mining by Grahne and Zhu [5].

All the above mentioned methods are based on sequential pattern mining, item set mining, and graph mining methods which are not suitable for finding longest frequent trajectory. The spatial and temporal attributes are considered simultaneously for mining trajectory patterns in Anthony et al. [13]. Item set and sequential pattern mining algorithms do not consider the spatial attribute, while the graph mining algorithms do not consider the temporal attribute instead uses the edge. The geometry of dynamic objects can be of any spatial type and is defined by a function from a temporal domain for a range of spatial values is followed by Stefano et al. [20]. The trajectory is considered as a poly-line or multiple curves connecting the sample points that define discrete representation of movement in a sequence of spatio-temporal segments.

Trajectory is defined as the path of flying object; the path that a projectile makes through space under the action of given forces such as thrust, wind, and gravity. It is also defined as the curve intersecting at constant angle; a curve or surface that intersects all of a family of curves or surfaces at a constant angle. Trajectory is a path of process or event; the way in which a process or event develops over a period of time. With the advancements in tracking the path of flying objects, a large amount of spatial-temporal data has been collected in databases. Getting knowledge from this data based on the observation of useful patterns has increased the attention of technocrats and decision makers recently. Frequent trajectory pattern mining is the process of discovering the most frequently occurring coordinates in the set of trajectories. Different trajectories may arise from different coordinates passing through different coordinates and ending at different coordinates. Finding the longest frequently occurring trajectory will guide to analyze and predict the movement of objects. 3. Preliminaries and problem description
Frequent trajectory pattern mining is to find all trajectories frequently occurred in a trajectory database with respect to the user specified minimum support threshold value. Initially the coordinate data set consists of trajectory identifier and its corresponding coordinates in two dimension, that is x and y the maximum number of coordinates in the set. This trajectory data is inputted to the modified Apriori and frequent pattern tree algorithms to generate the output of set of frequently occurring coordinates of the trajectories.

Trajectory can be represented as a set of coordinates in sequence in Euclidian space. Let X  X  consider trajectories D = { P 1 ,P 2 ,...,P n } , n is the number of paths of the flying object. Each trajectory path P consists of set of coordinates { V 1 , V 2 ,..., V k }, (1 k n )and n is the number of non-empty coordinate set, while considering the two dimension Euclidian space. Here k varies from 1 to n and is represented as (1 k n )where k is denoted as the length of the trajectory and n is the number of coordinates in it. In other words k -coordinate set is a set of coordinates having number of coordinates n where k = n . Each coordinate in a vertex V is represented in units in X -axis and Y -axisas( x , y ). A sub-trajectory path p consists of set of coordinates { v 1 ,v 2 ,...,v k } , (1 k n ) and n is the number of coordinate set. A sub-sequence coordinates set s = { c 1 ,c 2 ,...,c k } may contain in different set of trajectory paths. The set s is maximal if it is not contained in any other trajectory path P. Hence the trajectory path P of a flying object O consists of set of coordinates { v 1 ,v 2 ,...,v k } arranged in increasing sequence number. Such a sequence set of coordinates is called the trajectory path sequence. The support of a coordinate v is the percentage of coordinates in D that contains the coordinate v . It is defined as the fraction of all the trajectories which support this coordinate. It can be written as, Support, v = Number of coordinates v in D/ Total number of trajectories in D .

A trajectory path or sub-trajectory path is frequent if its support exceeds the user-specified minimum support threshold value  X  . Such a set of coordinates is the large coordinate set which is also termed as frequent trajectory pattern.

Let C k be the set of k -coordinates with each member of this set has two fields (i) coordinate set and (ii) support count. Let L k be the set of large k -coordinate sets with each member of this set has two fields (i) coordinate set and (ii) support count. This algorithm initially scans the database D to find the distinct distinct coordinates in D. Again scan the database D to find the support count of each coordinates in C 1 . From this set consider the coordinates whose support is greater than the user-specified minimum support threshold value  X  . Let this coordinates be considered as L 1 . Idea is that if the trajectory coordinate set L is frequent if and only if its subsequences L k  X  1 are frequent. This step is the first step of the algorithm.
Beginning of the second step is the generation of 2-coordinate candidate set C 2 = L 1  X  L 1 .Thatwillbe ( x m ,y m ) ,..., ( x m  X  1 ,y m  X  1 )( x m ,y m ) } ,where m denotes the number of coordinates in 1-coordinate set C more than once, that is ( x 1 ,y 1 )( x 1 ,y 1 ) . Again scan the database D to find the support count of each co-minimum support threshold value  X  . Let this coordinates considered be L 2 . Join all the coordinates in the set and this set is the frequent 2-coordinate sets of the trajectories in D . Similarly continue the process until k +1 times finds a set of candidates generated is an empty set. The set of coordinates obtained before the empty set ( k th step) is the longest frequent trajectory coordinate sets.
 3.1. Method I: Modified apriori algorithm  X  for mining the longest frequent trajectory
The algorithm for mining the longest frequent trajectory from trajectory coordinates data set. It con-sists of two phases. As mentioned in the first paragraph of this section the frequent 1-coordinate set L 1 obtained from the trajectory data set. The second phase starts from candidate generation, pruning, match the coordinate for a specific pattern generated and find the support count are all memory resident. Then consider only the coordinates whose support count is greater than or equal to the user specified minimum support threshold value  X  . The output obtained at the end of this phase is the set of coordinates which form the longest frequent trajectory. 3.1.1. Key concepts  X  Frequent Coordinate sets: Coordinate sets whose support count is not less than the minimum support  X  Apriori Property: Any subset of frequent coordinate set must be frequent.  X  Prune Operation: Deleting the generated candidate coordinates which are not required for further  X  Join Operation (  X  k L k ): To find L k , a set of candidate k -coordinate set is generated by joining L k  X  1 3.1.2. An example
A simple example is discussed to illustrate the process of the modified Apriori algorithm construc-tion and finding the longest frequent trajectory. Assume there are six trajectory transactions shown in Table 1. Here TID represents trajectory identifier. The trajectory column represents the two dimension coordinates of a trajectory. Normally a trajectory is represented by its coordinates along with its time component. For finding the longest frequent trajectory the spatial coordinates are enough.

The frequent one trajectory coordinate is constructed in the following way. Here support of a trajectory coordinate is the occurrence of the coordinate in all the trajectories in D. For example the support of coordinate (1, 1) is 2/6. That is 33.33%. Initially assume the minimum support count is set at 50%. That is if a coordinate occur in 50% and more of all the trajectories is the user specified minimum support threshold value. In short in this example the coordinates whose support count is 3 and more will be considered. First, the trajectory data set is scanned to find the support of 1-coordinate sets. Let this 1-coordinate sets in the trajectory data set D is shown in Table 2. All the 1-coordinate sets with their support count are shown in Table 3.

From this coordinate support count are compared with the minimum support count and consider only the coordinates which satisfies the criteria. Let this 1-coordinate set be L 1 and is shown in Table 4. Up to this point the first phase of the algorithm is done, each coordinate in L 1 is a member of the pattern from the frequent 1-coordinate set L 1 . In this step generate the various possible 2-coordinates that can occur from the coordinate set L 1 .Letthissetbe C 2 and is shown in Table 5. Do a pruning operation, that is from the set of 2-coordinates in C 2 check for the coordinates that are already in C 2 also for similar coordinates, that is (1, 2), (1, 2). If there is any such coordinate combinations exists then delete the entry. For lack of space the actual 2-coordinate sets generated and 2-coordinate sets pruned are not shown.

Then read a 2-coordinate set C 2 and again scan the data set D and search for the matching coordinate set pattern. Here the coordinate set pattern (1, 2), (2, 2) means for example, either (1, 2), (2, 2) or (2, 2), (1, 2). Both are similar patterns. If similar patterns are found then increment the support count of the sets are read and matched with the data set D . This is shown in the Table 6.

Compare the support count of coordinates in C 2 with the minimum support count and consider only the coordinates which satisfies the criteria. Let this 2-coordinate set be L 2 and is shown in Table 7.
Till this point the second iteration of the second phase of algorithm is done, each coordinate in L 2 is a yield the 5-coordinate set L 5 and is shown in Table 8.

After the fifth iteration, next step is the generation of 6-coordinate frequent pattern. In this step gen-erate the various possible 6-coordinate sets that can occur from the coordinate set L 5 . Let this set be C last the algorithm will return the set {(1, 2), (2, 2), (2, 3), (3, 4), (3, 5)} as longest frequent trajectory coordinates. 3.2. Method II: Modified frequent pattern tree algorithm  X  to mine longest frequent trajectory
Under the association mining category, the frequent pattern tree algorithm uses the divide and conquers strategy to find the frequent patterns [8]. In order to overcome the shortcomings of Apriori algorithm, Han et al. [6] proposed the frequent pattern growth method to mine complete set of frequently occurring item sets without candidate generation. This method is modified for mining longest frequent trajectory from the coordinates of trajectory data set. It requires only two database scan to list the frequently occurring coordinate sets of flying objects. In the initial scan it extracts coordinates and calculates their frequency. In the second scan, each trajectory transaction is rewritten by considering only the coordinates whose frequency count is greater than the threshold value are ordered in descending order. Based on this frequency descending list, the data set D is logically compressed into a frequent coordinate pattern tree or frequent pattern tree. Each nodes of a frequent pattern tree consists of a root labeled as  X  X ull X , a set of coordinates prefix sub trees which follows the root and a frequent coordinates header table. Each node in the coordinate prefix sub tree consists of three fields: (i) coordinates ( x , y ), (ii) frequency count of the coordinates and (iii) pointer which link the successive nodes in the frequent pattern tree. If the node is a leaf of the frequent pattern tree then the next node pointer is set to null. A logical table named header table is established to aid searching the coordinates. It consists of two fields, (i) coordinates ( x , y )and (ii) pointer pointing to the first occurrence of the coordinate node in the frequent pattern tree by node link structure. In this table nodes are arranged in descending order of the frequency. There will be a pointer which links the coordinate in the table and the corresponding node in the frequent pattern tree.
Starting from length one coordinate pattern to length n coordinates pattern is mined from frequent pattern tree by constructing its conditional pattern base. It consists of the set of prefix path in the fre-quent pattern tree co-occurring with the suffix pattern, and then constructing its conditional frequent pattern tree and do mining recursively. Traverse from the root of frequent pattern tree and retrieve pat-terns whose coordinate count satisfies the minimum support value  X  by path wise. Once all the paths are traversed depth-wise then integrate all the frequent coordinates which were retrieved during traversal. Frequent pattern growth is achieved by the concatenation of suffix pattern with the frequent patterns gen-erated from the conditional frequent pattern tree. Each pattern generated is compared with the previous generated one and the longest one is retained. The consecutive set of coordinates returned at the end is the longest frequent trajectory. Performance wise this method is the best method for finding frequently occurring paths of objects. The algorithm is shown below: 3.2.1. An example
A simple example is given below, to illustrate the process of finding the longest frequent trajectory using the modified frequent pattern tree. Consider the coordinates of six trajectory transactions shown in Table 1. The frequent pattern tree is constructed in the following way. Initially assume the minimum support is set at 50%. First of all, the coordinates of the trajectory data set D is scanned to find frequency of all coordinates. All the coor dinates with their counts (frequencies) are shown in Table 9.
From Table 9, the set of large 1-coordinates, named L 1 , can be obtained as: {(1, 1):2, (1, 2):4, (2, 2):6, (2, 3):6, (3, 4):6, (3, 5):3, (1, 3):2, (2, 5):3, (1, 5):2, (2, 1):2}, where the number after a coordinate represents its count. The large 1-coordinates in L 1 are sorted according to their descending frequency and consider the coordinates whose frequency count is more than the minimum support. The resultant sorted L 1 named as L 1 is {(2, 2):6, (2, 3):6, (3, 4):6, (1, 2):4, (3, 5):3, (2, 5):3}. Next, the trajectory coordinate data set is scanned again to rewrite each transaction on the basis of sorted large 1-coordinates and construct the frequent pattern tree. Each row with only sorted large 1-coordinates with their frequencies sorted descending is shown in Table 10.

Frequent pattern tree construction starts from a root and consists of a set of coordinate prefix sub-trees, as well as a frequent coordinate header table. The root of the tree is first set as Null. Transactions from the sorted large 1-coordinates are read and the prefix sub-trees are created. Each coordinates of the transaction form the node of the frequent pattern tree. Every node of the tree consists of three fields namely: coordinate, count and node link, where coordinate is the point in the trajectory. Count is the counter which is incremented each time when there is a same point exists in a transaction passing through this node. Initially the count is set to 1. The node link i s a pointer which links the current node with the already existing node with the same coordinate exists in the tree or else null. From the node (2, 2) next new node (2, 3) is created and its count is initialized to 1. Similarly the nodes (3, 4), (1, 2) and (3, 5) are created successively. The results after the first transaction is processed are shown below in Fig. 1.
The second trajectory transaction is next processed. Starting from the Null node, if there exists any node with coordinates (2, 2), then frequent pattern tree continues from that node otherwise it creates a new node and initializes its count as 1. Since the coordinate (2, 2) exists it uses the same node (2, 2) as the first branch of the frequent pattern tree. The count of node (2, 2) is then incremented by 1, and the nodes (2, 3), (3, 4), (1, 2) and (3, 5) are successively associated with their corresponding nodes and their respective count is incremented. The results after the second transaction is processed are shown below in Fig. 2.

The same process is then continued for the rest of the trajectory transactions. After all the transactions from Table 10 are processed, the resultant frequent pattern tree is shown in Fig. 3. Each time when a new coordinate is read from the sorted large coordinates an entry is made in the header table. Header table is a logical table consists of two columns: one of which is, coordinate and the other is the head of node links. The coordinates in the header table will be in the descending order of their frequency. The head of node link is a pointer pointing to the first occurrence of the node in the frequent pattern tree for its corresponding coordinate. After all the transactions from Table 10 are processed, the resultant header table and the frequent pattern tree will be like the one which is shown in Fig. 4. From this tree the longest frequent trajectory mined is explained in the next sub-section. 3.2.2. Mining of large coordinate sets
After the frequent pattern tree is constructed from a large coordinate trajectory data set, a mining procedure called frequent pattern growth [8] is executed to find all large coordinate sets. Frequent pattern growth does not need to generate candidate coordinate sets for mining, but derives frequent patterns directly from the frequent pattern tree. It is a recursive process, handling the frequent coordinates one by one and bottom-up approach with the help of the header table. A conditional frequent pattern tree is generated for each frequent coordinate, and from the tree the large coordinate sets with the processed coordinate can be recursively derived.

To continue the process, the frequent pattern tree formed in the previous example is used to illustrate the frequent pattern growth procedure. Frequent coordinates in the header table shown in Fig. 3 are processed in the same manner of bottom-up and one by one. The coordinate (2, 5) has lowest frequency and is the last coordinate in the table is first processed. Two prefix paths exist for coordinate (2, 5): is {(2, 2):6) ((2, 3):6) ((3, 4):6) (1, 2):4) (2, 5):1)} and {((2, 2):6) ((2, 3):6) ((3, 4):6) (2, 5):2)}. The counts of all the nodes in the first prefix path are then updated as 1 since they appear only once with coordinate (2, 5) in the branch. Similarly, the counts of the nodes in the second prefix path are all updated as 2 since they appear twice with coordinate (2, 5). Thus, the two converted prefix paths are {(2, 2):1) ((2, 3):1) ((3, 4):1) ((2, 2):1)} and {(2, 2):2) ((2, 3):2) ((3, 4):2) ((2, 5):2)}. This is the condition pattern base for the coordinate (2, 5). The counts of the coordinates in the two prefix paths are then calculated. After that, the coordinates (2, 2) (2, 3) (3, 4) with count 3 is large. Hence the condition pattern tree with coordinate (2, 5) are {((2, 2):3) ((2, 3):3) ((3, 4):3)}. Prefix paths with coordinate (2, 5) and the conditional frequent pattern tree for coordinate (2, 5) is shown below in Fig. 5. From the condition frequent pattern tree all the possible frequent coordinates like, {(2, 5), (2, 5)(2, 2), (2, 5)(2, 3), (2, 5)(3, 4), (2, 5)(2, 2)(2, 3), (2, 5)(2, 2)(3, 4), (2, 5)(2, 3)(3, 4), (2, 5)(2, 2)(2, 3)(3, 4)} are generated. The output is shown in the first row of Table 11. Each frequent coordinate set generated is compared with the successive one and the longest among them is preserved. At the end of the step the algorithm preserves (2, 5) (2, 2) (2, 3) (3, 4) as the longest frequent coordinate set.

Next, coordinate to be processed is (3, 5). There is only one converted prefix path (condition pattern base) for coordinate (3, 5): {((2, 2):3) ((2, 3):3) ((3, 4):3) ((1, 2):3)}. The counts of all coordinates in the path are larger than or equal to the minimum count 3. Thus the set of large coordinates for the conditional frequent pattern tree of coordinate (3, 5) is {((2, 2):3) ((2, 3):3) ((3, 4):3) ((1, 2):3)}. Prefix paths with coordinate (3, 5) and the conditional frequent pattern tree for coordinate (3, 5) is shown below in Fig. 6. From the condition frequent pattern tree all the possible frequent coordinates generated are shown in the second row of Table 11. Each frequent coordinate set generated is compared with the already obtained longest set. The algorithm retains the longest frequent set of coordinates. At the end of this step the algorithm preserves (3, 5) (2, 2) (2, 3) (3, 4) (1, 2) as the longest frequent coordinate set.
All the coordinates in the header Table (1, 2) (3, 4) (2, 3) and (2, 2) will be processed in the same way. The condition pattern base, condition frequent pattern tree and the frequent coordinates generated for the corresponding header table coordinates are shown in Table 11.

Finally the algorithm will return the set of (3, 5)(2, 2)(2, 3)(3, 4)(1, 2) coordinates. Because out of the generated patterns the returned set of coordinates sequence is the longest. 4. Experimental results Based on the modified Apriori and frequent pattern tree methods the longest frequent trajectories of the dynamic objects were found. Experiments were performed with the instructions of Net Beans IDE 6.7.1 with JavaFX on a PC having an Intel Pentium D CPU with a 3.40 GHz processor and 1 GB RAM and running under the Microsoft Windows XP Professional version 2002 operating system. The dataset used in this experiment is the synthetic dataset obtained from Yi-Anchen [13]. Each transaction in this dataset consists of x, y coordinates of the trajectories with time interval. The transactions were generated from the synthetic dataset with the following parameters. Number of trajectories: 500 X 3000, The length of the reference space: 10 X 100 cm, Average length of the trajectories: 10 X 100 coordinates, Maximum time span: 30 sec, The number of potential frequent patterns: 1000, Average length of the potential frequent patterns: 25 coordinates. Initially, the trajectory dataset is extracted from a text file and is imported into an Oracle database for doing an initial data cl eaning process. In this process checking is done to identify any missing coordinates and inconsistent values. In such cases the coordinates are omitted to avoid inappropriate results. Initial frequency counts of the coordinates are done in Oracle database using its programming feature. Then the data is written back in the operating system and further processing is done to find the longest frequent trajectory.

Experiments were conducted to study the performance of the algorithm for finding the longest frequent trajectory of the dynamic objects. The execution time obtained from it is observed and plotted (Cf. Figs 7 and 8). It can be observed that the frequent pattern tree algorithm takes about one third less execution time and space than the ones needed for graph based mining [13]. The minimum support threshold verses execution times, and the number of coordinate paths verses execution times were plotted and a comparative study is made after the implementation of the modified Apriori based mining (ABM) and frequent pattern tree based mining (FBM) with the graph based mining (GBM) across their execution times over various minimum support thresholds as shown in Fig. 7. The same experiment is repeated for various numbers of trajectories and their execution times are noted and are shown in Fig. 8. From these experimental results, it is clear that the modified frequent pattern tree based mining is nearly three times better than existing GBM and ABM for finding the longest frequently occurring trajectory of dynamic objects. 5. Conclusion and future work
This paper, proposes the modified association based approaches for finding longest frequent trajec-tory of the dynamic objects efficiently and effectively. Advantage of the first method is later iterations are much faster than the initial iterations. The results obtained by this method are more accurate and reliable. These algorithms uses large coordinate set property. More over these algorithms are easy to implement. Disadvantage of the first method are, it uses a generate, prune and test approach generates candidate coordinate sets (1-coordinate, 2-coordinate, 3-coordinate, . . . ), check the generated sequence of coordinates are already generated or not, and tests if they are frequent by scanning the database and counting their support each time. Generation of candidate coordinate sets is expensive (in both space and time). Since generation and pruning steps are memory resident, it needs more RAM. Another dis-advantage is it needs n +1 database scans, where n is the number of coordinates in the longest pattern. Advantage of the second method is that it takes only two database scans and is usually the fastest algo-rithm. Its disadvantage is, more difficult to implement than other approaches, also has a complex data structure. Its tree data structure will need more memory than a list of transactions.

These algorithms can be applied to mine frequent curve patterns, also to mine frequent patterns of molecules which are dealt in biomedical applications. They can be modified little to accommodate the frequent trajectory pattern mining in three dimensional spaces. Further enhancements of these algorithms may be done to improve performance by pruning method. Also other enhancements like the Partition-ing technique, Sampling approach, Dynamic item set counting and Integrating mining with relational database systems can be done to improve the performance. Based on the observed longest frequent tra-jectory pattern and apply the advanced techniques to predict the path of the object. The proposed work will help to analyze and predict the future movement of dynamic objects.
 Acknowledgement
The author acknowledges the receipt of research supported by the TATA Consultancy Service X  X  schol-arship.
 References
