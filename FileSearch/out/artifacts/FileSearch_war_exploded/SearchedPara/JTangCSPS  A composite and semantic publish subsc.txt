
Using ontological concepts and relations to express events and subscriptions can improve the e xpression of publ ish/subscribe system, and increase selectivity and finer grained control for the event matching process. Moreover, semantic reasoning can discover additional events that cannot be foundbytraditionalmatching algorithms.

On the other side, more sophisticated publish/subscribe appli-cations such as business process execution, business activity monitoring and workflow management need composite subscrip-tions to combine events from distributed sources. Composite events can be composed or derived from other events called its members. Composite subscriptions allow clients to subscribe patterns of events (composite events). It gives additional dimen-sion of data management, and improves scalability and perfor-mance of distributed systems.

However, the issues of how to support semantic events and logical and temporal correlations of composite events both and how to route and manage composite events and subscriptions are still largely unexplored.

To address the above issues, we present the design and the implementation of JTang Composite and Semantic Publish/sub-scribe system (JTangCSPS) over structured P2P networks. Com-pared with the existing work, the main contributions of our work are as follows: 1. We propose a Semantic broker network architecture, which is built by mapping ontology class weighted tree to weighted broker network. The ontology routing table maintains OCWT and helps deduce the hops, and the backup strategy improves the reliability of system.
 instance of unstructured networks in which peers are grouped by thematical, semantic or social relationships of documents they store. Each peer stores additional information about content classification and route queries to the appropriate SONs, increas-ing the chances that matching objects will be found quickly and reducing the search load. However, the maintenance cost in SONs becomes more expensive when the number of SONs increases.
Different from these systems, JTangCSPS proposes a semantic broker network over structured P2P network to achieve large-scale computing and load balance.

Composite events have been an important issue not only in traditional networks such as system monitoring but also in dis-tributed event systems. Some publish/subscribe systems support composite events and subscriptions. Courtenage (2002) describes a new declarative language for specifying composite events based on the typed l -calculus. Composite events are represented in this language by curried functional e xpressions. Following research ( Courtenage and Williams, 2006 ) implements a composite event notification system over a chord-based peer-to-peer network using
JXTA to handle the network management and network routing. CEA ( Pietzuch et al., 2003 ; Pietzuch et al., 2004 )proposesaCore Composite Event Language to express concurrent event patterns.
The CEA language is compiled into automata for distributed event detection supporting regular expression-type patterns. CEA employs polices to ensure that mobile event detectors are located at favor-2004 ) describes composite events using composite event filter expressions, which can be mapped to expressions of the Core
Composite Event Language ( Pietzuch et al., 2003 ). ECCO ( Yoneki and Bacon, 2005 ) created event broker architecture for a distributed adaptive mobile environment. Event correlation is part of event brokers, and grids of brokers are deployed over mixed network environments. The ECCO protot ype is implemented with a MANET protocol as a content-based pub lish/subscribe system. Cayuga ( Demers et al., 2006 ; Demers et al., 2007 ) is a stateful publish/ subscribe system based on nondeterministic finite state automata (NFA), and supports features such as parameterization and aggrega-tion. Gang et al. (2005) proposes the composite matching algorithm based on hierarchy colored Order Binary Decision Diagram (OBDD) graphs to handle temporal constraint variable of the composite subscription. PADRES ( Li and Jacobsen, 2005 ) supports paralleliza-tion, alternation, sequence and repetition compositions, and is based on a rule-based broker that implements composite event detection and proposes a distributed algor ithm for composite subscription routing. However, REBECA ( Ulbrich et al., 2004 ) allows subscribing temporal events only and ( Courtenage, 2002 ) lacks support for temporal correlation. Some other systems gave no distributed solutions ( Demers et al., 2006 ; Demers et al., 2007 ; Gang et al., 2005 ), and Yoneki and Bacon (2005) did not consider efficiency. In this paper, we present a composite event and subscription language and distributed composite subscription management over semantic broker network to achieve large-scale computing and efficient routing. 3. Semantic broker network architecture
Distributed publish/subscribe systems strive to achieve scalabil-ity and avoid a single point of failure using an overlay network of brokers. However, the hash function of structured P2P network is not sufficient for a content-based publish/subscribe system. In this section, we present the detail of the semantic broker network architecture. JTangCSPS is an extension of our early work ( Qian et al., 2011 ). Web Ontology Language (OWL) is used to build semantic broker network. We define weights of ontology classes to estimate the information of events and subscriptions, and create parent is put in the first place of sorted children set CS, and the sibling that is most similar to the first child is put in the next place and so on. The OCId of the child node is assigned with that of parent first, then set the first 0 ( x bit) to a value between 1 and 2 b 1 according to its weight. The x bit of the first child is set to 1, and the x bits of the other children are set by the equation in OCId algorithm where x f is the x bit value of the former child and w the weight of the former child. The equation guarantees that every ontology class has a unique OCId.
 S
Fig. 1 is an example of the ontology of food. The number above the node is the weight of ontology class, the number in the rectangle is the sum of the children X  X  weights, and the number behind the node is the value of OCId in the case of b  X  3, l  X  4. 3.2. Weighted broker network
For distributed publish/subscribe systems, the most important resources are the bandwidth of the network and computing ability of the brokers. Besides, brokers usually serve continuously. We define the weight of the brokers by
W N  X  a 1 B  X  a 2 C  X  a 3 t online  X  4  X 
W
N is the weight of the broker at t time, B is the bandwidth of the broker, C is the computing ability, t online is the online time and a a and a 3 are constants.

After defining the weight of the broker, we map OCWT to the weighted broker network. To achieve load balance, we let the bigger weight of broker responsible for the bigger weight of ontology classes. Subscriptions related to the same ontology class are defined as a virtual subscription, and each broker manages one or more virtual subscriptions.

When the number of nodes of OCWT is larger than the number of nodes of the broker network, some brokers will be responsible for one or more ontology classes. We combine the class nodes of
OCWT to create a new tree named composite ontology class weighted tree (COCWT). Correspondingly, a composite ontology composite ontology class and broker nodes and assigns one composite ontology class to one node in order. If a broker node is mapped with a composite ontology class, it gets the responding subtree from the OCWT and tries to split it and maps them to nodes in its routing table.
 Mapping Algorithm Input: OCWT
Output: map(OCWT) for node i A routing table WS.add( request(node i ))
WS.sort combine(OCWT) for node i A WS node i .map(OCWT.ccn i ) 3.3. Ontology routing table and backup strategy
The semantic broker network has three types of brokers: main node, backup node and routing node. The main node manages one or more virtual subscriptions, and the backup node backs up the virtual subscriptions of one main node, while a routing node only helps to route messages. Each broker has a node identifier (NId) by combining the OCId and the broker identifier (BId). The NId is used to indicate a broker X  X  position in a circular NId space, and BId is generated by hashing its IP address to k -bit space; so the length of NId is bl  X  k . For a main node, OCId is the smallest one of the virtual subscriptions. For a backup node, OCId is same as the main node it backs up. For a routing node, OCId is same as the node that the broker joins the network and first connects to.

Besides the routing table of the understructure P2P network, each main node has an ontology routing table (ORT), including NodeSet, ParentSet, ChildrenSet, GrandChildrenSet, LeftNeighbor,
RightNeighbor, BackupNode and BebackupNode. NodeSet contains the OCIds of the ontology classes, which the broker maintains; ParentSet contains the OCIds of parents and grand-parents of those in the NodeSet; ChildrenSet contains the OCIds of all children of those in the NodeSet; GrandChildrenSet contains the OCIds of first child of those in the ChildrenSet; LeftNeighbor and RightNeighbor are the OCIds of the left and right siblings;
BackupNode is the OCId of the node, which serves as a backup node of this node and BebackupNode is the OCId of the node, which is backed up by this node. ORT helps route messages and reconstruct the COCWT.
 To improve the reliability of system, a backup strategy is used.
During selection of the backup node, we consider two situations: (1) if n r m , then each broker is a main node. How to select the backup node is decided by the following conditions: (a) parent node is backed up by the first child; (b) leaf node is backed up by the left or right neighbor node or the parent node. It ensures that the node and backup node are always adjacent. (2) If n 4 m ,a main node try to find a not main node from the routing table as a backup node. If it cannot find one, it will follow the method above.
Fig. 2 is an example of mapping the COCWT of Fig. 1 to Pastry ( Rowstron and Druschel, 2001 ) network, which has eight nodes.
N 1000 is the root of the COCWT, and N 1111 , N 1114 and N 1141 composite nodes. Arrows with dotted line connect parents to their children.
 Routing algorithm Input: Message M
Output: next hop getNextHop( M ) if ( L return min( 9 M.dest -L i 9 ) 4. JTangCSPS composite event and subscription language
In a distributed system, each event has a timestamp associated with the occurrence time. There are two types of expressions of timestamps: point-based timestamps and interval-based time-stamps. Point-based timestamps usually consist of a single value, indicating the occurrence time. However, in a distributed system, node clocks may have unknown jitter within a known synchro-nization distance. As a result, if two nodes detect events E it may be impossible to decide which occurred first. On the other side, interval-based timestamps consist of a start time and an end time, which can make this ambiguity explicit and remain con-sistent with the physical time order of events. Interval-based timestamps are used in this paper.

In this section, we present a composite event and subscription language, and show the presentation of composite event and subscription model. Then we illuminate the management of distributed composite subscriptions including subscribing pro-cess, unsubscribing process and matching and notifying process. 4.1. Composite event and subscription language
To describe formally primitive and composite events (subscrip-tions), we adopt a symbolic representation that resembles and extends the CEA language ( Pietzuch et al., 2003 ) and is conformant with the logical and temporal expression of Lamport (1978) and Allen and Ferguson (1994) .

Events and subscriptions in JTangCSPS are related to domain knowledge and defined by OWL ontology language. A primitive event E p is defined by the following formula:
E  X  X  c , S tr , t , t l  X  X  5  X 
S  X f X  s 1 , p 1 , o 1  X  , :::  X  s n , p n , o n  X g X  6  X  t  X  X  t s , t e  X  X  7  X 
E is an individual of a class c A C (the classes of ontology) and is associated with a set of triples S tr and an interval timestamp t s , a property (predicate) p and an object o. t s is the interval start and has a finite value.

Composite events are defined by composing primitive events or composite events with logical and temporal operators. A composite event can be created by publishers or combined by brokers to satisfy a composite subscription. A composite event E N1114 N1111 N1110 time of the other, a composite event ( E 1 and E 2 ) will be created.
 Concurrency. S 1 99 S 2 : Events E 1 and E 2 occur in parallel.
Negation ( S 1 ) T : No event E 1 occurs within the T interval and a notification message will be created. ( S 1 S 2 ) T : E no E 2 occurs within the T interval. The negation operator of subscription is always followed by a T restriction, otherwise there will be no notification.

Iteration S 1 n : A number of n event E 1 occurrences ( S number of n event E 1 occurrences with each in the T interval of the former E 1 .( S 1 n ) T : Any number of event E 1 occurrences with each in the T interval of the former E 1 .

Sequence. It includes 7 temporal restrictions: S 1 before S meets S 2 , S 1 overlaps S 2 , S 1 finishes S 2 , S 1 includes S
S sequence relation of E 1 and E 2 ( Nejdl et al., 2003 ) is shown in
Fig. 3 . 4.2. Presentation of composite event and subscription model
In JTangCSPS, events and subscriptions are represented as RDF graphs. Since OWL does not support logical and temporal opera-tors and quantified variables natively, a special ontology is created to present the concepts and relations of event and subscription. Fig. 4 is a part of the ontology about subscriptions.
Both event and subscription have an additional property to express the interval-based timestamp, and the other ontology classes about events are similar.

The structure of an RDF graph is a collection of triples, and each triple consists of a subject, a property and an object. Every triple is denoted as a node X  X rc X  X ode link in the RDF graph. A node may be a URI reference, a literal or blank, while an arc is always a URI reference and points toward the object. Fig. 5 is an example of RDF primitive event graph. The value of rdf:type property means that it is a primitive event individual and it has a hasTimestamp property. The value of hasInfo property can be any individual and rdf:type property identifies the ontology class, which the event belongs to, and the other properties are pre-sented as p i ; URI reference and text are presented as URIref_i and Literal_i ( i Z 1 ).

Fig. 6 illustrates a primitive subscription S built on the event traditional mathematical operation. Fig. 7 illustrates that a composite subscription has two primitive subscriptions with a temporal operator  X  X  X efore X  X . 4.3. Distributed composite subscriptions management
In a large-scale distributed publish/subscribe system, events
Thing
In this paper, we propose a distributed composite subscriptions management. The distributed solution consists in decomposing the composite subscription and registering the parts of the subscription to different brokers during the routing process, and collecting the primitive events from the different brokers and aggregating them through the reverse path of subscription rout-ing. A notification message is sent to the subscriber only after all the parts are collected. The collections of events should be as close to the publishers as possible to ensure that the events are not unnecessarily disseminated throughout the broker network.
To store primitive and composite subscriptions, every broker has a primitive subscription map (PSM) and a composite sub-scription map (CSM). Each subscription has a unique subscription identifier (SId), which is used as the key of the two maps. During the subscribing process, when the broker receives a primitive subscription, it will be routed to the destination broker who manages the responding ontology class of the subscription, and then be put into the PSM. On the other hand, when a broker receives a composite subscription, a composite subscription tree (CST) is built by regular express. Leaf nodes of CST are primitive subscriptions and the internal nodes are operators. According to the OCId algorithm, each primitive subscription has its destina-tion. If all primitive subscriptions have the same next hop, the broker forwards the composite subscription as a whole to the next hop; otherwise it is put into the CSM and the broker creates a new composite subscription S i for each subtree of CST and subscribes it again. The subscribing process is finished till all primitive subscriptions arrived at their destinations and put into the PSMs of brokers.
 Subscribing algorithm Input: subscription S ; composite subscription tree CST
Output: null subscribe( S ) if S is a primitive subscription else if HOPS. size  X  X  1 else
Following the example in Fig. 8 , broker N 1 received a compo-of S is shown in Fig. 8 (a). Broker N 1 first calculates the destina-ing to the OCId algorithm. Since the next hops of all primitive subscriptions are the same ( N 11 ), the composite subscription is forwarded as a whole. Because the next hops are different, broker
N 11 first puts S into the CSM, then forwards ( S 3 ) T to broker N and creates a new composite subscription ( S 1 before S 2 forwards it to broker N 112 . Then broker N 112 puts ( S 1 into the CSM, and forwards S 1 and S 2 to N 1121 and N 1122 respectively. of the broker, the broker forwards it to the next hop. Otherwise, if
US is a primitive unsubscription message, the broker removes the corresponding subscription from PSM and sends an ACK message back to the subscriber. If US is a composite unsubscription message, the broker gets the composite subscription S from
CSM by SId, then for each primitive subscription PS i of S , if the destination is equal to OCId, the broker removes PS i from PSM and sends an ACK message back to the source broker where US is generated. Next, for each subtree of CST, the broker creates a new composite unsubscription US i and does the unsubscribing process again. When a broker receives an ACK message, if the destination of ACK is not equal to OCId, the broker forwards it to the next hop.
Otherwise, the ACK message arrives at its destination, if parentSId of ACK is null, the broker just sends the ACK to the subscriber. Else the broker gets the composite subscription S from CSM by the parentSId of ACK, and adds the value of count. If the S.count is equal to the number of subtrees S.size , then the ACK messages from all subtrees of S are received, S is removed from CSM. If parentSId of S is null, an ACK message is send to the subscriber. Else, a new ACK message is created and forwarded.

Fig. 9 shows an example of the unsubscribing process. When broker N 1 receives a composite unsubscription message US , N forwards US as a whole to broker N 11 . Broker N 11 gets S from the
CSM, and creates new unsubscription messages for subtrees and forwards them to broker N 112 and N 111 . N 112 does almost the same thing as N 11 . Then N 1121 and N 1122 receive the unsubscrip-tion messages and remove primitive subscriptions from PSMs correspondingly, and send ACK messages to N 11 . Finally, N receives an ACK message and sends it to the subscriber. 4.4. Matching and notifying process
Because composite subscriptions are decomposed into primi-tive subscriptions during the routing process, so the matching process only needs to match primitive events with primitive subscriptions only.
 Matching and notifying algorithm Input: event E
Output: null match( E ) for PS i A PSM if match( E , PS i ) match( E , PS ) if E.c  X  X  PS.c for p i A PS.S tr
N un((S 1 before S 2 )&amp;(-S 3 ) T )
To match the composite subscriptions, each broker has a subscription event map SEM and event map EM. The key of
SEM is SId of composite subscription and the value is EM. The key of EM is SId of the child subscription and the value is an event queue EQ, which stores the events matched with the child subscription. When a broker receives a notify message N , if the destination of N is not equal to OCId, it forwards N to the next hop. Else, if the parentSId of N is null, which means N is sent to a subscriber who subscribes a primitive subscription, the broker gets the subscription S from PSM and sends N to the client directly. Else, if the parentSId of N is not null, the broker gets
EM from SEM by parentSId of N , then gets EQ from EM by SId of N , and then adds N.E to EQ. One of the benefits of distributed composite subscriptions management is, for each composite subscription, the broker only has to handle one logical or temporal operator. If the broker detects the events satisfied with the operators of composite subscription S by createCS function, it removes the events from EQs and creates a composite event CE , then puts it into a notification message N and routes N to the destination of parent subscription or the subscriber. Fig. 10 shows an example of the notification routing process.
Broker N 112 receives notification messages from N 1122 and N and puts the events in EQs. When N 112 detects events E 1 satisfied with E 1 before E 2 , it creates and forwards the composite event ( E 1 before E 2 )to N 11 and removes them from EQs. At last, N forwards the notification message with (( E 1 before E 2 ) and ( E 3 ) T ) to the subscriber. 5. Experiments
To measure the performance of the proposed system and to verify the concepts presented in this paper, we have developed a prototype of the system and have simulated the prototype with various parameter settings. We use PeerSim ( Ulbrich et al., 2004 ), http://peersim.sourceforge.net/ simulator for performing experi-ments over Pastry overlays. All measurements took place on a standard PC installation with Linux libraries and a hardware configuration comprising 8 Intel Xeon CPU 2.00 GHz, 4 GB RAM.
To simplify, the simulations are made over a static network that does not suffer from node join and neither node failures.
To simulate the semantic broker network, for each different network size, we build a full ontology class weighted tree and its height is h and the number of children is c . The weight of child class is the weight of the parent class plus a new weight. The new weight is generated according to Zipf ( a  X  1) distribution. The weight of Broker is generated by Zipf ( a  X  1) distribution too. The number of OCWT is about 3 X 4 times of the network size. The size of different broker network and the corresponding OCWT are shown in Table 1 .
N primitive subscription only contains one type constraint. In the first scenario, each broker randomly creates 20 primitive sub-scriptions and registers to the broker network. In the other scenarios, instead of primitive subscriptions, each broker ran-domly creates 20/ i composite subscriptions, each consisting of i primitive subscriptions where i  X  2, 5, 10, 20. Fig. 12 (a) shows that the routing delay increases with the size of the network.
Fig. 12 (b) shows that the routing delay increases linearly with the number of hops of the composite subscription.
Fig. 12 (c) shows that the routing delay increases fast before NoPS reaches 5 and then increases slowly. Though the routing delay might be different for different performances of broker, different 1500 2000 2500 3000 Routing Delay (ms) 1500 2000 2500 3000 Routing Delay (ms) 1500 2000 2500 3000
Routing Delay (ms) subscription of 5 primitive subscriptions has a possibility of 50% to create a new composite subscription of 2 primitive subscrip-tions. It helps reduce an overall message traffic by collecting events as close as to the source nodes. However, due to Pastry X  X  feature of hop, the possibility to generate a composite subscrip-tion with 3 or 4 primitive subscriptions is very small. 5.4. Network traffic overhead
Detecting and composing composite events in the broker network reduce the message traffic received by clients. We use the same series of subscription scenarios of routing delay. After that, each broker publishes 50 events.

We count the number of notification messages passed at each broker in the different scenarios, which is shown in Fig. 14 . The result shows that the number of notification messages reduces while the number of the primitive subscriptions of the composite subscription increases. The number of notification messages of smaller size of broker network reduced faster than that of bigger size of network. For example, when NoPS is 20 in network of 500 nodes, the number of notification messages reduces from 470 to 375 with a reduction of 20%. 6. Conclusion
In the paper, we present JTangCSPS, a composite and semantic publish/subscribe system over structured P2P network. We intro-duce ontology into the structured P2P network to provide semantic support, and define the weights of ontology classes and brokers and virtual subscription to map OCWT or COCWT to the broker network, achieve large-scale distributed computing and load balance. The ontology routing table maintains OCWT or
COCWT and reduces the hops of messages over structured P2P network. Besides, the node backup strategy enhances the relia-bility of service. The paper also presents a composite event and subscription language to support the temporal and logical patterns of the distributed events. Distributed composite subscriptions management decomposes composite subscriptions and collects the primitive events from different brokers and aggregates them. It ensures that the events are not unnecessarily disseminated throughout the broker network. The experiments based on the Peersim simulator over the Pastry overlays show that the ontology routing table helps reduce the average number of hops, and the distributed composite subscriptions management significantly reduces the load on the network.
 Acknowledgment The work is supported by the National High-Tech Project of China (nos. 2011ZX01039-001-002 and 2009ZX01043-003-003).
The authors would like to thank the reviewers for their helpful and constructive remarks.
 References
