 1. Introduction
Web automation applications are widely used for different purposes such as B2B integration, web mashups, automated testing of web applications, Internet metasearch or technology watch.

Web automation applications involve dif fi cult tasks such as: 1) automating browsing through websites [2,18,21,24] ;2) extracting data from HTML pages (see Ref. [4] for a survey); 3) specifying the execution work
We can identify two distinct stages in this process:  X 
Generation phase. In this stage, the user speci fi es the navigation sequence to reproduce. The most common approach, cf. [2,18,21,24] , is using the  X  recorder  X  metaphor: the user performs one example of the navigation sequence using a modi browser; the web browser records the events produced by the user and generates a speci navigation sequence and to specify how they should be used in the sequence.  X  automaticnavigationcomponentwhichreproducesthesequence.Theautomaticnavigationcomponentcanbedevelopedbyusing
Fig. 1 shows an example of a navigation sequence accessing the content of the account.
 hand, the user actions that could be recorded were very restrictive (mainly clicking on elements and the other hand, it was assumed that almost every user action caused a request to the server for a new page. browser performs an AJAX request to obtain the message content and modi the page.

In this paper, we propose a set of new techniques to build an automatic web navigation system able to deal with all the complexities of these modern sites.
 sequence in a change-resilient manner.

In the execution phase, we use the APIs of commercial web browsers (Microsoft Internet Explorer and Firefox) to implement page behave differently when accessed with the custom browser. Also in the execution phase, we introduce a novel method to detect when the effects caused by a user action (including the effects of the scripting code and AJAX requests) have step can create the element that is the target of the next step).
 relevant tools. Section 5 discusses related work. Finally, Section 6 summarizes our conclusions and future work. 2. Models In this section we describe the models we use to characterize the components used for automated browsing.
The main model we rely on is DOM Level 3 Events Model [7] . This model describes how browsers respond to user-performed actions on an HTML page currently loaded in the browser. Although the degree of implementation of this standard by real browsers is variable, the key assumptions our techniques rely on are veri that are relevant to our objectives.

Secondly, Section 2.2 states additional assumptions about the execution model employed by the browser with regards to the scripting code, including the kind of asynchronous calls required by AJAX requests. These assumptions are also veri major browsers. 2.1. DOM Level 3 Events Model can perform actions such as modifying nodes, removing them, creating new ones or even launching new events. capture phase are executed before the events executed for the bubbling phase. This lifecycle is somewhat of a compromise between the approaches historically used in major browsers (Microsoft Internet Explorer using bubbling and Netscape using capture).
 events caused by l i execution will be processed (and, therefore, their associated listeners executed) before l
Example 1. Fig. 2 shows an excerpt of a DOM tree and the listeners registered to the event types e node for each event type are listed in the registration order (the listeners registered for the capture phase appear as lc ones registered for the bubbling phase appear as lb xyz ). At the bottom of the they would be executed in the case of receiving the event-type e lc 313 fi res the event-type e 2 on the node n 4. The fi rst listeners executed are lc listeners associated to the event type e 1 on the capture phase for the root node ( n phase for the nodes in the path from the root to the target node are triggered: that is, lc addition, as lc 313 fi res the event-type e 2 on the node n Note that there are not listeners for e 2 in other nodes.
 target element n 3 (speci fi cally, functions lb 311 and lb the path from the target to the root node ( lb 211 for n 2 will see in Section 3.1 , this will have implications for the recording process in our system. 2.2. Asynchronous functions and scripts execution model
In this section we describe the model we use to represent how the browser executes the scripting code of the listeners associated to an event. This model is veri fi ed by the major commercial browsers.
The script engine used by the browser executes scripts sequentially in a single-thread mode. The scripts invoked by the the order speci fi ed by the queue.
 listeners are executed sequentially.

The complexity of this model is slightly increased because the code of a listener can execute asynchronous functions. An provided as parameter in the asynchronous function invocation will be called when the action server response is received, the callback function is invoked to process it.
 It is important to notice that, from the described execution model, the following property is inferred: scripts associated to that event have fi nished .
 always be positioned after them in the execution queue, even if the background action executed by the asynchronous call is instantaneous. 3. Description of the solution 3.1. Recording user events during the execution phase.
 user action consists of detecting which events are issued and locating the target node of those events. registers its own listeners for the most common events involved in navigations (mainly clicks and the events involved in paper, we will call this approach  X  implicit  X  recording process.
 much wider set of user actions (e.g. placing the mouse over an element, changing the value of a user actions: tables, images, texts, etc. ensures that all events reach the root). Registering listeners for every event has the important drawback that it would
To overcome this fi rst problem, we need a new method for recording user actions (we will call it  X  and fi lls in the value of certain form fi elds in a pop-up window instead of in the
This way, we do not need to add a new listener: we know the target element by capturing the coordinates at where the mouse the events we need to record because the user explicitly selects the action to perform. every time a key is pressed) and change (issued when an element content changes). explain in Section 3.2 how this information is obtained in our system). For instance, the node may be identi clicks on a button with the label  X  Edit  X  and one listener triggered by this action changes the button label to incorrectly use the label  X  Save  X  instead of the label  X  because the listeners could remove it.
 be sure that no event alters the state of the page before the action is speci user on the page and, therefore, temporarily deactivating them is not an option.
 phase, we will describe how to do it in Section 3.3 . 3.2. Identifying elements be automatically reproduced at the execution phase.
 anyway and automatic maintenance techniques need to be used (we have addressed that problem in Ref. [22] ). purposes, we need to ensure that the generated expression on one hand identi uniquely identi fi es the target element. The algorithm we use for this purpose is presented in Section 3.2.1 .
In addition, the generated expressions should not be sensible to the use of session identi work in any later session. Section 3.2.2 presents a mechanism to remove the session identi 3.2.1. Algorithm for identifying target elements This section describes the algorithm for generating the expression to identify the target element of a user action.
As has already been said, the algorithm starts from a very simple XPath expression and progressively augments it until it uniquely identi fi es the target element. More precisely, the algorithm value of their attributes) will be considered one by one until the root is reached.
DOM tree. In the while loop, we add attributes one by one to the expression until either n is uniquely identi of n i , have been added.

A special case is considered at the beginning of the repeat loop: when adding either the text of n the expression is enough to uniquely identify n , we do not need to enter the while loop to consider the attributes of n elements identi fi ed by the expression to the XPath expression. Note that the algorithm only uses the as a last resort, since it is very sensitive to small changes in the page.

Fig. 5 shows an example where the algorithm is used to generate the XPath expression to identify the grayed DIV node. The fi gure shows the value of X after each iteration. 3.2.2. Removing session IDs very sensitive to small changes in the page). For instance, consider a list of identically formatted items with a besides each item. The only way to distinguish the  X  More Info position, is by using its URL attribute, since their text and path are the same.

It is worth noticing that using URLs introduces a dependency with the structure of the site. Nevertheless, when the site [22] should be used in that case.

Unfortunately, there is not a global standard to specify the session identi technologies have de fi ned their own standards. For instance, JEE applications usually include the identi http://www.acme.com/doOperation;jsessionid=F8DC3...A8DA?id=12 .

Our prototype implementation recognizes the main s tandard formats for including the session identi Therefore, we propose an algorithm to post-process the XPath expressions to generalize the value of attributes containing parts, then it is irrelevant for the purpose of identifying an element in the DOM tree by the value of its attributes.
The basic idea of the algorithm derives directly from the above observations: value in all the URLs in which they appear and ignore their values for identi to notice that the session ID removal does not have side effects because the page is not modi Fig. 6 gives the algorithm to generate the expression for a node n .

Fig. 7 shows a simple example of the algorithm where n is the grayed node in the with the same path). Therefore, they are considered irrelevant for node identi standard function for applying regular expressions). 3.3. Execution phase
The generation phase generates a program capturing the navigation sequence recorded by the user. The execution phase runs the program in the automatic navigation component.

A fi rst consideration is that we opt to use the APIs of commercial web browsers to implement the automatic web navigation components instead of the alternative approach of building a simpli that AJAX-based websites make an intensive use of scripting languages and support quite a complex event model. Creating a extremely vulnerable to small implementation differences that can make a web page behave incorrectly or differently when accessed with the custom browser than when accessed with a have been implemented in both Microsoft Internet Explorer and Mozilla Firefox.

To reproduce each action in the navigation sequence, there are three steps involved: 1. Locating the target node in the DOM tree of the page. 2. Generating the recorded event (or list of events) on the identi to be completed (e.g. the action n +1 can generate an event on a node generated in the action n ). described in Section 3.1 .

In turn, step 3 is dif fi cultbecausebrowserAPIsdonotprovideanywayofdetectingwhentheeffectsonthepageofissuinga fi those circumstances, then we are introducing an unnece ssary delay when the server is responding normally.
The remainder of this section explains the method we propose to detect when the effects caused directly or indirectly by a assumptions stated in Section 2 , which are veri fi ed by the major commercial browsers.
The method we use to detect when the effects of an event-type e generated on a node n have executed after all the listeners triggered by the execution of e have asynchronous calls, then the control arriving to cf would indicate that the effects of e had listeners can actually execute other asynchronous calls, this is not enough. 2. To be noti fi ed of every asynchronous call executed by the listeners triggered by e , we rede providing our own implementation of them (for instance, in Javascript we need to rede functions used to execute AJAX requests such as XMLHTTPRequest ). The template of our implementation of each function is then decreases the counter. This way, the counter always takes the value of the number of currently active calls. are all 0, we know the asynchronous calls have fi nished and execution can proceed. 4. There may be some cases where the effects of e never actually function is used. This function executes the callback function at speci noti fi es the user so she/he can specify the desired action, which can be to wait a complete.
 end of the effects of this event have fi nished, using the same technique used for the rest of the events.
We fi nalize the section explaining how to deal with two special cases: 1) There might be speci sent when this situation is detected, the wait for their effects is cancelled. 4. Evaluation
To evaluate the validity of our approach, we fi rst tested the implementation of our techniques in both the recording and execution phases with a wide range of AJAX-based web applications. Secondly, we compared our approach with several widely used web automation tools. Sections 4.1 and 4.2 respectively describe the obtained results. 4.1. Evaluation with AJAX websites
In this stage, we performed two kinds of experiments: purpose of the site. For instance, in electronic shops we automated the process of searching products; in webmail sites we automated the process required to access e-mails (see Fig. 1 for an example of an actual sequence we tested: a navigation sequence that accesses the content of the fi rst message in the Inbox folder of a Gmail account). complexexamples,sinceinmanycasestheapplicationswereverysimpleorwerecontainedinothers).InRef. [31] ,itcanbefound generated in the Internet Explorer were manually modi fi ed to
The results of the evaluation were encouraging (see Table 1 ). In Table 1 , the column named browser. In the fi rst set of experiments (real websites), 74 of 75 sequences were recorded and executed correctly. query parameter which changed every time the page was reloaded. Apparently this parameter is not a session identi changes its value during the same session. If the recorded XPath expression is modi parameter, then the sequence works fi ne at the execution phase.
 sequence; this way, if an element cannot be identi fi ed using the information). Another option would be allowing the user to provide several examples of the same sequence; this way, those parameters could be easily detected. Nevertheless, it would make the process signi
The second group of tests was completely successful in GWT applications, while in the Yahoo Toolkit case only one sequence corrected, the sequence could be recorded. 4.2. Comparison with other tools
To further validate our approach, we have compared it with other relevant web automation tools in both the recording and downloadable version.
 [8] APIs for generating AJAX applications (see [31] for more detail). The obtained results are shown in Table 2 . recorded because some of the elements participating in the sequence are not shown or behave improperly in Kapow's browser. be executed either. The other cause of failure in Kapow is that it did not support actions such as drag and drop. these tools at this stage are:  X  or drag and drop.  X 
The second problem with implicit approaches mentioned in Section 3.1 also affected Sahi and Selenium in these experiments: has been performed. Therefore, if the action changes the state or the position in the DOM tree of the element, they could generate incorrect identi fi cation commands and the sequence will fail at execution time.  X 
In some cases, they did not correctly record some user actions, although in principle they were supported. For instance, website and, therefore, the generated sequence was incorrect. This situation happened more frequently in Selenium than in Sahi and this explains most of the difference in their success ratio.

In the execution stage, both Selenium and Sahi have signi is that they allow manually programming navigation sequences using scripts. The script languages of both tools support the actions that cannot be recorded, and they also allow manual speci those scripts requires certain programming expertise.
 still happened in some situations. 5. Related work
Building complete web automation applications requires solving several dif automation. An area that has received much attention from the research community is automatically or semi-automatically occur in the website, has also been studied (see [22] and [11] for a survey). How to easily specify the execution work browsing sequences.

In the academic arena, WebVCR [2] , WebMacros [24] and Wargo [21] were pioneer systems for generating web navigation language scripts (such as  X  type Danny into fi rst name fi have considered: HtmlUnit [10] , Selenium [26] and Sahi [25] .

In the commercial arena, we have considered QEngine [23] , which is another package for web applications testing and iOpus wrappers. In this paper we consider only their capabilities for recording and executing navigation sequences. the moment of writing (see references). Sections 5.1, 5.2 and 5.3 respectively describe the characteristics analyzed. 5.1. Recording process
Most of the considered systems [2,13,14,18,20,21,23  X  26] use the
Older systems [2,21,24] are only able to record a reduced set of events (clicks and elements (mainly anchors and form-related elements) and, therefore, cannot be successfully used with AJAX websites. still limited in the same way as in the older tools. Most of the systems support the manual speci reduced set of events or suffering from  X  event fl ooding the mouse over the target element for more than a certain timeout (thereby avoiding the browsing: the user changes the left mouse button for the right mouse button and approach.

Kapow [15] uses a navigation sequence recording process that can also be considered as problemcannothappeninourcase.Inaddition,Kapowdoesnot support all actions: for instance, drag and drop operations.
Finally, HtmlUnit [10] does not provide a recording tool (sequences are created using Java). 5.2. Identifying elements techniques
Some systems [2,14,21,23  X  25] use the text associated to the elements and the value of some speci associated label, using the text cannot always work. In complex websites, it is also frequent that some elements cannot unambiguously be identi fi ed only by the value of their attributes.

Smart Bookmarks [13] can also generate full XPath expressions pointing to the target element when the above strategy does TD [5] /DIV [2] ) and, therefore, they are not resilient to small changes on the page.
Selenium generates XPath expressions to identify the target element trying to make them resilient to changes, but they to deal with more cases.
 algorithm are not reported.
 for text fi elds). On one hand, it is frequent that some elements cannot unambiguously be identi example, clicks in links and typing text in forms).

Ref. [16] uses relative XPath expressions to improve the robustness of the web content extraction. They de [5,6,17] the user provides several example pages identifying the target element and the system induces a generalized XPath expression. But this approach forces the user to record the navigation sequence several times. automatic maintenance techniques [22] should be used. 5.3. Automatic execution component
In the execution phase, WebVCR [2] and WebMacros [24] rely on simple HTTP clients that lack the ability to execute complex scripting code or to support AJAX requests.
 drawbacks: 1) it forces the user to manually identify in each step the element to wait for, and 2) depend on are loaded, simply waiting for the element to appear is not enough.
 visual coordinates of elements in the page, which are only available after rendering.
Most of the proposed crawlers use HTTP clients that cannot execute complex scripting code or support AJAX requests. An exception is Ref. [1] , where crawling processes are based on automated client-side scripting code. However, they do not consider any other type of elements. 6. Conclusions and future work techniques using screenshots.

References
