 We investigated the problem of finding from a collection of strings those similar to a given query string based on edit distance, for which the critical operation is merging inverted lists of grams generated from the collection of strings. We present an efficient algorithm to accelerate the merging op-eration.
 H.3.3 [ Information Systems ]: Search process Algorithms, Experimentation Approximate String Search
Approximate string searching is very important and has attracted great attention with its ever increasing applica-tions in Web service-based environment, such as data clean-ing, query suggestion, spell checking, etc., where a prereq-uisite is supporting instant feedbacks to many users, and any improvements on the search algorithm will have a great impact on the overall system performance.

A query used for approximate string search finds from a collection of strings those similar to a given string. The similarity between two strings can be measured by different metrics such as edit distance, Jaccard similarity, and cosine similarity. In this paper, we focus on similarity search with edit distance thresholds. A broadly adopted method is using q -gram based strategy, which assumes that inverted lists of q -grams generated from the strings are built in advance [2 X  4], and works in two steps: (1) find from a set of lists the candidate strings; (2) apply the similarity function on the candidates to eliminate false positives. Similar to existing methods [2, 3], we aims at efficiently computing the set of candidates in the first step. Let characters in is the substring of s from the i -th to j -th character.
Q -Grams : For a given positive integer q , a positional q -gram of a given string s is a pair ( i, g ), where g is the q -gram of s starting at the i -th character, that is g = s [ i, i + q  X  1]. For example, if q = 2, and s = sigir, we have the set of q -grams G ( s, q )= { (1,si),(2,ig),(3,gi),(4,ir) } . For simplicity, the positional information is omitted in the following discussion.
Approximate String Search : For two strings s 1 and s 2, the edit distance of s 1 and s 2 is the minimum number of edit operations (insertion, deletion, and substitution) on sin-gle character needed to transform s 1 to s 2, which is denoted as ed ( s 1 , s 2) in our discussion. For example, ed( X  X igir X ,  X  X ig-mod X ) = 3. Let M be a collection of strings and Q the query string, the problem can be stated as: finding all s  X  M such that ed ( s, Q )  X  k for a given threshold k .

According to the result of [1], if for two strings s 1 and s 2, ed ( s 1 , s 2) = k , then they have at least t common grams, where t = max ( | s 1 | , | s 2 | )  X  q + 1  X  qk . Therefore for a given query string Q , the problem of computing candidate strings can be solved by finding the set of string ids that appear at least t times on the inverted lists of the grams of Q .
For a given string query Q with m grams q 1 , q 2 , ..., q each q i corresponds to a list L i of sorted ids, L i is associated with a cursor C i pointing to some element of L i . Henceforth,  X  C i  X  X r X  X lement C i  X  X efers to the element C i points to, when there is no ambiguity. The cursor can move to the element (if any) next to element C i using advance ( C i ). Initially, all cursors point to the first elements of the corresponding lists.
Assume that for each list L i , all elements before C i have been processed, and without loss of generalization, we use C ( C m ) to denote the list with the minimum (maximum) cursor value, i.e., C 1  X  C 2  X  ...  X  C m , then we have the following result.

Lemma 1. Assume that each cursor C i (1  X  i  X  m ) points to the first element of L i , then any element e of list L j  X  t  X  1) satisfying C 1  X  e &lt; C t is impossible to appear at least t times.

Proof. Since all cursors point to the first elements of the set of lists, e is impossible to appear in L t since C t is the first element of L t . For the same reason, e would not appear in L j ( t &lt; j  X  m ). Thus e will not appear in all lists at least t times.

Lemma 1 tel ls us that all elements that are less than C t can be safely discarded initially. Accordingly, the basic idea of our method is to use C t as the eliminator to probe list L (1  X  i &lt; t ) until C i  X  C t . If C t satisfies the requirements, output it as a candidate answer and move it to the next element.
Algorith m 1 : SEJoin( t, L 1 , L 2 , ..., L m )
As shown in Algorithm 1, in each iteration (line 2-18), we first sort all lists according to their cursor values (line 3), such that after the sort operation, we have C 1  X  C 2 ...  X  C m . In line 5-15, we probe all lists in the direction from 1 to m , and increase the counter k by 1 if C i = C t (line 12-13). Note that pos ( C i ) is used to get the position of C i in L i , seqentialScan() (line 10) is used to sequentially scan each element to make comparison with C t , which is in-voked only when the matched element 1 of C t is located very close to C i in L i (less than  X  elements). In our experiment, matched element of C t in L i is located far away from C i thus we use indexLookup() to find the matched element for C . According Lemma 1 and Algorithm 1, we have the fol-lowing theorem, the correctness is obvious and we omit the proof for limited space.

Theorem 1. According to Algorithm 1, at any time, any element e of list L j (1  X  j &lt; t ) satisfying C 1  X  e &lt; C cannot be a candidate answer.

Compared with existing methods [2,3], the difference lies in three aspects: (1) the eliminator element C t that is used to conduct lookup operation on other lists is selected dy-namically according to cursors values, not the length of lists, so as to skip more useless elements if possible; (2) be-fore conducting lookup operation, we first check whether the matched element of C t in L i is located close to C i so as to take advantage of the benefits of sequential scan operation For a given number n , the matched element n i of n in list L i is the first element that satisfies n i  X  n . (line 10 in Algorithm 1); (3) when finding the matched ele-ment by calling indexLookup(), unlike existing search meth-ods, e.g., binary search, galloping search and interpolation search, that use a single strategy to reduce the search scope, our method uses binary search to quickly shrink the search interval (line 3-10 in Function indexLookup()) if its length is greater than  X  ; otherwise, we use sequential scan opera-tion to complete the index lookup operation (line 11-15 in Function indexLookup()). We have conducted experiments to verify the efficiency of SEJoin algorithm by comparing it with the MergeSkip [2] algorithm. We implement both the MergeSkip and SEJoin algorithms using Visual C++. We use DBLP dataset and generate lists of 2-grams for strings. We have compared 24 query strings containing 4 to 11 grams, of which the longest inverted list contains 115947 ids, and the shortest list con-tains 616 ids. In our experiment, t = n  X  2, where n is the number of grams for a query string.

As shown in Figure 1, SEJoin is more efficient than MergeSkip algorithm for all queries. The reason lies in that the elimi-nator used to probe other lists comes from the t th list, and the index lookup operation used in our method will firstly check whether the matched id for the current eliminator is located close to the cursor of the probed list, so as to take advantage of the sequential scan operation. In this paper, we presented a novel algorithm, namely SEJoin, for efficient processing of approximate string search. The experimental results verified the performance advantage of our method.

Acknowledgments: This research was partially sup-ported by the grants from the National Natural Science Foundation of China (No.61073060, 61040023). [1] P. Jokinen and E. Ukkonen. Two algorithms for [2] C. Li, J. Lu, and Y. Lu. Efficient merging and filtering [3] S. Sarawagi and A. Kirpal. Efficient set joins on [4] Z. Yang, J. Yu, and M. Kitsuregawa. Fast algorithms
