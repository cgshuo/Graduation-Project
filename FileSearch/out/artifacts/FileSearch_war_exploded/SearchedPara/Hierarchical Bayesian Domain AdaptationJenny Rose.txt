 The goal of multi-task learning is to improve perfor-mance on a set of related tasks, when provided with (potentially varying quantities of) annotated data for each of the tasks. It is very closely related to domain adaptation , a far more common task in the natural language processing community, but with two pri-mary differences. Firstly, in domain adaptation the different tasks are actually just different domains. Secondly, in multi-task learning the focus is on im-proving performance across all tasks, while in do-main adaptation there is a distinction between source data and target data, and the goal is to improve per-formance on the target data. In the present work we focus on domain adaptation, but like the multi-task setting, we wish to improve performance across all domains and not a single target domains. The word domain is used here somewhat loosely: it may refer to a topical domain or to distinctions that linguists might term mode (speech versus writing) or regis-ter (formal written prose versus SMS communica-tions). For example, one may have a large amount of parsed newswire, and want to use it to augment a much smaller amount of parsed e-mail, to build a higher quality parser for e-mail data. We also con-sider the extension to the task where the annotation is not the same, but is consistent, across domains (that is, some domains may be annotated with more information than others).

This problem is important because it is omni-present in real life natural language processing tasks. Annotated data is expensive to produce and limited in quantity. Typically, one may begin with a con-siderable amount of annotated newswire data, some annotated speech data, and a little annotated e-mail data. It would be most desirable if the aggregated training data could be used to improve the perfor-mance of a system on each of these domains.

From the baseline of building separate systems for each domain, the obvious first attempt at domain adaptation is to build a system from the union of the training data, and we will refer to this as a second baseline. In this paper we propose a more principled, formal model of domain adaptation, which not only outperforms previous work, but maintains attractive performance characteristics in terms of training and testing speed. We also show that the domain adapta-tion work of (Daum  X e III, 2007), which is presented as an ad-hoc  X  X reprocessing step, X  is actually equiv-alent to our formal model. However, our representa-tion of the model conceptually separates some of the hyperparameters which are not separated in (Daum  X e III, 2007), and we found that setting these hyperpa-rameters with different values from one another was critical for improving performance.

We apply our model to two tasks, named entity recognition, using a linear chain conditional random field (CRF), and dependency parsing, using a dis-criminative, chart-based model. In both cases, we find that our model improves performance over both baselines and prior work. 2.1 Motivation We call our model hierarchical Bayesian domain adaptation , because it makes use of a hierarchical Bayesian prior. As an example, take the case of building a logistic classifier to decide if a word is part of a person X  X  name. There will be a param-eter (weight) for each feature, and usually there is a zero-mean Gaussian prior over the parameter val-dard, single-domain, case the log likelihood of the data and prior is calculated, and the optimal pa-rameter values are found. Now, let X  X  extend this model to the case of two domains, one containing American newswire and the other containing British newswire. The data distributions will be similar for the two domains, but not identical. In our model, we have separate parameters for each feature in each domain. We also have a top level parameter (also to be learned) for each feature. For each domain, the Gaussian prior over the parameter values is now centered around these top level parameters instead of around zero. A zero-mean Gaussian prior is then placed over the top level parameters. In this ex-ample, if some feature, say word= X  X igel, X  only ap-pears in the British newswire, the corresponding weight for the American newswire will have a sim-ilar value. This happens because the evidence in the British domain will push the British parameter to have a high value, and this will in turn influence the top-level parameter to have a high value, which will then influence the American newswire to have a high value, because there will be no evidence in the American data to override the prior. Conversely, if some feature is highly indicative of isName=true for the British newswire, and of isName=false for the American newswire, then the British parameter will have a high (positive) value while the American parameter will have a low (negative) value, because in both cases the domain-specific evidence will out-weigh the effect of the prior. 2.2 Formal Model Our domain adaptation model is based on a hierar-chical Bayesian prior, through which the domain-specific parameters are tied. The model is very general-purpose, and can be applied to any discrim-inative learning task for which one would typically put a prior with a mean over the parameters. We will build up to it by first describing a general, single-domain, discriminative learning task, and then we will show how to modify this model to construct our hierarchical Bayesian domain adaptation model. In a typical discriminative probabilistic model, the learning process consists of optimizing the log con-ditional likelihood of the data with respect to the pa-rameters, L orig ( D ;  X  ) . This likelihood function can take on many forms: logistic regression, a condi-tional Markov model, a conditional random field, as well as others. It is common practice to put a zero-mean Gaussian prior over the parameters, leading to the following objective, for which we wish to find the optimal parameter values: From a graphical models perspective, this looks like Figure 1(a), where  X  is the mean for the prior (in our case, zero),  X  2 is the variance for the prior,  X  are the parameters, or feature weights, and D is the data. Now we will extend this single-domain model into a multi-domain model (illustrated in Figure 1(b)). Each feature weight  X  i is replicated once for each domain, as well as for a top-level set of parame-ters. We will refer to the parameters for domain d as  X  d , with individual components  X  d level parameters as  X  tively as  X  . All of the power of our model stems from the relationship between these sets of param-eters. First, we place a zero-mean Gaussian prior over the top level parameters  X  level parameters are used as the mean for a Gaussian prior placed over each of the domain-specific param-eters  X  d . These domain-specific parameters are then the parameters used in the original conditional log likelihood functions for each domain. The domain-specific parameter values jointly influence an appro-priate value for the higher-level parameters. Con-versely, the higher-level parameters will largely de-termine the domain-specific parameters when there is little or no evidence from within a domain, but can be overriden by domain-specific evidence when it clearly goes against the general picture (for instance Leeds is normally a location , but within the sports domain is usually an organization (football team)).
The beauty of this model is that the degree of in-fluence each domain exerts over the others, for each parameter, is based on the amount of evidence each domain has about that parameter. If a domain has a lot of evidence for a feature weight, then that evi-dence will outweigh the effect of the prior. However, when a domain lacks evidence for a parameter the opposite occurs, and the prior (whose value is deter-mined by evidence in the other domains) will have a greater effect on the parameter value.

To achieve this, we modify the objective func-tion. We now sum over the log likelihood for all do-mains, including a Gaussian prior for each domain, but which is now centered around  X  parameters. Outside of this summation, we have a Gaussian prior over the top-level parameters which is identical to the prior in the original model: L the parameters for all the domains, as well as the top-level parameters. The graphical models repre-sentation is shown in Figure 1(b).

One potential source of confusion is with respect to the directed or undirected nature of our domain adaptation model, and the underlying model of the data. Our hierarchical Bayesian domain adaptation model is directed , as illustrated in Figure 1. How-ever, somewhat counterintuitively, the underlying (original) model of the data can be either directed or undirected , and for our experiments we use undi-rected, conditional random field-based models. The directed domain adaptation model can be viewed as a model of the parameters, and those parameter weights are used by the underlying data model. In Figure 1, the entire data model is represented by a single node, D , conditioned on the parameters,  X  or  X  . The form of that model can then be almost any-thing, including an undirected model.

From an implementation perspective, the objec-tive function is not much more difficult to implement than the original single-domain model. For all of our experiments, we optimized the log likelihood using L-BFGS, which requires the function value and par-tial derivatives of each parameter. The new partial derivatives for the domain-specific parameters (but not the top-level parameters) utilize the same par-tial derivatives as in the original model. The only change in the calculations is with respect to the pri-ors. The partial derivatives for the domain-specific parameters are: and the derivatives for the top level parameters  X  are: This function is convex. Once the optimal param-eters have been learned, the top level parameters can be discarded, since the runtime model for each domain is the same as the original (single-domain) model, parameterized by the parameters learned for that domain in the hierarchical model. However, it may be useful to retain the top-level parameters for use in adaptation to further domains in the future.
In our model there are d extra hyper-parameters each domain. When this value is large then the prior has little influence, and when set high enough will be equivalent to training each model separately. When this value is close to zero the prior has a strong in-fluence, and when it is sufficiently close to zero then it will be equivalent to completely tying the param-eters, such that  X  d having many more parameters, for both of the tasks on which we performed experiments, we found that our model did not take much more time to train that a baseline model trained on all of the data concate-nated together. 2.3 Model Generalization The model as presented thus far can be viewed as a two level tree, with the top-level parameters at the root, and the domain-specific ones at the leaves. However, it is straightforward to generalize the model to any tree structure. In the generalized version, the domain-specific parameters would still be at the leaves, the top-level parameters at the root, but new mid-level parameters can be added based on beliefs about how similar the various domains are. For instance, if one had four datasets, two of which contained speech data and two of which con-tained newswire, then it might be sensible to have two sets of mid-level parameters, one for the speech data and one for the newswire data, as illustrated in Figure 1(c). This would allow the speech domains to influence one another more than the newswire do-mains, and vice versa. 2.4 Formalization of (Daum  X  e III, 2007) As mentioned earlier, our model is equivalent to that presented in (Daum  X e III, 2007), and can be viewed tion, the adapation is done through feature augmen-tation. Specifically, for each feature in the original version, a new version is created for each domain, as well as a general, domain-independent version of the feature. For each datum, two versions of each orig-inal feature are present: the version for that datum X  X  domain, and the domain independent one.

The equivalence between the two models can be shown with simple arithmetic. Recall that the log likelihood of our model is: We now introduce a new variable  X  d =  X  d  X   X  plug it into the equation for log likelihood: The result is the model of (Daum  X e III, 2007), where the  X  d are the domain-specific feature weights, and  X  d are the domain-independent feature weights. In mains d .

This separation of the domain-specific and inde-pendent variances was critical to our improved per-formance. When using a Gaussian prior there are two parameters set by the user: the mean,  X  (usu-ally zero), and the variance,  X  2 . Technically, each of these parameters is actually a vector, with an en-try for each feature, but almost always the vectors are uniform and the same parameter is used for each feature (there are exceptions, e.g. (Lee et al., 2007)). Because Daum  X e III (2007) views the adaptation as merely augmenting the feature space, each of his features has the same prior mean and variance, re-gardless of whether it is domain specific or indepen-dent. He could have set these parameters differently, we explicitly represent different variances for each domain, as well as the top level parameters. We found that specifying different values for the domain specific versus domain independent variances sig-nificantly improved performance, though we found no gains from using different values for the differ-ent domain specific variances. The values were set based on development data. For our first set of experiments, we used a linear-chain, conditional random field (CRF) model, trained for named entity recognition (NER). The use of CRFs for sequence modeling has become stan-dard so we will omit the model details; good expla-nations can be found in a number of places (Lafferty et al., 2001; Sutton and McCallum, 2007). Our fea-tures were based on those in (Finkel et al., 2005). 3.1 Data We used three named entity datasets, from the CoNLL 2003, MUC-6 and MUC-7 shared tasks. CoNLL is British newswire, while MUC-6 and MUC-7 are both American newswire. Arguably MUC-6 and MUC-7 should not count as separate domains, but because they were annotated sepa-rately, for different shared tasks, we chose to treat them as such, and feel that our experimental results justify the distinction. We used the standard train and test sets for each domain, which for CoNLL cor-responds to the (more difficult) testb set. For details about the number of training and test words in each dataset, please see Table 1.
 One interesting challenge in dealing with both CoNLL and MUC data is that the label sets differ. CoNLL has four classes: person , organization , lo-cation , and misc . MUC data has seven classes: per-son , organization , location , percent , date , time , and money . They overlap in the three core classes ( per-son , organization , and location ), but CoNLL has one additional class and MUC has four additional classes.

The differences in the label sets led us to perform two sets of experiments for the baseline and hier-archical Bayesian models. In the first set of exper-iments, at training time, the model allows any la-bel from the union of the label sets, regardless of whether that label was legal for the domain. At test time, we would ignore guesses made by the model which were inconsistent with the allowed labels for restricted the model at training time to only allow legal labels for each domain. At test time, the do-main was specified, and the model was once again restricted so that words would never be tagged with a label outside of that domain X  X  label set. 3.2 Experimental Results and Discussion In our experiments, we compared our model to sev-eral strong baselines, and the full set of results is in Table 2. The models we used were: T
ARGET O NLY . Trained and tested on only the data A
LL D ATA . Trained and tested on data from all do-A
LL D ATA *. Same as A LL D ATA , but restricted D
AUME 07. Trained and tested using the same tech-D
AUME 07*. Same as D AUME 07, but restricted H
IER B AYES . Our hierarchical Bayesian domain H
IER B AYES *. Same as H IER B AYES , but re-
For all of the baseline models, and for the top level-parameters in the hierarchical Bayesian model, we used  X  = 1. For the domain-specific parameters, we used  X  d = 0 . 1 for all domains.

The H IER B AYES model outperformed all base-lines for both of the MUC datasets, and tied with the D AUME 07 for CoNLL. The largest improvement was on MUC-6, where H IER B AYES outperformed D
AUME 07*, the second best model, by 1 . 36%. This improvement is greater than the improvement made by that model over the A LL D ATA * baseline. To as-sess significance we used a document-level paired t-test (over all of the data combined), and found that H
IER B AYES significantly outperformed all of the baselines (not including H IER B AYES *) with greater than 95% confidence.

For both the H IER B AYES and D AUME 07 mod-els, we found that performance was better for the variant which did not restrict possible labels based on the domain, while the A LL D ATA model did ben-efit from the label restriction. For H IER B AYES and D
AUME 07, this result may be due to the structure of the models. Because both models have domain-specific features, the models likely learned that these labels were never actually allowed. However, when a feature does not occur in the data for a particular domain, then the domain-specific parameter for that feature will have positive weight due to evidence present in the other domains, which at test time can lead to assigning an illegal label to a word. This information that a word may be of some other (un-known to that domain) entity type may help prevent the model from mislabeling the word. For example, in CoNLL, nationalities, such as Iraqi and Ameri-can , are labeled as misc . If a previously unseen na-tionality is encountered in the MUC testing data, the MUC model may be tempted to label is as a location , but this evidence from the CoNLL data may prevent that, by causing it to instead be labeled misc , a label which will subsequently be ignored.

In typical domain adaptation work, showing gains is made easier by the fact that the amount of train-ing data in the target domain is comparatively small. Within the multi-task learning setting, it is more challenging to show gains over the A LL D ATA base-line. Nevertheless, our results show that, so long as the amount of data in each domain is not widely dis-parate, it is possible to achieve gains on all of the domains simultaneously. 4.1 Parsing Model We also tested our model on an untyped dependency parsing task, to see how it performs on a more struc-turally complex task than sequence modeling. To our knowledge, the discriminatively trained depen-dency model we used has not been previously pub-lished, but it is very similar to recent work on dis-criminative constituency parsing (Finkel and Man-ning, 2008). Due to space restrictions, we cannot give a complete treatment of the model, but will give an overview.
We built a CRF-based model, optimizing the like-lihood of the parse, conditioned on the words and parts of speech of the sentence. At the heart of our model is the Eisner dependency grammar chart-parsing algorithm (Eisner, 1996), which allows for efficient computation of inside and outside scores. The Eisner algorithm, originally designed for gen-erative parsing, decomposes the probability of a de-pendency parse into the probabilities of each attach-ment of a dependent to its parent, and the proba-bilities of each parent stopping taking dependents. These probabilities can be conditioned on the child, parent, and direction of the dependency. We used a slight modification of the algorithm which allows each probability to also be conditioned on whether there is a previous dependent. While the unmodified version of the algorithm includes stopping probabil-ities, conditioned on the parent and direction, they have no impact on which parse for a particular sen-tence is most likely, because all words must eventu-ally stop taking dependents. However, in the modi-fied version, the stopping probability is also condi-tioned on whether or not there is a previous depen-dent, so this probability does make a difference.
While the Eisner algorithm computes locally nor-malized probabilities for each attachment decision, our model computes unnormalized scores. From a graphical models perspective, our parsing model The score for a particular tree decomposes the same way in our model as in the original Eisner model, but it is globally normalized instead of locally nor-malized. Using the inside and outside scores we can compute partial derivatives for the feature weights, as well as the value of the normalizing constant needed to determine the probability of a particular parse. This is done in a manner completely analo-gous to (Finkel and Manning, 2008). Partial deriva-tives and the function value are all that is needed to
Features are computed over each attachment and stopping decision, and can be conditioned on the parent, dependent (or none, if it is a stopping deci-sion), direction of attachment, whether there is a pre-vious dependent in that direction, and the words and parts of speech of the sentence. We used the same features as (McDonald et al., 2005), augmented with information about whether or not a dependent is the first dependent (information they did not have). 4.2 Data For our dependency parsing experiments, we used LDC2008T04 OntoNotes Release 2.0 data (Hovy et al., 2006). This dataset is still in development, and includes data from seven different domains, la-beled for a number of tasks, including PCFG trees. The domains span both newswire and speech from multiple sources. We converted the PCFG trees into dependency trees using the Collins head rules (Collins, 2003). We also omitted the WSJ portion of the data, because it follows a different annotation remaining six domains, we aimed for an 75/25 data split, but because we divided the data using the pro-vided sections, this split was fairly rough. The num-ber of training and test sentences for each domain are specified in the Table 3, along with our results. 4.3 Experimental Results and Discussion We compared the same four domain adaptation models for dependency parsing as we did for the named entity experiments, once again setting  X  = 1 . 0 and  X  d = 0 . 1. Unlike the named entity experi-ments however, there were no label set discrepencies between the domains, so only one version of each domain adaptation model was necessary, instead of the two versions in that section.

Our full dependency parsing results can be found in Table 3. Firstly, we found that D AUME 07, which had outperformed the A LL D ATA baseline for the sequence modeling task, performed worse than the baseline here, indicating that the transfer of infor-mation between domains in the more structurally complicated task is inherently more difficult. Our model X  X  gains over the A LL D ATA baseline are quite small, but we tested their significance using a sentence-level paired t-test (over all of the data com-bined) and found them to be significant at p &lt; 10  X  5 . We are unsure why some domains improved while others did not. It is not simply a consequence of training set size, but may be due to qualities of the domains themselves. We already discussed the relation of our work to (Daum  X e III, 2007) in Section 2.4. Another piece of similar work is (Chelba and Acero, 2004), who also modify their prior. Their work is limited to two do-mains, a source and a target, and their algorithm has a two stage process: First, train a classifier on the source data, and then use the learned weights from that classifier as the mean for a Gaussian prior when training a new model on just the target data.
Daum  X e III and Marcu (2006) also took a Bayesian approach to domain adaptation, but structured their model in a very different way. In their model, it is assumed that each datum within a domain is either a domain-specific datum, or a general datum, and then domain-specific and general weights were learned. Whether each datum is domain-specific or general is not known, so they developed an EM based algo-rithm for determining this information while simul-taneously learning the feature weights. Their model had good performance, but came with a 10 to 15 times slowdown at training time. Our slowest de-pendency parser took four days to train, making this model close to infeasible for learning on that data.
Outside of the NLP community there has been much similar work making use of hierarchical Bayesian priors to tie parameters across multiple, similar tasks. Evgeniou et al. (2005) present a sim-ilar model, but based on support vector machines, to predict the exam scores of students. Elidan et al. (2008) make us of an undirected Bayesian trans-fer hierarchy to jointly model the shapes of differ-ent mammals. The complete literature on related multi-task learning is too large to fully discuss here, but we direct the reader to (Baxter, 1997; Caruana, 1997; Yu et al., 2005; Xue et al., 2007). For a more general discussion of hierarchical priors, we recom-mend Chapter 5 of (Gelman et al., 2003) and Chap-ter 12 of (Gelman and Hill, 2006). In this paper we presented a new model for domain adaptation, based on a hierarchical Bayesian prior, which allows information to be shared between do-mains when information is sparse, while still allow-ing the data from a particular domain to override the information from other domains when there is suf-ficient evidence. We outperformed previous work on a sequence modeling task, and showed improve-ments on dependency parsing, a structurally more complex problem, where previous work failed. Our model is practically useful and does not require sig-nificantly more time to train than a baseline model using the same data (though it does require more memory, proportional to the number of domains). In the future we would like to see if the model could be adapted to improve performance on data from a new domain, potentially by using the top-level weights which should be less domain-dependent.
 The first author is supported by a Stanford Graduate Fellowship. We also thank David Vickrey for his helpful comments and observations.
