 ALBERT BIFET, EIBE FRANK, GEOFF HOLMES, and BERNHARD PFAHRINGER, When applying boosting algorithms to build ensembles of decision trees using a stan-dard tree induction algorithm, the tree inducer has access to all the attributes in the data. Thus, each tree can model arbitrarily complex interactions between attributes in principle. However, often the full modeling power of unrestricted decision tree learners is not necessary to yield good accuracy, and it may even be harmful because it can lead to overfitting. Hence, it is common to apply boosting in conjunction with depth-limited decision trees, where the growth of each tree is restricted to a certain level. In this way, only a limited set of attributes can be used in each tree, but the risk of overfitting is reduced. In the extreme case, only a single split is allowed and the decision trees de-generate to decision stumps. Despite the fact that each restricted tree can only model interactions between a limited set of attributes, the overall ensemble is often highly accurate.

The method presented in this article is based on this observation. We present an algorithm that produces a classification model based on an ensemble of restricted deci-sion trees, where each tree is built from a distinct subset of the attributes. The overall model is formed by combining the log-odds of the predicted class probabilities of these trees using sigmoid perceptrons, with one perceptron per class. In contrast to boosting, which forms an ensemble classifier in a greedy fashion, building each tree in sequence and assigning corresponding weights as a by-product, our method generates each tree in parallel and combines them using perceptron classifiers by adopting the stacking approach [Wolpert 1992]. Because we are working in a data stream scenario, Hoeffd-ing trees [Domingos and Hulten 2000] are used as the ensemble members. They, as well as the perceptrons, can be trained incrementally, and we also show how ADWIN -based change detection [Bifet and Gavald ` a 2007] can be used to apply the method to evolving data streams.

There is existing work on boosting for data streams [Oza and Russell 2001b], but the algorithm has been found to yield inferior accuracy compared to bagging [Bifet et al. 2009a, 2009b]. Moreover, it is unclear how a boosting algorithm can be adapted to data streams that evolve over time: because bagging generates models independently, a model can be replaced when it is no longer accurate, but the sequential nature of boosting prohibits this simple and elegant solution. Because our method generates models independently, we can apply this simple strategy, and we show that it yields more accurate classifications than online bagging [Oza and Russell 2001b] on the real-world and artificial data streams that we consider in our experiments.

Our method is also related to work on building ensembles using random subspace models [Ho 1998]. In the random subspace approach, each model in an ensemble is trained based on a randomly chosen subset of attributes. The models X  predictions are then combined in an unweighted fashion. Because of this latter property, the number of attributes available to each model must necessarily be quite large in general, so that each individual model is powerful enough to yield accurate classifications. In contrast, in our method, we exhaustively consider all subsets of a given, small, size, build a tree for each subset of attributes, and then combine their predictions using stacking. In random forests [Breiman 2001], the random subspace approach is applied locally at each node of a decision tree in a bagged ensemble. Random forests have been applied to data streams, but did not yield substantial improvements on bagging in this scenario [Bifet et al. 2010b]. Another related weighted ensemble method is dynamic weighted majority [Kolter and Maloof 2007].

The article is structured as follows. The next section presents the new ensemble learner we propose. Section 3 details the set-up for our experiments. Section 4 presents the experimental comparison to bagging. In Section 5 we consider ensemble pruning and in Section 6 we evaluate the effect of using stacking rather than simple averaging to combine the trees X  predictions, and also consider the effect of different ADWIN -based classifier replacement strategies. Section 7 concludes. The basic method we present in this article is very simple: enumerate all attribute subsets of a given user-specified size k , learn a Hoeffding tree from each subset based on the incoming data stream, gather the trees X  predictions for each incoming instance, and use these predictions to train simple perceptron classifiers. The question that needs to be addressed is how exactly to prepare the  X  X eta X -level data for the percep-trons and what shape it should take.

Rather than using discrete classifications to build the meta-level model in stack-ing, it is common to use class probability estimates instead because they provide more information due to the fact that they represent the degree of confidence that each model has in its predictions. Hence, we also adopt this approach in our method: the meta-level data is formed by collecting the class probability estimates for an in-coming new instance, obtained from the Hoeffding trees built from the data observed previously.

The meta-level combiner we use is based on simple perceptrons with sigmoid acti-vation functions, trained using stochastic gradient descent to minimize the squared loss with respect to the actual observed class labels in the data stream. We train one perceptron per class value and use the Hoeffding trees X  class probability estimates for the corresponding class value to form the input data for each perceptron.

There is one caveat. Because the sigmoid activation function is used in the percep-trons, we do not use the raw class probability estimates as the input values for training them. Rather, we use the log-odds of these probability estimates instead. Let  X  p ( c ij | x ) be the probability estimate for class i and instance x obtained from Hoeffding tree j in the ensemble. Then we use as the value of input attribute j for the perceptron associated with class value i .
Let a i be the vector of log-odds for class i . The output of the sigmoid perceptron for use the log-odds as the inputs for the perceptron because application of the sigmoid function presupposes a linear relationship between log( f ( a i ) / (1  X  f ( a i ))) and a i .
To avoid the zero-frequency problem, we slightly modify the probability estimates obtained from a Hoeffding tree by adding a small constant to the probability for each class, and then renormalize. In our experiments, we use =0 . 001, but smaller values lead to very similar results.

The perceptrons are trained using stochastic gradient descent: the weight vector is updated each time a new training instance is obtained from the data stream. Once the class probability estimates for that instance have been obtained from the ensemble of Hoeffding trees, the input data for the perceptrons can be formed, and the gradient de-scent update rule can be used to perform the update. The weight values are initialized to the reciprocal of the size of the ensemble, so that the perceptrons give equal weight to each ensemble member initially.

A crucial aspect of stochastic gradient descent is an appropriately chosen learning rate, which determines the magnitude of the update. If it is chosen too large, there is a risk that the learning process will not converge. A common strategy is to decrease it as the amount of training data increases. Let n be the number of training instances seen so far in the data stream, and let m be the number of attributes. We set the learning rate  X  based on the following equation.
However, there is a problem with this approach for setting the learning rate in the context we consider here: it assumes that the training data is identically distributed. This is not actually the case in our scenario because the training data for the percep-trons is derived from the probability estimates obtained from the Hoeffding trees, and these change over time, generally becoming more accurate. Setting the learning rate based on the preceding equation means that the perceptrons will adapt too slowly once the initial data in the data stream has been processed.

There is a solution to this problem: the stream of predictions from the Hoeffding trees can be viewed as an evolving data stream (regardless of whether the underlying data stream forming the training data for the Hoeffding trees is actually evolving) and we can use an existing change detection method for evolving data streams to detect when the learning rate should be reset to a larger value. We do this very simply by setting the value of n to zero when change has been detected. To detect change, we use the ADWIN change detector [Bifet and Gavald ` a 2007], which is discussed in more detail in the next section. It detects when the accuracy of a classifier increases or decreases significantly as a data stream is processed. We apply it to monitor the accuracy of each Hoeffding tree in the ensemble. When accuracy changes significantly for one of the trees, the learning rate is reset by setting n to zero. The value of n is then incremented for each new instance in the stream until a new change is detected. This has the effect that the learning rate will be kept relatively large while the learning curve for the Hoeffding trees has a significant upward trend. The ADWIN change detector comes with theoretical guarantees on the ratio of false positives and the scale of change. In addition to using it to reset the learning rate when necessary, we also use it to make our ensemble classifier applicable to an evolving data stream, where the original data stream, used to train the Hoeffding trees, changes over time.

ADWIN maintains a window of observations and automatically detects and adapts to the current rate of change. Its only parameter is a confidence bound  X  , indicating the desired confidence in the algorithm X  X  output, inherent to all algorithms dealing with random processes. ADWIN does not maintain the window explicitly, but compresses it using a variant of the exponential histogram technique. Consequently it keeps a window of length W using only O (log W ) memory and O (log W ) processing time per item.

The strategy we use to cope with evolving data streams using ADWIN is based on the approach that has been used to make online bagging applicable to an evolving data stream in Bifet et al. [2009b]. The idea is to replace ensemble members when they start to perform poorly. To implement this, we use ADWIN to detect when the accuracy of one of the Hoeffding trees in the ensemble has dropped significantly. To do this, we can use the same ADWIN change detectors that are also applied to detect when the learning rate needs to be reset. When one of the change detectors associated with a particular tree reports a significant drop in accuracy, the tree is reset and the coefficients in the perceptrons that are associated with this tree (one per class value) are set to zero. A new tree is then generated from new data in the data stream, so that the ensemble can adapt to changes.

Note that all trees for which a significant drop is detected are replaced and that a change detection event automatically triggers a reset of the learning rate, which is important because the perceptrons need to adapt to the changed ensemble of trees. Our approach is based on generating trees for all possible attribute subsets of size k . If there are m attributes in total, there are m k of these subsets. Clearly, only moder-ate values of k , or values of k that are very close to m , are feasible. When k is one, there is no penalty with respect to computational complexity compared to building a single Hoeffding tree, because then there is only one tree per attribute, and an unre-stricted tree also scales linearly in the number of attributes. If k is two, there is an extra factor of m in the computational complexity compared to building a single unre-stricted Hoeffding tree, that is, the overall effort becomes quadratic in the number of attributes. k = 2 is very practical even for datasets with a relatively large number of attributes, although certainly not for very high-dimensional data (for which linear classifiers are usually sufficient anyway). Larger values of k are only practical for small numbers of attributes, unless k is very close to m (e.g., k = m  X  1). We have used k = 4 for datasets with 10 attributes in our experiments, with very acceptable runtimes. It is important to keep in mind that many practical classification problems appear to exhibit only very low-dimensional interactions, which means small values of k are sufficient to yield high accuracy. We have performed several experiments to investigate the performance and resources needed by our new method, and to compare to bagged Hoeffding trees. To measure use of resources, we use time and memory, and also RAM-Hours, a new evaluation measure introduced in Bifet et al. [2010c], where every RAM-Hour equals a GB of RAM deployed for 1 hour.

We performed our experiments using the Massive Online Analysis (MOA) frame-work [Bifet et al. 2010a], a data mining software environment for implementing al-gorithms and running experiments for evolving data streams. We implemented all algorithms in Java within the MOA framework. We used the default parameters of the classifiers in MOA. The experiments were performed on 2.66 GHz Core 2 Duo E6750 machines with 4GB of memory.

In the rest of this section we briefly describe the datasets and methods used (exclud-ing our new method, which was described in the previous section). We consider two types of data streams, synthetic ones and ones corresponding to real-world problems. To evaluate our method on real-world data, we use three dif-ferent datasets: two large datasets from the UCI repository of machine learning databases [Frank and Asuncion 2010], namely, Forest Covertype and Poker-Hand, and one other large dataset that has previously been used to study data stream methods, namely the Electricity dataset [Gama et al. 2004; Harries 1999]. In our experiments with these datasets all numeric attributes have been normalized to the [0 , 1] range.
Forest Covertype. This data contains the forest cover type for 30 x 30 meter cells obtained from US Forest Service (USFS) Region 2 Resource Information System (RIS) data. The data has 581,012 instances and 54 attributes. There are 7 classes. The data is often used to evaluate methods for data stream classification, for example, in Gama et al. [2003] and Oza and Russell [2001a].

Poker-Hand. This data contains 1,000,000 instances. Each instance in this dataset is an example of a hand consisting of five playing cards drawn from a standard deck of 52 cards. There are 10 predictor attributes in this data because each card is described using two attributes (suit and rank). The class attribute has 10 possible values and describes the poker hand, for example, full house. The cards are not ordered in the data and a hand can be represented by any permutation, which makes it very difficult to learn for propositional learners such as the ones that are commonly used for data stream classification. Hence, we use a modified version, in which cards are sorted by rank and suit and duplicates have been removed [Bifet et al. 2009b]. The resulting dataset contains 829,201 instances.

Electricity. The electricity data is described in Harries [1999] and has been used for data stream classification in Gama et al. [2004]. It originates from the New South Wales Electricity Market in Australia. In this market, prices are not fixed but set ev-ery five minutes, as determined by supply and demand. The data comprises 45,312 instances and 8 predictor attributes. The class label is determined based on the change of price relative to a moving average of the last 24 hours, yielding 2 class values.

In the data stream scenario, it is important to consider evaluation under concept drift. We can use the method from Bifet et al. [2009b] in conjunction with the aforesaid three datasets to create a data stream exhibiting concept drift. To this end, we assume the underlying distributions are fixed and then combine these  X  X ure X  distributions by modeling concept drift events as weighted combinations of two distributions. As originally suggested in Bifet et al. [2009b], the sigmoid function is used to define the probability that an instance is sampled from the  X  X ld X  stream X  X he one in place before the concept drift event X  X r the  X  X ew X  stream. In this way, two distributions are mixed using a soft threshold function. The exact specification of the operator used to combine two data streams is given in the following definition from Bifet et al. [2009b].
Definition 3.1. Given two data streams a , b , we define c = a  X  W t built by joining the two data streams a and b , where t 0 is the point of change, W is the b ( t )].

This operator can be applied repeatedly to introduce multiple concept change events, thus making it possible to combine multiple data streams into a single evolving data stream. Different parameters can be used for each change event. For example, the following expression corresponds to the combination of four data streams a , b , c , and d , joined with three parametrized change events: ((( a  X  W 0 t
We use this operator to join the preceding three real-world datasets into a sin-gle data stream that exhibits concept drift. More specifically, we define a new data stream
Note that, to perform the operation, we concatenate the lists of attributes from the three datasets, and the number of classes is set to the maximum number of classes amongst the three datasets. There is a shortage of publicly available large real-world datasets that are suitable for the evaluation of data stream methods. Thus we also consider synthetic data in our experiments. To avoid bias, we use synthetic data generators that are commonly found in the literature. Most of these data generators exhibit a mechanism that implements concept drift. For each generator, we use 1 million instances in our experiments.
Rotating Hyperplane. This data generator, introduced in Hulten et al. [2001], provides an elegant way of generating time-changing data for the evaluation of data stream classification. The data is generated based on hyperplanes whose orientation and position is varied smoothly over time. Classes are assigned to data points based on which side of a hyperplane they are located. The generator has a parameter that con-trols the speed of change. We use 10 predictor attributes for this data and 2 class values.

Random RBF Generator. This data generator, from Kirkby [2007], is also able to pro-duce time-changing data. Like the hyperplane generator, it produces data that is diffi-cult to model accurately using decision tree learners. It first generates a fixed number of radial basis functions with randomly chosen centroids and assigns weights and class labels to them. Data is then generated based on these basis functions, taking their relative weights into account. Concept drift is introduced by moving the centroids with constant speed, as controlled by a parameter. We use several variants of this data, varying the numbers of centroids and the speed of change, but keeping the number of predictor attributes constant at 10 and the number of class values fixed at 5.

LED Generator. This generator is one of the oldest data generators that can be found in the literature. It was introduced in Breiman et al. [1984] and a C implementation can be found in the UCI repository of machine learning databases [Frank and Asuncion 2010]. The task is to classify the 10 digits based on boolean attributes that corre-spond to the LEDs of a seven-segment LED display. Each attribute value has a 10% chance of being inverted, so the data includes noise. The variant of the data generator that we use additionally also generates 17 completely irrelevant attributes. Concept drift is controlled by a drift parameter that determines the number of attributes with drift.

Waveform Generator. This source of synthetic data was also introduced in the CART book [Breiman et al. 1984] and a C implementation is available from the UCI repos-itory. The data has three classes that correspond to three different waveforms. Each waveform is based on a combination of two or three base waves. As in the LED gener-ator, there is a drift parameter determining the number of attributes with drift. The data has 21 attributes.

Random Tree Generator. This generator, which is the only generator we use that does not implement concept drift, first constructs a decision tree by randomly choosing at-tributes to define splits for the internal nodes of the tree. It then assigns randomly chosen class labels to the leaf nodes of this tree. To generate data, it routes uniformly distributed synthetic instances down the appropriate paths in the tree and assigns class labels based on the corresponding leaf nodes. This generator was introduced in Domingos and Hulten [2000] and favors decision tree learners. We use it with 10 attributes and 5 class values. Hoeffding trees [Domingos and Hulten 2000] are state-of-the-art tree inducers in clas-sification for data streams. They exploit the fact that a small sample can often be enough to choose an optimal splitting attribute. This idea is supported mathematically by the Hoeffding bound, which quantifies the number of observations (in our case, ex-amples) needed to estimate some statistics within a prescribed precision (in our case, the goodness of an attribute). Using the Hoeffding bound one can show that the in-ducer X  X  output is asymptotically nearly identical to that of a nonincremental learner using infinitely many examples.

Hoeffding trees perform prediction by choosing the majority class at each leaf. Their predictive accuracy can be increased by adding naive Bayes models at the leaves of the trees. However, Holmes et al. [2005] identified situations where the naive Bayes method outperforms the standard Hoeffding tree initially but is eventually overtaken. They proposed a Hoeffding Naive Bayes Tree (hnbt), a hybrid adaptive method that generally outperforms the two original prediction methods for both simple and com-plex concepts. This method works by performing a naive Bayes prediction per training instance, comparing its prediction with the majority class. Counts are stored to mea-sure how many times the naive Bayes prediction gets the true class correct as com-pared to the majority class. When performing a prediction on a test instance, the leaf will only return a naive Bayes prediction if it has been more accurate overall than the majority class, otherwise it resorts to a majority class prediction.

Bagging using ADWIN [Bifet et al. 2009b] is based on the online bagging method of Oza and Russell [2001b] with the addition of the ADWIN algorithm to detect changes in accuracy for each ensemble member. It yields excellent predictive performance for evolving data streams. When a change is detected, the classifier of the ensemble with the lowest accuracy, as predicted by its ADWIN detector, is removed and a new classifier is added to the ensemble. We use ADWIN bagging to compare to our new ensemble learner, in both cases using hnbt as the base learner for the ensemble members. Our first experimental evaluation compares our new stacking method using restricted Hoeffding trees with bagging, and we use the datasets discussed in the previous section for this evaluation. The evaluation methodology used was Interleaved Test-Then-Train or Prequential evaluation (based on 10 runs for the artificial data): every example was used for testing the model before using it for training [Gama et al. 2009]. This interleaved test followed by train procedure was carried out on the full training set in each case. The parameters of the artificial streams are as follows.  X  RBF( x , v ): RandomRBF data stream of x centroids moving at speed v .  X  X YP( x , v ): Hyperplane data stream with x attributes changing at speed v .  X  RT: Random Tree data stream.  X  X  AVEFORM ( v ): Waveform dataset, with v as the value of the drift parameter.  X  X ED( v ): LED dataset, with v as the value of the drift parameter.

We test our method using restricted Hoeffding trees containing 1, 2, 3, and 4 at-tributes respectively, against bagging using ADWIN . We do not show results for online bagging [Oza and Russell 2001b] as in Bifet et al. [2009b] it was shown that bagging using ADWIN outperforms online bagging. Note that we use the average class probabil-ity estimates of the ensemble members in bagging, because we found that this yields better results than simply majority voting.

Results for a single Hoeffding Naive Bayes Tree (hnbt) are shown in Table I. Bag-ging using ADWIN (10 trees) in Table IV is at least 2% more accurate than hnbt on all but two of the datasets we used, P OKER -H AND and C OV P OK E LEC . The former dataset is the only one on which hnbt achieves substantially higher accuracy (77.1%) than bagging using ADWIN .

Tables II, III, and IV report the final accuracy, speed, and memory consumption of the ensemble classification models induced on the synthetic data and the real-world mixture of the three). Accuracy is measured as the final percentage of examples cor-rectly classified over the test/train interleaved evaluation. Time is measured in sec-onds, and memory in MB. Some methods did not complete (DNC in the tables) due to the lack of memory required by the new methods that generate a large number of ensemble members on some datasets. Because of this, averages are computed across those datasets that finished.

The results of our method for different values of k , and the comparison to bagging, show that excellent predictive performance can be obtained on the practical datasets for small values of k : even with k = 1, the proposed method outperforms bagging on the real-world datasets. Further substantial improvements can be obtained by moving from k =1to k = 2. These results indicate that modeling low-dimensional interactions is sufficient for obtaining good performance on the practical datasets we considered.

Note that, in a separate experiment, we have also investigated the effect of disabling the ADWIN -based change detection mechanism for resetting the learning rate. Disabling the mechanism yields a reduction in average accuracy of about 1.6% for n =2and0.9% for n = 3. This shows that change detection for resetting the learning rate is indeed beneficial.

Also, we note that bagging using ADWIN with 100 trees is no more accurate overall than using 10 trees. Hence, the good performance of our method is not due to the fact that it uses a larger number of trees. The combination of using attribute subsets and the perceptron weighting methodology is essential for the improvement in accuracy obtained.

As the RandomRBF, Random Tree, and Hyperplane data streams have 10 at-tributes, the number of attribute sets used by the restricted trees for these datasets are respectively. When the number of attributes is bigger than 15, the number of com-binations is huge as combinations grow exponentially. For example, for the F OREST C
OVER T YPE data with 54 attributes we obtain the following figures.
We observe that for k =2 m 2 = m  X  ( m  X  1) / 2 the number of possible combinations is relatively small, and we can run experiments on all datasets. However, for k =4, the number of combinations is so large m 4 = m  X  ( m  X  1)  X  ( m  X  2)  X  ( m  X  3) / 24 that for some datasets insufficient memory was available.

The learning curves and model growth curves for the ELECTRICITY dataset are plotted in Figures 1 and 2. We use the prequential method [Gama et al. 2009] with a sliding window of 1 , 000 examples to compute the learning curves. We observe that using k = 1 we obtain the fastest and most resource-efficient method, but also the worst in accuracy. On the other hand, with k = 3 we have the slowest method, the one that uses more RAM-hours, but also the most accurate. As we increase the complexity of the model using higher values for k , we use more resources, but we improve the method X  X  accuracy. ADWIN bagging appears to use a similar amount of RAM-hours as our method with k = 2, but its accuracy for this dataset is worse than with k =1.
The results on the artificial data yield a somewhat different picture. On these data streams, larger values of k are necessary in most cases to obtain classification ac-curacy that is competitive with bagging. This is not surprising given the functional relationships underlying the data generation processes. Nevertheless, competitive per-formance can be obtained with k =3or k =4.

Let us briefly consider our method in the case where each tree in the ensemble can access a large number of attributes, more specifically, close to the full number of attributes m . This case is interesting to consider because m k = m m  X  k , although using m  X  k as subset size does introduce an extra factor of m in overall time complexity. Table V shows results for our method using m  X  2and m  X  3 attributes, respectively. Predictive performance on the artificial data streams is very good compared to the low-dimensional cases considered previously (where k was small) because these data streams benefit from modeling higher-dimensional interactions. However, using small values of k is clearly preferable on the real-world data, yielding higher accuracy with lower resource use. We use the Kappa statistic  X  [Margineantu and Dietterich 1997] to show how using the new classifier based on stacking with restricted Hoeffding trees increases the diversity of the ensemble.

The Kappa statistic is a measure defined so that if two classifiers agree on every ex-ample then  X  = 1, and if their predictions coincide purely by chance, then  X  = 0. Given two classifiers h a and h b , and a dataset containing m examples, the Kappa statistic is based on a contingency table where cell C ij contains the number of examples for which h ( x )= i and h b ( x )= j .

The  X  statistic is defined formally as follows. The  X  statistic uses 2 for normalization, the probability that two classifiers agree by chance, given the observed counts in the table. If h a and h b make identical classifica-tions on the dataset, then all nonzero counts will appear along the diagonal. If h a and h b are very different, then there will be a large number of counts off the diagonal. This is used for 1 . We define We could use 1 as a measure of agreement, but in problems where one class is much more common than the others, all classifiers will agree by chance, so all pairs of clas-sifiers will obtain high values for 1 .

The Kappa-Error diagram consists of a plot where each point corresponds to a pair of classifiers. The x coordinate is the  X  value for the two classifiers concerned. The y coordinate is their average error.

Figures 3 and 4 show the Kappa-Error diagram for the hyperplane data stream with 10 attributes changing at speed 0.0001 and the Electricity dataset, repectively. As for k =2, k =3, k = m  X  2, and k = m  X  3, the number of classifiers is large; we only plot the points of the significant classifiers, the ones with higher perceptron weights, more specifically those that represent 90% of the total weight of the coefficients of the ensemble. The figures generally show that the new stacking method produces more diverse ensembles. The ADWIN bagging ensembles are tightly clustered whereas the stacking method produces more disagreement among classifiers in the ensemble. This is the case in particular for k =2and k = 3, as one would expect.
 Although the results on the real-world data streams show that small values of k are often sufficient to obtain accurate classifiers, it is instructive to consider whether it is possible, at least in principle, to prune the ensemble by reducing the number of classi-fiers, without losing accuracy. To investigate this, we performed a further experiment, using only those trees for prediction that exhibited the largest average coefficients in the perceptrons, where the average was taken across class values. Table VI shows the results for reduced sets of 10 and 40 classifiers, respectively, for k = 2. Even for 40 trees, performance is substantially below that of the full ensemble, indicating that a pruning strategy based on simply removing classifiers in this manner is not sufficient to maintain high accuracy. To conclude our experimental evaluation, we consider empirically if the components of the new method presented in this article can be easily applied to standard bagged decision trees, specifically:  X  the new strategy of replacement of ensemble classifiers: when one of the ADWIN estimators detects change, the classifier monitored by this estimator is replaced by a new one;  X  the use of stacking instead of majority voting as a combination mechanism for ob-taining the ensemble predictions.

We also considered the effect of averaging instead of stacking in our method, and the effect of using the old ADWIN -based classifier replacement strategy in our method.
First, we implemented ADWIN bagging*, an extension to ADWIN bagging with the same strategy of replacing the classifiers as our new stacking method with restricted Hoeffding trees. Table VII shows the results of this extension using 10 and 100 base classifiers. If we compare these results with the results for standard ADWIN bagging in Table IV, we observe that average accuracy increases for bagging with 100 trees and decreases with bagging with 10 trees. Looking at these results, it appears that the best strategy for a small number of trees is to replace the worst classifier when a change is detected in the accuracy of one of the learners. For large ensembles of classifiers, the best strategy is to replace the classifier that exhibited change. However, there are exceptions to this rule. Overall, the differences appear comparatively small.
Second, we tested the use of the other ADWIN strategy, replacing the worst classifier when change is detected, using the new method proposed in this article, stacking with restricted Hoeffding trees. Table VIII shows the results. Comparing this with the results in Tables II and III shows that the new replacement strategy is essential for stacked ensembles of restricted Hoeffding trees.

Third, we investigated whether it is necessary to train a perceptron to combine the trees X  predictions. To this end, we show results for simple averaging of the trees X  probability estimates in Table IX. We see that using the simple averaging mechanism we use the same resources, but obtain lower accuracy. Hence, combining predictions adaptively is clearly essential. This is due to the fact that not all attribute subsets (and, thus, Hoeffding trees) are equally relevant for prediction.

Finally, we tested using stacking to combine the bagged trees X  predictions, and we show results in Table X. Comparing these results with standard ADWIN bagging in Table IV or ADWIN bagging* in Table VII, we observe that using a perceptron to com-bine the prediction results of the base learners improves the global accuracy of the ensemble. It is interesting to observe that using 100 trees in standard ADWIN bagging did not improve global accuracy over using 10 trees, however, using the perceptron, as the contribution of every learner prediction is not the same, we improve global accu-racy of the ensemble. On real-world datasets, we note that looking at Tables II and III, limited-interaction trees still have an edge.

Considering the artificial datasets, the two best results overall reported in this arti-cle are for our new method with k = m  X  3 in Table V and for stacking 100 bagged trees in Table X. It is interesting to note that they have quite similar accuracy and an order of magnitude difference in the use of resources. Clearly the stacking procedure merits further investigation. This article has presented a new method for data stream classification that is based on combining an exhaustive ensemble of limited-attribute-set tree classifiers using stacking. The approach generates tree classifiers for all possible attribute subsets of a given user-specified size k .For k = 2, this incurs an extra factor of k in time complexity compared to building a single tree grown from all attributes. For larger values of k , the method is only practical for datasets with a small number of attributes (unless k is chosen to be close to the number of attributes). However, even if limited to k =2, the method appears to be a promising candidate for high-accuracy data stream classi-fication on practical data streams. Our results on real-world datasets show excellent classification accuracy.

Part of our method is an approach for resetting the learning rate for the perceptron meta-classifiers that are used to combine the trees X  predictions. This method, based on the ADWIN change detector, is employed because the metadata stream is not identically distributed: the trees X  predictions improve over time. When change is detected, the learning rate is reset to its initial, larger value, so that metalearning quickly adapts to the improved predictions of the base models.

The ADWIN change detector is also used to reset ensemble members when their pre-dictive accuracy degrades significantly, in which case the learning rate is reset also. This makes it possible to use the ensemble classifier for evolving data streams where the distribution changes over time. Promising results are demonstrated for applying the new classifier replacement strategy introduced in this article to bagging. When dealing with a large number of trees the best strategy is generally to replace the clas-sifier that exhibits an increased error rate.

We have empirically verified that it is important to use stacking to learn how to com-bine the tree classifiers X  predictions in an appropriate manner: simple averaging yields very poor accuracy. This is not surprising because not all attribute subsets are equally relevant. We have also shown that stacking can be beneficial for bagging. Our initial experiments with ensemble pruning, discarding the least important ensemble mem-bers, did not prove successful. In future work, we would like to investigate smarter pruning techniques and methods for preselecting attribute subsets, for example, based on using a diversity-based measure, or based on maximizing pairwise Hamming dis-tance between indicator vectors. We also plan to investigate whether using stacking to combine ensemble predictions is beneficial in nonstreaming settings.

