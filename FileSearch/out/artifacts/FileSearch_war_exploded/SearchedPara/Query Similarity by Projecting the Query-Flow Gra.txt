 Defining a measure of similarity between queries is an in-teresting and difficult problem. A reliable query-similarit y measure can be used in a variety of applications such as query recommendation, query expansion, and advertising.
In this paper, we exploit the information present in query logs in order to develop a measure of semantic similarity be-tween queries. Our approach relies on the concept of the query-flow graph. The query-flow graph aggregates query reformulations from many users: nodes in the graph rep-resent queries, and two queries are connected if they are likely to appear as part of the same search goal. Our query-similarity measure is obtained by projecting the graph (or appropriate subgraphs of it) on a low-dimensional Euclidea n space. Our experiments show that the measure we obtain captures a notion of semantic similarity between queries an d it is useful for diversifying query recommendations. H.3 [ Information Storage and Retrieval ]: Information Search and Retrieval Algorithms, Experimentation
Finding a measure of similarity between queries can be very useful to improve the services provided by search en-gines. First, the ability to identify similar queries is in t he core of any query-recommendation system. Second, query similarity can be used for performing query expansion. Ad-ditionally, a reliable notion of query similarity can be use d for broad matching of advertisements to queries, or even for suggesting keywords to advertisers. However, defining a Part of this work was done while visiting Yahoo! Research Labs, Barcelona query-similarity measure is not an easy task as it strongly d e-pends on user intent: syntactically similar queries may ori g-inate from completely different intents. Issues such as poly -semy, synonymy, high levels of noise, and the small amount of available information make the problem challenging.
In such a complex setting, information extracted from query logs has shown to be effective. The information on how users interact with search engines has often been used to improve the user search experience. In particular, query -log analysis is used to provide insights on how users refine their queries, and what kind of search strategies they are using to locate the information they need.

In this paper we describe a method of obtaining a query-similarity measure, based on query-log analysis. Our metho d relies on an aggregated representation of a query log by the means of a reformulation graph, which is known as the query-flow graph [6]. In this graph, nodes represent queries and two queries are connected if they are likely to appear as part of the same search goal [15].

Our main intuition is that related queries will tend to clus-ter in local neighborhoods of the graph. Graph-projection methods are known to map graph nodes into geometric spaces so that the distance distortion is minimized. Thus, we sug-gest projecting the query-flow graph (or appropriately de-fined subgraphs of it) and then measure query similarity on the resulting geometric space. The technique is general and it can be applied to other graphs obtained from query-logs, for example, the click graph [5, 11, 22].

We use the resulting query-similarity measure for diversi-fying query recommendations. Query-recommendation sys-tems are provided by all major search engines and they aim at helping users to find more easily what they are search-ing for. The idea is that a diversification algorithm require s a notion of query similarity, for which we use the proposed measure. We show that the resulting system provides diverse yet relevant recommendations. Our main contributions are summarized as follows: Roadmap. The rest of this paper is organized as follows: Section 2 discusses related work. Sections 3 and 4 describe the framework we use to define our measures of query simi-larity, and Section 5 explores different variants for optimi z-ing our measures. Section 6 describes our application for diversifying query recommendations and Section 7 offers our concluding remarks. Query graphs. Graphs can be used to provide a com-pact representation of query-logs. Query graphs of differen t types have been extensively studied in literature [2, 5, 3, 22, 6]. In most of these studies query-logs are represented by graphs in which vertices represent queries and edges cap-ture various types of query relations. Baeza-Yates [2] defin es a query-graph taxonomy, introducing five types of graphs where edges connect queries according to different criteria (e.g., common words, common clicked URLs). Tiberi et al. [3] show how to infer semantic relations between queries from the cover graph and describe an application to the task of detecting multi-topical URLs.

Query-document graphs, also known as click graphs [5, 22] are bipartite graphs G = { Q, D, E } where Q is a query set and D is a document set. A query is connected to documents that were clicked in the associated result list.

The query-flow graph [6] aggregates different sources of information in order to capture the latent query behavior of users. Leven and Loizou [19] introduce a concept similar to the query-flow graph, but their work is focused on browsing behavior inside a Web site. Borges and Levene [8] propose an improved method to summarize Web navigation sessions based on a variable-length Markov model.
 Query recommendations. Most query-recommendation methods use similarity measures obtained by mining ( i ) the query terms, ( ii ) the clicked documents, and/or ( iii ) the user sessions containing the queries. Typical methods use a combination of these factors.
 Query recommendation based on clicked documents.
 Baeza-Yates et al. [4] propose a measure of query similarity and use it to build methods for query expansion. Their technique is based on a term-weight vector representation o f queries, obtained from the aggregation of the term-weight vectors of the URLs clicked after the query. Wen et al. [30] also present a clustering method for query recommendation that is centered around various notions of query distance.
Craswell and Szummer [11] describe a method based on random walks on the query-click graph [5], and they test it for an application of image search. Fuxman et al. [13] use the query-click graph to find related keywords for ad-vertising. Antonellis et al. [1] also use the query-click gr aph, and exploit the idea of co-citation through its generalizat ion known as SimRank [14]. Mei, Zhou and Church [22] use the notion of hitting time for ranking related queries. Query recommendation based on query reformula-tions. Many effective approaches focus on the analysis of user query sessions [12, 33, 16]. Fonseca et al. [12] propose a query recommendation system based on association rules ap-plied to query logs. Zhang and Nasraoui [33] represent each user session by a complete graph where consecutive queries are connected with an edge of a predefined weight d . Not consecutive queries are connected by an edge weighted with the product of the weights on the walk connecting them. Recent works have shown that not only the previous query, but also the long-term interests of users, are important for understanding their information needs [20, 26].

In [16], the notion of query substitution is introduced: for each query, a set of similar queries is obtained by replacing the whole query or only its sub-phrases. White et al. [31, 32] use the query rewrites observed in a query log to generate query recommendations. Sadikov et al. [27] have recently proposed to cluster the refinements of a user query by per-forming a random walk on a query-document graph that incorporates both session and click information.
A query-flow graph, as defined by Boldi et al. [6], is a directed graph G = ( V, E, w ) where: In the query-flow graph, two queries q and q  X  are connected by an edge if there is at least one session of the query log in which q  X  follows q . The weight w may depend on the application; in the following we simply consider the weight to be the frequency of the transition in the query log.
The edge probabilities along with other data associated to each transition, are used to segment physical sessions into missions [15] or chains [25]. Here, physical sessions are de-fined as sequences of the activities of a single user before a timeout of 30 minutes, while missions/chains are defined as sequences of activities that are topically related.
The query-flow graph captures implicit similarity between queries: queries connected by a heavy edge are similar in the sense that they are motivated by the same user information need. Query logs collected over a few months are rich in in-formation, but they also contain a lot of noise. Our approach is motivated by the idea of defining a similarity measure be-tween queries that takes into account the global structure o f the query-flow graph, and not only pairs of queries.
Measuring distances of nodes on large graphs is a well-studied problem, and many approaches have been proposed, including the shortest-path distance and the commute time . A drawback of those measures is that they are very expen-sive to compute, as their complexity is at least linear to the number of the nodes in the graph, while one would like to have measures whose complexity depends only on the nodes under consideration (and possibly features of the nodes) bu t not on the whole dataset.

One of the key methods for measuring distances in a graph, which has been used extensively for visualizing graph data, is the idea of graph projection . The idea is to project the original graph into a low-dimensional Euclidean space and then measure distances between graph nodes by considering the distances of the corresponding projected points. There are many techniques that can be used to obtain such projec-tions, including multidimensional scaling [18], spectral pro-jections [10, 17, 24], IsoMap [29], maximum-variance unfol d-ing [28], and many more. In this paper we use the spectral projection, which we briefly describe below, via the concept s of Laplacian matrix and spectral embedding .
 Laplacian matrix. Given a graph G with adjacency ma-trix A , the Laplacian matrix L G = D  X  A is computed using the diagonal matrix D , whose entry d ii equal to the degree of the i -th node of G .
 Spectral embedding. An embedding  X  : V  X  R m is computed by finding the ( m + 1) eigenvectors of L G that correspond to the smallest eigenvalues. Only m of these are used as the one corresponding to the smallest eigenvalue is the vector of all 1  X  s.

The spectral embedding has the property of preserving the distances in the projected space. For  X  X ear-by X  nodes u and v in the graph G , the Euclidean distance between the vectors  X  ( u ) and  X  ( v ) is small. Details on the properties of spectral embeddings of graphs and spectral algorithms can be found in [10, 17, 24]. The notion of  X  X ear-by X  nodes in the graph is related to the expected time of coming across node v in a random walk starting from node u . Regarding the property of maintaining distances, the spectral projection optimiz es a global objective function that can be interpreted as the overall distortion of the graph projection.

On the projected space, various distance metrics can be used, for example the Euclidean distance or the cosine simi-larity. In our experiments, we observed that cosine similar ity outperforms Euclidean distance, and in the rest of the paper we focus on cosine similarity. Since the cosine between two vectors can be negative we rescale it as follows: Recently the notion of directed Laplacian was introduced and analyzed by Fan Chung [9]. Since the query-flow graph is a directed graph, using the directed Laplacian is more ap-propriate for our application scenarios. However, our eval ua-tion showed that the projection based on the directed Lapla-cian does not yield any improvement.

In the next two sections we describe our experiments with projections of the query-flow graph. Our objective is to ex-plore systematically the space of possible parameters and alternatives on defining appropriate subgraphs to project, in order to optimize the quality of query similarities.
We note that we have not tried to explore the possibility of improving our empirical results using different graph em-bedding algorithms. Any graph embedding algorithm can be used as a black-box in our method, instead, our main fo-cus has been to leverage the idea that graph projections can yield meaningful notions of query similarity, and we have also experimented extensively with finding the best sub-graphs to project.

The query-flow graph was built using a set of sessions extracted from a query log from the Yahoo! search engine.
We improve the graph by estimating the probability that both the queries q and q  X  in a transition belong to the same  X  X earch mission X  X 15] (also known as X  X uery chain X  X 25]). Th is modification prunes out transitions to frequent navigation al queries such as popular web portals.

Motivated by the results of some preliminary assessments, we apply a number of filters on the graph, such as removing the transitions that have frequency less than 5. We also remove s and t and prune all the nodes that remain isolated: these correspond to sessions composed by singleton queries . Altogether, starting from a graph with 58 312 610 nodes and 131 836 560 edges, we obtain a graph with 4 152 773 nodes and 7 788 232 edges. This is the graph G that we consider in the rest of the paper.
Our evaluation method is summarized as follows: We se-lect 140 queries from the log, sampling queries that are nei-ther too frequent nor too infrequent ( torso queries ), as head queries tend to be of a particular type (e.g., navigational) , while tail queries give information that is too sparse. We fo -cus on single-term queries that are likely to have more than one interpretation. For each of these queries, we build a test set of related queries by selecting a small set of their most frequent successors in the query-flow graph. Each test set is then clustered into 2 to 5 clusters by human editors; the clustering of a test set represents the ground truth for that set. Table 1 shows examples of clustered test sets. We then apply our graph projection method, and we obtain a similar-ity measure for queries, for which we evaluate its agreement with the human-defined clustering. We compare different variants of graph projections by testing which variant yiel ds similarities that agree better with the golden truth.
Note that to apply our methodology we need to mea-sure agreement between a clustering and a similarity func-tion. We use the following measure: let V be a set and tors. We tested whether our results depend on the subjective perception of the editors about clustering, by repeating ou r analysis for the queries labeled by each editor separately. We found that in all cases we obtain similar results. We omit the details for lack of space. C = { C 1 , . . . , C k } , with V = S i C i , be a clustering of V . For a similarity function Sim( q, q  X  ), we introduce two scores: intra-cluster similarity of cluster C i : inter-cluster similarity of cluster C i : The intuition is that a similarity measure agrees with clus-tering C if the InSim score is large compared to the OutSim score. Thus, we capture the quality of a similarity measure, with respect to the clustering C , using the ratio Given two different similarity measures, the best one is the one that maximizes the measure M  X  C (Sim).
We experiment with two alternatives for extracting sub-graphs from the query-flow graph: query-dependent and query-independent methods.
 Query-dependent subgraphs. Given a query q we ex-tract a subgraph around q by a breadth-first search from q . For a graph G = ( V, E ) and two nodes q, q  X  , let d ( q, q the length of the shortest path from q to q  X  following di-rected edges in E . Let V d ( q ) = { q  X   X  V such that d ( q, q d or d ( q  X  , q )  X  d } . For instance, V 0 ( q ) = { q } and V tains the in-neighbors and out-neighbors of q . We define the sets: We experimented with the following subgraphs of q :
Figure 1 shows an example. The sizes of the obtained sub-graphs vary widely, with | V 2 ( d ) | ranging from 31 to 20 702 queries (median: 2 320 queries).
 Query-independent subgraphs by partitioning. Query-dependent subgraphs may be expensive to compute at query time, so we also experimented with query-independent sub-graphs obtained by partitioning the filtered graph. The par-titioning was done using metis [23] and varying the number of clusters that metis takes as a parameter.
The objective of our study is twofold: ( i ) to demonstrate the effectiveness of the query-flow graph projections in orde r to define a measure able to capture the human notion of similarity between queries, and ( ii ) to optimize such a query-similarity measure.

To address the first objective we define a baseline measure that relies on the query-flow graph but does not use projec-tions. To obtain more refined graphs, and thus similarities of better quality, we apply the projection method locally, o n the neighborhood of a given query. This approach is based on constructing query-dependent subgraphs as we discuss in detail in Section 4. Applying projections locally yields a better similarity measure, but unfortunately, the method i s computationally more expensive since it requires to build a different subgraph for each query. Thus we propose a  X  X y-brid X  approach, which builds query-independent subgraphs by using partitions of the query-flow graph obtained with the metis graph-clustering algorithm.

Overall, we perform a large number of experiments to as-sess the following parameters: ( i ) the number of dimensions of the spectral embedding, ( ii ) the choice of the weight-ing scheme, ( iii ) the method to be used in the construction of the query-dependent subgraphs, and ( iv ) the number of partitions to be considered in the computation of query-independent subgraphs.
Our first similarity measure is purely based on the query-flow graph: the similarity between two queries is given by the cosine similarity of their vectors of neighbors. Given a query q , we denote by N ( q ) its vector of neighbors in the query-flow graph.

For our test sets, the average value of M  X  C for this base-line similarity measure is 1.03 with a variance of 0 . 03. Fig-ure 4(a) reports the results obtained for the query watch ; we observe little separation between queries in different clus -ters. These results suggest that the metric based on the cosine similarity of the neighborhoods of two queries does not capture well the similarity of queries. We stress here the fact that methods based on random walks [11] or hit-ting time [22] are not able to capture the notion of semantic similarity we aim to. In the example of Figure 4(a), the probability to end up in frequent queries like  X  rolex watch or  X  watch free movies online  X , starting from the query  X  watch  X , might be quite similar even if such queries are not semantically related.
We describe the choices we explored in order to optimize the performance of query projections.
 Choice of dimensions. In order to investigate how varying the number of dimensions of the spectral projection affects performance, we build three embeddings of G , which respec-tively have m = 3, m = 5 and m = 7 dimensions. To get a more complete picture, we do the same for two types of query dependent subgraphs, S 2 and S 3 . For each of these cases, we use the projections to compute the similarity be-tween all the pairs of queries in every test set collected, an d then we compute the measure M  X  C to evaluate agreement with the clusters created by hand. We also perform t -tests Table 2: Average M  X  C for different projections with different number of dimensions Table 3: Average M  X  C obtained for S 2 ( q ) , S 3 ( q ) using different weighting schemes.

S 2 1.9 1.8 1.3 bin. &gt; raw *** log &gt; raw ***
S 3 2.2 1.9 1.7 bin. &gt; raw ** bin. &gt; log * to figure out whether the differences among the various cases are statistically significant or not.

Our results, reported in Table 2, show that increasing the number of dimensions does not determine a consider-able gain in terms of quality. A slight improvement in terms of less variance is observed, but the differences between the various cases are not statistically significant. For this re ason we fix m = 5 in the remainder of our experimentation. Choice of weighting scheme. In the query-flow graph, every edge connecting two queries is weighted with the fre-quency of the transition in the original query log, and the transition probabilities of the edges can be used to identif y queries that represent similar information needs. We per-form a number of tests to investigate whether taking the edge weights into account during the computation of the spectral embeddings improves our method.

We experiment with three different weighting functions:
When an edge between two queries exists in both direc-tions, we symmetrize the weights choosing the maximum of the two. This step is needed for the computation of the pro-jection. We also tried with minimum, average or sum of the two weights, but we observed no substantial changes.
We compare the above weighting schemes for two types of query dependent subgraphs: S 2 ( q ) and S 3 ( q ). Table 3 shows the results. Binary and log weights yield the best results, whereas the usage of raw counts hurts performance, and the difference between this weighting scheme and the other two is statistically significant. For this reason we discard the raw counts, and we focus on the simplest of the two schemes that exhibit the best behavior, which is the one using binary weights. We consider projections of unweighted graphs in the remainder of this section.
 Projecting directed or undirected graphs? A natural objection to the use of the spectral embedding of the query-flow graph is that the technique is intended to be applied on undirected graphs. Surprisingly preliminary experiments , which we do not present for lack of space, showed that us-Figure 2: Comparison among local projections, projec-ing the directed Laplacian does not yield any improvement. Hence, we retained the standard method.
We now study if projecting the neighborhood of a given query improves performance. We consider three types of query-dependent subgraphs: F 1 ( q ), S 2 ( q ), S 3 ( q ). The first is the subgraph induced by the neighbors of the input query, while the other two graphs are obtained by applying two or three steps of a breadth-first search on the query-flow graph, starting from the input query.

We compare the embeddings of the query-dependent sub-graphs against the methods discussed before, i.e., project ing the whole graph or using the query-flow graph directly. The results of this study are presented in Figure 2 and Table 4: N is the baseline, while the other cases represent the meth-ods that project either the full graph G or the corresponding query-dependent subgraphs. Local projections introduce a relative improvement in the average M  X  C in the range of the 16%  X  39%. Even if the variances of local projections are also increasing we can observe that the lower bound for both S and S 3 match the upper bound of N . Also, the differences between the query-dependent subgraphs and the other two approaches are statistically significant (see Table 4).
Figure 5 reports a qualitative comparison of the above methods for the query  X  watch  X .
Using local projections of small query-dependent subgraph s allows to define a metric that captures better the similar-ity between queries. However, this method has the clear drawback of requiring query-time computational process-ing, which may be expensive. For this reason we investigate whether projecting larger, query-independent subgraphs a l-lows to trade-off performance and computational costs. Table 5: M  X  C for varying numbers of clusters; none of the pair-wise differences is statistically significant
We generate sets of query-independent subgraphs using the metis algorithm, which partitions the nodes of a graph into balanced clusters minimizing the number of edges in the cut. The number of clusters to be created is chosen by the user. In the following, we briefly describe how we use a partition of the nodes in the query-flow graph created with metis to derive query-independent subgraphs. We then compute the spectral embeddings of these subgraphs. Cluster expansion. We first partition the graph into 100 and 200 clusters. We choose these values because they yield cluster sizes comparable to the size of query-dependent sub -graphs for which our method obtains the best performance.
As first attempt, we directly project the partition created by metis . This solution performs very poorly (results are omitted due to lack of space), because the raw clusters do not typically include a significant fraction of the neighborhoo d of each node.

To overcome this limitation, we study how to make the partitions include (a significant fraction of) the neighbor -hood of each node assigned to them. We test two methods. The first strategy consists of enlarging each partition with the in/out-neighbors of every node originally included in i t  X  so that clusters may overlap. We found that this method does not improve performance.

We then experiment with a more expensive strategy, which consists of adding to each partition the two-step neighbor-hood of every node originally assigned to it. This solution creates larger clusters, and experimental evaluation show s that it provides results comparable to those obtained by projecting the full graph (see Table 5). Hence, we retain this approach as our cluster expansion method.
 Choice of number of clusters. The expansion step is necessary to make the clusters include many neighbors of a given node, i.e., queries that are likely to be related to the input query. However, this operation creates clusters o f very large size: we believe that this can be a reason for not having a significant improvement in performance.

Hence, we perform more extensive experiments, using metis to divide the query-flow graph into a larger number of par-titions and applying the expansion step to the sets of nodes obtained.

Table 5 shows how the method behaves with 1 000, 5 000 and 20 000 clusters. Starting from 5 000 we get a little im-provement in performance, but the differences are not sig-nificant at p &lt; 0 . 1. Although the method performs at least as well as the projection of the full graph, our intuition is that it would be worth exploring other approaches to extract query-independent subgraphs from the query-flow graph. Figure 3: Summary of performance of some systems
Figure 3 summarizes the tested methods, which can be divided into three groups:
With respect to effectiveness, a positive result is that for all the projection-based methods we tested, in at least 75% of the cases the system gave a larger similarity to queries in the same user-defined clusters than to queries in different user-defined clusters.
In this section we describe how we apply the proposed method for producing diverse query recommendations. Di-versification of search results or query recommendations is a strategy adopted by search engines to improve the user experience and minimize the risk that the information need of the user will not be satisfied.
 For our experiment we use a random sample of 100 queries. For each query, we generated a set of baseline query recom-mendations using a method suggested in [7]. This method ( QueryFlow-SP ) associates a query q with a set Q of rec-ommendations obtained by selecting the most frequent refor -mulations from q . Each query q  X   X  X  is assigned a ranking score given by the frequency of the transition ( q, q  X  ). This method was shown to perform as well as more sophisticated recommendation algorithms. In the following, we refer to it as the baseline.

Next, we use the diversification method described by Manca and Pintus [21]. The idea is to apply a greedy search that maximizes diversity while maintaining high relevance. The algorithm takes as input the set Q and builds a diverse set A of queries. First, the query q 0  X  X  with the highest relevance score is selected, removed from Q , and inserted into A . Ob-serve that this ensures that the most popular query related to the input query is always selected for recommendation. Next, the algorithm starts an iterative phase: at each step the query q  X  X  with maximum score s ( q ) is removed from Q and inserted into A . The score s ( q ) is a combination function of the relevance of q with the distance d ( q, A ) of query q from the set A of queries that have already been selected. The algorithm balances diversity with relevance . Given that the two measures, distance from other queries and relevance, are not comparable, the algorithm tries to maximize the product of the two, picking up queries that have a high ranking score while being not too similar to the queries that have already been selected. We omit the details of the diversity algorithm since it is not the focus of this paper. We derive the distance metric that we use for diver-sification from our projection method. We experiment with three schemes: N , G and S 2 ( q ). These methods measure similarity between queries in terms of cosine similarity be -tween (a) their vectors of neighbors in the query-flow graph; (b) the vectors associated with the queries in the projectio n of the full graph; (c) the vectors obtained projecting the subgraph S 2 ( q ). In the case of N , we define the distance of a query q from the set A as the minimum distance between q and a query in A : In the case of G and S 2 ( q ) the distance of q from A is defined as the distance between q and the centroid c ( A ) of the set A . Perceived diversity. The task is highly subjective, and when measuring the agreement of the assessors on a subset of questions in which they overlap, we observe a moderate level of agreement (Cohen X  X   X  = 0 . 49).

In Table 6 we show the results of this evaluation. The re-sults are expected given the results from previous sections , as Table 6: Result of user test for assessing diversity of recommendations Baseline 0.30/0.13 * 0.39/0.25 * 0.51/0.14 *** S ( q ) is the best method (in 51% of the cases it is perceived as more diverse than the baseline, in 14% of the cases as less diverse), followed by G (projecting the full graph), followed by N (using the graph without applying projection). Perceived relevance. We examine 100 queries and take the union of the top-3 recommendations from all the systems that are compared. This yields 460 distinct query pairs. The assessment is to measure if the recommendation is relevant to the original query. In this case, the inter-assessor agre e-ment is  X  = 0 . 53.

The accuracy of relevant queries that the baseline algo-rithm recommends is 97%. When using the projection on the full graph, this figure drops to 90%, and to 92% when using the S 2 method. Instead, when using N there was basically no drop in relevance, measuring a 97% of recommendations relevant to the original query. These results suggest that ( i ) N does only a small change in the recommendations, and ( ii ) S 2 and the method that projects the full graph change the recommendations but still keep the fraction of recom-mended queries that are relevant to the original query at 90% or more.
We have shown that projecting the reformulation graphs in a low-dimensional space allowed us to define a similarity measure between queries. To the best of our knowledge, this is the first attempt to apply spectral methods to query-reformulation analysis.

After methodically exploring several design choices, we found two methods that perform well: one for off-line pro-cessing and one for on-line processing. The method for off-line processing basically works by storing 3-5 spectral co-ordinates per query and then using them at query time at constant cost. The method for on-line processing requires computing a small subgraph at query time and then project-ing this graph to obtain the coordinates. Our experiments suggest that the on-line method is a more effective similarit y measure, but of course it has a higher computational cost.
To demonstrate the practical impact of our method, we tested our measure as a component of a system for produc-ing diverse query recommendations. Our experiments show that our method can be used to produce diverse recommen-dations at small cost of relevance.

As future work, we would like to seek more effective off-line methods than the projection on the full graph. We also plan to investigate alternative projection methods, as wel l as the use of other query graphs, such as the click graph.
Key references: [6, 10]. [1] Antonellis, I., Garcia-Molina, H., and Chang, [2] Baeza-Yates, R. Graphs from search engine queries. [3] Baeza-Yates, R., and Tiberi, A. Extracting [4] Baeza-Yates, R. A., Hurtado, C. A., and [5] Beeferman, D., and Berger, A. Agglomerative [6] Boldi, P., Bonchi, F., Castillo, C., Donato, D., [7] Boldi, P., Bonchi, F., Castillo, C., Donato, D., [8] Borges, J., and Levene, M. Evaluating [9] Chung, F. Laplacians and the cheeger inequality for [10] Chung, F. R. K. Spectral Graph Theory (CBMS [11] Craswell, N., and Szummer, M. Random walks on [12] Fonseca, B. M., Golgher, P. B., de Moura, [13] Fuxman, A., Tsaparas, P., Achan, K., and [14] Jeh, G., and Widom, J. Simrank: a measure of [15] Jones, R., and Klinkner, K. L. Beyond the session [16] Jones, R., Rey, B., Madani, O., and Greiner, W. [17] Koren, Y. On spectral graph drawing. In COCOON [18] Kruskal, J. Nonmetric multidimensional scaling: A [19] Levene, M., and Loizou, G. A probabilistic [20] Luxenburger, J., Elbassuoni, S., and Weikum, [21] Manca, M., and Pintus, E. Diversity in web search. [22] Mei, Q., Zhou, D., and Church, K. Query [23] METIS  X  Family of multilevel partitioning algorithms. [24] Ng, A. Y., Jordan, M. I., and Weiss, Y. On [25] Radlinski, F., and Joachims, T. Query chains: [26] Richardson, M. Learning about the world through [27] Sadikov, E., Madhavan, J., Wang, L., and [28] Sun, J., Boyd, S., Xiao, L., and Diaconis, P. The [29] Tenenbaum, J. B., Silva, V., and Langford, J. C. [30] Wen, J.-R., Nie, J.-Y., and Zhang, H.-J.
 [31] White, R. W., Bilenko, M., and Cucerzan, S.
 [32] White, R. W., Bilenko, M., and Cucerzan, S.
 [33] Zhang, Z., and Nasraoui, O. Mining search engine
