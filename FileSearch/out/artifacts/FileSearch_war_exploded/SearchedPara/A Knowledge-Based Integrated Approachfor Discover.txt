 Fabrizio M. Maggi, R.P. Jagadeesh Chandra Bose, and Wil M.P. van der Aalst Imperative process models such as BPMN, UML ADs, EPCs, and Petri nets are often used to design and enact operational processes. The procedural nature of such models also helps to guide users by showing  X  X hat X  X  next? X . Unfortunately, imperative process models are less appropriate for  X  X urbulent X  environments characterized by the terms variability and flexibility . Consider, for instance, a physician in a hospital that requires flexibility to take into account individual characteristics of a patient. But, also physicians have to follow regulations and guidelines and may only deviate for good reasons. In such cases, declarative process models are more effective tha n the imperative ones [15,12,2].
Instead of explicitly specifying all possi ble sequences of activities in a process, declarative models implicitly specify the allowed behavior using constraints, i.e., rules that must be followed during execution. In comparison to imperative ap-proaches, which produce closed models ( X  X hat is not explicitly specified is for-bidden X ), declarative languages are open ( X  X verything that is not forbidden is allowed X ). In this way, models offer flexibility and still remain compact.
Declarative languages have been successf ully applied in the context of pro-cess discovery [7,5,6,11,10]. Declare , a declarative process modeling language basedonLTL(LinearTemporalLogi c) [13], was introduced in [2]. 1 Declare is characterized by a user-friendly graphical representation and formal semantics grounded in LTL. A Declare map is a set of Declare constraints each one with its own graphical representation and LT L semantics (the constraints used in this paper are introduced in Table 1, see [2] for a full overview of Declare).
Declare maps are interesting in the context of process mining [1]. One can dis-cover Declare maps from event logs (extracted from audit trails, transaction logs, and databases) without preexisting models and knowledge [10]. It is also fairly easy to check conformance of an event log with respect to Declare model and diagnose deviations and bottlenecks. The unstructured nature of many real-life processes  X  X emonstrated by variability in event logs X  suggests using declara-tive models for process mining. However, when discovering a Declare map from an event log, there are often too many candidate constraints. Showing all possible constraints often results in a cluttere d Declare map. The number of constraints in a Declare map can be reduced by identi fying only those constraints that are the most interesting for the user. As proposed in [10], the  X  X nterestingness X  of a constraint can be defined using association rules metrics such as support and confidence. This paper proposes two sets of techniques to further improve the relevance of discovered Declare maps: (1 ) techniques to prune discovered process maps using various reduction and simplification rules and (2) techniques using apriori domain knowledge.

A constraint between two activities (e.g., A is eventually followed by B )is redundant if a stronger constraint holds (e.g., A is directly followed by B ). There may also be constraints that are im plied by other constraints (e.g., if A is followed by B and B is followed by C ,then A is also followed by C ). By selectively removing such redundant constraints, we can simplify the model without losing information.

Furthermore, using domain knowledge, activities in the log can often be grouped in different categories. Hence, it is possible to focus the discovery only on constraints involving activities belonging to the same group ( intra-group constraints ) or on constraints involving activities belonging to different groups ( inter-group constraints ). There may also be a reference map providing another source of domain knowledge. Instead of d iscovering a Declare map from scratch, it is possible to generate a new map by repairing the reference map. The refer-ence map is modified using information retr ieved from the event log, e.g., existing constraints are strengthened, weakene d or refuted and important missing con-straints are added.
 The paper is structured as follows. I n Section 2, we briefly introduce the Declare language and the Declare maps discovery approach proposed in [10]. In Section 3, we describe how we remove redundant constraints to create simpler Declare maps. Here, we also explain how to use domain knowledge for discovering and repairing Declare maps. The propo sed techniques can be integrated in a general framework as shown in Section 4. In Section 5, we validate our approach using a case study in a Dutch hospital. Section 6 concludes the paper. Table 1 shows the graphical notation and the meaning of the Declare constraints used in this paper. Consider, for example, the response constraint. This con-straint indicates that if A occurs, B must eventually follow. Therefore, this constraint is satisfied for traces such as t 1 = A, A, B, C , t 2 = B,B,C,D , and t 3 = A, B, C, A, B , but not for t 4 = A, B, A, C because, in this case, the second A is not followed by a B .

In [10], the authors use the seminal apriori algorithm introduced in [3] for discovering Declare maps. In this way, only constraints involving frequent ac-tivities are taken into consideration. The authors show that the apriori-based approach significantly improves the computational complexity and accuracy of the uncovered Declare maps with respect to the brute force approach where all activities in the log are considered. In the same approach, the constraints in the discovered map with a support lower than a given threshold are removed. The support of a constraint is evaluated based on the number of traces where the constraint is non-vacuously satisfied [8]. We explain vacuity using an example. Consider again the response constraint and the traces mentioned above. The constraint is satisfied in t 1 , t 2 and t 3 . However, in t 2 ,the response constraint is satisfied in a trivial way because A never occurs. In this case, we say that the constraint is vacuously satisfied . The validity of a constraint is, therefore, more significant if there is a high percen tage of traces where the constraint is non-vacuously satisfied. Declare maps can be discovered by smartly testing all possible constraints. How-ever, as Section 3.1 shows this may result in an explosion of discovered con-straints. In Section 3.2, we illustrate how redundant and  X  X ess relevant X  con-straints can be pruned out to reduce the number of constraints in a map and improve its readability. In Section 3.3, we explain how domain knowledge can help guiding the discovery process towards the identification of the most inter-esting constraints. 3.1 The Problem of Discovering Too Many Constraints The support measure assessing the significance of a constraint (i.e., the frac-tion of traces satisfying the constraint non-vacuously) is not robust enough to prune constraints. We have discovered D eclare maps on several event logs (both synthetic as well as real-life logs) and our experiences show that the number of discovered constraints is often beyond human comprehension. Table 2 depicts the number of Declare constraints discovered for several logs and varying de-grees of support. We see that even for very high support values, the number of discovered constraints is too high to be visualized in a single understandable diagram.

Moreover, several of these constraints are considered to be trivial by domain experts. Analysts are more interested in finding patterns that are surprising and interesting. There is a need for robust methods for discovering such non-trivial constraints. In this paper, we address this through two directions: (1) pruning discovered constraints to filter out redundant ones and (2) exploiting domain knowledge in the form of reference maps and grouped activities. 3.2 Mine Only for Surprising (Non-trivial) Constraints When discovering a Declare map, there are many constraints that are redundant thus cluttering the map. Therefore, we propose various techniques to remove redundant constraints.
 Removing Weaker Constraints Implied by Stronger Constraints. A constraint between two activities is redundant if a stronger constraint holds be-tween the same activities according to the constraint hierarchy shown in Fig. 1. For example, if a response constraint and a responded existence constraint hold between the same activities A and B ,the responded existence constraint is re-dundant and can be discarded. Note that if a chain succession constraint and a response constraint hold between activities A and B , then the response con-straint is redundant because there is a directed path of solid arrows from chain succession to response in Fig. 1.
 Transitive Reduction for Declare Maps. Redundancy may also be caused by the interplay of three or more constraints. Removing such redundancies greatly improves the readability of discovered Declare maps.
Consider the example in Fig. 2(a). In this case, the response constraint be-tween A and C is redundant, because it belongs to the transitive closure of the set composed of the response constraints between A and B and between B and C . For the same reason, several other constraints are also redundant in this map. To prune these redundant constraints, we use techniques for transitive reduction of a directed graph. In particular, we have implemented the algorithm presented in [4], which can deal with cyclic graphs. Applying this algorithm on the input map in Fig. 2(a) yields the pruned map in Fig. 2(b).

Not all constraints can be pruned using transitive reduction. For instance, if we take the example in Fig. 4(d), none of the constraints in the map can be pruned out because the not co-existence is not transitive and none of the constraints in the map is redundant. 2 ThedashedarcsinFig.1showforwhich Declare constraints transitive reduction can be applied.

The co-existence constraint is  X  X idir ectional X  and can be considered as a spe-cial case for transitive reduction. For example, for the map in Fig. 3(a), there are three possible reductions (indicated in Fig. 3(b) X (d)).
The transitive reduction can also be used in case some of the constraints involved are stronger. Consider for example Fig. 4(a). The response constraint between A and C belongs to the transitive closure of the set composed of the chain response constraint between A and B and the response constraint between B and C .The chain response between A and B , implies the weaker response constraint. Hence, we can indeed apply t ransitive reduction and remove the response constraint between A and C . Fig. 4(b) shows the resulting map. In contrast, in the example in Fig. 4(c), the chain response constraint cannot be pruned out because it indicates that the relation between A and C is stronger than a simple response.
 Prune a Declare Map through Reduction Rules. Another way to remove redundant constraints is by using reduction rules. For example, reduction rules can be used to prune out redundant not co-existence constraints from a map. For the reduction rules defined here, we use the concept of co-existence path .A co-existence path is a sequence of activities in a Declare map connected through co-existence constraints or through constraints stronger than co-existence (e.g., succession , alternate succession ,and chain succession ). For example, A, C, E is a co-existence path in Fig. 6(a) X (d), and E,D,C is a co-existence path in Fig. 7(a) and (b).

We illustrate the triangular reduction rule for not co-existence using the ex-ample map in Fig. 5(a). The co-existence constraints ensure that both A and C are in or out. Hence, one not co-existence constraint is sufficient to exclude B in case A and C occur. The resulting maps are shown in Fig. 5(b) and (c).
Another reduction rule is shown in Fig. 6. Here, instead of having one activity connected through not co-existence constraints to a coexistence path, we have the elements of two coexistence path s connected pair-wise through not co-existence constraints. Also in this case, only one of the not co-existence constraints is enough (Fig. 6(b) X (d)) to imply all the original constraints in Fig. 6(a).
As shown in Fig. 7, the reduction rules in Fig. 5 and in Fig. 6 can be ap-plied in combinations and, also, with co-existence paths composed of heteroge-neous types of Declare constraints. In Fig. 7(a), the original map contains three parallel co-existence paths: A, B , E,D,C and F,G . In the pruned map de-picted in Fig. 7(b), the not co-existence constraint between A and D and the not co-existence constraint between D and G can be removed through the tri-angular reduction rule. Then, the not co-existence constraint between B and C and the not co-existence constraint between C and G can be removed through the reduction rule on parallel co-existence paths.

Note that these rules are m erely examples. Currently, we are developing a much larger set of reduction rules. 3.3 Guiding the Discovery Process through Domain Knowledge The techniques provided above may still fail to single out interes ting constraints as they do not consider any domain know ledge. Therefore, we propose several means of integrating domain knowledge during the discovery process. The first class of techniques deals with repairing an apriori Declare map (called a reference map ) provided by a domain expert while the second class of techniques deals with discovering constraints based on conceptual groupings of activities .Fig.8 depicts the process of Declare map discovery/repair based on apriori domain knowledge. Note that reference map and the groupings are optional.
 Repair a Declare Map. Given an apriori Declare map, it can be repaired in several ways:  X  We can use the set of templates (i.e., constraint types) and activities provided  X  WecantrytorepairtheprovidedDeclaremapbasedonthelogby strength- X  One of the challenges when discover ing Declare maps from event data is Use Activity Ontologies to Discover Declare Maps. Activities in a log can typically be grouped (clustered) based on their functionality, e.g., using an ontology. For example, a log pertaining to the treatment procedures of can-cer patients in a hospital contains activities related to patient administration, diagnosis, surgery, therapy, etc. Given such a grouping of activities, we can dis-tinguish between two classes of constraints:  X  intra-group constraints: this refers to the class of constraints where the activ- X  inter-group constraints: this refers to the class of constraints where the activ-We have developed and implemented a comprehensive framework for discover-ing/repairing Declare maps. Fig. 10 shows that the framework consists of the following building blocks (all implemented in ProM).  X  Association Rule Mining: Using the apriori association rule mining algo- X  Disposition Generation: This step corresponds to th e generation of candi- X  Declare Miner: This step corresponds to instantiating the filtered disposi- X  Pruning: This step corresponds to pruning the discovered Declare map using We have implemented the functionalities described in Fig. 10 as part of the Declare Miner , a plug-in of the process mining tool ProM ( www.processmining.org ). We evaluated the approach presented in this paper using a real-life event log originating from a large Dutch academic hospital. The log contains events re-lated to the treatment of patients di agnosed for bladder cancer. Bladder cancer is a life-threatening disease and each patient must be treated in a different way, depending on the patient X  X  characteristics (e.g., age, gender), their histology, stage of cancer and depth of invasion. There are several possible tests and treat-ments the doctors can decide to use. Due to the high variability of the treatment process, it is impossible to create or discover an imperative model. Therefore, we apply the Declare Miner .

Here, we report results based on an event log with 289 log traces (patients) containing 152 event classes and 10.215 events. In Table 2, we have already shown how many constraints would be discovered from this log (log D in the table) by pruning the model only based on support. Table 3 shows the number of discovered constraints after removing redundant constraints using the pruning techniques presented in Section 3.2. W e can see a significant reduction (84%, 81% and 35% for support equal to 60, 80 and 100 respectively) in the number of constraints. Nevertheless, as shown in Table 3, even for the reduced maps the number of constraints is still too high for the maps to be readable.
To reduce the number of discovered constraints, it is possible to use domain knowledge as a criterion to  X  X uide X  the discovery task and to discriminate be-tween constraints that are more interestin g and others that are less relevant from the domain point of view. To illustrate the conceptual grouping of activities pre-sented in Section 3.3, we define three groups of activities (shown in Table 4). The first group includes administrative activities ( G 1), in the second group there are surgery-related activities ( G 2), and the last group includes therapy-related activities ( G 3).

Fig. 11 depicts the discovered inter-group constraints . The map has been dis-covered with a minimum support equal to 60 and the constraints in the map are sorted by confidence. Their colors range from purple (indicating the highest confidence) to white (indicating the lowest confidence). In Fig. 11, the three ac-tivity groups are highlighted with a dashed line. Note that the constraints in the map connect activities belonging to different groups and that there are no con-nections between activities belonging to the same group. This way, we can focus our analysis on inter-group relations. For example, if we consider the connections between group G 1 and group G 2, we can see that after a cysto-urethroscopy and a transurethral resection the patient i s registered and the order fee is payed ( al-ternate response ). Also, activity short-out ma p cost for anesthesia is preceded by cysto-urethroscopy ( alternate precedence ) and is followed by transurethral re-section ( alternate response ). On the other hand, if we consider the connections between group G 2 and group G 3, we can see that an intravesical chemother-apy is preceded by a transurethral resection ( alternate precedence )andbya cysto-urethroscopy ( precedence ).

Fig. 12 shows the discovered intra-group constraints . In this case, the con-straints in the map connect activities belonging to the same group, whereas connections between activities belong ing to different groups are not shown. Therefore, we focus our process analysis o n intra-group relations. For example, in group G 2, we can see that, in most of the cases, activity cysto-urethroscopy is followed by transurethral resection and, vice versa, transurethral resection is preceded by cysto-urethroscopy ( alternate succession ). In group G1, the first visit is followed by order fee payment ( alternate response )andthepaymentis followed by the patient registration ( response ).

Instead of discovering a Declare map from scratch, it is also possible to provide domain knowledge in the form of a referen ce Declare map (cf. Section 3.3). This map is repaired based on the information from the event log. Fig. 13 shows a hand-made Declare map. The map was created using the Declare designer [14] and describes the expected process behavior. This map can be given as input to the Declare Miner . We repair the map by discovering constraints of the same type as the ones in the map in Fig. 13 and by using the same set of activities. We search for constraints with a support greater or equal to 80.

The repaired map is shown in Fig. 14. In the repaired map, some con-straints are the same as in the initial map (e.g., the succession constraints between histological examination and nursing period). Some constraints have been strengthened (e.g., the precedence constraint between pr eoperative screen-ing and transurethral resection becomes a succession and the response constraint between transurethral resection a nd nursing period also becomes a succession ). Moreover, the resulting Declare map show s that constraints can be removed (e.g., the init constraint), added (e.g., the response constraint between preoperative screening and histological examination) or replaced by another constraint (e.g., the precedence constraint between nursing perio d and dbc registration code has been replaced by a response constraint). As shown in this paper, one may easily find thousands of constraints for event logs with only a moderate number of activities (see Table 2). This results in incomprehensible Declare maps despite the assumed ability of declarative lan-guages to deal with highly variable processes. However, most constraints in such maps are not interesting or redundant. We developed new techniques to re-move such constraints and only conserve the most interesting ones. Moreover, we showed that domain knowledge in the form of reference models or activity groupings can be used to further guide the discovery process. The approach has been implemented as a ProM plug-in and experiments show that it is indeed possible to produce simple, yet informative, Declare maps. In this paper, we re-ported on a case study involving a bladder cancer treatment process of a Dutch hospital.

