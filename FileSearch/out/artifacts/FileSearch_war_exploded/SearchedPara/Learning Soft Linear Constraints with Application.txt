 Citation field extraction, an instance of informa-tion extraction, is the task of segmenting and la-beling research paper citation strings into their constituent parts, including authors, editors, year, journal, volume, conference venue, etc. This task is important because citation data is often pro-vided only in plain text; however, having an ac-curate structured database of bibliographic infor-mation is necessary for many scientometric tasks, such as mapping scientific sub-communities, dis-covering research trends, and analyzing networks of researchers. Automated citation field extrac-tion needs further research because it has not yet reached a level of accuracy at which it can be prac-tically deployed in real-world systems.

Hidden Markov models and linear-chain condi-tional random fields (CRFs) have previously been applied to citation extraction (Hetzner, 2008; Peng and McCallum, 2004) . These models support ef-ficient dynamic-programming inference, but only model local dependencies in the output label se-quence. However citations have strong global reg-ularities not captured by these models. For exam-ple many book citations contain both an author section and an editor section, but none have two disjoint author sections. Since linear-chain mod-els are unable to capture more than Markov depen-dencies, the models sometimes mislabel the editor as a second author. If we could enforce the global constraint that there should be only one author section, accuracy could be improved.

One framework for adding such global con-straints into tractable models is constrained infer-ence , in which at inference time the original model is augmented with restrictions on the outputs such that they obey certain global regularities. When hard constraints can be encoded as linear equa-tions on the output variables, and the underlying model X  X  inference task can be posed as linear opti-mization, one can formulate this constrained infer-ence problem as an integer linear program (ILP) (Roth and Yih, 2004). Alternatively, one can em-ploy dual decomposition (Rush et al., 2010). Dual decompositions X  X  advantage over ILP is is that it can leverage existing inference algorithms for the original model as a black box. Such a modular algorithm is easy to implement, and works quite well in practice, providing certificates of optimal-ity for most examples.

The above two approaches have previously been applied to impose hard constraints on a model X  X  output. On the other hand, recent work has demon-strated improvements in citation field extraction by imposing soft constraints (Chang et al., 2012). Here, the model is not required obey the global constraints, but merely pays a penalty for their vi-olation.

This paper introduces a novel method for im-posing soft constraints via dual decomposition. We also propose a method for learning the penal-ties the prediction problem incurs for violating these soft constraints. Because our learning method drives many penalties to zero, it allows practitioners to perform  X  X onstraint selection, X  in which a large number of automatically-generated candidate global constraints can be considered and automatically culled to a smaller set of useful con-straints, which can be run quickly at test time.
Using our new method, we are able to incor-porate not only all the soft global constraints of Chang et al. (2012), but also far more com-plex data-driven constraints, while also provid-ing stronger optimality certificates than their beam search technique. On a new, more broadly rep-resentative, and challenging citation field extrac-tion data set, we show that our methods achieve a 17.9% reduction in error versus a linear-chain con-ditional random field. Furthermore, we demon-strate that our inference technique can use and benefit from the constraints of Chang et al. (2012), but that including our data-driven constraints on top of these is beneficial. While this paper fo-cusses on an application to citation field extrac-tion, the novel methods introduced here would easily generalize to many problems with global output regularities. 2.1 Structured Linear Models The overall modeling technique we employ is to add soft constraints to a simple model for which we have an existing efficient prediction algorithm. For this underlying model, we employ a chain-structured conditional random field (CRF), since CRFs have been shown to perform better than other simple unconstrained models like hidden markov models for citation extraction (Peng and McCallum, 2004). We produce a prediction by performing MAP inference (Koller and Friedman, 2009).

The MAP inference task in a CRF be can ex-pressed as an optimization problem with a lin-ear objective (Sontag, 2010; Sontag et al., 2011). Here, we define a binary indicator variable for each candidate setting of each factor in the graph-ical model. Each of these indicator variables is associated with the score that the factor takes on when it has the indictor variable X  X  corresponding value. Since the log probability of some y in the CRF is proportional to sum of the scores of all the factors, we can concatenate the indicator variables as a vector y and the scores as a vector w and write the MAP problem as where the set U represents the set of valid config-urations of the indicator variables. Here, the con-straints are that all neighboring factors agree on the components of y in their overlap.

Structured Linear Models are the general fam-ily of models where prediction requires solving a problem of the form (1), and they do not always correspond to a probabilistic model. The algo-rithms we present in later sections for handling soft global constraints and for learning the penal-ties of these constraints can be applied to gen-eral structured linear models, not just CRFs, pro-vided we have an available algorithm for perform-ing MAP inference. 2.2 Dual Decomposition for Global In order to perform prediction subject to various global constraints, we may need to augment the problem (1) with additional constraints. Dual De-composition is a popular method for performing MAP inference in this scenario, since it lever-ages known algorithms for MAP in the base prob-lem where these extra constraints have not been added (Komodakis et al., 2007; Sontag et al., 2011; Rush and Collins, 2012). In this case, the MAP problem can be formulated as a structured linear model similar to equation (1), for which we have a MAP algorithm, but where we have im-posed some additional constraints Ay  X  b that no longer allow us to use the algorithm. In other Algorithm 1 DD: projected subgradient for dual decomposition with hard constraints words, we consider the problem for an arbitrary matrix A and vector b . We can write the Lagrangian of this problem as Regrouping terms and maximizing over the primal variables, we have the dual problem min .  X  D (  X  ) = max For any  X  , we can evaluate the dual objective D (  X  ) , since the maximization in (4) is of the same form as the original problem (1), and we assumed we had a method for performing MAP in this. Fur-thermore, a subgradient of D (  X  ) is Ay  X   X  b , for an lem. Therefore, we can minimize D (  X  ) with the projected subgradient method (Boyd and Vanden-berghe, 2004), and the optimal y can be obtained when evaluating D (  X   X  ) . Note that the subgradient of D (  X  ) is the amount by which each constraint is violated by  X  when maximizing over y .

Algorithm 1 depicts the basic projected subgra-dient descent algorithm for dual decomposition. The projection operator  X  consists of truncating all negative coordinates of  X  to 0. This is neces-sary because  X  is a vector of dual variables for in-equality constraints. The algorithm has converged equality or its corresponding component of  X  is 0, due to complimentary slackness (Boyd and Van-denberghe, 2004). We now introduce an extension of Algorithm 1 to handle soft constraints. In our formulation, a soft-constrained model imposes a penalty for each unsatisfied constraint, proportional to the amount by which it is violated. Therefore, our derivation parallels how soft-margin SVMs are derived from hard-margin SVMs by introducing auxiliary slack variables (Cortes and Vapnik, 1995). Note that when performing MAP subject to soft constraints, optimal solutions might not satisfy some con-straints, since doing so would reduce the model X  X  score by too much.

Consider the optimization problems of the form:
For positive c i , it is clear that an optimal z i will be equal to the degree to which a T i y  X  b i is vio-lated. Therefore, we pay a cost c i times the degree to which the i th constraint is violated, which mir-rors how slack variables are used to represent the hinge loss for SVMs. Note that c i has to be pos-itive, otherwise this linear program is unbounded and an optimal value can be obtained by setting z i to infinity.

Using a similar construction as in section 2.2 we write the Lagrangian as: L ( y,z, X , X  ) =  X  w,y  X  X  X  X  c,z  X  The optimality constraints with respect to z tell us that  X  c  X   X   X   X  = 0 , hence  X  =  X  c  X   X  . Substi-tuting, we have except the constraint that  X  =  X  c  X   X  implies that for  X  to be positive  X   X  c .

Since this Lagrangian has the same form as equation (3), we can also derive a dual problem, which is the same as in equation (4), with the ad-ditional constraint that each  X  i can not be bigger than its cost c i . In other words, the dual problem can not penalize the violation of a constraint more than the soft constraint model in the primal would penalize you if you violated it.

This optimization problem can still be solved with projected subgradient descent and is depicted in Algorithm 2. The only modifications to Al-gorithm 1 are replacing the coordinate-wise pro-jection  X  0  X  X  with  X  0  X  X  X  X  c and how we check for convergence. Now, we check for the KKT con-ditions of (5), where for every constraint i , either the constraint is satisfied with equality,  X  i = 0 , or  X  Algorithm 2 Soft-DD: projected subgradient for dual decomposition with soft constraints
Therefore, implementing soft-constrained dual decomposition is as easy as implementing hard-constrained dual decomposition, and the per-iteration complexity is the same. We encourage further applications of soft-constraint dual decom-position to existing and new NLP problems. 3.1 Learning Penalties One consideration when using soft v.s. hard con-straints is that soft constraints present a new train-ing problem, since we need to choose the vector c , the penalties for violating the constraints. An important property of problem (5) in the previous section is that it corresponds to a structured lin-ear model over y and z . Therefore, we can apply known training algorithms for estimating the pa-rameters of structured linear models to choose c .
All we need to employ the structured perceptron algorithm (Collins, 2002) or the structured SVM algorithm (Tsochantaridis et al., 2004) is a black-box procedure for performing MAP inference in the structured linear model given an arbitrary cost vector. Fortunately, the MAP problem for (5) can be solved using Soft-DD, in Algorithm 2.

Each penalty c i has to be non-negative; other-wise, the optimization problem in equation (5) is ill-defined. This can be ensured by simple mod-ifications of the perceptron and subgradient de-scent optimization of the structured SVM objec-tive simply by truncating c coordinate-wise to be non-negative at every learning iteration.

Intuitively, the perceptron update increases the penalty for a constraint if it is satisfied in the ground truth and not in an inferred prediction, and decreases the penalty if the constraint is satisfied in the prediction and not the ground truth. Since we truncate penalties at 0, this suggests that we will learn a penalty of 0 for constraints in three cat-egories: constraints that do not hold in the ground truth, constraints that hold in the ground truth but are satisfied in practice by performing inference in the base CRF model, and constraints that are satisfied in practice as a side-effect of imposing non-zero penalties on some other constraints . A similar analysis holds for the structured SVM ap-proach.

Therefore, we can view learning the values of the penalties not just as parameter tuning, but as a means to perform  X  X onstraint selection, X  since con-straints that have a penalty of 0 can be ignored. This property allows us to consider large families of constraints, from which the useful ones are au-tomatically identified.

We found it beneficial, though it is not theoreti-cally necessary, to learn the constraints on a held-out development set, separately from the other model parameters, as during training most con-straints are satisfied due to overfitting, which leads to an underestimation of the relevant penalties. We consider the UMass citation dataset, first intro-duced in Anzaroot and McCallum (2013). It has over 1800 citation from many academic fields, ex-tracted from the arXiv. This dataset contains both coarse-grained and fine-grained labels; for exam-ple it contains labels for the segment of all authors, segments for each individual author, and for the first and last name of each author. There are 660 citations in the development set and 367 citation in the test set.

The labels in the UMass dataset are a con-catenation of labels from a hierarchically-defined schema. For example, a first name of an author is tagged as: authors/person/first . In addition, indi-vidual tokens are labeled using a BIO label schema for each level in the hierarchy. BIO is a commonly used labeling schema for information extraction tasks. BIO labeling allows individual labels on tokens to label segmentation information as well as labels for the segments. In this schema, labels that begin segments are prepended with a B , la-bels that continue a segment are prepended with an I , and tokens that don X  X  have a labeling in this schema are given an O label. For example, in a hi-erarchical BIO label schema the first token in the first name for the second author may be labeled as: I-authors/B-person/B-first .

An example labeled citation in this dataset can be viewed in figure 1. 5.1 Constraint Templates We now describe the families of global constraints we consider for citation extraction. Note these constraints are all linear, since they depend only on the counts of each possible conditional ran-dom field label. Moreover, since our labels are BIO-encoded, it is possible, by counting B tags, to count how often each citation tag itself appears in a sentence. The first two families of constraints that we describe are general to any sequence la-beling task while the last is specific to hierarchical labeling such as available in the UMass dataset.
Our sequence output is denoted as y and an ele-ment of this sequence is y k .

We denote [[ y k = i ]] as the function that outputs 1 if y k has a 1 at index i and 0 otherwise. Here, y k represents an output tag of the CRF, so if [[ y k = i ]] = 1, then we have that y k was given a label with index i . 5.2 Singleton Constraints Singleton constraints ensure that each label can appear at most once in a citation. These are same global constraints that were used for citation field extraction in Chang et al. (2012). We define s ( i ) to be the number of times the label with index i is predicted in a citation, formally:
The constraint that each label can appear at most once takes the form: 5.3 Pairwise Constraints Pairwise constraints are constraints on the counts of two labels in a citation. We define z 1 ( i,j ) to be and z 2 ( i,j ) to be
We consider all constraints of the forms: z ( i,j )  X  0 , 1 , 2 , 3 and z ( i,j )  X  0 , 1 , 2 , 3 .
Note that some pairs of these constraints are re-dundant or logically incompatible. However, we are using them as soft constraints, so these con-straints will not necessarily be satisfied by the out-put of the model, which eliminates concern over enforcing logically impossible outputs. Further-more, in section 3.1 we described how our proce-dure for learning penalties will drive some penal-ties to 0, which effectively removes them from our set of constraints we consider. It can be shown, for example, that we will never learn non-zero penal-ties for certain pairs of logically incompatible con-straints using the perceptron-style algorithm de-scribed in section 3.1 . 5.4 Hierarchical Equality Constraints The labels in the citation dataset are hierarchical labels. This means that the labels are the concate-nation of all the levels in the hierarchy. We can create constraints that are dependent on only one or couple of elements in the hierarchy.

We define C ( x,i ) as the function that returns 1 if the output x contains the label i in the hierarchy and 0 otherwise. We define e ( i,j ) to be e ( i,j ) =
Hierarchical equality constraints take the forms: 5.5 Local constraints We constrain the output labeling of the chain-structured CRF to be a valid BIO encoding. This both improves performance of the underly-ing model when used without global constraints, as well as ensures the validity of the global con-straints we impose, since they operate only on B labels. The constraint that the labeling is valid BIO can be expressed as a collection of pairwise constraints on adjacent labels in the se-quence. Rather than enforcing these constraints using dual decomposition, they can be enforced directly when performing MAP inference in the CRF by modifying the dynamic program of the Viterbi algorithm to only allow valid pairs of adja-cent labels. 5.6 Constraint Pruning While the techniques from section 3.1 can easily cope with a large numbers of constraints at train-ing time, this can be computationally costly, spe-cially if one is considering very large constraint families. This is problematic because the size which is possible because of the use of soft constraints. Table 1: Set of constraints learned and F1 scores. The last row depicts the result of inference using all constraints as hard constraints. of some constraint families we consider grows quadratically with the number of candidate labels, and there are about 100 in the UMass dataset. Such a family consists of constraints that the sum of the counts of two different label types has to be bounded (a useful example is that there can X  X  be more than one out of  X  X hd thesis X  and  X  X our-nal X ). Therefore, quickly pruning bad constraints can save a substantial amount of training time, and can lead to better generalization.

To do so, we calculate a score that estimates how useful each constraint is expected to be. Our score compares how often the constraint is vio-lated in the ground truth examples versus our pre-dictions. Here, prediction is done with respect to the base chain-structured CRF tagger and does not include global constraints. Note that it may make sense to consider a constraint that is sometimes vi-olated in the ground truth, as the penalty learning algorithm can learn a small penalty for it, which will allow it to be violated some of the time. Our importance score is defined as, for each constraint c on labeled set D , where [[ y ]] c is 1 if the constraint is violated on out-put y and 0 otherwise. Here, y d denotes the ground truth labeling and w d is the vector of scores for the CRF tagger.

We prune constraints by picking a cutoff value for imp ( c ) . A value of imp ( c ) above 1 implies that the constraint is more violated on the pre-dicted examples than on the ground truth, and hence that we might want to keep it.

We also find that the constraints that have the largest imp values are semantically interesting. There are multiple previous examples of augment-ing chain-structured sequence models with terms capturing global relationships by expanding the chain to a more complex graphical model with non-local dependencies between the outputs. In-ference in these models can be performed, for example, with loopy belief propagation (Bunescu and Mooney, 2004; Sutton and McCallum, 2004) or Gibbs sampling (Finkel et al., 2005). Be-lief propagation is prohibitively expensive in our model due to the high cardinalities of the out-put variables and of the global factors, which in-volve all output variables simultaneously. There are various methods for exploiting the combi-natorial structure of these factors, but perfor-mance would still have higher complexity than our method. While Gibbs sampling has been shown to work well tasks such as named entity recogni-tion (Finkel et al., 2005), our previous experiments show that it does not work well for citation extrac-tion, where it found only low-quality solutions in practice because the sampling did not mix well, even on a simple chain-structured CRF.

Recently, dual decomposition has become a popular method for solving complex structured prediction problems in NLP (Koo et al., 2010; Rush et al., 2010; Rush and Collins, 2012; Paul and Eisner, 2012; Chieu and Teow, 2012). Soft constraints can be implemented inefficiently using hard constraints and dual decomposition X  by in-troducing copies of output variables and an aux-iliary graphical model, as in Rush et al. (2012). However, at every iteration of dual decomposition, MAP must be run in this auxiliary model. Further-more the copying of variables doubles the num-ber of iterations needed for information to flow between output variables, and thus slows conver-gence. On the other hand, our approach to soft constraints has identical per-iteration complexity as for hard constraints, and is a very easy modifi-cation to existing hard constraint code.

Initial work in machine learning for citation ex-traction used Markov models with no global con-straints. Hidden Markov models (HMMs), were originally employed for automatically extracting information from research papers on the CORA dataset (Seymore et al., 1999; Hetzner, 2008). Later, CRFs were shown to perform better on CORA, improving the results from the Hmm X  X  token-level F1 of 86.6 to 91.5 with a CRF(Peng and McCallum, 2004).

Recent work on globally-constrained inference an HMM with the addition of global features that are restricted to have positive weights (Chang et al., 2012). Approximate inference is performed using beam search. This method increased the HMM token-level accuracy from 86.69 to 93.92 on a test set of 100 citations from the CORA dataset. The global constraints added into the model are simply that each label only occurs once per citation. This approach is limited in its use of an HMM as an underlying model, as it has been shown that CRFs perform significantly better, achieving 95.37 token-level accuracy on CORA (Peng and McCallum, 2004). In our ex-periments, we demonstrate that the specific global constraints used by Chang et al. (2012) help on the UMass dataset as well. Our baseline is the one used in Anzaroot and McCallum (2013), with some labeling errors re-moved. This is a chain-structured CRF trained to maximize the conditional likelihood using L-BFGS with L2 regularization.
 We use the same features as Anzaroot and Mc-Callum (2013), which include word type, capital-ization, binned location in citation, regular expres-sion matches, and matches into lexicons. In addi-tion, we use a rule-based segmenter that segments the citation string based on punctuation as well as probable start or end segment words (e.g.  X  X n X  and  X  X olume X ). We add a binary feature to tokens that correspond to the start of a segment in the output of this simple segmenter. This final feature im-proves the F1 score on the cleaned test set from 94.0 F1 to 94.44 F1, which we use as a baseline score.

We then use the development set to learn the penalties for the soft constraints, using the percep-tron algorithm described in section 3.1. MAP in-ference in the model with soft constraints is per-formed using Soft-DD, shown in Algorithm 2.
We instantiate constraints from each template in section 5.1, iterating over all possible labels that contain a B prefix at any level in the hierarchy and pruning all constraints with imp ( c ) &lt; 2 . 75 cal-culated on the development set. We asses perfor-mance in terms of field-level F1 score, which is the harmonic mean of precision and recall for pre-dicted segments.

Table 1 shows how each type of constraint fam-ily improved the F1 score on the dataset. Learning all the constraints jointly provides the largest im-provement in F1 at 95.39. This improvement in F1 over the baseline CRF as well as the improvement in F1 over using only-one constraints was shown to be statistically significant using the Wilcoxon signed rank test with p-values &lt; 0 . 05 . In the all-constraints settings, 32.96% of the constraints have a learned parameter of 0 , and therefore only Table 2: Performance from terminating Soft-DD early. Column 1 is the number of iterations we allow each example. Column 3 is the % of test examples that converged. Column 4 is the aver-age number of necessary iterations, a surrogate for the slowdown over performing unconstrained in-ference. 421 constraints are active. Soft-DD converges, and thus solves the constrained inference prob-lem exactly, for all test set examples after at most 41 iterations. Running Soft-DD to convergence requires 1.83 iterations on average per example. Since performing inference in the CRF is by far the most computationally intensive step in the iter-ative algorithm, this means our procedure requires approximately twice as much work as running the baseline CRF on the dataset. On examples where unconstrained inference does not satisfy the con-straints, Soft-DD converges after 4.52 iterations on average. For 11.99% of the examples, the Soft-DD algorithm satisfies constraints that were not satisfied during unconstrained inference, while in the remaining 11.72% Soft-DD converges with some constraints left unsatisfied, which is possible since we are imposing them as soft constraints.
We could have enforced these constraints as hard constraints rather than soft ones. This exper-iment is shown in the last row of Table 1, where F1 only improves to 94.6. In addition, running the DD algorithm with these constraints takes 5.21 iterations on average per example, which is 2.8 times slower than Soft-DD with learned penalties. In Figure 2, we analyze the performance of Soft-DD when we don X  X  necessarily run it to con-vergence, but stop after a fixed number of itera-tions on each test set example. We find that a large portion of our gain in accuracy can be obtained when we allow ourselves as few as 2 dual decom-position iterations. However, this only amounts to 1.24 times as much work as running the baseline CRF on the dataset, since the constraints are satis-fied immediately for many examples.
 In Figure 2 we consider two applications of our Soft-DD algorithm, and provide analysis in the caption.

We train and evaluate on the UMass dataset in-stead of CORA, because it is significantly larger, has a useful finer-grained labeling schema, and its annotation is more consistent. We were able to ob-tain better performance on CORA using our base-line CRF than the HMM CCM results presented in Chang et al. (2012), which include soft con-straints. Given this high performance of our base model on CORA, we did not apply our Soft-DD algorithm to the dataset. Furthermore, since the dataset is so small, learning the penalties for our large collection of constraints is difficult, and test set results are unreliable. Rather than compare our work to Chang et al. (2012) via results on CORA, we apply their constraints on the UMass data us-ing Soft-DD and demonstrate accuracy gains, as discussed above. 7.1 Examples of learned constraints We now describe a number of the useful con-straints that receive non-zero learned penalties and have high importance scores, defined in Sec-tion 5.6. The importance score of a constraint pro-vides information about how often it is violated by the CRF, but holds in the ground truth, and a non-zero penalty implies we enforce it as a soft constraint at test time.

The two singleton constraints with highest im-portance score are that there should only be at most one title segment in a citation and that there should be at most one author segment in a cita-tion. The only one author constraint is particu-larly useful for correctly labeling editor segments in cases where unconstrained inference mislabels them as author segments. As can be seen in Table 3, editor fields are among the most improved with our new method, largely due to this constraint.
The two hierarchical constraints with the high-est importance scores with non-zero learned penalties constrain the output such that number of person segments does not exceed the number of first segments and vice-versa. Together, these constraints penalize outputs in which the number of person segments do not equal the number of first segments, i.e., every author should have a first name.

One important pairwise constraint penalizes outputs in which thesis segments don X  X  co-occur with school segments. School segments label the name of the university that the thesis was submit-ted to. The application of this constraint increases the performance of the model on school segments Table 3: Labels with highest improvement in F1. U is in unconstrained inference. C is the results of constrained inference. + is the improvement in F1. dramatically, as can be seen in table 3.

An interesting form of pairwise constraints pe-nalize outputs in which some labels do not co-occur with other labels. Some examples of con-straints in this form enforce that journal segments should co-occur with pages segments and that booktitle segments should co-occur with address segments. An example of the latter constraint be-ing employed during inference is the first example in Figure 2. Here, the constrained inference pe-nalizes output which contains a booktitle segment but no address segment. This penalization leads allows the constrained inference to correctly label the booktitle segment as a title segment.

The above example constraints are almost al-ways satisfied on the ground truth, and would be useful to enforce as hard constraints. However, there are a number of learned constraints that are often violated on the ground truth but are still use-ful as soft constraints. Take, for example, the con-straint that the number of number segments does not exceed the number of booktitle segments, as well as the constraint that it does not exceed the number of journal segments. These constraints are moderately violated on ground truth examples, however. For example, when booktitle segments co-occur with number segments but not with jour-nal segments, the second constraint is violated. It is still useful to impose these soft constraints, as strong evidence from the CRF allows us to violate them, and they can guide the model to good pre-dictions when the CRF is unconfident. We introduce a novel modification to the stan-dard projected subgradient dual decomposition al-gorithm for performing MAP inference subject to hard constraints to one for performing MAP in the presence of soft constraints. In addition, we offer an easy-to-implement procedure for learning the penalties on soft constraints. This method drives many penalties to zero, which allows users to auto-matically discover discriminative constraints from large families of candidates.

We show via experiments on a recent substantial dataset that using soft constraints, and selecting which constraints to use with our penalty-learning procedure, can lead to significant gains in accu-racy. We achieve a 17% gain in accuracy over a chain-structured CRF model, while only need-ing to run MAP in the CRF an average of less than 2 times per example. This minor incremen-tal cost over Viterbi, plus the fact that we obtain certificates of optimality on 100% of our test ex-amples in practice, suggests the usefulness of our algorithm for large-scale applications. We encour-age further use of our Soft-DD procedure for other structured prediction problems.
 This work was supported in part by the Cen-ter for Intelligent Information Retrieval, in part by DARPA under agreement number FA8750-13-2-0020, in part by NSF grant #CNS-0958392, and in part by IARPA via DoI/NBC contract #D11PC20152. The U.S. Government is autho-rized to reproduce and distribute reprint for Gov-ernmental purposes notwithstanding any copy-right annotation thereon. Any opinions, findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect those of the sponsor.

