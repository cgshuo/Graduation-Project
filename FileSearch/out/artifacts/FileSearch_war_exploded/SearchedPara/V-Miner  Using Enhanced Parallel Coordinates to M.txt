 Analyzing data to find trends, co rrelations, and stable patterns is an important task in many indus trial applications. This paper proposes a new technique ba sed on parallel coordinate visualization. Previous work on parallel coordinate methods has shown that they are effective only when variables that are correlated and/or show similar patterns are displayed adjacently. Although current parallel coordina te tools allow the user to manually rearrange the order of va riables, this process is very time-consuming when the numbe r of variables is large. Automated assistance is required. This paper introduces an edit-distance based technique to rearrange variables so that interesting change patterns can be easily detected visually. The Visual Miner (V-Miner) software includes both automated methods for visualizing common patterns and a query tool that enables the user to describe specific target patterns to be mined or displayed by the system. In addition, the system can filter data according to rules sets imported from other data mining tools. This feature was found very helpful in practice, because it enables decision makers to visually identify interesting ru les and data segments for further analysis or data mining. This pa per begins with an introduction to the proposed techniques and the V-Miner system. Next, a case study illustrates how V-Miner has b een used at Motorola to guide product design and test decisions. H.2.8 [Information Systems]: Da tabase Management --Data Mining; I.3.m [Computer Graphics]: Miscellaneous --Visualization Change patterns, parallel coordi nate visualization, rules. This paper describes a multi-variab le visualization tool called V-Miner (for Visual Miner) designe d for mining product design and test data. The goal is to discove r useful or actionable knowledge from mobile phone testing data that can be provided as feedback to design engineers, who will use the knowledge to identify opportunities for improving both the product design and the product development process. In this way, the design cycle of new products can be shortened. At a high level, it is possible to characterize the typical design process for consumer electronic products, such as mobile phones, as follows: 1. Engineers, who are experts in mechanical, electrical, 2. After the mechanical, electrical and software designs are 3. A set of functional tests is performed on the prototypes to The engineers need to repeat the above three steps until the design meets the complete specification. After that, the phone will be released to the New Product In troduction (NPI) Team, who will coordinate the release to volume manufacturing. For existing product platforms, there is typically a large knowledge base available. E ngineers have a good understanding of potential design issues and po ssible ways to address them. However, for a new product platfo rm, which incorporates fewer previously proven solutions, it may be necessary to coordinate a number of iterations of design re visions, prototype builds (also called proto-builds ), and product tests. A large number of measurements are made for each proto-build, e.g., more than 100 variables are tested to characterize the electrical performance of a mobile phone. In order to reduce the engineering costs and cycle time associated with this design process, as well as to minimize the opportunities for design defect s, we developed a method and software tool for mining useful knowledge from electrical test data that can be used to guide the decisions made by mobile phone designers. At the first stage, which coincides with the early prototype stages of a new mobile phone product at Motorola, engineers performed an extensive set of tests on a particular type of phone. After each design change, all the electrical test variables were measured. The resulting measurement data were mined. There are more than 100 test variables that characterize the performance of a mobile phone. Each variable takes numeric values and has the following characteristics: 1. It has an upper limit and a lower limit . Any value that 2. It also has an ideal value, which is called the target value . Table 1 shows a sample test data set. Value for change i is the measured value for each variable after the i th component change. Understanding the sequence of va lues for incremental design changes 1, 2, ... is a significant part of our analyses. Note that tests were done after each component change, and that once a change was made to the design, it was not changed back to its original component. Thus, we can view each change of a component on the phone as a new de sign. Subsequent changes are based on earlier changes. Thus, the data can be treated as a sequential data set. With the testing data, product designe rs are typically interested in the following:  X  Prominent (or significant) changes in variable values after  X  The cause of these significant value changes.  X  Stable variables whose values are not affected by design  X  Patterns of values, changes, and failures. It is easy to think of ways to use classic data mining algorithms to mine patterns from the data. For example, it is possible to use association rule mining [1] to fi nd associations or use a decision tree [11] to find failure patterns. However, these algorithms are inadequate for this task for the following reasons: 1. Due to the large number of variables (more than 100), 2. The decision tree approach was initially tried by Motorola In our approach, we use parallel coordinates based visualization, which gives an intuitive view of the underlying data, thereby enabling the user to identify interesting patterns easily and quickly. Parallel coordinate visualization is suitable for the mobile phone test prototype application because, as explained later in this paper, interesting patterns can be easily seen from the visualization using various querying and sorting options. Feedback from the Motorola engineers, who carried out the data mining using our system, confirmed this. By no means, we say that rule mining or other data mining techniques are not applicable. Actu ally, the engineers have some related but previous data mining results in the form of rules, which are helpful in this project. Our system also has the capability to visually filter data us ing rules, which allows the user to study the data records cove red by certain rules. Detailed examples will be given in Section 4. This section presents a brief re view of the parallel coordinate method [7] for visualizing multi-variable data in a 2D space. In this approach, a separate vertical axis is assigned to each variable. Multiple vertical axes, i.e., one for each of the coordinates (variables) of the data set, are arranged at an equal distance from each other along the horizontal axis. For each data point (or record), a coordinate value is plotted along its respective vertical axis. The coordinate values for a given data point for two adjacent vertical axes are connected with straight lines. In this way, an n-variable data record can be visualized as a polygonal line drawn across the n parallel vertical axes with n -1 line segments. Figure 1 depicts a data set with nine 6-variable data records. By viewing the arrangement of the lines on the visualization, the user can search for patterns visually. Those line segments that have a similar slope indicate th at their corresponding data may have some correlations. For thos e similar data records, their corresponding lines will be visualized with similar shapes. In this Variable 1 0 -4 4 Voltage 0.9 ...... 
Variable 2 50000 50000 55000 HZ 495830 ...... way, the task of searching for relations among multi-variable data is transformed into the problem of 2D pattern recognition. This shifts the computational load fro m numerical reasoning to visual reasoning, which is simpler for human beings. Using the traditional parallel coordinate technique directly, however, is not sufficient for our application for two reasons: 1. The traditional parallel coordi nate method does not consider 2. The traditional parallel coor dinate visualization does not Details of these two enhancements will be discussed in Section 3 of this paper, and their respectiv e benefits will be presented in a case study in Section 4. Parallel coordinate techniques are widely used for multi-variable visualization. In [6], a parallel coordinate method helps the user understand how a certain design compares to other designs. It allows the user to investigat e correlations between variables (dimensions) in the data by manually selecting a  X  X riving X  variable to color the lines, or by manually re-arranging the ordering of variables. This is different from our V-Miner system as we perform this task automati cally or semi-automatically based on the user X  X  interests. In [9], the WinViz system was de scribed, which is an enhanced parallel coordinate technique. In this system, each polygonal line in the visualization may represent several data n -tuples satisfying the attribute values specified by the user. Group bars are used in place of attribute values on each vertical axis, with the size of the bars indicating some related info rmation such as population size. This helps to reduce the complexity of the visualization when there are many data points. The system also supports visual querying, in which the user can formulate simple AND and OR type of queries. The system highlights the specified conditions in approximate/similarity queries, as we will explain in Section 3. Another parallel coordinate appro ach is described in [3]. The PARCOVI software tool follows the original idea of parallel coordinates, yet it aims to be a generic data visualization system, and allows the user to manually se lect and re-arrange variables in the visualization. It also incorporates scatter plots for the purpose of cross-checking and verification. VisDB [8] is also a generic visualization tool, which allows exploration of large databases using visualization techniques, su ch as parallel coordinates and pixel-oriented techniques. The above systems aid in inform ation discovery. Each has its advantages. However, these appli cations are based on an implicit assumption about the data. Namely, the data records are independent of each other, and t hus the results obtained from data mining are independent of the order in which the records are fed into the data mining system. In our application, where the goal is to characterize a set of sequential prototypes of a mobile phone design, this assumption is not true. Our work is also related to shape querying [2] and axes sorting. The method presented in [2] includes a shape definition language for retrieving objects based on shapes contained in the histories of these objects. The history of an obj ect is represented by its values at each point in time. Shapes are expressed with a set of primitives, e.g.,  X  X p X ,  X  X own X ,  X  X table X , etc. Given a shape query, the system will return all the objects (variables) whose histories match the query. This approach, however, does not allow approximate matching, which is ve ry important in our work, since not all test values are available for all prototype designs. Furthermore, [2] is not concerned with visualization. In our work, we use edit distance [5] in the similarity matching. In our visualization, we allow the user to specify a query shape either by indicating an example data point or by explicitly specifying the shape of interest. The system can then sort the variables according to edit distance results. In [10], an algorithm for ordering categorical values in parallel coordinates is proposed with the following three steps: 1) constructing natural clusters of categorical values based on domain semantics; 2) ordering the clusters; 3) ordering the categorical values within each cluster. As all the variables for our application are numeric, the technique described in [10] is not applicable. In [4], an ordering algorithm is proposed for numerical variables. It shows that the best arrangement of coordinates/variables is NP-com plete. Thus, some heuristic algorithms are proposed for the variable arrangement problem. The basic idea is to make sure that the most similar variables are placed next to each other after the rearrangement. This is an important and useful idea. Our work is somewhat different, though, as we wish to allow the us er to issue approximate queries. We believe that performing a singl e sort for the best global result is not flexible and not always effective because users always have different interests, and their in terests also change with time. We have extended the basic paralle l coordinate technique in two major ways, namely, by adding trend figures and enabling querying by approximate matching. We now discuss them in turn. As mentioned in Section 2, th e classic parallel coordinate visualization does not consider the sequence in which the data records were generated or collected. Thus, it assumes that the order of the data records is of no significance. However, in product testing applications, the se quence in which the values are observed is very important a nd may reveal some sequence-dependent relations or cause-and-effect relations. In this work, we extend the cla ssical parallel coordinate method by adding an additional graph for each variable above its coordinate. In the supplemental gr aph, as shown at the top of Figure 2, the horizontal axis reflects the sequence of the data record, and the vertical axis show s its value in each data record. We call these graphs trend figures. They make it possible to quickly see variables that change in similar ways, by noting their similar trend figures. Trend figures are very useful for sequential types of data and do not crowd the space, i.e., 1. Each added trend figure sits a bove its coordinate. It uses the 2. In classic parallel coordinate visualization, the overlapping This extension is thus generic and readily applicable to other applications. Our second major enhancement to traditional parallel coordinate visualization is to allow the user to query shapes based on approximate pattern matching. Af ter the matching is completed, sorting of variables is performed, which enables the user to view the most interesting patterns in nearby sections of the horizontal axis. Two important types of patterns are the value change pattern and the failure pattern . For our mobile phone design application, the value change pattern of a variable shows how the variable X  X  value changes over different design change s. After a design change, if a variable value increases compared to its previous value, we say its value is  X  X p X , and we denote it with the character  X 3 X  in its value change pattern. If its value decreases after a design change, we say it is  X  X own X  and use the character  X 1 X  to represent it. If its value remains the same after a design change, we use  X 2 X  (stable) to represent it in the value change pattern. With these representations, the behavior history of the variable can be summarized using a value change pattern string. For example, the string  X 331 X  means that the value becomes larger after the first and the second changes, and then goes down after the third change. Queries can be issued using such value change strings. The failure pattern of a variable shows whether or not its value falls outside the upper or lower limit after a design modification. If the variable value is outside the acceptable range, we say that it acceptable range, we mark it with an  X  X  X  (OK). An example of a failure pattern is  X  X OOFFF X , which means that the variable is within the acceptable range for the first three design changes, but fails from the fourth design cha nge onward. The V-Miner system allows the user to query failure patterns. The value change pattern and failure pattern convert the numerical comparison task to string comparison, which is more convenient and intuitive for human users. Our system allows the user to issue queries by supplying the above two types of string patterns. We employ the edit distance [5] for string comparison. Ordering of variables in parallel coordinate visualization is done according to the comparison results. The query can be formed either by indicating an example data point or by specifying the shape of interest explicitly. In this section, we describe how our enhanced parallel coordinate visualization tool V-Miner has been used to discover useful knowledge from phone testing data th at can be fed back to design engineers, who can use the knowle dge to anticipate problems in the design process so as to reduce the number of design errors and to speed up the design process. The tool also allows the user to visualization, which turns out to be quite useful in practice. The overall goal for the Motorola application is to enable the engineers who design and prototype new products to identify the following:  X  Test variables that show prom inent changes in their values  X  The causes of these significant value changes, i.e., the  X  Those stable test variables that are not affected by current  X  Failure patterns of those vari ables that have failed after  X  Test variables that have si milar value change patterns.  X  Existing rules mined from previ ous or related projects that V-Mine is also integrated with other tools at Motorola so that the user can perform all the tasks in a data mining cycle. Mining can also be done recursively through data filtering. As with most data mining and visu alization applications, the first task is to normalize the raw data. Normally, the value range of each variable is made within a fixed range, e.g., -1 to 1. However, this method is not suitable for our data because: 1. It does not consider any user-s pecified target value, which is 2. It does not consider the lower and upper limits. Thus, it will We have designed se veral normalization methods that clearly separate values within the nor mal range from those outside the normal range. Variables whose values are out of range will be normalized to either larger than 1 or less than  X 1. Thus, the normalized values close to 0 are the ones that are close to the target values. The following is one example of them: 
Procedure normalization (value, min, max, target) // return value stores in: normalized_value This normalization makes it very easy for the user to visualize important patterns. The above me thod is only one of the possible ways to perform normalization. V-Miner offers the user a number of normalization methods from which to select. The user can also switch from one to another at any time to obtain better visualization for different datase ts and/or pending decisions. In our interviews with Motorola engineers who had used V-Miner, we found that this intuitive normalization was one of their favorite features of the software. We now present a typical knowledge discovery scenario. After normalizing the data and loading it into V-Miner, the user is presented with the visualization as shown in Figure 3. Due to confidentiality concerns regarding the actual product data, the test variable (attribute) names have been replaced with generic names  X  X est-Attribute-i X  in all the figures. In Figure 3, the main window on the left displays the parallel coordinate visualization of the data . Most of the user interactions with the system are performed in this window. The horizontal axis shows all the test variables. Th eir names are displayed below the horizontal axis. The vertical axis displays the normalized value of each variable after every component or design change. The information window on the right displays the detailed information as the user moves th e mouse cursor over points in the main window. The key features of the visualization include: 1. Data from different desi gns (component changes) are 2. For each test variable, a trend figure is drawn at the top of 3. There are two dashed lines on the vertical axes at Y = 1 and 4. The querying mechanism discussed in Section 3 allows the After loading data into V-Miner, the user can identify some significant characteristics from the visualization (Figure 3): 1. The user can easily identify which values of a variable are 2. From the trend figures on top of each variable, it is possible 3. Some variables have stable values over all the tests. In classic parallel coordinate vi sualization, the overlapping lines significantly hinder the visualization. Here, we observe that the trend figures mitigate this problem to a great extent, as the users can easily see the changes and trends of variables from the figures. Next, we present some example findings from our system. Suppose that at first, the user is interested in identifying stable variables, whose values do not ch ange a great deal over different design changes. It is possible to issue a  X 222... X  query on the value change pattern to obtain th is information. Figure 4 shows the query result based on the value change pattern. The test variables on the horizontal axis are ordered in such a way that stable variables appear first on the left side of the visualization. Note that V-Miner also allows the user to hide variables if they are deemed unnecessary for further analysis. This reduces the complexity of the visualization and enables the user to better focus on the remaining variables. In Figure 4, one can observe a very interesting phenomenon. Some variables, e.g., 18 and 19, fa il the tests after the first design modification, and their values remain in the failure range after that. The user can specify a query function on the failure pattern to see if any other test variable s display a similar pattern. Figure 5 shows the results of this query . In Figure 5, the values are reordered along the horizontal axis according to their similarity to the query variable. From the main visualization window, one can see that the first fourteen test variables have the same patterns. From the trend figures on top, it is clear that they fail all the tests except the first one. This reveals that during the first design modification, a certain component change had adversely affected these variables. Furthermore, the failures persist throughout all the subsequent design changes. Th is tells the user that this component has a major impact on these test variables and, therefore, should be the focus of their attention for the next prototype design. We can see that the trend figures again play an important role in this finding. Without the trend fi gures, it is difficult to interpret the main parallel coordinate visu alization, due to the overlapping lines. If one scrolls the visualization shown in Figure 5 to the right, one would see a different set of vari ables, as shown in Figure 6. Important features in this part of the visualization include the fact that the values of test variables 40 through 50 fluctuate a great deal. This means that many design changes can affect these variables' values and should prompt the user to study the associated portions of the circuit designs to find the underlying reasons for this fluctuation. The user may also want to identify test variables that always fail, no matter how the designs are m odified. The results shown in Figure 7 can be obtained by querying a specific failure pattern. Designers should pay special atte ntion to these variables in subsequent prototype designs. Although the queries, whose results were shown in Figures 4, 5, and 7, were performed for patterns that the user knew a priori to exist in the data, it is possible to use V-Miner to query the data for any arbitrary pattern. For example, one may wish to know whether any design modification can bring a test variable from fail back to normal. The user can issue the query for this failure pattern using the query string of  X  X O X , where  X  X  X  stands for failure, and  X  X  X  stands for normal. The system will display the variables sorted according to the query string. The results in Figure 8 show that design change s with corresponding  X  X O X  test variable values do exist in the data set. The  X  X urning points X  where variables change from  X  X  X  (failure) to  X  X  X  (within range) are possible interesting things for engineers. Figure 8. Results of an ad hoc query for the  X  X O X  pattern In the above demonstration, we mainly focus on querying and sorting variables, as well as helping the user narrow down the attributes to a more focuse d range. What makes V-Miner especially attractive is its ability to reuse engineers' previous data mining results in the form of da ta mining rules, and work with other data mining tools to form a data mining cycle. We discuss this in the next section. Internally, Motorola engineers are using several software tools for their data mining tasks, such as the DTE [12], which is a general data mining system. These tools have been used for a number of years, and there are some data mining results accumulated from these tools. Thus, there is the opportunity for combining V-Miner with existing tools and reusing th eir data mining results. V-Miner allows the user to use previous mined rules as a way to filter the data in the visualization. Filteri ng the data using rules means to display those data records that ar e covered by the rules or remove the data records that are not covered by the rules. The main purpose of data filtering is to id entify interesting data segments for further analysis. V-Miner, together with the data mining tools used by Motorola engineers, form a closed and recursive data mining task cycle. Each part reinforces the others. The process is illustrated in Figure 9. V-Miner visualizes the data, and allows the user to do visual mining and ad hoc querying. It can read rule files from other data mining tools for visualizing the data records covered by some rules and also using the rules to filter data. This helps the engineers to select a subset of data for further examination, i.e., the reduced set of data is used in the next data mining cycle. This process has been shown very effective in practice. One may ask why visualization is needed to filter the data because in many cases filtering can be done easily with a simple procedure. Visualization, however, plays an important role. V-Miner does not act simply as a tool that filters the data using rules. Instead, V-Miner provides an opportunity for the user to interact with the data visually. Through visualization the user can decide whether a sub-population is worth further study. When the user decides to filter the data usi ng a certain set of rules, the first step is to study the rules with respect to their applicable coverage. After the filtering is done, the user is able to see the immediate results, from which it is possible to verify previous assumptions on the data. Also, if the user is not satisfied, it is possible to undo the filter, and try another set of rules. This whole process is possible only with instant visualization and visual data manipulation. Clearly, this process is much more effective than writing a simple procedure to filter the data without the user visualizing the data. Note that before filtering the data, the user can visually manipulate the data. The user may also filter the data by values on certain attributes, etc. Last but not least, all these procedures can be used in conjunction with the visual mining options described above. The resulti ng sub-data set can be a very complex one, which is not possibl e to obtain without V-Miner. We now demonstrate part of this process using a different data set from the one for the first example in this paper. The data set is initially visualized as in Figure 10. At this point, the engineers have a set of rules from a data mining tool. These rules are loaded into V-Miner, and the user can select the rules to be used from Figure 11. The user has the option to use one rule or multiple rules to filter the data. The user can also apply the rule(s) to those data records currently on screen or to all the data, or to add those data that satisfy the selected rule(s) back to screen. We show an example in Figure 12. The filtering is done using two rules on the data set. If the user finds some interesting features from the results, i.e., the segment of the data, it is possible to save the data and study them using other data mining tools or do further mining using V-Miner. In this way, the data mining task can be done in a recursive manner, which leads to a finer granularity of mining. 
Figure 12. Visualization of aft er data filtering using rules. The visualization system described in this paper has been used by engineers at the Motorola Personal Communications Sector factory in Flensburg, Germany, a nd at Motorola Labs in Germany and the U.S. for more than a year . During this time, they have provided feedback regarding the application of the V-Miner software and have reported that the tool indeed helps them find useful patterns and informa tion from product test data.  X  Thanks to the enhanced normalization and visualization, it is  X  It is easy to see the failure patterns of variables and to group  X  Querying and sorting functions are used frequently to find ad  X  The visualization tool has help ed to confirm rules found by  X  The visualization system significantly speeds up the data  X  Using rules to filter the data in V-Miner facilitates the In this paper, we have intr oduced the V-Miner visualization system and described its app lication for mining mobile phone design and test data. V-Mine r implements two important extensions to classical parallel c oordinate visualization. Figures that show trends of the variables are added into the visualization to summarize sequence-dependent trends in the data. An edit distance based technique is also included to rearrange and group variables so that interesting patte rns can be easily identified, i.e., variables showing similar patterns are viewed in adjacent sections of the visualization. V-Miner also has a query engine that enables the user to specify patterns to be mined and displayed. Furthermore, the system can use rules to filter the data visually. This allows the use of data mi ning results from other tools in V-Miner. V-Miner, together with the other data mining tools, enables a data mining cycle, in which the user can narrow down the raw data for focused analysis or mining. Experimental results and feedback from Motorola engineers, who have used the V-Miner software for more than one year, indicate that the proposed methods are both powerful and easy to use. Two areas for future work have been identified. The first is to add functionalities to V-Miner so that it can also analyze time-series data. The second is to use V-Miner to guide product testing. Traditionally, data mining is perfo rmed after a large amount of data is collected. However, the probl em with this approach is that the data collected may not be the most appropriate for the application, and consequently few interesting patterns may be found. Thus, it is desirable to de velop a process in which testing (which generates data) and data mining are done concurrently. The key advantage of this appro ach is that testing is not done blindly. Instead, it is focused on the problems discovered from mining previous test data. [1] Agrawal R. and Srikant R.  X  X ast algorithm for mining [2] Agrawal R, Psaila G, Wi mmers E.L, Zait M.  X  X uerying [3] Alexakis A, Deftereos M, Samiotakis Y.  X  X he Parallel [4] Ankerst M., Berchtold S., Ke im D.A..  X  X imilarity Clustering [5] Baeza-Yates R.A.  X  X lgorithms for string matching: A [6] Goel A, Baker C., Shaffer C.A., Grossman B., Haftka R.T., [7] Inselberg A., Dimsdale B.  X  X arallel Coordinates for [8] Keim D.A., and Kriegel H.-P .  X  X isDB: Database Exploration [9] Lee H-Y., Ong H-L., and Singh K.  X  X isual Data Exploration [10] Ma S., Hellerstein J.  X  X rder ing Categorical Data to Improve [11] Quinlan J.  X  X 4.5: program for machine learning X . Morgan [12] Zhou C., Nelson P.C., Tirpak T.M., Xiao W., and Lane S.A., 
