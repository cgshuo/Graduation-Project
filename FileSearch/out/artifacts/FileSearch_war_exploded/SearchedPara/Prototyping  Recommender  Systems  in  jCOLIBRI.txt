 Our goal is to support system developers in rapid proto-typing recommender systems using Case-Based Reasoning (CBR) techniques. In this paper we describe how j colibri can serve to that goal. j colibri is an object-oriented frame-work in Java for building CBR systems that greatly benefits from the reuse of previously developed CBR systems. j colibri includes a case base of templates for case-based recommender systems that can be easily adapted to proto-type a great variety of alternatives. We describe the contents of the case base and show experimental results from our ex-perience using the recommender templates case base with mid-size projects from undergraduate students.
 H.3.1 [ Information Systems ]: INFORMATION STOR-AGE AND RETRIEVAL X  Content Analysis and Indexing ; I.2.1 [ Computing Methodologies ]: ARTIFICIAL INTE-LLIGENCE X  Applications and Expert Systems Algorithm s, Stand ardization
Case-based reasoning is a paradigm for combining problem-solving and learning that has became one of the most suc-cessful applied subfields of AI in recent years. CBR is based on the intuition that problems tend to recur. It assumes that new problems are often similar to previously encoun-tered problems and, therefore, that past solutions may be of use in the current situation [6].

The most important process in a CBR system is that of retrieval. In retrieval the CBR system assists the user to se-lect the most relevant past case for the problem at hand. A number of sophisticated techniques have been developed for elicitating a case description from the user and efficiently as-sessing similarity between the query and the available cases. developed a case base of templates for building case-based recommender systems which effectiveness has been tested through empirical evaluation.

The selection of an appropriate template can be a pro-blem in itself. Since it may be difficult for users to come up with a good specification of the requirements of a system, we have exploited the executable nature of templates. j colibri includes a recommendation module that helps the user to se-lect the most convenient template for his problem. The sys-tem lets the user navigate the set of available templates by proposing templates that the user may actually run. Based on the execution, the user may provide feedback in order to further navigate the template collection. The underlying mechanisms for this form of navigation by proposing, which we have named retrieval-by-trying , are described in [14].
The rest of the paper runs as follows, Section 2, describes how to build systems in j colibri .Section3presentsthe templates for recommender systems included in j colibri . Section 4 describes the methods used to instantiate tem-plates into executable systems. Section 5 presents the re-sults from an empirical evaluation using the recommender templates case base for building mid-size projects from un-dergraduate students in our University. Finally, Section 6 concludes the paper and describes future work. j colibri is a Java framework for building CBR systems 1 . j colibri offers capabilities to persist and access cases in dif-ferent formats and a library of reusable methods that can be reused to build CBR systems. In the current version there are two different ways of designing systems: method-based and template-based that are briefly described in this section. we refer the interested reader to [7, 14] for more details on these issues. 2 The basic way of designing CBR systems in j colibri is a method-based design process that relies on decomposition methods that solve a certain task by breaking it into subtasks. Building a CBR system with j colibri is a process of configuration: the system developer selects tasks that the CBR system must fulfil and, for every primitive task, assigns one of a set of competing methods to achieve the task, where a method is an actual Java imple-mentation. Non-primitive tasks decompose into subtasks, which themselves may be primitive (achieved by methods) or non-primitive (requiring further decomposition). Ideally, every task and method that a system designer needs will already be defined; more realistically, s/he may need to im-plement some new methods and, more rarely, to define some new tasks [7]. In its current version j colibri is a white-box framework that make it easier for programmers to add new methods to its repository.

With this method-based design process, the reusable com-ponents are tasks, methods and case storage utilities. This is a bottom-up kind of design where reusable pieces are tasks and methods. We are currently working on a new way of de-sign where we high up the level of granularity of the reusable pieces. We define the idea of templates, as abstractions over past systems, and we build a library of templates obtained from a previously designed set of CBR systems. In case-http://gaia.fdi.ucm.es/projects/jcolibri
Although the methods library is already available as open-source, the template-based design tool will be available be-fore 2009.
As we have described in previous section, template-based design in j colibri is based on retrieving and reusing tem-plates from a library of templates (i.e. a case base of system design experience). As a case study, we have done an analy-sis of recommender systems that is based in part on the con-ceptual framework described in the review paper by Bridge et al. [4]. The framework distinguishes between collabora-tive and case-based, reactive and proactive, single-shot and conversational, and asking and proposing. Within this fra-mework, the authors review a selection of papers from the case-based recommender systems literature, covering the de-velopment of these systems over the last ten years.
We represent templates graphically as shown in Figures 1, 2, 3 and 4. Each rectangle in the template is a subtask. Simple tasks (shown as blue or pale grey rectangles) can be solved directly by a resolution method. Complex tasks (shown as red or dark grey rectangles) are solved by decom-position methods having other associated templates. There may be multiple alternative methods to solve any given task.
We take the systems X  interaction behaviour as the funda-mental distinction from which we construct templates: 1. Single-Shot Systems make a suggestion and finish. Fi-Figure 4: Methods for solving the One-Off and Iter-ated Query Elicitation tasks.
For lack of space, we cannot give diagrams for most of the templates mentioned in this section.
Because we are focussing on case-based recommender sys-tems (and related memory-based recommenders including collaborative filters), Retrieval is common to all our recom-mender systems. Retrieval is a complex task, with many alternative decompositions. The choice of decomposition is, of course, not independent of the choice of decomposition for One-Off Preference Elicitat ion and Iterated Preference Elicitation. For example, if One-Off Preference Elicitation delivers a ratings profile, then the method chosen for achiev-ing the Retrieval task must be some form of collaborative recommendation.

In many cases, retrieval is a two-step process where a scor-ing process is followed by a selection process. Nevertheless, there are alternative decompositions of the Retrieval task that would not have this two-step nature. For example, filter-based retrieval, where th e user X  X  preferences are treated as hard constraints, conventionally does not decompose into two such steps. On the other hand, there are recommen-der systems in which Retrieval decomposes into more than and Navigation-by-Proposing for Iterated Preference Elici-tation, preferring the former while the set of candidate items remains large [17]. In fact, we have confirmed that we can build a version of ExpertClerk based on the template in Figure 3 and using methods discussed in this paper. But, for reasons we do not have space to discuss, we found we needed a special decomposition of Figure 3 X  X  Display Item List task. This informally illustrates the promise of our ap-proach: complex systems (such as ExpertClerk) can be con-structed by adapting existing templates.
The generic templates exposed in previous section have been already included in the j colibri framework, and are available to be used. As we described in Section 2 we are working a semantic tool to refine each complex task into several decompositions and assign an appropriate method that could solve each simple task. This way the tool could generate a completely implemented recommender. In this section we describe the different methods included in the library, that can be assigned to solve the tasks in the tem-plates. However, the description of the representation, se-lection and instantiation of templates is out of the scope of this paper although a detailed explanation can be found at [14]. This paper focuses on the evaluation of template based design of recommender systems.

Our framework includes several final templates where each complex task is decomposed into simple ones. These final templates extend the three generic templates shown in Fi-gures 1, 2 and 3. Templates are instantiated into one or more recommenders where each task is solved by a method of the framework. These implemented templates serve as examples that the framework offers to develop new recom-menders by extending or modifying their code. This way, the examples follow the behaviour defined by the templa-tes and illustrate the complete code of a real recommender Currently, our framework includes 10 final templates and 14 examples of systems that show how to use them.

The j colibri  X  X  methods to implement recommender sys-tems are organized regarding the simple task they solve. For example, we have several methods to implement the  X  X ases Selection X  task that can be switched in the code as they have the same signature. Some methods were originally de-veloped for CBR purposes and take advantage of the ex-perience of several years of framework development. Next, we briefly describe the methods that are already included in the library of methods. We do not claim these are the only methods that are useful to solve each task. The library can be extended with other methods.
Retrieval task obtains and ranks items to be presented to the user. It can be solved by one of the following methods:
There are different strategies to modify the user preferen-ces according to item X  X  critiques [11]:
There are other methods to display item X  X  lists, make cri-tiques, display attribute questions (for NbA), manage user profiles, etc. Any developer could use the framework by di-rectly composing these methods (method-based design) or reusing one or more of the given examples (template-based design). Following section describes some experimental re-sults that compare both design approaches to develop re-commender systems.
Before starting this work, our initial hypothesis was that the conceptualization of system behaviour into templates could serve to ease the development process. Therefore, af-ter developing the recommender X  X  templates and the corres-ponding examples we tested experimentally the viability of this approach. To achieve this goal we used a group of 50 students of an Artificial Intelligence and Knowledge Based Systems course at the Complutense University of Madrid, and proposed them to: 1. Design a recommender system. 2. Choose a development process: independent (without 3. Implement the recommender and provide feedback about
Note that these students had medium programming skills and no previous experience in this field. They were given se-veral databases about movies, videogames, music, etc. that they could use to create the recommender. They use j colibri connectors to get the databases and use them as case bases of the recommender system. They could also think about a
In a general way, the experiment was very successful al-though we did not force them to use j colibri and we biased the students to develop collaborative recommenders whereas our framework only has one template that shows how to im-plement them.

Regarding the initial impressions of the framework, Fi-gure 6 shows the results of the first survey that was filled out after the guided introduction to j colibri . It reflects a smooth learning curve and a good global acceptance of the framework, mainly due to the plentiful documentation that also includes a complete tutorial 3 .

The intermediate survey measured the development pro-cess followed by the students. Surprisingly, all the students chose to use our framework: 62,5% by adapting the exam-ples (template-based design) and the remaining by reusing the methods (method-based design). After reviewing the re-commenders implemented by the students we noticed that the election of the design process had not a clear expla-nation. Some students chosen the template-based design and made several modifications to the examples, obtaining unusual recommenders. On the other hand, the students that followed the method-based design created systems that were also close to the examples included in the framework. Anyway, we could find two main reasons to use this second approach. The first one, is the design of a incorrect recom-mender which behaviour could drive, for example, to empty results. Another reason was the incorporation of special fea-tures or methods required by the domain. As example, let X  X  cite a book recommender that implemented the item-to-item collaborative method of Amazon, or a Meetic style system that needed a specific initial filtering over the user X  X  profiles.
Although the selection of the design process was not clear, our final impression is that templates were always very close to the students X  designs. Some of them used directly the template-based approach while other chose the method-based design although actually implementing a system very similar to a (combination) of available templates. This conclusion was confirmed by the intermediate survey where we mea-sured the coverage of the templates. Here, students had to compare their designs to the templates before they receive the introduction to j colibri in the second lesson. Figure 7 shows the similarity of each template with respect to stu-dents X  designs. To obtain this result, students gave a value to each template according to their opinion about its simi-larity to their own design. The average of the maximum similarity given to a template is 8.25. It means that the stu-
Available at: http://gaia.fdi.ucm.es/projects/jcolibri/ jco-libri2/docs.html
In this paper we described how to use j colibri ,aJava framework to design Case-Based Reasoning systems, to help developers in rapidly prototyping recommender systems using CBR techniques. We have presented two different system de-sign approaches: method-based and template-based design.
Template-based design is based on retrieving templates from a library of templates that represent generalizations of systems; the designer will choose and reuse one or more of them.

Basedonananalysisofrecommendersystemsfromthe case-based recommender systems literature, we have pro-posed a library of templates a nd a library of reusable me-thods to instantiate these templates.

Regarding related work, it is specially relevant the work by [8]. This system also uses a graphical environment to define the workflow of a recommender and generate the ap-plication. However it is only focused in the development of advisers exploiting deep knowledge level and does not allow to generate the wide range of recommenders included in the j colibri  X  X  library of templates.

In this paper we have tested our initial hypothesis that the conceptualization of system behaviour into templates eases the system development process. We have tested experimen-tally the viability of this approach with a group of students from our university. We proposed them to design a recom-mender system with or without templates and to evaluate the design approach.

Results showed that the template-based design was chosen by 62% of students and it greatly simplified the development process. Moreover, only 25% students had to implement new code that was not covered by the library of methods included in the framework.
This work has been supported by the Spanish Commit-tee of Education and Science project TIN2006-15140-C03-02 and it has been partially supported by the Comunidad de Madrid Education Council and UCM (consolidated re-search group 910494). We also thank the students that have participated in the course. [1] R. Bergmann. Experience Management: Foundations, [2] K. Bradley and B. Smyth. Personalized information [3] D. Bridge and A. Ferguson. An expressive query [4] D. Bridge, M. H. G  X  oker, L. McGinty, and B. Smyth. [5] R. Burke. Interactive critiquing forcatalog navigation [6] D. Leake (Ed.). Case Based Reasoning. Experiences,
