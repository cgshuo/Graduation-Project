 The labeling scheme is designed to label the XML nodes so that both ordered and un-ordered queri es can be processed without accessing the original XML file. When XML data become dynamic, it is important to design a labeling scheme that can facilitate updates and support query processing efficiently. In this paper, we propose a novel contai nment labeling scheme called DXCL (Dynamic XML Containment Labeling) to effectively process updating in dynamic XML data. Compared with the existing dynamic labeling schemes, a distinguishing feature of DXCL is that DXCL is compact and efficient regardless of whether the documents are updated or not. DXCL uses fixed length integer numbers to label initial XML documents and hence yields compact label size and high query performance. When updates take place, DXCL also has high performance on both label updates and query processing especially in the case of skewed insertions. Experimental results conform the benefits of our approach over the previous dynamic schemes. H.2.4 [ Database Management] : Systems  X  Query processing Algorithms, Performance. Dynamic XML Data, Containmen t Labeling scheme, Update. XML becomes an important standa rd for data representation and exchange on the web and elsewher e. Labeling schemes have been wildly adopted to process query over XML data which conform to an ordered tree-structured data model. Labeling schemes facilitate XML query processing by assigning a unique label to each node in the XML tree. In such a way, the structural relationships of the nodes such as ancestor/descendant, parent/child can be efficiently established. database management systems. It provides several advantages over prefix labeling scheme [2]. The label size of containment scheme is not affected by the structure of the XML documents; whereas the sizes of prefix labels increase linearly with the depths of XML document, which makes prefix labeling scheme performs poorly if XML documents are deep and complex. In addition, when querying XML data, the prefix based scheme needs a prefix comparison for the determination of the structural relationships, which spends more time than ordering operations. XML documents, an insertion of a node incurs re-labeling of large amounts of nodes, which is costly and becomes a bottleneck. The existing approach to design dyna mic containment labeling scheme is based on the notion of encodi ng, which includes CDBS [3] and QED [4]. The encoding approaches transform the original containment labels to some dyna mic formats which can avoid re-labeling when updates take pl aces. However, the encoding schemes are no entirely satisfactory. Firstly, transforming labels into dynamic formats incurs extra labeling cost and larger label size. In addition, since encoding approaches generate the codes not sequentially, they all require creating encoding table with size O( N ) for labeling N nodes. It may fail to process large-scale XML documents when limited memory is available. scheme both have advantages and disadvantages: the dynamic labeling schemes are preferred for XML documents that are frequently updated, in which cas e the performances of static labeling schemes degrade significantly as large amounts of nodes need relabeling; in contrast, wh en the XML documents are not or rarely updated, the static documents are more efficiently supported by the static labeli ng schemes as applying dynamic schemes to documents would resu lt in extra encoding cost and querying inefficiency. For getti ng better performance, we should choose between the static schemes and the dynamic schemes to label the XML document in accordance with its updating frequency. In practice, however, the line between static and dynamic XML documents is often blurred since the updating frequency of a document varies according to time. Hence making a choice between the static schemes and the dynamic schemes is not an easy thing and in many cases it may turn out to be contrary to one's expectations. It is of great interest to design a labeling scheme tailored for both static and dynamic XML documents. labeling scheme called DXCL which doesn X  X  need transform the original labels to dynamic format but can effectively process updating in dynamic XML data. DXCL labels initial XML document based on integer numbers which are stored with fixed bits, and therefore yields cheap label costs as well as compact label size and high query perfo rmance. Moreover, when XML becomes dynamic, DXCL completely avoids relabeling and its label quality is resilient to skewed insertions. Due to space constraint, we only focus on XML labeling and encoding techniques related to containment labeling scheme. scheme [1], every node is assigned three values: start , end and the level in the XML document tree. For any two nodes u and v , u is an ancestor of v iff the interval of v is contained in the interval of u . Additionally, with using the level of a node, the parent-child relationship can be determined efficiently. Document order can also be deduced well by the comparison of start values. However, containment labeling scheme can not support updates efficiently. An insertion of a node incurs relabeling of all its ancestor nodes and all the nodes after this node in document order. when XML updating. By applying an encoding scheme to containment labeling scheme, the original labels are transformed to some dynamic codes which can efficiently process updates. QED[4] encoding scheme transforms labels to QED codes. Given three integer numbers 1,2, 3 where each number is stored with 2 bit, i.e. 01, 10 and 11, a QED code is a sequence of these numbers which ends with 2 or 3. QED codes are compared based on lexicographical order and robus t enough to allow insertions without re-labeling. For example,  X 22 X  can be inserted between  X 2 X  and  X 3 X  whereas  X 212 X  can be inserted between  X 2 X  and  X 22 X . In additional, QED completely avoids the overflow problem as the number 0 does not appear in QED code itself and can be served as the separator of the different codes. However, the sizes of QED codes increase fast for skewed insertions. For example, suppose there are many codes that are required to be inserted one by one before a QED code  X 332 X , then each insertion requires that two more bits should be added for the new inserted code, i.e., the new codes will be  X 3312 X ,  X 33112 X ,  X 33112 X  etc. The fast increase of code lengths make QED perform poorly. The other encoding scheme CDBS [3] is similar to QED except that its encoding unit is binary bit. Compared with QED, CDBS is compact and its labeling cost is small, but CDBS cannot completely solve the re-labeli ng problem in frequent updates due to its overflow problem. scheme called P-Containment is proposed. Rather than storing the level information, P-Containment scheme stores the start value of the parent of the node. With the parent information, the parent-child relationship can be determined faster and the sibling relationship can be determined mu ch faster. Furthermore, when dynamic encoding schemes are applied, P-Containment can efficiently process the internal node insertions. Prefix labeling schemes, however, cannot intrinsica lly avoid re-labeling when an insertion takes place between child and parent nodes. Our labeling scheme DXCL is based on P-Containment (see Sec.2), and solves the update sensitive problem. We first introduce some correlative conceptions on DXCL code. Definition 1 (Quaternary String, QS) Given a set of integer numbers A={1,2,3} where each number is stored with 2 bit, i.e.  X 01 X ,  X 10 X  and  X 11 X . A quaternary string is (q 1 is the code size; q t  X   X  {2, 3}and q i  X  A, 1  X  i  X  t-1.
 Definition 2 (DXCL Code, DC) DXCL Code is a integer number N concatenating a quater nary string, i.e. DC=N (N.q 1 q 2 ...q t ), where N is store with fixed bits and t  X  0. number and therefore we can apply the integer number to label initial XML document;(2).The delimiter  X . X  in a DXCL code (N.q 1 q 2 ...q t ) is not needed to be stored since the integer number N is of fixed length; (3). The same as that of QED [4], number 0 (stored with 2 bits, i.e.  X 00 X ) does not appear in the quaternary string field because it servers as the separator to identify the different DXCL codes. In su ch a way, DXCL could never encounter the overflow problem. Example 1 DXCL uses the number 0 (2 bits) to separate different codes. For example,  X 9.2209.230 X  w ill be separated to  X 9.22 X  and  X 9.23 X . Importantly, it avoids the overflow problem in this way. Definition 3 (Lexicographical order p ) Given two DXCL codes S :M.p 1 p 2 ...p s , and S R :N.q 1 q 2 ...q t , S L p S following three conditions holds: C1. M&lt;N; C2. M=N, s&lt;t and p 1 =q 1 , p 2 =q 2 ,..., p s =q s ; C3. M=N and  X  k  X  min(s, t), such that p 1 =q 1 ; p 2 =q Example 2 We have  X 9 X  p  X 10 X  based on condition C1 .  X 9 X  p  X 9.2 X  since  X 9 X  is a prefix of  X 9.2 X , which satisfies C2 . Based on C3 ,  X 9.233 X  p  X 9.3 X  because the comparison is from left to right. DXCL labels the initial XML tree based on integer numbers which are stored with fixed bits. S uppose the total number of the nodes in an XML tree is K . Since we should assign start and end values to total K nodes, we need to generate 2 K consecutive integer numbers, and the size to store each integer is log Fig.1 shows an example of an XML tree labeled by DXCL. Note that each integer in Fig.1 is stored with 4 bits. We start by introducing two primitive functions to determine a new quaternary string that precedes or follows a given quaternary string S in lexicographical order. Suppose a sequence SEQ containing all the quaternary strings with size equal to that of S is arranged in increasing lexicographical order. We define BEF ( S ) this sequence . Specially, when S is the first string in SEQ , i.e. Example 3 Let 23 be a quaternary string, then SEQ is 12, 13, 22, 23, 32,33. Based on our definition, we have AFT (23)=32 and BEF (23)=22 . Likewise, AFT (12)=13, AFT (13)=22, ...; and BEF (33)= 32, BEF (32)=23, .... Specially, AFT (33)=3312 and BEF (12)=1133. The implements of AFT and BFE are shown in Algorithm 1 and Algorithm 2. Algorithm 1 AFT (S) 2 else if the last symbol of S is  X 2 X  3 then return S with the last symbol changed to  X 3 X ; 4 else if the last symbol of S is  X 3 X  6 if substring ( S , p , p )=  X 1 X  7 then return substring ( S , 1, p -1)  X  2  X  1 size(S ) -p -1 9 return substring ( S , 1, p -1)  X  3  X  1 size(S ) -p -1 Algorithm 2 BEF ( S ) 2 else if the last symbol of S is  X 3 X  3 then return S with the last symbol changed to  X 2 X  4 else if the last symbol of S is  X 2 X  5 S T  X  substring ( S , 1, size ( S )-1); 6 denote the position of the lastly encountered  X 2 X  or  X 3 X  in 7 if substring( S , p , p )=  X 2 X  8 then return substring ( S , 1, p -1)  X  1  X  3 size(S ) -p 10 return substring ( S , 1, p -1)  X  2  X  3 size(S ) -p code between two ordered DXCL codes, which guarantees that we can update the XML document without re-labeling. Algorithm 3 GetInsertedCode ( S L , S R ) Input: DXCL codes S L and S R Output: DXCL code S M , such that S L p S M p S R 1 if size ( S L ) = size ( S R ) then S M  X  S L  X   X 2 X  2 else if size ( S L ) &lt; size ( S R ) then 3 S T  X  substring ( S R , size ( S L )+1, size ( S R ) ) 4 S M  X  S L  X  BEF ( S T ) 5 else S T  X  substring ( S L , size ( S R )+1, size ( S 6 S M  X  substring ( S L , 1, size ( S R ) )  X  AFT ( S T ) 7 end 8 return S M Theorem 1 Given any two DXCL codes S L and S R which satisfies S L p S R , we can always find a new DXCL code S Algorithm 3 such that S L p S M p S R lexicographically. Proof If size ( S L ) = size ( S R ), then S M = S If size ( S L )&lt; size ( S R ), then S L p =substring(S Moreover, let S T = substring ( S R , size ( S L )+1, size ( S quaternary string and we can get BEF ( S T ) which is smaller than S lexicographically. Thus S L p S L  X  BEF ( S T ) p S L  X  S (S , 1 ,size (S L )  X  S T =S R . Let S M = S L  X  BEF ( S If size ( S L )&gt; size ( S R ), then substring(S L , 1 ,size (S In additional , let S T = substring ( S L , size ( S R a quaternary string and we can get AFT ( S T ) which is larger than S lexicographically. Thus S L = substring ( S L ,1, size ( S substring ( S L ,1, size ( S R ))  X  AFT ( S T ) p S R  X  AFT ( S S = substring ( S L ,1, size ( S R ))  X  AFT ( S T ), then S Example 4 To insert a code between  X 9 X  and  X 10 X , since they are of same size, we concatenate one more  X 2 X  after  X 9 X  to get the inserted code, which is  X 9.2 X . To insert a code between  X 9 X  and  X 9.2 X , since the size of  X 9 X  is smaller than that of  X 9.2 X , we get S =  X 2 X  (see line 3 in Algorithm 3) and then concatenate BEF ( S  X 12 X  after  X 9 X  to get the inserted code, which is  X 9.12 X . Similarly, we can get the inserted code  X 9.3 X  between  X 9.2 X  and  X 10 X . the quaternary string field in a DXCL code to be  X 2 X  or  X 3 X . We use an example to show the reason. Example 5 Suppose there are two codes  X 9.1 X  and  X 9.11 X . We have  X 9.1 X  p  X 9.11 X , but we can not insert anther code S that  X 9.1 X  p S M p  X 9.11 X . Hence we require the quaternary string field in a DXCL code to be ended with  X 2 X  or  X 3 X .
 XML updating without re-labeling the existing labels. Example 6 To insert a node  X  a  X  in Fig. 1, we should insert 2 node c  X 10 X . If we use the original containment scheme, we can not insert a code between  X 9 X  and  X 10 X  and we must re-label the existing nodes. Based on our GetInsertedCode algorithm, we insert a code  X 9.2 X  between  X 9 X  and  X 10 X , and then the start value of the inserted node  X  a  X  is  X 9.2 X . The end value of node  X  a  X  is an insertion between the code  X 9.2 X  and  X 10 X , which is X 9.3 X . We don X  X  need to re-label any node but can keep the labeling scheme working correctly. It is similar fo r the insertions in other positions. example to analyze the DXCL label size after skewed insertions. Example 7 Suppose there are 2000 nodes which are required to be inserted repeatedly before the node  X  c  X  in Fig.1. Then we should generate 4000 DXCL codes one by one between  X 9 X  and  X 10 X . Based on our algorithm, the first 2 codes are  X 9.2 X  and X 9.3 X , which can be stored with 8 bits(equal to 4+2  X  1+2, where the last 2 is the size of the separator 0);Likewise, the following 2 codes are  X 9.32 X  and  X 9.33 X  stored with size 10; 6 codes  X 9.3312 X ,  X 9.3313 X ,  X 9.3322 X ,  X 9.3323 X ,  X 9. 3332 X  and  X 9.3333 X  are stored with size 14; 54 codes  X 9.33331112 X ,...,  X 9.33333333 X  are stored with size 22; and all the rest codes are stored with size 38. It can be seen that the label size of DXCL is little affected by ordered insertion sequence. In contrast, the sizes of CDBS and QED codes increase at 1 or 2 bits per insertion. scheme which does not re-label nodes must increases linearly in the worst case. DXCL cannot escape from this claim also. DXCL needs to assign labels of size O ( n ) when n nodes are inserted between two consecutive nodes left and right as follows: the first node M is inserted between left and right ; then the second node is inserted between left and M ; the insertion of the i th takes place between the ( i-2) th inserted node and the ( i -1) inserted node. Clearly, this is norma lly extremely rare in practice. We evaluate DXCL against CDBS and QED using P-Containment labels. We don X  X  compare DXCL against Ordpaths(see SIGMOD 2004) and DDE(see SIGMOD 2009) as they are prefix-based schemes. Table 1 show s the test datasets. Dataset Doc. No. of nodes Max/average depth We test the performances of diffe rent schemes labeling on D1-D5. the size of the encoding table and show the result in Fig.2 (a). We observe clear difference of memory usages between difference schemes. This result conforms to our previous discussions that DXCL need no encoding table whereas both CDBS and QED need a tables of size O ( N ) where N is the nodes number. DXCL can process large XML documents with limited memory available. time of different containment sc hemes. DXCL spends smallest time since it doesn X  X  need to transform labels into dynamic formats as those of CDBS and QED. Additionally, QED needs longest encoding time since QED encodes longer strings and has time-consuming division operation by  X 3 X . label size as QED is stored with quaternary string and  X 0 X  cannot appear in the QED code itself, which is a waste. Compared with CDBS codes which are stored with variable length, DXCL is more compact. We discuss the performances of two kinds of frequent updates. nodes are uniformly inserted between two consecutive nodes left and right where the end value of the node left and the start value times. At the first time, one node M is inserted between left and right . At the second time, another 2 new nodes are inserted between every two consecutive nodes which lie between left and right , i.e., one is inserted between left and M and the other between M and right . At the k th time ( k =1, 2,..., n ), 2 are inserted similarly. We study the average label size of new inserted nodes after uniform inserti ons. As is shown in Fig.3 (a), the label size of DXCL shows a little overhead compared with that of QED. However, the difference is negligible. Both DXCL and QED assign labels to update d nodes using quaternary strings and thus their label sizes are approximately the same. Though the label size of CDBS is smallest , it cannot avoid re-labeling in XML frequent updates. encounter overflow problem in the case of skewed insertions as it uses fixed bits to represent its size. Therefore we just compare our DXCL against QED. We test the case that n nodes are inserted one by one before a particular node of which the start value is NIL . Fig.3 (b) shows the different label sizes after skewed insertions. The size of DXCL la bels only increases slightly whereas the size of QED labels has showed a much higher increase. This result illustrates the significant advantage of DXCL. Since all the three schemes compare labels based on lexicographical order, the label size is the primary factor in determining the query performances. We ignore the diagrams of the comparison of query performances here as they show the similar trends to that of Fig.2(c), Fig.3 (a) and Fig.3 (b). DXCL has high performance on query processing especially in the case of skewed insertions. In this paper, we have pres ented a novel containment labeling scheme DXCL which not only comp letely avoids re-labeling when updating, but also has compact size and high query performance. DXCL has controllable size for skewed insertions in which case the existing labeling schemes perform poorly. Experimental results have dem onstrated the benefits of our proposed labeling scheme compar ed to previous approaches. This research was supported by the Fundamental Research Funds for the Central Universities under Grant No. 2011121049. [1] C. Zhang, J. F. Na ughton, D. J. DeWitt, Q. Luo, and G. M. [2] I. Tatarinov, S. Viglas, K. S. Beyer, J. Shanmugasundaram, [3] C. Li, T. W. Ling, and M. Hu. Efficient updates in dynamic [4] C. Li and T. W. Ling. QED: a novel quaternary encoding to [5] E. Cohen, H. Kaplan, and T. Milo. Labeling Dynamic XML 
