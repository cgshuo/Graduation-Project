 I/O costs are wasted in dealing with these useless nodes. { e dressed to reduce the number of candidate nodes based on XML schema information. The contributions of this paper can be summarized as follows: performance and better efficiency. conclude this paper in Section 6. Fig.1(a). satisfying n &gt; k and k &gt; m . if  X  R  X  X  (R  X  S), not satisfying R  X  S and S  X  R.
 structured. n lemmas and thermos can not be included in this paper. 3.1 Filter Strategy relation of equivalence. between j, k and m. Thus, j, k and m must all lie in the same block of  X  . F node j , k and m are inlined as a new node n . n &gt;n 2 ,...,n k-1 &gt;n k , n k &gt;b. set in T , denoted by { p (a, b)}, is consists of the b nodes via the path p . exists only one reachable path from root to e 1 . { node ( e )}={ p 1 ( e )}. 3.2 Algorithm for Generating the Filter Expression final filter expression in line 6. Algorithm 1 FindFE ( p , IG ) Input : p is the path expression; IG is the ISG ; 
Output : the filter expression FE ; begin 1: InitEx( p ); 2: stage=0; 3: for each vertex u  X  V[ IG ] 4: do color[u]  X  WHITE; 5: SCAN(root,root,stage); 6: return MergeHT(); end. marked as WHITE (unvisited).
 MergeHT . procedure SCAN (u, s, stage) 
Input : u is the start node of this stage; s is the current scanned node; stage is the number of stage; begin 1: if stage  X  MAX_STAGE 2: return; 3: color[u]  X  GRAY; 4: Stack[stage].PUSH(u) 5: for each v  X  Adj[u] do 6: if color[v]=GRAY 7: if ((IsExisted(HT[stage],v)&amp;&amp;(Rel[stage]=AD)) 8: Add(HT[stage],u); 9: else 10: x  X  stagenode(v); 11: if x&gt;stage 12: SCAN(v,v,x); 13: if x&lt;stage 14: SCAN(v,s,stage); 15: if x=stage 16: if (Rel[stage]=AD) 17: Stack[stage]  X  HT[stage]; 18: else //FS 19: if (Depth(s,v)=1) 20: Stack[stage]  X  HT[stage]; 21: Stack[stage].POP(); end. sion in line 4. procudure MergeHT (); 
Output : the filter expression FE; begin 1: for each HT i of Hash Table Chain 2: do Calculate complement of HT i ; 3: ListC  X  Intersection of each HTi ; 4: return elements in ListP and  X  elements in ListC; end. O( n ). Therefore, the total amount of work is now bounded by O( n 2 ). Filter. bottom end of the window goes beyond the end of bit vectors. pression from line 8 to line 10. Algorithm BFX-Filter ( p , IG ) Input p is the path expression; 
Output List L of Candidate nodes; begin 1: fe = FindFE ( p , IG ); 2: enode = GetLastNode ( p ); 3: the extended bit vectors of nodes in fe , except 4: if ( IsExtended ( enode )) 5: Append Extended bit vector of enode to node-list ; 6 : else 7: Append Solid bit vector of enode to node-list ; 8: for each 32 rows of loaded bit vectors do 9: if( GetFilter ( fe )) 10: Add position to the tail of L ; end. in memory, when they are loaded. The cost of the running time is O( n ). bit vector of 0-V is the sequence of masks of bit 0, while the 1-V, bit 1. ber of blocks are skipped and loaded into the cache in processor. Algorithm SX-Filter ( p , IG ) Input p is the path expression; 
Output List L of Candidate nodes; begin 1: fe = FindFE ( p , IG ); 2: enode = GetLastNode ( p ); 3: Load the bit vectors of nodes, except enode , in fe ; 4: if ( IsExtended ( enode )) 5: Load Extended Signature Vector of enode  X  SV ; 6 : else 7: Load Solid Signature Vector of enode  X  SV ; 8: while (!IsEOF( SV )) do 9: if( GetFilter ( fe )) 10: Add position to the tail of L ; end.
 u then calculate the Header . The cost of running time is O(n). Algorithm CX-Filter ( p , IG ) Input p is the path expression; 
Output List L of Candidate nodes; begin 1: fe = FindFE ( p , IG ); 2: enode = GetLastNode ( p ); 3: Load the bit vectors of nodes, except enode , in fe ; 4: if ( IsExtended ( enode )) 5: Load Extended Header of enode ; 6 : else 7: Load Solid Header of enode ; 8: while (!IsEOF( Header )) do 9: GetthePosition( Headers )  X  position; 10: if( GetFilter ( fe )) 11: Add position to the tail of L ; end. est shift in header files (line 8-line 11). The cost of running time is O(n). (3) running time ; (4) the number of pages access . 5.1 Disk Storage Requirements the value of XMark factor. 5.2 Number of Elements Scanned due to the space limitation of this paper. two node sets. 5.3 Running Time average of 10 times run. positions to be evaluated. along with the crescent of block size. 5.4 Numbers of Page Accesses brute force scan can be applied to these files. tributed by I/O times. tion. 
