 The Web contains a large collection of documents, some with mathematical expressions. Because mathematical expres-sions are objects with complex structures and rather few distinct symbols, conventional text retrieval systems are not very successful in mathematics retrieval. The lack of a defi-nition for similarity between mathematical expressions, and the inadequacy of searching for exact matches only, makes the problem of mathematics retrieval even harder. As a re-sult, the few existing mathematics retrieval systems are not very helpful in addressing users X  needs.

We propose a powerful query language for mathemati-cal expressions that augments exact matching with approx-imate matching, but in a way that is controlled by the user. We also introduce a novel indexing scheme that scales well for large collections of expressions. Based on this indexing scheme, an efficient lookup algorithm is proposed. H.3.3 [ INFORMATION STORAGE AND RETRIEVAL ]: Information Search and Retrieval Design, Algorithms, Performance
Retrieving the mathematical content of the Web is cur-rently very limited. Conventional text retrieval systems are not tuned for mathematical expressions, which are ob-jects with complex structures and rather few distinct terms. Moreover, there is no clear definition for similarity between mathematical expressions, and merely searching for exact matches often results in missing useful information.
Each mathematical expression has two sides, its mathe-matical meaning, often expressed in L A T E X [6] or Presen-tation MathML [4], and its appearance, usually expressed using Content MathML [4] or OpenMath [3]. The majority of mathematical expressions on the Web are represented by their appearance. The lack of content information forces a retrieval system to rely mostly on the presentation of ex-pressions, which makes it hard to judge whether two expres-sions are mathematically similar or not. The relevance of two expressions depends on the users X  needs, and while in one users X  X  opinion two expressions are related, another user might find them totally dissimilar. For example, a user who is interested in sin 2 ( x ) might also be interested in sin but not in sin 2 ( x +1), and another user might find the former irrelevant and the latter useful. We know of no consensus for similarity in general. On the other hand, by limiting the search to exact matches, many relevant expressions will be missed, and the user might need to issue a large number of queries to find a useful answer. For example if the user is looking for probably address her needs.

Currently, the few content-based mathematics retrieval systems [5, 9] are limited to resources that encode the se-mantics of mathematical expressions, which are not very popular on the Web. There are a few mathematics retrieval systems [2, 8, 10, 12, 13] that rely on the presentation of mathematical expressions, but they either can find exact matches only, or they use a  X  X ag of symbols X  model that usually returns a large number of irrelevant results.
The rest of this paper is organized as follows. In Section 2, we describe the problems that we address in this paper. Our query language is described in Section 3. In Section 4 the indexing algorithm is explained, and in Section 5 the match-ing and lookup algorithms are presented. We finally present an evaluation of our algorithms before concluding the paper.
Given a mathematical expression, the problem is to find expressions that match it. In the absence of a consensus definition for similarity, we have no basis on which to judge relevance, which is necessary to build an automatic retrieval system. We therefore choose to augment the query with extra information from the user. In this paper we propose a powerful query language that uses various forms of wild cards. It is specific enough to reduce irrelevant results while it provides the flexibility to capture many similar expres-sions.

As an information retrieval system, the mathematics re-trieval system should scale well to the size of the Web which is a huge repository of mathematical expressions. Collect-ing these expressions and efficiently indexing them is also an important problem. We propose a novel indexing scheme that is efficient in terms of memory consumption and lookup time, and allows fast matching and lookup of expressions. Based on this indexing scheme, we propose an efficient lookup algorithm.

We assume all expressions are encoded with Presenta-tion MathML. There are translation tools that automati-cally translate expressions from most encoding schemes to this form [7, 11], so this assumption does not limit our re-trieval system. A MathML-encoded expression can be rep-resented as a tree, e.g. Figure 1. Our indexing and lookup algorithms are based on this tree representation.
As shown in the introduction, searching only for exact matches to a given expression is not adequate as some rel-evant expressions would not be retrieved. On the other hand, ranking mathematical expressions based on approxi-mate matching of expressions results in the retrieval of many irrelevant expressions. In general only the user can judge whether two expressions that look similar are useful for her or not. To solve this problem, in this section we propose a new query language that allows approximate matching of expressions, but in a controlled way.

We express queries as mathematical expressions that in-clude wild cards . The following wild cards are defined:
In the above, i is a natural number denoting the index of a wild card, e.g. [ N 1], [ O 3]. Ifinaquerywildcardsofthe same type have the same indices, they must match subtrees that are equal.For example if the query is [ V 1] [ V 1] ,thenit matches x x and y y but not x y , but if it is [ V 1] [ V 2] cards with no index, such as [ E ], are also allowed. If such a wild card is repeated, then the matching subtrees do not need to be equal. For example [ N ] x [ N ] matches 2 x 3 as 2 x 2 .

Constraints can be specified for wild cards in a query using a  X  X here X  clause. For example the query  X  X  E ] 2 [ O 1]3 where O 1  X  X  + ,  X  X   X  X atches x 2 +3, and ( x +1) 2  X  3 but not x 2  X  3. For a number wild card, a constraint on the range of the number can be specified, e.g.  X  x [ N 1] where 1  X  N 1 matches x 2 but not x 9 or x  X  1 . Constraints can be defined for other types of wild cards similarly. The following is a list of constraints that our system currently supports: The constraint on expressions allows us to perform subex-pression matching. For example  X  X  E 1] + 1 where E 1 con-tains x 2  X  X atches x 2 + 1 and or expressions that contain a quadratic.

We also support optional patterns, which are represented in braces, such as { E } . An optional part might not appear in some matching expressions. For example, x 2 +[ N ]matches x + 1 but not x 2 ,whereas x 2 { +[ N ] } matches both.
In our implementation we use L A T E X [6] to express our queries. Although we could have chosen to use any other markup language, L A T E X is widely used for publishing math-ematical information and is fairly easy to learn. In addition there are automatic tools that translate expressions from L T
E X to Presentation MathML, e.g. Tralics [7].
Assume we are given a set of mathematical expressions in the form of Presentation MathML trees. First, we as-sign a data structure called exp-info to each expression. It stores information such as the Web address of the pages from which the expression is taken, and a list of the labels of all leaves in the same left-to-right order that they appear in the tree. Then, we perform a simple syntactic normaliza-tion as follows. We remove nodes that represent numbers and variables. These nodes can be detected by the labels also remove the nodes representing brackets and add new nodes with a special label, e.g.  X () X , as the parent of the sur-rounded expression (see Figure 1-c) (Note that we are not performing any mathematical normalization.). In the rest of this paper we assume all trees are normalized and we use terms  X  X ree X  and  X  X ormalized tree X  interchangeably.
Some stored trees represent mathematical expressions taken directly from web pages, and some trees instead represent their subtrees. We call the former a web expression ,and the latter a proper subtree . The label of the root of com-plete trees is always  X  &lt; math &gt;  X , so they can be easily dis-tinguished from proper subtrees.
Our indexing algorithm is based on the observation that many subtrees appear repeatedly in various trees. To inves-tigate this, we ran experiments on a collection of 297,300 expressions taken from articles with various topics. (In Sec-tion 6 we explain how web expressions were collected.) The number of subtrees of specific sizes and the average number of their repetitions is presented in Figure 2, which shows that many expression trees share several common subtrees. The basis of our indexing algorithm is to store each sub-tree once only and to allow subexpressions to point to them. This significantly decreases the size of the index, and as we will explain later, it also speeds up the lookup algorithm. The motivation behind storing the structure of each tree in-dependently of the values of numbers and names of variables (by normalizing them as explained above) is to increase the number of common subtrees further. Figure 2: (a) The number of distinct subtrees of specific
We assign a hash signature to each subtree such that equal subtrees have the same signatures. A table of unique MathML (sub)trees, indexed by their signatures, forms the basis of our index. Each entry of the table contains the label of the root, and a list of pointers to entries corresponding to the list of the children of the root. Given a tree, we find the corresponding entry by computing its signature and looking it up in the table. Initially, the index is empty. We add expression trees one by one to the index. To add a tree, T , we first perform a lookup in the table. If it is found, we return a pointer to the corresponding entry in the table. We also update the exp-info if T is a complete tree. If T is not found, we add a new entry for T to the table. Then, we recursively insert subtrees that correspond to the children of the root of T in the index, and insert a list of the pointers to their corresponding entries in the entry for T . This algo-rithm guarantees that each tree is inserted once only, even if it repeats. In Figure 3 a schematic of the index is shown
Similar to an expression, a query is represented as a MathML tree, with some extra tags that represent wild cards and op-tional parts. We normalize a query tree as explained in Sec-tion 4 and also modify subtrees that represent wild cards. We also mark each optional subtree with a special flag that is stored in its root and remove the surrounding braces ( X  {} An example is shown in Figure 4. Figure 4: (a) A query tree representing { 2 } [ E 1] 4
Consider a tree, T . T.root is the root of T and C T is thenumberofchildrenof T.root . T [ i ], 1  X  i  X  C T ,isthe subtree rooted at the i th child of T.root from the left, and T [ i..j ] is the sequence of subtrees T [ i ]to T [ j ].
Given a query Q and expression E , match ( Q, E ) returns either true or false. If Q does not contain any wild card or optional parts, match ( Q, E ) is true if they have the same signatures. If Q contains wild cards, but the root is not itself a wild card, then if Q and E have different roots, the result is false. The result is also false if C Q &lt;C E . If there are k optional subtrees among the children of Q.root , then the result is false if C Q  X  k&gt;C E . If none of these cases happen, we recursively match the children of both trees using the boolean function m :
If the root of Q is a wild card, we evaluate the match as follows, and if the match is successful and the wild card has an index, we bind the wild card to E . First if the wild card has an index, we need to determine whether it has already been bound to a subtree because of a previous match having been made when matching another part of the query. If a subtree representing expression E is already bound to the wildcard represented by Q ,then Q matches E only if E and E are equal, i.e. have the same signatures. If no expression has previously been bound to Q , we need to compare the types of labels at the roots. If Q is a number wild card and E result is false. Similarly, variable, operator, and expression wild cards must match variables, operators, and expressions respectively. Otherwise, if there are no constraints on the wild card, we return true.

Assume Q is an operator wild card with the constraint that it should belong to a specific set of operators, S .It matches E only if E.root is  X  &lt; mo &gt;  X  and its child X  X  label is in S .If Q is an expression wild card and there is a constraint that E should contain Q , we match all subtrees of E against Q and return true as soon as a match is found; otherwise, if no match is found, we return false. While matching trees, we keep track of the matched nodes that represent numbers or variables (whose children are removed and stored in the exp-info during the normalization). It allows us to check constraints on number or variable wild cards by retrieving the corresponding values from the exp-info .

In Section 4, we showed that many subtree structures re-peat several times in various expressions. This implies that while performing a search, the same subtrees are repeat-edly compared against the query subtrees, so we can cache and reuse the result of these comparisons to optimize our lookup algorithm. In particular, we allocate a local cache for each index entry, and any time we attempt to match the corresponding tree against another tree, we first examine its cache. Only if a cache miss occurs do we run the more extensive match, whereupon we save the result in the cache.
In this section we present the results of the empirical eval-uation of our algorithms. We crawled a set of web pages totaling 60GB in size. We extracted 4000 mathematical ex-pressions encoded with MathML (content and presentation), 3000 of them from the web pages of the MathML test suite maintained by W3C. Some main publishers of mathemati-cal information, including Wikipedia and Wolfram, present x + y =( x 1 + y 1 ,x 2 + y 2 ) 275 ms [ N 1]+[ N 2] where N 1 = N 2 270 ms 2 + 4, 43 + 70 where E 1 contains sin (  X  [ V 1] ) and E 2 contains cos (  X  [ V 1] ) [ E 1] where E 1 contains x 2 460 ms 2 x 2 , x 2 , 1 x 2 and E 1 contains sin ( x ) where E 1 contains [ V 1] 2 mathematical expressions as images. They also annotate these with pieces of L A T E X. We could collect a set of 293,300 expressions encoded this way. After refining the expressions to fix their L A T E X errors, we translated the collected expres-sions into MathML using a T E X to presentation MathML translator [7]. So in total we could collect 297,300 expres-sions from various resources on the Web [1]. The results presented in this section are based on this set of expres-sions. We ran our experiments on a PC with a 3GHz AMD Athlon Dual Core Processor, 2GB memory, and Linux ver-sion 2.6.24-27 operating system.

We define a simple index to be a set of expression trees that are stored independently from each other. Note that in a simple index common subtrees are stored several times while in our index they are stored only once. Figure 5, in which the x-axis represents the number of indexed expres-sions, presents the ratio of the size of the simple index to the size of our index as new expressions are indexed. This figure implies that the size of our index grows slower as more Figure 5: The ratio of the memory usage of the simple expressions are indexed. The reason is that the size of the simple index grows linearly as new expressions are added while the size of our index increases slower because repeat-ing subtrees are stored only once.

Table 1 lists some sample queries and the lookup time (in milliseconds) for each one. Looking up queries that contain optional patterns or require subexpression matching takes relatively longer because in these cases generally a larger number of subtrees are matched. In all cases the lookup times of the listed queries are less than one second. Assum-ing that these queries represent a wide range of queries that our system supports, we can conclude that our matching and lookup algorithms are quite efficient.
We propose a novel and powerful query language for math-ematical expressions that allows users to issue queries that flexibly match various expressions. We also propose an effi-cient indexing scheme, and based on this indexing scheme, we propose fast matching and lookup algorithms. Our eval-uations highlight the performance of our algorithms in terms of memory consumption and lookup time. We believe that our query language will allow users to pose queries that match expressions relevant to their needs, but the effective-ness of the language remains to be tested. We also believe that our approach based on wild cards and our efficient in-dex can be applied to other tree-structured data matching, such as the retrieval of chemical formulae, symbolic logic expressions, or perhaps musical passages. [1] http://db.uwaterloo.ca/mathretrieval. [2] G. Bancerek. Information retrieval and rendering with [3] O. Caprotti, D. Carlisle, and A. Cohen. The [4] D. Carlisle, P. Ion, and R. Miner. Mathematical [5] T. H. Einwohner and R. J. Fateman. Searching [6] G. Gratzer. Math into L A T E X: An Introduction to [7] J. Grimm. Tralics, A L A T E X to XML translator . 2008. [8] F. Guidi and I. Schena. A query language for a [9] M. Kohlhase and I. A. Sucan. A search engine for [10] R. Munavalli and R. Miner. Mathfind: a math-aware [11] L. A. Sobreviela. A reduce-based OpenMath-MathML [12] A. Youssef. Search of mathematical contents: Issues [13] A. Youssef. Methods of relevance ranking and
