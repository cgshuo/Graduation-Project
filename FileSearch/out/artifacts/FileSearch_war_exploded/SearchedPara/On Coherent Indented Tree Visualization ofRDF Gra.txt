 The recent explosion of Linked Data has b rought about a large volume of graph-structured RDF data from various domains. To help human users find and con-sume it on the Web, a broad range of Linked Data search engines [3,13] and browsers [2,12] have been developed to collect, process, and present RDF data. However, it is challenging to present such machine-friendly, graph-structured semantic data in an open-domain environment, which domain-specific visualiza-tions [4,11] cannot inclusively support. Domain-independent visualizations like node-link diagram and indented tree are needed.

Whereas node-link diagram has been exte nsively studied [5] and its drawbacks have been discussed [10], what we focus on in this paper is indented tree, which has been successfully used in many applications and has shown its potential to visualize semantic data [6]. Although indented tree has been adopted by some Linked Data search engines and browsers [2,3], very little research attention has been paid to the fact that given a starting resource as root, a cyclic RDF graph (e.g. Fig. 1a) can be transformed, by dup licating vertices and reversing edges when necessary, into different tree repre sentations (e.g. Fig. 2a and Fig. 2b) and thus be visualized as different indented trees. A question that follows is whether and how these different representations influence the user X  X  browsing experience, which drives our research in this paper.

Our work is motivated by the observation that we still lack a general, effective way of presenting reversed edges in RDF. Conventional solutions either simply attach a special symbol (e.g. a hyphen) or words like  X  X s ... of X  to each reversed edge, giving rise to confusing property names like  X  X nfluenced- X  or  X  X s influenced of X  as illustrated in Fig. 1b, which are harmful to the user X  X  reading experience and frequently interrupt the user X  X  cognitive process. In light of this, we pro-pose to reduce the number of reversed edges as far as possible, to provide the user with a coherent indented tree visualization of RDF graph. Specifically, our contribution in this paper is threefold.  X  To our knowledge, we are among the first to give a formalized analysis of  X  We devise a two-step approach to transform an RDF graph into a tree rep- X  We empirically show the difference in co herence between tree representa-
The remainder of this paper is struct ured as follows. Section 2 formalizes the problem. Section 3 describes our approach. Section 4 reports experiments. Section 5 discusses related work. Section 6 concludes the paper with future work. Let I , B ,and L be pairwise disjoint sets, comprising all IRIs, blank nodes, and literals, respectively, which are known c ollectively as resources. An RDF triple B  X  L ). An RDF graph T is a set of RDF triples, which can be represented by an edge-labeled directed graph G =( V G ,E G ) where the vertex set V G comprises the t  X  T } ), and each edge e  X  E with pred ( e ). Figure. 1a shows an RDF graph visualized as a node-link diagram.
The essence of an indented tree visualiz ation is a vertex-and edge-labeled rooted tree where edges are all direct ed away from a particular root vertex. To transform an RDF graph G (which may contain cycles) into a tree TR ,we may have to map a vertex of G to more than one vertex of TR ; however, a bijection between the edge set of G and the edge set of TR is required. Since some edges of G may have to be mapped to TR in a reversed direction, we introduce a set of inverse labels I R satisfying I R  X  I =  X  , and define a function Definition 1 (Tree Representation of RDF Graph). Given an RDF graph G =( V G ,E G ) and a starting resource s  X  V G ,a tree representation of G starting from s is a vertex-and edge-labeled rooted tree TR =( V,E,L V ,L E ,r,f ) where  X  V is the vertex set,  X  E is the edge set consisting of ordered pairs on V ,  X  L V : V  X  V G is a surjection that labels each vertex in V with a vertex in V G ,  X  L E : E  X  ( I  X  I R ) labels each edge in E with an IRI or an inverse label  X  r  X  V with L V ( r )= s is the root, and called the starting vertex of TR ,  X  f : E  X  E G , defined by  X  e =( u, v )  X  E , f ( e )=( L V ( u ) ,L E ( e ) ,L V ( v ))  X   X  u  X  V G , |{ v  X  V : L V ( v )= u, d + ( v ) &gt; 0 }| 1 (where d + (  X  ) returns the The set of all tree representations of G starting from s is denoted by TR ( G, s ).
For instance, Fig. 2 illustrates two tree representations of the RDF graph in Fig. 1a, both with starting resource James_Cameron . Since this RDF graph contains cycles, vertices such as James_Cameron in Fig. 2a and Michael_Bay in Fig. 2b become labels of more than one vertex in tree representation. When visualizing a tree representation like Fig. 2a as an indented tree in Fig. 1b, the direction of an edge is presented from left to right. Further, both Fig. 2a and 2b contain reversed edges, and in Fi g. 1b we present an inverse label inv ( p )by prefixing p with  X  X s X  and suffixing p with  X  X f X .
 Let  X  ( TR ) denote he number of reversed edges in a tree representation TR . We argue that the tree representation in Fig. 2a is better than that in Fig. 2b because the former is with a smaller  X  and thus when being visualized as indented tree, the former appears more  X  X oherent X . We define the coherence of a tree representation TR as the percentage of non-reversed edges it contains: For instance, the tree representatio n in Fig. 2a contains 1 reversed edge (  X  =1) and its coherence is 12/13. By contrast, the one in Fig. 2b contains 7 reversed edges (  X  = 7) and its coherence is 6/13. (In both cases, | E | = 13.)
GivenanRDFgraph G =( V G ,E G ) and a starting resource s  X  V G ,weaim to find a tree representation in TR ( G, s ) that has the largest coherence: which is called an optimal tree representation of G starting from s . For instance, Fig. 2a gives an optimal tree representation of the graph in Fig. 1a starting from James_Cameron . Now we introduce an approach to generating an optimal tree representation for an RDF graph given a starting resource. RDF graphs consider ed in this section are assumed to be simple (i.e. without loops or parallel edges) and connected. The correctness proof of the approach and a discussion about graphs that are not simple or being disconnected are given in our technical report. 1 3.1 Overview We firstly present an overview of our two-step approach.

In Step 1 (c.f. Sect. 3.2), we transform not the entire but only a spanning tree (which is not necessarily a rooted tree) of the RDF graph into a tree represen-tation, which is only a partial tree representation of the entire RDF graph. For instance, for the RDF graph in Fig. 1a and starting resource James_Cameron , the tree representation in Fig. 2a is not completely generated in this step; only its subgraph excluding dotted vertices and t heir associated edges is generated. This subgraph, as a tree representation of a spanning tree of the RDF graph, is actually one that has the smallest  X  value among all the tree representations of spanning trees of the RDF graph starting from James_Cameron .Weobtain this subgraph with the help of an edge-weighted cost graph and its spanning arborescence of minimum weight as illustrated in Fig. 3.

In Step 2 (c.f. Sect. 3.3), we complete th e tree representation by transforming the remaining edges of the RDF graph. Since what we have transformed in Step 1 is a spanning tree, i.e., ever y vertex of the RDF graph has labeled a vertex of the partial tree representation, in Step 2 we can complete the tree representation by constantly adding new vertices and edges without introducing reversed edges, as illustrated by the dotted vertices and their associated edges in Fig. 2a. 3.2 Step 1: Transforming a Spanning Tree In this step, we find and transform a spanning tree of the RDF graph into a tree representation that has the smallest  X  value among all possibilities under a given starting resource.

A spanning tree of RDF graph G =( V G ,E G ), as a spanning subgraph of G , can be denoted by T =( V G ,E G )where E G  X  E G . An arbitrary spanning tree of G can be straightforwardly transformed into a tree representation (which is a partial tree representation of G ) according to Algorithm 2, where the toBeRe-versed mark on an edge of T is given in Algorithm 1 (c.f. Step 1.3) to indicate that the edge is directed to the starting r esource and thus needs to be reversed
Algorithm 1. Generating a spanning tree of an RDF graph from a span-ning arborescence of its cost graph.

Algorithm 2. Transforming a spanning tree of an RDF graph into a tree representation.
 to ensure that TR is a rooted tree. The spanning tree to be transformed is found by the following three sub-steps.
 Step 1.1: Constructing a Cost Graph. We firstly construct an edge-weighted directed graph, called cost graph, to refl ect whether or not a directed edge exists between each ordered pair of vertices of the RDF graph. Every pair of adja-cent vertices of the RDF graph will be co nnected by a pair of inverse edges in the cost graph, weighted by either 0 or 1, where 0 indicates the existence of a corresponding directed edge in the RDF graph, or 1 otherwise.
 Definition 2 (Cost Graph). Given an RDF graph G =( V G ,E G ) ,its cost graph is an edge-weighted directed graph G C =( V C ,E C ,w ) where  X  V C = V G is the vertex set,  X  E C is the edge set consisting of ordered pairs on V C with ( u, v )  X  E C if and  X  w : E C  X  X  0 , 1 } is an edge labeling function defined by:  X  e =( u, v )  X  E C , The strong connectivity of G C is ensured when G is connected.
 For instance, Fig. 3a shows the cost graph of the RDF graph in Fig. 1a. Step 1.2: Finding a Spanning Arborescence of Minimum Weight in the Cost Graph. In the cost graph, we aim to find a spanning arborescence of minimum weight with the given starting resource as its root. Recall that an arborescence is just a rooted tree, and the weight of an arborescence in an edge-weighted graph is defined as the sum of the weights of the edges in the arborescence. A spanning arborescence of the cost graph G C =( V C ,E C ,w ), as a spanning subgraph of G C , can be denoted by T C =( V C ,E C ,w | E E that for any given root, the existence of a spanning arborescence of G C is ensured by the strong connectivity of G C . A spanning arborescence of minimum weight Given the cost graph in Fig. 3a and James_Cameron as root, Fig. 3b illustrates a spanning arborescence of minimum weight of 1.
 Step 1.3: Obtaining a Spanning Tree from the Spanning Arborescence of Minimum Weight. We will show a way of generating a spanning tree of the RDF graph from a spanning arborescence (with root s ) of its cost graph, satisfying that the  X  value of the tree representation of this spanning tree starting from s is exactly equal to the weight of thi s spanning arborescence. Therefore, the desired spanning tree to be transformed in Step 1 will be the one generated from the spanning arborescence of minimum weight.

A spanning tree T of the RDF graph can be generated from a spanning ar-borescence T C (with root s ) of its cost graph according to Algorithm 1. In the tree representation of T starting from s obtained according to Algorithm 2, reversed edges exactly come from those generated by line 4 of Algorithm 1. Therefore, the  X  value of this tree representation is exactly equal to the weight of T C . For in-stance, the weight of the spanning arborescence in Fig. 3b is equal to the  X  value of the tree representation of the spanning tree it generates in Fig. 2a (i.e. the subgraph excluding dotted vertices and their associated edges). 3.3 Step 2: Transforming Remaining Edges Having generated a partial tree representation of the entire RDF graph, in this step, we complete the tree representation by transforming the remaining edges of
Algorithm 3. Completing a tree representation by transforming the re-maining edges of an RDF graph.
 the RDF graph. A key observation is that the transformation of a spanning tree gives rise to every vertex of the RDF graph labeling a vertex of the partial tree representation. As described by Algorit hm 3, we can transform each remaining edge ( u, p, v ) of the RDF graph to extend the tree representation by adding to it a new vertex v labeled with v and a new edge ( u ,v ) labeled with p where u is the vertex labeled with u in the partial tree representation. It can be verified that the result is a representation tree of the entire RDF graph, and no additional reversed edges are introduced in this step . For instance, in Fig. 2a, dotted vertices and their associated edges are transformed from the remaining edges in Fig. 1a. In this section, we will show the effectiv eness of the proposed approach by empir-ically comparing the coherence of tree representations of real-world RDF graphs generated by our approach and two popular baseline approaches. Then we will present a preliminary user study to show how the coherence of tree representa-tion influences the user X  X  browsing experience. Finally we will test the running time of our approach in practice. 4.1 Test Cases and Approaches Our experiments were carried out on a sample of the Billion Triples Challenge 2011 Dataset, 2 comprising 10,000 RDF documents (i.e. RDF graphs) that were randomly selected, with 10, 790 connected components as test cases. In each case, a vertex having the largest outdegree was designated as the starting resource.
Three approaches were compared in the experiments.  X  X FS generated a tree representation of an RDF graph by following a breadth- X  X FS was similar to BFS but followed depth-first search instead.  X  X OH generated tree representations according to Sect. 3. 4.2 An Empirical Analysis of Coherence Figure 4 depicts the cumulative distributions of coherence of tree representations generated by different approaches for all the test cases. All the three approaches generated fairly coherent tree representations at the level of coh  X  0 . 5formore than 98% of the test cases. When raising the level to coh  X  0 . 8, COH still achieved this for 93.42% of the test cases, whereas the percentages for BFS and DFS dropped significantly to 83.31% and 59.37%, respectively. Interestingly, COH generated tree repr esentations without reversed edges (i.e. coh =1 . 0) for 64.62% of the test cases (being almost twice as large as the percentages for BFS and DFS), indicating that reversed edges were unavoidable in the tree representations of approximately one third of the test cases.

To summarize, COH, which was designed to be the best possible approach to generating coherent tree representations, far outweighed the popular BFS and DFS in practice. BFS performed re latively well compared with DFS. 4.3 A Preliminary User Study We carried out a user study to reveal the relationship between coherence and user experience. Eighteen university students having considerable knowledge of RDF were invited to carry out browsing tasks. In each task, the RDF graph in a random test case was visualized as an inde nted tree based on its tree represen-tation generated by one of the three approaches. The subject was instructed to browse and then retell the informatio n provided. Each subject carried out two tasks based on each of the three approaches. The subject responded to ques-tions Q1 and Q2 in Table 1 after each task, and responded to Q3 after two consecutive tasks based on the same approach. Questions were responded using a five-point Likert item from 1 for strongly disagree to 5 for strongly agree.
Table 1 presents statistics about each subject X  X  average responses to Q1 and Q2 and response to Q3 based on each approach. Repeated measures ANOVA ( F and p ) revealed that the differences in subjects X  mean responses to the three ques-tions were all statistically significant ( p&lt; 0 . 05). According to Q3, subjects were overall slightly more satisfied with COH than BFS, both of which significantly outweighed DFS as revealed by LSD post-hoc tests ( p&lt; 0 . 05). Similar results were observed on Q1 and Q2, capturing subjects X  understanding of information and learning of graph struct ure, respectively. Specifically, COH was considered more helpful than BFS and DFS, although LSD post-hoc tests ( p&lt; 0 . 05) only saw significant differences between COH and DFS.
 It was noticeable that the coherence ranking of the three approaches (i.e. COH &gt; BFS &gt; DFS) given by Fig. 4 agreed with the response ranking given by Table 1. It would be interesting to further investigate the correlation between coherence and responses about user experience. We calculated the Spearman X  X  rank correlation coefficient (  X  ) between the coherence of tree representations provided to each subject and the responses made. On Q1 and Q2, positive  X  val-ues were observed on 15 (83.33%) and 12 (66.67%) subjects, respectively; and average  X  values were 0.26 and 0.21, respectively, indicating that coherence and user experience were notably dependent. 4.4 A Performance Test We tested the performance of our approach on an Intel Xeon E3-1225 v2 with 2GB memory for JVM. The average running time on all the test cases was 24 ms. Figure 5 shows the running time on each test case. The maximum running time needed for an RDF graph with not more than 2,000, 4,000, 6,000, 8,000, and 10,000 RDF triples was 90, 295, 426, 776, and 1,563 ms, respectively, being reasonably fast.
 Popular domain-independent ways of visualizing an RDF graph (or more gener-ally, graph-structured data) include node-link diagram, indented tree, and adja-cency matrix. Node-link diagram straightforwardly presents a graph to the user as it is represented conceptually, but is problematic in terms of usability par-ticularly when the graph has more than a manageable number of vertices or a complex structure [6,10]. Indented tree hasproventobemoreeffectiveinsuch cases [6]. In fact, people are probably more familiar with tree-like environment because a wide variety of types of data in the world have been organized in this way. Thanks to its focus on a given root vertex to start with, indented tree particularly suits entity browsing, and has been adopted by entity browsers like Tabulator [2] and entity search engines like Falcons [3]. Adjacency matrix also suits large graphs better than node-link diagram [9], and it helps to identify certain patterns of data [8].

Compared with node-link diagram and a djacency matrix, i ndented tree has received relatively not much research atte ntion. However, it is worth noting that a cyclic RDF graph can be transformed into different tree representations and thus be visualized as different indented trees. For instance, in Falcons [3], a tree representation is obtained by traversing the edges of the RDF graph in a breadth-first manner, whereas in this paper, we address the coherence of tree representations and propose to generate one that has the fewest reversed edges. We have shown in the experiments that different tree representations lead to a significance difference in user experience, which considerably depends on coher-ence . Besides, we are aware of some researc h that transforms an RDF graph into a tree or forest for indexing purposes [1] . However, coherence is not considered in that work because it is motivated by a different application scenario.
There are also many domain-specific visualizations [4,11], which however are out of the scope of this paper. We have presented a formalized analysis of indented tree visualization of RDF graphs from the coherence aspect. An indented tree visualization based on a coherent tree representation of RDF g raph is expected to smooth the user X  X  reading experience and reduce confusion and interruption to the user X  X  cognitive process caused by unfriendly, reversed presentation of RDF triples. Our prelim-inary user study has shown a notable dependence between coherence and user experience. Specifically, coherent indented tree visualization is beneficial to the understanding of information as well as the learning of graph structure, leading to improved user satisfaction. However, it would be interesting to explore other aspects of tree representation (e.g. depth, branching factors) that may influence the user X  X  browsing experience, which will be our future work.

We have proposed an approach to generating optimal tree representations in terms of coherence. In fact, the approach has been designed to handle not only RDF graphs but graphs in general, and we will apply it to other types of graph-structured data in future work. As to RDF data, we plan to extend our approach by exploiting the semantics of OWL (e.g. inverse properties) so that more reversed edges may be avoided.
 Acknowledgments. The authors thank Jidong Jiang, Chenxi Qiu, and the anonymous reviewers. This work was supported in part by the NSFC under Grant 61170068 and 61223003, and in part b y the JSNSF unde r Grant BK2012723.
