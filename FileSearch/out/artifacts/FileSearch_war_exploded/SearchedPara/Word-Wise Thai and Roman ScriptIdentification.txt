 SUKALPA CHANDA and UMAPADA PAL Indian Statistical Institute and ORIOL RAMOS TERRADES Univ. Polit  X  ecnica De Valencia 1. INTRODUCTION There are many printed Thai documents where a single document page con-tains both Thai and Roman texts. An example of such document is shown in Figure 1 For OCR development of such a document page, it is better to sep-arate different scripts before feeding them to the OCRs of individual scripts [Lu et al. 2005; Pal et al. 2003]. In this paper, a SVM based technique is proposed for word-wise identification of Thai and Roman scripts from a document page.
 Chanda et al. 2007; Dhandra et al. 2006; Dhanya et al. 2002; Ding et al. 1997; Gllavata and Freisleben 2005; Hochberg et al. 1997; Jaeger et al. 2005; Pal et al. 2003; Spitz 1997; Tan 1998; Zhang and Ding 1999; Zhou et al. 2006]. Among them, Spitz [1997] developed a method for Han-based or Latin-based script separation. He used optical density distribution of char-acters and frequently occurring word shape characteristics for the purpose. Using cluster-based templates an automatic script identification technique has been described by Hochberg et al. [1997]. Tan [1998] described an auto-matic method for identification of Chinese, English, Greek, Russian, Malay-alam, and Persian text using fractal-based texture features. Jaeger et al. [2005] used K-NN, SVM, weighted Euclidean distance, and Gaussian mixture models to identify English from Arabic, Chinese, Korean, and Hindi scripts. Busch et al. [2005] proposed a scheme for script identification technique using texture-based features, where strategies for improving classification results in situations with limited training data and multiple font types are also included. Lu and Tan [2008] proposed a script and language identification technique where, at first, document images are vectorized using vertical component cuts and character extrema points. The vector characterizes the shape and fre-quency of the contained character or word images. For each script or language under study, a script or language template is then constructed through a train-ing process. Finally, script and languages of document images are then deter-mined according to the distances between converted document vectors and the preconstructed script and language templates. Among Indian scripts, Pal et al. [2003] proposed a line-wise script identification scheme from Indian trilingual documents. Later, they proposed a word-wise script identification from Indian document scripts [Sinha et al. 2004]. Dhanya et al. [2002] used Linear Support Vector Machine (LSVM), K-NN and Neural Network (NN) classifiers on Gabor and Zoning features to classify Tamil and English scripts. Zhou et al. [2006] proposed a Bangla/English script identification scheme using connected com-ponent analysis. Dhandra et al. [2006] proposed a combined approach based on mathematical morphology and average pixel distribution to identify English, Hindi, Kannada, and Urdu scripts using a nearest neighbor classifier. Roman scripts from a single text line is presented; to the best of our knowledge this is the first work of its kind. Different features obtained from structural shape, profile informat ion, component overlapping informa-tion, topological properties, and water reservoir concept, etc. of the characters of a word are computed and fed to a SVM classifier for the identification of the word. Here we explore Linear, Polynomial, and Gaussian SVM for Thai and Roman scripts recognition. This work is an extended version of our work recently presented at a conference [Chanda et al. 2007].
 are discussed in Section 2. Section 3 deals with preprocessing as well as line and word segmentation. Feature extraction is detailed in Section 4. Classifier used for the script identification is dis cussed in Section 5. Experimental result and discussions are given in Section 6. Finally, conclusion of the article is given in Section 7. 2. PROPERTIES OF THAI SCRIPT Thai, a Tai-Kadai language, is used by more than 25 million people in Thailand, the Midway Islands, Singapore, the UAE, and the USA. The Thai alphabet was probably derived from, or at least influenced by, the Old Khmer alphabet. According to tradition it was created in 1283 by King Ramkhamhaeng. 1 The Thai alphabet set consists of 44 basic consonants, 17 vowels, four tones, and two punctuation marks. For some consonants there are multiple letters. Originally they represented separate sounds, but over the years the distinction between those sounds was lost and the letters were used instead to indicate tones. The Thai character set is shown in Figure 2. division helps to determine the tone of a syllable. The sounds represented by some consonants change when they are used at the end of a syllable. Some consonants can only be used at the beginning of a syllable. Thai is a tonal language with four tones. The tone of a syllable is determined by a combination of the class of consonant, the type of syllable (open or closed), the tone marker, and the length of the vowel. Roman, sometimes such white space between two consecutive words in Thai is absent. This makes word separation difficult in Thai text. If a single line contains both Roman and Thai text then generally there is enough space between Roman and Thai text. For example, see the second or third line of Figure 1 where both Roman and Thai text are present. We use this space in-formation for segmentation of text into character groups (words) and identify the script of these groups. Because of t he inter word space problem, some-times two or more consecutive Thai words are not segmented properly and they merge into a single group. From the script identification point of view such improper segmentation does not affect our scheme. In fact, our method shows better accuracy in this case since a group/word will have more character information (feature) because of such merging of words into a single group and thus the lack of white space between Thai words does not hamper our script identification method. 3. PREPROCESSING The digitized images are in gray tone and we have used a histogram-based thresholding approach [Roy et al. 2004] to convert them into two-tone im-ages. Document skew is corrected using the algorithm due to Pal et al. [1996]. The digitized image may contain spurious noise pixels and irregularities on the boundary of the characters, leading to undesired effects on the system. Sometimes characters may be broken because of low resolution. To remove these noise pixels and joining some broken parts, we used a smoothing scheme discussed in Roy et al. [2004]. 3.1 Line Segmentation Lines are segmented from a document by finding the valleys of the horizon-tal projection profile computed by counting the number of black pixels in each row. The trough between two consecutive peaks in this profile denotes the boundary between two text lines. A text line can be found between two consecutive boundary lines. An example of line segmentation is shown in Figure 3. 3.2 Word Segmentation After a text line is segmented, it is scanned vertically for word segmentation. If in one vertical scan two or less black pixels are encountered then the scan is denoted by 0. Otherwise, the scan is denoted 1. In this way a string of 0 and 1 is constructed. Now, if in the string there exist a run of 0s with minimum length 2  X  k 1 then the midpoint of that run is considered as a boundary for segmenting text into words (or a character group). The value of k 1 is taken as the statistical mode of the white runs among the characters of a line obtained by its row-wise scanning. In other words, k 1 is an estimation of the white gap between two consecutive characters of a line. k 1 is computed as follows: the text portion is scanned row-wis e. If n different runs of lengths r 1 , r 2 ,  X  X  X  , r n of word segmentation. If in the string (0-1 string computed for word segmen-tation) there exists a run of 0s of length m  X  k 1 , then the midpoint of that run is considered a boundary of character segmentation. Component labeling is also used in some cases when two consecutive characters are kerned in nature and vertical segmentation is not possible (kerned characters are the characters that overlap with neighboring characters [Pal 1997]). 4. FEATURE EXTRACTION We will now discuss some of the features used in our script identification scheme. 4.1 Feature Based on Loop Loop is an important property of Thai script. In general, the width of a loop present in a Thai character is very small compared to the character width. In Roman we noted that the loop width is generally bigger in size. For example theRomancharacters(A,a,b,B,d,D,e,g,o,O,p,Pq,Q,R,etc.)haveloop and the loop width of a character is greater than 2.5 times of stroke width ( R L ) of the character. (Stroke width computation is discussed latter). This is not true for Thai characters. We used this loop information as a feature of our scheme. In Figure 4, a Thai and a Roman character and their loops are shown to get the idea.
 ing algorithm on the background part (white) of the character image. If there is no loop in a character image then the number of the background component will be only one in the character. If there is more than one background compo-nent then loop exists in the character. If there are L loops in a character then number of background component will be L + 1 in that character.
 of the character black pixels. It is similar to white gap estimation discussed in Section 3.2. Here scanning is done in both the horizontal and vertical di-rections, and instead of white gap we compute statistical mode of the black run lengths. For a character, R L is calculated as follows: The character is, at first, scanned row-wise (horizontally) and then column-wise (vertically). If N tively are obtained by scanning the character, the value of R L will be r i if f =max( f i ) , j =1 , 2 ,  X  X  X  , N . 4.2 Water Reservoir Principle-Based Features We have found that the water reservoir-based features play an important role in the separation of Roman and Thai scripts. The water reservoir principle is as follows. If water is poured from a side of a component, the cavity re-gions of the component where water will be stored are considered as reservoirs [Pal et al. 2003]. Although the water reservoir concept has been used by the researchers earlier [Pal et al. 2003], its application in Thai and Roman script separation is new.

Top (bottom) reservoir. When water is poured from top (bottom) side of the component, the cavity regions of the component where water will be stored are considered as top (bottom) reservoirs. (A bottom reservoir of a component is visualized as top reservoir when water will be poured from top after rotating the component by 180  X ).

Left (right) reservoir. Left (right) reservoirs are obtained when water is poured from left (right) side of a component. For an illustration, see Figure 5. Here top, bottom, left, and right reservoirs of some Roman char-acters are shown.
 in the bounding box of the component, where water could be stored. These re-gions are the water reservoirs. Computation of top reservoir is done as follows. Consider a binary component C with 1 and 0 [here 1 means object (black) and 0 means background (white) pixels of the component]. At first, we scan the com-ponent from left to right (starting from top) to find the run of 1s whose upper pixels (North neighbor in four-neighborhood sense) are 0. We call these runs candidate runs . For the particular example shown in Figure 6(a) there are only two candidate runs (2 nd and 3 rd rows of Figure 6(a)) which satisfy above condition. End points of these two candidate runs are marked by boldface in Figure 6(a). Let B be the set of such candidate runs. Information of two end pixels (rightmost and leftmost pixels) of each run of B is noted. From the right-most point (say x) of a candidate run of B we move right until we hit a black pixel or the right boundary of the component C. If a black pixel is found then we note that pixel as the right associated point of x of that run. If no black pixel is found then there is no associated point of x and we discard the point x of the run. Similarly, from the leftmost point (say y) of a candidate run of B we move left until we hit a black pixel or the left boundary of the component C to find its associated point. If a black pixel is found then we note that pixel as the left associated point of y of that run. If no black pixel is found then there is no associated point of y and we discard the point y. In the example shown in Figure 6(a), there is no associated point of the end points of the topmost candidate run. Also, there is no associated point of the rightmost point of the other candidate run and the associated point of the leftmost point of this can-didate run is marked by A (shown in Figure 6(b)). Now we check whether it is possible to reach from an end point of a candidate run to its associated point by traversing the contour of the component. To find the top reservoir, if one can reach from one end point of a candidate run to its associated point without passing any pixel lying above the rows of the current candidate run during traverse then a top reservoir is obtained from this end point. The traversed points denote the surface (border) of th e top reservoir. See Figure 6(b) where traversed points are marked by S and the reservoir portion is marked by bold-face characters. Note that the traversing is done clockwise (anti-clockwise) to reach the associated point of the rightmost (left-most) point of a candidate run. The above procedure is done for all the runs of B to compute all the reservoirs for the component C.
 puting the top reservoir, we will get bottom reservoir. Left and right reservoirs canbecomputedinasimilarway.
 called water flow level of the reservoir (see Figure 7).
 and parallel to water flow level of the reservoir is the reservoir base line (see Figure 7).
 ter in the reservoir. In other words, the height of a reservoir is the distance between the reservoir base line and the water flow level of the reservoir (see Figure 7).
 discriminating Roman and Thai scripts.
 voir can be found in many Thai characters. Although a top reservoir can be obtainedinsomeoftheRomancharacters(likeH,k,K,M,N,u,U,v,V,w,W, x, X, y and Y), there is a structural difference in the water reservoir in Thai and Roman scripts. Note that here we consider only those top reservoirs whose heights are greater than 40% of the character height. Differences in the top reservoirs found in Roman and Th ai characters are as follows: coincides with the character upper boundary, which sometimes does not hap-pen with the Thai characters. For example, see Figure 8(a) where the reservoir flow level and character boundary are shown. We use the position of water flow level of top reservoirs as a feature here . Like most of the Roman characters the water flow level of some Thai characters also coincides with the character up-per boundary. Thai and Roman characters having top reservoir and water flow level that coincides with their upper boundary can be distinguished by the fol-lowing property. Thai characters have a small loop at the upper part of the reservoir left side and this loop is absent in Roman characters. Loops in some such Thai characters are shown in Figure 8(b).
 information as discussed above, water flow level feature is decided as follows: If in a character we get a top reservoir of height greater than 40% of the char-acter height then we say water flow level feature satisfies for Roman if (1) the reservoir flow level coincides with character upper boundary, (2) there is no small loop at the upper part of the character X  X  left side.
 check another property of  X  X  X  based on reservoir base line. In  X  X  X  the water flow level of top reservoir does not coincide with its upper boundary, but the reservoir base line of  X  X  X  is almost at the middle of the character. In Thai script, the reservoir base line generally lies near the lower boundary of the character and the position of the reservoir base line is the distinguishing feature. We used this information for the identification of  X  X  X  from Thai characters. If for a character, water flow level does not coincide with the character upper boundary and its reservoir base line lies at the middle portion of the character height, then the water flow level feature of that character also satisfies for Roman. feature satisfies for Roman and this number is the value of this feature for the word.
 tant role in our identification scheme and the shape information of the bottom reservoir has been used as a feature. There is a distinct difference between the shapes of the bottom reservoirs in some of the Roman and Thai characters. To find the shape of a reservoir we compute the width of the reservoir in every row and note the change of these widths. (By reservoir width of a row we mean the distance between two border points of that reservoir in that row). Due to the irregular shape of the bottom reservoir of Thai characters, the reservoir width at different rows will be different as we move towards the reservoir base starting from the water flow level. For Roman characters the reservoir width at different rows will either remain th esameortendtodecreaseaswemove toward the reservoir base from water flow level, and this is because of the reg-ular shape of the reservoir in Roman characters. For illustration, see Figure 9. Here, shapes of the bottom reservoir of one Thai and two Roman characters are shown. For the Thai character, reservoir width decreases from A to B and again increases from B to C. For the Roman characters, reservoir width gen-erally remains the same or decreases from A to C. Only the characters having bottom reservoir height greater than 40% of character height and reservoir flow level coinciding with a character X  X  lower boundary are considered here. mean the change of reservoir width from increasing mode to decreasing mode, or vice versa) of reservoir width. If in a reservoir the number of transition is one or more then this feature satisfies for Thai script. We find the number of characters in a word where this feature satisfies for Thai and this number is the value of this feature for the word. 4.3 Component Overlapping Feature Component overlapping feature is another distinct feature between Roman and Thai texts, and is used for their identification. In Roman text, vertical overlapping of two components is absent except the characters i and j but in Thai there are many such situations where one component vertically overlaps with other component. For illustration, see Figure 10. To compute this overlap-ping feature, we draw the bounding box of each component and check whether bounding boxes of two components vertically overlap or not. Although two Roman characters i and j have vertical overlapping, these two characters have distinct behavior for their separation from Thai. These Roman characters have a vertical line-like structure, which is present just below the middle position of the upper component and the ratio of the length of two overlapping compo-nents (main part of i and its dot) is more than four times the stroke width ( R L ) of the character. This is not true in Thai scripts, and we use this property for their identification of Roman i and j. 4.4 Rotated  X  X  X  Feature In Thai there is a frequently occurring character  X   X  (an image of this character is shown in Figure 11) which looks similar to the Roman character  X  X  X  when it is flipped vertically. Presence of this shape has been used as a feature and we check the presence of this particular character shape based on the profile information as follows. Suppose each character is located within a rectangu-lar boundary, a frame. We compute the horizontal profile from left and right boundary of the frame to the character edge for each row within the frame, we call this distance as left distance and right distance respectively (left and right distance is shown in Figure 11). If we find that in a particular row the left distance is at least 70% of the character width and in that corresponding row the right distance is less than 30% of the character width then we say that row as candidate row . If for a component the number of such candidate rows is at least 65% of the character height and situated at the lower portion of the character, and upper part of the component is wider than its lower part then we assume that this shape is present. Different threshold values, which are used here, are obtained from the experiment. 4.5 Left Convexity Feature In some of the Roman characters (like e, c, C, G, etc.) we noticed convexity from the left side and used this convexity information as a feature. For a character, this feature is computed by considering the information of the left profile distance (as discussed in Section 4.4) of the character. In case of Roman characters this profile has a single transition because of the rounded shape in the left part of the characters; also the transition takes place at the middle region of the character height. By transition we mean change of left profile distance from ascending to descending order or vice-versa. But in the case of Thai characters such a convexity feature does not exist. Left convexity feature of two Roman characters is shown in Figure 12. 4.6 Vertical Stroke Feature We use presence of one or more vertical lines as a feature in our script identi-fication scheme. In Thai there are many characters with one or more vertical lines (For example see the text shown in Figure 1, Figure 2), also many Roman characters such as B, D, E, F, H, I, K, L, N, P, h, n, q, etc. have one/two ver-tical line-like structures. The distinctive difference is that almost every Thai character with a vertical line has a loop and the size of the loop is very small compared to the character width. But in case of Roman characters with verti-cal line, loop is either absent (e.g., in E, F H, I, K, L, N, h, n, etc.) or the width of the loop is at least 2.5 times of R L (e.g., B, D, P, q, etc.) ( R L is stroke width discussed in Section 4.1). Computation of vertical strokes can be done using different techniques [Lu et al. 2005; Pal 1997] proposed by the researchers. Lu et al. [2005] proposed a morphology-based approach for vertical stroke de-tection for the perspective rectification of document images. A column-wise vertical scan has been used in Pal [1997]. Here, if in a scan, a run of black pixels with length greater or equal to 70% of a character height is obtained, then the presence of vertical stroke in that character is assumed. If a text is written in italic style then above vertical line detection method may not work properly. To take care of both normal and italic style we have used profile-based method for vertical line detection. For detection of vertical stroke-like features we use the information of the profile computed earlier (as discussed in Section 4.4). We compute the number of transitions (changing from increasing mode to decreasing mode, or vice versa) in the profiles of the characters and use this value for vertical stroke feature extraction. If the left (or right) pro-file has only zero transition (either all are constant or increasing/decreasing mode) then we say that a vertical line exists in that character. If in both left and right profiles there are zero transitions then two vertical lines exist. For example, see Figure 13, where left and right profiles of the italic character  X  P  X  is shown. Here all the left profiles in the character are in decreasing mode from top to bottom. Hence we assume that one vertical line exists in the character. Note that even if a character is italic this method can detect vertical line-like structures properly.
 7 from a word (character group). The value of a feature vector lies between 0 and 1. To get this normalized value (between 0 and 1) for a particular feature (say, x) we proceed as follows. Let a word consist of N characters. If out of these N characters, P characters have the feature x, then value of this feature x is P/N. We feed the feature vector of a word to our SVM classifier for the script identification of the word. 5. SVM CLASSIFIER FOR SCRIPT IDENTIFICATION Support Vector Machine (SVM) is a classification technique successfully ap-plied in a wide range of applications [Burges 1998; Vapnik 1995]. SVM was originally defined for two-class problems and it looks for the optimal hyper-plane which maximize the distance, the margin, between two classes. This hyper-plane is characterized by the normal vector, which can be expressed as linear combination of the nearest examples of both classes, named support vec-tors (SVs) [Vapnik 1995]. Given a training database of M data: { ( x m , y m ) / m = 1 ,  X  X  X  , M , y where { x j } are the set of support vectors, w = and b has been determined by solving the quadratic problem: subject to the constraint: y j ( w  X  x j  X  b )  X  0 data cannot be properly separated. There fore, in order to permit to violate the separability constraint, a new constraint is added: and the objective function is modified as follows: where K is another parameter to be set during SVM training. Further-more, in order to extend SVM for much mo re general decision surfaces than hyper-planes, kernels technique is used. Data is embedded into a high dimen-sional space, H (Hilbert Space), using a mapping  X  . The inner product in H is computed by the kernel function: k ( x , y )=  X  ( x )  X   X  ( y )which have to be square integrable and verify the Mercer X  X  Condition [Burges 1998]. Hence, a nonlinear kernel SVM is of the form: Sigmoid kernels of the form: k ( x , y ) = tanh( x . y  X   X  ) and Gaussian kernels k ( x , y )=exp(  X  || x  X  y || 2 c ) . Gaussian and polynomial kernels have been cho-sen in our experiments to get the idea of effectiveness of different nonlinear SVM in script identification problem. Since documentation of SVM is widely available, here we are not giving more details of it. 6. RESULTS AND DISCUSSIONS 6.1 Global Accuracy The data used for the experiment are taken from printed document pages. These document pages are obtained from Thai/Roman newspapers and books, and some printouts of Thai literatures obtained from internet. We consid-ered 10,000 data (5,000 words from each of the scripts) for our script identi-fication result computation and the database contained text of different fonts and sizes. For English we considered mainly two popular fonts (Times New Roman and Arial), and for Thai Microsoft-Sans-Serif and Arial unicode fonts are considered. The documents are scanned by a flatbed scanner at 300 DPI. We have used five-fold cross validation scheme for identification result calcula-tion. Here, the database is divided into five subsets and testing is done on each subset using rest of the four subsets for learning. The identification results for all the five test subsets of the data set are averaged to get the accuracy. classifiers is linked to feature data dist ribution. Hence, in the hypothetic case in which data is perfectly separable, Linear SVM should be largely enough to achieve 100% accuracy in recognition tasks. Nevertheless, such situations are rare and, therefore, it is necessary to find hyper-surfaces separating two classes. Therefore, we applied Linear SVM as well as Gaussian and Polyno-mial kernel-based SVM. We tested our results using Linear, Polynomial, and Gaussian SVM using OpenCV library. 2 Detailed results of different SVMs are given in Table I. From linear SVM we obtained 97.88% accuracy, from Polynomial kernel we obtained maximum accuracy of 98.86%, and from Gaussian SVM we got best accuracy (99.62%) from our script identification scheme.
 of SVM chosen, from the experimental results we have computed standard deviation of the recognit ion accuracies obtained from five subsets. Standard deviation of the recognition accuracies obtained from linear SVM is 0.27. The standard deviation of the recognition accuracies obtained from Gaussian SVM are 0.23, 0.20, 0.13, 0.21, 0.20, and 0.15 when we consider c as 1.0, 2.0, 4.0, 8.0, 16.0, and 32.0, respectively. The standard deviation of the recognition ac-curacies obtained from Polynomial SVM are 0.35, 0.23, 0.27, 0.26, 0.25, and 0.29 when degree of the Polynomial kernel are 0.50, 1.00, 1.50, 2.00, 2.50, and 3.00, respectively. From Table I it can be seen that the choices of the parameter c do not have significant influence in the accuracy of the Gaussian SVM. It means that the choice of training data does not have too much in-fluence on Gaussian SVM comparing to Linear and Polynomial SVM. Further-more, for different values of c the accuracy of our experiment on Gaussian SVM lies between 99.56% (when c = 1) to 99.62% (when c = 16). For different values of degrees the accuracy of Polynomial SVM lies between 95.32% (when degree = 0.5) to 98.86% (when degree = 2). This means that Gaussian SVM fits better feature descriptors distribution and the separating hyper-surface defined by its SVs able to better separate both Thai and Roman scripts, given the feature vectors distribution, than the other separating hyper-surfaces.

To get an idea of the effectiveness of our proposed method on different fonts we computed results of individual fonts. From Times New Roman (Arial) fonts of 12 to 16 point sizes, we obtained 99.61% (99.67%) accuracy. We obtained 99.36% (99.47%) accuracy from Times New Roman (Arial) fonts of 10-point size. We noted that because of the presence of the serif part in Times New Roman font we obtained lower accura cy in Times New Roman than Arial. From the experiments of Microsoft-Sans-Serif (Arial unicode) fonts of Thai, we obtained 99.69% (99.76%) script identification accuracy when 12 or more point size documents are considered. 6.2 Results on Varying Data Size We also computed accuracy of our classi fier using different sizes of data and the results are given in Table II, Table III, and Table IV. We computed accuracy on five different data set, the number of data in each data set is 1,500, 3,000, 4,500, 6,000, and 10,000 respectively. In each of the data set 50% of data is Roman and the rest 50% is Thai. From the tables we notice the tendency of the accuracy rates for Linear, Polynomial SVM ( degree = 0.50, 1.00, 1.50, 2.00, 2.50, 3.00) and Gaussian SVM ( c = 1, 2, 4, 8, 16, and 32) with corresponding data size. We can observe that for Gaussian SVM the accuracy rates are increasing with the number of samples, whereas for Linear and Polynomial SVM it is not always true.
 6.3 Comparison of Results Since our work is the first of its kind on Thai-Roman script, we cannot compare our results with the work on Thai-Roman script identification. However, to get an idea about the recognition accuracy with other existing pieces of work on different scripts, some comparison are given in Table V. Jaeger et al. [2005] separately experimented on Arabic-Roman, Chinese-Roman, Korean-Roman, and Hindi-Roman and obtained the highest accuracy from Hindi-Roman and it is 97.51%. They used SVM classifier for Arabic-Roman and Chinese-Roman script classification and obtained 90.93% and 93.43% accuracy. Analyzing the profile the of the connected components of the image, Zhou et al. [2006] devel-oped a rule-based system for identification of Bengali and Roman script from postal envelops. They obtained an accuracy of 99% (95%) from printed (hand-written) documents. From Table V it can be seen that our proposed method gives better results than that of other published reports. 6.4 Error Analysis Analyzing the errors from our syste m we found that errors are mainly due to broken character images. If a character is broken then water reservoirs or loops cannot be detected properly and hence we may get some errors. From the experiment of our Gaussian kernel based SVM on 10,000 data we noted that only 0.24% errors are due to broken characters. It may be noted that if the broken area is small then the broken part joining algorithm [Roy et al. 2004] used in the preprocessing step can joi nbrokenareasandh ence small broken characters do not affect our system. Wh en the broken area is big, errors occur. In real-life documents, touching character may appear. To take care of some touching characters here most of the features are computed in such a way, so that they do not depend on character touching. Hence touching characters do not affect our scheme largely.
 97.92% accuracy from this words, when Gaussian kernel-based SVM is used. Gaussian and salt and pepper noise documents are considered here and the different noises are generated using Matlab software. To get an idea about the considered noisy data, two images are provided in Figure 14.
 where the number of characters in the words is three or less. For illustration, see Figure 15 where examples of misrecognized words are shown. It can be noted that in the Roman word  X  X n X  (shown in Figure 15(a)), the loop of the character  X  X  X  is broken. Moreover, the lower part of the right vertical line of the character  X  X  X  is distorted and this makes the bottom reservoir flow level of the character  X  X  X  far away from the character/component lower boundary. Due to such degradation, this short word gets misclassified. In the Thai erroneous word (shown in Figure 15(b)), the middle character is a bit distorted and loses its loop feature, and the other characters looks like the Roman  X  X  X . Hence, the error gets generated by our scheme.
 6.5 Accuracy on Individual Scripts We also computed the accuracy of our system with respect to each script. The highest accuracy for Thai and Roman s cripts with Gaussian and Polynomial kernels is reported in Table VI. It shows that for both of the kernel types, the accuracy of each individu al script is very close to each other. Hence proving the proposed system to be nonbiased to both of the scripts. 6.6 Identification Results of the Individual Features To get an idea of effectiveness of individual features, we have computed iden-tification results of the individual features and their results are given in Table VII. In the table, F1, F2, F3, F4, F5, F6, and F7 are loop features, top reservoir-based features, bottom reservoir-based features, overlapped features, rotated J features, convexity features, and vertical stroke features, respec-tively. From the table it can be noted that loop feature F1 showed highest ac-curacy of 77.61% and this is because most of the Thai characters have smaller loops which can easily be distinguished from the loop of Roman characters. Convexity feature F6 showed lowest accuracy of 42.28% and this is due to the low frequency of characters exhibiting such features in words. 7. CONCLUSION Script identification is an important step for multi-lingual OCR develop-ment. In this article we proposed a SVM based scheme for identification of word-wise printed Roman and Thai scri pts from a single document page. The features used here are simple and they are obtained from structural shape, profile behavior, component overlapping information, topological properties, and water reservoir concept, etc. We tested our scheme on 10,000 data and obtained 99.62% accuracy from the proposed scheme. To the best of our knowledge this is the first work on Thai and Roman script identification. One of the authors, Dr. Oriol Ramos Terrades, wishes to thank the Juan de la Cierva programme for the support for his research work.

