 1. Introduction and sensing. Thus, minimizing the number of transmitted messages can increase sensor lifetime. set of sensors ( S 1 , S 2 , ... , and S 5 ) every two seconds (i.e., the sampling period is 2 seconds). Example 1. A declarative query example: SELECT SUM(light) FROM S 1 , S 2 , S 3 , S 4 , S 5 SAMPLE PERIOD 2s following examples provide some scenarios in which concurrent queries could share some intermediate results: fi on tree growth. These concurrent queries could share some intermediate results. network to determine road traf fi c conditions and fi nd the best route. Traf for bus passengers. In this scenario, since users may query traf responsiveness by generating some intermediate results to be shared by all. from many army units ef fi ciently.

To demonstrate the concept of sharing intermediate results, consider the two query trees in Fig. 1 , where Q represented as solid and dashed line, respectively. The data sources of Q
S intermediate result on sensor S 4 is fi ve (i.e., the sum of intermediate results at S 9. On the other hand, in Fig. 1 (b), if Q 1 shares the intermediate result of S intermediate result of S 4 without accessing readings at S the number of messages involved in multiple queries.

Several challenge issues must be overcome to achieve this goal: (1) Determine the bene fi t of sharing intermediate results between query trees. (2) Select backbones from a set of query trees.
 (3) Determine the set of backbones for each non-backbone.
 (4) Deal with dynamic query workload.

To address theissues above, this study fi rst formulates a bene trees and possible number of messages reduced. The bene fi optimal solution with greater ef fi ciency when the number of queries increases. provides discussions. Section 7 concludes this paper. 2. Related works
Sincesensornodesareusuallypoweredbybatteries,energyisaverypreciousresourceforeachsensornode.Therefore,minimizing
Generally speaking, energy saving could be achieved from several approaches. The sending only coded packet instead of individual packets reduces the traf transmission cost is much higher than the computational cost, in-network aggregation can ef for further reduce the number of message incurred. Thus, our paper belongs to this category.
The idea of in-network aggregation in sensor networks is fi queries considered in [30] are not in-network aggregate queries.
 the query sensors are viewed as the receiver. Generally, the solution of intermediate results among multiple query trees.
 results. These features distinguish this paper from others. 3. Preliminaries to determine bene fi ts of sharing intermediate results among queries. 3.1. Problem formulation number of messages. To facilitate the presentation of our paper, some notations are de a query tree, expressed by T i , where i is the identi fi every E ( T i ) time units, where E ( T i ) is the sampling period for query T messages incurred is expressed as N ( T i ), the number of edges in T intermediate results for non-backbone T i is de fi ned as B ( T
S intermediate results of S n is expressed as R i , j ( S m sharing pairs that can maximize the number of messages reduced.
Example 5. Assume that in Fig. 2 , T 1 is a backbone and T result at S 11 in T 1 , R 2,1 ( S 12 , S 11 )=4. As Fig. 3 (a) shows, to access intermediate results at S corresponding tree. An alternative way to access the intermediate results of T (b) shows. Compared to the case in Fig. 3 (a), the value of R would be better than ( S 10 , S 9 ) in terms of reducing the number of messages. backbones when backbones are performed at their sampling time periods. Given one non-backbone T derive the probability of accessing intermediate results of T time units, where lcm (  X  ) is the largest common multiplier of E ( T this observation, the value of P ( T i , T j )is PT i ; T
Suppose that T 4 is a backbone for non-backbone T 2 . Note that T intermediate results of T 4 is 6 lcm 6 ; 8  X  X  = 1 4 .
 incurred in sets of backbones and non-backbones. Denote AvgCost backbone T j , and AvgCost NB ( T i , T j ) as the average number of messages per time unit for non-backbone T formula:
For a backbone T j , the number of messages incurred is N ( T average number of messages incurred by T j is AvgCost B T accordingtotheirsamplingtimeperiods.Fornon-backbone T i ,theprobabilityofaccessingintermediateresultsof T that T i accesses its backbone T j via a sharing pair ( S the other hand, the probability of performing T i is (1  X  messages is as (1  X  P ( T i , T j )) X  N ( T i ). If the set of sharing pairs of T follows: The formula for AvgCost(Q) leads to the following derivations: Consequently,
With the above derivations, it is possible to minimize AvgCost(Q) by maximizing the sum of
T  X 
B ( T i ). Since R i ; j S m ( S , S n ) can be de fi ned as benefit i ; j S m ; S n  X  X  = R follows: backbones for each non-backbone. The objective of this problem is to maximize the sum of bene results of backbones.
 determine a set of backbones and the sharing pairs for each non-backbone. 3.2. Determination of bene fi ts among query trees
Given a set of query trees, this section derives a reduction graph that captures the amount of bene reduction graph is de fi ned as follows:
De fi v  X 
V represents a query tree T i  X  Q . For each sharing pair ( S source of ( S m , S n ) and its weight as max {0, bene fi sharing pair ( S m , S n ) of two query trees T i and T j maximizethe sumof bene fi ts.Therefore,it is necessary to derive thesharing pairs ( S
The value of R i , j ( S m , S n ) is related to the sharing pair ( S
S of T j . Clearly, we could save the number of messages required for S required to access the intermediate result at S n from S m between S m and S n . Therefore, the number of messages reduced is N
The scenario above shows an example case in which S m of T query trees T i and T j , if the data sources for one sensor in T sharing pair. It is possible to further determine the number of messages reduced by this sharing pair (i.e., R pairs. Sharing pairs with the maximal set of data sources between query trees should be generated. Consider T example, where T 2 intends to access intermediate results of T results because they have the same set of data sources (i.e., { S the maximal set of data sources because the sharing pair ( S sources of the sharing pair ( S 9 , S 10 ). The value of R pairs that have the maximal set of data sources.
 reduction graph for these query trees. For example, the fi sharing pair ( S 11 , S 12 )of T 1 and T 2 is { S 1 , S 2 weight of this edge is benefit 1 ; 2 = S 11 ; S 12  X  X  = R and T 4 . The second row of the second block in Table 2 shows that the data source of this pair is { S
Therefore, the edge ( v 2 , v 4 ) is labeled { S 7 , S 8 , S 4. Query optimization by selecting backbone trees
Since queries may join or leave dynamically, Section 4.3 proposes a maintenance mechanism. 4.1. Algorithm BM
Using the reduction graph, the BM algorithm determines the set of backbones and mapping relationships among partition phase determines sets of backbones and non-backbones with the purpose of maximizing the sum of bene non-backbone.
 4.1.1. Partition phase of each edge belong to two sets (e.g., B and NB ), such that B Note that the backbone set and the non-backbone set are determined after a maximum cut is derived. determine the corresponding backbone gain and use the gain to estimate the bene
De fi nition 2. Backbone Gain: Given a reduction graph, the backbone gain achieved by selecting v  X  ( v ), is set, which results in the maximal sum of bene fi ts.
 example,  X  v 2  X  X  = wv 1 ; v 2  X  X  + wv 3 ; v 2  X  X  + wv 4 ; + 1 6  X  0  X  0  X  0  X  0  X  0= 19 24 N 0. Note that the maximal backbone gain is marked with an asterisk. In the selected into the backboneset since v 1 brings the maximal bene non-backbone query trees are then updated. In the second iteration, v backbone set update their corresponding backbonegains. Similarly, v and the non-backbone set NB ={ v 2 , v 3 }. Fig. 6 shows that this produces a maximum cut as 2 maximum cut in the example above indicates the maximum value of bene intermediate results of backbones.
 4.1.2. Mapping phase a set of backbones. A set of backbones for each non-backbone should be carefully selected since the bene if a non-backbone selects backbones with overlapping sources. For example, Fig. 6 shows that a non-backbone v that are linked to all backbones. Among these three edges, the label set of edge ( v sources (i.e., s 1 and s 2 ). Clearly, if non-backbone v 2 v since the edge ( v 2 , v 1 ) includes the intermediate result from sensors s backbones with disjoint sensors to maximize the sum of bene of edge weights in M , select an edge with larger weight, and speci scores.

De fi nition 3. Scoring Function: Assume that v i is a non-backbone and the set of selected edges is M be L ( v i , v j ) and the weight of an edge ( v i , v j )be w ( v selected. Since the weight of an edge represents the bene fi sources of the current mapping relation. The second term of the scoring function re maximal score and its label set not containing any common sensors in the union set of label sets of edges in M selected in M i , update the scores of other edges incident to v edge will be discarded. Repeat the operations above until no edge can be selected. In this case, M such that the label set of edges in M i are disjoint.

Example 9. Consider the example in Fig. 5 , where v 2  X  NB , the scores of all incident edges are sv sv ; v 4  X  X  = 5 24  X 3= 5 8 , and sv 2 ; v 5  X  X  = 1 6  X 2= 1 3 . In the beginning, the edge ( v are updated accordingly. Thus, sv 2 ; v 4  X  X  = 5 24  X 3= 5 ( v , v 4 ) is selected into M 2 . Since there is no edge incident to v other edges into M 2 . Following the same operations, derive the mapping set M relationships, where the bold lines are the edges selected for each non-backbone. Finally, M v )}. Consequently, the set of backbones for T 2 (respectively, T Algorithm 1. BM: Backbone Mapping Input: A reduction graph G =( V , E )
Output: Mapping relation M 1: /* Partition Phase */ 2: NB  X  V ; 3: B  X   X  ; 4: while it exists some query tree whose backbone gain is larger than zero do 5: Select v i as backbone whose backbone gain is maximal among all query trees in NB ; 6: B  X  B  X  { v i }; 7: NB  X  NB  X  { v i }; 8: /* Mapping Phase */ 9: M  X   X  ; 10: for each u i  X  NB do 11: while there exists an edge ( u i , v k ) such that Lu 12: v j  X  the vertex in B with the maximum s ( u i , v j ); 13: add ( u i , v j ) into M ; iteration of backbone selection. For eachiteration in the partition phase, each non-backbonequery tree T that there are i vertices in NB and | V |  X  i vertices in B in one iteration. Thus, computing edge with maximum score is at most O (| V |). Therefore, O (| V | needs at most O (| V | 2 ). 4.2. Algorithm OOB: obtaining optimal backbones algorithmtoderivethemappingrelationshipsbetweenthebackbonesetandthenon-backboneset.Determiningoptimalbackbonesis discovering child nodes (referring to the branch operation) continues until the goal node is reached. controlled by a bounding function f (*) that estimates the upper bound of the sum of bene are larger than zero to ensure that the goal node is reached. Hence, h(P) is formulated as hP  X  X  =
Example 10. Consider the node Z with B ={ v 1 , v 4 , v 5
Fig. 6 and thus, we can have g(Z) as 11 8 with their mapping relationships as {( v that since the values of  X  ( v 2 ) and  X  ( v 5 ) are negative, h ( Z )=0. Algorithm 2. OOB: obtaining optimal backbones Input: A reduction graph G =( V , E )
Output: Backbone mapping X 1: P . NB  X  V 2: P . B  X   X  3: max  X  0; 4: Construct a heap H according to the values of evaluation function f ( 5: Insert P into H ; 6: while heap is not empty do 7: Remove node P from H ; 8: Branch P ; 9: for each child Q of P do 10: if g ( Q ) N max then 11: max  X  g ( P ); 12: Best _ P  X  P ; 13: remove all nodes in H which f less than max ; 14: if h ( Q )  X  0 then 15: Insert Q into H ; 16: Return Best _ P . M the maximum f (  X  ) value for branching its child nodes, and uses the maximum g ( updated according to the search in the state space tree. Therefore, the variable max records the maximum g ( set Z . B and the non-backbone set Z . NB , it is possible to derive the maximum bene phase of the BM algorithm.

Example 11. Fig. 7 shows a snapshot of deriving the optimal solution by the state space tree based on the than max =31/24.

Analysis. Since the OOB algorithm adopts the branch-and-bound strategy, the ef by the design of the bounding function. Experimental results show that the proposed bounding function can ef to get the optimal solution. The size of the whole solution space is is O (2 n ). 4.3. Maintenance mechanism new query being submitted and a query being canceled.
 Case 1. When a new query tree arrives
When a new query tree is issued to wireless sensor networks, it is necessary to check how much bene the new query tree if this new query tree was put in the backbone set. The bene query tree T i is in the backbone set. For each non-backbone tree T shares some edges with the new query tree T i , examine these edges and derive the bene
T . If the label of an edge ( v j , v i ) does not have any common sensors to the existing edges in M edge in M j . Thus, the total bene fi t achieved by setting T other hand, it is necessary to determine how many messages will be reduced if query tree T accesses intermediate results of backbones. This bene fi t, denoted as edge weight between two query trees. Hence,  X  NB ( v i ) is formulated as decide whether query tree T i should be in the backbone set or not. Explicitly, if backbone. Otherwise, T i is a non-backbone.
 Case 2. When a query tree leaves query tree left is a backbone, we should compare the reduction bene this query tree. The total bene fi t of keeping the query tree is estimated as terminated immediately, the number of average messages reduced per time unit is kept as a backbone even T i is terminated, if the following condition is satis tree T h . These subtrees should then stop accessing intermediate results of query tree T 5. Performance evaluation presents a sensitivity analysis of the BM and OOB algorithms. 5.1. Simulation model which contains  X  k  X  r 2  X  nodes of this routing tree. A valid subtree satis subtree should contain the source nodes in this subtree. For example, let k be 60 % . The subtree contain case, we enumerate another routing tree and then fi nd a valid subtree again. If all the routing trees cannot guarantee the intermediates results that could be shared.
 number of query trees in the network remained stable with respect to the mean. arrival rate and the departure rate were  X  =3 and  X  =3, respectively. results. On the other hand, TAG-U refers to deriving the union of all queries submitted at the sink indicates the time to derive the sets of backbones and non-backbones.
In the following experiments, the default values of the query range were set as 100 X 100 m of queries is set to 60. 5.2. The effect of sharing intermediate results results of the real dataset, which is similar to the one of synthesis dataset.
The section next evaluates the reprogramming cost, which represents the number of messages incurred by recon rates, the reprogramming cost of TAG-U increases signi fi
The following experiments examine the effects of the amount of intermediate results shared among query trees. We total number of messages ef fi ciently.
 advantage of sharing intermediate results in algorithm BM and OOB.
 5.3. Performance comparison of algorithms BM and OOB
The results of the above experiments demonstrate that BM and OOB can signi which g values are smaller than max .
 validation of the cost function. This experiment considers the which implies that the average cost re fl ects the total number of messages when we consider the whole monitoring duration can be decomposed into small sub-durations in which the set of query trees are cost can be effectively used to reduce the total number of messages.
Force, BM, OOB, and DFS in the synthesis dataset. This fi approaches are similar. This implies that our proposed approaches could achieve optimality ef and OOB algorithms could be adopted to reduce the total number of messages ef derive optimal solutions in a more ef fi cient manner than the Brute-Force method. 6. Discussion involved. This study proposes the BM and OOB algorithms to scalability of algorithm BM.
 extension is to derive a more sophisticated bounding function to reduce the execution time signi algorithms could be executed to select new backbones to balance such overhead of energy consumption. messages as a metric, which is also widely used to approximate the energy consumption [8,11 7. Conclusions determine sets of backbones and non-backbones that minimize the number of messages incurred. This study possible cases of sharing intermediate results among query trees and their associated bene show that by sharing intermediate results among queries, the BM and OOB algorithms are able to signi the bounding function, the OOB algorithm is able to derive the optimal solution more ef the number of queries increases.
 Acknowledgement ATU Program, by ITRI-JRC, Project No. 100-EC-17-A-05-01-0626, by D-Link and by Microsoft
References
