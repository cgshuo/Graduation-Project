 Provenance information is vital in many application areas as it helps explain data lineage and derivation. However, stor-ing fine-grained provenance information can be expensive. In this paper, we present a framework for storing provenance information relating to data derived via database queries. In particular, we first propose a provenance tree data struc-ture which matches the query structure and thereby presents a possibility to avoid redundant storage of information re-garding the derivation process. Then we investigate two ap-proaches for reducing storage costs. The first approach uti-lizes two ingenious rules to achieve reduction on provenance trees. The second one is a dynamic programming solution, which provides a way of optimizing the selection of query tree nodes where provenance information should be stored. The optimization algorithm runs in polynomial time in the query size and is linear in the size of the provenance infor-mation, thus enabling provenance tracking and optimization without incurring large overheads. Experiments show that our approaches guarantee significantly lower storage costs than existing approaches.
 H.2.4 [ Database Management ]: General Provenance Storage, Relational Query
Understanding the provenance of data has become exceed-ingly important due to the large number of sources, diversity of formats and sheer volume of data that current business and scientific applications have to deal with. For example, in scientific computing, provenance is vital to establish trust or correctness of results [4]. In database environments it can help update views, explain unexpected results, and assist with data integration [11]. Similarly in databases with un-certainty, it can be used to track correlation between prob-abilistic variables [2].

Equally diverse is the type and granularity of provenance information considered. In scientific computing, the work-flow that embeds dataflow graphs is a common tool for mod-eling the derivation processes. In database or data ware-house scenarios, queries take the role of the derivation pro-cess. Tracking of provenance can be undertaken at a high level, e.g. by storing only the workflow or query for an en-tire data set, or more fine-grained. In the latter case, every  X  X bject X  (which could mean a single measured or derived re-sult in an experiment, or a single tuple or attribute value in a database) has individual provenance data associated with it. Which level of granularity is the  X  X ight X  one is determined by the requirements of the particular application using it.
A growing problem is provenance storage. While storage space is of little concern when dealing with high-level prove-nance, the requirements of storing fine-grained provenance data can be significant, as the size of provenance data often exceeds the size of actual data [7]. One way to deal with this is to compute provenance data only when requested rather than to store it [21, 10, 12]. A drawback is that without good inverse functions this can be expensive, and it may require intermediate query results to be stored [10].
In this paper we address the issue of efficient provenance storage in the context of relational database queries, where provenance information is recorded to explain the compu-tational process leading to their generation [1]. Although provenance management and storage in the context of sci-entific data workflows have received much attention in the past, such as tracing of the lineage [2, 13], uncertainty [2] and curated data [5], the challenges encountered in these contexts simply do not arise in the context of DB queries: [7] is a good example, where all its hard work is spent on extracting a provenance structure which we get for free with DB queries. More details on provenance storage for various contexts will be discussed in Section 2 later.

For this we first develop a provenance tree data struc-ture for storing provenance data, which closely resembles the query tree. Redundant storage of information about the derivation process is avoided, because tuples which pos-sess the same derivation process (with different inputs) are grouped. According to the classification of provenance se-mantics in [8], our provenance tree records the how-provenance . Although we address provenance for DB queries in this pa-per, similar issues arise when dealing with arbitrary operator trees (e.g. the transformations over the workflows), and our results are applicable to those scenarios as well.
Regardi ng how to reduce storage costs, we first develop a rule-based reduction technique. Later, we propose a dy-namic programming solution to provide a means of making right choices for selecting the nodes to store provenance data for a given query tree. This is non-trivial as not storing provenance data at one node can cause other nodes to grow in size. The optimization algorithm runs in time polynomial in the query size and linear in the size of the provenance data, thus enabling provenance tracking and optimization without incurring large overheads. Lastly, we have also built a proof of concept system called PTree to demonstrate the above methods.
Since no work targets particularly at recording provenance for relational query as studied in this paper, we choose to in-vestigate the most related works, which either follow/extend the relational model as the base data model or are imple-mented on top of relational DBMS, even though they aim at the contexts other than the context of relational query.
In [8] the authors characterized three types of provenance, whose interpretations in the relational setting are: (1) where-provenance [6], describing where an attribute value (of a tu-ple) is copied from; (2) why-provenance [10], which is anno-tated as a set of sets of source tuples that contribute to the output tuples of the query; (3) how-provenance [14], which subsumes the why-provenance by being aware of the case that a source tuple may contribute to an output tuple more than once. One can derive the why-provenance of an output tuple from its how-provenance . As illustrated in Section 3 later, our provenance tree records the how-provenance infor-mation. Green et al. [14] proposed a concept called prove-nance polynomial (on tuple identifiers) as a general form to represent all the aforementioned provenance semantics.
For a certain piece of data t , its provenance information can be either stored in form of annotations associated with it, or computed on request by inverting the original query that generates t . Our work is on the annotation track.
Among those adopting annotation approach, Trio [20] is a system built on ULDBs [2], which is a database model extending the relational model with why-provenance and uncertainty. Provenance data is computed at query execu-tion time and stored in separate  X  X ineage-relations X , storing one lineage-tuple (containing complex values) for each re-sult tuple. DBNotes [3] extends the relational model with the where-provenance by appending an extra provenance at-tribute for each attribute in relations, and enables annota-tion propagation by an extension of SQL queries. ORCHES-TRA [13, 15] uses relational encoding to record provenance when they propagate data and updates from one RDBMS to another; it also uses provenance to assess trust and author-ity within collaborative data sharing systems(CDSSs). In [5] provenance management for curated databases is discussed, with focus on how to track insertion, deletion and copying operations. While the authors investigate optimizations for efficient provenance storage, the type of provenance tracked is very different from ours, and optimization techniques are not applicable to our context.

Computation of provenance through inversion , rather than annotation storage, is first discussed in [21]. In [18] in-version queries for computing provenance relating to rela-tional database queries are stored explicitly to enable effi-cient querying of provenance. The inversion method avoids storage of fine-grained provenance information altogether, but applicability is restricted to queries for which efficient inversion functions can be found. Without such functions, inversion amounts to re-execution of the query. An extension of the pure inversion method, which ensures the existence of inversion functions by materializing intermediate results, is first investigated in [10] for ASPJ views, and extended to more general classes of transformations in [11].
From the aspect of database theory, there are two works [17] and [1] studying the size issue of relational query X  X  how-provenance . In particular, [17] tried to apply algebraic fac-torizations on provenance polynomials to seek more succinct representation. But the solution is built upon an assumption that, the databases under investigated should use a factor-ized representation to store the relations and query results at physical layer; in real-world, however, relational databases adopt the flat representation of relations at physical layer, and our work aims to optimize the provenance storage cost on real-world RDBMSs. [1] defined the notion of core prove-nance for a query Q , which is the part of provenance that appears in the result of evaluating every query equivalent to the given Q ; then it designed numerous query rewriting techniques to ensure the minimal size of the core provenance.
Since in practice no particular work has been built to trace relational query result X  X  provenance, we investigate some well-known systems in related contexts to check whether their storage schemes can be adapted to fit our context. In Trio [20], its reduction schemes in storage bears resemblance to the store-final scheme mentioned in Section 4 of this pa-per, but it focuses on only the source data tuples from which the result tuples are derived, while the store-final scheme captures how they are derived as well. In the extension [15] of ORCHESTRA [13], the reduction schemes on its proposed provenance graph bears similarity to the store-all approach in our context in recording provenance data (see section 4.4). In [7], it addressed the why-provenance of complex-valued data obtained from scientific workflows. Their reductions (structural inheritance, optional node factorization) are not applicable for DB queries, as they aim to find common prove-nance subtrees for different data which we get for free with DB queries. Their node and argument factorization achieve a similar goal as our basic provenance-tree model.
When considering provenance for database queries, we can store provenance information at different granularity, i.e., for data values, tuples or tables. For most database queries (including all SQL queries not involving custom functions), value-provenance can be derived from tuple-provenance by simply attaching the mapped attribute name for a certain value. Tuple-provenance can also be derived from table-provenance by re-executing the query or using inversion as described in [10]. However, this can be costly, especially for large data sets and/or complex queries. This motivates the need for storing tuple-provenance.

At this point it is necessary to state explicitly what ex-actly our notion of provenance captures. Adopting the ter-mino logy of [8], we are interested in the how-provenance , which describes how an output tuple is derived from source tuples according to the query. While many different ways for storing instance-level provenance have been proposed, a common approach is that transformation functions (e.g. subqueries for DB queries, or experiment descriptions for scientific workflows) are stored as part of the provenance in-formation. However, this can generate significant overhead in terms of storage space if multiple instances share the same transformation, which is the case for many scenarios, and particularly for database queries. We address this problem by designing a tree-structure with nested data types for stor-ing provenance information, matching the query structure.
Definition 1 ( provenance type/tuple/table ). A provenance type is constructed from a base type tupleID , whose domain contains references to tuples and a special null value  X  , through nesting of tuple and set constructors: 1. tupleID is a provenance type (base type). 2. If T 1 , . . . , T n are provenance types, then ( T 1 , . . . , T 3. If T is a provenance type, then { T } is a provenance Domain elements of a provenance type are called provenance tuples , and a set of provenance tuples of type T form a provenance table of type T . 1. Tuple references (to data or provenance tuples) and  X  2. If t 1 , . . . , t n are provenance tuples of types T 1 3. If t 1 , . . . , t m are all provenance tuples of type T , then
Example 1. Denote tuple references by r i . Then ( is a provenance tuple of provenance type and the following is a provenance table of type T :
The prov enance of a single data tuple, based on preceding intermediate results, can be described by a single provenance tuple. As all data tuples in an intermediate result table are derived in the same way i.e., using the same operation, the corresponding provenance tuples will share the same type and can be stored in a single provenance table. The prove-nance tables of all intermediate or final results together form a provenance tree.
 Definition 2 ( provenance tree ). Given a query tree Q with node set N and root node R , a provenance tree for Q is a pair P = ( P N , P O ) , where P N is a partial mapping of N to provenance tables, such that R is mapped and leaf nodes (base tables) in N are not, and P O is a total mapping of output tuples of Q to provenance tuples in P N ( R ) . The nodes of P are the images of N under P N , and P N ( n 1 ) is an ancestor of P N ( n 2 ) in P iff n 1 is ancestor of n 2 Furthermore, we require that every tupleID entry  X  =  X  in a provenance table P N ( n ) in P references either Definition 3 ( complete/redundant tree ).
 We call a provenance tree P complete if every output data tuple is mapped to a provenance tuple.
 For a provenance tuple t that is not associated with an output data tuple, we say t is redundant if it is never referenced. We call P redundant if it contains any redundant tuples; otherwise, we call it non-redundant or redundancy-free .
We illustrate these definitions with an example showing the intended use of provenance trees. Note that a prove-nance tree contains no data values, but only references to (data or provenance) tuples. We will only store the prove-nance tree, not intermediate query results.
Example 2. Consider table Enrolment below, in which  X  X D X  denotes a database-internal value for referencing tuples:
The fol lowing SQL query selects all student enrolments where the student is enrolled in more than one course:
This leads to the query tree shown below. Numbers in brackets  X  X  X  are used to identify nodes:
Figure 1 shows the intermediate query results obtained when executing this query (left tree), along with a corre-sponding provenance tree (right tree). In the provenance tree, we use a number to denote the provenance table as-sociated with the intermediate results resulted from a query opera tor, and use the first character of the table name to refer to the base table. E.g. there are four provenance tables table  X  4  X  refers to the base table Enrolment.

By Definition 3, the provenance tree in Figure 1 is com-plete but not redundancy-free , as tuple 4.2 is never refer-enced and thus redundant. Note that for the remainder of the paper, we will only consider complete provenance trees.
The underlying idea for using provenance trees is to ini-tially store the information how a result tuple is constructed in every step. Later, after query computation has been fin-ished, we combine multiple steps if this is advantageous. Since we do not keep intermediate query results, we do not explicitly associate provenance tuples with any (no longer known) tuples in intermediate result tables, although such an association exists implicitly.
We begin by describing a simple method for constructing complete and redundancy-free provenance trees. As our fo-cus is on relational database queries, we will assume that query trees use relational algebra operators. To cater for the de-facto standard SQL, we shall
None of these extensions makes the problem of provenance storage harder (or easier). The projection operator over sets (which eliminates duplicates) can be expressed as multiset projection plus aggregation. Union and intersection oper-ators are also multiset operations, with the latter being a special case of join on all attributes.

Initial provenance tree construction is straightforward for each operator. The provenance types for each operator are listed below, i.e., the provenance type of a provenance table associated with a query result derived using this operator.  X  selection  X  : tupleID  X  union  X  : (tupleID,tupleID)  X  projection  X  : tupleID  X  join  X  X  X  : (tupleID, tupleID)  X  minus  X  : tupleID  X  intersect  X  : (tupleID,tupleID)  X  replacement  X  : tupleID  X  aggregation  X  : { tupleID }
For selection, projection, minus and replacement opera-tor, where each output tuple is computed from exactly one input tuple, this is straightforward. For join and multiset intersection, every output tuple is created from two input tuples which we record, and outer joins can be modeled us-ing  X  values. For union a tuple is copied from one of two tables, and by using a two-tuple, with  X  value describing the absence of a source tuple, we can structurally identify which input relation a tuple comes from. While it is possi-ble to model union via tupleID type, this will complicate the reduction as described in Section 4, which we avoid here for the sake of simplicity. Multiset intersection as handled by SQL can be modeled as aggregation (for duplicate removal) followed by set intersection. For aggregation, each output tuple is derived from a group (=set) of input tuples, so we store all of these.

Non-binary joins, unions or intersections are not supported directly, although they could be without any technical dif-ficulty. This is done because a tree of binary operations (joins, unions or intersections) can sometimes offer more ef-ficient provenance storage than a single non-binary opera-tion, and our optimization techniques discussed in Sections 4 will produce a provenance table that is isomorphic to a sin-gle non-binary operation, e.g. of type (tupleID, (tupleID, tupleID)) instead of (tupleID, tupleID, tupleID), if this is beneficial.

In summary, the initial provenance tree is constructed bottom-up as the query is evaluated. To remove redun-dant provenance tuples, we proceed in a top-down manner which allows us to eliminate all such tuples in a single pass. Bottom-up elimination is also possible and leads to the same result, but may require multiple passes. It is easy to find that, the provenance tree obtained in this way is complete and redundancy-free (see Example 2), and it is our starting point for further optimization.
Storing a provenance tree is straight-forward when using a storage system which accommodates complex-valued types (in particular nesting of tuple and set constructor). If stor-age within a relational database system is desired, which would allow us to handle provenance computation, storage and querying without having to utilize external structures, a mapping to relational tables can be used. See [3] for a discussion on this issue. Note that one can avoid storing an ID column for each provenance table by referencing tuples via their row number.
Instead of storing provenance information at every node of the query tree, it can be more efficient to store it only at some of them. We will investigate this next. Note that as a side-effect of this storage-space oriented optimization, querying of provenance information can become more effi-cient as well, as reference-paths are reduced in length.
In current practice, two opposing approaches for storing (rather than re-computing) provenance information prevail. The first approach, which we shall call store-final , only uses the equivalent of a single provenance table for the final result referencing base tuples directly. While this may not be done in the form of a nested table (e.g. RDF triples are commonly used), the issues arising w.r.t. data duplication are the same. The second approach, which we shall call store-all , goes to the other extreme: it stores a provenance table for every intermediate result, i.e., every node in the query tree.
Note that some existing approaches can fall into either category, regardless whether these systems are designed for relational context. They store provenance data after ev-ery  X  X ransformation X , which can be of arbitrary granularity [20, 16]. Taking an entire query as transformation equates to store-final, such as Trio[20] and GridDB[16]; while using  X ,  X ,  X  X  X , . . . as transformations translates into store-all, such as ORCHESTRA[13]. Of course, one can also decompose a query into subqueries, treating each as a transformation. From this point of view, this section addresses the question of ho w to find a good decomposition into subqueries. As we will demonstrate next, both store-final and store-all can be arbitrarily poor, that is, one may require an arbitrarily large factor in storage space compared to the other.

Example 3. Consider a query  X  1 (  X  2 ( . . . (  X  n ( R )))) con-sisting of n consecutive selection operations (or other op-erations with tupleID provenance type). Then the store-all approach requires n times as much space as store-final.
Example 4. Consider the query R 1  X  X  X   X  ( R 2 ) and in-stances r 1 , r 2 such that r 1 , r 2 contain n tuples each, all tuples in r 2 are aggregated into a single tuple t 2 and all tuples in r join with t 2 . Then the store-all approach requires only n references at the query node  X  ( R 2 ) plus another n reference at the final node, whereas the store-final approach uses n references at the final node. Hence, the store-final approach requires n 2 times as much space as store-all.

When combining the two examples above, e.g. as both extreme cases fail to yield good results.

As neither approach is a good solution in general, we will investigate approaches which associate provenance ta-bles with several but not necessarily all nodes of the query tree. The crucial question here is which nodes we should select to store into the provenance tables.
For our first reduction approach, we will start out with a store-all solution, which can be constructed as described in Section 3.1, and then improve it by combining provenance information from multiple tables into one. Provenance ta-bles are combined (by copying provenance tuples instead of referencing them) whenever this is clearly beneficial for stor-age space. This leads to the following rules:
Rule I : Whenever all tuples in a provenance table are ref-erenced at most once, we copy the provenance information rather than referencing it.

In part icular, this situation always arises for the following operators, provided that the input tables are not used as input for multiple operators, which can happen after query-optimization (where the query is not in tree-form anymore): If references to tuples originate from different provenance tables, we simply copy provenance information for all refer-encing tables.

Rule II : Whenever we would reference a provenance table of type tupleID (i.e., referenced tuples contain only a single reference), we copy the provenance information instead.
The follo wing operators generate provenance tables of type tupleID: selection, projection, minus, replacement.
The reason behind Rule I is that it does not introduce any redundancy, and avoids storing an extra table. For Rule II the reason is that, referencing a tupleID is no cheaper
The k ey property only needs to hold w.r.t. tuples con-tributing to the final result. This is easily checked after unreferenced provenance tuples have been removed. than copying it, and again we avoid storing an extra table. After references have been copied, we can immediately delete provenance tuples (other than those corresponding to output tuples) which are no longer referenced.

Our general approach to constructing a reduced prove-nance tree involves three steps: 1. Construct initial provenance tree. 2. Remove unreferenced provenance tuples. 3. Integrate provenance tables using Rule I and Rule II.
For the last step, rules I and II can be applied in different order, leading to different results, as shown in Example 5.
Example 5. Recall our Enrolment Example 1. In step 1, we get an initial provenance tree as shown in Figure 1. In step 2, tuple 4.2 is removed as it is never referenced; for ease of illustration we refer to the current provenance tree as T here. In step 3, suppose we traverse T in bottom-up manner from table  X  4  X  up to table  X  1  X  . When Rule II is first applied to T , then since table  X  3  X  is of type TupleID, its reference to tuple 4.1 is copied to table  X  2  X  where Rule II is applicable again, so it is in turn copied to table  X  1  X  . The temporary result is shown in Figure 2(a). Next we check whether Rule I is applicable: since tuple 4.1 is referenced twice in table  X  1  X  , Rule I is inapplicable and Figure 2(a) shows the reduced tree by Rule II followed by I. Conversely, if Rule I is applied first to T , then since the only tuple in table  X  4  X  is referenced once by table  X  3  X  , we copy its data { E. 1 , E. 2 } into table and it is in turn copied to table  X  2  X  , and since tuple 2.1 is referenced twice by table  X  1  X  , we stop copying. Figure 2(b) shows the final result of applying Rule I followed by II. Note that, similar differences in provenance trees can be caused by applying the rules in a top-down manner. Figure 2: Reduction results by different orders
However, the results in Example 5 are isomorphic , in the sense that provenance tables are associated with different nodes and references are renamed, but no other differences exist. For this, it is critical to find the right notion of iso-morphism, which captures the intuition that we can shift provenance tables to different nodes and rename references, but cannot change anything else. To avoid an overly complex definition of isomorphism, we translate provenance trees into reference trees and then define isomorphisms between these.
Definition 4 ( subtype/subtuple ). The subtype (sub-tuple) relationship &lt; P ( &lt; T ) between provenance types (tu-ples) is the transitive extension of the following rules: We call a subtype (subtuple) direct if it follows from the above rules directly (without transitive extension).
Definitio n 5 ( reference tree ). The reference tree of a provenance tree P is a directed acyclic graph (DAG) con-structed as follows. Every referenced base tuple is added as a node. For every provenance tuple t we add a node labeled with its provenance table, as well as an unlabeled node for each subtuple of t . Finally we add arcs for every tuple-reference and direct subtuple-relationship. For direct subtuple-relationships of the form (1), we label the arc with the corresponding position i .

Continuing our Enrolment example, the reduced prove-nance trees are translated into the reference trees below.
Definitio n 6. [ isomorphism ] Let P 1 , P 2 be two prove-nance trees over the same query tree. We say that a bijection  X  : tupleID  X  tupleID is an isomorphism relating P 1 and P , if (i)  X  is a graph isomorphism between the reference trees of (ii)  X  leaves the base (input) tuples fixed, and each output If such isomorphism  X  exists, we call P 1 , P 2 isomorphic .
It is easy to see that being isomorphic is an equivalence relation: If  X  12 relate P 1 and P 2 , and  X  23 relates P then  X  23  X   X  12 relates P 1 and P 3 . Moreover, by Definition 6, the isomorphic provenance trees require the same storage space under any sensible storage measure. We are now ready to state our main result concerning rules I and II.
Theorem 7. Let P be a provenance tree, where no prove-nance table is referenced from more than one table 2 . Apply rules I and II to P in any order, until no more rule appli-cations are possible. Then all resulting reduced provenance trees are isomorphic.

Proof. Applications of Rules I and II can be seen as reduction steps over the classes of isomorphic provenance trees. Using a well-known theorem from [9], it suffices to show that this reduction system has the Church-Rosser prop-erty, i.e., whenever two different reductions are applied to isomorphic provenance trees, we can reduce the resulting provenance trees (via further reduction steps) to isomorphic ones. Each reduction step (i.e., application of Rule I or II) is associated with one non-empty provenance table, and ap-plying reduction steps to corresponding provenance tables preserves the isomorphism relationship between provenance trees. In the following we will apply reduction steps for one
Query-o ptimization can combine identical subqueries, so that query  X  X rees X  are no longer actual trees. provenance tree to a different but isomorphic provenance tree, with the understanding that the reduction step is first  X  X ranslated X  using the connecting isomorphism. We do not mention this translation explicitly for ease of readability.
Now, let P 1 , P 2 be two isomorphic provenance trees and  X  ,  X  2 be two reduction steps applied to provenance tables T , T 2 in P 1 and P 2 , respectively. If T 1 , T 2 are not adjacent, meaning that no direct references between T 1 and T 2 exist (again we do not mention translation via isomorphism), they are not in conflict, i.e., application of  X  1 does not prevent subsequent application of  X  2 , and vice versa. Hence we can apply  X  2 to  X  1 ( P 1 ) and  X  1 to  X  2 ( P 2 ) to obtain isomorphic provenance trees.

Finally let T 1 , T 2 be adjacent, say T 1  X  T 2 . If each tuple in T 1 is referenced only once (  X  1 uses Rule I), application of  X  2 cannot change this property, so the two contractions are not in conflict. Similarly, if T 2 has provenance type tupleID (  X  2 uses Rule II), this property cannot be changed by application of  X  (  X  1 ), so again there is no conflict.
It remains to consider the case where T 1 is of type tupleID (  X  1 uses Rule II), and tuples in T 2 are referenced only once (  X  2 uses Rule I). Then, after  X  1 is applied, tuples in T 2 be referenced multiple times, so that Rule II cannot be ap-plied. Similarly, after  X  2 is applied the new T  X  1 need not be of type tupleID, so that Rule I cannot be applied. Hence  X  1 and  X  2 are in conflict, i.e., application of one prevents application of the other. However,  X  1 ( P 1 ) and  X  2 ( P already isomorphic: The isomorphism  X   X  relating them can be constructed as  X   X  =  X   X   X   X  , where  X   X  maps the tupleID of each tuple in T 2 to the tupleID of the (unique) tuple in T 1 that references it.

Time Comp lexity : Testing where to apply reduction rules I and II is straight-forward, and a fully reduced prove-nance tree can be computed in O ( N ) where N is the total number of tuple references in the initial provenance tree.
While the reduction rules described above are fast and easy to implement, the resulting reduced provenance tree may not be optimal. In the following we will describe a polynomial-time algorithm for finding an optimal solution in the case where the provenance tree is really a tree (rather than an arbitrary DAG), using dynamic programming.
For every node in the query tree except root and leaves, we must decide whether to assign a provenance table to this node. We shall refer to this as materializing a node, and will not always distinguish between a materialized node and the provenance table associated with it. The size of a prove-nance table (measured in number of tupleIDs ) is then simply the sum of the number of tupleIDs pointing to (tuples in) each closest materialized descendent node.

When deciding whether to materialize a node N , we only need to consider its closest materialized ancestor (as its size will be affected) and its closest materialized descendants (as they affect the size of N ). In particular, we do not have to consider any sibling nodes . While the materialization of sib-lings may affect the size of a common closest materialized an-cestor, the effects of such materializations on ancestor table size are independent of each other. Next, we will introduce some notations before describing our dynamic programming solution.

Definition 8 ( subtree notations ). Let T be a tree and N 1 , N 2 b e nodes in T such that N 1 is an ancestor of N 2 , denoted by N 1  X  N 2 . ( N 1 , N 2 ) is the set of nodes on the unique path between N 1 and N 2 , excluding N 1 , N 2
We write T [ N 1 ] for the subtree of T containing all de-scendants of N 1 , and T [ N 1  X  N 2 ] for the subtree of T [ N containing all ancestors or descendants of N 2 .

Given a set S of nodes in T and s 1 , s 2  X  S , s 1 is a direct ancestor of s 2 w.r.t. S , written s 1  X  d s 2 , if s 1  X  and there exists no s  X   X  S \ { s 1 , s 2 } with s 1  X  s  X   X 
Example 6. The figure below shows the following graphs, from left to right: T , T [ N 2 ] and T [ N 2  X  N 5 ] . For S = { N 1 , N 3 , N 4 , N 6 , N 7 } , N 1 is a direct ancestor of N and an ancestor but not a direct ancestor of N 4 , N 6 , N
Definition 9 ( partial result notation ). Let P be the initial provenance tree and N 1 , N 2 be the nodes in P with N 1  X  N 2 . We denote by ref ( N 1 , N 2 ) the number of refer-ences from the provenance table associated with N 1 to (prove-nance) tuples associated with N 2 . Given a set S of nodes in P to materialize, the cost of S is We call S valid for a subtree P  X  if S contains the root of P  X  and all leaves. We write opt ( N minimizing cost ( S ) among all valid sets S for P [ N 1 ] , and opt ( N 1 , N 2 ) for the set S minimizing cost ( S ) among all valid sets S for P [ N 1  X  N 2 ] with S  X  ( N 1 , N 2 ) = not materializing any nodes between N 1 and N 2 . With this definition, opt ( N ) is short-hand for opt ( N, N ). We are now interested in finding opt ( root ) where root is the root of our provenance tree, i.e., the set of nodes to materialize such that the storage cost (measured in number of tuple references) is minimized.

Theorem 10. Let N 1 be an ancestor of N 2 , N be a node. (iii) if N 1  X  = N 2 and N 2 is not a leaf node then
Proof. (i) is trivial. (ii) follows by definition of cost . For (iii) { N 1 }  X  opt ( N 2 ) is the optimal solution among all valid sets containing N 2 , while opt ( N 1 , C 1 )  X  . . .  X  opt ( N optimal among all valid sets not containing N 2 .
This tra nslates into Algorithm 1, which we can implement efficiently by storing (rather than re-computing) opt ( N and cost ( opt ( N 1 , N 2 )). The complexity of our dynamic programming approach is discussed in Lemma 11.

Lemma 11. Let n denote the number of nodes and N be the number of tuple references in the initial provenance tree. Then Algorithm 1 can be implemented to compute a prove-nance tree with minimal storage costs in O ( n  X  N ) .
Proof. Given a node N , we can count the number of ref-erences from N to every single tuple in any descendant table N  X  in a top-down manner, and then aggregate them for each descendant table to get ref ( N , N  X  ). This requires O ( N ) time. Computing ref ( N 1 , N 2 ) for all ancestor-descendant pairs is thus possible in O ( n  X  N ). Afterwards each call of DP-opt can be performed in constant time. If we store re-sults, at most O ( n 2 ) such calls have to be made, giving us a time bound of O ( n 2 ), which is dominated by O ( n  X  N ). Algori thm 1 DP-opt Input: P, N 1 , N 2 Output: opt ( N 1 , N 2 ) 1: if N 2 is a leaf then return { N 1 , N 2 } 2: O 2 := DP-opt( P, N 1 , C 1 )  X  . . .  X  DP-opt( P, N 1 3: if N 1 = N 2 then return O 2 4: O 1 := { N 1 }  X  DP-opt( P, N 2 , N 2 ) 5: if cost ( O 1 )  X  cost ( O 2 ) then return O 1 6: else return O 2
Note that our dynamic programming approach only works for tree-shaped query graphs. It is an open question whether a polynomial time algorithm for optimizing arbitrary query DAGs exists.
Next, we will see how close to the optimal case a prove-nance table obtained by our simple reduction rules is, and compare it to alternative approaches. Let us consider the following strategies for storing provenance information:
Note that the table-free reduction strategy does not fit into our provenance tree framework. While storing operators or references to them with each provenance tuple incurs an overhead, it is possible to apply reductions to only some tuples in a provenance table when it would be inefficient to apply such reductions to the whole table (as we must in our framework). Therefore, we include it in our comparison as an alternative model, which provides us with a lower bound for the storage model and optimization approach described in [7].

The first thing we observe is that the difference between the reduction strategies can be huge.

Lemma 12. In terms of storage space,  X  X ull reduction X  can be worse than  X  X o reduction X  by an arbitrarily large factor. Conversely,  X  X o reduction X  can be worse than  X  X ull reduction X  by an arbitrarily large factor.

Proof. See Example 3 and 4.
Obvio usly optimal reduction will be at least as good as any rule-based reduction method, though it may be more difficult to find. However, neither optimal reduction nor table-free reduction can be arbitrarily much better than rule-based reduction using Rule II (Rule I is not required for obtaining a bound), as we will show next in Theorem 13 and Theorem 14 respectively.

While operators (selection, join, etc.) will typically be larger than a tuple reference in terms of storage space re-quirements, the number of different operators occurring within a given query (including parameters, e.g. selection criteria) is strictly limited, so that each basic operator (and possibly also combinations of operators, e.g. selection followed by join) is stored once and then only referenced. In [7] this is done for frequent operations. For simplicity of analysis we will assume: Making different (reasonable) size assumptions can change the bounds on storage space factors that we will establish in the following, but there will still be fixed finite bounds. Even when ignoring the space for storing operator references completely, which may be realistic for a hybrid model that splits provenance tables and applies reductions to them in-dividually 3 , the space requirements for table-free reduction are at most halved.

Theorem 13. Reduction by Rule II requires less than twice as much space as the table-free reduction.

Proof. After Rule II has been applied to the provenance tree, each provenance tuple referenced is of tuple type ( tupleID, . . . , tupleID ) or of a set type. Table-free reduction can re-duce the number of references further by applying Rule I on a tuple basis, i.e., by copying provenance information instead of referencing it, provided it is referenced at most once.

Now, consider the number of base references , i.e. the ref-erences to tuples in the original database rather than prove-nance tuples. Since each referenced provenance tuple refer-ences at least two other tuples (here we count each set stored as one extra base reference for the purpose of storage space), we have a tree in which the number of leaves is larger than the number of non-leaf nodes (provenance tuples). As table-free reduction can only eliminate non-leaves, the remaining number of references is more than half that as for Rule II reduction.

Theorem 14 . Reduction by Rule II requires less than twice as much space as optimal reduction.

Proof. After Rule II has been applied to the provenance tree, each provenance tuple referenced is of tuple type ( tupleID, . . . , tupleID ) (or an isomorphic nesting of tupleID) or of a set type. Denote this reduced provenance tree by P II .
Now, consider the provenance tuples in P II which are ref-erenced at least twice. Removing such tuples as part of optimal reduction cannot reduce overall storage space, so
Note ho wever that this can cause an exponential increase in the number of provenance tables. for purposes of calculating size we may assume that they are still present in the optimally reduced provenance tree. Hence all references to such tuples must also be present in the optimally reduced provenance tree. Similarly, references to base tuples (tuples in the original database) cannot be avoided, and we shall call references to either base tuples or tuples referenced multiple times unavoidable references (and all other references avoidable ).

Since each avoidable provenance tuple in P II references at least two other tuples (here we count each set stored as one extra base reference for the purpose of storage space), we have a reference DAG in which the number of avoidable references is smaller than the number of unavoidable ones. As optimal reduction can only eliminate avoidable references (or rather, cannot reduce the total number of references by eliminating unavoidable ones), the remaining number of ref-erences is more than half that as for Rule II reduction.
As shown above, Rule II alone already achieves a 2-approxi-mation (is worse by factor 2 at most) of the optimal prove-nance representation among the storage schemes considered. Applying Rule I (in addition to Rule II) can reduce stor-age costs further, but does not lower the theoretical bound. Moreover, table-free reduction is at most twice as bad as optimal reduction: It has at most as many tuple-references as optimal reduction, and its number of operator-references is bounded by the number of tuple-references.
To conduct a fine-grained study on various storage schemes of provenance data for relational query, we built a relational query engine called PTree from scratch using java, sup-porting ASPJ operations required for executing SQL-style queries as well as provenance tree construction during query execution. All reduction approaches proposed in Section 4 were implemented into PTree, and experiments were run on a 2.0GHz dual-core machine with 2GB RAM running Win-dows 7. Correctness of query results returned by our system has been verified using MySQL 5.1.
 Data Set &amp; Query Set Unlike optimizing query tree for efficiency evaluation, which needs a benchmark query/data set of various characteristics like TPC-H, there is no estab-lished benchmark data/query set for studying provenance data storage. Three freely available databases are chosen: The Wildfinder database 4 , a collection of medical databases and TPC-H with SF=1. Queries and query-plans for the first two datasets were hand-crafted, with the goal to obtain  X  X ealistic X  queries and avoid  X  X illy X  query plans (e.g. plans with consecutive selections or projections). Also we restricted ourselves to tree-shaped query plans. This allowed us to ef-ficiently compute the optimal solution (using Algorithm 1) for baseline comparison. For TPC-H, we adapt Q1-Q10 by keeping the core ASPJ part. The query sets and data sets used throughout experiments are available at [19]. Goals Our major focus is on comparing the space require-ments for provenance storage under the different optimiza-tion schemes discussed in Section 4, which are: optimal re-duction, reduction using Rules I and II, table-free reduction, no reduction and full reduction. Further , we compare our PTree ( X  X  optimal reduction) with the up-to-date provenance www.worl dwildlife.org www.medicare.gov stora ge methods such as Trio [20, 11] and Orchestra [13, 15], by adapting their provenance data structure for relational query context. Lastly , we evaluate the efficiency of our ap-proach for provenance tracking and optimization relative to query costs.
We will present results in detail for six representative queries, which involve up to 8 projections, 3 selections, 7 joins and 2 aggregation operations. Specifically, wwf 1 , med and med 2 are complex queries, while wwf 2 -wwf 4 are join-only queries. In addition, we give results for the entire query set [19] in summarized form.

When measuring the space requirements for storing a prove-nance tree, we use the number of tuple references across all provenance tables in the provenance tree, and use all refer-ences to tuples and subqueries for table-free reduction . Reduc tion wwf 1 wwf 2 wwf 3 wwf 4 med 1 med 2 Init ial tree 120 91 332 2032 249 0 1221 7 6512 4 No reduc t. 417 0 332 2032 249 0 393 4082 7 Full reduct. 816 2 249 1270 109 4 109 4775 3 Rule I 206 8 249 1270 109 4 109 1360 9 Rule I I 302 8 332 1332 115 2 175 2135 3 Rules I&amp;I I 195 0 249 1270 109 4 109 1360 9 Rules I I&amp;I 195 0 249 1270 109 4 109 1360 9 Optimal 187 5 166 708 604 109 1336 7 Tab le-free 217 8 332 1016 996 118 1970 0
Tab le 1 records the size of the provenance tree when it is initially constructed, after redundant tuples are removed (no reduction), for full reduction, reduction using Rule I and/or II, optimal reduction, and table-free reduction. From Table 1, we have made the following observations. (1) Reduction by Rules I&amp;II clearly outperforms no reduc-tion and full reduction. (2) While Theorem 14 only guarantees that reduction by Rules I&amp;II achieves a 2-approximation of the optimal solu-tion, the actual difference in size between the rule-based re-duction and the optimal reduction tends to be much smaller. (3) Even though Rule I alone offers no theoretical guaran-tee, it usually achieves better reduction than applying Rule II alone in practice. This is because, besides the operators such as selection and projection where both rules can be applied on, each query tested involve a lot of table join op-erations, where Rule I can move the provenance information for the joined table, while Rule II cannot. (4) The provenance tree resulted from Rules I&amp;II is of the same size as that resulted from Rule II&amp;I, which in some sense validates the isomorphism property of the resulted provenance tree regardless of the order of applying Rule I and Rule II, as stated in Theorem 7. (5) In many cases the solution found by application of Rules I&amp;II is indeed optimal. This can mainly be attributed to the fact that most joins occurring in practice (and in our query set, based on the database schemata provided) are key joins. (6) While no reduction incurs a significant overhead and is hardly ever optimal, the overhead is never extreme (typically around factor 2-4). The reason for this observed stability is that, the cost factor is bounded by the height of the query tree. (7) Full reduction is sometimes optimal (more likely for sim-ple queries like med 1 ), but can result in extremely high stor-age costs as well. Such extreme cases typically involve an aggregation followed by a join, similar to Example 4. (8) While table-free reduction can never be more than twice as bad as optimal reduction, this bound is frequently reached, whenever joins and aggregations are such that for each table either all or no tuples are referenced multiple times.
A summa ry of results for our entire query set [19] is given in Table 2. As space requirements for storing provenance in-formation can vary greatly among different queries, we sum-marize storage space used relative to the optimal solution, reporting average and maximum (worst case) results.
Figur e 3: Provenance Storage Cost on TPC-H
Recall Section 2, when evaluating the effectiveness of our optimizations, we do not compare our results to existing systems for provenance storage directly, as none of them is specifically designed for the context of relational query, and simply treating queries as workflows would incur significant overheads which would make a comparison unfair.

Among those systems, we find Trio[20] and Orchestra [13] should be the most related systems. We choose to compare them with our PTree system equipped with the optimal re-duction strategy. For a fair comparison, we re-implement their up-to-date provenance storage schemes [11] and [15], and adopt the how-provenance semantics for each approach. The re-implementation keeps their core storage scheme while ignoring the overhead costs of [11, 15] tailored for their own contexts. During the re-implementation, we have an interesting observation: the space requirements for such ap-proaches can be bounded from below by no reduction or full reduction (the most common case for individual queries). The result on TPC-H dataset is shown in Figure 3, where queries are ordered by a descending order of number of joins and aggregations. From Figure 3, we find: PTree usually saves up to 5-times storage space than Trio and Orchestra. The last point to address is time efficiency of our method. We have already shown theoretical bound on the time com-plexity of our methods: all algorithms have execution time linear or near-linear in the number of tuples visited during query co nstruction, and are of low polynomial order in the size (number of nodes) of the query tree. For each of the above sample queries, we separate the time for SQL query processing, initial provenance tree building and various re-duction strategies of our system. The cold-cached time for our six representative queries are shown in Figure 4. Figu re 4: Efficiency of Reduction on Sample Query
We find: (1) Initial provenance tree building takes roughly the same time as query evaluation. A more or less constant ratio is to be expected, as the number of provenance tuples in the initial provenance tree is exactly the total number of data tuples occurring in intermediate and final results. (2) All the reduction approaches considered take significantly less time than query evaluation, typically by one or two or-ders of magnitude, although this is query dependant. The main reason for this efficiency, which cannot be explained by the theoretical complexity bounds alone, is that the re-moval of redundant tuples from the initial provenance tree often shrinks it dramatically. (3) Optimal reduction can be significantly slower than Rules I&amp;II reduction, but never by more than one order of magnitude. This is due to the poly-nomial time nature of our proposed dynamic programming approach, as shown in Lemma 11.
 A summa ry of results for our entire query set is given in Table 3, by reporting the average and maximum (worst case) results, with costs for query evaluation as baseline. Results can be interpreted as computational overheads incurred by tracking/optimizing provenance data. Recall from Section 4, our approach for optimizing provenance storage (includ-ing query-rewriting) is orthogonal to query execution, and hence can be seamlessly incorporated into existing database engines. While the provenance tree will not always fit into main memory, standard externalization techniques used in query evaluation can be applied here as well.

We find for optimization by reduction, the two compet-ing approaches are Rules I&amp;II and optimal reduction. As efficiency of computation is typically not an issue, optimal reduction is preferable whenever the query is tree-shaped (recall that query graphs can be general DAGs, and Algo-rithm 1 is restricted to tree-shaped query plans). For other queries reduction by Rules I&amp;II can be used to achieve re-sults close to optimal.
In this paper, we have presented a new method for gener-ating and storing tuple-based provenance data for database queries. We first developed a provenance tree data struc-ture to store provenance information. Then we presented two rule-based reduction mechanisms to reduce the storage space. Furthermore, we proposed a polynomial time algo-rithm which computes an optimal solution for tree-structured queries, which represent a common subclass in practice. Ex-periments showed our approach can reduce storage cost sig-nificantly, while the computational overhead for provenance tracking and optimization is reasonably small. This work is partially supported by ARC Discovery grant DP120102829 and ARC DP110102777. Zhifeng Bao is in part supported by the Singapore Ministry of Education Grant No. R252-000-394-112.
