 1. Introduction the LDSQ according to the query point and returns the result set (i.e., quali research problem; and we are addressing this problem in this paper. 1.1. Query containment for LDSQs
R  X  ) is contained by that of another LDSQ, Q (denoted by R ); formally, R the clients and, on the other hand, the quantity of LDSQs submitted to a server for evaluation can be reduced. and the other objects (e.g. g and h ) are non-result objects. For another range query Q determine R  X  p R if cir ( q  X  ,r  X  ) p cir ( q, r ). Indeed, there are some other cases, in which R analysis, we list all six cases categorized a ccording to possible relationships between q and q  X 
Case 1. q  X  =q and r  X  =r . The radii and query points of Q
Here, it is certain that R  X  =R as they cover exactly the same searched area.  X 
Case 2. q  X  =q and r  X  b r . This case implies that the search area of Q hence R  X  must be contained by R . As illustrated in Fig. 1 (b), both Q
R p R .  X  objects inside cir ( q, r ) are locally available to the client, it is possible that cir ( q  X  mobile applications where a client issues the same range query while moving. In this case, the result of Q that of Q if the non-overlapped portion (i.e., cir ( q  X  ,r with r 2 =r but q 2  X  q gets R 2 ={d}  X  R .  X 
Then, R  X  is contained by R if and only if the area cir ( q cir ( q  X  ,r  X  ) p cir ( q, r ) is a special case of this condition. Q contains zero object and hence R 3 ={ c }  X  R .  X  this case, Q  X  may cover some additional objects beyond cir ( q, r ). answered and thus overall system performance.

On the other hand, when r  X  N r (i.e., Case 3 and Case 6), the new search space cir ( q located inside cir ( q  X  ,r  X  )butoutsideof cir ( q, r ). After all objects with cir ( q studies, these two cases are not addressed in this work. 1.2. Containment scope in an area S , a containment scope for the result R of an LDSQ Q , denoted by S S and Q  X  ' s search area size is not larger than Q 's, Q  X  result set R of a range query Q of our example. Now, as shown in Fig. 2 (b), because of conditions (1) r hold, Q 2 and Q 3 can also be answered with R locally, with R On the other hand, the representation of a containment scope S only a representative subset of non-result objects (called complementary set ) that suf 1.3. Paper organization through simulations to validate the ef fi ciency of the proposed approaches. lists our contributions presented and states our future research plans. 2. Related work following. Besides [18] provides a comprehensive review of location-dependent query processing. 2.1. Continuous queries
In general, there are two major types of approaches for continuous queries. The queries, are explored. Usually the size and shape of safe regions are prede according to client and object trajectories. Our work does not assume any given client trajectories. 2.2. Semantic region
The main idea of semantic regions is to determine whether the queried area of an LDSQ Q another LDSQ Q (denoted by A Q ). As long as A  X  Q p A Q , the result for Q preserved together with the description A Q as the semantic region for R . As another window query Q m NN objects, o 1 ,o 2 ... o m , obtained with respect to a query point q , k NN query issued at q q to q  X  is bounded by a safe distance, i.e., (| o m ,q | an NN query over 2NN objects, i.e., c and d .
 another 2NN query, issued at q  X  which is more than (| d, q | 2.3. Valid scope before reaching its target vertex, the valid scope is trimmed by o intersection of c 's and d 's Minkowski windows. This valid scope re approaches always incur a long processing time and high I/O cost.
 scope computation presented in this paper are not the same as those for valid scopes. terms of the main ideas and the supported types of queries in Table 1 . 3. Preliminaries the client side.
 are indexed on their spatial coordinates by an R-tree [25] , for its wide acceptance and ef fi ef fi into a single index traversal, as will be discussed later.
 Thereafter, the server returns R together with a corresponding containment scope S
Then, it submits Q  X  to the server only when the containment tester indicates R server. Otherwise, the local LDSQ processor returns required objects for Q 4. LDSQ containment for range and window queries
Since range queries and window queries share a lot of similarities, we, in this section, range queries. Later, we extend those techniques to handle window queries. 4.1. Formulation of containment scope for range query
Every range query Q range ( q, r ) searches for objects located inside a speci radius r . Formally, the result set R of Q range ( q, r ) equals { o |o As q is only located inside cir ( c, r ) and cir ( d, r ), objects c and d form the result set. result objects. Formally, V R can be expressed as follows: where the fi rst term where all the result objects are covered by a query; and the second term result object is included as a result object. Revisit our example. The valid scope for R q  X   X  V R , R range ( q  X  r )={ c, d }.

Unlike valid scope, containment scope maximizes the reusability of individual result objects of R by Q range ( q, r ). Let R  X  ( p R range ( q, r )) denote the result set of an LDSQ that can be answered by R denoted by S range ( q, r ), is derived in Eq. (1) :
Here, the fi rst term (see Fig. 2 (b)) is larger than the valid scope (as shown in Fig. 7 (b)).
As we can observe from Eq. (1) , the derivation of S range { b ... b |B| }, i.e., (1) A  X  B  X  A  X  (A  X  B), and (2) A  X  B expressed in Eq. (2) .

From Eq. (2) , we can see that only those non-result objects o
Minkowski circle are needed. Those non-result objects are termed complementary objects . 4.2. Containment scope computation for range query outlined in Fig. 8 . While the algorithm can be seamlessly integrated with the best-in a non-decreasing order of mindists to q , are taken as inputs to our algorithm. of any result object, a detailed examination is performed (lines 4
Lemma 1. The largest search space for complementary objects for a given range query Q
Proof. As illustrated in Fig. 9 , for a range query, Q range q does not exceed r . As two circles cir ( o, r ) and cir ( o between the query point and a complementary object for a range query Q
Fig. 10 illustrates how the algorithm runs for a range query Q
R contains c and d and the priority queue P maintains ( a , b , N
P is examined. Since cir ( a, r ) overlaps cir ( c, r ), a is included in C . Next, N containment scope is shown in Fig. 10 (d). 4.3. Removable complementary objects covers that between cir ( o, r )and cir ( o 2 ,r ). In this case, o removable complementary object identi fi cation.

Basically, a complementary object o  X  is removable if overlaps between cir ( o covered by some other complementary objects. Here, we discuss two possible cases where complementary object o
For the fi rst case that o is the result object and o 1 and o cir ( o 2 , r ) is fully covered by that between cir ( o, r )and cir ( o
Fig. 11 (b), the arc example. To determine if o 3 is removable due to other complementary objects o follows. We determine an intersection point p between the perimeter of cir ( o certainly hidden by the union of cir ( o 1 , r )and cir ( o index node N on a result object o fully covered by that for a complementary object o
N on a result object o is covered by those for two complementary objects o thus N is ignored.
 conducts two checks. The fi rst check (line 3) examines the existence of a complementary object c whose arc , i.e.,  X  o . If such c exists, may be removable. The second check (lines 4 examining all result objects, and it can be removed. result objects. 4.4. Containment test for range query
Fig. 14 . Whenever a client receives a new range query Q  X  complementary objects (lines 2  X  3). The query that passes these two checks will be answered locally. 4.5. LDSQ containment for window query query result to window query result. Given a window query Q centered at q , with length and width of 2 l and 2 w , respectively. Hence, the result set of Q denoted by S window ( q, l, w ), as in Eq. (3) .
 complementary objects and the fi nal containment scope are depicted in Fig. 15 (b).
Lemma 2. The maximum search space for complementary objects for a given window query Q rect ( q, 3l, 3w ).  X 
Centering at o , rect (o, l, w) can touch a complementary object, o 3 l (3 w ).  X 
Further, some removable complementary objects with Minkowski rectangles hidden by those of other complementary
Fig. 16 (a), whenever the overlapped area between a result object o and a complementary object o the union of other complementary objects.

Finally, given a new window query Q window ( q  X  ,l  X  ,w  X  and w  X   X  w , and if no complementary object is covered by rect ( q containment test fails. 5. LDSQ containment for k nearest neighbor query 5.1. Formulation of containment scope for k NN query
A k NN query Q nn ( q, k )returns k objects nearest to q . Formally, the result set of Q k and HP o  X  ,o along the perpendicular bisector  X  o,o  X  between o and o two half-planes HP d,f and HP f,d formed based on the perpendicular bisector determined as an intersection area of all half-planes of o formed against all the other objects, i.e., S is known as Voronoi cell [9,27] , which is also a containment scope and a valid scope for the NN query result. object o  X  R and each non-result object o  X   X  O  X  R . The valid scope V or possible subsets R  X  where R  X  p Rnn ( q,k ). Hence, the containment scope, S d , that is observably larger than the corresponding valid scope.
 property, we develop an ef fi cient containment scope calculation algorithm for k NN query. 5.2. Containment scope computation for kNN query objects are examined in the process.
 queue P before the processing. First, we initialize a convex hull for each result object o out of all the existing largest circles.
 vertex v 1 , v 2 v 3 , and v 4 , as shown in Fig. 19 (a), and the priority queue P ={ d, c, a, b, N
Then, the convex hull is trimmed by the half-plane HP c,d fi result objects. 5.3. Containment test for kNN query can be answered locally. The logic of the test as depicted in Fig. 20 is to examine if k ascending order of their distances to a query point, q  X  . If all of the collected objects are the result set of k  X  NN query issued at q evaluation. 6. Performance analysis containment scope computation and its transmission for range, window and k NN queries, and determine the bene facilitate our discussion, Table 2 summarizes the notations used hereafter. processing cost and communication cost can be estimated as  X   X comm C ). LDSQ containment is bene fi cial if  X   X proc C and
To facilitate our analysis, we assume that all objects O are in dimensional unit space (i.e., [1] ). The average distance between any two adjacent objects, denoted by 1 j O j s with d i = j q ; o i j  X  of size s c . 6.1. Performance analysis for range and window queries  X  6.1.1. Estimation of  X  range
Assumethata client initially submits a range query Q range for simplicity in the following) and a containment scope S
Q range ( q  X  ,r  X  )with r  X  = r ,theresultof Q range ( q  X  assume that q  X  is uniformly distributed in the space and hence  X  complementary objects | C range | and (B) estimating the areas of individual containment scope. For simplicity, we do not consider those removable complementary objects in this analysis. (A) Estimation of | C range |. As shown in Fig. 21 (b), each non-result object o 2  X  a sin r d angular range that is uniquely contributed by a non-result object o 1  X  0
B @ intersecting with those of result objects (e.g., cir ( q ,2 r ) in this example), the union of all object) covers (0, 2  X  )with respect to q .
 be determined as in Eq. (5) . (B) Estimation of containment scope area. Now, we determine the area of an which represents the area of the  X  arrowhead-like  X  shape formed by object o complementary object o i and let  X  ( d i ,  X  i ),  X  ( d i a lower triangle that bounds  X  i , and the area of a sector, respectively as stated in Eq. (6) . where 1  X  | S range ( q, r )| as stated in Eq. (7) . 6.1.2. Estimation of proc Q,range and proc C,range and | C range |, the search area becomes cir (q,  X  )where and (9) , respectively. where s t is the expected side length of each node's MBB at level t and it equals
N = N t  X  1 f while N 1 = N f ; and fi nally  X  log N f  X  determines the height of an R-tree index. Then, the net cost incurred by the containment scope computation (i.e., proc
Eqs. (9)  X  (8) ).Foralarge r ,| C range |isexpectedtobesmallandthus 6.1.3. Estimation of comm R,range and comm C,range containment consumes extra bandwidth to download the spatial coordinates of complementary objects, comm
While (1  X   X  range ) LDSQs can be answered locally, the communication cost saved is (1 s  X  reasonably insigni fi cant, i.e., comm C,range  X  (1  X   X  range 6.1.4. Analysis for window queries facilitate the analysis, we consider window queries Q window consider that window queries with square search areas are equivalent to range queries with r = that a window query needs to be submitted to the server,  X  scope, proc C,window , and the communication overhead for transferring complementary objects, comm based on the above techniques. To save space, we omit the detailed discussion. 6.2. Performance analysis for kNN queries
Next, we analyze the performance for k NN queries. We consider a k NN query Q simplicity in the following) has a containment scope S knn needs to be sent to the server, (2) the processing cost proc cost proc C,knn for formulating its containment scope S knn result to the client, and the communication cost comm C,knn k NN query Q q,knn . Hence, the size of the containment scope, i.e., | S (1-| S knn ( q, k )|), as stated in Eq. (10) . for a larger k is expected to be smaller which forces more queries to be sent to the server for processing.
Then, we estimate the total processing cost in evaluating Q search area that covers k NN objects with respect to q is expected to be a circle cir ( q, d objects is  X  (i.e., to cir q ; in Eqs. (11) and (12) , respectively.
The number of node accesses needed for deriving containment scope S  X 
Last, based on a fact that k result objects are located inside the circle cir ( q , d complementary objects and result objects is cir ( q, d k +  X   X  | O |  X  (( d k +  X  ) 2  X  d k 2 ). Then, the transmission overhead for complementary objects, comm containment scope can save the communication overhead of | s 6.3. Discussion scope. In the next section, we validate our cost model through simulations. 7. Experiments related approaches reviewed in Section 2 . 7.1. Experiment setup results and the context is clear. Except Bare, Semantic and Valid as well as LDSQC respectively de and containment scope, are collectively called auxiliary scopes in this evaluation. scope computation algorithms. Finally, for LDSQC, we evaluate the removable complementary object removable complementary objects.
 with 750 MHz CPUs and 1 GB RAM each running the SunOS 5.10 operating system. This con policy is used to alleviate server I/O costs for Valid (TPQ) that needs repeated index accesses. 7.2. Exp. 1. Performance evaluation on fi xed query parameters distance D moved between steps is varied. First, Fig. 22 plots the performance for range queries with radii expensive removable complementary object detection. To identify the extra cost incurred by result objects). As such, we can see that no removable complementary object improvement becomes huge for large populations of mobile clients.

Second, we investigate the system performance improvement for window queries, with the window side length l the processing cost at a small expense of I/O cost and bandwidth consumption. containment scope. Thus, LDSQC can outperform both Valid (TPQ) and Valid (Geo) as will be presented next. 7.3. Exp. 2. Performance evaluation on varied query parameters the others when query parameters can vary.
 7.4. Exp. 3. Performance evaluation on object density
While the object density increases, the effectiveness of all the approaches is reduced as re Fig. 26 (c) and (d), respectively. Finally, in general, LDSQC still outperforms all the other approaches.
In summary, LDSQC performs the best among all the evaluated approaches for both mobile and wireless environments. 8. Conclusion mobile clients access location-related information (such as local news, traf the server, shortening query response time, and reducing client energy consumption and bandwidth contention. containment scope that represents a spatial area associated with an LDSQ result set R wherein any new LDSQ Q previous one for clients. objects, so as to reduce the bandwidth consumption and client storage overhead. 5. We have analyzed the effectiveness of LDSQ containment in terms of the performance gains and the overheads. many circumstances.

We believe that our proposed LDSQ containment concept will lead us to other advanced data management and query client answering LDSQs with multiple LDSQ results and support LDSQ containment for other complex LDSQs.
References
