 In cloud computing paradigm, data owners could outsource their databases to the service provider, and thus reap huge benefits from releasing the heavy stor-age and management tasks to the cloud server. However, sensitive data, such as medical or financial records, should be encrypted before being uploaded to the cloud [ 7 ]. To preserve the privacy of sensitive data, decryption keys should never be revealed to the cloud server. Unfortunately, this will introduce new challenges to data utilization. Considering the multi-dimensional range queries, which are typical database query operations in real life, lightweight encryption scheme, e.g. block cipher [ 3 ], cannot be directly applied for the server to conduct the queries. To enable private queries over encrypted data, Lu [ 1 ]proposed LSE , a symmet-ric encryption scheme, which can deal with the private single-dimensional range queries in logarithmic time. As a multi-dimensional range query can be decom-posed to several single-dimensional queries, LSE theoretically can be extended to support private multi-dimensional range queries. However, the extended scheme will cause significant information leakage. Specifically, the cloud server will learn the exact relationship between every single-dimension of the query data and the outsourced data. Other recent works, e.g. [ 2 ], are also suffered from leaking this kind of information to the cloud server.
 To prevent the single-dimensional information leakage, Wang et al .[ 4 ]pro-posed Maple by leveraging Hidden Vector Encryption [ 5 ]inanovelway. Although Maple can provide stronger privacy guarantee than previous works, it is still not fully secure in the sense of cryptography, e.g., the cloud server can learn the query path as well as which data records are the query results during each query. The cloud server can easily determine the data distribution based on this knowledge through statistical analysis. Besides, this work is inefficient due to the heavy computational operations of cryptography.
 To deal with this problem, we present in this paper a fully secure scheme based on private information retrieval (PIR) [ 8 ] and batch codes (BC) [ 6 ]. To improve computational efficiency and to reduce storage cost, we adopt the block cipher as the underlying encryption scheme. Specifically, we use the AES in counter mode to encrypt the data records before uploading them to the cloud server. 2.1 Basic Scheme We first give a basic private range query protocol. When the data owner wants to issue a range query, she does not send the server any information about the query region. Instead, she just submits a query requirement. Once receiving a query requirement from the data owner, the cloud server forwards all the encrypted nodes and the topology structure in high levels of the encrypted tree to the data owner. Each node in the bottom level is required to be associated with an identity that contains the indexes of its children nodes in the next level. The data owner first decrypts the root node, and then decides which nodes in the next level should be selected based on the intersection judgement. This process will continue until the data owner obtains the desired indexes of the children nodes of the bottom level. The above process is secure, because the data owner does not send any confidential information to the cloud server. Also, storage and computational overhead can be reduced by restricting the number of levels. Obviously, this process only enables the data owner to perform traversal over limited levels, as transferring the nodes in the next level will incur large communication cost and storage overhead on the data owner. Fortunately, this problem can be resolved by adopting PIR protocol. Recalling that during the above process, the data owner has already known which nodes in the next level should be transferred. In the next step, the data owner and the cloud server could engage in PIR protocol several times to let the data owner extract the information of these nodes, without revealing the required nodes to the cloud server. The data owner then decrypts these nodes and judges which children nodes should be transferred in the next level. This process could continue to the end, and the data owner will obtain all the data records within the query region. result and does not leak much information, it may cause large volume of com-putation on the server side, because the computational time on the cloud server will increase linearly with respect to the amount of query result. The proto-col will suffer from inefficiency in such a case. In the next subsection, we will present an improvement to greatly reduce the cost. Integrating the improvement into the above query protocol, we can easily eliminate the potential security risk by masking the amount of elements issued in each level, and it will not cause significant increase of the overhead. 2.2 Efficient Private Range Query Protocol As shown in [ 6 ], batch code constructions can be used to support multi-round PIR. We now give an example to show how it works. Considering a database with n bits, one can straightforwardly use the above PIR scheme twice to obtain two elements of the database. However, the corresponding computational overhead is 2 n multiplications at the server. If we partition the database into two parts: L and R containing n/ 2 bits each, and store L on the first bucket, second and L  X  R on the third. Now one can extract two elements by calling single-bit PIR in each bucket, and the computational overhead at the server is reduced to 3 n/ 2 multiplication. Also, the database can be partitioned into m parts, i.e. n = n 1 || ... || n m , where | n i | = n m ,i n m +1 = n 1  X  ...  X  n m . Now it is easy to know that we can retrieve any two bits in n by extracting single bit from each of the m + 1 parts, and the computational overhead at the server will be reduced to ( m +1) n/m multiplication. retrieval, and the computational overhead at server side is monotonic with respect to m . However, we cannot simply set m the maximum value to reduce the total cost, as this will also increase the corresponding computational over-head at the data owner side and the communication overhead. Fortunately, the optimization coding scheme can be selected easily by considering the overall overhead, and using such a coding scheme will greatly reduce the total cost. Our protocols are implemented in C++ using GMP library and tested on two MacBook Pro laptops (2.2GHz CPU and 16GB RAM) connected by a 100 Mbps LAN. The default experimental setting is as follows: the encryption key length is 128, the bit length of N is 1024, the bit length l of each data record is 24, the maximum number of result points k is 64, the number of data records is 4,000,000. We show in Fig. 1 the computation time and message volume by executing different partition scheme (where m varies from 1 to 13). Clearly, the computation overhead will decrease rapidly, and the transmitted message volume will increase slowly when m varies from 1 to 7. So, we could easily select the best encoding scheme to greatly reduce the total overhead. Based on the optimization partition scheme, even to deal with 10,000,000 data records, our protocol can be finished within 10 minutes, which is much faster than the most secure previous work (Maple requires 928 seconds to deal with 100,000 data records). In this paper, we have studied the problem of private range queries in outsourced database. We have presented a fully secure scheme based on private information retrieval. By adopting batch code, our scheme is much more efficient than state-of-the-art approaches.

