
Syed Khairuzzaman Tanbeer, Chowdhu ry Farhan Ahmed, Byeong-Soo Jeong, Mining frequent patterns [1], [2], [4], [6] from transactional databases has been actively and widely studied in data mining and knowledge discovery techniques such as association rule, sequential pattern, classification, and clustering. Since the rationale behind mining the support metric-based frequent patterns is to find the set of patterns that appear frequently in a database, a huge number of patterns are normally generated and most of which might be found insignificant depending on application or user requirement. Moreover, the computation cost in finding such number of patterns may not be trivial. As a result, several tech-niques to mine constraint-based and/or user interest-based frequent patterns [9], [10], [5] have been proposed recently to reduce the desired result set by effectively and efficiently applying early pruning techniques. Uses of several interesting pa-rameters such as closed [3], K -most [5], demand-driven [10], maximum length [9] are found useful in literature in discovering frequent patterns of special inter-est. The other important criterion for identifying the interestingness of frequent patterns might be the shape of occurrence, i.e., whether they occur periodically, irregularly, or mostly in specific time interval in the database.

In a retail market, among all frequently sold products, the user may be in-terested only on the regularly sold products compared to the rest. Besides, for improved web site design or web administration an administrator may be in-terested on the click sequences of heav ily hit web pages. Also, in genetic data analysis the set of all genes that not onl y appear frequently but also co-occur at regular interval in DNA sequence may ca rry more significant information to sci-entists. As for stock market, the set of high stocks indices that rise periodically may be of special interest to companies and individuals. In the above examples, we observe that the occurrence periodicity plays an important role in discovering some interesting frequent patterns in a wide variety of application areas. We de-fine such a frequent pattern that appears maintaining a similar period/interval in a database as a periodic-frequent pattern .
 Let us consider the transactional database of Table 1 with ten transactions. The support of the patterns  X  e  X ,  X  ae  X ,  X  cd  X ,  X  ce  X ,  X  b  X , and  X  de  X  in the database are respectively 8, 5, 5, 6, 5, and 5. Even though these patterns may be frequent in the database, some of them may not be periodic-frequent because of non-similar occurrence periods. For example,  X  b  X  X nd X  ae  X  appear more frequently at a certain part of the database (i.e.,  X  b  X  at the end and  X  ae  X  at the begin-ning of database) than the rest part. In contrast, patterns  X  e  X ,  X  cd  X ,  X  ce  X ,  X  de  X  appear at almost regular intervals. Therefore, the latter patterns can be more important frequent patterns in terms of the appearance intervals. On the other hand, although the respective appearance intervals of patterns  X  ac  X ,  X  cde  X ,  X  f  X  etc. are almost similar, they may not be th e patterns of interest due to their rel-atively low frequency. The traditional fr equent pattern mining techniques fail to discover such periodic-frequent patterns because they are only concerned about the occurrence frequency and disregard the pattern occurrence behavior.
Motivated by the above discussion and examples, in this paper, we address a new problem of discovering periodic-frequent patterns in a transactional database. We define a new periodicity measure for a pattern by the maximum interval at which the same pattern occurs in a database. Therefore, periodic-frequent patterns, defined such way, satisfy the downward closure property [1], i.e., if a frequent pattern is found periodic then all of its non-empty subsets will be periodic. In other words, if a frequent pattern is not periodic then none of its supersets can be perio dic. In order to mine periodic-frequent patterns, we capture the database contents in a highly compact tree structure, called a PF-tree (Periodic-frequent Pa ttern tree). To ensure that the tree structure is com-pact and informative, only periodic-frequent length-1 items will have nodes in the tree and to obtain higher prefix sharing, more frequently occurring items are located at the upper part of the tree. We also propose an efficient pattern growth-based mining approach to mine the complete set of periodic-frequent patterns from our PF-tree. The comprehensive performance study on both synthetic and real datasets demonstrates that discovering periodic-frequent patterns from the PF-tree is highly memory and time efficient.

The rest of the paper is organized as follows. In Section 2, we summarize the existing algorithms to mine interesting frequent patterns. Section 3 formally introduces the problem of periodic-frequent pattern mining. The structure and mining of PF-tree are given in Section 4. We report our experimental results in Section 5. Finally, Section 6 concludes the paper. Since its introduction by Agrawal et al. in 1993 [1], a large number of techniques [2], [4], [6] have been proposed in mining support constraint-based frequent pat-terns. Han et al. [2] proposed the frequent pattern tree (FP-tree) and the FP-growth algorithm to mine frequent patterns with a memory and time efficient manner. The performance gain achieved by the FP-growth is mainly based on the highly compact nature of the FP-tree, where it stores only the frequent items in a support-descending order. To reduce the size of resultant pattern set and to improve the mining efficiency closed [3] frequent pattern mining has been focused. However, none of the above frequent pattern mining techniques can successfully provide interesting frequent patterns, since their outputs are only based on the support threshold.

Mining interesting frequent patterns of different forms [9], [10], [5], [7] in transactional databases and time-seri es data has been well-addressed over the last decade. Minh et al. [5] proposed a top-K frequent pattern mining technique that allows the user to control the number of patterns to be discovered without any support threshold. In [9] the authors put efforts to discover the maximum length frequent patterns, rather than finding the complete set of frequent pat-terns. They have shown the suitability of their method in several real world scenario where long patterns play significant role. Wang et al. [10] mined fre-quent patterns from relational databas e. Using the user X  X  query, they find the frequently occurring pattern structures defined by attributes values of items. However, the above models still fail to discover the interesting periodic occur-rence characteristics of frequent patterns.

Temporal relationships among pattern occurrences were studied in [7] which focused on discovering the frequently occurring substring patterns in a dimension of multivariate time-series data. Periodic pattern mining has also been studied as a wing of sequential pattern mining [8] in recent years. A lthough periodic pattern mining is closely related to ou r work, it cannot be directly applied for finding the periodic-frequent patterns from a transactional database because of two primary reasons. First, it considers either time-series or sequential data; second, it does not consider the support threshold which is the only constraint to be satisfied by all frequent patterns. Our proposed periodic-frequent pattern mining technique, on the other hand, introduces a new interesting measure of periodicity and provides the set of patterns that satisfy both of the periodicity and support thresholds in a transactional database. In this section, we describe the conceptu al framework of the periodic-frequent pattern mining and introduce the basic notations and definitions in this regard.
Let I = { i 1 ,i 2 , ..., i n } be a set of literals, called items that have ever been used as a unit information of an application domain. A set X = { i j , ..., i k } X  I , where j  X  k and j, k  X  [1 ,n ], is called a pattern (or an itemset). A transaction t =( tid, Y ) is a tuple where tid represents a transaction-id (or timestamp) and Y is a pattern. A transactional database TDB over I is a set of transactions T = { t 1 , ..., t m } , m = | TDB | ,where | TDB | is the size of TDB in total number of transactions. If X  X  Y ,itissaidthat t contains X or X occurs in t and j, k  X  [1 ,m ]and j  X  k is the set of all transaction-ids where X occurs in TDB . Definition 1. ( a period of pattern X ) Let t X j +1 and t X j , j  X  [1 , ( m  X  1)] be two consecutive transaction-ids where X appears. The number of transactions or the time difference between t X j +1 and t X j can be defined as a period of X , say p X ( i.e., p X = t X j +1  X  t X j , j  X  [1 , ( m  X  1)]) . For the simplicity of period computation, the first and the last transactions ( say, t f and t l ) in TDB are in the TDB of Table 1 the set of transactions where pattern  X  de  X  appears is T de = { 1 , 2 , 4 , 7 , 8 } . Therefore, the periods for this pattern are 1(= 1  X  t f ) , 1(= 2  X  1) , 2(= 4  X  2) , 3(= 7  X  4) , 1(= 8  X  7) ,and 2(= t l  X  8) ,where t f =0 and t l =10 .
 The occurrence intervals, defined as abo ve, can give the exact information of appearance behavior of a pattern. The largest occurrence period of a pattern, therefore, can provide the upper limit of its periodic occurrenc e characteristic. Hence, the measure of the chara cteristic of a pattern of being periodic in a TDB (we call it as the periodicity of that pattern) can be defined as follows. Definition 2. ( periodicity of pattern X ) Let for a T X , P X be the set of all periods of X i.e., P X = { p X 1 , ..., p X r } ,where r is the total number of periods in P
X . Then, the periodicity of X can be denoted as Per ( X )= Max ( p X For example, in the TDB of Table 1, Per ( de )=3 i.e., Max (1 , 1 , 2 , 3 , 1 , 2) . Definition 3. ( support of pattern X ) The number of transactions in a TDB that contain X is called the support of X in TDB and denoted as Sup ( X ) . Therefore, Sup ( X )= | T X | ,where | T X | is the size of T X . For example, the support of pattern  X  de  X  X nthe TDB of Table 1 is Sup ( de )=5 ,since | T de | =5 . A pattern is called a periodic-frequent pattern if it satisfies both of the following two criteria: ( i ) its periodicity is no greater than a user-given maximum period-icity threshold say max per ,  X  and ( ii ) its support is no less than a user-given minimum support threshold, say min sup ,  X  ,with  X  ,  X  in percentage of | TDB | . Therefore, the Periodic-frequent pattern mining problem ,given  X  ,  X  ,anda TDB , is to discover the complete set of periodic-frequent patterns in TDB having pe-riodicity no more than  X  and support no less than  X  .Let PF TDB refer to the set of all periodic-frequent patterns in a TDB for given  X  and  X  . In this section, we describe the construction and mining of Periodic-Frequent Pattern tree (PF-tree). Since periodic-frequent patterns follow the downward closure property, periodic-frequent length-1 items will play an important role in mining periodic-frequent patterns. Therefore, it is necessary to perform one database scan to identify the set of length-1 periodic-frequent items. The objec-tive of this scan is to collect the support count (i.e., frequency) and the period-icity of each item in the database. Consequently, for further processing we can ignore all items that do not satisfy the periodicity and support thresholds. Let PF be the set of all items that are found periodic-frequent at this stage. 4.1 Structure of the PF-Tree The structure of the PF-tree includes a prefix-tree and a periodic-frequent item list, called the PF-list, consisting of ea ch distinct item with relative support, periodicity and a pointer pointing to the first node in the PF-tree carrying the item. To facilitate high degree of compactness, items in a PF-tree are arranged in support-descending item order. It has been proved in [6] that such tree can provide a highly compact tree structure (as FP-tree in [2] and CP-tree in [6]) and an efficient mining phase using FP-growth mining technique. Before discussing the tree construction process, we provide the PF-list construction technique and the node structures of a PF-tree.
 Construction of the PF-list. Each entry in a PF-list consists of three fields -item name ( i ), total support ( f ), and the periodicity of i ( p ). The tid softhelast occurring transactions of all items in the PF-list are explicitly recorded for each item in a temporary array, called id l .Let t cur and p cur respectively denote the tid of current transaction and th e most recent period for an item i . The PF-list is, therefore, maintained according to the process given in Fig. 1.

In Fig. 2 we show how the PF-list is populated for the TDB of Table 1. With the scan of the first transaction { acde } (i.e., t cur = 1), the items  X  a  X ,  X  c  X ,  X  d  X , and  X  e  X  in the list are initialized as shown in Fig. 2(a) (lines 1 and 2 in Fig. 1). The next transaction { adef } with t cur = 2 initializes PF-list entries for item  X  f  X  and updates values { f ; p } and id l (lines 3 -6 in Fig. 1) respectively to { 2; 1 } and { 2 } for items  X  a  X ,  X  d  X , and  X  e  X  (Fig. 2(b)). As shown in Fig. 2(c), the periodicity ( p ) of  X  c  X  changes from 1 to 2, since after scanning tid = 3 the value of p cur for it is found greater than its previous periodicity (lines 5 and 6 in Fig. 1). The PF-list after scanning all ten transactions is gi ven in Fig. 2(d). To reflect the correct periodicity for each item in the list, the whole PF-list is refreshed as mentioned in line 7 of Fig. 1 which results the final PF-list of Fig. 2(d). Therefore, once the PF-list is built, we generate the PF by removing items that do not satisfy the user-given periodicity and support thresholds from it.
 PF-tree Node Structures. An important feature of a PF-tree is that, it explicitly maintains the occurrence information for each transaction in the tree structure by keeping an occurrenc e transaction-id list, called tid -list, only at the last node of every transaction. Hence, there are two types of nodes maintained in a PF-tree; ordinary node and tail -node. The former is the type of nodes similar to that used in FP-tree, whereas the latter is the node that represents the last item of any sorted transaction. Therefore, the structure of a tail -node is number of transactions from the root up to the node) is a transaction-id where item N is the last item. Like the FP-tree [2], each node in a PF-tree maintains parent, children, and node traversal pointers. However, irrespective of the node type, no node in a PF-tree maintains support count value in it. 4.2 Construction of the PF-Tree With the second database scan, the PF-tree is constructed in such a way that, it only contains nodes for items in PF . We use an example to illustrate the construction of a PF-tree.

Consider the transactional database of Table 1. In Fig. 3, we show the PF-tree construction steps for  X  =4and  X  = 5. At first, the support-descending PF-list (Fig. 3(a)) for all periodic-freq uent items is constru cted from the PF-list of Fig. 2(d). Next, using the FP-tree [2] construction technique, only the items in this list take part in PF-tree construction. For the simplicity of figures, we do not show the node traversal pointers in trees, however, they are maintained in a fashion like FP-tree does. The tree construction starts with inserting the first transaction { acde } (i.e., tid = 1) according to PF-list order, as shown in Fig. 3(b), since all the items in the transactions are periodic-frequent. The tail -node  X  d : 1 X  carries the tid of the transaction. After removing the non-periodic-frequent item  X  f  X , the second transaction is inserted into the tree in the formandanorderof { ead } with node  X  d :2 X  X sthe tail -node for it (Fig. 3(c)). After inserting all the transactions in similar fashion we get the final PF-tree for the database as shown in Fig. 3(d).

Based on the PF-list population technique discussed in Section 4.1 and the above example, we have the following property and lemmas of a PF-tree. For each transaction t in a TDB , PF ( t ) is the set of all periodic-frequent items in t , i.e., PF ( t )= item ( t ) PF , and is called the periodic-frequent item projection of t .
 Property 1. A PF-tree maintains a complete set of periodic-frequent item pro-jection for each transaction in a TDB only once.
 Lemma 1. Given a transactional database TDB ,a max per ,anda min sup , the complete set of all periodic-frequent item projections of all transactions in a TDB can be derived from the PF-tree for both of the max per and min sup . Proof: Based on Property 1, PF ( t ) of each transaction t is mapped to only one path in the tree and any path from the root up to a tail -node maintains the complete projection for exactly n transactions (where n is the total number of entries in the tid -list of the tail -node).
 Lemma 2. ThesizeofaPF-tree ( without the root node ) on a transactional database TDB for a max per ,anda min sup is bounded by t  X  TDB | PF ( t ) | . Proof: According to the PF-tree construct ion process and Lemma 1, each trans-action t contributes at best one path of the size | PF ( t ) | to a PF-tree. Therefore, the total size contribution o f all transactions can be t  X  TDB | PF ( t ) | at best. However, since there are usually a lot of common prefix patterns among the trans-actions, the size of a PF-tree is normally much smaller than t  X  TDB | PF ( t ) | .
One can assume that the structure of a PF-tree may not be memory efficient, since it explicitly maintains tid s of each transaction. But, we argue that the PF-tree achieves the memory efficiency by keep ing such transaction information only at the tail -nodes and avoiding the support count field at each node. Moreover, keeping the tid information in tree can also been found in literature for efficient frequent pattern mining [3], [4].

Therefore, the highly com pact PF-tree structure maintains the complete in-formation for all periodic-frequent pa tterns. Once the PF-tree is constructed, we use an FP-growth-based pattern growth mining technique to discover the complete set of periodic-frequent patterns from it. 4.3 Mining Periodic-Frequent Pattern Even though both of the PF-tree and FP-tree arrange items in support-descending order, we can not directly apply the FP -growth mining on a PF-tree. The rea-son is that, PF-tree does not maintain the support count at each node, and it handles the tid -lists at tail -nodes. Therefore, we devise a pattern growth-based bottom-up mining technique that can handle the additional features of the PF-tree. The basic operations in mining a PF-tree for periodic-frequent patterns are ( i ) counting length-1 periodic-frequent items, ( ii ) constructing the prefix-tree for each periodic-frequent itemset, and ( iii ) constructing the conditional tree from each prefix-tree. The P F-list provides the length-1 periodic-frequent items. Before discussing the prefix-tree construction process we explore the following important property and lemma of a PF-tree.
 Property 2. A tail -node in a PF-tree maintains the occurrence information for all the nodes in the path ( from that tail -node to the root ) at least in the transactions in its tid -list.
 Lemma 3. Let Z = { a 1 ,a 2 , ..., a n } be a path in a PF-tree where node a n is the tail -node carring the tid -listofthepath.Ifthe tid -list is pushed-up to node a n  X  1 , then a n  X  1 maintains the occurrence information of the path Z = { a 1 ,a 2 , ..., a n  X  1 } for the same set of transactions in the tid -list without any loss.
 Proof: Based on Property 2, a n maintains the occurrence information of the path Z at least in the transactions in its tid -list. Therefore, the same tid -list at node a n  X  1 exactly maintains the same transaction information for Z without any lose.

Using the features revealed by the above property and lemma, we proceed to construct each prefix-tree starting from the bottom-most item, say i ,ofthePF-list. Only the prefix sub-paths of nodes labeled i in the PF-tree are accumulated as the prefix-tree for i ,say PT i .Since i is the bottom-most item in the PF-list, each node labeled i in the PF-tree must be a tail -node. While constructing the PT i , based on Property 2 we map the tid -list of every node of i to all items in the respective path explicitly in a temporary array (one for each item). It facilitates the periodicity and support calculation for each item in the PF-list of PT i . Moreover, to enable the constructio n of the prefix-tree for the next item in the PF-list, based on Lemma 3 the tid -lists are pushed-up to respective parent nodes in the original PF-tree and in PT i as well. All nodes of i in the PF-tree and i  X  X  entry in the PF-list are deleted thereafter. Figure 4(a) shows the status of the PF-tree of Fig. 3(d) after removing the bottom-most items  X  d  X . Besides, the prefix-tree for  X  d  X , PT d is shown in Fig. 4(b).

The conditional tree CT i for PT i is constructed by removing all non-periodic-frequent nodes from the PT i . If the deleted node is a tail -node, its tid -list is pushed-up to its parent node. Figure 4(c), for instance, shows the conditional tree for  X  d  X , CT d constructed from the PT d of Fig. 4(b). The contents of the temporary array for the bottom item j in the PF-list of CT i represent the T ij (i.e., the set of all tid swhereitems i and j occur together). Therefore, it is rather simple calculation to compute Per ( ij )and Sup ( ij )from T ij by generating P ij . Then the pattern  X  ij  X  is generated as a periodic-frequent pattern with the periodicity and support values of Per ( ij )and Sup ( ij ), respectively. The same process of creating prefix-tree and its corresponding conditional tree is repeated for further extensions of  X  ij  X . The whole process of mining for each item is repeated if PF-list =  X  .

The above bottom-up mining technique on support-descending PF-tree is ef-ficient, because it shrinks the search space dramatically with the progress of mining process. In the next section, we present the experimental results of find-ing periodic-frequent pa tterns from the PF-tree. Since there is no existing approach to discover periodic-frequent patterns, we only investigate PF-tree X  X  performance. All programs are written in Microsoft Visual C++ 6.0 and run with Windows XP on a 2.66 GHz machine with 1GB memory. The runtime specifies the total execution time, i.e., CPU and I/Os. The experiments are pursued on several synthetic ( T10I4D100K )and real datasets ( chess , mushroom ,and kosarak ) respectively developed at IBM Almaden Quest research group ( http://www.almaden.ibm.com/cs/quest )and obtained from UCI Machine Learning Repository (University of California -Irvine, CA). T10I4D100K is a large sparse dataset with 100,000 transactions and 870 distinct items. The dense datasets chess and mushroom contain 3,196 and 8,124 transactions, and 75 and 119 distinct items respectively. In the first experiment, we study the compactness of the PF-tree on different datasets. 5.1 Compactness of the PF-Tree The memory consumptions of PF-tree on the variations of max per and min sup values over several datasets are report ed in Table 2. The first and second columns of the table respectively show the dataset-dependent different max per and min sup values we used in the experiment. The size of the PF-tree is, there-fore, shown in the last three column s for the respective thresholds.

The data in the table demonstrate that, keeping the min sup fixed the mem-ory consumption of PF-tree increases with the increase of max per for almost all of the datasets. In contrast, for fixed max per the tree size becomes smaller with increasing values of min sup . The reason of such threshold-dependent tree size variation is that, more and more patterns become periodic-frequent with the increase of max per and the decrease of min sup values. Therefore, the PF-tree size increases to represent the increasin g pattern set. However, it is clear from the Table 2 that, the structure of the PF-tree can easily be handled in a memory efficient manner irrespective of the dataset type (dense or sparse) or size (large or small) and threshold values. In the next experiment, we show the execution time performance of PF-tree in mining periodic-frequent patterns. 5.2 Execution Time of the PF-Tree The changes on the periodicity and the support thresholds show the similar effect on execution time as of the size of PF-tree structure. Because of the space limitations, we report the results, in Fig. 5, only on T10I4D100K and mushroom datasets. The execution time shown in the graphs encompasses all phases of PF-list and PF-tree constructions, and the corresponding mining operation.
We varied the values of both thresholds as we demonstrated in the previous experiment. It can be noticed from the graphs in Fig. 5 that, for both sparse and dense datasets PF-tree takes similar amount of time for relatively higher support threshold values for the variation of the periodicity thresholds. However, as the support thresholds go down, the gaps become wider. From another point of view, keeping the max per fixed, the execution time incr eases (mainly for higher max per s) with lowering the min sup . The reason of such performance variation is that, for a fixed min sup value the number and the lengths of periodic-frequent patterns increase for higher values of max per .Forafixed max per value, on the other hand, the same effect we get for lower min sup values. In general, when mining for lower min sup and higher max per values, the PF-tree requires more execution time. However, as per as the database size and reasonably high max per and low min sup values are concerned, we see that mining periodic-frequent patterns from the corresponding PF-tree is rather time efficient for both sparse and dense datasets. The scalability study on PF-tree, discussed in the next subsection, also reflects this scenario. 5.3 Scalability of the PF-Tree We study the scalability of our PF-tree on execution time and required mem-ory by varying the number of transactions in database. We use real kosarak dataset for the scalability experiment, since it is a huge sparse dataset with a large number of distinct items (41,270) and transactions (990,002). We divided the dataset into five portions of 0.2 million transactions in each part. Then we investigated the performance of PF-tre e after accumulating each portion with previous parts with performing periodic-frequent pattern mining each time. We fix the max per to 50% and the min sup to 2% of | kosarak | for each experi-ment. The experimental results are shown in Fig. 6. The time and memory in y -axes of the left and right graphs in Fig. 6 respectively specify the total exe-cution time and required memory with the increase of databa se size. It is clear from the graphs that as the database size increases, overall tree construction and mining time, and memory requirement increase. However, PF-tree shows stable performance of about linear increase of runtime and memory consumption with respect to the database size. Therefore, it can be observed from the scalability test that PF-tree can mine the PF TDB over large datasets a nd distinct items with considerable amount of runtime and memory. In this paper, we have introduced a new interesting measure, called temporal periodicity of occurrence behavior, for frequently recurring patterns in transac-tional databases. We have defined such patterns as the periodic-frequent patterns under the user-given periodicity and support thresholds. This paper also shows the significance of discovering such patterns in a wide range of real-world appli-cation areas. We have prov ided the PF-tree, a highly c ompact tree structure to capture the database content, and a pattern growth-based mining technique to discover the complete set of periodic-fre quent patterns on the user-given maxi-mum periodicity and minimum support thresholds over a transactional database. The experimental results demonstrate that our PF-tree can provide the time and memory efficiency during mining the period ic-frequent pattern set. Moreover, it is highly scalable in terms of runtime and memory consumption.

