 Within the area of statistical machine translation, there has been a growing interest in so-called syntax-based translation models, that is, models that de-fine mappings between languages through hierar-chical sentence structures. Several such statistical models that have been investigated in the literature are based on synchronous rewriting or tree transduc-tion. Probabilistic synchronous context-free gram-mars (PSCFGs) are one among the most popular ex-amples of such models. PSCFGs subsume several syntax-based statistical translation models, as for in-stance the stochastic inversion transduction gram-mars of Wu (1997), the statistical model used by the Hiero system of Chiang (2007), and systems which extract rules from parsed text, as in Galley et al. (2004).
 Despite the widespread usage of models related to PSCFGs, our theoretical understanding of this class is quite limited. In contrast to the closely related class of probabilistic context-free grammars, a syn-tax model for which several interesting mathemati-cal and statistical properties have been investigated, as for instance by Chi (1999), many theoretical prob-lems are still unsolved for the class of PSCFGs.
This paper considers a parsing problem that is well understood for probabilistic context-free gram-mars but that has never been investigated in the con-text of PSCFGs, viz. the computation of prefix prob-abilities. In the case of a probabilistic context-free grammar, this problem is defined as follows. We are asked to compute the probability that a sentence generated by our model starts with a prefix string v given as input. This quantity is defined as the (pos-sibly infinite) sum of the probabilities of all strings of the form vw , for any string w over the alphabet of the model. This problem has been studied by Jelinek and Lafferty (1991) and by Stolcke (1995). Prefix probabilities can be used to compute probabil-ity distributions for the next word or part-of-speech. This has applications in incremental processing of text or speech from left to right; see again (Jelinek and Lafferty, 1991). Prefix probabilities can also be exploited in speech understanding systems to score partial hypotheses in beam search (Corazza et al., 1991).

This paper investigates the problem of computing prefix probabilities for PSCFGs. In this context, a pair of strings v 1 and v 2 is given as input, and we are asked to compute the probability that any string in the source language starting with prefix v 1 is trans-lated into any string in the target language starting with prefix v 2 . This probability is more precisely defined as the sum of the probabilities of translation pairs of the form [ v 1 w 1 , v 2 w 2 ] , for any strings w and w 2 .

A special case of prefix probability for PSCFGs is the right prefix probability. This is defined as the probability that some (complete) input string w in the source language is translated into a string in the target language starting with an input prefix v .
Prefix probabilities and right prefix probabilities for PSCFGs can be exploited to compute probabil-ity distributions for the next word or part-of-speech in left-to-right incremental translation, essentially in the same way as described by Jelinek and Lafferty (1991) for probabilistic context-free grammars, as discussed later in this paper.

Our solution to the problem of computing prefix probabilities is formulated in quite different terms from the solutions by Jelinek and Lafferty (1991) and by Stolcke (1995) for probabilistic context-free grammars. In this paper we reduce the computation of prefix probabilities for PSCFGs to the computa-tion of inside probabilities under the same model. Computation of inside probabilities for PSCFGs is a well-known problem that can be solved using off-the-shelf algorithms that extend basic parsing algo-rithms. Our reduction is a novel grammar trans-formation, and the proof of correctness proceeds by fairly conventional techniques from formal lan-guage theory, relying on the correctness of standard methods for the computation of inside probabilities for PSCFG. This contrasts with the techniques pro-posed by Jelinek and Lafferty (1991) and by Stolcke (1995), which are extensions of parsing algorithms for probabilistic context-free grammars, and require considerably more involved proofs of correctness.
Our method for computing the prefix probabili-ties for PSCFGs runs in exponential time, since that is the running time of existing methods for comput-ing the inside probabilities for PSCFGs. It is un-likely this can be improved, because the recogni-tion problem for PSCFG is NP-complete, as estab-lished by Satta and Peserico (2005), and there is a straightforward reduction from the recognition prob-lem for PSCFGs to the problem of computing the prefix probabilities for PSCFGs. In this section we introduce basic definitions re-lated to synchronous context-free grammars and their probabilistic extension; our notation follows Satta and Peserico (2005).

Let N and  X  be sets of nonterminal and terminal symbols, respectively. In what follows we need to represent bijections between the occurrences of non-terminals in two strings over N  X   X  . This is realized by annotating nonterminals with indices from an in-finite set. We define I ( N ) = { A t | A  X  N, t  X  N } and V I = I ( N )  X   X  . For a string  X   X  V  X  I , we write index (  X  ) to denote the set of all indices that appear in symbols in  X  .

Two strings  X  1 ,  X  2  X  V  X  I are synchronous if each index from N occurs at most once in  X  1 and at most once in  X  2 , and index (  X  1 ) = index (  X  2 ) . Therefore  X  ,  X  2 have the general form:  X   X  t 6 = t j for i 6 = j , and  X  is a permutation of the set { 1 , . . . , r } .

A synchronous context-free grammar (SCFG) is a tuple G = ( N,  X , P, S ) , where N and  X  are fi-nite, disjoint sets of nonterminal and terminal sym-bols, respectively, S  X  N is the start symbol and P is a finite set of synchronous rules . Each syn-chronous rule has the form s : [ A 1  X   X  1 , A 2  X   X  ] , where A 1 , A 2  X  N and where  X  1 ,  X  2  X  V  X  I are synchronous strings. The symbol s is the label of the rule, and each rule is uniquely identified by its label. For technical reasons, we allow the existence of multiple rules that are identical apart from their labels. We refer to A 1  X   X  1 and A 2  X   X  2 , respec-tively, as the left and right components of rule s . Example 1 The following synchronous rules im-plicitly define a SCFG: In each step of the derivation process of a SCFG G , two nonterminals with the same index in a pair of synchronous strings are rewritten by a synchronous rule. This is done in such a way that the result is once more a pair of synchronous strings. An auxiliary notion is that of reindexing , which is an injective function f from N to N . We extend f to V I by letting for a  X   X  . We also extend f to strings in V  X  I by letting f (  X  ) =  X  and f ( X X  ) = f ( X ) f (  X  ) , for each X  X  V I and  X   X  V  X  I .

Let  X  1 ,  X  2 be synchronous strings in V  X  I . The de-there exist an index t in index (  X  1 ) = index (  X  2 ) , a synchronous rule s : [ A 1  X   X  1 , A 2  X   X  2 ] in P and some reindexing f such that: (i) index ( f (  X  1 ))  X  ( index (  X  1 ) \ { t } ) =  X  ; (iii)  X  1 =  X  0 1 f (  X  1 )  X  00 1 ,  X  2 =  X  0 2 f (  X  2 )  X  indicate that the derive relation holds through rule s .
Note that  X  1 ,  X  2 above are guaranteed to be syn-chronous strings, because  X  1 and  X  2 are syn-chronous strings and because of (i) above. Note also that, for a given pair [  X  1 ,  X  2 ] of synchronous strings, an index t and a rule s , there may be in-finitely many choices of reindexing f such that the above constraints are satisfied. In this paper we will not further specify the choice of f .

We say the pair [ A 1 , A 2 ] of nonterminals is linked (in G ) if there is a rule of the form s : [ A 1  X   X  , A 2  X   X  2 ] . The set of linked nonterminal pairs is denoted by N [2] .

A derivation is a sequence  X  = s 1 s 2  X   X   X  s d of syn-chronous rules s i  X  P with d  X  0 (  X  =  X  for every i with 1  X  i  X  d and synchronous strings [  X  1 i ,  X  2 i ] with 0  X  i  X  d . Throughout this paper, we always implicitly assume some canonical form for derivations in G , by demanding for instance that each step rewrites a pair of nonterminal occurrences of which the first is leftmost in the left component. When we want to focus on the specific synchronous strings being derived, we also write derivations in [  X  specified. The translation generated by a SCFG G is defined as: T ( G ) = { [ w 1 , w 2 ] | [ S 1 , S 1 ]  X   X  G [ w 1 , w For w 1 , w 2  X   X   X  , we write D ( G, [ w 1 , w 2 ]) to de-note the set of all (canonical) derivations  X  such that
Analogously to standard terminology for context-free grammars, we call a SCFG reduced if ev-ery rule occurs in at least one derivation  X   X  D ( G, [ w 1 , w 2 ]) , for some w 1 , w 2  X   X   X  . We as-sume without loss of generality that the start sym-bol S does not occur in the right-hand side of either component of any rule.
 Example 2 Consider the SCFG G from example 1. The following is a canonical derivation in G , since it is always the leftmost nonterminal occurrence in the left component that is involved in a derivation step: It is not difficult to see that the generated translation The size of a synchronous rule s : [ A 1  X   X  1 , A 2  X   X  2 ] , is defined as | s | = | A 1  X  1 A 2  X  2 | . The size of G is defined as | G | = P s  X  P | s | .
A probabilistic SCFG (PSCFG) is a pair G = ( G, p G ) where G = ( N,  X , P, S ) is a SCFG and p G is a function from P to real numbers in [0 , 1] . We say that G is proper if for each pair [ A 1 , A 2 ]  X  N [2] we have: Intuitively, properness ensures that where a pair of nonterminals in two synchronous strings can be rewritten, there is a probability distribution over the applicable rules.

For a (canonical) derivation  X  = s 1 s 2  X   X   X  s d , we define p G (  X  ) = Q d i =1 p G ( s i ) . For w 1 , w 2  X   X  we also define: We say a PSCFG is consistent if p G defines a prob-ability distribution over the translation, or formally: If the grammar is reduced, proper and consistent, then also: for every pair [ A 1 , A 2 ]  X  N [2] . The proof is identi-cal to that of the corresponding fact for probabilistic context-free grammars. If w = a 1  X   X   X  a n then the expression w [ i, j ] , with 0  X  i  X  j  X  n , denotes the substring a i +1  X   X   X  a j (if i = j then w [ i, j ] =  X  ). In this section, we assume the input is the pair [ w 1 , w 2 ] of terminal strings. The task of a recognizer for SCFG G is to decide whether [ w 1 , w 2 ]  X  T ( G ) .

We present a general algorithm for solving the above problem in terms of the specification of a de-duction system, following Shieber et al. (1995). The items that are constructed by the system have the form [ m 1 , A 1 , m 0 1 ; m 2 , A 2 , m 0 2 ] , where [ A N [2] and where m 1 , m 0 integers such that 0  X  m 1  X  m 0 1  X  | w 1 | and 0  X  m 2  X  m 0 2  X  | w 2 | . Such an item can be de-rived by the deduction system if and only if:
The deduction system has one inference rule, shown in figure 1. One of its side conditions has a synchronous rule in P of the form: Observe that, in the right-hand side of the two rule components above, nonterminals A 1 i and A 2  X   X  1 ( i ) , 1  X  i  X  r , have both the same index. More pre-with i 0 =  X  (  X   X  1 ( i )) = i . Thus the nonterminals in each antecedent item in figure 1 form a linked pair.
We now turn to a computational analysis of the above algorithm. In the inference rule in figure 1 there are 2( r + 1) variables that can be bound to positions in w 1 , and as many that can be bound to positions in w 2 . However, the side conditions imply m ij = m ij + | u ij | , for i  X  { 1 , 2 } and 0  X  j  X  r , and therefore the number of free variables is only r + 1 for each component. By standard complex-ity analysis of deduction systems, for example fol-lowing McAllester (2002), the time complexity of a straightforward implementation of the recogni-tion algorithm is O ( | P |  X  | w 1 | r max +1  X  | w 2 | r where r max is the maximum number of right-hand side nonterminals in either component of a syn-chronous rule. The algorithm therefore runs in ex-ponential time, when the grammar G is considered as part of the input. Such computational behavior seems unavoidable, since the recognition problem for SCFG is NP-complete, as reported by Satta and Peserico (2005). See also Gildea and Stefankovic (2007) and Hopkins and Langmead (2010) for fur-ther analysis of the upper bound above.

The recognition algorithm above can easily be turned into a parsing algorithm by letting an imple-mentation keep track of which items were derived from which other items, as instantiations of the con-sequent and the antecedents, respectively, of the in-ference rule in figure 1.

A probabilistic parsing algorithm that computes p
G ([ w 1 , w 2 ]) , defined in (1), can also be obtained from the recognition algorithm above, by associat-ing each item with a probability. To explain the ba-sic idea, let us first assume that each item can be inferred in finitely many ways by the inference rule in figure 1. Each instantiation of the inference rule should be associated with a term that is computed by multiplying the probability of the involved rule s and the product of all probabilities previously as-sociated with the instantiations of the antecedents. The probability associated with an item is then computed as the sum of each term resulting from some instantiation of an inference rule deriving that item. This is a generalization to PSCFG of the in-side algorithm defined for probabilistic context-free grammars (Manning and Sch  X  utze, 1999), and we can show that the probability associated with item p
G ([ w 1 , w 2 ]) . We refer to the procedure sketched above as the inside algorithm for PSCFGs.

However, this simple procedure fails if there are cyclic dependencies, whereby the derivation of an item involves a proper subderivation of the same item. Cyclic dependencies can be excluded if it can ]  X   X   X   X   X   X   X   X   X   X   X   X   X   X   X  be guaranteed that, in figure 1, m 0 1 r  X  m 10 is greater than m 1 j  X  m 0 1 j  X  1 for each j ( 1  X  j  X  r ), or m 2 r  X  m 20 is greater than m 2 j  X  m j ( 1  X  j  X  r ).

Consider again a synchronous rule s of the form in (2). We say s is an epsilon rule if r = 0 and u 10 = u 20 = . We say s is a unit rule if r = 1 and u 10 = u 11 = u 20 = u 21 = . Similarly to context-free grammars, absence of epsilon rules and unit rules guarantees that there are no cyclic depen-dencies between items and in this case the inside al-gorithm correctly computes p G ([ w 1 , w 2 ]) .
Epsilon rules can be eliminated from PSCFGs by a grammar transformation that is very similar to the transformation eliminating epsilon rules from a probabilistic context-free grammar (Abney et al., 1999). This is sketched in what follows. We first compute the set of all nullable linked pairs of non-terminals of the underlying SCFG, that is, the set of all [ A 1 , A 2 ]  X  N [2] such that [ A 1 1 , A 1 2 ]  X   X  This can be done in linear time O ( | G | ) using essen-tially the same algorithm that identifies nullable non-terminals in a context-free grammar, as presented for instance by Sippu and Soisalon-Soininen (1988).
Next, we identify all occurrences of nullable pairs [ A 1 , A 2 ] in the right-hand side components of a rule s , such that A 1 and A 2 have the same index. For every possible choice of a subset U of these occur-rences, we add to our grammar a new rule s U con-structed by omitting all of the nullable occurrences in U . The probability of s U is computed as the prob-ability of s multiplied by terms of the form: for every pair [ A 1 , A 2 ] in U . After adding these extra rules, which in effect circumvents the use of epsilon-generating subderivations, we can safely remove all epsilon rules, with the only exception of a possible rule of the form [ S  X  , S  X  ] . The translation and the associated probability distribution in the result-ing grammar will be the same as those in the source grammar.

One problem with the above construction is that we have to create new synchronous rules s U for each possible choice of subset U . In the worst case, this may result in an exponential blow-up of the source grammar. In the case of context-free grammars, this is usually circumvented by casting the rules in bi-nary form prior to epsilon rule elimination. How-ever, this is not possible in our case, since SCFGs do not allow normal forms with a constant bound on the length of the right-hand side of each compo-nent. This follows from a result due to Aho and Ull-man (1969) for a formalism called syntax directed translation schemata, which is a syntactic variant of SCFGs.

An additional complication with our construction is that finding any of the values in (3) may involve solving a system of non-linear equations, similarly to the case of probabilistic context-free grammars; see again Abney et al. (1999), and Stolcke (1995). Approximate solution of such systems might take exponential time, as pointed out by Kiefer et al. (2007).

Notwithstanding the worst cases mentioned above, there is a special case that can be easily dealt with. Assume that, for each nullable pair [ A 1 , A 2 ] in hold for any w 1 and w 2 with w 1 6 =  X  or w 2 6 =  X  . Then each of the values in (3) is guaranteed to be 1 , and furthermore we can remove the instances of the nullable pairs in the source rule s all at the same time. This means that the overall construction of elimination of nullable rules from G can be imple-mented in linear time | G | . It is this special case that we will encounter in section 4.

After elimination of epsilon rules, one can elimi-nate unit rules. We define C unit ([ A 1 , A 2 ] , [ B 1 , B as the sum of the probabilities of all derivations de-or more precisely: Note that [ A 1 , A 2 ] may be equal to [ B 1 , B 2 ] and  X  may be  X  , in which case C unit ([ A 1 , A 2 ] , [ B 1 , B at least 1 , but it may be larger if there are unit rules. seen as a probability.

Consider a pair [ A 1 , A 2 ]  X  N [2] and let all unit rules with left-hand sides A 1 and A 2 be: The values of C unit (  X  ,  X  ) are related by the following: where  X  ([ A 1 , A 2 ] = [ B 1 , B 2 ]) is defined to be 1 if [ A 1 , A 2 ] = [ B 1 , B 2 ] and 0 otherwise. This forms a system of linear equations in the unknown variables C unit (  X  ,  X  ) . Such a system can be solved in polyno-mial time in the number of variables, for example using Gaussian elimination.

The elimination of unit rules starts with adding a rule s 0 : [ A 1  X   X  1 , A 2  X   X  2 ] for each non-unit rule s : [ B 1  X   X  1 , B 2  X   X  2 ] and pair [ A We assign to the new rule s 0 the probability p G ( s )  X  C unit ([ A 1 , A 2 ] , [ B 1 , B 2 ]) . The unit rules can now be removed from the grammar. Again, in the re-sulting grammar the translation and the associated probability distribution will be the same as those in the source grammar. The new grammar has size O ( | G | 2 ) , where G is the input grammar. The time complexity is dominated by the computation of the solution of the linear system of equations. This com-putation takes cubic time in the number of variables. The number of variables in this case is O ( | G | 2 ) , which makes the running time O ( | G | 6 ) . The joint prefix probability p prefix G ([ v 1 , v 2 ]) of a pair [ v 1 , v 2 ] of terminal strings is the sum of the probabilities of all pairs of strings that have v 1 and v , respectively, as their prefixes. Formally: At first sight, it is not clear this quantity can be ef-fectively computed, as it involves a sum over in-finitely many choices of w 1 and w 2 . However, anal-ogously to the case of context-free prefix probabili-ties (Jelinek and Lafferty, 1991), we can isolate two parts in the computation. One part involves infinite sums, which are independent of the input strings v 1 and v 2 , and can be precomputed by solving a sys-tem of linear equations. The second part does rely on v 1 and v 2 , and involves the actual evaluation of p
G ([ v 1 , v 2 ]) . This second part can be realized effectively, on the basis of the precomputed values from the first part.

In order to keep the presentation simple, and to allow for simple proofs of correctness, we solve the problem in a modular fashion. First, we present a transformation from a PSCFG G = ( G, p G ) , with G = ( N,  X , P, S ) , to a ( N prefix ,  X , P prefix , S  X  ) . The latter grammar derives all possible pairs [ v 1 , v 2 ] such that [ v 1 w 1 , v 2 be derived from G , for some w 1 and w 2 . Moreover, p fied later.

Computing p G generic probabilistic parsing algorithm for PSCFGs is difficult, due to the presence of epsilon rules and unit rules. The next step will be to transform G prefix into a third grammar G 0 prefix by eliminating epsilon rules and unit rules from the underlying SCFG, and preserving the probability distribution over pairs of strings. Using G 0 prefix one can then effectively apply generic probabilistic parsing algorithms for PSCFGs, such as the inside algorithm discussed in section 3, in order to compute the desired prefix probabilities for the source PSCFG G .

For each nonterminal A in the source SCFG G , the grammar G prefix contains three nonterminals, namely A itself, A  X  and A  X  . The meaning of A re-mains unchanged, whereas A  X  is intended to gen-erate a string that is a suffix of a known prefix v 1 or v . Nonterminals A  X  generate only the empty string, and are used to simulate the generation by G of in-fixes of the unknown suffix w 1 or w 2 . The two left-hand sides of a synchronous rule in G prefix can con-tain different combinations of nonterminals of the forms A , A  X  , or A  X  . The start symbol of G prefix is S  X  . The structure of the rules from the source gram-mar is largely retained, except that some terminal symbols are omitted in order to obtain the intended interpretation of A  X  and A  X  .

In more detail, let us consider a synchronous rule s : [ A 1  X   X  1 , A 2  X   X  2 ] from the source gram-mar, where for i  X  { 1 , 2 } we have: The transformed grammar then contains a large number of rules, each of which is of the form s 0 : [ B 1  X   X  1 , B 2  X   X  2 ] , where B i  X   X  i is of one of three forms, namely A i  X   X  i , A  X  i  X   X   X  i or A  X  i  X   X   X  i , where  X   X  i and  X   X  i are explained below. The choices for i = 1 and for i = 2 are independent, so that we can have 3  X  3 = 9 kinds of synchronous rules, to be further subdivided in what follows. A unique label s 0 is produced for each new rule, and the probability of each new rule equals that of s .
The right-hand side  X   X  i is constructed by omitting all terminals and propagating downwards the  X  su-perscript, resulting in:
It is more difficult to define  X   X  i . In fact, there can be a number of choices for  X   X  i and, for each choice, the transformed grammar contains an instance of the synchronous rule s 0 : [ B 1  X   X  1 , B 2  X   X  2 ] as de-fined above. The reason why different choices need to be considered is because the boundary between the known prefix v i and the unknown suffix w i can occur at different positions, either within a terminal string u ij or else further down in a subderivation in-volving A ij . In the first case, we have for some j ( 0  X  j  X  r ): where u 0 ij is a choice of a prefix of u ij . In words, the known prefix ends after u 0 ij and, thereafter, no more terminals are generated. We demand that u 0 ij must not be the empty string, unless A i = S and j = 0 . The reason for this restriction is that we want to avoid an overlap with the second case. In this second case, we have for some j ( 1  X  j  X  r ): Here the known prefix of the input ends within a sub-derivation involving A ij , and further to the right no more terminals are generated.
 Example 3 Consider the synchronous rule s : [ A  X  a B 1 bc C 2 d, D  X  ef E 2 F 1 ] . The first component of a synchronous rule derived from this can be one of the following eight: The second component can be one of the following six: In total, the transformed grammar will contain 8  X  6 = 48 synchronous rules derived from s . 2
For each synchronous rule s , the above gram-mar transformation produces O ( | s | ) left rule com-ponents and as many right rule components. This means the number of new synchronous rules is we sum O ( | s | 3 ) for every rule s we obtain a time and space complexity of O ( | G | 3 ) .

We now investigate formal properties of our grammar transformation, in order to relate it to pre-fix probabilities. We define the relation ` between P and P prefix such that s ` s 0 if and only if s 0 was ob-tained from s by the transformation described above. This is extended in a natural way to derivations, such that s 1  X   X   X  s d ` s 0 1  X   X   X  s 0 d 0 if and only if d = d s ` s 0 i for each i ( 1  X  i  X  d ).

The formal relation between G and G prefix is re-vealed by the following two lemmas.
 Lemma 1 For each v 1 , v 2 , w 1 , w 2  X   X   X  and is a unique  X  0  X  P  X  prefix such that [ S  X  , S  X  ]  X   X  0 [ v 1 , v 2 ] and  X  `  X  Lemma 2 For each v 1 , v 2  X   X   X  and derivation  X  there is a unique  X   X  P  X  and unique w 1 , w 2  X   X   X  such that [ S, S ]  X   X  G [ v 1 w 1 , v 2 w 2 ] and  X  `  X  0 The only non-trivial issue in the proof of Lemma 1 is the uniqueness of  X  0 . This follows from the obser-vation that the length of v 1 in v 1 w 1 uniquely deter-mines how occurrences of left components of rules in P found in  X  are mapped to occurrences of left components of rules in P prefix found in  X  0 . The same applies to the length of v 2 in v 2 w 2 and the right com-ponents.

Lemma 2 is easy to prove as the structure of the transformation ensures that the terminals that are in rules from P but not in the corresponding rules from P prefix occur at the end of a string v 1 (and v 2 ) to form the longer string v 1 w 1 (and v 2 w 2 , respectively).
The transformation also ensures that s ` s 0 im-plies p G ( s ) = p G p we may conclude: Theorem 1 p G
Because of the introduction of rules with left-hand sides of the form A  X  in both the left and right compo-nents of synchronous rules, it is not straightforward to do effective probabilistic parsing with the gram-mar G prefix . We can however apply the transforma-tions from section 3 to eliminate epsilon rules and thereafter eliminate unit rules, in a way that leaves the derived string pairs and their probabilities un-changed.

The simplest case is when the source grammar G is reduced, proper and consistent, and has no epsilon rules. The only nullable pairs of nonterminals in G prefix will then be of the form [ A  X  1 , A  X  2 ] . Consider such a pair [ A  X  1 , A  X  2 ] . Because of reduction, proper-ness and consistency of G we have: Because of the structure of the grammar transforma-tion by which G prefix was obtained from G , we also have: Therefore pairs of occurrences of A  X  1 and A  X  2 with the same index in synchronous rules of G prefix can be systematically removed without affecting the probability of the resulting rule, as outlined in sec-tion 3. Thereafter, unit rules can be removed to allow parsing by the inside algorithm for PSCFGs.

Following the computational analyses for all of the constructions presented in section 3, and for the grammar transformation discussed in this section, we can conclude that the running time of the pro-posed algorithm for the computation of prefix prob-abilities is dominated by the running time of the in-side algorithm, which in the worst case is exponen-tial in | G | . This result is not unexpected, as already pointed out in the introduction, since the recogni-tion problem for PSCFGs is NP-complete, as estab-lished by Satta and Peserico (2005), and there is a straightforward reduction from the recognition prob-lem for PSCFGs to the problem of computing the prefix probabilities for PSCFGs.
One should add that, in real world machine trans-lation applications, it has been observed that recog-nition (and computation of inside probabilities) for SCFGs can typically be carried out in low-degree polynomial time, and the worst cases mentioned above are not observed with real data. Further dis-cussion on this issue is due to Zhang et al. (2006). We have shown that the computation of joint prefix probabilities for PSCFGs can be reduced to the com-putation of inside probabilities for the same model. Our reduction relies on a novel grammar transfor-mation, followed by elimination of epsilon rules and unit rules.

Next to the joint prefix probability, we can also consider the right prefix probability , which is de-fined by: In words, the entire left string is given, along with a prefix of the right string, and the task is to sum the probabilities of all string pairs for different suffixes following the given right prefix. This can be com-puted as a special case of the joint prefix probability. Concretely, one can extend the input and the gram-mar by introducing an end-of-sentence marker $ . Let G 0 be the underlying SCFG grammar after the extension. Then:
Prefix probabilities and right prefix probabilities for PSCFGs can be exploited to compute probability distributions for the next word or part-of-speech in left-to-right incremental translation of speech, or al-ternatively as a predictive tool in applications of in-teractive machine translation, of the kind described by Foster et al. (2002). We provide some technical details here, generalizing to PSCFGs the approach by Jelinek and Lafferty (1991).

Let G = ( G, p G ) be a PSCFG, with  X  the alpha-bet of terminal symbols. We are interested in the probability that the next terminal in the target trans-lation is a  X   X  , after having processed a prefix v 1 of the source sentence and having produced a prefix v 2 of the target translation. This can be computed as:
Two considerations are relevant when applying the above formula in practice. First, the computa-scratch if p prefix G ([ v 1 , v 2 ]) has been computed al-ready. Because of the tabular nature of the inside al-gorithm, one can extend the table for p prefix G ([ v 1 , v by adding new entries to obtain the table for p
G ([ v 1 , v 2 a ]) . The same holds for the compu-tation of p prefix G ([ v 1 b, v 2 ]) .

Secondly, the computation of p prefix G ([ v 1 , v 2 a ]) for all possible a  X   X  may be impractical. However, one may also compute the probability that the next part-of-speech in the target translation is A . This can be realised by adding a rule s 0 : [ B  X  b, A  X  c A ] for each rule s : [ B  X  b, A  X  a ] from the source grammar, where A is a nonterminal representing a part-of-speech and c A is a (pre-)terminal specific to A . The probability of s 0 is the same as that of s . If G 0 is the underlying SCFG after adding such rules, then the required value is p prefix G 0 ([ v 1 , v 2 c A ]) .
One variant of the definitions presented in this pa-per is the notion of infix probability, which is use-ful in island-driven speech translation. Here we are interested in the probability that any string in the source language with infix v 1 is translated into any string in the target language with infix v 2 . However, just as infix probabilities are difficult to compute for probabilistic context-free grammars (Corazza et al., 1991; Nederhof and Satta, 2008) so (joint) infix probabilities are difficult to compute for PSCFGs. The problem lies in the possibility that a given in-fix may occur more than once in a string in the lan-guage. The computation of infix probabilities can be reduced to that of solving non-linear systems of equations, which can be approximated using for in-stance Newton X  X  algorithm. However, such a system of equations is built from the input strings, which en-tails that the computational effort of solving the sys-tem primarily affects parse time rather than parser-generation time.
