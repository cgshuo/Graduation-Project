
The discovery of sequential patterns is a complicated issue in data mining (Agrawal 1995; Bettini 1998; Garofalakis 1999; Mannila 1997; Pei 2002a; Rolland 2001; Sri-kant 1996; Tsoukatos 2001; Wang 1997; Zaki 2000, 2001). A typical example is a re-called data sequence . A data sequence is composed of all the customer X  X  transactions dicating the set of items (called itemset ) purchased in the trans action. The objective database.

The issue of mining sequential patterns with time constraints was first addressed in Srikant (1996). Three time constraints, including minimum gap, maximum gap and sliding time window, are specified to enhance conventional sequence discovery.
For example, without time constraints, one may find a pattern
However, the pattern could be insignificant if the time interval between ( a , f ) is too long. Such patterns could be filtered out if the maximum gap constraint is specified.

Analogously, one might discover the pattern &lt; ( b patterns, i.e. the minimum gap of 7 days. In other words, the sale of not trigger the sale of ( a , g ) in the next week. Therefore, time constraints including maximum gap and minimum gap should be incorporated in the mining to reinforce the accuracy and signifi cance of mining results.

Moreover, conventional definition of an element of a sequential pattern is too rigid instance, given a sliding time window of 5, a data sequence support the pattern &lt; (a,b,d)(c) &gt; if the difference between time t an element will broaden the applications of sequential patterns.
Although there are many algorithms dealing with sequential pattern mining (Agra-wal 1995; Guralnik 2001; Lin 2002; Masseglia 1998; Oates 1997; Roddick 2002;
Zaki 2001), few handle the mining with the addition of time constraints. GSP (gener-check whether a data sequence contains a certain candidate, GSP transforms each data sequence into items X  transaction-time lists. The transformation speeds up time-constraint-related testing but introduces overheads during each database scanning.
Recent studies indicate that pattern-g rowth methodology could speed up sequence mining. Despite many studies on sequential pattern mining within the pattern-growth methodology (Han 2000; Lin 2002; Pei 2001, 2002a, 2002b; Pinto 2001), no algo-found in the literature (except in the GSP context). In this paper, we propose a new time constraints on sequential patterns, introduced in the context of GSP , within the pattern-growth framework. DELISP solves the problem by recursively growing valid patterns in projected subdatabases generat ed by subsequence projection. To acceler-the projection to delimit the counting and growing of sequences. In DELISP ,the bounded projection technique eliminates invalid subsequence projections caused by unqualified maximum/minimum gaps, the windowed projection technique reduces re-
The conducted experiments show that DELISP outperforms GSP . The scale-up ex-periments also indicate that DELISP has good linear scalability with the number of data sequences.
 and review some related work in Sect. 3. Section 4 presents the DELISP algorithm. improving factors in Sect. 6. Section 7 concludes our study.
Let  X  ={  X  1 , X  2 ,... , X  n } be a set of literals, called items .An itemset I  X  ) is a nonempty set of q items such that I  X   X  .A sequence s , denoted by &lt; e 1 e 2 ... e w &gt; , is an ordered list of w elements , where each element e the elements in s . Sequence s is a k-sequence if | s |= &lt; (a,c)(a) &gt; and &lt; (b)(a,e) &gt; are all 3-sequences.
 having a unique identifier sid is represented by sid element e i  X  occurred at time t i , t 1 &lt; t 2 &lt; ... &lt; to mine the database DB :(1) minsup ( min imum sup port), (2) mingap ( min imum time gap ), (3) maxgap ( max imum time gap )and(4) swin ( s liding time-win dow).
Given minsup , the three constraints mingap , maxgap , swin , and the database DB , sequential patterns satisfying the three time constraints.
 s.sup is the support of the sequence s and minsup is the user-specified minimum-support threshold. The support of s is the number of data sequences containing s divided by | DB | . A data sequence ds = sid /&lt; t a sequence s = &lt; e 1 e 2 ... e w &gt; if there exist integers l 1  X  l hold: (1) e i  X  ( e l i  X   X  ...  X  e u i  X  ), 1  X  i  X  w ,(2) t (3) t u i  X  t l i  X  1  X  maxgap , 2  X  i  X  w and (4) t l i  X  that t j , mingap , maxgap and swin are all positive integers, mingap and swin can be zero, and mingap &lt; maxgap . Figure 1 visualizes how a data sequence ds may contain the sequence s .

Given mingap = 2, maxgap = 30, swin = 2, C 1 contains &lt; but it does not contain either &lt; (c)(b) &gt; or &lt; (c)(f ) larly, C 2 /&lt; 2 (b) 4 (d) &gt; does not contain &lt; mingap . Sequence &lt; (a)(b) &gt; is contained in C 3
C 5 /&lt; 1 ( a ,b,e) 4 (e) 7 (f ) 8 (d) 9 ( b ) &gt; ,sothat
C 4 /&lt; 2 (a) 4 (d) 30 (f ) 33 (a) 61 (f ) &gt; may contain tain &lt; (b,d,f ) &gt; (9  X  7  X  2). Given minsup = 40%, both time-constrained sequential patterns while &lt; (b,d,f ) &gt; of all sequential patterns.
Much research has been focused in sequence mining without time constraints of min-gap , maxgap and swin (Agrawal 1995; Ayres 2002; Han 2000; Lin 1998, 2002; Pei 2001; Shintani 1998; Zaki 2001). The GSP algorithm is the first algorithm that han-dles the time constraints in sequential patterns (Srikant 1996). Based on the Apriori every database scan, each data sequence is tra nsformed into items X  time lists for fast of an element (may comprise several transactions) mus t be considered, GSP defines contiguous subsequence for candidate ge neration and moves between the forward phase and backward phase for checking whether a data sequence contains a certain candidate (Srikant 1996).

A general pattern-growth framework was presented in Pei (2002b) for constraint-gate , regular expression , duration and gap constraints were covered. Among these constraints, duration and gap constraints are tightly coupled with the support count-nally classifying constraints by their roles in mining, monotonic , antimonotonic and succinct constraints, were characterised and the prefix-monotone constraint was in-troduced (Pei 2002b). The prefix-growth framework, which pushes prefix-monotone constraints into PrefixSpan was also proposed in Pei (2002b). However, with respect to time constraints, prefix-growth only mentioned maxgap and mingap (though du-ration was addressed) with no implementation details and swin was not considered at all.
 cal database layout, where data sequences are transformed into items X  (sequence-id, time-id) lists. The cSPADE algorithm checks mingap and maxgap while doing tem-possible for cSPADE to handle constraints like maxgap / mingap by expanding the id does not appear feasible to incorporate swin .The swin constraint was not mentioned in cSPADE .
 mingap / maxgap constraints, are discovered by the introduced timed automaton with granularities (Bettini 1998). Nevertheless, we are interested in the discovery of time-constrained sequential patterns built from itemsets. In Sect. 4.1, we introduce the terminology used in the proposed DELISP algorithm. describes the proposed algorithm. For convenience, we refer to a data sequence ds sid /&lt;
Definition 1 (Frequent item). An item x is called a frequent item in a sequence database DB if &lt;( x )&gt; . sup  X  minsup .

Definition 2 (Stem, type-1 growth, type-2 growth, prefix). Given a sequential pat-tern  X  and a frequent item x in the sequence database DB , x is called the stem item (abbreviated as stem ) of the sequential pattern  X  if  X  can be formed by (1) append-ing ( x ) as a new element to  X  or (2) extending the last element of formation of  X  is a type-1 growth if it is formed by appending growth if it is formed by extending with x .The prefix pattern (abbreviated as prefix ) of  X  is  X  .
 growth &lt;( a )( b )&gt; by appending ( b ) to &lt;( a )&gt; &lt;( a )( b )&gt; and &lt;( a , b )&gt; .Astoa type-2 growth &lt;( and its stem is d . Note that the null sequence, denoted by frequent 1-sequence.
 rence of itemset I in ds is marked in the projected database. If itemset I is contained breviated as et ) pair st : et is marked as t  X  : t  X  .If I is contained in e list of I in ds , which is denoted by [st 1 :et 1 ,st 2 1  X  i  X  k ,st i &lt; st i + 1 and et i &lt; et i + 1 for 1  X 
Definition 4 (Accessible). Let the tag list of itemset I in ds be [st st :et k ]. An element e a  X  X s accessible from I in ds if its time stamp t (1) et i  X  swin  X  t a  X  st i + swin ,where i  X  X  1 , 2 ,..., st + maxgap ,where i  X  X  1 , 2 ,... , k } ,or(3) t t is the time stamp of an accessible element e b  X  from I in ds .
Figure 2 demonstrates the three accessibl e circumstances. Note that, when an checked on not violating mingap or maxgap constraints with respect to the previous having time stamps satisfying the mingap / maxgap constraint with I illustration.

Lemma 1. Let ds contain the nonnull prefix  X  = &lt; e 1 of e p in ds , a frequent item x in an element e a  X  X n ds can be a stem only if e accessible from e p in ds .
 items in an accessible element from projection using Lemma 2, as depicted in Fig. 4.
Lemma 2. Let the last element in prefix  X  be e p , the last item in e the tag list of e p in ds be [st 1 :et 1 , st 2 :et 2 ,..., element e a  X  cannot be a stem if (1) x  X  x and (2) satisfying et 1  X  swin  X  t a  X  et 1 .
 ents. Any item to be used as a stem for the type-2 growth having prefix have an order greater than the order of the last item in x (located in t a e a  X , et 1  X  swin  X  t a  X  et 1 ) need not be projected.
All the time-constrained sequential patterns are found by growing frequent sequences from size one to the maximum size. Frequent items in DB can be determined after scanning DB once. We then use each frequent item as a stem with prefix then projected into related subdatabases for further growing. The stems of type-1 and type-2 growth can be determined by scanning the subdatabases once. Recursively, the time-constraint integrated projection and growing techniques are applied to discover the frequent 2-sequences, 3-sequences, etc.

Example 1. Given minsup = 40%, mingap = 2, maxgap = 30, swin
DB as shown in Table 1, DELISP mines the patterns by the following steps.
Step 1. Find frequent items. By scanning DB once, we have frequent items a (count = 3 for appearing in 3 data sequences C 3 , c ( count = 2 ) , d ( count = 4 ) and f ( count = 4 ) . Nonfrequent item e is omitted from mining afterward. The five items are stems of type-1 growth, having prefix
Step 2. Project corresponding subsequences to subdatabases. Considering the time-constrained sequential patterns having prefix  X  = &lt; having item x in DB . While projecting a data sequence ds into nonfrequent items, those inaccessible elements (using Lemma 1) and those lexico-graphically smaller items (using Lemma 2). We tabulate the subdatabases &lt; (b) &gt; -DB , &lt; (c) &gt; -DB , &lt; (d) &gt; -DB and
Step 3. Mine each subdatabase for the subsets of time-constrained sequential patterns. In each subdatabase, we grow the patterns in each sequence according to the time constraints and determine which pattern is a valid time-constrained sequen-tial pattern. Assume that we are growing patterns from prefix element is e p and the tag list of e p in ds is [st 1 : et potential type-1 growth come from the accessible e a , of which time stamp t ing et i + mingap &lt; t a  X  st i + maxgap ,where i  X  X  1 , type-2 growth come from the accessible e a satisfying et where i  X  X  1 , 2 ,..., k } . We may obtain the occurrence counts (i.e. supports) of stems after scanning  X  -DB once. Recursively, we then generate the corresponding (having prefix  X  ) for each stem having sufficient support count.
Step 4. Find all patterns by applying step 2 and step 3 on the subdatabases recursively. Considering the time-constrained sequential patterns having prefix &lt; (a)(b) &gt; , each can be found in the subdatabase (named projecting all the data sequences having (b) in &lt; nonfrequent items, those inaccessible elements (using Lemma 1), and those lexico-graphically smaller items (using Lemma 2). The projected subdatabases of DB are shown in part 2 of Table 2.
 &lt;( b )&gt; ,on &lt;( c )&gt; -DB for patterns having prefix constraints.
Figure 5 presents the proposed DELISP algorithm. DELISP decomposes the mining growth , are subjected to mingap and maxgap . Therefore, we perform type-1 growth with items in each element t a e a within range (et where i  X  X  1 , 2 ,... , k } , and type-2 growth with items in each element range (et i  X  swin  X  t a  X  st i + swin ), where i  X  X  1 , 2 st : et type-2 growth, called windowed-projection . We always add a new item (in e type-2 growth.

Theorem 1. Algorithm DELSIP discovers the set of all time-constrained sequential patterns.

Clearly, a frequent k -sequence is formed by either a type-1 growth or a type-2 growth patterns can be obtained by type-1 and type-2 growth , from size one to the maximum erwise, the corresponding growth would violate either swin or the mingap constraint. In Subroutine ProjectDB , by Lemma 1 and Lemma 2, those inaccess-the supports of time-constraint-satisfied items for type-1 and type-2 growth, respec-tively. By recursively applying ProjectDB and Mine , DELISP discovers the set of all time-constrained sequential patterns.
Extensive experiments were conducted to assess the performance of the DELISP algorithm. We compared th e total execution times of DELISP and GSP (Srikant 1996) by varying the parameters of mingap , maxgap and swin . The scalability were performed on an 866-MHz Pentium-III PC with 1024 MB memory running the Windows NT.
 considered. However, note that, for gap constraints ( mingap and maxgap ), Prefix-database. Nevertheless, such an extension cannot be applied for swin .The prefix periments.

The cSPADE algorithm (Zaki 2000), though it accepts mingap and maxgap con-layout. Additional storage space and computa tion time are required to transform the not handled in cSPADE . Revision of cSPADE to handle the swin constraint is not trivial. One possible implementation is to incorporate swin by incrementing the sup-join. For example, joining the id list of item x with that of item y ,evenwhen their time stamps are not equal, now might generate itemset mingap .
 2000; Lin 1998, 2002; Pei 2001; Zaki 2001), synthetic datasets were used and were generated using the procedure described in Srikant (1996) for these experiments. The transaction IDs were used to represent the transaction times. Table 3 shows the mean-
The execution times of GSP and DELISP in mining time-constrained sequential pat-terns are compared. In these experiments, DELISP is about 3 times faster than GSP .
Various values of minsup , mingap , maxgap and swin are used. Note that the mining of sequential patterns without time constraints is a special case with mingap maxgap = X  and swin = 0 here. The results of varying minsup (2%, 1.5%, 1%, 0.75%, 0.5%) are consistent. We set the minsup to 0.75% and focus on the compar-isons of varying time constraints in the following.
 execution time decreases. The total execution time of GSP is 2.8 to 3.3 ( mingap = 8 ) times than that of DELISP . It shows that DELISP removes more inaccessible elements with larger mingap .
 sequential patterns will decrease when the maxgap value increases because larger maxgap restricts more data sequences to contain certain patterns. In Fig. 7, the line depicting the execution time of GSP starts to fall steeply at maxgap the sample sequences have 4 transactions ( | S |= 4) on average. Note that GSP runs slightly faster without constraints (673 seconds) than with maxgap most checks eventually are useless and introduce overheads. DELISP consistently outperforms GSP , from 2.9 ( maxgap = 12 ) down to 1.4 ( maxgap experiments.
 creased swin .When swin = 0, it took GSP 673 seconds and DELISP 238 seconds or the discovery. To mine the additional patterns that appeared with swin performance when constraint swin is increased. Both algorithms scale up with the increased swin ; DELISP performs better.

To evaluate the performance with respect to datasets of different characteris-in Fig. 9, demonstrate that DELISP consistently outperforms GSP for various data characteristics.

The effects of varying the three constrai nts on performance are summarized be-low. With respect to mingap , GSP effectively prunes the candidates utilizing the antimonotonic property of candidate generation. For instance, if mingap to effectively remove the inaccessible items within the pattern-growth frame-work. Both DELISP and GSP can effectively handle the mining with mingap , while DELISP is at least two times faster than GSP .
 number of candidates increases when maxgap is used because we can no longer prune noncontiguous subsequences (Srikant 1996). The time for the containment test reducing the number of candidates that need to be checked against a data sequence when the user specifies a larger swin .

However, DELISP effectively handles the three c onstraints by integrating them in sequence projecting and growing within the pattern-growth framework. Thus, the performance difference between DELISP and GSP increases when maxgap or swin increases. are normalized with respect to the execution time for increases to a very large size, like 800 K or 1,000 K, and the average number of items which incurs larger overhead in disk accessi ng. As indicated in Fig. 10, the execution time ratio scaled up sublinearly. The execution time for maxgap is 271 seconds, and that for maxgap = 8 , swin = 2 is 304 seconds. with GSP below.  X 
No candidate generation. DELISP generates no candidates and saves the time for not only candidate generation but also candidate testing. Such an advantage is shared by all pattern-g rowth approaches, like PrefixSpan or prefix-growth .  X 
Focused search. DELISP searches and grows longer patterns in the smaller, promising subspace. Nevertheless, GSP takes every data sequence (the entire se-quence) for support calculation in each pass.  X 
Constraint integration. GSP suffers from maxgap , as candidate pruning is less restrictive. For instance, given a maxgap constraint, a data sequence that supports candidate ( a )( e )( f ) may not contain candidate ( a  X  Containment checking and sequence shrinking. In each pass, GSP transforms no candidate generation and focused search. However, DELISP eliminates the need for switching between forward and backward phases of GSP by extending concur-bidirectional growth) by ext ending pattern elements according to lexicographic order. of time-constrained sequential patterns.
We have presented the DELISP algorithm to provide the full functionality of the clas-sic GSP algorithm in terms of time constraints. The conducted experiments confirm that, with good scalability, DELISP outperforms GSP .
 age for the projected subdatabases while mining. Future improvements may include optimizations on disk projection. It is also interesting to extend the approach to deal with other time constraints, like overall time span (Pei 2002b; Zaki 2000) and vari-ous constraints (Garofalakis 1999; Mannila 1997; Pei 2002b; Zaki 2000) for effective and efficient sequential pattern mining.

