 YouTube represents one of the largest scale and most sophis-ticated industrial recommendation systems in existence. In this paper, we describe the system at a high level and fo-cus on the dramatic performance improvements brought by deep learning. The paper is split according to the classic two-stage information retrieval dichotomy: first, we detail a deep candidate generation model and then describe a sepa-rate deep ranking model. We also provide practical lessons and insights derived from designing, iterating and maintain-ing a massive recommendation system with enormous user-facing impact.
 recommender system; deep learning; scalability
YouTube is the world X  X  largest platform for creating, shar-ing and discovering video content. YouTube recommenda-tions are responsible for helping more than a billion users discover personalized content from an ever-growing corpus of videos. In this paper we will focus on the immense im-pact deep learning has recently had on the YouTube video recommendations system. Figure 1 illustrates the recom-mendations on the YouTube mobile app home.

Recommending YouTube videos is extremely challenging from three major perspectives: Figure 1: Recommendations displayed on YouTube mobile app home. In conjugation with other product areas across Google, YouTube has undergone a fundamental paradigm shift to-wards using deep learning as a general-purpose solution for nearly all learning problems. Our system is built on Google Brain [4] which was recently open sourced as TensorFlow [1]. TensorFlow provides a flexible framework for experimenting with various deep neural network architectures using large-scale distributed training. Our models learn approximately one billion parameters and are trained on hundreds of bil-lions of examples.

In contrast to vast amount of research in matrix factoriza-tion methods [19], there is relatively little work using deep neural networks for recommendation systems. Neural net-works are used for recommending news in [17], citations in [8] and review ratings in [20]. Collaborative filtering is for-mulated as a deep neural network in [22] and autoencoders in [18]. Elkahky et al . used deep learning for cross domain user modeling [5]. In a content-based setting, Burges et al . used deep neural networks for music recommendation [21].
The paper is organized as follows: A brief system overview is presented in Section 2. Section 3 describes the candidate generation model in more detail, including how it is trained and used to serve recommendations. Experimental results will show how the model benefits from deep layers of hidden units and additional heterogeneous signals. Section 4 details the ranking model, including how classic logistic regression is modified to train a model predicting expected watch time (rather than click probability). Experimental results will show that hidden layer depth is helpful as well in this situa-tion. Finally, Section 5 presents our conclusions and lessons learned.
The overall structure of our recommendation system is il-lustrated in Figure 2. The system is comprised of two neural networks: one for candidate generation and one for ranking .
The candidate generation network takes events from the user X  X  YouTube activity history as input and retrieves a small subset (hundreds) of videos from a large corpus. These candidates are intended to be generally relevant to the user with high precision. The candidate generation network only provides broad personalization via collaborative filtering. The similarity between users is expressed in terms of coarse features such as IDs of video watches, search query tokens and demographics.

Presenting a few  X  X est X  recommendations in a list requires a fine-level representation to distinguish relative importance among candidates with high recall. The ranking network accomplishes this task by assigning a score to each video according to a desired objective function using a rich set of features describing the video and user. The highest scoring videos are presented to the user, ranked by their score.
The two-stage approach to recommendation allows us to make recommendations from a very large corpus (millions) of videos while still being certain that the small number of videos appearing on the device are personalized and engag-ing for the user. Furthermore, this design enables blending candidates generated by other sources, such as those de-scribed in an earlier work [3].

During development, we make extensive use of offline met-rics (precision, recall, ranking loss, etc.) to guide iterative improvements to our system. However for the final deter-mination of the effectiveness of an algorithm or model, we rely on A/B testing via live experiments. In a live experi-ment, we can measure subtle changes in click-through rate, watch time, and many other metrics that measure user en-gagement. This is important because live A/B results are not always correlated with offline experiments.
During candidate generation, the enormous YouTube cor-pus is winnowed down to hundreds of videos that may be relevant to the user. The predecessor to the recommender Figure 2: Recommendation system architecture demonstrating the  X  X unnel X  where candidate videos are retrieved and ranked before presenting only a few to the user. described here was a matrix factorization approach trained under rank loss [23]. Early iterations of our neural network model mimicked this factorization behavior with shallow networks that only embedded the user X  X  previous watches. From this perspective, our approach can be viewed as a non-linear generalization of factorization techniques.
We pose recommendation as extreme multiclass classifica-tion where the prediction problem becomes accurately clas-sifying a specific video watch w t at time t among millions of videos i (classes) from a corpus V based on a user U and context C , where u  X  R N represents a high-dimensional  X  X mbedding X  of the user, context pair and the v j  X  R N represent embeddings of each candidate video. In this setting, an embedding is simply a mapping of sparse entities (individual videos, users etc.) into a dense vector in R N . The task of the deep neural network is to learn user embeddings u as a function of the user X  X  history and context that are useful for discriminating among videos with a softmax classifier.

Although explicit feedback mechanisms exist on YouTube (thumbs up/down, in-product surveys, etc.) we use the im-plicit feedback [16] of watches to train the model, where a user completing a video is a positive example. This choice is based on the orders of magnitude more implicit user history available, allowing us to produce recommendations deep in the tail where explicit feedback is extremely sparse. To efficiently train such a model with millions of classes, we rely on a technique to sample negative classes from the back-ground distribution ( X  X andidate sampling X ) and then correct for this sampling via importance weighting [10]. For each ex-ample the cross-entropy loss is minimized for the true label and the sampled negative classes. In practice several thou-sand negatives are sampled, corresponding to more than 100 times speedup over traditional softmax. A popular alterna-tive approach is hierarchical softmax [15], but we weren X  X  able to achieve comparable accuracy. In hierarchical soft-max, traversing each node in the tree involves discriminat-ing between sets of classes that are often unrelated, making the classification problem much more difficult and degrading performance.

At serving time we need to compute the most likely N classes (videos) in order to choose the top N to present to the user. Scoring millions of items under a strict serv-ing latency of tens of milliseconds requires an approximate scoring scheme sublinear in the number of classes. Previous systems at YouTube relied on hashing [24] and the classi-fier described here uses a similar approach. Since calibrated likelihoods from the softmax output layer are not needed at serving time, the scoring problem reduces to a nearest neighbor search in the dot product space for which general purpose libraries can be used [12]. We found that A/B re-sults were not particularly sensitive to the choice of nearest neighbor search algorithm.
Inspired by continuous bag of words language models [14], we learn high dimensional embeddings for each video in a fixed vocabulary and feed these embeddings into a feedfor-ward neural network. A user X  X  watch history is represented by a variable-length sequence of sparse video IDs which is mapped to a dense vector representation via the embed-dings. The network requires fixed-sized dense inputs and simply averaging the embeddings performed best among sev-eral strategies (sum, component-wise max, etc.). Impor-tantly, the embeddings are learned jointly with all other model parameters through normal gradient descent back-propagation updates. Features are concatenated into a wide first layer, followed by several layers of fully connected Rec-tified Linear Units (ReLU) [6]. Figure 3 shows the general network architecture with additional non-video watch fea-tures described below.
A key advantage of using deep neural networks as a gener-alization of matrix factorization is that arbitrary continuous and categorical features can be easily added to the model. Search history is treated similarly to watch history -each query is tokenized into unigrams and bigrams and each to-ken is embedded. Once averaged, the user X  X  tokenized, em-bedded queries represent a summarized dense search history. Demographic features are important for providing priors so that the recommendations behave reasonably for new users. The user X  X  geographic region and device are embedded and concatenated. Simple binary and continuous features such as the user X  X  gender, logged-in state and age are input di-rectly into the network as real values normalized to [0 , 1]. Many hours worth of videos are uploaded each second to YouTube. Recommending this recently uploaded ( X  X resh X ) content is extremely important for YouTube as a product. We consistently observe that users prefer fresh content, though not at the expense of relevance. In addition to the first-order effect of simply recommending new videos that users want to watch, there is a critical secondary phenomenon of boot-strapping and propagating viral content [11].

Machine learning systems often exhibit an implicit bias towards the past because they are trained to predict future behavior from historical examples. The distribution of video popularity is highly non-stationary but the multinomial dis-tribution over the corpus produced by our recommender will reflect the average watch likelihood in the training window of several weeks. To correct for this, we feed the age of the training example as a feature during training . At serving time, this feature is set to zero (or slightly negative) to re-flect that the model is making predictions at the very end of the training window.

Figure 4 demonstrates the efficacy of this approach on an arbitrarily chosen video [26]. Figure 4: For a given video [26], the model trained with example age as a feature is able to accurately represent the upload time and time-dependant pop-ularity observed in the data. Without the feature, the model would predict approximately the average likelihood over the training window.
It is important to emphasize that recommendation often involves solving a surrogate problem and transferring the result to a particular context. A classic example is the as-sumption that accurately predicting ratings leads to effective movie recommendations [2]. We have found that the choice of this surrogate learning problem has an outsized impor-tance on performance in A/B testing but is very difficult to measure with offline experiments.

Training examples are generated from all YouTube watches (even those embedded on other sites) rather than just watches on the recommendations we produce. Otherwise, it would be very difficult for new content to surface and the recom-mender would be overly biased towards exploitation. If users are discovering videos through means other than our recom-mendations, we want to be able to quickly propagate this discovery to others via collaborative filtering. Another key insight that improved live metrics was to generate a fixed number of training examples per user, effectively weighting our users equally in the loss function. This prevented a small cohort of highly active users from dominating the loss.
Somewhat counter-intuitively, great care must be taken to withhold information from the classifier in order to pre-vent the model from exploiting the structure of the site and overfitting the surrogate problem. Consider as an example a recommendations. case in which the user has just issued a search query for  X  X ay-lor swift X . Since our problem is posed as predicting the next watched video, a classifier given this information will predict that the most likely videos to be watched are those which appear on the corresponding search results page for  X  X ay-lor swift X . Unsurpisingly, reproducing the user X  X  last search page as homepage recommendations performs very poorly. By discarding sequence information and representing search queries with an unordered bag of tokens, the classifier is no longer directly aware of the origin of the label.

Natural consumption patterns of videos typically lead to very asymmetric co-watch probabilities. Episodic series are usually watched sequentially and users often discover artists in a genre beginning with the most broadly popular before focusing on smaller niches. We therefore found much better performance predicting the user X  X  next watch, rather than predicting a randomly held-out watch (Figure 5). Many col-laborative filtering systems implicitly choose the labels and context by holding out a random item and predicting it from other items in the user X  X  history (5a). This leaks future infor-mation and ignores any asymmetric consumption patterns. In contrast, we  X  X ollback X  a user X  X  history by choosing a ran-dom watch and only input actions the user took before the held-out label watch (5b).
Adding features and depth significantly improves preci-sion on holdout data as shown in Figure 6. In these exper-iments, a vocabulary of 1M videos and 1M search tokens were embedded with 256 floats each in a maximum bag size of 50 recent watches and 50 recent searches. The softmax layer outputs a multinomial distribution over the same 1M video classes with a dimension of 256 (which can be thought of as a separate output video embedding). These models were trained until convergence over all YouTube users, corre-sponding to several epochs over the data. Network structure followed a common  X  X ower X  pattern in which the bottom of the network is widest and each successive hidden layer halves the number of units (similar to Figure 3). The depth zero network is effectively a linear factorization scheme which performed very similarly to the predecessor system. Width and depth were added until the incremental benefit dimin-ished and convergence became difficult: Figure 6: Features beyond video embeddings im-prove holdout Mean Average Precision (MAP) and layers of depth add expressiveness so that the model can effectively use these additional features by mod-eling their interaction.
The primary role of ranking is to use impression data to specialize and calibrate candidate predictions for the partic-ular user interface. For example, a user may watch a given video with high probability generally but is unlikely to click on the specific homepage impression due to the choice of thumbnail image. During ranking, we have access to many more features describing the video and the user X  X  relation-ship to the video because only a few hundred videos are being scored rather than the millions scored in candidate generation. Ranking is also crucial for ensembling different candidate sources whose scores are not directly comparable.
We use a deep neural network with similar architecture as candidate generation to assign an independent score to each video impression using logistic regression (Figure 7). The list of videos is then sorted by this score and returned to the user. Our final ranking objective is constantly being tuned based on live A/B testing results but is generally a simple function of expected watch time per impression. Ranking by click-through rate often promotes deceptive videos that the user does not complete ( X  X lickbait X ) whereas watch time better captures engagement [13, 25].
Our features are segregated with the traditional taxonomy of categorical and continuous/ordinal features. The categor-ical features we use vary widely in their cardinality -some are binary (e.g. whether the user is logged-in) while others have millions of possible values (e.g. the user X  X  last search query). Features are further split according to whether they contribute only a single value ( X  X nivalent X ) or a set of values ( X  X ultivalent X ). An example of a univalent categorical fea-ture is the video ID of the impression being scored, while a corresponding multivalent feature might be a bag of the last N video IDs the user has watched. We also classify features according to whether they describe properties of the item ( X  X mpression X ) or properties of the user/context ( X  X uery X ). Query features are computed once per request while impres-sion features are computed for each item scored.
 We typically use hundreds of features in our ranking mod-els, roughly split evenly between categorical and continu-ous. Despite the promise of deep learning to alleviate the burden of engineering features by hand, the nature of our raw data does not easily lend itself to be input directly into feedforward neural networks. We still expend considerable connected. In practice, hundreds of features are fed into the network. engineering resources transforming user and video data into useful features. The main challenge is in representing a tem-poral sequence of user actions and how these actions relate to the video impression being scored.

We observe that the most important signals are those that describe a user X  X  previous interaction with the item itself and other similar items, matching others X  experience in ranking ads [7]. As an example, consider the user X  X  past history with the channel that uploaded the video being scored -how many videos has the user watched from this channel? When was the last time the user watched a video on this topic? These continuous features describing past user actions on related items are particularly powerful because they generalize well across disparate items. We have also found it crucial to propagate information from candidate generation into rank-ing in the form of features, e.g. which sources nominated this video candidate? What scores did they assign?
Features describing the frequency of past video impres-sions are also critical for introducing  X  X hurn X  in recommen-dations (successive requests do not return identical lists). If a user was recently recommended a video but did not watch it then the model will naturally demote this impression on the next page load. Serving up-to-the-second impression and watch history is an engineering feat onto itself outside the scope of this paper, but is vital for producing responsive recommendations.
 Similar to candidate generation, we use embeddings to map sparse categorical features to dense representations suitable for neural networks. Each unique ID space ( X  X ocabulary X ) has a separate learned embedding with dimension that in-creases approximately proportional to the logarithm of the number of unique values. These vocabularies are simple look-up tables built by passing over the data once before training. Very large cardinality ID spaces (e.g. video IDs or search query terms) are truncated by including only the top N after sorting based on their frequency in clicked im-pressions. Out-of-vocabulary values are simply mapped to the zero embedding. As in candidate generation, multivalent categorical feature embeddings are averaged before being fed in to the network.

Importantly, categorical features in the same ID space also share underlying emeddings. For example, there exists a sin-gle global embedding of video IDs that many distinct fea-tures use (video ID of the impression, last video ID watched by the user, video ID that  X  X eeded X  the recommendation, etc.). Despite the shared embedding, each feature is fed sep-arately into the network so that the layers above can learn specialized representations per feature. Sharing embeddings is important for improving generalization, speeding up train-ing and reducing memory requirements. The overwhelming majority of model parameters are in these high-cardinality embedding spaces -for example, one million IDs embedded in a 32 dimensional space have 7 times more parameters than fully connected layers 2048 units wide.
 Neural networks are notoriously sensitive to the scaling and distribution of their inputs [9] whereas alternative approaches such as ensembles of decision trees are invariant to scaling of individual features. We found that proper normalization of continuous features was critical for convergence. A con-tinuous feature x with distribution f is transformed to  X  x by scaling the values such that the feature is equally distributed in [0 , 1) using the cumulative distribution,  X  x = This integral is approximated with linear interpolation on the quantiles of the feature values computed in a single pass over the data before training begins.

In addition to the raw normalized feature  X  x , we also input powers  X  x 2 and by allowing it to easily form super-and sub-linear functions of the feature. Feeding powers of continuous features was found to improve offline accuracy.
Our goal is to predict expected watch time given training examples that are either positive (the video impression was clicked) or negative (the impression was not clicked). Pos-itive examples are annotated with the amount of time the user spent watching the video. To predict expected watch time we use the technique of weighted logistic regression, which was developed for this purpose.

The model is trained with logistic regression under cross-entropy loss (Figure 7). However, the positive (clicked) impressions are weighted by the observed watch time on the video. Negative (unclicked) impressions all receive unit weight. In this way, the odds learned by the logistic regres-sion are P T i N  X  k where N is the number of training examples, k is the number of positive impressions, and T i is the watch time of the i th impression. Assuming the fraction of pos-itive impressions is small (which is true in our case), the learned odds are approximately E[ T ](1 + P ), where P is the click probability and E[ T ] is the expected watch time of the impression. Since P is small, this product is close to E[ T ]. For inference we use the exponential function e x as the fi-nal activation function to produce these odds that closely estimate expected watch time.
Table 1 shows the results we obtained on next-day holdout data with different hidden layer configurations. The value shown for each configuration ( X  X eighted, per-user loss X ) was obtained by considering both positive (clicked) and negative (unclicked) impressions shown to a user on a single page. We first score these two impressions with our model. If the negative impression receives a higher score than the posi-tive impression, then we consider the positive impression X  X  watch time to be mispredicted watch time . Weighted, per-user loss is then the total amount mispredicted watch time as a fraction of total watch time over heldout impression pairs.

These results show that increasing the width of hidden layers improves results, as does increasing their depth. The trade-off, however, is server CPU time needed for inference. The configuration of a 1024-wide ReLU followed by a 512-wide ReLU followed by a 256-wide ReLU gave us the best results while enabling us to stay within our serving CPU budget.

For the 1024  X  512  X  256 model we tried only feeding the normalized continuous features without their powers, which increased loss by 0.2%. With the same hidden layer con-figuration, we also trained a model where positive and neg-ative examples are weighted equally. Unsurprisingly, this increased the watch time-weighted loss by a dramatic 4.1%. Hidden layers weighted, per-user loss
None 41.6% 256 ReLU 36.9% 512 ReLU 36.7% 1024 ReLU 35.8% 512 ReLU  X  256 ReLU 35.2% 1024 ReLU  X  512 ReLU 34.7% 1024 ReLU  X  512 ReLU  X  256 ReLU 34.6% Table 1: Effects of wider and deeper hidden ReLU layers on watch time-weighted pairwise loss com-puted on next-day holdout data.
We have described our deep neural network architecture for recommending YouTube videos, split into two distinct problems: candidate generation and ranking.

Our deep collaborative filtering model is able to effectively assimilate many signals and model their interaction with lay-ers of depth, outperforming previous matrix factorization approaches used at YouTube [23]. There is more art than science in selecting the surrogate problem for recommenda-tions and we found classifying a future watch to perform well on live metrics by capturing asymmetric co-watch behavior and preventing leakage of future information. Withholding discrimative signals from the classifier was also essential to achieving good results -otherwise the model would overfit the surrogate problem and not transfer well to the home-page.

We demonstrated that using the age of the training exam-ple as an input feature removes an inherent bias towards the past and allows the model to represent the time-dependent behavior of popular of videos. This improved offline holdout precision results and increased the watch time dramatically on recently uploaded videos in A/B testing.

Ranking is a more classical machine learning problem yet our deep learning approach outperformed previous linear and tree-based methods for watch time prediction. Recom-mendation systems in particular benefit from specialized fea-tures describing past user behavior with items. Deep neural networks require special representations of categorical and continuous features which we transform with embeddings and quantile normalization, respectively. Layers of depth were shown to effectively model non-linear interactions be-tween hundreds of features.

Logistic regression was modified by weighting training ex-amples with watch time for positive examples and unity for negative examples, allowing us to learn odds that closely model expected watch time. This approach performed much better on watch-time weighted ranking evaluation metrics compared to predicting click-through rate directly. The authors would like to thank Jim McFadden and Pranav Khaitan for valuable guidance and support. Sujeet Bansal, Shripad Thite and Radek Vingralek implemented key com-ponents of the training and serving infrastructure. Chris Berg and Trevor Walker contributed thoughtful discussion and detailed feedback. [1] M. Abadi, A. Agarwal, P. Barham, E. Brevdo, [2] X. Amatriain. Building industrial-scale real-world [3] J. Davidson, B. Liebald, J. Liu, P. Nandy, [4] J. Dean, G. S. Corrado, R. Monga, K. Chen, [5] A. M. Elkahky, Y. Song, and X. He. A multi-view deep [6] X. Glorot, A. Bordes, and Y. Bengio. Deep sparse [7] X. He, J. Pan, O. Jin, T. Xu, B. Liu, T. Xu, Y. Shi, [8] W. Huang, Z. Wu, L. Chen, P. Mitra, and C. L. Giles. [9] S. Ioffe and C. Szegedy. Batch normalization: [10] S. Jean, K. Cho, R. Memisevic, and Y. Bengio. On [11] L. Jiang, Y. Miao, Y. Yang, Z. Lan, and A. G. [12] T. Liu, A. W. Moore, A. Gray, and K. Yang. An [13] E. Meyerson. Youtube now: Why we focus on watch [14] T. Mikolov, I. Sutskever, K. Chen, G. Corrado, and [15] F. Morin and Y. Bengio. Hierarchical probabilistic [16] D. Oard and J. Kim. Implicit feedback for [17] K. J. Oh, W. J. Lee, C. G. Lim, and H. J. Choi. [18] S. Sedhain, A. K. Menon, S. Sanner, and L. Xie. [19] X. Su and T. M. Khoshgoftaar. A survey of [20] D. Tang, B. Qin, T. Liu, and Y. Yang. User modeling [21] A. van den Oord, S. Dieleman, and B. Schrauwen. [22] H. Wang, N. Wang, and D.-Y. Yeung. Collaborative [23] J. Weston, S. Bengio, and N. Usunier. Wsabie: Scaling [24] J. Weston, A. Makadia, and H. Yee. Label partitioning [25] X. Yi, L. Hong, E. Zhong, N. N. Liu, and S. Rajan. [26] Zayn. Pillowtalk.
