 More and more web sites are supporting location-based keyword search which consists of a spatial condition and a set of keywords as textual condition. Such query is formulated as the spatial keywo rd query, and aims to find objects with keywords description within a location region or close to a location. It requires users to query with exact keywords associated to objects, and mismatches be-tween queried keywords and object keywords will lead to result loss. In real-life applications, such mismatch is prevalent since there are errors in object keywords and users also produce typos while inputting their queries. Research community introduces spatial approximate keyword search[8][7] to deal with the mismatch problem. Instead of looking for object s with exact keywords provided by the query, spatial approximat e keyword query returns ob jects with keywords simi-lar enough to the queried keywords. Spatial approximate keyword query enables great usability when processing massive data containing errors, and it also makes users X  typos tolerant.

Recently, research community has proposed MHR-tree [8] and LBAK-tree [7] to support spatial approximate keyword search. MHR-tree incorporates key-words X  min-hash signatures into R-tree nodes to enable search functionality over approximate keyword conditions, and it may returns incomplete query results without quality guarantee. LBAK-tree is a memory based index structure which stores inverted lists of q-grams into R-tree nodes. Such solution consumes too large memory to work on massive data, since it costs memory larger than the original dataset. Meanwhile, LBAK-tree can not be extended to disk because LBAK-tree node size is quite unbounded. With the rapid growth of data, spatial databases are no longer able (or cost effective) to hold all the data and indexes in main memories. Thus, it is essential to answer spatial approximate keyword queries over disk resident datasets. Up to now, there is no disk resident index to support spatial approximate keyword queries in an exact manner.

This paper proposes R -tree incorporated with M ultiple B itmaps (RMB-tree) summarizing keywords to support spatial approximate keyword queries. RMB-tree augments multiple bitmaps which summarize the q  X  gram s for the set of keywords inside a sub-tree, and enables searching on fuzzy keyword conditions with the summary. Given a spatial appr oximate keyword query, RMB-tree cal-culates the number of q  X  gram s absent from sub-trees for each queried keyword, and prunes sub-trees with enough absent q  X  gram s. To achieve this goal, we first provide a SGB-filter with a single bitmap, and then give the design of MGB-filter based on multiple bitmaps providing better pruning effects. Compared to existing solutions, RMB-tree is able to return exact query results on disks.
This paper makes the following contributions: 1. An disk-resident index named RMB-tree is proposed. RMB-tree employs 2. We give the methods for RMB-tree utilization, including the insertion method 3. Experiments over real-life datasets are conducted, and the results validate
The rest of this paper is organized as follows. Section 2 introduces the pre-liminary and the definition of the spatial approximate keyword query. Section 3 presents the structure and utilization methods of RMB-tree. Section 4 presents the performance evaluation, and we conclude this paper in Section 5. This section introduces preliminaries used in the rest of this paper, including gram-based approximate string search and the formulation of the spatial ap-proximate keyword query. Here we take edit distance as the string similarity metric, and other similarity metrics can be adopted in similar ways. 2.1 Gram-Based Approximate String Search Given a finite alphabet ,astring s is a sequence of chars in .The ith char of s is labeled s [ i ], and the subsequence from the ith char to the jth char of s is denoted s [ i, j ]. The length of string s is denoted by | s | .

Given two chars  X  ,  X  which are not from , a new string s is built by adding q  X  1 copies of  X  before s and q  X  1 copies of  X  after s .The ith q-gram of string s (also referred as g ( i, s )) is the subsequence of s starting from the ith character with length q , and it equals to s [ i, i + q  X  1]. A string s has | s | + q  X  1q-grams. The q-gram set of a string s contains | s | + q  X  1 unique q-grams of s , and it is denoted by GS ( s ).

The edit distance between two strings s 1 and s 2 , denoted ED ( s 1 ,s 2 ) is defined as the minimum number of edits needed to transform one string to the other, with the allowable edit operations being insertion, deletion, or substitution of a single character.
 Example 1. Given two strings s 1 = theatre and s 2 = theater , the 2-gram set of s 1 and s 2 are GS ( s 1 )= { # t, th, he, ea, at, tr, re, e # } and GS ( s 2 )= { # t, th, he, ea, at, te, er, r # } respectively. The edit distance ED ( s 1 ,s 2 )=2.
Existing works on string similarity sear ch explores the relation between edit distance and q-gram sets of strings, and an intuition is that strings with small edit distance have a small number of different q-grams. The number of different tree follows gram-based solutions to deal with approximate keyword conditions. 2.2 Spatial Approximate Keyword Search Here we formulate range approximate keyword query. Suppose there is a spatial coordinate loc and j keywords ( k 1 ,..., k j ) describing itself.
 Definition 1. ( Range Approximate Keyword Query ) A range approximate keyword query Q RAK is formatted as ( R, ( k 1 , X  1 ) , ..., ( k m , X  m )) ,where R is a spatial region and k i is a queried keyword and  X  i is its similarity threshold for 1 i m . Given a spatial object set O = { o 1 , ..., o N } , Q RAK finds all the objects o satisfying that (1) o.loc  X  R ,(2)  X  k i  X  o.keywords and ED ( k i ,Q RAK .k u ) Q RAK . X  u for all 1 u m .
 Figure 1 depicts an example of querying in a set of business objects { o 1 , ..., o 10 } . Q
RAK looks for objects labeled with keywords whose edit distance is no more than2to X  Musum  X  within the square region. Object o 5 is returned. This section introduces a novel disk re sident index named RMB-tree. RMB-tree is able to answer queries with a spatial constraint and approximate keyword con-ditions. Section 3.1 describes the stru cture of RMB-tree, and Section 3.2 shows the utilization of RMB-tree involving specified update and query processing al-gorithms. 3.1 Structure of RMB-Tree The main idea of RMB-tree is to augment R-tree with capacity of searching fuzzy keywords, and such idea is in co mmon with recent proposed work [7][8]. RMB-tree stores a set of bitmaps called gram bitmap in internal nodes, and gram bitmap enables a tree node to judge whether there possibly exists keywords similar enough to given keywords in its descendent. Our proposed index is named RMB-tree since is augments R -tree nodes with M ultiple B itmaps. In next parts, we first introduce RSB-tree which is the single bitmap version of RMB-tree, then comes multiple bitmap solution of RMB-tree. The formal definition of gram bitmap is given as follows.
 Definition 2. ( Gram Bitmap ) Given a string s  X  ( )  X  , an integer q and a uniform hash function h b :( ) q  X  X  1 , 2 , ..., L } , the gram bitmap of s is a sequence belong to { 0 , 1 } L , whose the i th bit equals to 1 if and only if  X  g  X  GS ( s ) , h b ( g )= i . The gram bitmap of s is denoted by GB ( s ) . Given a string set S , the gram bitmap of S denoted GB ( S ) belongs to { 0 , 1 } L ,andthe ith bit of GB ( S ) is 1 if and only if there exists a string t  X  S satisfying that GB ( t )[ i ]=1 .
We denote the subtree rooted at an RSB-tree node N as SubTree ( N ), and the keyword set stored in SubTree ( N ) is denoted by KS ( N ). An internal node N i stores GB ( KS ( N i )). Given a spatial approximate keyword query Q ( S, K ), internal node N i employs GB ( KS ( N i )) to make a secure estimation whether KS ( N i ) possibly provides all necessary keywords to satisfy Q ( S, K ) X  X  approxi-mate keyword constraints. This estimation may bring false positives but never loses any results. The following theorems guarantees the correctness of search space pruning at internal node N i .
 Theorem 1. Given a string s and an edit distance threshold  X  ,ifthereexists astring t  X  KS ( N j ) satisfying that ED ( s, t )  X  , then the following inequality holds. Proof. Since there exists a string t  X  KS ( N j ) satisfying that ED ( s, t )  X  , | GS ( s ) /GS ( t ) | q  X   X  . Then, inequation |{ k | 1 k L, GB ( s )[ k ]= 1 ,GB ( t )[ k ]=0 }| q  X   X  holds true. For all 1 k L , GB ( N j )[ k ]=1if GB ( t )[ k ]=1.Thus |{ k | 1 k L, GB ( s )[ k ]=1 ,GB ( N j )[ k ]=0 }| |{ k | 1 k L, GB ( s )[ k ]=1 ,GB ( t )[ k ]=0 }| q  X   X  .

According to Theorem 1, an RSB-tree internal node is able to prune search space among its children for spatial approximate keyword queries. Here we de-note the filter with single gram bitmap by SGB-Filter , and it is employed to estimate whether a subtree possibly contains query results. Here is the defini-tion of SGB-Filter .
 Definition 3. ( SGB-Filter ) Given a string t , an edit distance threshold  X  and astringset S . SGB-Filter computes |{ g | g  X  GS ( t ) ,GB ( S )[ h b ( g )] = 0 }| ,and returns true if and only if the computed value is no larger than q  X   X  .
Given a string s and a string set S , RSB-tree employs the same principle with MHR-tree , and they conclude there does not exist t  X  S that ED ( s, t ) Filter or min-hash signatures. SGB-Filter estimates whether a gram g exists in GS ( S ) according to GB ( S ), and it produces false positive if g/  X  GS ( S ) but GB ( S )[ h b ( g )] = 1. The hash function h b , which is adopted in SGB-Filter ,hashes agram g to L positions of the bitmap with equal probability, so Given a set of strings denoted S ,and | t  X  S GS ( t ) | = N , the probability p L = Pr ( GB ( S )[ h b ( g )] = 1 | g/  X  GS ( S )) is related to the length of bitmap L .Itis computed as when N and L are relatively large, say hundreds or thousands. In a block-based tree index, a 4KB disk page may contain hundreds of identical grams, and SGB-Filter fails to improve filtering effects by increasing the length of gram bitmap. Figure 2 illustrates the probability of false positive while estimating gram membership. Suppose the total gram number in a string set is around 300, we increase the single bitmap length, and find that false positive probability decreases very slowly When single bitmap length is more than 1000. Such result not only shows the limit of RSB-tree X  X  pruning effects but also that of MHR-tree . In the meanwhile, increasing the length of bitmap also produces more internal tree nodes, thus costs more I/O operations during query processing. The single bitmap solution fails to further improve pruning since it takes a set of strings as a whole, and ignores the individual content of each string. Next we provide an example.
 { g string t that GS ( t )= { g 1 ,g 4 ,g 7 ,g 10 } . The single bitmap solution estimates | =3for i =1 , 2 , 3 , 4.

Based on the above observation, RMB-tree employs multiple bitmaps to ex-plore the content of individual strings for improving the filtering power at tree nodes. Such strategy divides a set of strings into k groups, and builds a gram bitmap for each group. Given a string t , the multiple bitmap solution invokes SGB-Filter with each gram bitmap, and returns true if all the groups return true. The gram membership estimation gives a correct answer with probability if the grams is nearly equally-divided into k groups. This means the multiple bitmap based solution does not decrease the accuracy of membership estimation, at the same time it provides opportunities to disseminate grams from different strings to different groups. Such dissemination increases approximate keywords pruning power since it identifies some grams do not occur in identical keywords. Next we introduce the definition of MGB-Filter designed for RMB-tree. Definition 4. ( MGB-Filter ) Given a string t , an edit distance threshold  X  and a string set S which is divided into k partitions denoted S 1 , ... , S k , MGB-Filter invokes SGB-Filter on each partition S i , and return true if t and  X  pass a SGB-Filter on any partition.
 An RMB-tree internal node N is formatted as &lt;P,R,B 1 , ..., B k ,CS &gt; ,where P is the disk page id of N and R is the spatial region of SubTree ( N ). B 1 ... B k are gram bitmaps of k keyword set partitions in SubTree ( N ). CS is N  X  X  children set, in which each item consists of the children X  X  page id, spatial region, and gram bitmaps. A leaf node N L of RMB-tree is formatted as &lt;P,R,B 1 , ..., B k ,DS &gt; including N L  X  X  disk page id, spatial region, gram bitmaps, and data set. Objects are stored in N L  X  X  data set DS . 3.2 Utilization of RMB-Tree This section introduces the utilization of RMB-tree, including object insertion and query processing algorithms. Algorithm 1. ChooseChild Algorithm 2. Insert Insertion of RMB-Tree Similar to R-tree X  X  ins ertion, an insertion in RMB -tree starts from the root and selects a subtree to accomplish the insertion at each level of the tree. When an insertio n reaches a leaf node finally, the object is inserted into the leaf node, then the leaf node updates its shape including spatial region and gram bitmaps. If the leaf node is full, RMB-tree processes the split from bottom to top if necessary. RMB -tree X  X  insertion differs from R-tree in the process of subtree selection and in sertion at a tree node. Algorithm 1 de-scribes how an RMB-tree internal node N selects subtree to finish the insertion. N computes insertion cost for all of its children nodes. The insertion cost of a child node j is a two-tuple c ( j, o )=( ROE j ( o ) ,BE j ( o )). ROE is the increased area of spatial region overlap between th e chosen child and other children after insertion. This is similar to the insertion of R*-tree. BE j ( o ) is the number of bits changing from 0 to 1 in j  X  X  gram bitmaps during insertion. RMB-tree chooses a child with minimum insertion cost, since smaller insertion cost leads to smaller spatial region overlap and smaller bitmap enlargement. Such selection of inser-tion target produces RMB-tree with better pruning power. Algorithm 2 shows how an RMB-tree inserts object o into node N . Similar to R*-tree X  X  insertion al-gorithm, Algorithm 2 firstly checks whether N is full and invokes R*-tree X  X  split algorithm to deal with node split when N is full (line 1-2). Otherwise it first Algorithm 3. RangeQueryProcessing refines N  X  X  spatial region (line 3) and gram bitmaps (line 4-7). Algorithm 2 adopts greedy strategy to minimize the loss of pruning power at N ,andit chooses a gram bitmap for each of o  X  X  keyword to join. The chosen gram bitmap has fewest enlargement, thus the overal l pruning power decrease is minimized. Then, Algorithm 2 finishes the ins ertion according to the type of N in the same manner as R*-tree (line 8-13). The method Split invoked in line 2 also refers to gram bitmap refinement, and it also greedily selects a bitmap for each key-word of o . The bitmap selection also aims to achieve minimum number of bits changing from 0 to 1. The detail is omitted for space.
 Query Processing of RMB-Tree RMB-tree T invokes Algorithm 3 at its root node to process a range approximate keyword query. Algorithm 3 presents how an RMB-tree node N processes a query. If N is a leaf node, it checks data objects inside it, and objects satisfying Q  X  X  constraints are added into the query result. If N is an internal node, it examines all of its children with MGB-Filter to find which children possibly contains query results of Q (line 7-14). Then Algorithm 3 is invoked recursively at chose n children nodes, and returned results are combined (line 15-16). The query processing is similar to that of R-tree, and the difference lies in pruning with MGB-Filter among subtrees instead of pruning with spatial condition only. RMB-tree is able to reduce search space with spatial condition and keyword condition, thus it a chieves better performance than pure R-tree solution. RMB-tree is tested on a PC with Intel i5-2400 CPU at 3.10GHz and 4GB of memory. We use two real-world datasets named TX and CA obtained from open street map project [1]. TX and CA both contain 14 million points, where each point consist of a two-dimensional coordinate and a number of string attributes. TX and CA contain the road networks and streets for Texas and California in USA. We sample 2  X  10 6 to 10  X  10 6 objects from each of TX and CA to test the performance of RMB-tree. The sampled datasets are named TX 2 to TX 10 and CA 2 to CA 10 respectively. We conduct a set of 100 range approximate keyword queries as follows. For each query, we randomly select an object and generate spatial region centered at the selected object. The area of generated spatial region is determined by parameter P which is the area ratio of the generated region to the entire region. We use normalized edit distance as the similarity metric of keywords, and RMB-tree is tested with no rmalized edit distance including 10%, 20% and 30%. Such query list guarantees that no empty results are returned. We compare RMB-tree with R-tree, since R -tree is disk resident and it returns precise results. Only results on TX are reported due to space limit, since results on CA are quite similar. We denote the number of bitmaps by k ,andthelength of bitmaps by l .

We first compare RMB-tree construction costs with different settings. To il-lustrate the effects of bitmap numbers, we fix bitmap length at 200 and vary the number of bitmaps from 1 to 25. Figure 3(a) shows that RMB-tree size grows with the number of bitmap, and the growth is near-linear. As depicted in Figure 3(b), the time of constructing an RMB-tree with different number of bitmaps also increases near-linearly. The reason is that increasing bitmap num-ber decreases the fanout of internal nodes, thus produces more internal nodes. More bitmaps also take more time during object insertions, since RMB-tree seeks a proper bitmap to include each keyword of the inserted object. RMB-tree con-struction costs more space and time than that of R-tree, since it stores additional bitmaps in tree nodes and computes which bitmap to insert each keyword. Sim-ilar results are retrieved when we fix th e number of bitmap at 10 and increase the length of each bitmap from 100 to 400. As shown in Figure 3(c) and Fig-ure 3(d), both space and time for building an RMB-tree grow as we increase the length of each bitmap. The reason is that longer bitmaps cost more space, thus decrease internal node fanout and create more internal nodes. In the meanwhile, longer bitmaps also take more time to be operated on. We vary the number of objects inserted and test the space and time cost for building an RMB-tree as reported in Figure 3(e) and Figure 3(f). With 10 bitmaps at the length of 200, we insert 2  X  10 6 to 10  X  10 6 objects into an RMB-tree. The index size grows proportional to the number of the inserted objects, and the time of constructing index follows the same trend. The results show that RMB-tree construction cost more space and time than that of building an R-tree, but the improvement of query performance introduced late r is worth the one-time investment.
Figure 4 reports the average query I/O numbers of RMB-tree and R-tree respectively, and the default number of objects is 2  X  10 6 . To illustrate pruning effects of single bitmap solution, we build RMB-tree with a single bitmap and increase the length of bitmap from 200 to 2400. The smallest query I/O shown in Figure 4(a) depicts the limitation of single bitmap solution. As Figure 4(a) shows, increasing the length of bitmap a chieves less query I/O before the length reaches 1200, then the query I/O cost increases when the length of bitmap grows on. Longer bitmaps provide more accuracy estimation of gram membership, so query performance improves until bitmap length reaches 1200, where the pruning effect limit of single bitmap solution is achieved. After then, increasing bitmap length does not provide benefit for gram membership estimation but produces more internal nodes, thus decreases query performance. Then we study the performance of multiple bitmap solution. Figure 4(b) shows results with varying total space consumed by bitmaps, and compares different gram lengths including 200, 300 and 400. As shown in Figure 4(b), query I/O decreases as total bitmap space increases from 600 to 3000. This means multiple bitmap solution provides better pruning power than single bitmap solution. Bitmap length of 200 gets the best performance, and wins those of 100 and 300 slightly, since it tradeoffs with a single bitmap estimation accuracy and the number of partitions. For better comparison of single bitmap solution and multiple bitmap solution, Figure 4(c) compares both solutions with varying total space of bitmaps ranging from 600 to 3000. Being consistent with previous results, single bitmap solution fails to improve query performance by using more bitmap space, while multiple bitmap solution keeps on reducing query I/O when more bitmap space is added. Figure 4(c) also shows that RMB-tree saves significant query I/Os compared to R-tree. Figure 4(d) shows t he query performance with different keyword normalized edit distances ( t ) at 10%, 20% and 30%, and RMB-tree costs 69% to 84% less query I/Os than R-tree. With varying normalized edit distances, RMB-tree costs more I/Os as t increases while R-tree pays a constant I/O number. Figure 4(e) shows the impact of queried area on query performance. We vary the the area ratio from 1% to 20% and study the query I/O with different queried areas with fixed t at 20%. As shown in Figure 4(e), RMB-tree costs nearly constant number of I/Os since irrelevant subtrees are pruned by MGB-Filter . The query I/O of R-tree grows with the queried area, as it provides only spatial pruning effect. For all queried areas, RMB-tree costs 66% to 88% less query I/Os compared to R-tree. To test the scalability of RMB-tree, we build RMB-tree with different number of objects ranging from 2  X  10 6 to 10  X  10 6 , and record the average query I/O. Figure 4(f) shows that RMB-tree query I/O grows linearly as the number of objects, and saves 80% to 84% number of I/O compared to R-tree. Thus RMB-tree scales well with the number of objects. Approximate string search is a fundamental sub-problem of spatial approximate keyword search. Existing works consist of two major types including trie-based methods and gram-based methods. Gram-based methods mainly employ a filter-and-verify framework, and more details can be referred to [6][2][11].
Spatial keyword search which returns objects with exact keywords matching query condition is well studied in [3][10][9], and so on. Most of these works employ a tree-based index structure and augment it with keyword information in each tree node. A recent excellent ex periment study can be found in [5]. Our work focuses on spatial approximate keyword search and these works deal with a special case of our problem.

MHR-tree [8] and LBAK-tree [7] are most related to our work, since they propose index answering spatial query with approximate keyword conditions. They share the same idea as previous works to incorporate tree-based spatial index with keyword information in tree nodes. In each R-tree [4] internal nodes, MHR-tree employs a number of independent hash functions to compute a min-hash signature of the keyword set in the subtree. Given a query, MHR-tree estimates whether a subtree contains enough common q-grams with given key-words based on the min-hash signature. Although the estimation is unbiased, the approximate nature of min-hash signature makes MHR-tree miss some of the query results. LBAK-tree is a memory based index, which stores inverted lists of q-grams for strings in a subtree in some tree nodes. The inverted lists of q-grams help a query to judge whether a subtree possibly contains all the required keywords similar enough to the queried ones. Such solution makes a tree node size unbounded thus it can not work efficiently on disks. In this paper, we propose a disk-resident index named RMB-tree to support spatial approximate keyword queries. We present the structure of RMB-tree to-gether with the insertion method and the query processing method. Compared to existing works, RMB-tree is able to return exact query results on disks effi-ciently. We compare RMB-tree with R-tree which is the state-of-art solution for returning exact results on disk, and the comparison validates the effectiveness and efficiency of our proposed RMB-tree.
 Acknowledgments. This work is funded by P roject (No. 61272046) sup-ported by the National Natural Science Foundation of China; Project sup-ported by the Natural Science Foundation of Heilongjiang Province,China(Grant No. F201317); The Fundamental Resear ch Funds for the Central Univer-sity (Grant No. HIT.NSR IF.2015065); Chi na Postdoctoral Science Foundation Funded Project(Grant No. 2013T60372, 2014M561351); Heilongjiang Postdoc-toral Science Foundation Funded Project(Grant No. LBH-Z14118).

