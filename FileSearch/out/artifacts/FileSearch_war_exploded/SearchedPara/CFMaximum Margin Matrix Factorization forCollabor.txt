 Collaborative filtering has gained much attention in the machine learning community due to the need for it in webshops such as those of Amazon, Apple and Netflix. Webshops typically offer personalized recommendations to their customers. The quality of these suggestions is crucial to the overall success of a webshop. However, suggesting the right items is a highly nontrivial task: (1) There are many items to choose from. (2) Customers only consider very few (typically in the order of ten) recommendations. Collaborative filtering addresses this problem by learning the suggestion function for a user from ratings provided by this and other users on items offered in the webshop. Those ratings are typically collected on a five star ordinal scale within the webshops. Learning the suggestion function can be considered either a rating (classification) or a ranking prob-lem. In the context of rating, one predicts the actual rating for an item that a customer has not rated yet. On the other hand, for ranking, one predicts a preference ordering over the yet unrated items. Given the limited size of the suggestion shown to the customer, both (rating and ranking) are used to compile a top-N list of recommendations. This list is the direct outcome of a ranking algorithm, and can be computed from the results of a rating algorithm by sorting the items according to their predicted rating. We argue that rating algorithms solve the wrong problem, and one that is actually harder: The absolute value of the rating for an item is highly biased for different users, while the ranking is far less prone to this problem.
 One approach is to solve the rating problem using regression. For example for the Netflix prize which uses root mean squared error as an evaluation criterion, 1 the most straightforward approach is to use regression. However, the same arguments discussed above apply to regression. Thus, we present an algorithm that solves the ranking problem directly, without first computing the rating. For collaborative rating, Maximum Margin Matrix Factorization (MMMF) [11, 12, 10] has proven to be an effective means of estimating the rating function. MMMF takes advantage of the collaborative effects: rating patterns from other users are used to estimate ratings for the current user. One key advantage of this approach is that it works without feature extraction. Feature extraction is domain specific, e.g. the procedures developed for movies cannot be applied to books. Thus, it is hard to come up with a consistent feature set in applications with many different types of items, as for example at Amazon. Our algorithm is based on this idea of MMMF, but optimizes ranking measures instead of rating measures.
 Given that only the top ranked items will actually be presented to the user, it is much more important to rank the first items right than the last ones. In other words, it is more important to predict what a user likes than what she dislikes . In more technical terms, the value of the error for estimation is not uniform over the ratings. All of above reasonings lead to the following goals:  X  The algorithm needs to be able to optimize ranking scores directly.  X  The algorithm needs to be adaptable to different scores.  X  The algorithm should not require any features besides the actual ratings.  X  The algorithm needs to scale well and parallelize such as to deal with millions of ratings arising We achieve these goals by combining (a) recent results in optimization, in particular the application of bundle methods to convex optimization problems [14], (b) techniques for representing functions on matrices, in particular maximum margin matrix factorizations [10, 11, 12] and (c) the application of structured estimation for ranking problems. We describe our algorithm C O F I R ANK in terms of optimizing the ranking measure Normalized Discounted Cumulative Gain (NDCG). Assume that we have m items and u users. The ratings are stored in the sparse matrix Y where Y i,j  X  { 0 ,...,r } is the rating of item j by user i and r is some maximal score. Y i,j is 0 if user i did not rate item j . In rating, one estimates the missing values in Y directly while we treat this as a ranking task. Additionally, in NDCG [16], the correct order of higher ranked items is more important than that of lower ranked items: Definition 1 (NDCG) Denote by y  X  { 1 ,...,r } n a vector of ratings and let  X  be a permutation of that vector.  X  i denotes the position of item i after the permutation. Moreover, let k  X  N be a truncation threshold and  X  s sorts y in decreasing order. In this case the Discounted Cumulative Gains (DCG@k) score [5] and its normalized variant (NDCG@k) are given by DCG@k is maximized for  X  =  X  s . The truncation threshold k reflects how many recommendations users are willing to consider. NDCG is a normalized version of DCG so that the score is bounded by [0 , 1] .
 Unlike classification and regression measures, DCG is defined on permutations, not absolute val-dependent: Higher positions have more influence on the score than lower positions. Optimizing DCG has gained much interest in the machine learning and information retrieval (e.g. [2]) commu-nities. However, we present the first effort to optimize this measure for collaborative filtering. To perform estimation, we need a recipe for obtaining the permutations  X  . Since we want our system to be scalable, we need a method which scales not much worse than linearly in the number of the items to be ranked. The avenue we pursue is to estimate a matrix F  X  R m  X  u and to use the values F ij for the purpose of ranking the items j for user i . Given a matrix Y of known ratings we are now able to define the performance of F : where  X  i is argsort(  X  F i ) , it sorts F i in decreasing order. 2 While we would like to maximize R ( F,Y test ) we only have access to R ( F,Y train ) . Hence, we need to restrict the complexity of F to ensure good performance on the test set when maximizing the score on the training set. However, R ( F,Y ) is non-convex. In fact, it is piecewise constant and therefore clearly not amenable to any type of smooth optimization. To address this issue we take recourse to structured estimation [13, 15]. Note that the scores decompose into a sum over individual users X  scores, hence we only need to show how minimizing  X  NDCG(  X ,y ) can be replaced by minimizing a convex upper bound on the latter. Summing over the users then provides us with a convex bound for all of the terms. 3 Our conversion works in three steps: Step 1 (Regret Conversion) Instead of maximizing NDCG(  X ,y ) we may also minimize  X (  X ,y ) is nonnegative and vanishes for  X  =  X  s .
 Step 2 (Linear Mapping) Key in our reasoning is the use of the Polya-Littlewood-Hardy inequal-ity: For any two vectors a,b  X  R n their inner product is maximized by sorting a and b in the same in the following fashion: denote by c  X  R n a decreasing nonnegative sequence, then the function is linear in f and maximized with respect to  X  for argsort( f ) . Since c i is decreasing by construction, the Polya-Littlewood-Hardy inequality applies. We found that choosing c i = ( i + 1)  X  0 . 25 produced good results in our experiments. However, we did not formally optimize this parameter. Step 3 (Convex Upper Bound) We adapt a result of [15] which describes how to find convex upper bounds on nonconvex optimization problems.
 Lemma 2 Assume that  X  is defined as in (3). Moreover let  X   X  := argsort(  X  f ) be the ranking  X ( y, X   X  ) . Proof We show convexity first. The argument of the maximization over the permutations  X  is a linear and thus convex function in f . Taking the maximum over a set of convex functions is convex itself, which proves the first claim. To see that it is an upper bound, we use the fact that The second inequality follows from the fact that  X   X  maximizes  X  c,f  X   X   X  . Loss The reasoning in the previous section showed us how to replace the ranking score with a convex upper bound on a regret loss. This allows us to replace the problem of maximizing R ( F,Y ) by that of minimizing a convex function in F , namely Matrix Regularization Having addressed the problem of non-convexity of the performance score we need to find an efficient way of performing capacity control of F , since we only have L ( F,Y train ) at our disposition, whereas we would like to do well on L ( F,Y test ) . The idea to overcome this prob-lem is by means of a regularizer on F , namely the one proposed for Maximum Margin Factorization by Srebro and coworkers[10, 11, 12]. The key idea in their reasoning is to introduce a regularizer on F via More specifically, [12] show that the above is a proper norm on F . While we could use a semidef-inite program as suggested in [11], the latter is intractable for anything but the smallest problems. 4 Instead, we replace F by UM and solve the following problem: Note that the above matrix factorization approach effectively allows us to learn an item matrix M and a user matrix U which will store the specific properties of users and items respectively. This approach learns the features of the items and the users. The dimension d of M  X  R d  X  m and U  X  R d  X  u is chosen mainly based on computational concerns, since a full representation would require d = min( m,u ) . On large problems the storage requirements for the user matrix can be enormous and it is convenient to choose d = 10 or d = 100 .
 Algorithm While (8) may not be jointly convex in M and U any more, it still is convex in M and U individually, whenever the other term is kept fixed. We use this insight to perform alternating sub-space descent as proposed by [10]. Note that the algorithm does not guarantee global convergence, which is a small price to pay for computational tractability. repeat until No more progress is made or a maximum iteration count has been reached.
 Note that on problems of the size of Netflix the matrix Y has 10 8 entries, which means that the number of iterations is typically time limited. We now discuss a general optimization method for solving regularized convex optimization problems. For more details see [14]. Bundle Methods We discuss the optimization over the user matrix U first, that is, consider the problem of minimizing The regularizer tr UU &gt; is rather simple to compute and minimize. On the other hand, L is expensive to compute, since it involves maximizing l for all users.
 Bundle methods, as proposed in [14] aim to overcome this problem by performing successive Taylor approximations of L and by using them as lower bounds. In other words, they exploit the fact that Algorithm 1 Bundle Method( )
Initialize t = 0 ,U 0 = 0 , b 0 = 0 and H =  X  repeat until H  X  L  X  Since this holds for arbitrary M 0 , we may pick a set of M i and use the maximum over the Taylor approximations at locations M i to lower-bound L . Subsequently, we minimize this piecewise linear lower bound in combination with  X  2 tr UU &gt; to obtain a new location where to compute our next Taylor approximation and iterate until convergence is achieved. Algorithm 1 provides further details. As we proceed with the optimization, we obtain increasingly tight lower bounds on L ( UM,Y train ) . One may show [14] that the algorithm converges to precision with respect to the minimizer of R ( U ) in O (1 / ) steps. Moreover, the initial distance from the optimal solution enters the bound only logarithmically.
 After solving the optimization problem in U we switch to optimizing over the item matrix M . The algorithm is virtually identical to that in U , except that we now need to use the regularizer in M instead of that in U . We find experimentally that a small number of iterations (less than 10) is more than sufficient for convergence.
 Computing the Loss So far we simply used the loss l ( f,y ) of (4) to define a convex loss with-out any concern to its computability. To implement Algorithm 1, however, we need to be able to solve the maximization of l with respect to the set of permutations  X  efficiently. One may show that computing the  X  which maximizes l ( f,y ) is possible by solving the inear assignment problem min P i P j C i,j X i,j with the cost matrix: Efficient algorithms [7] based on the Hungarian Marriage algorithm (also referred to as the Kuhn-Munkres algorithm) exist for this problem [8]: it turns out that this integer programming problem can be solved by invoking a linear program. This in turn allows us to compute l ( f,y ) efficiently. Computing the Gradients The second ingredient needed for applying the bundle method is to compute the gradients of L ( F,Y ) with respect to F , since this allows us to compute gradients with respect to M and U by applying the chain rule: L decomposes into losses on individual users as described in (6). For each user i only row i of F as in (4) we know that Here we denote by  X   X  the maximizer of of the loss and c  X   X   X  1 denotes the application of the inverse permutation  X   X   X  1 to the vector c . We evaluated C O F I R ANK with the NDCG loss just defined (denoted by C O F I R ANK -NDCG) as well as with loss functions which optimize ordinal regression (C O F I R ANK -Ordinal) and regression (C
O F I R ANK -Regression). C O F I R ANK -Ordinal applies the algorithm described above to preference ranking by optimizing the preference ranking loss. Similarly, C O F I R ANK -Regression optimizes for regression using the root mean squared loss. We looked at two real world evaluation settings:  X  X eak X  and  X  X trong X  [9] generalization on three publicly available data sets: EachMovie, MovieLens and Netflix. Statistics for those can be found in table 1.
 Weak generalization is evaluated by predicting the rank of unrated items for users known at training time. To do so, we randomly select N = 10 , 20 , 50 ratings for each user for training and and evaluate on the remaining ratings. Users with less then 20 , 30 , 60 rated movies where removed to ensure that the we could evaluate on at least 10 movies per user We compare C O F I R ANK -NDCG, C
O F I R ANK -Ordinal, C O F I R ANK -Regression and MMMF [10]. Experimental results are shown in table 2.
 For all C O F I R ANK experiments, we choose  X  = 10 . We did not optimize for this parameter. The results for MMMF were obtained using MATLAB code available from the homepage of the authors of [10]. For those, we used  X  = 1 1 . 9 for EachMovie, and  X  = 1 1 . 6 for MovieLens as it is reported to yield the best results for MMMF. In all experiments, we choose the dimensionality of U and M to be 100 . All C O F I R ANK experiments and those of MMMF on MovieLens were repeated ten times. Unfortunately, we underestimated the runtime and memory requirements of MMMF on EachMovie. Thus, we cannot report results on this data set using MMMF.
 Additionally, we performed some experiments on the Netflix data set. However, we cannot compare to any of the other methods on that data set as to the best of our knowledge, C O F I R ANK is the first collaborative ranking algorithm to be applied to this data set, supposedly because of its large size. Strong generalization is evaluated on users that were not present at training time. We follow the procedure described in [17]: Movies with less than 50 ratings are discarded. The 100 users with the most rated movies are selected as the test set and the methods are trained on the remaining users. In evaluation, 10 , 20 or 50 ratings from those of the 100 test users are selected. For those ratings, the user training procedure is applied to optimize U . M is kept fixed in this process to the values obtained during training. The remaining ratings are tested using the same procedure as for the weak generalization. We repeat the whole process 10 times and again use  X  = 10 and a dimensionality of 100 . We compare C O F I R ANK -NDCG to Gaussian Process Ordinal Regression (GPOR) [3] Gaussian Process Regression (GPR) and the collaborative extensions (CPR, CGPOR) [17]. Table 3 shows our results compared to the ones from [17].
 C
O F I R ANK performs strongly compared to most of the other tested methods. Particularly in the strong generalization setting C O F I R ANK outperforms the existing methods in almost all the settings. Note that all methods except C O F I R ANK and MMMF use additional extracted features which are either provided with the dataset or extracted from the IMDB . MMMF and C O F I R ANK only rely on the rating matrix. In the weak generalization experiments on the MovieLens data, C O F I R ANK performs better for N = 20 but is marginally outperformed by MMMF for the N = 10 and N = 50 cases. We believe that with proper parameter tuning, C O F I R ANK will perform better in these cases. C
O F I R ANK is a novel approach to collaborative filtering which solves the ranking problem faced by webshops directly. It can do so faster and at a higher accuracy than approaches which learn a rating to produce a ranking . C O F I R ANK is adaptable to different loss functions such as NDCG, Regression and Ordinal Regression in a plug-and-play manner. Additionally, C O F I R ANK is well suited for privacy concerned applications, as the optimization itself does not need ratings from the users, but only gradients.
 Our results, which we obtained without parameters tuning , are on par or outperform several of the most successful approaches to collaborative filtering like MMMF, even when they are used with tuned parameters. C O F I R ANK performs best on data sets of realistic sizes such as EachMovie and significantly outperforms other approaches in the strong generalization setting.
 In our experiments, C O F I R ANK shows to be very fast. For example, training on EachMovie with N = 10 can be done in less than ten minutes and uses less than 80 MB of memory on a laptop. For N = 20 , C O F I R ANK obtained a NDCG@10 of 0 . 72 after the first iteration, which also took less than ten minutes. This is the highest NDCG@10 score on that data set we are aware of (apart from the result of C O F I R ANK after convergence). A comparison to MMMF in that regard is difficult, as it is implemented in MATLAB and C O F I R ANK in C++ . However, C O F I R ANK is more than ten times faster than MMMF while using far less memory. In the future, we will exploit the fact that the algorithm is easily parallelizable to obtain even better performance on current multi-core hardware as well as computer clusters. Even the current implementation allows us to report the first results on the Netflix data set for direct ranking optimization.
 [2] C. J. Burges, Q. V. Le, and R. Ragno. Learning to rank with nonsmooth cost functions. In [3] W. Chu and Z. Ghahramani. Gaussian processes for ordinal regression. J. Mach. Learn. Res. , [4] R. Herbrich, T. Graepel, and K. Obermayer. Large margin rank boundaries for ordinal regres-[5] K. Jarvelin and J. Kekalainen. IR evaluation methods for retrieving highly relevant documents. [7] R. Jonker and A. Volgenant. A shortest augmenting path algorithm for dense and sparse linear [8] H.W. Kuhn. The Hungarian method for the assignment problem. Naval Research Logistics [9] B. Marlin. Collaborative filtering: A machine learning perspective. Masters thesis, University [10] J. Rennie and N. Srebro. Fast maximum margin matrix factoriazation for collaborative predic-[11] N. Srebro, J. Rennie, and T. Jaakkola. Maximum-margin matrix factorization. In L. K. Saul, [12] N. Srebro and A. Shraibman. Rank, trace-norm and max-norm. In P. Auer and R. Meir, [13] B. Taskar, C. Guestrin, and D. Koller. Max-margin Markov networks. In S. Thrun, L. Saul, and [14] C.H. Teo, Q. Le, A.J. Smola, and S.V.N. Vishwanathan. A scalable modular convex solver [15] I. Tsochantaridis, T. Joachims, T. Hofmann, and Y. Altun. Large margin methods for structured [16] E. Voorhees. Overview of the TREC 2001 question answering track. In Text REtrieval Con-[17] S. Yu, K. Yu, V. Tresp, and H. P. Kriegel. Collaborative ordinal regression. In W.W. Cohen
