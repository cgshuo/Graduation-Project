 1. Introduction
As the amount of commercial transactions carried out through the Internet increases at a spectacular rate, the interest for partially or totally automating the negotiation of the terms of these transactions has rapidly become a hot research topic [20] . Consequently, automated negotiation has evolved in a few years from a futuristic vision to a promising technology [27] . In particular, optimal strategies for several forms of auto-mated bargaining and auctioning under simplified assumptions have been identified, and the extensions of these results to more realistic settings have been studied by the game-theory and the distributed artificial intel-ligence communities [25,34,36] . Furthermore, several tournaments where automated traders compete to max-imize their profits in electronic auction houses have been organized (e.g. [22,40] ), and their results are quite encouraging.
Software agents are becoming a choice technology for carrying out automated negotiations [36] . In this approach, each party is represented through an agent who interacts either directly with the other parties, or through a broker. The focus of our work is on the automated negotiation aspect of e-commerce. As stated in [24] , automated negotiation is the process by which two or more agents communicate and try to come to a mutually acceptable agreement on some matter. The basic dimensions of automated negotiation are negotia-tion protocols and negotiation strategies. A Negotiation protocol is a set of rules which govern the interaction, and a negotiation strategy is a decision-making model, which participants employ in order to achieve their goal in line with the negotiation protocol. The issue in this context is thus  X  X  X ow to express a negotiation strategy X  X .
This work reports on an implemented system for automated agent negotiation, which is based on ideas of the abstract negotiation model of [13] . That work presented a simple yet expressive framework for specifying negotiating agents X  strategies, in a way that their decisions are predictable and explainable. Specifically, we explore in this paper the suitability of defeasible logic programming [3,18,31] for expressing the decision-mak-ing process of negotiating agents. In agreement with [13] , we argue that defeasible logic is suitable for express-ing negotiation strategies, since it straightforwardly captures concepts such as preferences, hypotheses, arguments and counter-arguments. Although defeasible logic is certainly not an end-user language but rather a developer X  X  one, it could provide a foundation for designing  X  X  X ser-friendly X  X  interfaces for negotiation strat-egy specification. And given the low computational complexity of defeasible logic programming [28] , these strategies can also be executed in real time.

The viability of these ideas is demonstrated through a prototypical implementation, which constitutes the main contribution of the present work. The implemented system, DR-NEGOTIATE, is based on the JADE multi-agent framework, and uses DR-DEVICE [6] as the deductive engine to apply defeasible logic programs (the negotiation strategies). The overall system design is described, and its functionality is demonstrated through a concrete example.

The paper is organized as follows. Section 2 provides a discussion of the overall approach and the under-lying formalisms, with emphasis on the motivation of using defeasible logic programming. Section 3 presents the system architecture, while Sections 4 X 6 illustrate the functionality and use of the system based on a con-crete case. Section 7 discusses related work, and Section 8 concludes the paper with a summary and description of current and future work. 2. Rationale, approach and enabling formalisms 2.1. An architecture for negotiating agents
In this section we briefly present the architecture proposed by Dumas et al. [13] . We view the negotiation process as a set of software agents which interact in order to reach an agreement. Agents participating in a negotiation can interact directly or through a broker. In some situations, the role of a party during the nego-tiation process is almost entirely carried out by the broker. This is the case for instance in some auction houses, where the auction broker takes the place of the seller.

Following an abstract architecture for agents with memory presented in [44] each of the software agents is composed of four modules: (i) a memory which contains the history of the past decisions and interactions of the agent, including its current intentions, (ii) a communication module responsible of receiving and sending messages to the other agents and interacting with the user, (iii) a reasoning module which encodes the decision-making part of the agent, and (iv) a control module which coordinates the other components. As a refinement to this architecture, we choose to express the control module as a finite automaton (see Section 4 ), the com-munication module was implemented using the JADE platform (see Section 3 ), the reasoning module as a defeasible logic program (see next subsection), and the memory as a knowledge base of facts.

Conceptually, each time a negotiating agent is notified of a change in the negotiation status, it updates the base facts stored in the knowledge base accordingly, and it activates the reasoning module. The reasoning module reads these facts from the knowledge base, attempts to deduce new facts and refute existing ones, and updates the derived facts stored in the knowledge base accordingly. Depending on the state of the knowl-edge base after this revision process, the control module determines whether it should ask the communication module to submit a proposal or counter-proposal immediately, wait for some further event, or retract from the negotiation. It is also through the communication module that the control module communicates with the agent responsible of managing the user interface. This separation between the agent responsible of handling the negotiation process, and the one responsible of interacting with the user (e.g. for collecting the parameters of the negotiation, or for displaying its status), adds considerable flexibility to the architecture. In particular, these two agents can be located in different machines, and the negotiating agent can even be mobile. 2.2. Desired properties for negotiation strategy representation formalisms
Before choosing one or several languages for the specification of negotiation strategies, it is important to establish a set of criteria that such languages need to satisfy. The criteria presented below are inspired from those formulated by [21] in the context of techniques for information modeling. They encompass several well-known principles of language design.

Firstly, a language for specifying negotiation strategies needs to be formal , in the sense that its syntax and its semantics should be precisely defined. This ensures that the strategy specifications can be interpreted unam-biguously (both by machines and humans) and that they are both predictable and explainable . In addition, a formal foundation is a prerequisite for verification purposes.

Secondly, the language should be conceptual . This, following the well-known Conceptualization Principle of [17] , effectively means that it should allow its users to focus only and exclusively on aspects related to strat-egies, without having to deal with any aspects related to their realization or implementation. Examples of con-ceptually irrelevant aspects in the context that we consider are: physical data organization and access, platform heterogeneity (e.g. message-passing formats), and book-keeping (e.g. message queue management).
Thirdly, in order to ease the interpretation of strategies and to facilitate their documentation, the language should be comprehensible . Comprehensibility can be achieved by offering a graphical representation, by ensur-ing that the formal and intuitive meanings are as much in line as possible, and by offering structuring mech-anisms (e.g. decomposition). These structuring mechanisms often lead to modularity , which in our setting means that a slight modification to a strategy should concern only a specific part of its specification. Closely related to its comprehensibility, the language that we aim should be suitable , that is, it should offer concepts close to those involved in negotiations.

As we are interested in the automation of the negotiation process, the strategy description language should be executable , and its execution should exhibit acceptable performances even for complex strategies involving many issues (i.e. the execution performance should be scalable ).

Finally, the language that we aim should be sufficiently expressive , that is, it should be able to precisely cap-ture a wide spectrum of strategies. 2.3. On defeasible logic programming
Defeasible reasoning is a simple rule-based approach to reasoning with incomplete and inconsistent infor-mation. It can represent facts, rules, and priorities among rules. This reasoning family comprises defeasible logics [31,3] and Courteous Logic Programs [18] , and has the following characteristics:  X  They are rule-based, without disjunction.  X  Classical negation is used in the heads and bodies of rules, but negation-as-failure is not necessarily used in the object language (it can easily be simulated, if necessary [4] ).  X  Rules may support conflicting conclusions.  X  The logics are skeptical in the sense that conflicting rules do not fire. Thus consistency is preserved.  X  Priorities on rules may be used to resolve some conflicts among rules.  X  The logics take a pragmatic view and have low computational complexity [28] .

Facts denote simple pieces of information deemed to be true regardless of other knowledge items. A typical fact is that an apartment a is air-conditioned: aircon ( a ).

There are two kinds of rules (fuller versions of defeasible logics include also defeaters [3] ): Strict rules are denoted by A ! p , and are interpreted in the classical sense: whenever the premises are indisputable then so is the conclusion. An example of a strict rule is  X  X  Professors are faculty members  X  X . Written formally: profes-sor ( X ) ! faculty ( X ). Inference from strict rules only is called definite inference . Strict rules are intended to define relationships that are definitional in nature, for example ontological knowledge.

Defeasible rules are denoted by A ) p , and can be defeated by contrary evidence. An example of such a rule is faculty ( X ) ) tenured ( X ) which reads as follows:  X  X  Faculty members are typically tenured  X  X . A superiority relation on R is an acyclic relation &gt; on R (that is, the transitive closure of &gt; is irreflexive).
When r 1 &gt; r 2 , then r 1 is called superior to r 2 ,and r
For example, given the defeasible rules which contradict one another, no conclusive decision can be made about whether a visiting professor is ten-ured. But if we introduce a superiority relation &gt; with r be tenured. We assume that the superiority relation is acyclic.

For each literal p we define the set of p-complementary literals C ( p ), that is, the set of literals that cannot hold when p does. Let us consider an example: suppose we have the predicates married and bachelor . Here, we pretation of the predicates, they cannot be true at the same time for one and the same individual. We stipulate that the negation of a literal is always complementary to the literal.
 We now give a short informal presentation of how conclusions are drawn in Defeasible Logic. A conclusion
P can be derived if there is a rule whose conclusion is P , whose prerequisites (antecedents) are either already been proved or given in the case at hand (i.e. facts), and any stronger rule whose conclusion is in C ( P ) has prerequisites that fail to be derived. In other words, a conclusion P is (defeasibly) derivable when:  X  P is a fact; or  X  there is an applicable strict or defeasible rule for P , and either  X  all the rules for P -complementary literals are discarded or  X  every rule for a P -complementary literal is weaker than an applicable strict or defeasible rule for P .
A formal definition of the proof theory is found in [3] . A model-theoretic semantics is found in [29] , and argumentation semantics is discussed in [16] .

In what follows, we rather focus on the application of defeasible logic to automated negotiation. Specifi-cally, we sketch a set of guidelines that can be used to formalize a negotiation strategy in defeasible logic. First of all, the negotiating agent developer needs to conduct an information analysis in order to identify an appro-priate set of predicates to encode the negotiation strategy. These predicates must collectively capture the infor-mation characterizing a given negotiation situation (e.g. negotiation issues, user parameters, thresholds, limit values, histories of offers, etc.) as well as the conclusions that can be derived from a negotiation situation (e.g. the actions that may need to be undertaken at a given point during the negotiation).

Next, the developer needs to identify the constraints over the negotiation, and the business rules governing the negotiation strategy. These constraints and business rules must then be classified as either hard or soft.
Hard constraints (or hard business rules) are those that apply in any situation, regardless of the context. These constraints set the basic boundaries of the negotiating agent behavior, and are used (for example) to model decisions that must be systematically taken when a given condition holds. Hard constraints and hard business rules are formalized directly as strict rules.

Soft constraints (or soft business rules) on the other hand can be violated under particular circumstances (i.e. they have exceptions). They are used to model the guidelines and user preferences that the negotiating agent will consider after making sure that all the hard constraints and rules are met. A soft constraint is for-malized as a team of defeasible rules. A soft constraint is formalized as a team of defeasible rules. Specifically the soft constraint itself is first translated into a defeasible rule in this team, and each exception to the con-straint is then encoded as a separate defeasible rule, whose conclusion is the negation of the conclusion of the defeasible rule corresponding to the soft constraint. For example, if a soft constraint C is formalized by the defeasible rule r 1: A 1, ... , An ) B (meaning that normally if A 1, ... , An hold, then so should B ), if we know that the state of affairs D constitutes an exception to C , then D must be formalized as r 2: D ) B . Since D is an exception to C , we have to specify that r 2 has precedence over r 1, i.e. r 2&gt; r 1.
In the third step, the developer should identify pairs of incompatible literals. Two literals are said to be incompatible if they cannot both hold at the same time, which essentially means that one of the literals implies the negation of the other. Having identified conflicting literals, and with the aid of an inference tool, the devel-oper can then detect conflicting (defeasible) rules, i.e. rules such that the literals appearing in the conclusions are incompatible. As we have alluded to above, no conclusion can be drawn from conflicting rules in defeasible logic, unless these rules are prioritized. For each pair of conflicting defeasible rules, the developer must analyze what will happen when the conjunction of the antecedents of the rules holds, and must deduce a priority between these rules from this analysis. In some cases, this analysis can be partially supported by an automated tool.

Indeed, several criteria for automatically determining priorities among rules have been put forth, one of the most common being the specificity criterion. In a nutshell, a rule is more specific than another one, when it applies in all cases where the other does. In other words, the set of prerequisites of the more general rule is a subset of the set of prerequisites of the more specific rule. In such cases, it can be suggested to the developer to give a higher priority to the more specific rule. However, the developer may decide to do the opposite, since specificity alone is not always an appropriate criterion for ranking rules. In addition, in general, two rules can-not be compared according to the specificity criterion, and thus, the developer must either determine different ranking criteria or perform a manual ranking. 2.4. Why defeasible logics for negotiation strategies
Applying a negotiation strategy in a particular context is an intensive decision-making process. While most aspects of negotiation strategies could be fully captured in classical logic programming (which has a formal semantics and has proven to be a powerful tool for building decision-making systems), this would put a bur-den on the developers of strategies, since logic programming is a generic paradigm and offers nothing specific to strategy specification (such as argumentation, defeasibility, hypothetical reasoning, preferences, etc.).
Accordingly, we propose to use a logic programming language based on non-monotonic reasoning. Among the many members of the family of non-monotonic logics, we choose defeasible logic [3] for the following reasons:  X  A negotiation can be thought of as a dialogue between parties concerning the resolution of a dispute. This suggests that argumentation-based reasoning formalisms are suitable to characterized it. In [16] , it was shown that defeasible logic can be characterized by an argumentation semantics, thus the formal semantics of defeasible logic is in line with the argumentative nature of negotiations.  X  Given the close connection between derivations in Defeasible Logic and arguments, strategies expressed in
Defeasible Logic are explainable.  X  Defeasible logic is a skeptical formalism, meaning that it does not support contradictory conclusions.
Instead it seeks to resolve conflicts. In cases where there is some support for concluding A but also support for concluding A , the logic does not conclude either of them (thus the name  X  X  X keptical X  X ). If the support for A has priority over the support for A then A would be concluded. We believe that non-skeptical rea-soning is inappropriate for modeling decision-making processes such as negotiations, since it is quite useless to deduce both that a decision should be taken, and that it should not be taken.  X  Defeasible logic integrates the concept of priorities between rules, thereby supporting a direct way of mod-eling preferences, without having to attach a metric to them, as it is the case of approaches based on utility functions [32] .  X  Regarding strategy specification, most of the current systems adopt a quantitative approach based on utility functions. Very often, it is not easy to find the right utility functions for a given set of negotiation issues, especially in situations where one needs to express preferences without attaching a metric to them. More-over, utility functions are mostly used to determine preferences that can otherwise be expressed in a more comprehensible and suitable way through defeasible rules and priorities among these rules. For this reason, we believe that defeasible logic is more suitable than, or at least complementary to, strategy specification approaches purely based on utility functions.  X  Defeasible logic has a linear complexity, and existing implementations are able to deal with non-trivial the-ories consisting of over 100,000 rules [30] , offering thus an executable and scalable system. 3. Implemented agent architecture
The agent framework we used is JADE [8,23] , an open-source middleware for the development of distrib-uted multi-agent applications based on the peer-to-peer communication architecture. JADE is Java-based and compliant with the FIPA specification. It provides libraries for agent communication and interaction, based on FIPA standards [14] . It also provides tools for agent lifecycle management, inspection of exchanged mes-sages and debugging. JADE provided us with the agent infrastructure we desired.

For the reasoning module of the agent we used the defeasible reasoning system DR-DEVICE [6] . Its user interface is compatible with RuleML, the main standardization effort for rules on the semantic web and is based on a CLIPS-based implementation of deductive rules [7] .

The architecture of the negotiating agent is depicted in Fig. 1 . When the agent is notified of an external event, such as an incoming message (step 1), the control module initially retrieves a fact template from the local storage unit (step 2) and consequently, the negotiation parameters from the memory (step 3). The tem-plate is an empty placeholder in line with DR-DEVICE system syntax. When the template is filled with the negotiation parameters, is then regarded as  X  X  X he facts X  X . The control module updates the knowledge base with the new facts (step 4) and then activates DR-DEVICE (step 5). DR-DEVICE in turn retrieves from the knowl-edge base the facts, along with the strategy (step 6) and starts the inferencing process. After the inferencing has been completed, the knowledge base is updated with the results (step 7). The control module queries the knowledge base for the result (step 8) and after a short processing an appropriate message is posted to the communication module. 4. The negotiation protocol: an example
As we have already stressed, a basic condition for the automation of the negotiation process among intel-ligent agents is the existence of a negotiation protocol, which encodes the allowed sequences of actions. Our first thought was to use a well-defined protocol for 1 X 1 automated negotiation. Although FIPA provides a plethora of standardized protocols, such as FIPA brokering, FIPA English auction, FIPA Contract net, etc., we found that there is no standard interaction protocol for 1 X 1 automated negotiation.

As a result, we implemented a negotiation protocol proposed in [41] . This protocol is a finite state machine that must be hard-coded to all agents, participating into the negotiation. Bartolini et al. [5] say that most multi-agents systems today use a single negotiation protocol which is usually a finite state machine, hard-coded to all the agents, leading to an inflexible environment, which can accept only agents designed for it.
To overcome this inflexibility they propose a generic interaction protocol which can be parameterized with different negotiation rules and give different negotiation mechanisms. The rules can be exchanged among agents that are able to inform their peers, which protocol they wish to use. Governatori et al. [15] show how to use Defeasible Logic to represent both negotiation protocols and strategies. However, the focus of our work is not on protocol design but rather on declarative negotiation strategy specification, therefore we believe the protocol we use is a good solution for our demonstrator.
 Our protocol is a finite state machine with discrete states and transition. The protocol is depicted in Fig. 2 . INIT is the initial state of the negotiation, PROP_SENT, PROP_REC, PROP_REJ, PROP_ACC,
ACC_PROP, REJ_PROP, represent the states of a negotiation, and TERM is the final state in which there is an agreement, or a failure of agreement between the participants. Send and Recv predicates represent the interactions which cause state transitions. To clarify the function of the protocol we give an example. If the sequence of transitions is the following: INIT ! PROP_SENT ! PROP_REC ! ACC_PROP ! TERM, that means that the agent initially sends a call for proposal message (CFP) to the other negotiating agent (INIT ! PROP_SENT), then it receives a propose message (PROP_SENT ! PROP_REC) and after the evaluation it decides to send an accept message (PROP_REC ! ACC_PROP). Lastly it receives an accept message and the negotiation terminates successfully (ACC_PROP ! TERM). We make the convention that the participant that plays the role of the buyer starts the negotiation by posting a CFP message. So, while the protocol can be used as it is by a buyer, it needs a small modification for a seller. Particularly instead of the transition INIT ! PROP_SENT there should be a transition INIT ! PROP_REC with label  X  X  X ecv CFP X  X . 5. The negotiation strategy: an example
The strategy of a potential buyer or seller during a negotiation scenario is very critical for the outcome of the encounter. Every strategy is indeed designed in line with a particular protocol. As we have already seen, there is a plethora of strategies classified according to different criteria. We based the strategies we used on the work of Tsang and Gosling [43] . They define the simple constrained bargaining game between one buyer and one seller. Some of the most important assumptions are that the seller is constrained by the cost and the num-ber of days within which it has to sell, while the buyer is constrained by its utility and the number of days within which it has to buy. In addition, neither the buyer nor the seller has information about the constraints of the other. The players make alternative bids with the seller to bid first and they can bid only once per day.
An agreement is reached when both buyer and seller bid for the same price. Finally, according to the assump-tions, if a deal cannot be made before a player runs out of time the negotiation terminates. Tsang and Gosling propose a number of different strategies both for buyer and sellers. For our buyer we adopted the simple buyer strategy, whose characteristics are found in Table 1 .

In our work we have modified the strategy of the buyer as follows: Firstly, we relaxed the rule that only one offer per day can be made, which is completely unrealistic in an e-Commerce setting. Instead we allow one offer per negotiation step . The negotiation step is handled by the protocol and increases each time a player (buyer or seller) has made an offer and subsequently has received a counteroffer or another message. So, we speak of time to buy (TTB) and time to sell (TTS), measured in negotiation steps. Secondly, except for the offer-accep-tance criterion we have added an extra check during the offer submission to avoid non-beneficial results for the player (see below). Thirdly, we incorporated into the strategy parameters relevant to the protocol like the state of the negotiation and the step of the negotiation. Lastly, an agreement is reached when both buyer and seller send an  X  X  X gree X  X  message.

For the buyer participating into the negotiation, we used the modified strategy of Tsang and Gosling and we expressed it in defeasible logic and for the seller we used a strategy hard-coded in Java to demonstrate that agents with different architecture can interact without any problems  X  we could have easily expressed the seller X  X  strat-egy in defeasible logic as well. The seller X  X  strategy is quite similar with that of buyer except for the general bid-ding strategy. The seller decreases its offer by a fixed amount and not in a linear fashion like the buyer.
First we express the buyer X  X  strategy in defeasible logic (see Fig. 3 ) and then we give some samples of the strategy expressed in DR-DEVICE X  X  defeasible logic rule language in native CLIPS-like syntax (see Fig. 4 ).
The predicates we use are the following:  X  Step ( s ): The step of the negotiation. When a buyer or seller sends a message and then receives another one the step is increased by one.  X  Counteroffer ( c ): The offer which a buyer or seller receives from the opponent.
  X  Min _ profit ( mp ): The minimum profit the buyer seeks after buying the product.  X  Utility ( u ): The utility of the buyer if it buys the product.  X  Ttb ( ttb ): The time (negotiation steps) the buyer has at its disposal in order to buy the product.  X  State ( st ): The current state of the negotiation according to the protocol. The possible states are: 1. (PROP_SENT): The buyer has already sent a CFP or a PROPOSE message. 2. (PROP_REC): The buyer has already received a PROPOSE message. 3. (PROP_REJ): The buyer has already received a REJECT message. 4. (REJ_PROP): The buyer has rejected the received proposal (i.e. has already sent a REJECT message). 5. (PROP_ACC): The buyer has already received an ACCEPT message. 6. (ACC_PROP): The buyer has accepted the received proposal (i.e. has already sent an ACCEPT  X  Previous _ bid ( prb ): The previous bid of the buyer; if it is zero, then the buyer has not yet made a offer.
Rules R1 X  X 3 define the conditions for the acceptance or rejection of a proposal. More specifically, rule R1 states that if the current state of the negotiation is 2 (i.e. PROP_REC, when the agent has received a  X  X  X ro-pose X  X  message) and if opponent X  X  offer plus the minimum profit is less or equal to half the utility, the count-eroffer is accepted in all cases. R2 describes the case in which opponent X  X  offer plus the minimum profit is greater than its utility and the counteroffer is rejected. There is also an intermediate counteroffer area, between those two limits, whereas the agent cannot immediately accept or reject the proposal, but it should make a counteroffer (see rules R4 X  X 10). Finally, rule R3 defines that if the current state of the negotiation is 5 (i.e. PROP_ACC, when the agent has received an  X  X  X ccept X  X  message) it also sends an  X  X  X ccept X  X  message.
Rules R4 X  X 10 define different bidding scenarios according to the step of the negotiation. There are three levels for the bidding policy: bidding of first step, bidding of last step and general bidding policy. R4 states that if the negotiation is at state 2 (PROP_REC) and at the first step, the utility divided by the ttb (i.e. the starting bid) is offered, when the proposal received is at an intermediate value range (see above). Rules R5 X  X 10 are the rules for the general bidding policy. According to R5, if the current state of the negotiation is 2 (i.e. PRO-
P_REC, the agent has received a  X  X  X ropose X  X  message) but it has not made one (i.e. previous bid is zero), it offers the utility divided by the ttb (i.e. the starting bid). R6 defines that if the current state of the negotiation is 2 (i.e. PROP_REC, the agent has received a  X  X  X ropose X  X  message) and it has made an offer in the previous step, it increases linearly its offer, according to the following type:
R7 describes that if the current state of the negotiation is 3 (i.e. PROP_REJ, the agent has received a  X  X  X eject X  X  message) it also offers the above bid. R8 defines that if R7 or R6 is true then the computed amount for the bid is to be offered. However, R9 checks whether the bid to be offered is lower than the utility minus the minimum profit and if it is not, then R10 is fired. Rules R9 and R10 are additional checks that ensure that the offered amount of money for the product is not against the benefit of the buyer. The control and the termination con-dition of the negotiation process are handled by the control module and there is no rule for that purpose. However, this is in accordance to the declarative nature of our negotiation specification scheme.
Regarding the DR-DEVICE version of the negotiation strategy ( Fig. 4 ), instead of predicates two classes are used: buyer and protocol. The former models (as object attributes) information needed for the negotiation strategy that concern solely the buyer, namely the minimum profit the buyer seeks, its utility and its ttb . The protocol class models information regarding the negotiation process, namely the state of the negotiation, the current step, the previous bid of the buyer and the counteroffer received from the seller. Furthermore, both classes hold additional administrative information, such as the names of the buyer and seller agents, and a link between each buyer object with the corresponding protocol instance. 6. Negotiation trace
In this section we demonstrate the operation of the system and we scrutinize a negotiation trace between a buyer agent and a seller agent. The JADE platform provides a special-purpose agent which is called sniffer .
Sniffer can monitor the exchanged messages of two or more agents in the agent platform. We examine the trace from the buyer X  X  viewpoint. The parameters of the negotiation are summarized in Table 2 .
As we can see in Fig. 5 , the buyer initially issues a  X  X  X all for Proposal X  X  message (CFP). At this point, as it is the first time we present a trace, we analyze the structure of exchanged messages. FIPA ACL messages are built up of three layers of languages: (a) elements of the world are defined in an ontology, (b) an agent X  X  inten-tion to describe or alter the world is expressed by a communicative act or speech-act such as INFORM, and (c) statements about the world are expressed by means of a Content Language. In order for agents to be able to reason about the effects of their communication, ACL messages are inserted into proper Agent Interaction Protocols that describe allowed sequences of actions among agents.

At the left-hand side of Fig. 5 one can see all the interactions between the buyer and the seller agent. We analyze the first interaction. The ACL message that corresponds to interaction 1 is depicted next to the inter-actions and is indicated by a solid arrow. The Communicative Act (or Speech-Act) of this ACL message is  X  X  X FP X  X . The Ontology, which both buyer and seller share, is called  X  X  X egotiation X  X  and the used Interaction protocol (or Negotiation Protocol) is called  X  X  X imple-Bargaining X  X . The message content ontology allows agents to model facts, beliefs, allowed actions, hypotheses and predications about a domain [1] . We have developed an RDF Schema ontology for actions that agents can request and perform (e.g. suggest) during the negotiation procedure, and predicates for error messages. We have also defined a few characteristics for the negotiated products.

The content of the message is indicated by the dashed arrow in Fig. 5 . According to the content of the mes-sage, the Actor of the action is Buyer who suggests a negotiation template, about a single item of a black
NOKIA 1100 mobile phone. For the content language, we have used both FIPA SL0 and FIPA-RDF. All the examples we show here use FIPA SL0, whereas Fig. 6 shows an interaction example in RDF. Either of those expressions is wrapped in an XML message, before transmission.

The seller responds with a  X  X  X ropose X  X  and the proposed amount is 1000 ( Fig. 7 ). According to the rule R2 of the buyer X  X  strategy, as long as the relation c +mp&gt; u is true, the buyer keeps rejecting the offer.
As the buyer has rejected the seller X  X  offer, at the next step of the negotiation, the seller decreases its offered amount by 40 (bid decrement) and waits for the response of the buyer ( Fig. 8 ). As the buyer regards (according to its strategy) that the amount of 960 is too high, it continues to reject the offer, without issuing a counteroffer. Although the protocol allows both for a counteroffer or a rejection of a proposal, the decision lies with the agent and is expressed through the strategy.

The seller decreases his offer by another 40, offering 920 ( Fig. 9 ). The buyer still rejects seller X  X  offer and the latter subsequently offers 880 ( Fig. 10 ). As the relation c + mp &gt; u ) 880 + 100 &gt; 1000 is now false, R5 fires and the buyer offers its initial offer, which is the amount u / ttb = 1000/5.

At the next step, the seller offers 840 and waits the buyer for its response ( Fig. 11 ). Rule R6 now fires and buyer offers the amount 600. The seller in turn issues an  X  X  X ccept Proposal X  X  ( Fig. 12 ) message and the nego-tiation terminates. At this point we must notice that if seller X  X  last message were not  X  X  X ccept Proposal X  X , the buyer X  X  control module would issue a  X  X  X ancel X  X  as the ttb would exceed 5.
 7. Related work
Kasbah [10] is an automated negotiation system. Users can create buyer or seller agents and engage in a negotiation. Each agent is provided with some information through a graphical user interface. Such informa-tion includes the date and time within which the agent must buy or sell the item, the desired or reservation price, the lowest (for sellers) or highest (for buyers) price intended to be offered and the strategy that the agent will follow. There are three predefined strategies, which alter the price in linear, quadratic or exponential man-ner, respectively. Negotiation in Kasbah is bilateral and competitive. Kasbah also provides a reputation mech-anism, which allows the buyers or sellers to rate opponent X  X  behavior during the negotiation.

AuctionBot [45] is an auction management system supporting the creation, location and enactment of dif-ferent kinds of auctions. Users can manually interact with the system through an HTML-based interface, or alternatively, they can develop their own arbitrarily complex bidding agents, and connect them to the auction manager through a TCP/IP-level API. This API is generic enough to deal with several kinds of auctions (e.g.
English, Dutch, double, etc.) through a common set of primitives. The task of defining the negotiation strategy is left to the user. Users must develop their own agents form scratch, each time they want to enter a negotiation.
Ref. [42] presents a web-based negotiation system for e-commerce, which uses heuristic techniques. It intro-duces an object-oriented content specification language, which is based on active object model (AOM). The language and its accompanying GUI tools are used both by sellers to advertise their products and by buyers to express their preferences. These are stored in a persistent storage. The same language is also used by clients to define proposals and counter-proposals, which are wrapped in XML. A constraint satisfaction processing component is used for the evaluation of proposals and counter-proposals. Authors adopt a declarative approach and each negotiation strategy is expressed by means of event-trigger rules (ETRs X ). The negotiation protocol is an FSM of allowed sequences of actions.

Our work on DR-NEGOTIATE differs from the works above in that it uses a declarative, logical language for expressing the parties X  negotiation strategies, offering thus greater expressiveness and flexibility and at the same time allowing the strategy specifications to be executed in real time, keeping low the computational complexity.

Ref. [2] presents an approach which is based on heuristic techniques for negotiation. They propose the con-struction of a software agent, which represents its owner and is able to search online auctions, negotiate with sellers and make purchases in an autonomous fashion. The agent not only decides in which auction to partic-ipate but also what bid to offer. Factors which the agents consider to calculate the current maximum bid at any given time are the remaining time, the number of remaining auctions, the level of desperateness, and the level of bargaining desire. These individual constraints are then combined to compose the agent X  X  overall position, i.e. its strategy, using weights. In addition, Dumas et al. [12] develops a probabilistic approach to an agent architecture for assembling software agents that participate in alternative heterogeneous auctions.
ContractBot [33] is an automatic contract negotiation system, which integrates the three phases of e-con-tracting, which are discovery, negotiation and execution. Courteous Logic Programs [18] are used to represent contracts and rules in general. A basic concept is that of a contract template. It is a declarative description of all possible outcomes with additional rules, which influence the structure of negotiation. Contract templates have two parts. The proto-contract and the negotiation level rules. The proto-contract refers to conditions of the deal such as the delivery options, payment options, guaranties, etc. It is the part of the contract that remains unchanged. The negotiation level rules, answer questions like what is to be negotiated and how. In other words, they influence the structure of the negotiation. Transactions in the auctions generate additional rules regarding buyers, sellers, prices, quantities, etc., which along with the proto-contract form the final con-tract. The system integrates with the Michigan AuctionBot, which is an auction server. Furthermore, Grosof and Poon [19] extended ContractBot to incorporate process knowledge descriptions, i.e. ontologies repre-sented in DAML+OIL. They give a conceptual approach to specifying LP/RuleML rules on top of DL/
DAML + OIL language. e-Mediator [37] is an auction management server. It is a system which uses game-theoretic and constrains satisfaction techniques for negotiation. It supports combinatorial auctions, in which a bidder may place bids on combination of items and may issue simultaneous bids for many combinations. It consists of three basic components: (a) eAuctionHouse, the configurable auction server, (b) eCommitter, the leveled commitment contract optimizer, and (c) eExchangeHouse, the safe exchange planner.
 The focus of the works [2,33,37] is different from our work because they focus on bidding in multiple auctions. In contrast, our work focuses on 2-party negotiations where the negotiation purpose may be other than price.
Tsang and Gosling [43] define the simple constrained bargaining game where one buyer interacts with one seller. They adopt a heuristic approach, and try to find an optimal strategy, by comparing its profit against those by other strategies. The general rules are the following: The seller is constrained by a cost and the num-ber of time units within which it must sell the product ( time to sell  X  tts ). The buyer is constrained by its utility and the number of time units it has to buy the product ( time to buy  X  ttb ). None of the participants have infor-mation about the other X  X  cost, utility and time thresholds. The players make alternative bids with the seller to bid first. Each player bids exactly once per time unit. When both players bid for the same price, a sale is agreed. If a sale cannot be agreed before a player runs out of time, the negotiation terminates. No one has information about the other player X  X  past behavior or performance. Our work adopts a different approach in that the negotiation history may be taken into account, and different negotiation parameters may be set.
Rosencheim and Zlotkin [34] present rules of encounter for state-oriented domains. Their approach is based on game-theoretic techniques for negotiation. In such domains, the goal of the agent is to move the world from an initial state to one or more desired states. There is interaction with other agents and limited resources.
There is the possibility of cooperation, coordination, compromise and conflict. Any goal is described from the set of states that satisfy it. There are primitive operations that an agents alone can do. When these operations are combined into a coherent sequence of actions specifying what both agents are to do, we speak about a joint plan. A joint plan transforms the world in a state that may or may not satisfy both agents. When agents carry out a joint plan, each agent plays some role. Their theory assumes that there is some way of assessing the cost of each role. This measure of cost is essential to how an agent evaluates a joint plan. They use terms such as individual rational and Pareto optimal and tools from game-theory to model agents X  decision-making model.
Compared to this work, DR-NEGOTIATE offers more flexibility in defining negotiation strategies. In addi-tion, it adopts a logic-based approach, which carries argumentation semantics [16] , while [34] is based on game-theoretic methods.

Sierra et al. [38] propose a formal approach for argumentation-based negotiation. They assume that a gen-eral and shared social relation is defined between agents. This relation can be modeled as a binary function, over a set of social roles. Authors assume that participants exchange locutions in a common communication language CL defined over a set of illocutionary particles, whose propositional content is expressed in a shared logical language L. CL accounts for the set of illocutionary particles, necessary to model the set of illocution-ary acts. The acts can be divided in two sets: Inego corresponds to negotiation particles such as offer, request, accept, etc. and Ipers, corresponds to persuasive particles such as appeal, threaten, reward. This work sup-ports more communication acts than DR-NEGOTIATE, but does not offer a general logical language for expressing negotiation strategies. Travel Agent Game in Agentcities (TAGA) [46] is a framework that extends and enhances the Trading Agent Competition (TAC) scenario to work in Agentcities, an open multi-agent environment, based on
FIPA compliant platforms. TAGA uses the semantic web languages and tools (RDF, OWL) to: (a) specify the underlying common ontologies, (b) as a content language within the FIPA ACL messages, (c) as the base for agent knowledge bases via XSB-based reasoning tools, and (d) to describe and reason about ser-vices. TAGA extends FIPA protocols to support different types of auctions. The travel market which
TAGA simulates includes service registries, service brokerage, wholesalers, peer-to-peer transactions, bilat-eral negotiation, etc. This provides a rich test bed for experimenting with agents and web services as well as an interesting scenario to test and challenge agent technology. TAGA operates as a continuous open game and anyone can participate and use his/her own agent strategy to compete with the others. This work adopts a logical approach similar to DR-NEGOTIATE, and addresses more aspects than our work (e.g. brokering). On the other hand, it is tailored to a specific domain, while our system is domain-independent. 8. Conclusions and future work
This paper reports on a system for automated agent negotiation, based on a formal and executable approach to capture the behavior of parties involved in a negotiation. It uses the JADE agent framework, and its major distinctive feature is the use of declarative negotiation strategies. The negotiation strategies are expressed in a declarative rules language, defeasible logic, and are applied using the implemented system
DR-DEVICE. The key ideas and the overall system architecture are described, and a particular negotiation case is presented in detail.

Defeasible logic seems to be a very promising solution when it comes to negotiation strategies and broker-ing preferences modeling. It combines all the desired characteristics of a language for data modeling. More specific, it is formal with well-defined semantics, conceptual with a high potential of abstraction, comprehen-sive, modular and executable. It is also highly expressive as it can model a great number of diverse cases as we have seen in Section 2 .
 We plan to extend our work in various ways.

DR-DEVICE [6] uses a specialized Clips-based syntax for the expression of rules, something which makes the rules complicated. There is a need for writing rules in a more abstract syntax. We intend to use the seman-tic web rule language of DR-DEVICE, which is an extension to RuleML [35] .

We will seek to integrate the agent negotiation and brokering functions in one system. In [11] an agent-based architecture for brokering and negotiation is presented. As a foundation we will use the semantic bro-kering system of [39] which is also based on defeasible logic.

We will implement a graphical user interface for the integrated system. Someone will be able to load, using a file manager, the files which correspond to the rules of negotiation strategy and brokering preferences respec-tively. The user will also be able to adjust negotiation protocol parameters and monitor the progress of the brokering and negotiation procedure. To this end, we will use the graphical rule authoring tool of DR-DEVICE, which is currently under development.

Finally, we will try to explore the argumentative nature of defeasible logic [16] by building Semantic Web agents that negotiate by exchanging logical arguments [26] within the proof layer of the Semantic Web archi-tecture [9] .
 Acknowledgements
This work was partially supported by the UQ Early Career grant on  X  X  X  system for automated agent nego-tiation with defeasible logic-based strategies X  X  and the REWERSE Network of Excellence.

References
