 1. Introduction
The rapid development of wireless networks and powerful portable computer technologies have accelerated the devel-opment of mobile computing technologies, resulting in the increased and widespread use of mobile computing devices.
These mobile units will often disconnect for a prolonged period of time to save battery power as well as communication cost in the mobile wireless computing environment. They also may be disconnected due to the node or wireless channel failure.
In a wireless mobile network, the server may have a high downstream bandwidth broadcasting capability while the upstream bandwidth for mobile clients to the server is very limited. Organizing massive amount of data on wireless communication networks to provide fast and low power access to users equipped with mobile devices, is a new challenge to data management and telecommunication communities [8,14] .

To cope with this challenge, broadcasting has been studied as a possible solution [13,15,18,19] . Acharya et al. proposed a broadcast disks technique for structuring the broadcast in a way that provides an improved performance for data with non-created by assigning data items to different  X  X  X isks X  of varying sizes and speeds, and then multiplexing the disks on the consists of all the broadcast data items with different broadcast frequencies.

The broadcasting model is suitable for many application domains where the size of the database is relatively small but the number of clients is very large. These applications include stock trading, mobile auctions, mobile commerce applications, tion of read-only transactions and a small number of update transactions. For example, the number of stock buyers or bid-violated by update transactions. Thus, a concurrency control scheme is needed to preserve data currency and consistency for mobile transactions [26,32] .

In wireless broadcast environments, conventional concurrency control schemes such as two-phase locking and timestamp ordering are not suitable for the mobile transactions due to the limited bandwidth in the uplink communica-tion channel and the limited battery power of mobile clients [3,7,11,16,17] . There have been many research efforts reported in the literatures that focus on the concurrency control scheme for wireless broadcast environments [2,5,10,20,22,23,25,27,28,33] . Lee et al. proposed a variant of the OCC method called FBOCC (Forward and Backward OCC) that uses forward validation for update transactions and partial backward validations for read-only transactions [24].
However, all the concurrency control methods for wireless broadcast environments including FBOCC method are focused on mobile transactions with uniform data access patterns. Existing methods perform poorly in broadcast disk environments where the data access patterns of mobile transactions are skewed. In broadcast disk environments, compared to a flat broad-cast program, a broadcast cycle usually becomes long to reflect the skewed data access patterns. This will often cause read-only transactions to access the old data items rather than the more updated data items. Furthermore, update mobile trans-with high access frequencies. This problem will increase the average response time of the update mobile transactions and waste the uplink communication bandwidth.

In this paper, we extend FBOCC method so that it can efficiently handle mobile transactions having skewed data access patterns in broadcast disk environments. We call the extension of FBOCC method as OCCBD (Optimistic Concurrency Control for Broadcast Disks). OCCBD method broadcasts the update control information multiple times in a single broadcast cycle.
OCCBD method will allow read-only transactions to access the more updated data while reducing the average response time of update transactions through an early abort and restart. Also, the uplink communication bandwidth for the final validation of the update transaction is reduced. OCCBD method uses a backoff technique to avoid the frequent abort and restart of up-date transactions.

The rest of the paper is organized as follows: In Section 2, we discuss the related works. We describe our proposed OCCBD method in Section 3. Section 4 discusses how to determine the number of minor group cycles in our proposed method. We give the performance analysis of OCCBD method in Section 5. Finally, Section 6 provides concluding remarks. 2. Related works and preliminaries on the concurrency control schemes for mobile transactions in wireless broadcasting environments. We also take a closer look at FBOCC scheme which is the basis of our method. 2.1. Mobile transaction management in wireless broadcast environments
Barbara proposed a modified version of the conventional Optimistic Concurrency Control (OCC) protocol to support both transactions. Shanmugasundaram et al. proposed a weaker correctness criterion called update consistency [28]. Update con-sistency allows read-only transactions to read current and consistent data in wireless broadcast environments without con-tacting the server. However, the serializability is not maintained which is very important in mobile commerce applications such as mobile stocks trading. Lee et al. proposed a method to reduce the response time of mobile read-only transactions by using a predeclaration technique [20 X 22] . However, the predeclaration technique does not support update transactions and the predeclaration process is computationally expensive.
 Pitoura and Chrysanthis proposed three broadcast methods to guarantee the correctness of read-only transactions [27]. However, their three methods have the following problems. The multi-version broadcast method increases the size of the broadcast cycle resulting in the increased response time [27,29,30] . The invalidation-only broadcast method has a low con-these three methods do not support update transactions. Chung et al. proposed a transaction processing protocol that in-creases the autonomy of clients based on the dependency relation among updated data items [5]. Each mobile client uses actions that need to be aborted in their early stages. Since the protocol assumes the asynchronous broadcast, mobile clients have the problem that they must listen to the downstream communication channel continuously.

Lee et al. proposed a concurrency control method using a dynamic adjustment of timestamp ordering to reduce the num-source consumption. However, their method requires read-only transactions to communicate with a server for their validation using uplink communication bandwidth. Since most mobile transactions are read-only in wireless broadcasting environments, their method results in the serious uplink bandwidth and battery resource consumptions. To overcome this problem, Lee et al. proposed a variant of the OCC protocol called FBOCC protocol that uses forward validation for update transactions and partial backward validations for read-only transactions [24]. FBOCC protocol allows the local validation and commitment of read-only mobile transactions. FBOCC protocol also gives update mobile transactions a better chance of commitment. 2.2. FBOCC protocol
The main idea behind FBOCC protocol is to minimize the usage of uplink channel when validating read-only mobile trans-actions as well as update mobile transactions. FBOCC protocol consists of two validation schemes at the mobile clients and the server. They are partial backward validation scheme performed at the mobile clients and forward validation scheme per-formed at the server.

At the mobile clients, all transactions including read-only transactions and update transactions have to perform a partial backward validation at the beginning of every broadcast cycle. The partial backward validation is carried out by comparing beginning of every broadcast cycle. The content of the control information is a set of IDs of data items that was updated (committed) by the update transactions at the server in the last broadcast cycle. The partial backward validation fails when the result of the above comparison gives non-empty set. If the transaction fails the partial backward validation, it will be aborted and restarted. Otherwise, the transaction can proceed. All the transactions committed at the server precede the val-idating transaction in the serialization order.

At the server, forward validation of a transaction is done against currently running transactions. A validating transaction at the server may be a server transaction or a mobile transaction submitted by the mobile clients. This process is based on the assumption that the validating transaction is ahead of every concurrently running transaction still in read phase in the set of the validating transaction and the read set of currently running transactions need to be compared. The conflicting transactions in read phase are aborted and restarted. An update mobile transaction from a mobile client has to perform a performed at the mobile client.

To better describe FBOCC protocol, we give an example of FBOCC protocol in Fig. 1 . We use the example similar to the one Notation :
C i : i th broadcast cycle.
 RS  X  T a  X  : the read set of transaction T a .
 WS  X  T a  X  : the write set of transaction T a .

CI  X  C i  X  : the set of IDs of data objects that have been commited(updated) in the last broadcast cycle C
R a  X  x  X  : read operation of data x for transaction T a .

W a  X  x  X  : write operation of data x for transaction T a c a : the commit of transaction T a .

We use the following set of five transactions given in Example 1 where we have two read-only transactions (i.e., Q validations are performed by FBOCC method.

Example 1. At mobile clients : Q 2 : R 2  X  a  X  R 2  X  b  X  R
At server : U 1 : R 1  X  a  X  W 1  X  a  X  , U 5 : R 5  X  x  X  W
In Fig. 1 , Q 2 cannot pass the partial backward validation in broadcast cycle C ward validation after receiving CI  X  C i  X  . This is because the data conflict is detected between the read set (i.e.,
RS  X  Q 2  X  X f a ; b ; c g ) of validating mobile transaction Q transaction U 1 at the server. RS  X  Q 2  X \ CI  X  C i  X  X f a g indicates that the two transactions U on the data a . Since the committed update transaction U 1 der, Q 2 should be aborted.

The transaction Q 3 passes the partial backward validation because it has no conflicting data against CI  X  C the intersection between RS  X  Q 3  X  X f p ; q g and CI  X  C i date transaction U 4 at the mobile client, U 4 passes the partial backward validation in the broadcast cycle C
U to the server. However, U 4 fails the final validation because the data x is written by U point. This can be detected by checking if the intersection between RS  X  U at time t 4 .If U 5 reaches its validation phase after U 4 process and U 4 can then commit. 3. OCCBD scheme
In this section, we describe our concurrency control method OCCBD (Optimistic Concurrency Control for Broadcast Disks) which is based on FBOCC (Forward and Backward Optimistic Concurrency Control) method. FBOCC method uses backward and forward validations for the concurrency control of transactions. In backward validation, validating of a transaction is ning transactions. The FBOCC method was shown to be effective for the mobile transactions with uniform data access pat-terns of flat broadcast programs. However, the FBOCC method performs poorly in broadcast disk environments where the data access patterns of mobile transactions are skewed. In the broadcast disk environments, servers broadcast popular data items (i.e., hot data) more frequently than unpopular data items (i.e., cold data).

An example of constructing a broadcast program is shown in Fig. 2 where all data items are sorted in descending order by their access probabilities [1]. In this figure, data items 1 and 11 have the highest and lowest access probabilities respec-ing assumptions that will be used for the rest of this paper: All data items have different access probabilities (i.e., frequencies).
 The server uses broadcast disks to disseminate data.
 Mobile transactions are either read-only or update transactions.
 There is no blind update.

Mobile transactions go through partial backward validation with the control information broadcast by the server.
OCCBD consists of GMCCI (Group of Minor Cycle with Control Information) and CRB (Conflict Resolution by Backoff) methods. Using the control information broadcast by the server, GMCCI method improves the effectiveness of the partial backward validation. When there are multiple update transactions competing for the same data to write, the CRB method sibility of further conflicts. In Section 3.1, GMCCI method is discussed. 3.1. GMCCI method
In this section, we explain the GMCCI method which partitions a major cycle of a broadcast disk program into several minor group cycles. A minor group cycle represents a group of consecutive minor cycles in the major cycle. Not only at the beginning of the major cycle, GMCCI method also sends the control information at the beginning of every minor group cycle. We formally define a minor group cycle in Definition 3.1 .

Definition 3.1. Let C m i denote the i th major cycle consisting of m minor cycles, C minor group cycle with c consecutive minor cycles in the i th major cycle. Thus, the minor group cycle G control information periodically at the beginning of every minor group cycle. Fig. 3 gives the example of G the broadcast disk program in Fig. 2 .In Fig. 3 , the major cycle C major cycle C 4 i is partitioned into 2 (i.e., c  X  2) minor group cycles G two consecutive minor cycles C i ; 1 and C i ; 2 . Similarly, the minor group cycle G
C i ; 3 and C i ; 4 . Note that c  X  2 is a divisor of m  X  4.

To prevent mobile clients from reading inconsistent data, all the data items within each minor group cycle should be up-date consistent. Thus, in our GMCCI method, all the updates occurred during the current minor group cycle will be taken effect on the data items that will be broadcast in their next corresponding minor group cycle. We illustrate this problem by using Fig. 3 . Assume that the data item 1 (i.e., 1 old )in C
G . Then, the updated data item (i.e., 1 new ) is not allowed to broadcast in C group cycle G 2 i ; 2 . Next, we give the formal definition of the control information in Definition 3.2 . Definition 3.2. Let the control information CI  X  G c i ; j previous minor group cycle of G c i ; j .

We also use Fig. 3 to give the example of CI  X  G c i ; j  X  . The server in Fig. 3 broadcasts the control information CI  X  G the beginning of the major cycle C 4 i , but it also broadcasts the control information CI  X  G the minor group cycles G 2 i ; 2 and G 2 i  X  1 ; 1 respectively. The control information CI  X  G that were updated during its corresponding previous minor group cycle G the previous C 4 i 1 major cycle. 3.1.1. Backward and forward validation The basic procedures of partial backward validation and the forward validation in GMCCI method is similar those in
FBOCC method proposed in [24]. Since all committed transactions in FBOCC method are serializable, all committed transac-tions in GMCCI method are also serializable. The correctness of serializability of all the committed transactions in FBOCC method is proved in [24]. Thus, we will not describe here the correctness and the details of the partial backward validation and the forward validation procedures in this paper. Instead, we focus on the primary differences between the FBOCC and GMCCI methods.

In the GMCCI method, all transactions at the mobile clients including read-only transactions and update transactions must perform a partial backward validation by using the control information at the beginning of every minor group cycle . performed against the committed update transactions at the server in the last minor group cycle . At the server, the forward the server is either a server transaction or a mobile update transaction submitted by the mobile clients. Fig. 4 describes the partial backward validation method of the GMCCI method which runs at the mobile clients. Unlike the
FBOCC method, the partial validation in the GMCCI method is performed at the beginning of every minor group cycle . Note that in FBOCC method the partial backward validation is performed at beginning of every broadcast (or major) cycle. This difference allows read-only transactions to access more updated data, and reduce the average response time of update trans-actions through an early abort and restart. It will also reduce the amount of uplink communication bandwidth for the final validation of the update transactions.

Fig. 5 describes the forward validation method which runs at the server. Let T update transaction T v must perform a final validation before the forward validation. This is because there might exist some update transactions already committed at the server since the last partial backward validation of T backward validation method in Fig. 4 records the value of G
G . Let G c x ; y be the last minor group cycle number when T validation T v , the mobile client sends the last minor group cycle number of T 3.1.2. Effectiveness of GMCCI method
To show the efficiency of our GMCCI method over the FBOCC method, we reuse Example 1 given in Section 2.2. Fig. 6 shows the schedule of five transactions in Example 1 where their validations are performed by our GMCCI method.
CI  X  G 2 i ; j  X  represents the set of data objects that were updated during the previous minor group cycle of G two minor group cycles in one major (or broadcast) cycle. Note that we assume a major cycle in Fig. 6 consists of four minor cycles, thus representing C 4 i . The transactions Q 2 and U respectively. Thus, their abort times t 1 and t 3 are much earlier than the corresponding abort times t od in Fig. 1 .

Furthermore, unlike U 4 in Fig. 1 , the mobile client does not need to send the final validation request of U due to this early abort. It prevents the wasteful usage of uplink bandwidth for the final validation request of U shows how GMCCI method improves the effectiveness of the partial backward validation. That is, the conflicting transactions in the GMCCI method can be detected and aborted earlier than in the FBOCC method with control information CI s sent at the beginning of every minor group cycle. Thus, the average response times of mobile transactions in the GMCCI method can be significantly reduced because conflicting transactions are aborted and restarted earlier than in the FBOCC method. In the next subsection, the CRB (Conflict Resolution by Backoff) method used in forward validation method is discussed. 3.2. CRB method
The CRB (Conflict Resolution by Backoff) method uses a backoff scheme to distribute the restart times of the aborted
In wireless broadcast environments, an OCC-based method such as the FBOCC method allows only one update transaction to commit among the update conflicting transactions in a broadcast cycle. All the other update conflicting transactions are aborted. They are restarted and aborted again in the next broadcast cycle except for one committed update transaction.
As the data access pattern of mobile update transactions gets skewed, the update transactions competing for the same hot data will be repeatedly aborted and restarted. This repeated abort and restart problem of update transactions will waste the local computing resources of mobile clients and their uplink bandwidth.

We show an example of this problem in Fig. 7 a where the transactions T broadcast cycle C i 2 ; T 1 commits and the others (i.e., T the next broadcast cycle. At the next broadcast cycle C i 1 starts of 4 transactions.

Fig. 7 b shows an example where the CRB method is used. The server detects an update conflict on data x of five transac-tions at the broadcast cycle C i 2 . The server allows transaction T
T ; T 3 ; T 4 ; T 5 ) by providing their corresponding mobile client a unique backoff number. Then, the mobile clients compute their transaction X  X  backoff time by multiplying the backoff number and the time length of a broadcast cycle. After the given backoff time, each transaction aborted at C i 2 restarts at different broadcast cycles. For example, T and it waits for a single broadcast cycle and restarts at C restarts at C i .

The server computes backoff numbers of the aborted transactions by using the start times of the aborted transactions, which prevents some transactions from restarting indefinitely. Note that the aborted transactions at the disconnected mo-started upon reconnection. If the restarted transactions conflicts on some data with other update transactions, then the server will run the CRB method again to resolve the conflict.

The CRB method is a solution to reduce repetitive abort and restarts of conflicting update transactions when their data access patterns are skewed. It serializes the execution of the aborted transactions over the broadcast cycles. By using CRB method, mobile clients can save their local computing resources and uplink bandwidths by reducing the repetitive re-exe-cution of their aborted transactions. The CRB method can be used in both FBOCC and GMCCI methods. If we use the CRB tech-nique in the FBOCC method, the expected waiting time of the backoff transactions will be large. This is because their expected waiting time is computed by multiplying their given backoff number by the time length of the entire broadcast cycle. However, with GMCCI, their expected waiting time is computed by multiplying their given backoff number by the time length of a minor group cycle. Since the period of a minor group cycle is much smaller than that of a major broadcast cycle, the expected waiting time of the backoff transactions is much smaller in the GMCCI method than in the FBOCC method.
We now describe how the CRB method determines backoff numbers. A simple approach is to have a server do a random permutation of all aborted transactions at the end of each minor group cycle. Let the corresponding permutation number of the aborted transaction T is p . Then, the backoff number of the aborted transaction T is p 1. For example, assume that the server has five aborted transactions T 1 , T 2 , T 3 , T 4
T , T 2 , T 3 , T 4 , and T 5 . Assume that the resulting random permutation be h T actions T 1 , T 2 , T 3 , T 4 , and T 5 are 2, 0, 4, 1, and 3. We call CRB method using this simple approach as S-CRB.
However, this simple approach ignores the update conflict interdependency of aborted transactions. In other words, it does not consider the update conflict data items of each aborted transaction when deciding their backoff numbers. We use the previous example to show the problem of the simple approach. Assume that the transactions T date conflict on data item a whereas the transactions T 3 actions T 1 and T 2 do not have any update conflicts with the transaction T
T will be used in the E-CRB method.
 CTS  X  G c i ; j  X  that have an update conflict on data x in
Definition 3.4. Let TS  X  x  X  be the set of transactions in CTS  X  G
STime  X  T  X  be the start time of transaction T . Then, OLT  X  x  X  X h T such that STime  X  T 1  X  6 STime  X  T 2  X  6 6 STime  X  T c  X  .

Definition 3.5. rank  X  OLT  X  x  X  ; T  X  represents the order of transaction T in OLT  X  x  X  X h T rank  X  OLT  X  x  X  ; T a  X  X  1 ; rank  X  OLT  X  x  X  ; T b  X  X  2 ; rank  X  OLT  X  x  X  ; T The E-CRB algorithm is described in Fig. 8 which is executed at the end of the every minor group cycle. To show how E-
CRB algorithm works, we give an example in Table 1 . Transaction T and 30 respectively. They are aborted at the end of a minor group cycle G update conflicts on data a and b , and T 4 and T 5 on data a .

At step 1 in the algorithm in Fig. 8 , we first get CTS  X  G conflictDegree  X  a  X  X  5 and conflictDegree  X  b  X  X  3. Since STime  X  T 25 6 STime  X  T 5  X  X  30, we obtain OLT  X  a  X  X h T 3 ; T 1 ; T 2 for the transactions T 1 , T 2 , T 3 , T 4 , and T 5 . The MaxConflictItems for the transactions T
OLT  X  a  X  X h T 3 ; T 1 ; T 2 ; T 4 ; T 5 i , we compute rank  X  OLT  X  a  X  ; T rank  X  OLT  X  a  X  ; T 5  X  X  5. As a result, the backoff numbers of the transactions T minor group cycle. 4. Determining the number of minor group cycles
In this section, we discuss how to determine the proper number of minor group cycles in the OCCBD method. Since a ser-ver broadcasts the control information at the beginning of every minor group cycle in the OCCBD method, the number of minor group cycles is the same as the broadcast frequency of the control information in a major broadcast cycle. Thus, increasing the number of minor group cycles results in increasing the broadcast frequency of the control information.
When the number of minor group cycles is small, the broadcast frequency of the control information is also small. The small broadcast frequency of the control information will cause read-only and update transactions to have the following the final validations at the server to detect the update conflicts. As a result, many update transactions competing for the same data will be aborted at the server and restarted. This will waste the uplink bandwidths and the computing resources of mobile clients.

On the other hand, when the number of minor group cycles is large, the broadcast frequency of the control information is updated broadcast data. However, they may suffer from frequent local aborts and restarts because the partial backward val-idation applies to read-only transactions more frequently. With the same reason, update transactions have more possibilities to have early local aborts and restarts, which has advantage of saving the uplink bandwidths and the computing resources of mobile clients. The small and large number of minor group cycles have their own advantages and disadvantages for process-ing mobile transactions.

The largest number of minor group cycles is obtained when it is equal to the total number of minor cycles. In this case, the server broadcasts the control information at the beginning of every minor cycle. The smallest number of minor group cycles the major cycle of a broadcast disk program. The main question is how to determine the proper number of minor group cy-cles between the smallest and largest numbers of minor group cycles. Since the number of minor group cycles is the same as
That is, the larger the number of minor group cycles, the more current broadcast data mobile transactions will access. Based on this observation, we will compute the proper number of minor group cycles from the degree of broadcast data currency we want to enforce in the major cycle of a broadcast disk program.

In broadcast disk programs, the list of data is partitioned into multiple disks where each disk contains data with similar access probabilities. Each disk has its relative broadcast frequency and the data assigned to each disk have the same broad-has k broadcast frequency. Then, all data in disk i will be repeatedly broadcast every m words, all data in disk i will appear exactly once within every m we are enforcing the degree i of broadcast data currency based on the frequency of disk i . Note that each minor group cycle consists of m k consecutive minor cycles and the proper number of minor group cycles is k .

As we can see, we can enforce the various degree of broadcast data currency by using different frequencies of disks. As we choose the hotter disk, the degree of broadcast data currency will be increased and vice versa. From the degree of broadcast data currency we want to enforce, we can easily obtain the proper number of minor group cycles. The following definition formalizes the degree of broadcast data currency and its corresponding proper number of minor group cycles.
Definition 4.1. Assume that there are n disks for the broadcast disk program where D disks respectively. Let f  X  i  X  represent the relative frequency of broadcast for each disk D the degree k of broadcast data currency based on disk k . The proper number of minor group cycles for DC  X  D PNMGC  X  DC  X  D k  X  X  where PNMGC  X  DC  X  D k  X  X   X  f  X  k  X  .

Definition 4.1 is illustrated through the example of a broadcast disk program in Fig. 2 .In Fig. 2 , we have three disks D we obtain PNMGC  X  DC  X  D 1  X  X   X  f  X  1  X  X  4 ; PNMGC  X  DC  X  D number of minor group cycles when we want to enforce the degree 2 of broadcast data currency DC  X  D disk program in Fig. 2 . Since PNMGC  X  DC  X  D 2  X  X   X  2, there are two minor group cycles.
 5. Performance analysis
In this section, we analyze the performance of OCCBD (Optimistic Concurrency Control for Broadcast Disks) by comparing it with that of FBOCC (Forward and Backward OCC) method proposed in Lee et al. [24]. We do not consider Lee et al. X  X  another method [23] and Chung et al. X  X  method [5] for our performance analysis because their methods waste uplink bandwidths and battery consumption more than the FBOCC method. Note that the control information is broadcast only once at the begin-ning of the major cycle for FBOCC method. The experiment of the OCCBD method is done for broadcast disks model. To ana-lyze the impact of the CRB method, we analyzed the OOCBD method without and with the CRB method. We address them as
GMCCI (i.e., without CRB method) and OCCBD (i.e., with CRB method). We used a PC with an Intel Pentium 4 CPU 2.60 GHz and 1 GB memory to run our simulation. The simulation model is based on the model described in [24]. The update pattern at model non-uniform access patterns.

The performance metrics we employed are the average response time of mobile transactions, the number of aborts of mo-measured by a simulation of 10,000 times by varying the Zipf parameter, H , and the number of minor groups. The data item consecutive data items from the broadcast channel. The baseline setting for parameters used in this simulation experiments are shown in Table 2 . 5.1. The effect of the number of read operations
In this section, we show that our proposed OCCBD method allows read-only transactions to access the more updated data than FBOCC method. For this, we measure the data access currency of read-only transactions by varying the number of read operations in the transactions from 1 to 10. The data access currency time of read-only transaction T d ; d 2 ; ... ; d i will be defined as DACT  X  T i  X  X  transaction T i read the data d k from the broadcast channel. UpdateTime  X  d ver. Thus, the small value of DACT  X  T i  X  indicates that transaction T values of the parameters used in this experiment.

Fig. 9 shows the average data access currency of read-only transactions in both FBOCC and OCCBD methods by varying their number of read operations from 1 to 10. It clearly shows the data access currency time of read-only transactions for OOCBD method is much less than FBOCC method. Note that in this experiment, both OCCBD with E-CRB and OCCBD with S-CRB methods give the same data access currency since we only consider read-only transactions.

We then show in Fig. 10 the average number of aborts of read-only transactions for OCCBD and FBOCC methods corre-sponding to the average data access currency time in Fig. 9 . It shows that OCCBD method gives much less number of aborts than FBOCC method. For the skewed data access patterns of read-only transactions, FBOCC method require much longer time for them to access all the necessary data before they finally commit than OCCBD method. As a result, the read-only trans-actions in FBOCC method have more possibility to get aborted in the subsequent broadcast cycles by the updates occurred in server than the read-only transactions in OCCBD method. 5.2. The effect of the number of minor groups
In this section, we analyze the performance of our proposed methods GMCCI and OCCBD by varying the number of minor group cycles. The small and large number of minor group cycles have their own advantages and disadvantages for the per-formance of processing mobile transactions as we explained in Section 4. Table 4 gives the specific values of the parameters used in this experiment.
Fig. 11 shows the average response times of mobile transactions for the GMCCI and OCCBD methods when varying the number of minor group cycles. The best average response time is obtained when the degree 2 of the broadcast data currency
DC  X  D 2  X  is enforced over a broadcast disk program. In other words, when PNMGC  X  DC  X  D shown to be minimal. The OCCBD method always give the higher average response time than the GMCCI method due to the This also explains why the OCCBD with E-CRB gives the lower average response time than OCCBD with S-CRB.
When the number of minor group cycles is getting smaller or larger than 8, the average response time increases. When the number of minor group cycles is getting smaller than 8, partial backward validation would be performed less frequently be aborted at the server and restarted. This will increase the average response times of mobile transactions.
On the other hand, when the number of minor group cycles is getting larger than 8, partial backward validation would be performed more frequently at mobile clients and becomes more effective. As a result, mobile transactions can detect data ting bigger among mobile transactions, their frequent local aborts and restarts will increase the average response times of mobile transactions.

Fig. 12 gives the affect of the different number of minor group cycles to the number of aborts of mobile transactions for the GMCCI and OCCBD methods. As the number of minor group cycles increases, the number of aborts increases. This is be-cause partial backward validations apply to mobile transactions more frequently which in turn increase their abortion prob-abilities. Thus, if applications do not require high data currency and the majority of mobile transactions are read-only transactions, a moderate number of minor group cycles is good enough for the efficient processing of mobile transactions in both the GMCCI and OCCBD methods. An interesting thing to note is that GMCCI method gives the higher number of aborts than OCCBD method. This is because GMCCI method do not serializes the execution of the update transactions involved in data update conflicts as OCCBD method. OCCBD with E-CRB gives the higher number of aborts than OCCBD with S-CRB, since E-CRB supports higher concurrency control than S-CRB does.

Finally, we analyze how different number of minor group cycles affects the uplink bandwidth usages of update mobile transactions in the GMCCI and OCCBD methods. For this, we measure the number of final validations performed at server bandwidth usages of update mobile transactions. The reason is that update mobile transactions in the GMCCI and OCCBD methods only use uplink bandwidths when they request the final validations to server for the commits of their updates.
The number of final validations decreases as the number of minor group cycles increases. Increasing number of minor group as shown in Fig. 12 . As a result, update mobile transactions can avoid sending their unnecessary update validation requests to the server which saves the usage of uplink bandwidths.

If the cost of uplink bandwidths usage is very expensive, the large number of minor group cycles would be chosen. Note that Figs. 12 and 13 also show the resource consumption improvement of OCCBD over GMCCI due to the efficiency of E-CRB and S-CRB methods. As we can see, there is a tradeoff between the number of aborts and the number of final validations for choosing the number of minor group cycles. Thus, it is important for mobile applications to choose the proper number of minor group cycles by carefully considering their domain properties. 5.3. The effect of skewness of data access patterns
In this section, we analyze the performance effects of the GMCCI, OCCBD, and FBOCC methods by varying the Zipf param-eter H and the number of minor group cycles. We set the number of broadcast data items to 100 and the number of mobile transactions to 300 in this analysis. The Zipf parameter H represents the skewness of data access pattern of mobile transac-tions. 2 When H varies, the corresponding broadcast program and the number of minor group cycles should be modified accord-ingly. For the modification of the broadcast program, we first fixed the number of broadcast disks to 5 (i.e., D cast disks and NMGC (number of minor group cycles) when H varies. Note that the FBOCC method has a flat broadcast structure regardless of the value of H .

As the data access pattern becomes more skewed, the probability of data access conflicts among mobile transactions will mobile transactions. Thus, we analyze the performance of the GMCCI, OCCBD and FBOCC methods in terms of these three measurements.

Fig. 14 shows the average response times of mobile transactions for three methods according to the skewness of data ac-cess pattern. As H varies from 0.0 to 0.6, the average response times of mobile transactions for the GMCCI, OCCBD, and
FBOCC methods are almost same and they are slowly increased. This is because mobile transactions have low data conflicts methods are increased sharply due to the high data conflicts.
 When H is over 0.7, the GMCCI and OCCBD methods give the much lower average response times than the FBOCC method.
The reason is that the GMCCI and OCCBD methods send the control information at the beginning of every minor group cycle whereas the FBOCC method send the control information only once at the beginning of a major broadcast cycle. Thus, when data access pattern is highly skewed, the GMCCI and OCCBD methods offset the disadvantage of having the longer broadcast cycle than the FBOCC method. That is, with more frequent control information received, the mobile transactions in the
GMCCI and OCCBD methods can detect its data access conflicts by partial backward validation at their early stages and re-start themselves earlier, which leads to the lower average response times. Since the GMCCI method does not have CRB meth-od, it supports higher concurrency than the OCCBD method. As a result, the GMCCI method gives the lower average response time than OCCBD method when H is over 0.7. The OCCBD with E-CRB gives the lower average response time than OCCBD with S-CRB. This is because E-CRB supports higher concurrency than S-CRB. Note that the higher concurrency is obtained at the cost of wasting the local computing resources of mobile clients and their uplink bandwidth.
We show in Fig. 15 the number of aborts of mobile transactions by varying H . The number of aborts of mobile transac-
The increased aborts of mobile transactions result in the increased resource consumption and the larger average response time. When H is less than 0.6, there is not so much performance difference between the FBOCC, GMCCI, and OCCBD methods.
Because the data access patterns of mobile transactions at low H values tend to follow an uniform distribution and thus greatly reduce the probabilities of data access conflicts among mobile transactions. However, as the data access pattern of mobile transactions becomes more skewed, the GMCCI and OCCBD methods give far smaller number of aborts than the
FBOCC method. Among the GMCCI, OCCBD with S-CRB, and OCCBD with E-CRB methods, the OCCBD with S-CRB method gives the lowest average number of aborts. The reason is that the degree of concurrency supported by the OCCBD with S-CRB method is the lowest.

Fig. 16 shows the number of final validations performed in GMCCI, OCCBD with S-CRB, OCCBD with E-CRB, and FBOCC methods by varying H . The number of final validations reflects the amount of uplink communication bandwidths used by update mobile transactions. As data access patterns become skewed, we can clearly observe that the GMCCI and OCCBD methods uses far smaller amount of uplink communication bandwidths than the FBOCC method. When compared to the
FBOCC method, the more frequent broadcast control information of the GMCCI and OCCBD methods allows the update mo-bile transactions in the GMCCI and OCCBD methods can avoid sending their unnecessary update validation requests to the server and save the usage of uplink communication bandwidths.

The average numbers of final validations for the GMCCI, OCCBD with S-CRB, OCCBD with E-CRB methods are almost sim-ilar. As H becomes close to 1.0, they show the small differences reflecting the degree of concurrency the three methods sup-port. Since the GMCCI method supports the highest degree of concurrency among the three methods, it has the largest average number of final validations. 5.4. The effect of different ratio of data items and mobile transactions
In this section, we analyze the performance of the GMCCI, OCCBD with S-CRB and E-CRB, and FBOCC methods by varying the number of broadcast data items is the half of the number of mobile transactions. When q is 20, the number of broadcast data items is 20 times the number of mobile transactions. Table 6 gives the specific values of the parameters used in this experiment.

Fig. 17 shows the average response times of mobile transactions for the GMCCI, OCCBD with S-CRB and E-CRB, and FBOCC and restarted much earlier than the FBOCC method. This tendency is getting more apparent in the longer length of the broad-cast cycle than in the shorter length of the broadcast cycle.
The GMCCI method gives the lowest average response time since it supports the higher concurrency than the OCCBD methods. By the same reason, the OCCBD with E-CRB method gives the lower average response time than the OCCBD with S-CRB method. As q is increased, the average response time difference between the OCCBD with S-CRB and the OCCBD with
E-CRB methods is getting bigger. This shows that the E-CRB method becomes more effective than the S-CRB method when q is large. The OCCBD with E-CRB method gives the average response time similar to that of the GMCCI method and their dif-ference is small.
 Fig. 18 shows the average number of aborts of mobile transactions for the GMCCI, OCCBD with S-CRB and E-CRB, and
FBOCC methods by varying q .As q increases, the number of aborts in all four methods decreases. This is because the increas-ing number of broadcast data items reduces the possibility of data access conflicts among mobile transactions. Since the mo-bile transactions are more likely to have data access conflicts in the small values of q than in the large values of q , the number of aborts in each method decrease rapidly when q increases from 0.5 to 5.0. The four methods give their largest aver-age number of aborts when q is 0.5. 3 Throughout the entire range of q , the FBOCC method gives much higher number of aborts than the other three methods. The other three methods give the more similar number of aborts as q is getting close to 20. The early aborts and restarts of mobile transactions in the GMCCI and OCCBD methods result in giving the less average number of aborts than the FBOCC method.
 We show in Fig. 19 the average number of final validations of mobile transactions in the GMCCI, OCCBD with S-CRB and E-
CRB, and FBOCC methods. The average number of final validations in all four methods decreases sharply when q increases from 0.5 to 3.0. However, it decreases very slowly when q increases from 4.0 to 20.0. That is, the large value of q does not give much impacts on the average number of final validations in all four methods. Compared to the average number of aborts in Fig. 18 , the number of final validations in the FBOCC method is relatively much higher than the other three methods throughout the entire range of q . In other words, the GMCCI and OCCBD methods use far smaller amount of uplink commu-nication bandwidths than the FBOCC method. The more frequent broadcast control information of the GMCCI and OCCBD aborts. As a result, update mobile transactions in the GMCCI and OCCBD methods can avoid sending their unnecessary up-date final validation requests to the server and save the usage of uplink communication bandwidths. 6. Conclusion
In wireless broadcast environments, the conventional concurrency control schemes such as two-phase locking and time-tery powers and uplink communication bandwidths. In this paper, we proposed an efficient concurrency control scheme named the OCCBD (Optimistic Concurrency Control for Broadcast Disks) for mobile transactions with skewed data access patterns in broadcast disk environments. The OCCBD method is a new optimal concurrency control scheme suitable for broadcast disk environments. The OCCBD method allows mobile transactions to access the more updated data, and reduces the average response times of mobile transactions through early aborts and restarts. The OCCBD method also reduces the amount of uplink communication bandwidth for the final validation of the update mobile transactions. We present an in-depth experimental analysis of our method by comparing it with the FBOCC method. Our performance analysis shows that it significantly decreases the average response time, and the amount of uplink bandwidth over the FBOCC method. Acknowledgement This work was supported by the Special Research Grant of Sogang University.

References
