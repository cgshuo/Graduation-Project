 The XML support in relational databases and the SQL /XML language are still relatively new as compared to pu rely relational databases and traditional SQL. Today, most database users have a strong relational and SQL background. SQL/XML enabl es users to perform queries and updates across XML and relat ional data, but many struggle with writing SQL/XML statements o r XQuery update expressions. One reason is the novelty of SQ L/XML and of the XQuery expressions that must be included. An other prob-lem is that the tree structure of the XML data may be unknown or difficult to understand for the user. Evolving XML Schemas as well as hybrid XML/relational schemas make it even harder to write SQL/XML statements. Also, legacy applications use SQL but may require access to XML data without costly c ode changes. Motivated by these challenges, we developed a metho d to gener-ate SQL/XML query and update statements automatical ly. The input is either a GUI or a regular SQL statement th at uses logical data item names irrespective of their actual locati on in relational or XML columns in the database. The output is a SQL /XML statement that queries or updates relational and XM L data as needed to carry out the original user statement. Th is relieves the user and simplifies schema evolution and integratio n. We have prototyped and tested the proposed method on top of DB2 9.5. H.2.3 [ Database Management ]: Languages X  Query languages Languages, Design, Algorithms, SQL, SQL/XML, Translation, Generation, Mapping, XQu ery The development of the relational data model and we ll-defined concepts for data normalization, relational algebra , and query optimization have laid the foundation for the broad commercial success of relational databases. A corner stone of that success is the Structured Query Language (SQL). Today, commerc ial applications in every industry rely heavily on SQL and relational databases. For many companies, these applications i nclude mission-critical systems and constitute a tremendou s investment. Thus, today X  X  database administrators and database application developers typically have a skill set that is heavi ly geared towards relational databases and SQL. XML has continued to emerge as the de-facto standar d for data exchange. The main reasons include that XML is exte nsible, flexible, self-describing, and suitable for combini ng structured, unstructured and semi-structured data. Many enterpr ises also store large amounts of business data permanently as XML, to fulfill auditing and compliance requirements or when XML is more suitable than a relational schema. For example, hig hly variable data is often easier to handle in XML than in relat ional format. In response to these needs, the major database vend ors have added XML capabilities to their products [11] [12] [13]. Additionally, the SQL standard has been extended to include an XML da ta type as well as XML-specific functions and predicates. This is known as SQL/XML [1]. The functions XMLQUERY and XMLTABLE as well as the predicate XMLEXISTS enable users to inc lude XPath, XQuery, and XQuery Update expressions [14] in SQL statements. SQL/XML allows users to query or update XML and rel ational data in an integrated manner. This is necessary bec ause most companies do not manage XML data separately from th eir relational data. Instead, a hybrid database design is commonly used where tables contain a mix of XML and relation al columns. Over several years we have worked with many compani es to as-sist them in the design, implementation, and deploy ment of XML applications on top of DB2. This includes applicati ons in retail [4], government [5], health care [6], finance [10], and others [7]. All observations, challenges, and assumptions descr ibed in this paper are based on our experiences with such real a pplications We frequently observe that the adoption of SQL/XML faces several challenges. When relational legacy applicat ions require access to new XML data, it is often too expensive o r risky to convert them from SQL to SQL/XML. Another frequent challenge is to actually write queries and updates with SQL/XML and XQuery. We see that their use poses a number of problems:  X 
Users need to learn these new languages, which are often perceived as difficult to master. This stems from t he differences between the XML data model and the relational data model.  X 
SQL/XML involves path expressions that navigate the tree structure of XML documents. To write path expressio ns, users must know the structure of the XML data in detail. It is not enough to know which data items exist, it is also n ecessary to know their exact case-sensitive name, namespace, an d location within the document structure. But, this structure is often complex, difficult to understand, or even unknown t o the user.  X 
As more XML documents are accumulated in a database , newer documents may have a different XML Schema than olde r ones. 
This requires queries and updates to work across do cuments for different schemas, which compounds the complexity o f writing 
SQL/XML statements. Also, existing XML queries may need to be changed when the XML Schema evolves.  X 
In a hybrid database, where some data is stored in relational format and some in XML format, users need to know w hich data is in which format before they can write corre ct queries. We have observed that these issues make it difficul t, sometimes even impossible, for users to write correct SQL/XML statements. Therefore we have designed and prototyped a method to generate SQL/XML queries and updates automatically. In the c ase of updates, XQuery transform expressions [14] are generated and included in SQL update statements. We introduce our approach with focus on SQL/XML queries and revisit updates i n Section 6. The input to our generation algorithm is a simple r epresentation of the user query. The input can come from a GUI, QBE (query by example), or web interface where users see logical data items that can be selected for projection, filtering, grouping , or ordering. The input can also be a regular SQL statement that uses logical data item names as column names in the select, where, gr oup-by, and order-by clauses. This paper focuses on the transla tion from SQL to SQL/XML, but similar concepts work for GUI or QB E input. The translation process uses a mapping from logical data item names to their actual locations . Actual locations of data items are described by a relational column name or an XML col umn name with an XPath expression, all required namespaces, and other metadata. We also present a semi-automatic method t o generate the mapping information and to store it in a mappin g table. The mapping table provides benefits beyond the quer y translation: (1) It serves as a metadata repository for all XML and relational data in the database. While relational columns are documented in the system tables of the database, XML columns are often a black box for the end user. The mapping table contains in formation about all XML attributes and elements that carry bu siness data. Even if an XML Schema exists, it may consist of man y schema documents and its notation is too complex to serve as metadata for users who write queries and updates. (2) The mappin g helps users and applications to deal with schema evolution. If XML data for a new (version of a) XML Schema is added to the datab ase, the mapping table can be updated or regenerated while S QL queries remain unchanged. Instead, the translation algorith m uses the updated mapping to generate new SQL/XML statements that take the new schema information into account. The mappin g table is the single point of maintenance for schema evolutio n and relieves users from manually modifying all existing SQL quer ies across all applications that use the database. This resilience was a specific requirement from several companies that we worked w ith. We have implemented the mapping table generation an d the query translation on top of the SQL/XML support in DB2 [12]. The query translation can run either as a Java library in an application or as a Java stored procedure in DB2. The stored pr ocedure takes an SQL statement as parameter, generates and execut es a corre-sponding SQL/XML statement, and returns the desired result set. In Section 2 we introduce the sample data for this paper and provide a brief recap of key SQL/XML concepts. Sect ion 3 describes the content and generation of the mapping table. The translation of queries and updates is explained in Sections 4, 5 and 6. Section 7 discusses schema diversity and Section 8 compares related work. Section 9 concludes with a summary. The examples in this paper are based on the databas e schema with two tables in Figure 1. Figure 2 shows one sample d ocument for the customer table and two documents for the order table. Customer documents are variable in that the Status information is either an element or an attribute. In our exampl e, orders arrive from two different order entry systems and therefor e have two different XML structures that represent the same in formation. The SQL/XML query in Example 1 produces a phone dir ectory for all customers whose status is 1. It returns the relational column cid together with name, country and phone information from the XML column. One row is returned for each Phone element. Since Phone is a repeating element, the row-generating express ion in the XMLTABLE function is $CDOC/c:Customer/c:Phone . This row-generating expression provides the context for the column definitions in the COLUMNS clause. There, th e elements Name and Phone and the attribute Country are extracted and assigned to SQL data types and relational column na mes. These column names are referenced in the select and order -by clauses. The XMLEXISTS predicate in the where clause ensures that only customers are selected whose Status element or attribute is 1. A lot of data-specific knowledge is required to wri te this query. First, a missing or incorrect namespace declaration leads to an empty result set. The element Addr is in a separate namespace which requires an extra declaration. Correct handli ng of name-spaces is typically difficult for users who are new to SQL/XML. Also, the location of the Name and Addr elements relative to the Phone element must be known to write correct relative XP ath ex-pressions in the column definitions. To avoid trunc ation or errors, the user must also know that the customer X  X  name ca n be safely cast to the SQL type varchar(30). It is also critic al to know that Status can be an element or an attribute; otherwise the q uery result will be incomplete. Also, it is not obvious to the end user that Status is always a number so that a numeric predicate is safe and does not fail with a type error. Since tab le and column names in SQL are case-insensitive by default, many users even struggle with the case-sensitivity of XML tags. The mapping and translation mechanism that we propose solves these problems. In this section we first explain the information st ored in the mapping table and then a method to generate it auto matically. The mapping assigns a logical name to each relation al column in the database and to each distinct element or attrib ute name that occurs in an XML column. If the same element or att ribute occurs on multiple different paths, then these paths can b e mapped to the same or different logical names, as we explain late r in this section. Without loss of generality, we exclude non-leaf ele ments from the mapping table, such as Lineitem , and only list leaf elements, i.e. ones that only contain text nodes with the actual b usiness data. For data centric XML we found that users find it mo re useful to query the values of leaf-elements, such as Qty and Price , rather than the values of non-leaf elements, which are def ined as the concatenation of all descendant text nodes. The que ry translation does not depend on this decision. It also works if non-leaf elements are listed and queried, e.g. if mixed cont ent is expected. The overall mapping consists of two parts which are implemented as two tables. The mapping for our sample documents is shown in Tables 1 and 2. The first table maps logical data i tem names to:  X  A column name and a corresponding table name. If the  X  One or more XPath expressions.  X  The repeat level , i.e. the deepest level in an XPath expression  X  An SQL data type that the XML element or attribute can be The logical data item customerID maps to a relational column, as indicated by the special value SQL in the XPath column of the mapping table. The other table maps namespace prefi xes to URIs. This separation from the main mapping table allows us to handle XML data where multiple different namespaces occur in a single path, as for the logical data item country . It is important to distinguish between the two orth ogonal notions of (a) multiple paths per logical data item and (b) multiple occurrences of a given path: (a) A logical data item can be mapped either to the same path in all documents, or to multiple different paths. For example, a customer X  X  status information can be an element in one instance document and an attribute in another. Therefore, th e logical data item status has multiple associated paths. But, we assume that
Logical Data Item Table Column XPath Repeat Level S QL Data Type name customer CDOC /ns1:Customer/ns1:Name 0 varchar(30) country customer CDOC /ns1:Customer/ns2:Addr/@Country 0 varchar(30) phone customer CDOC /ns1:Customer/ns1:Phone 2 varchar(12) email customer CDOC /ns1:Customer/ns1:Email 2 varchar(30) status customer CDOC /ns1:Customer/@Status 0 integer status customer CDOC /ns1:Customer/ns1:Status 0 integer customerID customer cid SQL -integer orderID order ODOC /ns3:Order/@Oid 0 integer customerRef order ODOC /ns3:Order/ns3:CustomerRef 0 integer product order ODOC /ns3:Order/ns3:Lineitem/ns3:Product 2 varchar(50) product order ODOC /ns3:Order/ns3:Product 2 varchar(50) qty order ODOC /ns3:Order/ns3:Lineitem/ns3:Qty 2 double qty order ODOC /ns3:Order/ns3:Product/@Qty 2 double price order ODOC /ns3:Order/ns3:Lineitem/ns3:Price 2 double price order ODOC /ns3:Order/ns3:Product/@Price 2 double 
Prefix Namespace different paths for the same logical data item do n ot occur in the same instance document. We verified in several real XML applications that this assumption is reasonable. If two nodes with the same name appear on different paths in the same document, then they almost always have logically distinct mea nings, despite their identical names. The notable exception is rec ursive XML, which we encounter relatively rarely in real XML ap plications. (b) Separately, any XML element or attribute on any path may oc-cur multiple times in the same document (e.g. /Cust omer/phone). Collecting the required mapping information manuall y is not practical for any but trivial XML data. We found th at for real-world XML data the main mapping table can contain t housands of entries. For example, industry-specific XML Schemas such as FpML, FIXML, OAGIS, HL7, STAR, or UNIFI define thou sands of optional XML elements and attributes. Hence, the population of the mapping table must be automated as much as p ossible. Our mapping tables are populated semi-automatically , either based on a master document or a set of representative instance documents . A master document is generated from an XML Schema and includes all mandatory and optional elem ents and attributes on all possible paths. It also includes elements for all the alternatives defined by xs:choice constructs. Thus, the master document is not necessarily valid for the schema it was generated from. Existing XML tools (e.g. Stylus Studio) can g enerate such a master document from XML Schemas. If an XML Schema does not exist, a set of actual instance documents is us ed as input. We developed SQL/XML statements to populate both ma pping tables from a master document or instance documents . This avoids the implementation of custom code and uses existing XML data-base capabilities. To populate the namespace mappin g (Table 2), an SQL/XML statement with the expression //(*, @*) visits each element and attribute in the XML data. The XQu ery function namespace-uri() obtains each node's namespace.
 Populating the main mapping table is done by a recu rsive SQL/XML statement. It traverses the XML document(s) , collects information for each node, and recursively passes i t to the next level of the tree. This produces all existing paths from the root to the leaves. Due to space limits, Figure 3 only show s a reduced skeleton of the actual query but still conveys key concepts, e.g. the common table expression for the recursive tree traversal. The first SELECT block in Figure 3 retrieves a docu ment X  X  root node together with its name and path. The second le g of the UNION ALL takes the already existing rows in the vi ew pathstable as input. A document X  X  root element has been added to the pathstable in the first step, now all its child nodes are add ed in the same manner. Their paths are composed of the pa rents' paths and the node X  X  local name. All newly added nodes ar e then processed recursively, until no new child nodes are found. The query in Figure 3 does not produce all necessar y information for the mapping table. Additional metadata collecti on must be added to this skeleton. E.g., a node X  X  level in the tree is a column with a counter that starts at 1 for the root and is incremented for each level of the recursion. Also, a logical data i tem name is pro-posed for each node by appending its name to its pa rent's name. To determine a suitable SQL type that an element or attribute val-ue can be cast to, the XQuery expression castable tests whether a node's value can be cast to xs:integer , xs:date , xs:double , and so on. An SQL data type is then assigned accord ingly. This is reasonable although corresponding data types in XML and SQL do not always have identical value spaces. We see t hat XML data in most real-world applications contain values that are well within the value spaces of SQL data types. Also, the SQL/X ML function XMLTABLE is based on the exact same assumption. To check whether multiple nodes with the same path occur in a document, an extra group-by clause aggregates and c ounts nodes that have the same name and parent within a documen t. Note that the elements Price , Qty and Product occur multiple times per document. They do not repeat within their parent, b ut the parent Lineitem repeats. This information is pushed down to all le af nodes to assign the correct repeat level to each node, i.e. either its parent X  X  repeat level or its own repeat level, whic hever is higher. When all these features are added to the query skel eton in Figure 3, the final statement is 1.5 pages long and availa ble upon request. This automated process produces the final mapping t able, unless an administrator with domain knowledge decides to m ake adjust-ments. For example, the administrator can decide th at the nodes /ns3:Order/ns3:Lineitem/ns3:Qty have the same meaning as /ns3:Order/ns3:Product/@Qty and give them the same logical data item name, as in Table 1. She can also define logical names other than the ones generated by the automate d process. Information about the relational columns can be add ed to the mapping table by querying the database catalog. Thi s leads to physical replication of catalog information in our prototype, but can be avoided through the use of views. When XML S chemas evolve or documents for new schemas are added, the mapping tables can be updated incrementally or regenerated. Our current prototype supports a subset of the SQL language as input, where queries can include the following:  X  "select", "from", "where", "group by", and "order b y" clauses  X  conjunction and disjunction of predicates  X  aggregation functions in the select clause  X  joins between XML columns, between relational colum ns,  X  SQL parameter markers Our future work aims to extend the prototype to als o accept "having" clauses, nested sub-selects, SQL "case" ex pressions, grouping sets, OLAP functions such as rank(), and a rbitrary nesting of "and", "or", "not", "any" and "in". The SQL/XML generation process takes the following steps: 1. Parse and analyze the original query (see section 4 .1) 2. Generate XMLTABLE functions (section 4.2) 3. Generate XMLEXISTS predicates (section 4.3) 4. Compose the new query from parts of the original qu ery and When the original query is parsed, select, from, wh ere, group-by, and order-by clauses are separated from one another . All logical data items referenced in the select, group-by, and order-by clauses are divided into two groups, i.e., those that map t o relational columns and those that map to XML columns. The ones that reference relational columns are replaced by the ac tual physical column names listed in the mapping table. In the se lect clause, physical column names are assigned their logical na me as an alias. All logical data items that refer to XML elements o r attributes are grouped by the corresponding XML columns. The logic al items that map to the same XML column are produced by one XMLTABLE function, where each logical item is repre sented by one column definition. In this way, our algorithm assigns a set of logical data items to each XMLTABLE function . This includes logical data items referenced in the order-by or gr oup-by clauses of the SQL query, even if they are not listed in th e select clause. The query in Example 2 returns the ID, name, countr y and status for the customer John Smith . The logical data item customerID maps to a relational column and is replaced by the actual column name cid . The other logical data items reference XML elemen ts or attributes. Since they are all located in the XML c olumn cdoc , our algorithm assigns them to one XMLTABLE function. For the generated SQL/XML query, the original from clause is augmented by the generated XMLTABLE functions. In t he where clause, all predicates on logical data items that r eference relational columns are moved to the generated query unchanged. Predicates that involve at least one logical data item that ma ps to an XML column are translated to XMLEXISTS predicates. In E xample 2, the SQL predicate name = 'John Smith' uses the logical data item name which maps to an XML element. The algorithm turns this into a corresponding XMLEXISTS predicate. (See section 5 for considerations related to the existential seman tics of the XQuery general comparison operators.) If a logical data item that maps to an XML element or attribute is used in mult iple predi-cates, then those are combined in a single XMLEXIST S predicate. The query parsing has determined the number of requ ired XMLTABLE functions (one per XML column that contain s referenced XML data) and has assigned a set of logi cal data items to each. For every logical data item assigned to an XMLTABLE function, step 2a of the generation process retriev es their paths and metadata from the mapping and namespace tables. All name-spaces that occur in any of the retrieved path expr essions for one XMLTABLE function are combined in an XMLNAMESPACES function. Then the row-generating expression and co lumn definitions are built. The row-generating expression defines the context f or all column definitions. The XMLTABLE function returns one row for each node found on the row-generating path, i.e., one or multiple rows per input document. We differentiate two cases, ref erred to as the simple and the nested case. The simple case takes place if each XML element or attribute returned by the XMLTABLE f unction occurs at most once per document. In this case, eac h XML document contributes at most 1 row to the result se t. In this simple case, the row generating expression is determined a s follows. For each logical data item that was previously assigned to the XMLTABLE function, the corresponding path is obtain ed from the mapping table (step 2a). Then the longest commo n prefix of these paths is chosen as the row-generating express ion and is the context for all relative paths in the COLUMNS claus e. Example 2 clarifies how the row-generating expressi on is deter-mined in the simple case. The SQL query uses the lo gical data items customerID , name , country and status . Since customerID refers to a relational column, it is not assigned t o the XMLTABLE function. The three other data items occur at most once per document (simple case). The paths for these logical items are: The longest common prefix is $CDOC/ns1:Customer and used as the row-generating expression in the XMLTABLE fu nction. The nested case occurs if at least one logical data item assigned to the XMLTABLE function can appear multiple times per document. In this case, the row-generating expressi on must generate multiple rows per input document. Repeatin g items are identified in the mapping table by a repeat level g reater than 0. The paths of all repeating items that are assigned to the XMLTABLE function are candidates for the row-genera ting expression. Among them we select the one with the d eepest repeat level (see Section 4.2.2). If multiple items repeat on the same level, the one that occurs first in the mapping tab le is picked. Consider Example 1 in Section 2. The logical data items assigned to the XMLTABLE function are name , country and phone, where phone is the only one that occurs multiple times per doc ument. Its path /c:Customer/c:Phone repeats on level 2 whereas name and country are listed with repeat level 0. The path of the lo gical data item phone is therefore the row-generating expression. The nested case also applies to Example 3. The logical data items assigned to the XMLTABLE function are orderID , product and qty . While orderID occurs at most once per document, product and qty have repeat level 2. Since product is listed before qty in the mapping table, it is selected for the row-gener ating expression. The logical item product is mapped to two paths and the row-generating expression combines both paths using the XQuery comma operator. Thus, multiple relative paths are a lso used in the column expressions for orderID and qty to produce the correct column values. This relies on our assumption that d ifferent paths for the same logical data item do not occur in the same document. In this sub-section we shed more light on using the deepest repeat level to select the row-generating expression. We d escribe cases where this method works and cases where it can lead to errors, and we argue that it is nevertheless a reasonable a pproach. We select the logical data item with the greatest r epeat level for the row-generating expression because we assume tha t (a) it is the one that generates the most rows per input document , and (b) that the remaining items assigned to the XMLTABLE functi on resolve to singletons when relative paths are built for the COLUMNS clause. Assumption (b) is trivially true for all el ements and attributes that occur at most once per document. Th is is shown in Example 1 where the path /c:Customer/c:Phone is the row-generating expression. Using this path as context, the relative paths ../c:Name and ../a:Addr/@Country never produce more than one item since name and country have repeat level 0. Otherwise, the cast to the SQL type varchar(30) wou ld fail. Whenever multiple logical data items with repeat levels greater than 0 are assigned to the same XMLTABLE function, it must be ensured that their column expressions always resolv e to singletons. Selecting the logical data item with th e greatest repeat level to build the row-generating expression is suf ficient in most cases. Example 3 illustrates this observation. The logical data item product is selected for the row-generating expression. The path in the column definition for the item qty , which has the same repeat level as product , resolves to a singleton value although it also occurs multiple times per document. This is because there is at most one Qty element for each Product element. Building the row-generating expression from the ite m that repeats at the deepest level does not guarantee singletons for all column expressions in the XMLTABLE function. One example i s a query that tries to return the logical data items phone and email from the customer data. Both items have the same repeat leve l. No matter which one is chosen for the row-generation expressi on, the other one does not resolve to a singleton in its column d efinition. The reason is that the document structure does not defi ne a relation-ship between individual phone numbers and email add resses. Both elements repeat independently from each other and may occur unequally often. Hence, retrieving phones and email addresses in two columns is not well-defined. A full Cartesian p roduct between all phones and all e-mail addresses typically does not make sense. We therefore use the mapping information (paths and repeat levels) to detect and reject such queries with an e xplanatory message to the user. Thus, using the deepest repeat level to select the row-generating expression is still reasonable a nd safe. The next step in building an XMLTABLE function gene rates a column definition for each assigned logical data it em. Each column definition consists of a column name, a SQL type, and an XQuery expression. The column name is always that o f the corresponding logical data item. Together with the SQL type, this name is obtained from the mapping table. The XQuery expression in each column definition dep ends on two logical data items: (1) the logical item for which values are produced in this column, and (2) the logical item t hat contributed the row-generating expression, which provides the c ontext for the column expressions. For both logical data items, two properties must be taken into account: (a) whether the logical item is mapped to one or multiple paths in the mapping table, and (b) whether the item occurs once or multiple times per document (i. e. repeat level 0 or &gt;0). Table 3 shows all possible combinations f or property (a). Both items, (1) and (2), may be mapped to one or mu ltiple paths. This leads to four categories, identified by roman numerals I to IV in Table 3.Table 4 shows the same matrix for proper ty (b). Both items can occur either once per document (repeat le vel 0) or multiple times (repeat level &gt;0). The four categori es are numbered V to VIII (where VII never occurs because our algor ithm always selects the logical item with the greatest repeat l evel for the row-generating expression). Because the two properties (a) and (b) are orthogonal, each category in Table 3 can occur toge ther with each category in Table 4. This leads to 16 combinations. Some of them can be treated similarly; some do not occur at all.

Table 3: Property (a) -No. of paths mapped to a lo gical item (1) (1) The characteristics of an XMLTABLE function (simple vs. nested) and its column definitions can be deduced a fter identifying the applicable categories in Tables 3 a nd 4. When the algorithm detects that a column definition is in category V, a simple case XMLTABLE function must be construc ted. This implies that the row-generating expression is the c ommon prefix of all logical items assigned to the XMLTABLE funct ion. Hence, the relative path expression for the column definit ion is produced by removing this common prefix from the absolute path for the logical data item in the column. To illustrate, con sider the column definition for the logical data item name in Example 2: The XPath expression ns1:Name is built by removing the row-generating expression $CODC/ns1:Customer from the element X  X  absolute path. (This is the combination (I,V) in Ta bles 3 and 4.) If multiple paths are associated with a column X  X  lo gical item, all relative paths are combined. The column definition for the logical item s tatus in Example 2 falls into the combination (III, V). Category III implies that all relative paths for th is logical data item are combined with the XQuery comma operator. A t the same time, category V means that the relative paths are produced by removing the row-generating expression from each ab solute path for this logical data item. Thus, the absolute path s /ns1:Customer/@Status and /ns1:Customer/ns1:Status are combined into the single column expression (ns1:Status, @Status) . The column definitions for other simple case XMLTABLE functions (II, V) and (IV, V) are built id entically. For nested case XMLTABLE functions, column expressi ons are built differently. First, the logical data item tha t is used for the row-generating expression has the column expression '.' . For all other items, the common prefix of the row-generatin g expression and the item's absolute path is removed from this a bsolute path. This produces a relative path. Then we count the nu mber of child steps in the row-generating expression after the common prefix. The same number of parent steps is then added to th e beginning of the relative path for the column definition. Consid er Example 1: the row-generating expression is $CDOC/c:Customer/c:Phone and the absolute path for the logical data item name is $CDOC/c:Customer/c:Name . The common prefix $CDOC/c:Customer/ is removed from this absolute path, leav-ing just c:Name . The row-generating expression has one child step after the common prefix, so we add one parent step to th e column definition. Thus, the final column definitio n and the relative path from $CDOC/c:Customer/c:Phone to c:Name is: This column definition belongs to combination (I,VI ). Combina-tion (I,VIII) is similar in that only one relative path is used in the column expression. To avoid a cast error with the S QL data type, this relative path must produce a singleton. This i s true if the original absolute path up to and including its repe at level is a prefix of the row-generating expression. In this ca se any repeating elements were removed as part of the common prefix and the remaining relative path has no repeating elements. Otherwise, the algorithm detects that the column item repeats independently from the row-generating item and rejects the query with a message that explains why the query cannot produce a meaningful result set. The XQuery expression in a column definition consis ts either of a single relative path (category I in Table 3), or of multiple relative paths which are combined with the XQuery comma oper ator (categories II, III, IV). In the latter cases, a co lumn definition has multiple relative paths to navigate from each path in the row-generating expression to each XML element or attrib ute that is associated with the logical data item in the column definition. This is illustrated in Example 3, where the row-gen erating expression contains two repeating paths, which are:  X  /ns3:Order/ns1:Lineitem/ns3:Product (p1)  X  /ns3:Order/ns3:Product (p2) The logical item qty itself also maps to two paths that repeat:  X  /ns3:Order/ns3:Lineitem/ns3:Qty (q1)  X  /ns3:Order/ns3:Product/@Qty (q2) The relative paths that are required in the column expression for qty are ../ns3:Qty to navigate from p1 to q1, as well as @Qty to navigate from p2 to q2. The paths p1 and q1 belong to the first type of order documents; p2 and q2 to the second ty pe of orders. Hence, relative paths from p1 to q2 and p2 to q1 ar e not needed. The algorithm excludes those paths when it detects that p2 and q1 as well as p1 and p2 repeat independently , i.e. the repeat level of q1 is 2 but the first two steps of q1 are not a pre fix of p2. XMLEXISTS predicates are built from the original pr edicates for logical data items that reference XML columns. Pred icates on the same logical data items are grouped together in the parsing phase. These predicates are combined in one XMLEXISTS pred icate. If both sides of a predicate reference XML columns, su ch as a join, the left-hand side decides which XMLEXISTS the pred icate belongs to. Thus, all predicates that are combined in one XMLEXISTS have the same left-hand side. The first step in generating an XMLEXISTS expressio n is to parse the paths for all logical data items in the predica tes. Namespace prefixes are looked up in the namespace table and n amespace declarations are added to the XMLEXISTS predicate a s needed. The context for the XPath predicate(s) within an XM LEXISTS is the path for the logical data item that is the comm on left-hand side for all predicates in the XMLEXISTS. If multiple pa ths are associated with the left-hand side, their common pr efix is used as context. These cases are shown in Example 2, where the full path $CDOC/ns1:Customer/ns1:Name is used as context, and in Example 1 where only the common prefix of the assoc iated paths, $CDOC/ns1:Customer , is used as the context. The next step is to process all right-hand sides. R ight-hand sides in the original query can include logical data item s, constants, and parameter markers. This determines how a right-hand side is added to the predicate. Constant values can be used as right-hand sides with no or minimal further processing. The fo rmat of date and time may need conversion, depending on the form ats and database system used. SQL parameter markers are con verted to generated variable names and a passing clause is added: If a right-hand side is a logical data item that re fers to an XML column, the associated path is added. If the item m aps to multiple paths, all are added as disjunctions. Logical data items referencing relational columns are added by using the column na me as an XQuery variable, such as $CID in Example 4. In DB2 this variable is implicitly bound to the column value. A lternatively, a passing clause can be generated. Example 4 also illustrate s how joins between XML and relational columns are genera ted. Joins between XML columns are generated similarly. Consider the products table which stores detailed information for each product (Figure 4). Example 5 joins the XML columns of the order and product tables. For each product whose weight is greater than 5, the query retrieves the orderID and product names. The join condition is placed in the row-generating expression be-cause it applies to the logical data item product whose repeat level is &gt;0. Placing the join condition in the XMLEXISTS predicate would cause the same problem as in Example 6 (see s ection 5). If the left-hand side of a predicate is associated wit h multiple paths, all of them are added to the XMLEXISTS and each pat h is combined with all right-hand sides and added as a d isjunction. The translation of SQL to SQL/XML with embedded XQu ery expressions must be aware of semantic differences b etween the languages and their underlying data models. Some of the chal-lenges are described in [5]. We don't claim that we formally over-come all semantic differences. Instead we have take n a pragmatic approach to address semantic differences so that th e implemented solution fits practical use cases that meet our ass umptions. For example, the difference in data types is handled by the SQL/XML standard and its casting rules from XQuery types to SQL types in XMLTABLE functions. No additional measures are appl ied. An-other aspect is that XML and XQuery are order prese rving while SQL and the relational data model are unordered. We target users and applications that come from the data-centric re lational world. They use the SQL order-by clause explicitly if orde ring is desired. One semantic difference to overcome is that of comp arison opera-tors. General comparisons in XQuery (=, &lt;, &gt;, etc.) operate on sequences and have existential semantics, i.e. $i = $j is true if there is at least one item in $i that is equal to a t least one item in $j. In contrast, comparisons in SQL operate on atom ic values. This difference can lead to unexpected results when SQL equality predicates "=" are translated into the XQuery gener al comparisons "=". This is illustrated in Example 6 where both qu eries are syn-tactically correct but the SQL/XML query returns a result (Table 5) that does not match the semantics of the origina l SQL query. The XMLEXISTS predicate in Example 6 selects every document that has a Phone element with the value 123-456-7890 . For each such document, the XMLTABLE function produces rows for all Phone elements that occur, and not just the Phone element that fulfilled the XMLEXISTS predicate. An SQL user view s this result as wrong. Using SQL as the original query la nguage means that the result set should follow SQL semantics. To eliminate the unexpected result rows, our algorithm does not generate the SQL/XML query in Example 6. Instead, it places the predicate into the row generating expression of the XMLTABLE function: This is done whenever there is a predicate on a log ical data item with repeat level &gt;0. With this expression, the new result set for Example 6 contains only the first result row in Tab le 5. Name Phone John Smith 123-456-7890 
John Smith 123-555-6523 Our algorithm generates SQL/XML update statements w ith the same concepts as for queries. XQuery transform expr essions [14] are generated for updates of XML elements or attrib utes. The necessary XPath expressions are assembled from one or multiple paths in the mapping table. Predicates on XML eleme nts or attributes are transformed depending on the repeat level. They are converted to XMLEXISTS predicates if the element or attribute occurs at most once per document (repeat level 0). A predicate on an element or attribute with repeat level &gt; 0 means that only one of multiple occurrences of an element should be upd ated. In this case the predicate is also applied in the transform expression. A simple SQL update statement and the corresponding g enerated SQL/XML update statement are shown in Example 7. In Example 8 the logical data item price is updated, which occurs multiple times per document. The update is restrict ed by a predicate on the logical data item product , which also occurs multiple times. This predicate is converted to an X MLEXISTS predicate in the where clause of the SQL/XML update statement. It allows the database engine to use an XML index t o efficiently locate the required order documents. The predicate is also applied in the XQuery transform expression, to update the p rice of the correct product within a given order. Our mapping and query translation method does not s olve schema diversity and schema integration problems of arbitr ary nature. However, we found that our method can effectively a ddress several common cases of schema diversity and schema evolution that we have encountered in real XML applications. Industry-specific XML Schemas such as FpML, FIXML, HL7, ARTS , ACCORD, OAGIS, and STAR evolve with each new versio n that is released. Elements and attributes may be added, removed, or restructured. Some companies also add custom enhanc ements to these schemas to better fit their business needs. A common requirement that we encountered is to query across documents that belong to different versions of the same schem a in one XML column. Our method supports this requirement. If SQ L statements use logical data item names, the mapping table can be updated to reflect changed or additional schemas without havin g to change existing SQL statements. In particular, mapping a s ingle logical item to multiple possible paths helps to address sc hema diversity. One company that we worked with has subsidiaries th at reside in different countries and use XML tag names in their local languages. Additionally, the document hierarchy has slight varia-tions from country to country although the represen ted data has the same meaning. Queries and updates across docume nts from multiple countries were not easily possible. Conver ting local XML data to a common global XML Schema was not desi rable because (a) converting large data volumes on an ong oing basis is costly; (b) maintaining the data conversion process is labor intensive when new countries (schemas) are added; a nd (c) any data updates based on a global schema would need to be reflected in the original local formats where legacy applicat ions depend on it. The company had 22 critical queries and updates that had to run across XML messages from multiple subsidiaries. Our approach solved this scenario by correctly converti ng all 22 query and update statements -instead of converting data to a common global schema. The one-time labor to map local elem ent names to global logical data items was considered a worthwhi le investment to facilitate the generation of SQL/XML queries and updates. There has been a lot of work on translating XQuery to SQL, but very few papers have been published that deal with the translation of SQL to XQuery. We are not aware of any work that focuses specifically on the generation of SQL/XML instead of XQuery . We are also not aware of previous work that generates SQL update statements with embedded XQuery transform expressions . Although the generation of basic path expressions c an be similar for XQuery and SQL/XML, the construction of XMLTABL E functions and XMLEXISTS predicates is different fro m the gen-eration of FLWOR expressions. For example, column e xpressions in XMLTABLE must produce singletons, which is a res triction that does not exist for general XQuery. SQL/XML que ries can also includes relational predicates or join XML and relational columns, which is not directly possible in XQuery. An SQL to XQuery translation algorithm to access XM L data in a federated environment is presented in [8]. Based on a global relational schema, queries are written in SQL and t ranslated to XQuery before execution on an XML data source. This postulates that a mapping from a global relational schema to a local XML schema exists. However, the paper does not provide any details on this mapping, the information it contains, or how t o generate it. Our work describes the metadata necessary to transl ate SQL to SQL/XML, and presents a method to automatically bui ld the mapping tables. Opposite to [8], our work also shows how to generate SQL/XML updates, XML joins, and queries on mixed XML/relational databases, including joins between X ML and relational data. It is not obvious whether the same can be achieved with the XQuery generation in [8]. Our approach also addresses some challenges related to XML Schema variability o r evolution. Documents for different or evolving schemas can be integrated in one table and queried transparently. This is not ad dressed in [8]. In [2], SQL is converted to XQuery for the special cas e where relational data is exposed to the web using XML as an inter-mediate format. This approach generates XML documen ts from flat, relational data. These documents are evenly s tructured. The SQL to XQuery translation in [2] enables applications to access the relational data as if there was no intermediate XML format. The proposed translation is based on the fixed and known XML document format. Unlike our approach, it is not sui ted to generate queries for arbitrarily structured XML documents. The algorithm shown in [9] has a similar restriction. It uses a translation from SQL to XQuery to provide applicati ons access to data sources in an integrated Data Service Platform . XQuery functions are wrapped around data services and prod uce flat XML structures that resemble relational tables. This fl at XML can be queried with SQL through an SQL to XQuery conversio n. Similar to [2], the query generation depends on the known flat structure of the XML data and it is not applicable to arbitraril y nested XML. The ROX experiments in [3] provide SQL access to XML data by manually defining relational views over the XML data. Each repeating element and its non-repeating children ar e mapped to a separate view, and users write SQL join queries aga inst these views. This approach has the same problem as the tr aditional shredding of XML data, i.e. it often takes dozens a nd sometimes hundreds of relational views (or tables) to represe nt the structure of real-world XML data, such as FpML. This leads to multi-way join queries which are hard to write and to execute efficiently. Writing correct SQL/XML queries and updates require s applica-tion developers to (a) be familiar with SQL/XML, XQ uery, and XQuery Updates, (b) have detailed knowledge of the tree structure of the XML documents in the database, and (c) handl e schema diversity/evolution when needed. To address these c hallenges, we have prototyped a method that translates SQL to SQL /XML statements. The translation uses a mapping table th at assigns logical data item names to the location of XML elem ents and attributes in XML documents. Most of the mapping in formation is generated automatically, a critical prerequisite fo r the applicability of our method. The query translation enables relati onal users to perform queries and updates on XML data while mitig ating the aforementioned challenges. The mapping layer can pr ovide some resilience against schema changes and eases the int egration of diverse XML structures. An administrator with domai n knowl-edge may have to modify selected entries in the map ping table, e.g. if multiple elements with distinct names repre sent the same logical data item. An area for future work is to mi nimize this manual labor, reusing work in the area of schema in tegration. We have implemented the translation algorithm in Ja va as a proto-type on DB2 and have successfully tested it in real XML applica-tion scenarios. It does not yet support all possibl e SQL queries as input, which is subject for future work along with the integration of our method with object-relational mapping framew orks. [1] Eisenberg, A. and Melton, J. "Advancements in [2] Escobar, F.J.C. et al. "XML Information Retrieval U sing [3] Halverson, A. et al. "ROX: Relational over XML". Internat. [4] IBM, DB2 pureXML at Douglas Holding AG, [5] IBM, DB2 pureXML at New York State Tax, [6] IBM, DB2 pureXML at UCLA Health System, [7] IBM, DB2 pureXML Case Studies, [8] Jahnkuhn, H. et al. "Query Transformation of SQL in to [9] Jigyasu, S. et al. "SQL to XQuery Translation in th e [10] Loeser, H., Nicola, M. and Fitzgerald, J. "Index Ch allenges [11] Murthy, R. et al. "Towards an enterprise XML archit ecture", [12] Nicola, M. and Kumar-Chatterjee, P. "DB2 pureXML [13] Rys, M. "XML and Relational Database Management [14] The XQuery Update Facility, 
