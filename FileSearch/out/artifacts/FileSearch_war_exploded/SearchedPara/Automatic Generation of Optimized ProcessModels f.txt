 Scheduling tasks so that the overall execution is efficient and at the same time no constraints are violated continues to be a fundamentally important problem. Process models describe the possible arrangements of the tasks.
 Example 1 . Our application scenario is commissioning. Commissioning means configuring and testing the electronic components of a vehicle during its produc-tion. Process models describe the arrangement of the configuration and testing tasks. For instance, a factory worker has to configure the transmission and to activate the anti-theft system. The transmission can either be manual, i. e., Task M does the configuration, or automatic (Task A ). Task T activates the anti-theft system. Before the activation, a central computer needs to generate a master key (Task G ), and it opens the connection to the specific control unit (Task The connection has to be closed before the process finishes (Task figuration of the transmission and the activation of the anti-theft system require a running engine; Task E turns it on. Figure 1 (a) shows the tasks that may be part of the commissioning. The second column is the expected processing time. Commissioning always has a context, i .e., the variation of the vehicle, its com-ponents, their relationships and the constraints the vehicle currently tested must fulfill. The variation determines which tasks have to be executed, e. g., a car with a manual transmission requires different tasks than a car with an automatic one. model all processes for each possible set of required tasks by hand. This calls for generic process models for several contexts. With such generic models however, one optimal arrangement of tasks for any context does not exist.
 Example 2 . The context characteristic transmission determines the required tasks as follows: If the vehicle has an automatic transmission, the commissioning requires execution of the tasks T c = { E , A , T , C , O , G between the tasks as a graph. Directed edges represent ordering dependencies, while dashed lines represent exclusive dependencies. The graph is the declarative specification we generate the process model from. The extended version of this paper [ 17 ] shows how one can generate such a specification from input in other languages. Section 2 will introduce the notation behind that graph structure. graph of Figure 1 (b). Figure 2 (a) has a shorter processing time if the transmis-sion is automatic (7s to 10s). For a manual transmission in turn, the process model in Figure 2 (b) has a shorter processing time (8s to 10s).
 With at least one process model for each possible context, the number of such models increases exponentially with the number of context characteristics. For instance, 10 context characteristics that are Boolean in nature result in 1024 process models. Next, several models typically are possible for a given context. The problem studied here is how to generate a good process model for a given context from a declarative specification. The model should be good according to predefined quality criteria, e. g., throughput time. Process models that comply with the dependencies can be very different with respect to quality and perfor-mance criteria. Section 4 will show that models generated with our approach are about 50% faster than ones designed by professionals with years of experience. We focus on the restricted case that there are no repetitions, i. e., on process trees with inner nodes seq , and , xor , but not loop . There is a number of set-tings with this characteristic, for instance in manufacturing. In particular, loops are unnatural in commissioning processes, since a feature is tested only once. On the other hand, if a problem occurs and is fixed, a new commissioning process is started. Another assumption, which also holds for commissioning and elsewhere, is that context information together with experience from the past allows to reliably estimate the processing time of individual tasks.
 The generation of a process model from a declarative specification bears cation, as mentioned before. To illustrate, the sequential arrangement of in the absence of any constraint, give way to n ! different process models. For the possible models is not possible. It is challenging to detect a good process model that does not violate any constraint.
 Example 3 . There are four tasks A , B , C ,and D . Suppose that the following constraints exist: B must always occur before A and C ( B  X  A, B  X  C always occurs before C ( D  X  C ). It seems to be a good idea to put parallel, because this might reduce the throughput time. But putting parallel rules out having A and D in parallel.
 Related work in process synthesis is fully automatic only for processes that [ 6 ] requires a process modeler to manually make decisions, and [ 25 ] requires a manual clustering of the constraints. This is not practical, because of the daunt-ing number of possible models. To this end, we propose a novel process synthesis algorithm whose output on the one hand complies with the dependencies and on the other hand is good according to predefined criteria. Our approach is as follows: First, it uses a modular decomposition of the dependencies to detect the prime components. For each prime component, our approach partitions the corre-sponding ordering graph systematically, as follows. It selects a pivot element and generates several smaller ordering graphs from the pivot partition. We reduce the problem in a divide and conquer fashion until it is small enough to explicitly generate all possible models. We repeat this for different pivot elements to have a better coverage according to our quality criterion the throughput time of the process. Other criteria such as overall energy consumption are possible as well. As we show in the evaluation with thousands of non-trivial process models, our approach is efficient, i. e., is able to test thousands of models in under a second, checking for complex constraints. On average, our approach nearly halves the processing time compared to the reference processes, which already are the out-put of a careful intellectual design. Our approach can handle complex real-world specifications containing several hundred dependencies as well as more than one hundred tasks. In our evaluation, the process models generated contain between 98 and 185 tasks, and their arrangement typically is nontrivial.
 for the process generation. Section 4 features our evaluation. Section 5 discusses related work, and Section 6 concludes. A meaningful input for process synthesis is the declarative specification in the form of an ordering relation graph ( org )[ 21 ]. The modular decomposition of a graph yields its components and implies a hierarchical structure of components called the Modular Decomposition Tree ( mdt )[ 15 ], see Subsection 2.3 .The separates the under-specified regions from the fully specified ones. 2.1 Ordering Relation Graph In an ordering relation graph, each node represents a task. Each edge represents a dependency between tasks. The dependencies consist of ordering dependencies, i. e., in which order do the tasks occur, and exclusive dependencies, i. e., when do two tasks exclude each other.
 Definition 1. The ordering relation graph is a directed attributed graph (
V, E ) ,with V being nodes and E  X  V  X  V the edges. Each node corresponds to a task. E consists of two subsets E  X  and E # such that E  X   X  E # =  X  . E  X  defines the ordering relation, i. e., two tasks that should be in a specific order have an edge in E  X  . E  X  is transitive and anti-symmetric: E # defines the exclusiveness relation, i. e., if two tasks exclude each other they share an edge in E # . E # is symmetric, i. e.,  X  ( x, y ) not allow self-edges, i. e.,  X  v  X  V :( v, v )  X  E .
 processing time. The average error of the estimated execution times of our tasks from our application scenario is less than 17%. We had calculated these times by analyzing the logs of existing traces. Definition 2. The neighborhoods N out ( v ) , N in ( v ) of a node ( v ):= { w | w  X  V  X  ( v, w )  X  E  X  } N in ( v ):= { w | w  X  V  X  ( v ) is the set of nodes with an incoming ordering edge from the set of nodes that have an outgoing ordering edge to v V the incoming and outgoing set are defined as N out ( V ):= ( V ):= v  X  V N in ( v ) respectively.
 In contrast to an imperative process language like bpmn , description and not necessarily fully specified. 2.2 Process Tree We want to generate the process model in the form of a process tree (PT). In contrast to a graph-based process model, the process tree has two important characteristics. First, it can be easily transformed into an executable process language, see [ 17 ]. Second, a process tree is sound by default [ 10 ]. This means the following: First, the process will terminate properly. Second, for each task there is at least one process instance containing it. Each process tree is an ordered tree, thus a rooted tree for which an ordering is specified for the children of each vertex. V consists of leaf nodes V t V  X  X  c = V , V t  X  X  c =  X  . Each leaf node corresponds to a task, and each inner node corresponds to a control structure. In this paper we consider three control structures, namely sequence seq , parallel and and exclusive structures correspond to the basic control workflow patterns [ 2 ]. This study focuses on the synthesis of process models without cycles. Hence, we do not define a loop operator. It is possible to model the commissioning processes using those control structures. Each control structure can be translated to another block-oriented language, e. g., ws-bpel , otx , or to a graph-oriented process language, e. g., Petri nets, bpmn . 2.3 Modular Decomposition We want to generate a process tree from the declarative specification, i. e., from the org .Let G =( V, E ) be such a graph. For any W  X  V G ( V W ,E W ) is the sub-graph induced by W ,i.e., V W = E  X  (
W  X  W ). We call W a component iff  X  v, v  X  W , N out ( v and
N in ( v ) \ W = N in ( v ) \ W .Thus v and v have identical neighborhoods outside of
W . In other words, a component consists of tasks with the same dependencies regarding tasks outside of the component.
 Example 4 . The set { T,C } is a component of the graph in Figure 3 (a). incoming edges from E , G ,and O and no outgoing edge except the one to shares the same edges, not considering the inner edge between { T,G } is not a component because T has an incoming edge from not.
 electronic control unit of the vehicle. W is a strong component if, for each com-ponent W  X  V , one of the following holds: W  X  W =  X  , W  X  W Example 5 . Consider a graph G { A, B } and W = { B, C } are components. They are not strong because  X  ,
W W ,or W W . The strong components are { A, B, C } , { A } Decomposition, and the resulting hierarchical structure is called Modular Decom-position Tree ( mdt ). Figure 3 (a) shows the simple ordering relation graph of Figure 1 , its decomposition in four components Figure 3 (b) and the correspond-ing modular decomposition tree Figure 3 (c). [ 15 ] shows that a node with children S 1 ,S 2 ,...,S k is of one of the following: Example 6 . The root node in Figure 3 (c) is a prime node. None of the subsets of the children with size 2 or 3, e. g., { X, E } or { E, Y, Z } A complete component W with the induced graph G W ( V W ,E W plete component can easily be transformed to a process tree deterministically, see [ 21 ]. For a prime component our approach will use a heuristic optimization. Lemma 1. A strong complete component W is of exactly one of four types: trivial : | V W | =1 serial : For every v, v  X  V W : ( v, v )  X  E W  X   X  ( v ,v branch : For every v, v  X  V W : ( v, v )  X  E W parallel : For every v, v  X  V W : ( v, v )  X  E W Proof. The proofs of all lemmas are in [ 17 ]. O ( | V | + | E | ), thus in time linear with the size of the graph  X  We use the to transform the org into a process tree. In this section we explain the conceptual design of our approach. Subsection 3.1 gives an overview, and Subsection 3.2 states how the algorithm handles under-specified regions.
 Algorithm 1. Synthesize( org G , context c ): ProcessTree PT 3.1 Overview of the Automatic Generation Our goal is to automatically generate a process model from a declarative descrip-tion. Algorithm 1 synthesizes a process tree from an org and a context context c determines the required tasks T c (Line 1). We then reduce the to the subgraph G W with the nodes W = T c (Line 2). The algorithm then com-putes a modular decomposition of the org (Line 3 in Algorithm 1 ). The result-ing modular decomposition tree ( mdt ) may contain both complete and prime components. For complete components, a transformation to process fragments Figure 4 . In other words, each prime component stands for an under-specified region. For each prime component P , we use a probabilistic optimization to find a solution (Line 5). We replace P with the solution found (Line 6). synPrime() splits the org of the prime components into partitions. It generates a graph with one node for each of these partitions. The algorithm recursively calls itself, in order to replace each node with a subtree. Finally, our approach transforms the PT into a process language, e. g., bpmn , ws-bpel . 3.2 Under-Specified Regions Each prime component P induces a graph G P =( V P ,E P ).
 strong components that belong to P . Figure 3 shows that the graph prime component P consists of V P = { X , R , Y , Z } with Y ) , ( Z  X  Y ) } . P is not fully specified and thus there does not exist a unique corresponding process tree. Due to the large number of possible process models for a prime graph G P it is not feasible to construct every possible one. regions of the process. Our overall idea is to reduce the size of the graph induced by a prime component iteratively until the number of remaining solutions is low ( tion is to select a pivot node v and detect which nodes ( and which nodes ( V 2 ) can be scheduled in parallel to v two smaller ordering graphs. We repeat this with several different pivot nodes. Our approach randomly selects a node v  X  V P with N out ( Lemma 3 will show why we need this characteristic. The org thus a node v with N out ( v )=  X  always exists.
 Definition 3. The zero neighborhood of a pivot node N (1) ( v ):= N in ( v ) .For i  X  N , i&gt; 1 we define the n ) is a subgraph of the org G P with the nodes N ( i ) ( v as the neighborhood graph. Formally, given a pivot node v graph G v =( V v ,E v ) is as follows The graph contains each non-empty neighborhood as a node.
 Example 7 . For the graph in Figure 3 (b) and the pivot Y N (0) ( Y )= { Y } , N (1) ( Y )= { R , Z } , N (2) ( Y )= { X } The neighborhood graph G Y ( V Y ,E Y ) for the pivot Y is: Example 8 . Figure 5 (a) shows a more complex graph which is a prime com-ponent, i. e., there is no unique corresponding tree. The possible pivot nodes are in violet. The pivot node at the top of Figure 5 (a) leads to the partitioning in Figure 5 (b). Figure 5 (c) shows the respective neighborhood graph. Lemma 2. The partitioning into the neighborhood graph for a pivot all order dependencies. In other words, for each edge ( v following holds: (a)  X  i  X  N (b) v Lemma 2 states that our approach does not loose any dependencies. A sym-metric solution would be to select pivots with N in ( v )= inition of the neighborhood accordingly. However, a pivot  X  X  X  N in ( v ) =  X  would loose a dependency, see Lemma 3 .
 Lemma 3. The neighborhood graph G v forapivotnode v with N out ( v ) =  X  does not preserve the order dependencies.
 Algorithm 2. synPrime (Neighborhood Graph G ( V, E )) : ProcessTree PT Algorithm 2 generates a process tree for an under-specified region, i. e., a prime component. First, the algorithm randomly selects a pivot node and calculates its neighborhood graph G v (Line 2). The parameter defines when the neighborhood graph is small enough to generate a process tree. If the neighborhood graph is too large, the algorithm calls synPrime again, and everything is repeated until the graph is processable. Figure 6 shows the reduc-tion of a neighborhood graph. If our approach selects n 2 then builds the smaller graph on the right hand side.
 domly selects a tree pattern for it (Step 4). A tree pattern is a process tree for the neighborhood graph. The neighborhood graph in Figure 4 (a) contains 5 nodes and 4 edges. For a graph with five nodes thousands of process trees are possible. For the graph in Figure 4 (a) 53 trees are possible, given the con-straints. For most of these 53 process trees, there is another tree with a lower overall processing time, for any processing times of the tasks. If we exclude these dominated trees, three trees remain. Figures 4 (b) and (c) show two of them, ran-domly selected. The tree patterns define which additional dependencies have to be added to generate a block based process model for the specification. [ 17 ] shows and explains all tree patterns for  X   X  [1 , 5]. Figure 4 (d) shows a process tree fulfilling the constraints in Figure 4 (a), but the processing time of the tree in Figure 4 (b) always is shorter.
 The resulting trees differ depending on the probabilistic choices in Algorithm 2 (Line 1) and (Line 4). We select the best process tree found according to quality criteria, e. g., the processing time. We calculate a quality value of each tree as follows. The average processing time for each node in a process tree PT ( calculated recursively with function fit : V X  R . type : V X  X  task , and , seq , xor } is a function to determine the type of the tree node. child n := { c | ( n, c )  X  X } is the set of nodes in the process tree with parent node n . The estimation for the XOR-Split is a worst case analysis, i.e., the processing time is smaller than the estimated one. If the probabilities of the splits are known a priori a more precise average case assumption is possible, algorithm returns the process tree with the highest fitness value. The resulting process tree can easily be transformed to the notation required.
 We have implemented the algorithms in C#. The program receives the as input, see [ 17 ] on how to generate an org from a declarative specification. The output of the program is a process tree that is then transformed to the commissioning process notation otx by a proprietary xslt script written by us. The implementation can handle specifications with several hundreds of tasks and thousands of dependencies in a few minutes, see Section 4 . Our evaluation uses 21 process models from a car manufacturer that specify the testing and commissioning of middle-class vehicles. Each process model reflects several context characteristics which are attached for the generation. The con-text characteristics consist of properties of the vehicle project, of the factory and of the components to put in commission. Professional process developers have designed the process models. The tasks to be executed depend on the com-ponents built into the vehicle to be tested. In cooperation with those domain experts we have built the specification for the 21 process models, i. e., the order-ing relationship graphs, automatically using a knowledge base. See [ 19 ]. The process models contain up to 185 tasks and over 3000 dependencies, including transitive ones. The parameter  X  defines the maximum size of the process trees. The possible number of trees grows exponentially with the maximum size. There-fore, the correct and optimal tree patterns are harder to find for larger values of  X  . Otherwise, a higher value could allow to find a process model with a better processing time. We choose  X  = 5 for our evaluation.
 Table 1 shows the results for commissioning process models A , B ,and C . We have chosen A , B ,and C because they are representative for the whole set, ranging from a relatively small one ( C ) to one of the largest ( B ). For a summary of all models see Table 2 . The second row in Table 1 shows the processing time measured for the process model created by hand. Table 1 then lists the expected processing time of the process ( pt ) and the time our approach needs to generate the respective model (computation time ct ) for 10 to 100,000 iterations. In all cases, the algorithm has been able to generate a process model in less than 100 ms that outperforms the reference process model. After 100,000 iterations (in less than 1.5 minutes) it could find process models with processing times 34%, 37%, and 50% lower than their manually generated counterparts.
 quartile for 7 values of the evaluation. The process models contain between 98 and 185 tasks, and need up to 178s to perform. Our approach requires and  X  37 000 iterations on average to generate the best result found. For all instances our approach has identified a solution that is better than the manually generated one in less than 100 ms. Our approach needs less than 3 iterations to do so in most cases. On average, it nearly halves the processing time of the commissioning process models (47 . 47%) compared to the reference points. are in propols [ 25 ], a temporal constraint specification language. The specifi-cations are transformed into finite state machines and then integrated into one machine. Next, each accepting path is generated from the state machine. An algorithm similar to the  X  -algorithm [ 3 ] is applied to synthesize a process model into small groups, synthesizes a process fragment for each group and manually combines the fragments. For our use case, this approach would require over a hundred state machines for each commissioning process model, and the manual combination would not be feasible. [ 6 ] has specifications with point. It generates a pseudo model from the specification. This model lists all paths that fulfill the ltl formula. [ 6 ] generates an ordering relation graph from the set of paths and uses it to synthesize a process tree. For our use case the generation of all paths would not be feasible. This is because the number of paths grows exponentially with the size of the specification. Even for the small-est process model we have evaluated calculating all paths has not been possible. Process discovery means finding a process model that can reproduce the notation. It generates a graph (directly-follows graph) from the log and tries to find different kinds of cuts in the graph. Each kind of cut refers to a control structure in the process tree ( seq , and , xor , loop ). The cuts partition the graph and allow to hierarchically find a process tree for the log. In contrast to an org , a directly-follows graph is not transitive, and if two nodes are in paral-lel they share a two-way edge (no edge in the org ). It is not possible to find a cut for a prime component, thus the approach of [ 12 ] does not help in case the specification is under-specified. Put differently, the problem statement in [ 12 ] is different from ours; the neighborhood graph of the complete log of a process tree never contains a prime component. For an incomplete log, a prime compo-an incomplete log. The cut with the highest probability is chosen. This means that their algorithm generalizes from the incomplete log and assumes relation-ships that are not present. An org is an upper bound of the possible behavior. Assuming an additional relation would result in a violation of a constraint. An approach different from generating the process model from scratch is to extract information from process models already specified and to create a similar process. [ 7 ]usesa cbr -based method to this end. The search is based on key-words that are annotations of the workflows. [ 9 ] guides the process designer with suggestions on how to complete data-oriented visualization models. The sugges-tions are generated from paths of existing visualization process models stored in a repository. [ 9 ] does not allow building a process model with an and therefore is not sufficient in our case. [ 11 ] predicts which activity pattern (generic process fragment) will follow the partly modeled process. The paths of existing process models are extracted and analyzed with association rule mining. None of the approaches mentioned optimize the runtime or consider constraints. [ 21 ] transforms an unstructured model without cycles into a behaviorally Gateway there is a corresponding Join-Gateway. Structured processes allow an ships between the tasks of a process model and generates an relationships. Next, [ 21 ] decomposes the org into a Modular Decomposition Tree. In contrast to our approach, [ 21 ] generates the org an existing process model and not from a set of compliance rules. The behavior is definite, the result therefore is a unique process model. In our approach in turn, the behavior is under-specified, and several process models are possible. AI planning is the task of defining a set of actions that achieve a specified [ 23 ] uses a genetic algorithm to find a manufacturing plan. Some approaches that synthesize business processes are discussed next: [ 14 ] uses an AI planning approach to synthesize service compositions. Without calling it AI planning, [ 4 ] uses a similar approach for configuration-based workflow composition. [ 5 ]intro-duces a planning algorithm to compose data workflows. None of these studies focuses on optimizing the runtime of the process or considers requirements sim-ilar to ours. These approaches are not applicable to our problem statement. provide maximum flexibility not limited by a process model. In comparison, [ 25 ], [ 6 ] and our approach generate an imperative process model from the declarative support by major vendors is missing. To our knowledge, there is no tool that executes declarative process models comparable to the commissioning of vehicles. We have proposed a novel approach to generate a process model for a specific context automatically, given a set of constraints. We study the restricted case that there are not any repetitions of a task, as is the case in commissioning and elsewhere, e.g., manufacturing. We use a probabilistic search to find a good pro-cess model according to quality criteria that fulfills the constraints. Our approach can handle complex real-world specifications consisting of several hundred con-straints and more than one hundred tasks. The process models generated with our scheme are superior (nearly twice as fast) to ones designed by professional process designers.
 els. One approach could be to detect sese ( S ingle E ntry S ingle E xit) loops in the graph, similarly to [ 21 ] Chapter 6.4. One could also extend the approach to resource dependencies limiting the possible number of parallel executions of certain tasks. One could detect such situations analyzing the graph structure and then add additional dependencies for the generation.

