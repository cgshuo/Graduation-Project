 We study query processing in large graphs that are funda-mental data model underpinning various social networks and Web structures. Given a set of query nodes, we aim to find the groups which the query nodes belong to, as well as the best connection among the groups. Such a query is useful to many applications but the query processing is extremely costly. We define a new notion of Correlation Group ( CG ), which is a set of nodes that are strongly correlated in a large graph G . We then extract the subgraph from G that gives the best connection for the nodes in a CG. To facilitate query processing, we develop an efficient index built upon the CGs. Our experiments show that the CGs are mean-ingful as groups and importantly, the meaningfulness of the query results are justifiable. We also demonstrate the high efficiency of CG computation, index construction and query processing.
 Categories and Subject Descriptors: H.2.8 [Database Management]: Database Applications -Data Mining General Terms: Algorithms Keywords: Connection query, correlated group, social net-works
Graph is known as the most general data model for repre-senting and understanding objects and their relationships in various application domains. In recent years, graph databa ses have become more in use and the volume of graph data in-creases rapidly. Thus, it is important to develop efficient algorithms for processing queries in graph databases.
Let W = ( V W , E W ) be a graph, where V W and E W are the set of nodes and edges in W . The nodes in V W are uniquely labeled and the edges in E W are undirected and weighted. We call W a uniquely-labeled weighted graph , or simply a graph in this paper. Given a set of query nodes, Q , the query processing problem we study in this paper is described as follows: 1. Find the group to which each query node q  X  Q be-2. For the group of each q  X  Q , extract a subgraph from 3. Compute the best connection among the groups of all We name such a query a group-oriented connection query. Group-oriented connection queries are important to a wide range of applications. For example, how organizations and people do business together, how terrorists plan and conduc t terrorist activities together and how the different terrori st groups are related to each other, and how the various social networks behave. It can also be applied to other domains such as gene regulatory networks, viral marketing, the In-ternet, and many more.

One of the challenges in processing group-oriented con-nection queries is the formation of groups for different quer y nodes. Consider two nodes in the graph, how do we decide whether they are in the same group or not? A common way is to consider every maximal clique as a group. However, in many cases we cannot simply consider only the edge con-nection, especially when some edges between the nodes in the clique may have very low edge weight while others have very high edge weights. Therefore, the nodes that belong to the same clique may not really mean that they have close connection with all other nodes. On the contrary, many other structures, such as a star or a ring, may well repre-sent a significant relationship between the nodes and can be considered as a group.

In literature, the proximity graph [4] and the center-piece subgraph ( CEPS ) [8] may be considered as a group. How-ever, the computation of the proximity graph and the CEPS is costly in general, especially for a large graph. Communit y detection [7, 10, 3, 6, 1] can be employed to define groups in a graph as communities; however, communities are usually disjoint with each other, whilst in a large graph such as a social network, many people may belong to different groups at the same time.
We define groups by considering the relation between nodes in a graph. The relation of one node u to another node v is measured by a relevance score based on the concept of Ran-dom Walk with Restart ( RWR ) [9]. There are many ways to define the relevance measure, such as the shortest path and the maximum flow. However, these measures are shown to be inadequate in capturing the relation between two nodes [2]. On the other hand, RWR is robust to various graph structures and has been shown to be able to capture the relationship between people in social networks [8, 9].
Based on the node relation, we define group, called a Cor-relation Group ( CG ), as the set of nodes that are pair-wise related with each other. To avoid redundancy, we require a CG to be the maximum set of nodes that are correlated. For each CG, we also extract a subgraph, called a Correlation subgraph ( C-graph ), that reflects the correlation or relation among the nodes.

To facilitate query processing, we develop an inverted-index built upon the set of CGs. We devise efficient al-gorithms for both the index construction and the query pro-cessing. Our extensive experiments demonstrate the mean-ingfulness of the CGs and the C-graphs, which are shown to indeed capture the relation among the nodes as a group. The results also show the efficiency of the index construction and query processing. We also justify the meaningfulness of our query answer. We start by defining the notion of a group in a graph W (See Section 1 for the definitions of a graph and our problem). Semantically, a group refers to a set of objects that have a certain  X  group  X  relation with each other such that they are regarded as belonging together. We first define this  X  group  X  relation.
 We define correlation between two nodes as follows.
Definition 1 (Correlation). Let u and v be two nodes in W . Let r ( u, v ) be the relevance score from u to v . Let  X  be a predefined minimum relevance threshold . Then, u is related to v if r ( u, v )  X   X  ; u and v are correlated if r ( u, v )  X   X  and r ( v, u )  X   X  .

The relevance score r ( u, v ) in Definition 1 is a measure to quantify the degree of the relation from u to v . We can adopt a specific measure to suit the need of a specific application. For general purpose, in this paper we use Random Walk with Restart to define the relevance score, for its robustness to various graph structures.

After defining the correlation between two nodes, we can now extend the correlation to a set of nodes as follows.
Definition 2 (Correlated Nodeset). Let U be a set of nodes in W . U is a Correlated Nodeset ( CN ) if  X  u, v  X  U , r ( u, v )  X   X  .

It follows from Definition 2 that every node in a CN must be correlated to all nodes (including itself) in the CN. How-ever, the definition of CN reveals that every subset of a CN is also a CN. If we define a group to be a CN, then there are exponentially many groups, the majority of which share many common nodes. To address this problem, we define a group to be a maximal CN as follows.

Definition 3 (Correlation Group). Let U be a set of nodes in W . U is a maximal CN if U is a CN and  X  U  X   X  U such that U  X  is a CN. U is said to be a Correlation Group ( CG ) if and only if U is a maximal CN. A CG U is assigned a correlation score , r ( U ) , as given by the following equation:
For computing the CGs, we only require those relevance scores that are no less than  X  . We define a graph G score based on the relevance scores as follows. The set of nodes in G score is the set of nodes in W . For any two nodes u and v in G score , there is an edge ( u, v ) in G score if r ( u, v )  X   X  and r ( v, u )  X   X  . It is not difficult to see that the set of CGs is just the set of maximal cliques in G score . We can then apply any existing algorithm for computing the set of CGs.
In this section, we devise an index for processing group-oriented connection queries.

First, given the set of CGs, C G , we construct an inverted-index on C G . We define the structure of the inverted-index as follows.

Definition 4 (CG-Index). An inverted-index constructed on C G , called the CG-index , consists of the following com-ponents:
We assign the ID of a CG as follows. Let CGA[ i ][ j ] be the j -th entry in CGA[ i ]. We assign the CG stored in CGA[ i ][ j ] an ID j .

Constructing the CG-index, as shown in Algorithm 3, is straightforward and efficient. Let U be the CG in CGA[ i ][ j ]. We add the ID of U , which is j , to the end of the size-i ID-array of each node u  X  U . The ID-arrays of the nodes are accessed via a link in the NA, while the nodes in the NA can be efficiently accessed via a hashtable.

After we obtain the CGs of the query nodes, we still need to find how the nodes in a CG are connected with each other. Let U be a CG and G U be the subgraph that gives the best connection among the nodes in U . We call G U the correlation subgraph (or C-graph for short) of U . Different methods may be used to compute G U . For example, we may define G U as the induced subgraph of W by U , or we may connect the correlated nodes in U by the shortest paths between them. Since we define correlation by relevance score based on RWR, we use an RWR-based approach to compute G
U by an algorithm similar to that in [1] (Section V.C). Algorithm 3 BuildIndex Input: C G .
 Output: The CG-index built on C G . 1. Store U  X  X  G in CGA[ i ], where | U | = i ; 2. Sort the CGs in each CGA[ i ] in descending order of 3. for each j = 1 , 2 , . . . , in each CGA[ i ] do 4. for each u  X  U in CGA[ i ][ j ] do 5. Insert u into the NA if u is not yet in the NA; 6. Add j to the end of the size-i ID-array of u ;
However, after finding the groups, we also need to com-pute the connection between the groups. For this purpose, we model the relation between the CGs in a graph as follows.
Definition 5 (CG-Graph). A CG-graph is a weighted, undirected graph G = ( V G , E G ) defined as follows:
Intuitively, in Definition 5 we construct the CG-graph G by connecting any two CGs if there is an edge between them in W or if they share any common nodes. In other words, two CGs are connected in G if and only if they are connected in the original graph W . Since we measure the correlation by the relevance scores, we also assign the weights of the edges as the average relevance scores of the nodes that connect the two CGs.
In this section, we discuss how we process a query using the CG-index and the CG-graph.

Given a set of query nodes, Q , we find the set of CGs that contain all nodes in Q by the algorithm FindCG as shown in Algorithm 4.

FindCG first finds the set of all maximal CNs in Q . The purpose of this step is to group the correlated nodes in Q first. Since Q is small, it is efficient to find all maximal CNs in Q .

The CNs that are maximal in Q may not be maximal in the global W ; therefore, in Lines 3-10 of Algorithm 4, FindCG uses the CG-index to find the CG that contains each of the maximal CNs in Q . For each maximal CN U , we begin with the size-| U | ID-arrays of each node u  X  U . We skip all size-i ID-arrays, for i &lt; | U | , because the CGs whose IDs are in a size-i ID-array cannot contain U . The algorithm is simple, as we only need to intersect the size-i ID-arrays and obtain the first CG returned by the intersection. Finally, we return the set of all CGs obtained, which contains all nodes in Q .

According to the way that the CG-index is constructed, the first CG obtained by the intersection is the smallest CG Algorithm 4 FindCG Input: The CG-index, and a set of query nodes Q . Output: The set of CGs that contains all nodes in Q , C Q 1. C Q  X  X  X  ; 2. Find the set of all maximal CNs in Q ; 3. for each maximal CN, U , do 4. for each i = | U | , | U | + 1 , . . . , n , 5. Intersect the size-i ID-array of u ,  X  u  X  U ; 6. if (the intersection returns an ID, j ) 7. Add the CG in CGA[ i ][ j ] to C Q ; 8. Go to Line 3 and continue with next U ; 9. else if (the intersection reaches the end of 10. Go to Line 4 and continue with next i ; 11. return C Q ; that contains U . Here, we favor a smaller CG because the smaller the CG, the larger proportion is U in the CG. When there is a tie between CGs of the same size, the first CG obtained has the highest correlation score since their IDs are ordered according to their correlation scores in the ID-arrays.
 Next, we compute the best connection among the CGs. We model the problem as a Steiner tree problem as follows: given the CG-graph G and a set of CGs C Q , find a subtree of minimal weight which includes all CGs in C Q . However, before we can apply the Steiner tree model, we need to first transform the weight of each edge in G into its inverse, since we are finding the minimum-weight tree.

The minimum-weight Steiner tree problem has a fast al-gorithm [5] that achieves 2-approximation and a complexity stant.

Note that each node in the minimum-weight Steiner tree is a CG; for clearer visualization, we can display the query answer as the Steiner tree, but allow the user to click into a CG to view the detailed relationship between the nodes when he/she is interested.
We assess the performance of CG computation, index con-struction and query processing. We run all experiments on an AMD Opteron 248 with 1GB RAM, running Linux 64-bit.

We use the DBLP co-authorship dataset. The graph has approximately 316K nodes and 1,834K edges, where a node represents an author and the edge weight is the number of papers co-authored between two authors. Due to space limit, we only report part of our results.
In this experiment, we examine the performance of query processing. We select three sets of queries as follows.
The three sets of queries represent three categories of cor-relation between the nodes in a query. For each query in CorQ , the nodes are highly correlated with each other within the query. For each query in RelQ , only part of the nodes in the query are highly correlated while the rest of the query nodes are only related to others (one-way relation). For eac h query in RandQ , the nodes within the query are likely not correlated nor related.

We further classify each set of queries into five groups (each containing 1000 queries) by varying the size of the queries from 2 nodes to 20 nodes. Figure 1 shows the re-sults of the query response time averaged over 1000 queries. The response time increases linearly with the increase in th e query size. However, the worst response time for queries of 20 nodes is still less than 700  X sec . Overall, the query per-formance is impressive as the response time is measured in  X sec . This experiment demonstrates the efficiency of our CG-index and the C-graph extraction algorithm.
We describe a case study to assess the quality of the query answers. We select a query with the following four authors:
Due to space limit, we only show one full C-graph, at the top shaded region of Figure 2, which corresponds to the CG, { Sergey Brin , Lawrence Page } . The correlation score of the C-graph is 0.01. The C-graph consists of nine per-sons. Among the nine persons, Page is related to Brin , Cho , Garcia-Molina , Motwani , and Winograd . However, apart from Brin , Page has only one collaboration with the others. The reason that Page is related to them is because Page has only three publications and these five persons are all the co-authors. Page has two out of three papers with Brin , thus they are correlated. But the other scholars are not related t o Page or Brin since they have a large number of publications with other people. As a result, although the C-graph may seem to be complicated, it reflects the true and significant information of Brin and Page regarding to their academic publications.

For the founders of Yahoo! , since Filo and Yang do not have any paper co-authored, they are separated in two C-graphs. We show the two C-graphs by the shaded region at the bottom of Figure 2 (only those very closely related au-thors are shown), which shows that both Filo and Yang are related to De Micheli who links the two C-graphs together. Figure 2: Relationship between the Founders of Google and Yahoo!
The overall answer graph depicted in Figure 2 reveals the relationship between the founders of Google and Yahoo! . Ev-ery edge in Figure 2 has a relevance score of at least  X  , which implies a strong correlation or relation between the two au-thors linked by the edge. The computation of this answer graph takes only 0.016 second.
We propose an effective group formation technique that classifies the nodes in a large graph into meaningful groups called CGs. The notion of CG reflects the correlation among all the nodes within a CG. We develop an index for efficient query processing. Experimental results verify the meaning -fulness of the CGs and C-graphs and demonstrate the effi-ciency of our algorithms.
