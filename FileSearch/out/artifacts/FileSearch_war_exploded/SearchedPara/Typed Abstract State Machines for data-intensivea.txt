 Klaus-Dieter Schewe  X  Jane Zhao Abstract This paper focuses on extensions of Abstract State Machines (ASMs) for the ASMs and a more specific notion of strong data refinement, which incorporates the pres-ervation of information content by means of schema dominance. Each typed ASM can be effectively translated into an equivalent ordinary one. Providing typed ASMs helps to exploit the existing logical formalisms used in data-intensive applications to define a ground model. Furthermore, strong data refinement helps to set up a refinement-based development method that uses provably correct standard refinement rules.
 Keywords Abstract state machines  X  Types  X  Data warehouses  X  Refinement 1 Introduction Data warehouse research generally focused on the issues of view selection [ 7 ] and view maintenance [ 4 , 5 ]. Our research aims at providing sound refinement rules for the develop-ment of distributed data warehouses and on-line analytical processing (OLAP) systems [ 13 ]. The rationale is such that a refinement calculus would simplify the development task and at the same time increase the quality of the resulting systems. The simplification results from centrate on selecting the appropriate refinement rules. This is further supported by a method that guides the application of the refinement rules. The quality improvement results from our approach being grounded in the general method of Abstract State Machines (ASMs) [ 2 ]. The ASM method explicitly supports our view of systems development to start with an ini-refinements are defined in a way that preserves already proven quality statements.
The ground model employs three interrelated ASMs, one for underlying operational data-views on the data warehouse with OLAP functionality [ 11 ]. For the data warehouse level the model of multi-dimensional databases [ 3 ], which are particular relational databases, can be adopted. Then a large portion of the refinement work has to deal with view integration as one of the major challenges in this area [ 12 ].

We believe it is a good idea to incorporate types into the ASM method to make it closer to the well-established terminology in data-intensive systems; hence to make it easier to model the schema evolution by the notion of  X  X trong data refinement X . Although there are several approaches to introducing typed versions of ASMs, our rationale for introducing typed ASMs is far more modest, as our primary goal is to obtain an application-specific version of ASMs. Although the quality-assurance aspect is an important argument for a formal development in which informal development is still quite dominant. So providing a version of ASMs that are easier to use due to the adoption of more familiar terminology will be a necessary step towards the simplification of systems development and the desired quality improvement.
In Sect. 2 we introduce TASMs and define their semantics by runs following the usual approach used for ASMs. In particular, we show that each typed TASM will be equivalent to an ordinary ASM. Furthermore, we formally introduce the notion of strong data refinement , which realises the idea of schema preservation with the formal development. Roughly, part of the state of a typed ASM will be defined by a schema, and any refined specification can only contain a schema that dominates the previous one, i.e., it does not contain less information.
In Sect. 3 we discuss our approach using standard refinement rules for TASMs. These rules are sound in the sense that their application will always result in a strong data refinement. Furthermore, the rules are embedded in a method for the development of OLAP systems, which sets the conditions, under which a rule should be applied. We conclude with a brief summary and outlook. 2 Typed Abstract State Machines The three-tier architecture for data warehouses and OLAP systems in [ 13 ] basically requires relations on the database and the data warehouse tiers, whereas the OLAP tier requires sets t  X  X  X  X  X  X  t n | 1l .
  X  a domain d om ( t ) in the usual way. Furthermore, we obtain the usual notation of subtyping yielding a partial order  X  on types. Then subtyping t  X  t induces a canonical projection mapping  X  t t : dom ( t )  X  dom ( t ) . 2.1 Signatures, states and rules The signature of a TASM is defined by a finite list of function names f 1 ,..., f m . Each functions can be controlled or derived .

The functions of a TASM define the set of states of the TASM. Each pair = ( f i , x ) with x location/value pairs.

We call a function R of kind t  X  X  1l } a relation . This generalises the standard notion of R ( x ) = X  ,and x /  X  R instead of R ( x ) = X  .

State transitions are defined via update rules using the following language:  X  the skip rule skip , which indicates no change;  X  the assignment rule f ( X  ) :=  X  with a function f : t  X  t and terms  X ,  X  of type t and  X  the call rule r ( X  ) indicates the execution of rule r with parameters  X  .
Each update rule r defines an update set ( r ) in the same way as for ordinary ASMs [ 2 ]. Such an update set is consistent iff (, v 1 )  X   X  (, v 2 )  X   X  v 1 = v 2 holds for all state s i . 2.2 Terms and bulk updates we obtain a set T t of terms of type t . Then also the formulae  X  used in the rules change in All the rest remains unchanged.

So let us assume that for each type t we are given a set V t of variables of type t .Thenwe should have V t  X  T t and dom ( t )  X  T t , and further terms can be built as follows:  X  X or  X   X  T t and t  X  t we get  X  t t ( X  )  X  T t .  X  X or  X   X  T t 1  X  X  X  X  X  t n we get  X  i ( X  )  X  T t i .  X  X or  X   X  T { t } , a constant e  X  dom ( t ) and static functions f : t  X  t and g : t  X  t  X  t  X  X or x  X  V t and a formula  X  we get I x . X   X  T t .

The last three constructions for terms need some more explanation. Structural recursion src [ e , f , g ] ( X  ) is a powerful construct for database queries, which is defined as follows:  X  X rc [ e , f , g ] ( X  ) = e ,if  X  = X  ;  X  X rc [ e , f , g ] ( X  ) = f (v) ,if  X  ={ v } ;
We can use structural recursion to specify comprehension, which is extremely impor-( x ) ={ x } ,if  X ( x ) holds, else f  X  ( x ) = X  , which can be composed out of very simple functions.

For the join  X  1  X  2 ,using [[  X  ]] s to denote the interpretation in a state s ,weget which generalises the natural join from relational algebra.

I x . X  stands for  X  X he unique x satisfying  X   X . If such an x does not exist, the term will be undefined term appears in a rule, the rule defines an inconsistent update set.
For relations R of kind t  X  X  1l } we further permit bulk assignments , which take one of of a relation). These constructs are shortcuts for the following TASM rules:  X  R :=  X  represents A x  X  x  X   X  { R ( x ) := { 1l }} A x  X  x  X  R  X  x /  X   X  { R ( x ) :=  X  X   X  R :&amp; k  X  represents 2.3 Strong data refinement assume that names of functions, rules, etc. are completely different for M and M  X  .Then tively. Such formulae will be called abstraction predicates .Furthermore,lettherulesof M and M  X  , respectively, be partitioned into  X  X ain X  and  X  X uxiliary X  rules such that there is a the initial states of M and M  X  , respectively.
ATASM M  X  is called a (data) refinement of a TASM M iff there is an abstraction
Although this definition gives a proof obligation for refinements in general, it still per-mits too much latitude for data-intensive applications. In this context we must assume that some of the controlled functions in the signature are meant to be persistent. For these we empty.

The second additional requirement is that the schema S  X  of the refining TASM M  X  should dominate the schema S of TASM M . For this we need a notion of computable query. For a f : S  X  S  X  is computable iff f is a computable function that is closed under isomorphisms.
A data refinement M  X  of a TASM M with abstraction predicate A is called a strong data refinement iff the following holds: 3. There exist computable queries f : S  X  S  X  and g : S  X   X  S such that for each pair
This definition provides a stronger proof obligation for refinements in the application area we are interested in. Furthermore, this notion of strong data refinement heavily depends on the presence of types.
 Let us now look at the relationship between TASMs and ASMs. We will first translate a TA S M M into an ASM ( M ) . For this consider first a function f : t  X  t in the signature of
M .For t = t 1  X  X  X  X  X  t n define an n -ary function ( f ) =  X  f in the signature of ( M ) with
In all other cases define a unary function ( f ) =  X  f with  X  f ( x ) = 1for x of type t , while otherwise  X  f t ( x ) is undefined. Then we must have In doing so, each state of the TASM M corresponds in a canonical way to a state of the ASM ( M ) . We simply extend the functions in the signature to be applicable to any values, but they are undefined, if these values have the wrong type. Using this correspondence of states we can define the TASM M to be equivalent to an ASM ( M ) iff both machines have thesameruns.

Then for the rules in M we mainly have to consider assignments f ( X  ) :=  X  , which have to The problem is now to ensure that the right term is computed by the assignment, i.e., we have to translate the complex term language of TASMs into extensions to the rules in ( M ) .
For subtype functions  X  t t we may assume these are defined in the signature of ( M ) by fresh variable y that is substituted for the term.

Similarly, for projections  X  i on tuple types we can replace a rule r containing  X  i ( X  ) by differences of sets there is nothing to do.
 Now consider structural recursion, which gives the most complicated case. If a rule r in M involves the term src [ e , f , g ] ( X  ) with  X  of type { t } , then replace this by a rule
As structural recursion covers set comprehension, the join is covered as a special case, which in addition exploits that the subtype functions are represented by static functions. rule @ y  X { x |  X  }={ y }{ r [ I x . X / y ]} with a new variable y .

Taking together these translations of rules, a rule r and its translation ( r ) result in the same update set. Together with the canonical correspondence between states of M and ( M ) we have obtained the following theorem.
 Theorem 1 Fo r e a c h TA S M M there is an equivalent ASM ( M ) . 3 Data warehouse design using TASMs As emphasised in [ 13 ] we start with a ground model that models the three-tier architecture through coupled (typed) ASMs. This ground model is then subject to refinements, which in our case will be strong data refinements. 3.1 Ground model and refinements For the three-tier architecture we have the operational database model, which has the control tion from the operational database to maintain the freshness of the data warehouse. In the of view. In our case, we have the star schema for the detailed data and a set of summarised views for performance purpose. At the top tier, we have the data marts, which are constructed out of dialogue objects with OLAP operations. Based on this three-tier architecture, we end up with three linked ASMs: the DB-ASM, the DW-ASM, and the OLAP-ASM in our ground model.

Each of these ASMs uses separate controlled functions to model states of the system by logical structures and rules expressing transitions between these states. The ASMs are then linked together via queries that are expressed by these transitions.

Refinements dealing with changes that are due to identified requirements will therefore start on the top level, i.e., the OLAP ASM. We just iterate the following steps each of which corresponds to the application of some formal refinement rules: 1. Add a new controlled function to the OLAP ASM : This will be used to model a view that 2. Integrate controlled functions on the data warehouse ASM : This will be used whenever 3. Add additional controlled functions to the data warehouse ASM : This will be a conse-4. Reorganise the controlled functions on the data warehouse ASM : This will result from 5. Change the rules on the operational database ASM : These rules actually model the data 6. Apply operational refinements : These refinement rules apply to the ASMs on all three 7. Distribute the data warehouse and the OLAP ASM : 3.2 Refinement calculus for data warehouses Let us now discuss refinement rules for data warehouses and OLAP systems. According to Zhao and Ma [ 13 ] the integration of schemata and views on all three tiers is an important part of such refinement rules. Furthermore, the intention is to set up rules of the form
That is, we indicate under some side conditions  X  , where parts of the machine M will be has to indicate, which relations belong to the schema, and the correspondence between main rules.

We can obtain such standard refinement rules by formalising the schema integration rules in [ 9 ]. Rules for this purpose can be grouped roughly into five groups dealing with schema dling.

In a nutshell, schema restructuring rules reflect the existence of isomorphisms between nature can be replaced by an equivalent type, this can be expressed by a schema restructuring rule.

The second group of rules affects relations of kind t 1  X  X  X  X  X  t n  X  X  1l } . A component restrictions that are expressed in the set of constraints on the schema.

Schema extension rules address the addition of  X  X ttributes X  and the like. More generally, and can be expressed through strong data refinement.

The fourth group of rules replaces two relations R 1 and R 2 by a single new one in the case of equality or selection, or two new relations in the case of containment, or three relations in the case of overlap, which aims at reducing redundancy. Rules for this can be expressed again through strong data refinement. These rules exploit the notion of key .So,if R has the kind t  X  X  1l } and t is a supertype of t , then we can express a key constraint by requiring  X  x , y . x  X  R  X  y  X  R  X   X  t Furthermore, let t i be a type residing between t i and t such that the constraints imply a bijection between {  X  t i t t schema dominates the given one.

The fifth group of rules captures additions, removal, and modifications of relations due strong data refinement.
 As an example let us consider a single type integration rule, which merges two relations R 1 and R 2 into a single one R where K 1 and K 2 are the keys, and h is a bijective mapping. The corresponding abstraction predicate A is Finally, the corresponding computable queries f and g can be obtained from and
In addition, as we are interested in extended views capturing the functionality of data warehouses, we have to provide additional rules that deal with the implied modifications to TASM-rules on the machine OLAP X  X SM. The rule body may refer to one or more rela-tions of the schema. Consequently, each modification of the schema implies a subsequent modification of the rules. 4Conclusion In this paper we introduced a typed version of Abstract State Machines. The motivation for this is that our research aims at applying the ground model/refinement method supported by ASMs in the area of data warehouses and OLAP systems. For this it is advantageous to have available in ASMs. So, the major reason for adding them is to increase the applicability of ASMs. We did, however, show that these extensions do not increase the expressiveness of ASMs, as each typed ASM can be mapped to an equivalent  X  X rdinary X  one.

In a second step we approached refinement in typed ASMs. We clarified what we wanted to achieve by refinements in data-intensive application areas. Strong data refinement is more tics of data in accordance with schema dominance as discussed in [ 9 ].
This brings us closer to the goal of our research project to set up a handy set of sound refinement rules for the development of distributed data warehouses and OLAP systems. The general approach to defining such rules has already been discussed in Zhao and Ma [ 13 ], while the current work clarifies, what kind of rules we have to expect. The challenging task steps will address the extension of such a rule set.
 References Authors Biographies
