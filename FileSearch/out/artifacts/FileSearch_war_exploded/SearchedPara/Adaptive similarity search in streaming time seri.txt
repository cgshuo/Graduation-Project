 1. Introduction Nowadays, a significant number of applications require the manipulation of data streams [6,2,7,17,8,10] .
Examples of these applications are online stock analysis, computer network monitoring, network traffic man-agement, earthquake prediction. The major common characteristic of the above applications is that they are all time-critical. Therefore, the Database Management System (DBMS) must be equipped by effective and efficient tools for data stream processing, towards acceptable performance during insert, update and query operations. Due to the highly dynamic nature of data streams, random access is prohibitive. Therefore, each are not compatible with traditional query processing approaches used in Online Transaction Processing (OLTP) and Online Analytical Processing (OLAP) systems, and therefore additional tools are required. An important query type that has been studied thoroughly in database literature is the similarity query.
Given a query object Q the similarity query asks for all objects O
Similarity queries have been studied for multidimensional objects, images, video, time series and other non-literature: such that dist  X  q ; a  X  6 e . database objects a i 2 A  X  1 6 i 6 j A j X  such that for any other object a dist  X  q ; a i  X  6 dist  X  q ; a j  X  . b 2 B such that dist  X  a ; b  X  6 e .

In this paper, we study similarity e -range and k -nearest-neighbor queries in streaming time series, where both the query sequence and the data sequences change over time. The length of a streaming time series can be very large, since new values are continuously appended. Therefore, the similarity of two time series is expressed by means of the last values of each stream (e.g., 128, 256, 1024 values), using a sliding window approach. Each stream can be represented as a vector in a high-dimensional space. Dimensionality reduction techniques (e.g., Discrete Fourier Transform, Karhunen X  X oeve Transform) can be used in order to reduce the number of dimensions, allowing efficient multidimensional access methods to be utilized. However, each vec-tor changes over time since new values are continuously appended. The naive approach is to delete the old feature vector by updating the access method, to re-apply the dimensionality reduction technique to the both in Central Processing Unit (CPU) time and number of disk accesses and therefore, it is inappropriate in our case. We develop a novel method in order to process similarity queries in data streams with sliding win-dows. The basic characteristics of the proposed approach are summarized as follows:  X  Streaming queries over streaming data are supported.  X  R-tree-based [21,5] access methods are utilized, which are well-studied in the literature and they have already been incorporated in commercial database management systems.  X  The feature extraction method works in an incremental manner, enabling considerable savings in CPU time during the feature extraction process.  X  Index updates are either avoided or performed in a bottom-up manner, which results in improved perfor-mance. Moreover, the update ratio is controllable and can be altered according to the current system workload.  X  Storage requirements are significantly less in comparison to existing techniques, and therefore in-memory maintenance of access methods is feasible. stream applications.

The rest of the work is organized as follows. In the next section, we give the appropriate background, the related work and the motivation behind the proposed research. Section 3 studies in detail the proposed method for similarity query processing. Section 4 presents performance evaluation results based on real-life data sets. Finally, Section 5 concludes the work and shortly discusses future research in the area. 2. Background, related work and contribution
A streaming time-series S is a sequence of real values s 1
The ordering that tuples become available induced by the timestamps. For example, a temperature sensor which monitors the environmental temperature every five minutes, produces a streaming time-series of tem-perature values. As another example, consider a car equipped with a Global Positioning System (GPS) device and a communication module, which transmits its position to a server every ten minutes. A streaming time-series.

Similarity queries in streaming time series have been studied in [11] where whole-match queries are inves-tigated by using the Euclidean distance as the similarity measure. A prediction-based approach is used for query processing. The distances between the query and each data stream are calculated using the predicted values. When the actual values of the query are available, the upper and lower bound of the prediction error
The same authors have proposed two different approaches, based on pre-fetching [12,13] . Both the aforemen-series and the query is dynamic (changes over time).

A class of algorithms for stream processing focuses on the recent past of data streams by applying a sliding considered for query processing, whereas older values are considered obsolete and they are not taken into similar if the window is shifted in the time axis (right).

In [17] the authors present a method for query processing in streaming time series where both the query object and the data are dynamic. The VA-stream and VA  X  -stream access methods have been proposed, which rization of the data and enable the incremental update of the structure every time a new value arrives. This method is our competitor since both queries and data are dynamic. We give a brief description and we discuss some implementation issues of this method later in the paper.

The design of efficient index structures with respect to the number of updates has attracted the interest of ture is not applied to the root but to internal nodes. In [16] the authors have proposed a variation of the and (ii) a summary data structure which is used to obtain access to the internal tree nodes. These approaches to reduce the number of updates. In the streaming case, the control of the update frequency of the index is necessary to avoid system degradation.

In [15] , we have proposed an indexing scheme and a query processing mechanism for similarity range query processing on streaming time series, using the sliding window approach. The proposed approach (IDC-Index) outperforms the VA  X  -stream method during range queries, whereas the overall performance for queries and updates has been shown to be better. In this article, we extend the work studied in [15] in the following ways:  X  In addition to range queries, k -NN queries are considered.  X  A technique is proposed which adapts the index update rate according to application requirements.  X  A bottom-up approach for index updates is adopted in order to accelerate update operations.  X  Several optimizations to the original IDC-Index are proposed, towards more efficient query processing. 3. Proposed approach
A stream is denoted by the symbol S x and a finite time series by the symbol S instance of the time series and j is the last. The number of values of a time series is therefore j i + 1 and corresponds to a window of length W . S x  X  i  X  is the i th value of the time series.

In our study, the Euclidean distance between two finite time series is used as the similarity measure. The distance between two streaming time series S x and S y is defined by the Euclidean distance between the last throughout the study.

Let us assume the existence of n streaming time series, each updated over time. To determine similar streaming time series, we use only the last W values of each one and update these values when a new value becomes available. Given a query streaming time series the challenge is to determine similar time series as the data evolve with time.

The naive approach is the Sequential Scan (SS). In each update, the distances between the query streaming
The streaming environment poses new challenges to the applications as unbounded memory requisites, high input rates and fast response times. Therefore more sophisticated approaches are necessary to speed up the similarity process.

Feature extraction and dimensionality reduction are well known and established techniques that have been proposed in order to simplify complicated problems. The similarity measure is applied on the extracted fea-processing step to discard false alarms.

Following the above scheme, in this paper we used the DFT coefficients as features and R * -tree based indexes. To satisfy the limitations posed by the streaming environment, (a) we introduced an incremental com-putation of DFT in order to avoid costly DFT computation, and (b) we introduced different deferred update policies in order to avoid the degradation of the system due to the usage of the index structure and the high number of updates.
 Fig. 2 depicts the architecture of the system. The last W values of each stream are stored in the disk. The
DFT coefficients with the stream. Additionally each stream maintains a link to the leaf where the correspond-ing DFT coefficients are stored. When a value becomes available the window of the stream is updated, the features of the stream are extracted incrementally and the new DFT coefficients replace the old ones using tom-up adjustment is performed from the leaf up to the root of the tree if necessary. The query is applied The next sections provide details on each of them.
 3.1. Incremental DFT computation
The DFT is used as the feature extraction method, which preserves the Euclidean distance between two sequences. Real-life time series often concentrate the energy in the first few components of the
DFT. Therefore, we need less information to capture the characteristics of the original vector. Another important feature of the DFT is that the Euclidean distance in the time domain and the Euclidean dis-tance in the frequency domain are equal. By taking the first coefficients of the DFT vectors, the result-ing distance between two vectors is reduced, and therefore, no false dismissals occur during range query processing, since the distance is lower-bounded [1,9] . There is a trade-off between the number of the
DFT coefficients and the approximation of the distance in the time domain. If more DFT coefficients are used then the number of candidates is reduced during the query processing, thus the query proce-dure speeds up.

Normally, every time a new value for a stream arrives, the DFT vector must be recalculated by using the last W values of the stream. This may lead to high costs since the re-computation of the DFT is quite expen-sive. However, as the following proposition explains, the computation of the DFT can be performed incre-mentally, avoiding re-computation, by exploiting the last calculated DFT coefficients. coefficients of T can be computed by the DFT coefficients of S according to the following equation: Proof. See Appendix. h
Each DFT coefficient has a real and an imaginary part. An implementation issue must be solved is how we can compute separately each part of a DFT coefficient. The following proposition explains. ( DFT n  X  T  X  real ) and the imaginary ( DFT n  X  T  X  imag coefficients of S according to the following equations: and where  X  0 6 n 6 W 1  X  .
 Proof. See Appendix. h
The above proposition can be used to incrementally compute the new DFT vector of a streaming time ser-ies, taking into account the previous one, and therefore, avoiding the re-computation. Example 1. Assume the streaming time series S : 3, 2, 1, 3 with W = 4. The second DFT coefficient of S is
DFT 1  X  S  X  X  2  X  j 2 or DFT 1  X  S  X  real  X  1 and DFT 1  X  S  X  and forms a new streaming time series T : 2, 1, 3, 4. So if for example we want to compute DFT
DFT 1  X  S  X  . Therefore DFT 1  X  T  X  real  X  1 ffiffi  X  ffiffiffi 4 p 3.2. Deferred update policy
Since the number of streams may be quite large, the use of an index structure is desirable to avoid the com-the DFT coefficients of the streaming data series. In our case the problem is that the DFT coefficients of a streaming time series must be updated when a new value arrives. If we update the index every time a new value becomes available, the overhead may be prohibitive due to additional page accesses. To avoid continuous deletions and insertions in the R * -tree, we use a deferred update policy. A parameter D the updates. If the distance between the new and the old DFT vector exceeds the value of parameter D the R * -tree is updated. Otherwise, no update is performed. This technique leads to considerable savings in to become available when a new value arrives. The price paid is that the indexing scheme may not always reflect the data distribution. The use of the parameter D modifications performed to the query, no false dismissals occur and moreover, the query processing efficiency is not affected significantly.

Let S be a streaming time series. The last W values form a sequence denoted by S where N is the position of the last value of the time series. When a new value for S new sequence S 2  X  N W  X  2 : N  X  1 is formed. Assume further that DFT  X  S sequence corresponding to S 1  X  N W  X  1 : N , and DFT  X  S
S  X  N W  X  2 : N  X  1 , which is computed incrementally using the DFT  X  S 6 D u , then DFT  X  S 2  X  is stored as the most recent DFT (replaces DFT  X  S
R * -tree. Assume that another value for the same stream arrives. Let S series and DFT  X  S 3  X  the DFT of this sequence, which is computed incrementally using DFT  X  S replaces DFT  X  S 2  X  as the most recent DFT. If D E  X  DFT  X  S
R * -tree. On the other hand, if D E  X  DFT  X  S 3  X  ; DFT  X  S so an update is performed.

In summary, we need both the last recorded DFT vector and the previously calculated DFT vector. The coefficients. Step 4 updates the internal nodes of the index. 3.3. IDC-index with global query expansion
The value of the update threshold D u can either be fixed or can vary according to the application require-selecting a fixed value for D u is very restrictive. In [15] a fixed value for D we show how we can keep D u up-to-date as streams evolve with time.
 3.3.1. Selecting the update threshold D u frequency U posed by the specific application. The update frequency denote the maximum allowed number of updates that must be performed to the index to guarantee efficiency. Taking into consideration that a huge number of updates may be required as new stream values become available, the parameter U is used to com-pensate the excessive update demand. This parameter can be set by the application, or may vary according to index update frequency should be reduced to prevent performance degradation. In the sequel we explain in detail how to estimate the value of D u dynamically, to approximate U .

The target is to maintain the value of U as accurately as possible, based on the recent past of the streaming time series. In this way, we can determine a convenient value for D this, an adaptive calculation of D u is applied. The last u values arrived are used in order to determine D example, let U be 20%, which means that every 100 update requests only 20 index updates will be performed.
For the next u = 10 update requests we monitor the Euclidean distance between the last and the previous DFT vector for the affected streaming time series. In order to achieve 20% index updates, the value of D cedure is continuously repeated. An important issue that we note, is that the number u must be selected to have a significant number of stream values for the determination of D 500 and 1000 have been used for the estimation of D u in our experiments.

If the value of U remains constant, then no specialized data structures are required. In the previous exam-istic scenario, since U can be increased when stream mobility is low, and decreased when mobility is high. To minimum value at the root. This means that the minimum value is available in O(1) time. By deleting the min-imum value, the heap is adjusted in O(log n ) time (where n is the size of the heap) and the next minimum is placed at the root. Therefore, if the x th minimum value must be determined, the heap is accessed x 1 times, it is illustrated in the performance evaluation.

Maintaining the update frequency of the IDC-Index fixed, the method avoids system degradation due to high input rates of streams. Moreover, as we have already mentioned, we shall demonstrate that the use of
D does not introduce false dismissals and therefore does not affect the matching quality. 3.3.2. Updating the index
The traditional method to update the R * -tree index requires to locate the relevant object in the leaf node, delete the old entry and insert the new entry using the normal insertion algorithm. However, this process is computationally expensive and may lead to performance degradation when the stream  X  X  X obility X  X  is high.
Recall that in our case, an index update will take place if the Euclidean distance between the new DFT vec-tor and the last recorded DFT vector for a stream is greater than D ditional index update process, another method is applied which is more efficient regarding computational costs.

Each stream maintains a link to the leaf where the corresponding DFT vector is stored. Therefore, there is no need to search for the specific entry in a top-down manner. When a new value arrives, then the new DFT distance between the new DFT vector and the last recorded DFT vector is less than or equal to D more modifications are performed to the R * -tree structure. Otherwise, a bottom-up adjustment of the Mini-mum Bounding Rectangles (MBRs) is performed, by recalculating MBRs from the leaf, up to the root of the bottom-up manner (from a child node to its parent). By applying this technique, the use of the parameter D does not affect the query processing efficiency, since the leaves always contain up-to-date DFT vectors and therefore the candidate set is the same either D u is used or not.

For example, assume that a new value arrives for the stream 1 of Fig. 2 . The new DFT coefficients are com-case a bottom-up adjustment of the MBRs is performed so all the MBRs of the path from the leaf to the root to contain the new DFT coefficients. Note that the replacement of the DFT coefficients of the leaf is always performed regardless of the decision of the deferred update policy to update the index or not. 3.3.3. Query processing issues
So far we have focused on the detailed description of the feature extraction process, the way index updates are performed and how to adjust the update threshold D u . We proceed by describing the way query processing is performed. Both similarity range and nearest-neighbor queries are considered, and detailed algorithms are given. Both query processing algorithms follow a filter-refinement processing paradigm, to eliminate false alarms which may be present due to the approximation performed by the use of DFT vectors. The architecture outline of the query processor is depicted in Fig. 2 . 3.3.4. Range query processing
In order for similarity range queries to produce the correct results, the user-defined distance e must be dismissals occur.

Proposition 3. If the query radius e is expanded by D q in the internal nodes of R * -tree, where D
D u seen so far, then no false dismissals are introduced.

Proof. Assume that we have the DFT vector of the query stream DFT  X  S last recorded DFT vectors and a stream S x that belongs to the MBR last recorded DFT vector DFT  X  S x  X  LR of stream S x and the current DFT vector DFT  X  S
Proposition 3 implies that if the current DFT vector of a stream overlaps the query region, then the cor-responding MBR LR (a MBR that is formed by the last recorded DFT coefficients) will overlap the extended trated in Fig. 5 . 3.3.5. Nearest-neighbor query processing
For the nearest-neighbor queries, we use the multi-step k -NN algorithm [20] . The algorithm reduce the number of candidates by decreasing the value of the k th nearest neighbor distance with ongoing exact eval-
Proposition 4. If the kth nearest neighbor distance is expanded by D
Proof. Assume that we have the DFT vector of the query stream DFT  X  S last recorded DFT vectors and a stream S x that belongs to the MBR last recorded DFT vector DFT  X  S x  X  LR of stream S x and the current DFT vector DFT  X  S nearest neighbor distance is d k .

Proposition 4 implies that if the current DFT vector of a stream is closer to the query point than the k th neighbor, then the corresponding MBR LR will be inserted in the heap for further examination, if we expand the k th nearest neighbor distance by D q .

The k -NN query processing algorithm can be further improved, if a more sophisticated scheme is used for distances from the query. The maximum distance can be used for the initialization of d outline of the k -NN query processing algorithm is depicted in Fig. 6 . 3.4. IDC-Index with local query expansion
In the IDC-Index with global query expansion, only one value for D value of D q is determined by taking the maximum value of D value, the performance of queries will degrade. Moreover, if a few streams are characterized by intense fluc-tuations, this will have a direct impact on D u (and hence to D do not change their values in a sharp manner. Note that, a large value of D This means that more index MBRs will overlap the query range, leading to increased processing cost.
For example, assume that the parameter D u is 10 and the parameter D number of streams have intense temporary fluctuations, so the parameter D frequency of the index stable. In the IDC-Index with global query expansion, D equal to the maximum value of D u seen so far. When the intense fluctuations are over, D 10 but the D q will not be reduced in order to preserve the correctness of the algorithm.
Instead of using only one D q for all streams, we can maintain one D
A parent entry has its local D q set to the maximum D q of all the entries in its subtree. By using a local D query covers a minimum region, since the expansion of the query is as small as possible. This implies that fewer MBRs will overlap the query range, resulting in a more efficient processing scheme.
On the other hand, the maintenance of local D q for each entry requires some additional cost. As it is dem-onstrated in the experimental results, the use of the local D significantly larger than the number of updates in the workload. 3.4.1. Updating the index
As in the case of IDC-Index with global query expansion, the IDC-Index with local query expansion uses
Recall that with global D q the DFT vector of the leaf is updated every time. A full bottom-up update occurs only when the difference between the new DFT vector and the last recorded DFT vector exceeds the D threshold.

In the IDC-Index with local D q , the parameter D q is updated every time, regardless if an update occurs or not, in order to preserve the correctness of the query processing algorithm. The update of the local D formed by a bottom-up procedure. Notice that the cost to update the local D less than the cost to update the MBRs of the R * -tree. Therefore, significant savings in computation may be achieved.

When an update occurs, as we update the MBRs of internal nodes, we also update the local D need to update the MBRs, we update only the local D q . First, we update the local D ceed to the upper levels of the tree, the following condition must be satisfied:
Fig. 7 shows an example to clarify the above condition. To simplify the example, we use local D the nodes and not for the entries. It is obvious that the local D entries. We first examine the case where the new local D q local D q of node 5 is 4 then the local D q of the father (node 2) should be reduced (because the old local D equal to local D q of the father). The modifications proceed up to the root (node 1). If the new local D node 4 is 2 then no modifications of the father are required since the local D old local D q and therefore depends on the local D q of node 5. Now we examine the case where the new local D is greater than the old local D q of a node. If the new local D the local D q of the father is greater than the new local D 3.4.2. Query processing issues
The algorithms for both range and nearest neighbor queries in IDC-Index with local D
The query region initially is r = e , so it is expanded for each entry by the local D is compared with the sum of the k th nearest neighbor distance and the local D 4. Performance study 4.1. The VA  X  -stream approach
Before we present the experimental results, we briefly describe the VA been proposed in [17] as a similarity search method in streaming time series. The VA
VA  X  -file [22] , a structure that has been proposed as an index method to overcome the dimensionality curse and to support efficient similarity search for non-uniform data.

Since a streaming time sequence contains a large number of values, similarity is expressed with respect to each sequence is represented as a point in the 256-dimensional space.

The VA  X  -stream divides the data space into 2 b cells, where b is a user-specified parameter. The VA allocates different number of bits for each dimension. The sum of these bits is equal to b . Each cell is an ple of six time sequences in the 2D space ( W = 2) with b = 3 is given in Fig. 8 .

The data stream values considered are obtained by a sliding window which always contains the last W stream values. In order to adjust the structure due to the newly arrived values, a bit reallocation method is duction error. A drawback of this approach is that requires all the streams to have new values in order to adjust the structure, in contrast with IDC-Index which can manipulate streams with different data collection rate. The VA  X  -stream access method can answer similarity range and nearest-neighbor queries.
The performance of this approach is highly dependent on the number of bits associated with each dimen-structure is n d integers, where n is the number of streams. We used the CSET structure described in [17] . 4.2. Experimental results
In this section, we report the experimental results performed on real-life data sets. All methods are imple-mented in C++ and experiments have been conducted on a Pentium IV system at 3 GHz, with 1 GB of main memory running Windows XP. We have conducted a series of experiments to evaluate the performance of the
IDC-Index and its variations. We have used the VA  X  -stream and the sequential scanning methods as the com-petitors of IDC-Index. We use the labels SS for the sequential scanning algorithm, IDC-INDEX for the scheme with a global D q and IDC-LOCAL for the scheme with the local D
As we have already mentioned, one of the major disadvantages of the VA streams to have a new value in order to update the VA structure. On the other hand, the local IDC-Index (IDC-Index with local D q ) can be efficiently used only in cases where a fraction of the streams is updated in each time instance. Therefore, we divided the experiments into two categories. Experiments in which all the streams are updated in each time instance and experiments in which a fraction of the streams is updated in each time instance. In the first category, we compared the global IDC-Index (IDC-Index with global D
VA  X  -stream and the SS and in the second category we compared the global and the local IDC-Index. All the required data structures are maintained in main memory.

Both range and k -NN queries are considered. The VA  X  -stream is proposed for k -NN queries [17] ,sowe modified the method to be applicable for range query processing. We have studied the performance of the methods by varying several of the most important parameters such as the query distance e in range queries, number of DFT coefficients and the workload. The workload is composed of queries intermixed with updates. An update operation includes all the updates in a specific time instance. We have measured the CPU cost per query and per update, the number of disk accesses and the number of candidates. Moreover, we have studied the behavior of the R * -tree and the space requirements of the data structures.
 1% of the streams to be in the answer. The desirable update ratio is 0.1%. Thus only 0.1% of the streams will size is set 256. The workload is another important parameter. We have chosen two different workloads: (i) a  X  X  X eavy X  X  workload comprising 20% queries and 80% updates, and (ii) an  X  X  X ight X  X  workload comprising 80% queries and 20% updates. The real-life data sets used are described below shortly:  X  Stocks : contains daily stock prices obtained from http://finance.yahoo.com . In order to have an adequate number of streams, we have generated new ones by transposing values of the real streams. The data set consists of 50,400 time sequences, each with a length of 1500. 1974. The set is available by the Pacific Marine Environmental Laboratory ( http://www.pmal.noaa.gov/tao ), and consists of 12,217 series, each having a length of 1000. 4.2.1. Estimation accuracy
Recall that the update ratio U defines the number of updates that will be performed in the index, with respect to the total number of updates. For this reason the parameter D has been described in a previous section. Here, we demonstrate the accuracy in preserving the required update two different workloads have been used. The first workload contains 100 range queries and 400 update oper-ations, whereas the second workload contains 400 range queries and 100 updates. Note that all streams update their values, which means that the number of update operations is multiplied by the number of streams to obtain the total number of updates.

The first column contains the desired update ratio. The column labeled  X  X  X stimated X  X  contains the estimated number of index updates that should be performed to guarantee the desired update ratio. The column labeled  X  X  X eal X  X  shows the number of updates that actually took place. It is evident that the number of updates per-formed is very close to the predicted value. This means that the estimation of D desired update ratio very accurately. 4.2.2. Performance of range similarity queries is used. Both CPU cost and disk accesses are given in each experiment. The CPU cost is given in seconds. The y -axis is in logarithmic scale.

The IDC-Index outperforms the other two methods. Notice that the CPU cost of SS is less than that of the IDC-Index when the number of queries is low. This is expected since the SS does not require any index updates. We emphasize that the problem is disk-dominated so the number of disk accesses determines the total performance of a method. As e increases, the difference between the three methods is decreased because the number of streams that are contained in the final answer increases rapidly. Moreover in the  X  X  X ight X  X  workload the gap between IDC-Index and VA  X  -stream is greater because IDC-Index processes que-ries faster than VA  X  -stream since IDC-Index introduces less false dismissals as we will show later in the experiments.

Fig. 11 illustrates the performance of the methods with respect to variable workload. The IDC-Index is steadily more efficient than VA  X  -stream and SS. Again the CPU cost of SS is less than that of the IDC-Index when the number of queries is low. As we mentioned above this is expected since the SS does not use an index structure. The gain from the disk accesses surpasses the CPU cost. IDC-Index outperforms VA cially when the number of queries is high. That is because, as already mentioned in the previous experiment,
IDC-Index achieves better hit ratio than VA  X  -stream. This impacts in the number of disk accesses, thus the mic scale.

The number of DFT coefficients has an important impact on the performance. As the number of DFT coef-shows the hit ratio with respect to the number of the DFT coefficients both for STOCKS and TAO data sets.
For the STOCKS data set the hit ratio of the IDC-Index is much better than that of the VA the stocks values match with the DFT properties. On the contrary, to achieve a good hit ratio for the TAO data set, more DFT coefficients are required. A reasonable question is how the number of coefficients influ-ences the CPU cost. Fig. 13 depicts the CPU cost and the disk accesses for the TAO data set. The gain from the reduction of the disk accesses is more than the overhead imposed by the CPU. For example, in Fig. 13 the difference between the use of two and eight coefficients, is about 8 seconds for the CPU and 100,000 for the number of disk accesses. Thus it is better to use an adequate number of DFT coefficients sacrificing low CPU method.

We also studied the behavior of the method with respect to specified update ratio. As the update ratio increases, the update cost is increased and the query cost is reduced. That is because the parameters D
D (recall that the query is expanded by D q ). We chose a very low update ratio for the experiments because, of candidates since the leaves of the index have always the current DFT coefficients so the number of disk accesses is not affected by the specified update ratio.

An advantage of the IDC-Index is that it can handle different window sizes. Fig. 15 illustrates the CPU cost and the number of disk accesses with respect to window size. The IDC-Index is again more efficient than the other two methods. The CPU cost for the IDC-Index is almost unaffected from the window size since the num-dow size since they perform operations in each dimension. Therefore as the number of dimensions increases the CPU cost is increased.
Fig. 16 shows the space requirements for the two methods for the STOCKS and TAO data sets, with respect to the sliding window size. The space requirements of the IDC-Index remains fairly constant. On the other hand, the size of the CSET structure of the VA  X  window size. Recall that the CSET structure uses one integer for each dimension to determine the cell of each stream. 4.2.3. Performance of k-NN similarity queries
In the sequel, we studied the performance of the three methods in k -NN query processing. The first exper-iment studies the performance of the methods with respect to k . Figs. 17 and 18 show the results for the
STOCKS and the TAO data set, respectively. IDC-Index is consistently more efficient than SS and VA stream. It is evident that the impact of k is not significant. The methods have the same behavior in both k -NN and range queries. Again the CPU cost of SS is less than that of the IDC-Index but the gain of disk accesses surpasses this cost. Moreover, IDC-Index is better than VA hit ratio.

Fig. 19 depicts the performance with respect to the workload. The CPU cost of SS is less than that of the other methods, whereas the I/O cost dominates. IDC-Index outperforms VA cesses queries faster than VA  X  -stream.
As we already mentioned, we have used a buffering for the IDC-Index and the VA Both methods are equally affected by the buffer size.

Next, we examine the impact of the sliding window size to the performance of the methods. It is expected fixed. The number of disk accesses of the IDC-Index increases due to the loss of information as the window size increases. Nevertheless, the IDC-Index method is more efficient than the VA depicted in Fig. 21 . 4.2.4. Comparison of global and local IDC-index In this section, we show the experimental results obtained by the comparison of global and local IDC-
Index. In these experiments, only a fraction of the streams is updated in each time instance. The specified update ratio is set equal to 1%. We studied the performance of the methods both for range and k -NN queries.
Notice that both methods have back pointers at the leaves and therefore have the current DFT values. Thus the number of disk accesses is the same.

The first experiment shows the CPU cost of the methods in executing k -NN queries with respect to the ratio of the streams that are updated. The ratio varies from 0.1% to 10%. We used two different workloads: (a) 20% queries and 80% updates and (b) 80% queries and 20% updates. Fig. 22 depicts the results for k = 10 for the TAO data set. It is observed that the local IDC-Index shows better performance, especially when the workload contains more queries than updates and the ratio of updated streams is low. Recall that the IDC-Index with local D q updates the local D q of the leaf when a new value arrives. This can cause a bottom-up update to the upper levels. If the number of updates is much more than the number of queries or the ratio of streams that are updated is high, then the IDC-Index with local D
Fig. 23 shows the same results for k = 1000 for the TAO data set. The results are similar to those of the previous case.

An important parameter in the IDC-Index is the specified update ratio. If the update ratio is low, then the update operation is fast, whereas query processing efficiency may be affected. Since the update operation is implemented in a bottom-up manner, the question is how this modification affects the performance of the antee the quality of the structure. We used both the global and the local IDC-Index. Fig. 24 illustrates the is higher, but not enough to surpass the total CPU overhead. Notice that the gap between the reconstructed costly operation. Moreover the IDC-Index with local D q is better than the IDC-Index with global D accessed. 5. Concluding remarks
Data stream processing is an active area of research aiming at the design of efficient methods for handling time evolving data with frequent updates. Streaming time series compose a special category of data streams that appear in many applications such as network monitoring, sensor networks, financial applications, tele-communications data management. A streaming time series is a sequence of data values, where new values are continuously appended as time progresses. In many cases we are interested only in the recent values of a streaming time series. Therefore, a sliding window of length W is defined to capture the last W values of each streaming time series.

An important operation in streaming time series is to determine similar time series with respect to a query ilarity range queries and similarity nearest-neighbor queries in such an environment. More specifically, we addressed the issues of: (1) incremental feature extraction, (2) efficient in-memory indexing by means of the indexing scheme to approximate the update frequency. Performance evaluation results have shown that significant improvement is achieved in comparison to a recent proposal based on the Vector Approximation
File (VA-File), both in storage requirements and query processing efficiency. The current research can be extended in a number of different directions:  X  the support of multiple continuous queries,  X  the consideration of other similarity measures such as Dynamic Time Warping (DTW) [3] and Discrete
Wavelet Transform (DWT) [19] ,  X  the selection of the number of coefficients with respect to the properties of the data set, and  X  the efficient processing of similarity join queries in a streaming environment.
 Acknowledgement The research supported by the PENED 2003 program, funded by the General Secretariat for Research and Technology, Ministry of Development, Greece.
 Appendix coefficients of T can be computed by the DFT coefficients of S according to the following equation: by: Similarly, the n th DFT coefficient of a streaming time series T is given by:
We begin with Eq. (6) and substitute the values of DFT  X  S
By algebraic manipulations in the above equation and taking into consideration that S  X  i  X  X  T  X  i  X  for which is exactly Eq. (4) . h ( DFT n  X  T  X  real ) and the imaginary ( DFT n  X  T  X  imag coefficients of S according to the following equations: and where  X  0 6 n 6 W 1  X  .
 Proof. Using Eq. (4) , we substitute the DFT n  X  S  X  with the real and the imaginary part: Using the Euler X  X  formula, we get:
By algebraic manipulations in the above equation we get Eqs. (7) and (8) . h
References
