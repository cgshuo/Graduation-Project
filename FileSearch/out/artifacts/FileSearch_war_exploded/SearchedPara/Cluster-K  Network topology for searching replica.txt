 1. Introduction
Peer-to-peer (p2p) applications consume the majority of the Internet bandwidth ( Ipoque, 2008 ). Furthermore, the variety focused on developing efficient data processing search strategies that minimize resource consumption and yet provide gen-erally desired data processing functionality. Consistency among replicas is one such functionality.

In p2p environments, file copies, called replicas, are distributed among network nodes, namely, peers. By the very nature licas are typically assumed as static in terms of content, consistency among the replicas is not a concern. Today, however, p2p applications are being touted as possible means for general information dissemination. In such applications, replicas might no longer be static; thus, consistency among the replicas must be guaranteed.

We focus on p2p systems that handle non-static files, i.e., files that are continuously updated such as software, logs, or news updates. Consider, for example, relief workers (a potential p2p community) that share, disseminate, and coordinate Replicas in such domains must remain consistent; otherwise, relief resources may be dispatched erroneously. Furthermore, in devastated communities, a centralized infrastructure might not be available and a self-organizing, resource-sharing, dis-tributed control environment, such as p2p, is one of only few viable coordination and dissemination options.
Updateable, rather than static data, information dissemination networks must not only efficiently locate and retrieve objects of interest but must also maintain consistency by ensuring timely updates to the subscribers. Given that p2p systems generally consist of many thousands of peers, maintaining replica consistency in an efficient manner with continually added,  X  updates to all interested peers is needed.
 the number of labels a peer may express interest in.
 supports ease of retrieval, addition and updates of labels in an unstructured network. The Cluster-K + architecture, based on the complete K-ary tree, ensures consistency of labels in the dynamic environment of p2p networks. That is, consistency is maintained although peers join and leave regularly or change their data interest during connection. Our approach is scal-able and efficient for very large p2p systems. Our proposed structure guarantees a short response search time of O ( H + K ), both rare and popular objects in the network.
 are discussed in Section 5 followed by our conclusion in Section 6 . 2. Related work
It employed flooding across a scope of the network to process queries. This obviously results in very poor scalability of the system, as the number of peers grows. Yee, Nguyen, and Frieder (2007) characterize both the type of queries that are issued and the data being shared to provide a better understanding of these systems. To improve scalability and query response time of Gnutella-like systems, most unstructured decentralized p2p networks ( Liang, Kumar, &amp; Ross, 2006; Kleis, two-tier topology where a subset of peers, called ultrapeers or super-peers, form an unstructured mesh while other participating peers, called leaf peers, are connected to the top-level overlay through one or multiple ultrapeers ( Stutzbach &amp; Rejaie, 2005 ).
 ing the network. The super-peer is a peer node in charge of indexing information across its cluster. It is connected to other super-peers of other clusters. Queries are routed through the super-peers to reduce the flooding of queries across the net-work. Kleis et al. (2005) propose Lightweight SuperPeer Topologies (LST) for hierarchical p2p networks which uses highway proximity clustering. The Gia system ( Chawathe, Ratnasamy, Breslau, Lanham, &amp; Shenker, 2003 ) improves on the perfor-mance of the two-tier topology via the random walk ( Lv, Cao, Cohen, Li, &amp; Shenker, 2002 ) search protocol and a one-hop replication for each peer.
 large document collections. Winter (2008) demonstrates an approach suitable for routing structured queries in very large distributed systems.
 a hypercube structure to increase query efficiency. The network is partitioned into a various interest clusters based on the phenomenon that one user, at any given time, is usually interested in a few topics (typically one or two) and tends to issue tem is equivalent to our label . The label nets can be viewed as the interest clusters.
 multiple interest clusters. In our grouping of the network into a tree of clusters, peers mapping to the same cluster may be-groups. Our proposed system goes beyond this objective by also dealing with the maintenance of consistency of the replicas ensures timely updates and easy location and retrieval of any set of replicas in the network.
 topology is tightly controlled and content is placed not at random peers but at specified locations based on the network scheme utilized. Examples of structured schemes include Content Addressable Network (CAN) ( Ratnasamy, Francis, Handley, tree structure for efficient search of both exact and range queries which they further generalized to a multi-way tree in Jagadish, Ooi, Tan, Vu, and Zhang (2006) .
 store or maintain; where there exists a correlation between data stored at a given peer and the location of the peer in the network. This makes subsequent searches more efficient as compared to the unstructured networks where the searches are increasingly more difficult due to randomness and replication of data in the network. However, this type of setting is not practical for an open information-sharing p2p environment where each peer joining has unilateral control over which data it is interested in searching for.

Some work has been done on publish-subscribe systems such as Meghdoot ( Gupta, Sahin, Agrawal, &amp; Abbadi, 2004 ). Their content-based system is implemented over a DHT based on CAN ( Ratnasamy et al., 2001 ). The focus of our work is not re-stricted to publish-subscribe p2p systems where the publisher is responsible for the updates and the subscribers are then subsequently informed such as stock quotes. The peers in our system can update their replica. The other peers in the label net pertaining to the updated label must be notified of the update, to ensure consistency. We design a system that helps to keep track of replicas of the same or similar file  X  labels .

We focus on the challenge of efficient maintenance and location of label nets (overlapping sub-p2p systems) within an unstructured reliable p2p network where the information at the nodes is unrelated to their placement in the system. 3. Cluster-K + architecture 3.1. Preliminaries label nets, as shown in Fig. 1 .
 network. We model L j as a connected graph so that there exists efficient communication among the peers in a given label net to ensure timely updates. We could say that this group of peers form a simple hyperedge or some other structure that main-tains commonality.
 and retrieving any label l j is reduced to finding a peer p i that belongs to L j . 3.2. Description of proposed structure have the same depth. A Cluster-K + tree for a network P is defined by two parameters -the clustering factor k and the peerID algorithm ensures the consistency of the tree structure by maintaining the following invariant:
Definition 1. Clustering Invariant : At any depth d in the tree, peers belonging to the same cluster (tree node) share a common k d peerID prefix.
 the Cluster-K + structure is not valid. Note that the clustering factor is a dimensional parameter of the network, as defined above, which differs from the algorithm invariance.
 to w . Let ps(w) denote the peer X  X eer associated with a tree node w and w(ps,d) denote the tree node w associated with a peer X  X eer ps at a depth d in the tree. We formally define it as follows: peer X  X eer ps .
 peers into the p2p system. All protocols supported by our structure, as described in Section 4 , are shown to maintain the the tree. A leaf node represents the minimal cluster of peers possible in the network. Every peer belongs to a unique leaf leaf. The properties of the Cluster-K + tree are listed in Table 1 . 3.3. Motivation for Cluster-K + tree the network or restructuring except when the network parameters ( n, k ) are redefined, though the network itself is dynamic since the peers are transient. Advantages of a structurally static overlay for a dynamic network are: 1. Scalability: Performance is not impaired by sparseness or denseness of the tree. 2. No penalty cost of restructuring/splits when a peer joins/leaves: The cluster each peer belongs to is predetermined based on the clustering invariant. To join P , a peer simply locates its appropriate leaf cluster. If it is empty, it initiates it.
There are, however, certain disadvantages for maintaining a static structure. For example, if all peers in P mapped to the same leaf cluster then the tree structure is of no benefit since there is only one non-empty wl in P mapped to the same leaf cluster. However, this is rare since the fanout K j P j . Another is when majority of clusters are empty resulting in a very sparse tree which may lead to an unbalanced tree structure. This is not a major concern. Having an unbalanced tree structure implies that performance of the network will tend towards the worst-case bound. A random assignment of peerID to each peer joining the network helps ensure a normal distribution of the peers in the tree. 3.4. Peer X  X eers
Peers belonging to the same cluster do not necessarily share common label interests. They may subscribe to different la-easy search and retrieval of label s.

Every non-empty node w in the tree has a representative ps ( w ) which maintains some information pertaining to the label s of all the children nodes of w in the tree while ps [ parent(w) ] is the peer X  X eer of the parent node of w . information about the labels of peers 2 T ( w ) in a label-view table LVT . The LVT of a peer X  X eer ps is formally defined as traversal up and across the tree, in the worst-case.

The LVT of ps(w) provides label information on the peers in its subtree rooted at w . The peer X  X eers of nodes closer to the is a connected graph. To avoid an information overload or space complexity, we define a reduced version of LVT as: information of up to m peers are stored.

As the labels of T(w) of ps(w) enlarges, it is not overloaded with information since it maintains only the sufficient amount of information necessary to have representation of all the labels within its subtree. LVT m is dynamically updated when the number of peers representing a label in the table falls below m , as described in Section 4.4 . 3.4.1. Communication between peers and peer X  X eers resents the peer X  X eer associated with the leaf node of peer p . Given the hierarchal nature of the Cluster-K + structure, ps [children( w )].
 height of the tree H . However, the path is usually much shorter than H given that once a peer is a peer X  X eer of a cluster sists only of { p A }, the unique peer X  X eer along the path.
 network map to the same cluster at the root. Rather, at depth 1 in the tree, all the peer X  X eers at that level maintain a link to each other so as to be able to traverse across the tree. The implication of this is the K in the performance bound of our system O ( H + K ). There are at most K peer X  X eers at depth 1 in the tree; therefore, to communicate with all the peer X  X eers at that level takes K messages. 4. Cluster-K + protocols ipations in label nets , and routing of label queries. 4.1. Peers joining the network joins the network by contacting an existing peer in the system. The Join-P protocol secures membership in P for a new peer p uted nature of our algorithm, every peer currently in P can serve as an entry peer p entry for p new . level and all subsequent levels down the tree. The p new is now the ps for its leaf node wl .
 initiating a new one). Whenever a new peer joins P , the peer X  X eer of its leaf cluster is updated by adding the peer onto its children.
 Lemma 1. The number of messages exchanged during the Join-P protocol is O(H + K).
 most H 2+K  X  O ( H + K ). h Lemma 2. The clustering invariant is maintained during the Join-P protocol.

Proof. Lemma 2 is straightforward. From the Join-P algorithm, an affirmative response to join a cluster at any level in the tree is given when the same-cluster-check(d) routine is satisfied. Thus, the clustering invariant is maintained. h Algorithm 1. Join-P : Connects p new by p cur
Join-P (Peer p new , Peer p cur ) 1: d H //start from the leaf cluster 2: p new sends join-P request to p cur 3: p cur performs same cluster check(d) 4: if p new belongs to p cur  X  X  leaf cluster then 5: p cur replies successful join along with ps l ( p cur ) info. 6: p new connects successfully to the network by maintaining a link to the peer X  X eer. 7: else [common cluster not found] 8: p cur replies go up tree along with ps l ( p cur ) info. 9: p new climbs up tree along the path-of-peer X  X eers(p cur ) to locate its common cluster at level d i 10: p new obtains peer X  X eer ps information of its cluster at level d i 11: p new climb down tree along the children peer X  X eer path of ps to locate the peer X  X eer of its leaf cluster 12: if $ a level d j such that no ps 2 children [ ps ( w , d j )] satisfies same-cluster-check(d j+1 ) with p new then 13: p new initiates itself as peer seer of every cluster it belongs to from level d j +1 to leaf end 4.2. Search algorithm for labels By simply, inquiring from the K 1 peer X  X eers at the root, we are able to scope across the entire network to verify the exis-tence of l j . If none of them have information on l j in their LVT , then l j does not exist in the network. A key thing to note is that as P is being populated with peers and labels, some labels will be more popular than others. Pop-proven below.
 Lemma 3. The number of messages required to locate a label in the network is O(H + K).
 Lemma 4. The expected cost E[find-l j ] to locate a label in the network is H.
 that a peer in its cluster has that label .

Let p l denote the probability of a peer in the network with a given label while Pr ( i ) denotes the probability that a peer peer X  X eers at depth 1.
 4.2.1. Insertion of peers into label nets l in P .
 and the degree of label net .
 Algorithm 2. Find-label : p queries network for l j 4.3. Departure from network departure. Its peer X  X eer updates its LVT to reflect the disassociation of the peer from its old labels . ing a peer X  X eer is simplified with the existence of a static tree overlay structure. There are three cases: new peer X  X eer, as detailed above.
 Lemma 5. The clustering invariant is maintained during the departure process.
 still maintained. h 4.4. Update of LVT m information overload on the peer X  X eers. We described the above protocols by considering the worst possible case, in which the representation information. If the peer X  X eer has any children peer X  X eers, it also probes them to obtain the information to refill its LVT m .

An important consideration is how to determine m , the upper bound on the number of peers whose state information addition to the availability of storage. Given that the size of each L j differs according to the popularity of the label and the population of the network, we need to take into account the average size of L j when setting m .If m is much greater than the upper bound m is very high. The population of the network is localized for each peer X  X eer by the size of its T ( w ). The of thumb will be to select m =2 k . 4.5. Summary of protocols We summarize the performance of our protocols in terms of correctness and efficiency using the following theorems: O(H + K) where H  X  log N log K 1 .
 Proof. The proof of Theorem 1 is based on Lemmas 1 and 3 that show that all the protocols involve traversing up and across time to traverse across the tree (given by K). h ant is maintained. Hence the Cluster-K + tree structure is maintained correctly. h 4.6. Robustness and fault tolerance same label , peer failure can be accommodated without introducing significant hardship. The proposed structure guarantees that fails is a peer X  X eer. The above protocols have been designed with the assumption that a peer X  X eer exits the network gracefully.

Given that ours is an unstructured network, the state size of the network is expected to be flux. The key issue is that the peers must maintain a minimum state in which they are connected to the peer X  X eer of their leaf clusters. The peer X  X eers must maintain connection with the parent peer X  X eers (which could be itself) and the children. The system becomes frag-mented when this fails, hence the need for a fault tolerant solution.

Fault tolerance in p2p systems has been an ongoing effort. Many systems ( Risson &amp; Moors, 2006 ) propose replication as an effective way to handle this. For example, Meghdoot ( Gupta et al., 2004 ) uses a replication scheme implemented at a mir-ror image of the node. In our structure, we propose using replication and periodic updates to boost the robustness of our dated with any failed peers in its cluster. A peer is considered to have failed if it sends no response to the peer X  X eer. Our system ensures that the peer X  X eers are not overloaded because the size of the leaf clusters are small, and we utilized LVT m to handle the space complexity.

To offset the implications of the failure of a peer X  X eer, we propose to use current existing replication schemes. The infor-mation at a peer X  X eer is replicated at another peer in the system who would be the potential peer X  X eer (as described in Sec-and immediately replicates its information at the next potential peer X  X eer. 5. Experimental results and evaluation
We evaluate the performance of our structure by simulating a p2p system. We also deployed the system on various computers across our Information Retrieval Laboratory to ensure a fully implementable system. Our goal is to verify the theoretical bounds for the protocols listed in Section 4 .We quantify response time by the numbers of messages sent, which is equivalent to the number of peers contacted, to carry out any operation. We wanted to evaluate: 1. How does the sparseness or density of the Cluster-K tree affect performance of network? 2. How varying k for a given peerID bit-length of n affects the performance of the network? 3. The trade-off between the fanout and the height of our tree with respect to performance. 4. Response time for searching for labels. 5.1. Performance of the Join-P protocol overhead cost for our system. Thus, we evaluated the protocols cost experimentally determining an approximate actual run-time corresponding to our theoretical bound of O ( H + K ). 5.1.1. Scalability of the Cluster-K + tree worst-case performance. We simulated a p2p network P randomly assigning each new peer joining a peerID of bit-length We ran 500 simulations of 10,000 X 60,000 peers joining P to obtain the expected and maximum cost of Join-P protocol. bound O ( H + K ), we expect the number of messages to be 6 c (3 + 16) = c 19 where c is a constant. As we can observe from network grows. The experimental maximum cost obtained is 17, which is 6 c 19, thus less than the theoretical estimated cost. The maximum cost fits within the theoretical bound for all the different scenarios. The results obtained affirm Theorem 1 that independent of the network size, the performance is bounded by O ( H + K ). 5.1.2. Effect of sparseness on the performance of the Cluster-K + tree static structure could imply inefficiency when the tree is sparse, i.e., when the number of peers currently contained in the network is much less than the capacity of the network. The experimental results presented in this section demonstrate the performance of our structure, even in a sparse environment, is bounded by O ( H + K ).

We ran a series of simulations with 10,000 X 100,000 peers randomly joining a p2p network P using the IP address ( n = 32 bits) of each peer as its peerID. Thus, the capacity of P is 2 32 4.3 billion peers. Therefore, simulating with &lt;100,000 peers is operating at a maximum of 0.002% of the capacity of P . We randomly assigned an IP address to each new peer attempting to join the network. We obtained the expected and maximum cost of Join-P protocol over 500 simulation runs with the clustering factor k = 4. Therefore, H = 7 while K = 16. Our experimental results, as shown in Fig. 3 b, confirm our hypothesis. The theoretical bound is c (7 + 16) = c 23, where c is a constant. The experimental re-sults yield a maximum cost of 25 . Thus, we can observe that the maximum number of messages is indeed bounded by O ( H + K ). 5.1.3. Performance trade-off cost: Optimal value of k
The performance of our structure is given by O ( H + K ). Given that the value of both H and K depends on both the clustering k 1. Our protocols entail traversing up and down the tree and occasionally, across the tree at level 1. From a theoretical is not too large, given the exponential relationship.

We ran simulation experiments to verify our theoretical analysis by observing the effect of varying k on network perfor-mance for a fixed n . We repeated the same experiments we had done earlier to proof scalability ( n = 16) and network size independence ( n = 32) but this time around, varying k . The experimental results for both network sizes are illustrated in tocol increased.

The experimental results obtained demonstrated the practicality of our theoretically confirmed approach. When the val-ues of k is large, the performance of the network is worse compared to smaller values of k . For the p2p network with n = 16, a multi-hierarchal structure. The performance at k = 3 and k = 4 are almost the same because the resulting bounds are very close in values. For k =3, H + K =4+2 3 = 14 while for k =4, H + K =3+2 4 = 19. Therefore, when the theoretical values of the performance bound is very close for the different sets of the parameters, we may observe an insignificant difference in the actual performance.
 5.2. Performance of the search algorithm
We analyze the performance of find-label protocol in a similar way to the Join-P protocol experiments. After joining the network, each peer randomly selects its label ( s ) of interest. The number of labels each peer could be interested was ran-a find-label protocol. We evaluated the performance of the find-label protocol at the point any peer sends a Join L j request.
 The initial simulation runs focused on the performance of find-label as the popularity of a label increases in the network. We also expect that the performance should not decrease significantly as the number of peers in the network grows.
We can observe that from the experimental results obtained, shown in Fig. 4 a, that initially the performance of the find-label net , the response time oscillates around 2 hops, an acceptable steady state performance given the small percentage of network peers participating in the label net ( 0.2%).

Our next objective was to evaluate the scalability of the find-label protocol as the number of peers in the network in-creased. We varied the size of the network ( n = 16 bits and k = 3) from 5000 to 30,000. We measured the maximum cost for the varying network size to evaluate the worst-case performance. We anticipated that it should be bounded by O ( H + K ). From the results obtained, the performance was constant as the network size increased demonstrating the scala-to 40,000 peers and measured the expected cost of the search protocol. From the results shown in Fig. 4 b, we can observe that the expected response time is H , as intuitively anticipated based on the theoretical analysis.
To evaluate the effect of varying k for a fixed n on the expected response time of the find-label protocol, we simulated a Fig. 4 c, the performance decreases as k increases.
 5.3. Comparison of performance with other systems
We demonstrated the practicality of our theoretical bounds by extensive simulations. We now compare our theoretical bounds to other unstructured network protocols such as the traditional Gnutella ( Klingberg &amp; Manfredi, 2002 ) which uses ries are flooded among the super-nodes (ultrapeers). According to Table 2 , the performance of our protocols exceed the other systems.

Comparing our system to structured network schemes such as CAN ( Ratnasamy et al., 2001 ) and Chord (distributed look-up protocol) ( Stoica et al., 2001 ) is like comparing apples to oranges. The structured networks have the advantage that the data at a given peer are associated with the location of the peer in the network. We reran our simulation experiments to simulate a similar environment by placing the constraint of one label per peer in the network. However, there was no cor-relation between the location of the peer in the network and the label it had. The performance of the search protocol in this scenario was the worst-case performance of O ( H + K ).

Thus, we can confidently compare our theoretical bounds to that of CAN and Chord to demonstrate that our protocol per-forms better, as shown in Table 3 . 6. Conclusion
We presented a new model for maintaining consistency of replicated data in unstructured p2p networks. We demon-strated that the Cluster-K + structure is an effective and efficient overlay network topology solution for the organization and maintenance of the multiple label nets in a p2p network including, a short search response time for queries. age response time of O ( H ).
 We plan to develop a more integrated and robust failure mechanism for our tree structure beyond peer X  X eer replication. We also plan to explore more effective network schemes for managing peers within the label net s.
 References
