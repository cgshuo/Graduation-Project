 It has been well recognized that mining frequent patterns such as itemsets, se-quences, trees and graphs plays an essential role in many important data mining tasks. There have been many studies on efficient and effective frequent graph mining. AGM [3], FSG [4], gSpan [11], CloseGraph [12], FFSM [2], and Adi-Mine [10] have been presented for improving scalability on mining subgraphs one after one. However, the extraction is not always tractable for the user-defined support thresholds, especially when the data is dense or highly correlated. Even if it is tractable, the size of the output can be huge. The lack of focus leads to many uninteresting subgraphs to be derived.
 in constraint-based mining, by means of a class of constraints for representing application requirements. The cost for mining frequent patterns and the size of the output can be reduced effectively by pushing constraints deep into mining process. Many constraint-based algorithms for mining frequent patterns such as itemsets [5, 7] and sequences [1, 8] have been developed. However, there is little work on constraint-based graph mining.
 structure-critical. The user always expects to obtain focused frequent graphs con-taining certain subgraphs in these applications. For example, in structural analy-sis of chemical compounds, chemists wish to extract certain molecule structures which not only satisfies support threshold but also contains special substruc-tures. Therefore, it is important to perform a systematic study on constraint-based graph mining.  X  X ow can we characterize various kinds of constraints in graph mining? How can we push constraints deep into graph mining process for efficient extraction? X  These two problems motivate us to study more. and then characterize them. The concepts of monotonic, anti-monotonic and succinct constraints are extended to context of graph mining. We also point out some non-monotonic constraints to be commonly appeared in graph mining. A framework, called CabGin , is built to push constraints deep into mining process based on Adi-Mine [10]. Moreover, some tough aggregate constraints such as average can also be pushed deep into mining process with minor revision. Our performance study shows that CabGin can prune a large search space effectively and reduce many unfocused, uninteresting frequent graphs.
 various kinds of constraints in graph mining. In Section 3, we develop a frame-work CabGin to mine graphs with constraints. In Section 4, we evaluate the performance on synthetic datasets via comparing with gSpan and Adi-Mine . Related work is introduced in Section 5. We conclude the paper in section 6. A labeled graph can be represented by a 4-tuple, G =( V, E, L, l ), where V is a set of vertices, E  X  V  X  V is a set of edges, L is a set of labels, l : V  X  E  X  L in which l is a function assigning labels to the vertices and edges. Given an undirected graph G , if a path exists between any two vertices, G is called a connected graph . In the case that G is a directed graph, the above definition applies to the undirected graph obtained by ignoring directions of edges in G . Graph G =( V, E, L, l ), subgraph G s =( V s ,E s ,L s ,l s )of G fulfills the following condition: V s  X  V , E s  X  E . It is denoted as G s  X  G .
 problem of constraint-based graph mining is to find the complete set of graph patterns satisfying a given constraint C . Given a constraint C , the complete set of graph patterns satisfying C is denoted as SAT ( C ).
 of constraints based on the semantics. Although this is not complete, it covers most of useful constraints in applications.
 Constraint 1 (Element Constraint). An element constraint specifies what are the particular individual or groups of elements that should or should not be presented in the graphs. The elements consist of two parts: vertices and edges in or C edge (  X  )  X  (  X  i :1  X  i  X  SizeOfEdges (  X  ) , X  [ i ]  X V ) ,where V is a subset of elements,  X   X  X  X  ,  X  X  and  X   X  X  X  ,/  X  X  .
 Constraint 2 (Size Constraint). A size constraint specifies the requirement on the size of graph patterns, where the size can be either the number of edges or the number of vertices.
 Constraint 3 (Super-Graph Constraint). A super-graph constraint speci-fies what are the particular individual or groups of subgraphs that should or should not be appeared in the graphs. It is the form of C Graph (  X  )  X  (  X p X  X , p  X  P ) ,where P is a set of particular subgraphs,  X   X  X  X  ,  X  X  and  X   X  X  X  ,/  X  X  .
 Constraint 4 (Distance Constraint). A distance constraint specifies the re-quirement on a set of distances, where the distance should be the number of edges from one particular vertex to the other.
 Constraint 5 (Aggregate Constraint). An aggregate constraint is the con-straint on an aggregate of vertices of edges in a graph, where the aggregate func-tion can be sum , avg , max , min ,etc.
 constraints can be categorized into several major classes such as monotonicity, anti-monotonicity and succinctness.
 Definition 1 (Anti-monotonic Constraint). An anti-monotonic constraint is a constraint C a such that for all subgraphs s belonged in a graph S satisfy C a if S satisfies it.
 Definition 2 (Monotonic Constraint). A monotonic constraint is a con-straint C m such that for all super-graphs s derived from a graph S satisfy C m if S satisfies it.
 constraint is also an anti-monotonic (monotonic) constraint.
 Definition 3 (Succinct Constraint) 1. An edge E s  X  E is a succinct edge set if it can be expressed as  X  p ( E ) for 2. SP  X  2 E is a succinct powerset if and only in there exist a fixed number of 3. Finally, a constraint C s is succinct provided SAT ( C s ) can be expressed in characteristics of some commonly used constraints for graph mining are shown in table 1. After characterized into several major classes, constraints will be easily pushed deep into CabGin introduced in next subsection. 3.1 Preliminary Knowledge on Graph Mining In this paper, we focus on undirected labeled simple graph. We use 4-tuple, G =( V, E, L, l ), to represent a labeled graph. Subgraph G s =( V s ,E s ,L s ,l s )of G fulfills the following condition: V s  X  V , E s  X  E . It is denoted as G s  X  G . Given a set GS of graph structured data, the support sup ( G s ) of an subgraph G s is defined as a ratio of number of graph data including G s to the total number of graph data in the dataset GS .
 Definition 4 (Isomorphism and Subgraph Isomorphism). An isomor-phism is a bijective function f : V ( G )  X  V ( G ) , such that (1)  X  u  X  V ( G ) , l l G ( f ( u ) ,f ( v )) . A subgraph isomorphism from G to G is an isomorphism from G to a subgraph of G .
 minsup ,if g is isomorphic to a subgraph of G , then  X  ( g, G ) = 1, otherwise  X  ( g, G )=0.  X  ( g, GS )= sum G i  X  GS  X  ( g, G ),  X  ( g, GS ) denotes the occurrence frequency of g in GS , i.e. the support of g in GS . Frequent Subgraph Mining is to find each graph, g , such that  X  ( g, GS ) is greater than or equal to minsup . by X. Yan et al. [11], including its definition and property. The details on them refer to [11]. 3.2 Mining Graph with Constraints The high level structure of framework CabGin is shown in figure 1. While mining frequent subgrahps, CabGin grows the size of subgraphs by adding edges one by one. The framework mainly consists of two part: preprocessing graph set (Lines 1-5) and mining frequent subgraphs (Lines 6-15).
 The Part of Preprocessing Graph Set (Lines 1-5): The original dataset could be shrunk by cutting those graphs unsatisfied with a few succinct con-straints, which would never be considered in the subsequent process. The op-eration (in line 1-2) could help to scan and process the graph set as small as possible in the whole mining process. As a result, check all succinct constraints in
C firstly for decreasing the size of graph set GS . Then, scan the graph set once again and find all frequent edges by support threshold minsup . Next, construct adjacency database ADB for edges in graph set GS ordered by constraints and support. The data structure ADB is used to store the edge information and the detail about it will be described in the following section. Because a few con-straints such as element constraint will affect the appearance of certain edges in frequent subgraphs, the edges must be processed as early as possible for cutting search space. Therefore, the edges correlated with constraints will be initialized into ADB and ordered by their support firstly. Afterward, initialize the rest of edges in GS and put them into ADB by their support. At last, initial the set of constraint-based frequent subgraphs with empty and get ready for next part. The Part of Mining Frequent Subgraphs with Constraints (Lines 6-15): For each edge in adjacency database ADB , the following steps are taken one by one. In the circular steps, algorithm initials the checking results checkup for all constraints in C with empty at first. Then, call a procedure Check-Constraints (in line 8) to check whether the current pattern e satisfies all kinds of constraints in C . According to the checking results, the procedure will revise the corresponding items in checkup and return it. After checking constraints, firstly pay attention to those anti-monotonic constraints in C . If the pattern e unsatisfies any anti-monotonic constraint, the algorithm will break off and jump out from the current circulation. According to the property of anti-monotonic constraint, the algorithm could trim the search space in that any super patterns containing e would never satisfy the constraints. Afterwards, if the pattern e sat-isfies all constraints in C , e would be added into the set S of frequent subgraphs. In order to mine all subgraphs containing the edge e , we need to create a new adjacency-projected database ApDB like line 13. The ApDB mainly consists of those edges which is adjacent to e in the GS . Procedure Subgraph-Mining grows all nodes in the DFS Code Tree [11], shown in figure 3, rooted at the edge e in the current round. The detailed process of Subgraph-Mining will also be introduced in the following section. At last, shrink the adjacency database ADB by removing the edge after all descendants of this 1-edge graph have been searched.
 Adjacency Database for Edges. In order to mark an edge in a graph uniquely, the vertices and the edge between them. To further distinguish an edge from a graph set, another factor of identity of a graph must be considered. In the part of preprocessing graph set, the dominating problem is how to represent the original graph set with an efficient data structure. Therefore, we propose an idea of using adjacency database for edges in stead of original graph set as shown in figure 2. Recording edges information, each of which includes a 5-tuple and graph identity, and their adjacency information in each graph as a database, we can easily represent a graph set with it. The proof of this property is omitted in this section. Adjacency database in CabGin can be more convenient to min-ing constraint-based frequent subgraphs than sparse adjacency list presented in gSpan [11]. In figure 2, there are three essential objects: Edge , InGraph ,and Identity . Left vertex label, right vertex label, and edge label in Edge are equiv-a graph set is also registered in InGraph . Left vertex ID and right vertex ID in Identity represent i and j in 5-tuple. Meanwhile, we link all adjacent edges in each graph by their Identity .
 Procedure Subgraph-Mining. The details of procedure Subgraph-Mining in the part of mining frequent subgraphs with constraints are also shown in figure 4. In this procedure, we firstly find out all frequent adjacent edges in adjacency-projected database ApDB constructed in last round by support threshold minsup and store them into database FEDB . Then, for each edge in FEDB , the fol-lowing steps are taken recursively in the search space shown in figure 3. At first, compute a new DFS code when an adjacent edge is added into the current graph pattern and estimate whether it equals to minimum DFS Code. If not, the current pattern could not be considered for it has been discovered in the prior course. Otherwise, call a procedure Check-Constraints (in line 6) to check whether the current pattern s code satisfies all kinds of constraints in C .The process is almost same to the part in the figure 1. After checking constraints, Subgraph-Mining also looks over those anti-monotonic constraints in C firstly. If the pattern s code unsatisfies any anti-monotonic constraint, the algorithm will return to the last call. Otherwise, if the pattern s code satisfies all constraints in C , s code would be added into the set S of frequent subgraphs. At last, con-struct new adjacency-projected database ChildApDB of the pattern s code by uniting ApDB with those adjacent edges of edge ae . Meanwhile, recur to call the procedure in line 12 again. 3.3 Pushing Tough Aggregate Constraints into CabGin with As shown in table 1, some tough aggregate constraints such as those involving avg() and sum() with both positive and negative values are non-monotonic. Is it possible to push these commonly used aggregate constraints into CabGin with minor revision? v as the example for pushing tough aggregate constraints deep into CabGin . Assume edges in graphs have been labeled with numeric value for convenience to computer average value of edges in each graph. Also, we only consider edges as the object with constraints. 1. In the first scan of the database, remove those edges with unpromising big 2. Similarly, in the recursive process, for a projection  X  =  X  |  X  ,let m be the 3. For further improving efficiency on pushing tough aggregate constraint deep In this section, we evaluate the performance of CabGin in comparison with Adi-Mine [10] and gSpan [11] on synthetic datasets. All the experiments are performed on a 733MHz Intel Pentium III PC with 512MB main memory, run-ning Red Hat Linux 9.0. The executable file of gSpan is provided by X. Yan in University of Illinois at Urbana-Champaign.
 they do not push any constraints into mining process. We assume that the user mines the complete frequent graphs and then filter those unfocused graphs with constraints. Furthermore, we assume that the time for filtering those uninterest-ing patterns is negligible entirely. Therefore, the runtime of the both algorithms in this section will be the time spent in mining complete frequent graphs. lectivity of a constraint as the ratio of the number of patterns SATISFYING the constraint against the total number of patterns. Therefore, a constraint with 100% selectivity filters out no pattern, while a constraint with 0% selectivity is the one filtering out all the patterns.
 Synthetic Datasets Generation. For the performance evaluation, we gen-erate synthetic datasets controlled by a set of parameters shown in Table 2. The details about how to generate synthetic datasets was described in [4]. Lim-ited by space, in this section, we report only the results on a synthetic dataset D 100 kN 30 I 5 T 20 L 200.
 Frequent Graph Mining Without Constraint. We first test the scalability of mining graphs without constraint. Figure 5 shows the comparison between gSpan and CabGin with support threshold decreasing. It is obvious that Cabgin outperforms gSpan about 10 times. The performance of Cabgin is quite close to that of Adi-Mine when they mine the complete set of frequent subgraphs. The reason is that Cabgin import the similar method as Adi-Mine to enumerate frequent patterns. If we do not consider any constraints during the mining pro-cess, the abilities for the both algorithms are almost the same. We also conduct the experiments on the scalability of the two algorithms on the size of database. The result is shown in figure 6. Cabgin can process large dataset more efficiently. Figure 7 shows the results of scale on mined subgraphs from figure 6. Pushing Anti-monotonic Constraints into Graph Mining. Figure 8(a) shows the scalability of Adi-Mine , gSpan and CabGin on pushing anti-monotonic constraint sum (  X  )  X  v (with non-negative values) into the mining process. With various setting of v , the constraint can achieve various selectivities. The sup-port threshold is set to 0 . 01. The users always wish to extract focused graphs rapidly, especially when the constraint selectivity is very weak. As we know, anti-monotonic constraints, like support threshold, can be used to cut the search space and improve efficiency on mining frequent patterns. Therefore, it is easy to find that CabGin mines frequent graphs efficiently by pushing anti-monotonic constraints into mining process.
 Pushing Monotonic Constraints into Graph Mining. Monotonic con-straints can be used to save the cost of constraint checking, but it can not cut the search space any more. By pushing monotonic constraint into mining process, CabGin can save much effort on constraint testing. Figure 8(b) shows the scalability of Adi-Mine , gSpan and CabGin on pushing monotonic constraint Distance ( v 1 ,v 2 )  X  d . With various setting of d , the constraint can achieve vari-ous selectivities. The support threshold is set to 0 . 01.
 Pushing Succinct Constraints into Graph Mining. Figure 8(c) shows the scalability of Adi-Mine , gSpan and CabGin on pushing succinct constraint { edge ( v 1 ,e,v 2 ) } X   X  into the mining process. With various setting of the number of edges , the constraint can achieve various selectivities. The support threshold is set to 0 . 01. In the experiments, when selectivity is low, CabGin could save a lot of cost to scan the original database and count the frequent patterns. The reason is that large quantity of original graphs which unsatisfy succinct con-straint { edge ( v 1 ,e,v 2 ) } X   X  will be delete from graph set. With the decreasing of the size of the database, scanning and counting will also be alleviated. Pushing Tough Aggregate Constraints into Graph Mining. We have also tested Adi-Mine , gSpan and CabGin on pushing tough aggregate constraint avg (  X  )  X  v into graph mining. The result is shown in figure 8(d). As can be seen, when se-lectivity is weak, CabGin prunes a good number of projected database and search space. It is interesting to see that the curve in figure 8(d) is very sharp. This indi-cates that the major cost in CabGin is mining projected database. As the number of projected database can be cut, the runtime can be brought down accordingly. Many studies have contributed to the efficient mining of graph patterns [2, 3, 4, 10, 11, 12]. A. Inokuchi et al. [3] presented an efficient algorithm called AGM to dis-cover all frequent induced(possibly disconnected) subgraphs in a graph database which satisfy a certain support threshold. M. Kuramochi et al. [4] developed a more efficient algorithm named FSG , employing edge-growth instead of vertex-growth, to find all frequent connected subgraphs. X. Yan et al. [11] proposed a new graph-based substructure mining algorithm, without candidate generation, which outperforms FSG significantly by an order of magnitude. gSpan adopts depth-first search(DFS) as opposed to breadth-first search(BFS) used inherently in Apriori-based algorithms. Furthermore, X. Yan et al. [12] developed the idea of Close-Graph based on gSpan in order to generate a much less number of frequent sub-graphs without loss much useful information. J. Huan et al. [2] propose a novel fre-quent subgraph mining algorithm FFSM , which employs a vertical search scheme within an algebraic graph framework. Afterwards, we [10] present a novel adja-cency index for mining disk-based graph database and develop scalable algorithm Adi-Mine by transplanting the adjacency index into gSpan .
 paradigm of constraint-based patterns mining. At first, itemset constraints were incorporated into association rules mining [9]. A systematic method for the incor-poration of two large classes of constraints, anti-monotonicity and succinctness, in frequent itemsets mining was presented in [5]. A thorough study on pushing anti-monotonic, monotonic, succinct and convertible constraints to frequent pat-terns mining was developed in [6, 7]. M. Garofalakis et al. [1] proposed the use of regular expressions as a flexible constraint specification tool that enabled user-controlled focus to be incorporated into the sequential pattern mining process. J. Pei et al. [8] categorized constraints into several major classes and systemat-ically studied constraint-based sequential pattern mining. In this paper, we characterize constraints for graph mining from application points of view. A framework CabGin is developed to push constraints deep into the mining process. With some minor extension, some tough constraints, like the aggregate avg , can also be push deep into CabGin . Our experimental results show that CabGin is efficient and scalable in mining large databases. In future, it is interesting to extend it to mining tree patterns such as XML data.
