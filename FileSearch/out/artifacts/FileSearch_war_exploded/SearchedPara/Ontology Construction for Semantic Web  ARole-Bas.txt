 Semantic web is designed as the next-generation web. It augments the current web by adding machine understandable content to web resources, providing ex-tra information on content, and enabling agents acting on behalf of humans to reason with the information obtained[1, 2]. Ontologies are often seen as basic building blocks for the semantic web, as they provide a shared and reusable piece of knowledge about a specific domain. With the rapid development of se-mantic web, the scale and complexity of ontologies grow fast. The construction of large-scale ontologies will involve efforts of multiple developers. The collabora-tive construction of ontologies is a complicated task, and the main challenges are: i) how to avoid interference of different developers X  works; ii) how to arbitrate among different (even opposing) opinions of developers.
 current operations of multiple developers on the same ontology. KAON[3, 4] is the representative one among them. It resolves concurrence and conflict prob-lems by transaction and locking. It adopts a client-server system structure. An engineer server runs as a server, and user can connect to the engineering server through a client panel. Different users operate concurrently the same ontology on the engineering server. This is really a good approach to make a collabora-tive development environment, but there are some limitations. First, there is no distinction of roles. Ordinary developers can operate the ontology just as the domain experts, which may induce errors or conflicts. Second, the concurrence degree is low because of the (tree-) locking on the ontology. If too many people operate concurrently, the system may be inefficient. Third, the workspace is pub-lic for every developer. If developers have different opinions, the latter operation will overwrite the former without discussion.
 software code does. Tool for managing versions of software code, such as CVS[5], is a good choice for software engineers to participate in dynamic collaborative projects. Naturally, collaborative development of dynamic ontologies requires tools that are similar to software-version tools[6]. Therefore, they suggest that ontology developers can use the storage, archival, and checkout mechanisms of tools like CVS, and only need to improve the approach of comparing versions of ontologies. However, in CVS, every user must do check-in after he finishes his own work. After check-in, a new version is created in server, and the new version need be merged with the baseline version. In this way, the system record every version of the ontologies, and user can easily find out his operation or contribution done before, but there are still problems. First, the operation such as check-in and check-out is boring and time consuming. Second, the system mechanism is based on the comparison of file content. It does not support ontology stored in database. However database is more suitable for large-scale data. Third, there is still not distinction of roles in this kind of system.
 named RCDM. In RCDM, different developers serving as different roles work concurrently with different ontology views and different privileges, and a semi-automatic conflicts resolution mechanism is adopted to resolve conflicts problem led by different opinions. The method allows more developers to involve in the development process and ensures the correctness and agreement of ontologies. It has been proven by practice that RCDM is realistic and effective.
 3 gives the implementation of RCDM and especially discusses the ontology views control and conflicts resolution problem. Section 4 analyzes the related tools, and compares them with ours. Section 5 draws the conclusion. Ontologies reflect the consensus in some domain. Ontologies may be large or small. Small ontologies may be constructed by a few developers, but the con-struction of large-scale ontologies is labor-intensive and time-consuming. The challenge of constructing a large-scale ontology is how to harmonize different developers with different knowledge backgrounds to work together. Previous tools do not take developers X  backgrounds into account. It treats every developer without difference. However, it is not proper that every developer is permitted to modify the ontology at will. Otherwise confusion will be incurred. Although not every developer is permitted to modify ontology freely, we believe that he should have right to bring forward proposals. Therefore we solve the problem by limiting his privilege and providing limiting views for them.
 distinguished by privileges in the process of ontology construction and the mag-nitude of developers who can act as the role. The more privileges have the role, the less magnitude has developers who can act as the role. All the roles form a pyramidal developer structure. Here, we divide developers into five kinds of roles, which are KMGR (Knowledge Manager), KEXP (Knowledge Expert), KENG (Knowledge Engineer), KPRO (Knowledge Proposer) and KUSR (Knowledge User). The five kinds of roles form a pyramidal structure, which is shown in figure 1.
 domain. He has the most privileges and the highest credibility. His task is to manage the whole ontology. So he can modify the ontology at will and every developer X  work is visible to him. Confronted with conflicts, KMGR is the final arbitrator.
 structure of the ontology. Ontology is dynamic and evolves with time, so it is necessary to adjust the existing structure continually. However, the modification of structure is a complicated task and may influence many parts of ontology. To ensure the consistency of ontology, in our method, KEXP X  work will not take effect until it has been confirmed by KMGR.
 enrich the ontology, so they can only add objects to the ontology. The difference between KENG and KPRO is that KENG X  X  work will take effect at once but KPRO X  X  work will not. It means that KENG has more credibility than KPRO. KPRO is only the proposer of some new knowledge.
 in the web. He is the user of ontology, so he has only the privilege of browsing and querying the ontology.
 are query, addition, deletion and modification. According to RCDM, different roles have different privileges for the operations. The privilege of roles is shown in Table 1. The first column (ROLE) is the name of role. The second column (ADD) shows whether the role is allowed to add objects to the ontology. The third column (DELETE) indicates whether the role is allowed to delete existing objects in the ontology. The fourth column (MODIFY) indicates whether the role is allowed to modify existing objects in the ontology. The fifth column (QUERY) indicates the area accessed by the role. There are three values: All , Base , and Self . All indicates the role can access all objects in the ontology. Base indicates the role can access the objects having been confirmed by KMGR in the ontology. Self indicates the role can access objects created by himself in the ontology. The last column (VALIDATE) explains whether the role X  X  operations (add, delete or modify) would take effect directly after he committed his work.
 rative development method contributes to ontology construction at the following aspects.  X  Multi-role make developer management more easily by classifying developers  X  The method allows more people to participate in the ontology construction.  X  It assures the authority and consensus of ontology because more developers This chapter presents our implementation of RCDM in detail and discusses the important mechanism such as views control and conflicts resolution. 3.1 System Framework The system framework based on RCDM is shown in figure 2.
 are storage layer, management layer and interface layer. As for storage layer, our system support relational database and file system. Relational database is the backbone of collaborative development. In the management layer, the im-port and export module are responsible for importing ontology from OWL or RDF files and exporting ontology stored in database to OWL or RDF files. The file access module is used to access the ontology described by OWL or RDF files. User management module, query processing module,view control module, concurrency control module, conflict resolution module and version control module are used to ensure collaborative work of multiple developers. The views control and conflicts resolution will be discussed in detail in the rest part of this chapter.In the interface layer, the system provides application APIs for other applications to access the ontologies and GUI for users to access the ontologies.
 3.2 Views Control In our system, operations of KEXP and KPRO will not take effect until KMGR confirms them. The objects waiting for confirmation will not be visible to others, so different developers may have different ontology views. Here we use object to represent element in ontology, which is different from object in RDF model. Object here may be delegation of a concept, a property, an instance, or any element in ontology. Objects set of ontology is denoted as O . For object O i ( O developers set in which developers ever delete object O i and Status ( O i )asthe status of object O i . The value of Status ( O i ) can be valid , added or deleted .  X  valid : it means that the object has been validated by KMGR or has been  X  added : it means that the object is added by KEXP or KPRO and has not  X  deleted : it means that the object was deleted by KEXP and the operation system provides different views for different developers. Suppose the whole de-velopers set is D , for developer D i ( D i  X  D ), we define Role ( D i ) as the role of D i and V iew ( D i ) as objects that developer D i can access. V iew ( D i ) is a subset of O . For the five kinds of developers in our system, the principle of composing views of different developers is as following:  X  Role ( D i ) = KMGR :  X  Role ( D i ) = KEXP or Role ( D i ) = KENG or Role ( D i )=KPRO:  X  Role ( D i ) = KUSR : validated by KMGR. So the object with deleted status should be accessible for all others developers. According to our principle, all the objects accessed by KUSR is valid and each KEXP cannot modify the objects added by other KEXP or KPRO and had not been confirmed by KMGR. 3.3 Conflicts Resolution Different developers will have different (even opposing) opinions during the pro-cess of ontology construction. When KMGR begin solving conflict, it is difficult to judge whether the object is preferable to be accepted or deleted. In our system, the operations of KEXP or KPRO will not take effect until they are confirmed by KMGR, but the operations express their opinions on the corresponding object. So we give the following rule:  X  The operation that deletes object O i is regarded as opposing the object O i .  X  The operation that creates object O i is regarded as supporting the object O i .  X  The operation that creates objects related to object O i is regarded as sup- X  The operation that deletes objects related to object O i is regarded as sup-object is related to the other. For example, object  X  X tudent X  is a class and the object  X  X ame X  is a property. If  X  X ame X  is a property of  X  X tudent X  in a ontology, we call  X  X ame X  is related to  X  X tudent X  or  X  X tudent X  is related to  X  X ame X . they have different credibility. So we proposal a weighted statistical algorithm. Here, weight is the reflection of developer X  X  credibility. The weight value is related to each role and the developer acting as a role has the corresponding weight value. To formally describe the algorithm, some functions are defined as following.  X  Status ( O i ): status of object O i , O i  X  O .  X  Creator ( O i ): creator of object O i , O i  X  O .  X  Delete ( O i ): developers set in which developers ever delete object O i , O i  X  O .  X  Related ( O i ): objects that are related to object O i , O i  X  O .  X  CreatorR ( O i ): developers who create the objects which are related to object  X  DeleteR ( O i ): developers who delete the objects which are related to object  X  SD ( O i ): developers that support object O i , O i  X  O .  X  OD ( O i ): developers that oppose object O i , O i  X  O .  X  Role ( D i ): the role that developer D i acting as, D i  X  D .  X  W eight ( Role ( D i )): the weight value of developer D i , D i  X  D .  X  Support ( O i ): supporting value of object O i , O i  X  O .  X  Oppose ( O i ): opposing value of object O i , O i  X  O .
 Algorithm 1.
 Algorithm 1. Supporting Value Computation.
 1. Get the creator of object O x : 2. Get deleting developers of O x : 3. Get the related objects of object O x : 4. if Related ( O x )=  X  then SD ( O x )= { Creator ( O x ) } goto 8; 5. Get all creating developers of Related ( O x ): 6. Get all deleting developers of Related ( O x ): 7. Get supporting developers set SD ( O x ): 8. Get the supporting value of object O x : rithm 2.
 Algorithm 2. Opposing Value Computation 1. Find users who ever delete object O x : 2. Get opposing developers set OD ( O x ): 3. Get the opposing value of object O x : process of KMGR. For object O x , Support ( O x ) reflects the supporting degree of the developers and Oppose ( O x ) reflects the opposing degree of the developers. However, KMGR should not make decision only based on Support ( O x ) and Oppose ( O x ). His own opinion is an important factor too. A good overview, viz. a comparative study of existing tools up to 1999, is given in[7]. Naturally, it could not fully consider the more recent developments. Here we focus on the latest tools and that supporting collaborative construction for ontologies.
 tive development of consensus ontologies by access control of user and group and multi-user sessions. The Ontolingua Server uses the notion of users and groups that are typical in most multi-user file systems. As with file systems, access to ontologies such as read and write, is controlled by the ontology owner giving access to specific groups. This mechanism supports both access protection as well as collaboration across groups of people who are defined within the ontol-ogy development environment. The server provides supports for simultaneous work through group sessions. When a user opens a session, she may assign a group ownership to it. This enables any other members of that group to join the session and work simultaneously on the same set of ontologies. A notification mechanism informs each user of the changes that other users have made. laboration with reasoning and allows individuals to add to an ontology only when consistency is retained within the ontology as a whole. In Ontosaurus, changes can only be made by an individual user if they are consistent with the rest of the ontology. This is made possible due to the reasoning capabilities built-in to the LOOM representation language and prevents inconsistent ontologies from being built. Due to the simple  X  X tate-less X  HTML interaction, it has several lim-itations. E.g. does a server not maintain any state information about users, i.e. clients, nor is it possible for a server to initiate an interaction on its own, e.g. alerting users to simultaneous changes by others.
 development environment for the Semantic Web. To ensure safe development conditions, OntoEdit employed a locking and transaction protocol. It adopts the strategy of locking a complete subtree of the concept hierarchy. After the subtrees have been locked no conflicts can arise anymore. This (tree-) locking information is distributed to all other clients and visually indicated in the GUI. KAON, as the successor of OntoEdit, adopts similar concurrent controlling strategy. gives support to most of the activities involved in the ontology development pro-cess proposed by METHONTOLOGY. It offers inference services and an axiom manager (providing functionalities such as an axiom library, axiom patterns and axiom parsing and verification), but the very brief mentioning of these function-alities is too short to assess precisely. About collaboration, it is said that this is supported at the knowledge level, but how this is achieved remains open. OilEd[13] in the context of the European IST On-To-Knowledge project, offer sophisticated support for ontology engineering, but lack sophisticated support for collaborative ontology engineering.
 lists eight tools, Ontolingua, Ontosaurus, OntoEdit, KAON, WebODE, Prot  X  eg  X  e, OilEd and our cooperative ontology development environment (abbr. CODE). The column Developer, Ontology Storage, Collaboration Control, and Conflicts Resolution show the corresponding tool X  X  developer, ontology storage mode, col-laboration control strategy, and conflicts resolution method in turn. The last column User Demand indicates the developers demanded on condition that on-tology validity is ensured.
 make developers management more easily by adopting the pyramidal taxonomy of developers. ii) It has good conflicts resolution method by using the weighted statistical algorithm. iii) It integrates wisdoms of different kinds of developers, no matter whether they are domain expert or not. This paper discusses the challenging issues in constructing large-scale ontol-ogy and proposes a practical collaborative ontology development method. The method allows more developers to involve in the ontology development process, so that the constructed ontology may reach a better coverage of a specific domain of interest.
 The work was supported by the National Science Foundation of China (Grant No. 604963205) and 211 project. Thanks to graduate students Yan Wang and Yiyu Zhao for their work to the system realization.

