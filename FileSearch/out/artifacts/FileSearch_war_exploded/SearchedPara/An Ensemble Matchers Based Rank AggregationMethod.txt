
Hailun Lin 1 , Yuanzhuo Wang 1 ,YantaoJia 1 , Jinhua Xiong 1 , Peng Zhang 2 , As is known to all, a knowledge base is a formal collection of world knowledge including instances, relations and classes. And a taxonomy is a collection of classes, which are used to semantically classify or annotate knowledge items in a knowledge base [10]. In addition, differ ent knowledge bases sometimes contain overlapping or complementing data, ther e has been growing interest in attempt-ing to merge them by matching their common elements. As such, taxonomy matching is one of the most important operations in the process of knowledge base merging, which aims to match semantically equalled classes in different knowledge bases.

A number of taxonomy matchers have been established (e.g. [1,10,15,19]), ei-ther focusing on specific domains or aiming at providing a general technique in a wide variety of domains [17]. Most existing taxonomy matchers calculate sim-ilarities of classes between two taxonomies by utilizing various information, e.g., class names, structures, properties and i nstances. Specifically, these matchers usually define a similarity function by linearly combining the results of different similarities on different types of information.
Despite the significant amount of matchers for taxonomy matching, most of them perform well only on fairly taxonomies from specific domains, and are un-able to handle large-scale taxonomies as well as small-scale taxonomies [7]. This is because different knowledge bases gen erally use different t erms or structures to represent their classes, and the space of possible matchings grows exponen-tially with the number of classes. Moreover, choosing a suitable one among these matchers for a given application is far from trivial. Firstly, the diversity of them complicates the choice of the most appr opriate matcher. Secondly, there is no single dominant taxonomy matcher that performs the best, regardless of its ap-plication domain. In particular, due to the explosive emerging of Web big data, taxonomies become larger and more complex. Therefore, this paper aims to provide an efficient matching technique between different scales of taxonomies from various domains, on the premise of keeping high precision without greatly sacrificing recall.

To achieve the goal, we introduce a distributed computing framework tax-onomy metamatching , which combines an ensemble of taxonomy matchers to generate an optimal aggregated taxonomy mapping between two taxonomies in parallel. It should be noted that a taxonomy mapping here refers to a set of semantically equalled class pairs between two taxonomies. The combination of taxonomy matchers can make full use of the advantages of each taxonomy matcher and potentially compensate for the weakness of each other. The core idea of our approach is based on the meta-search techniques developed in the area of Web search [5]. Furthermore, we introduce the threshold algorithm [6] to ad-dress the taxonomy metamatching problem. Experimental results show that our method outperforms state-of-the-art methods regardless of domains and scales of taxonomies, which demonstrates that our method performs good adaptabil-ity to taxonomy matching. In general, the main contributions of this paper are three-fold:  X  We introduce taxonomy metamatching , a distributed computing framework  X  We introduce TRA, a Threshold Rank Aggregation algorithm for taxonomy  X  We extensively evaluate our method on two benchmark datasets. Experimen-
The rest of this paper is organized as follows. In Section 2, we give a review of related work. Section 3 formulates the problem of taxonomy metamatching. Section 4 describes our method for taxonomy metamatching. Section 5 is devoted to the experimental results. Finally , the paper is concluded in Section 6. The problem of taxonomy matching has been extensively studied, particularly under the umbrella term of ontology matching. And there are a number of surveys that shed light on this problem. Choi et al. [3] provided a good overview of the problem in general. Shvaiko et al. [17] analyzed several state-of-the-art tax-onomy matchers. These matchers mostly aim at calculating similarities between classes in terms of various information associated with the taxonomies.
Li et al. [13] presented a multistrategy matcher RiMOM for taxonomy match-ing, which dynamically combined string and structure strategies. But RiMOM had only been tested on small taxonomies. Jim  X  enez-Ruiz et al. [9] presented LogMap matcher, which integrated string, semantic and structure information to find similar classes. Ba et al. [1] proposed ServOMap matcher to find similar classes based on an Ontology Server and exploited string and context infor-mation. Both LogMap and ServOMap are designed for biomedical ontologies. Suchanek et al. [19] presented PARIS, a probabilistic algorithm for taxonomy matching based on instances. Lee et al . [12] measured the similarity between two classes by linearly combining the instances and properties associated with classes. Lacoste et al. [10] proposed a simple greedy matching algorithm, named SiGMa, for aligning knowledge bases with millions of entities and facts. They used the string, properties and structures information to obtain equalled class pairs in a greedy local search manner. These methods exploiting instances would not perform well when instances asso ciated with classes are sparse.
In addition, schema matching is a similar work to taxonomy matching. There are several surveys on schema matching (e.g. [16,18]). The goal of these work tries to construct a common schema from multiple data sources or to find the interscheme between different schemas. Although schema matching is similar to taxonomy matching, in comparison with schema matching, taxonomy matching has its own unique characteristics [13]. First, comparing with data schemas, taxonomies provide higher flexibility and more explicit semantics for defining data. Second, data schemas are usually defined for a specific database, whereas taxonomy is by nature reusable and sharable. Finally, in taxonomy, the number of knowledge representation primitives is much larger and more complex, e.g., cardinality constraints, disjoint classes and type-checking constraints. Therefore, the schema matching methods are no longer available to taxonomy matching. In this section, we will study the problem of taxonomy metamatching. For this purpose, we will firstly describe the notation of taxonomy, then formalize tax-onomy mapping and taxonomy mapping ordering for a taxonomy matcher, and finally formulate the taxonomy metamatching problem.

Gruber indicates that a taxonomy is an explicit specification of a conceptu-alization [8]. In this paper, we define taxonomy as the schemata of a knowledge base, which is a collection of classes to semantically classify or annotate infor-mation in a knowledge base. More formally, we have the following definition. A taxonomy is defined as a four-tuple: T =( C, P, R, I ), where C is the set of classes. P and I is the set of properties and instances related to C , respectively. R is the relationship function which gives a hierarchical relationship between classes, R  X  C  X  C , &lt;c,c &gt;  X  R denotes that class c is the subclass of c . Under the notion of taxonomy, we define a taxonomy mapping between two taxonomies as follows: Taxonomy Mapping. A taxonomy mapping is a set of semantically equalled class pairs between two taxonomies. More precisely, given two taxonomies T = ( C, P, R, I ), T =( C ,P ,R ,I ), and a taxonomy matcher M , a taxonomy map-ping  X  generated by M can be denoted as: where ( c i ,c j ,s ij ) denotes an equalled class pair between T and T with matching and j = l .Wehave  X  X  c i } X  C (1  X  i  X | C | )and  X  X  c j } X  C (1  X  j  X | C | ).
In this paper, a taxonomy matcher can be any form of matcher constructed based on any information from taxonomies. Based on the above definition, we can define the ordering on taxonomy mappings as follows: Taxonomy Mapping Ordering. Given two taxonomies T =( C, P, R, I ), T = ( C ,P ,R ,I ), and a taxonomy matcher M .Let  X  = {  X  = { ( c i ,c j ,s ij ) | c i  X  C, c j  X  C }} is the set of all candidate taxonomy mappings generated by matcher M with an ordering M . More precisely, for two taxonomy mappings  X ,  X   X   X  ,  X  M  X  means that  X  is better than  X  .

In the following, we elaborate on the process of a taxonomy matcher producing an ordered set of taxonomy mappings.
 Assuming that S :( C, C )  X  R is the similarity function used by matcher M , which computes the matching d egree of a class pair between T and T . Matcher M takes the following three steps to generate an ordered set of candidate taxonomy mappings between T and T : 1) Computing similarities of all class pairs between T and T based on function 2) Generating all possible taxonomy mappings  X  = {  X  = { ( c i ,c j ,s ij ) | c i  X  3) Ranking the taxonomy mappings in  X  . Specifically, using a scoring function
After those three steps, we can obtain an ordered set of candidate taxonomy mappings between T and T generated by matcher M .Nowwecanformulate the problem of taxonomy metamatching.
 Taxonomy Metamatching. Given two taxonomies T and T ,and m taxonomy matchers M 1 ,...,M m with scoring function f M 1 ,...,f M m , respectively. Taxon-omy metamatching is to generate an optimal taxonomy mapping between T and T with respect to an ensemble of taxnomomy matchers M 1 ,...,M m .
Based on the definition, we will introduce how we solve the problem. In this section, we will study the framework of taxonomy metamatching. Figure 1 summarizes the framework. In the framew ork, we firstly extract class features from taxonomies. Then, we develop a group of taxonomy matchers based on each of these features, respectively. And then, we apply those taxonomy matchers on two given taxonomies based on a distributed computing framework, such as MapReduce [4], to generate candidate taxonomy mappings in parallel. After that, we aggregate all taxonomy mappings generated by those taxonomy matchers. Finally, we obtain the optimal taxonomy mapping between taxonomies.
In what follows, we will firstly introduce the ensemble of taxonomy match-ers that we used in this paper. Secondly, we will introduce how the taxonomy metamatching framework generates an optimal taxonomy mapping. 4.1 Taxonomy Matcher We build four simplest taxonomy matchers as the source matchers for taxonomy metamatching, i.e., string-based, property-based, structure-based and semantic-based. In the following, we will introduce those matchers in details. String-Based Taxonomy Matcher. This matcher computes the similarity between two classes in terms of class nam es. The similarity can be measured by Jaccard coefficient 1 or Edit distance 2 . In this paper, we adopt Edit distance. Given two classes c 1 and c 2 , we define the similarity between them as follows: Property-Based Taxonomy Matcher. This matcher computes the similarity between two classes in terms of class prope rties. In this paper, we adopt Jaccard coefficient to calculate the property similarity. Given two classes c 1 and c 2 ,we define the property similarity between them as follows: common properties between c 1 and c 2 ; c 1 .P  X  c 2 .P is the union set of properties of c 1 and c 2 ; | X | is the set size.
 Structure-Based Taxonomy Matcher. This matcher computes the similarity between two classes in terms of class neigh bors (superclasses and subclasses). Like property-based matcher, we also us e the Jaccard coefficient measure. Given two classes c 1 and c 2 , we define the structure similarity between them as follows: where N c i ( i = { 1 , 2 } ) is the neighbor classes of c i , which can be derived based on the relationship function R defined in taxonomy.
 Semantic-Based Taxonomy Matcher. This matcher computes the similarity between two classes in terms of class semantics. There has been many studies that employ WordNet [14] to calculate the s emantic relevance between two strings [2,11]. In this paper, we directly adopt the Lesk algorithm [2] to compute the semantic similarity between two classes. Given two classes c 1 and c 2 , we define the semantic similarity between them as follows: on the lexical database WordNet.

Based on those matchers, in the following, we will elaborate on the process of taxonomy metamatching to generate an optimal taxonomy mapping. 4.2 Taxonomy Mapping Generation In this section, we will present how taxo nomy metamatching framework gener-ates the optimal taxonomy mapping. Given two taxonomies T =( C, P, R, I ), T =( C ,P ,R ,I ), and an ensemble of taxonomy matchers: string-based, property-based, structure-based and semantic-based. Let m = 4 denote the size of an ensemble of taxonomy matchers, M 1 ,...,M m denotes these matchers, with score function f M 1 ,...,f M m , respectively. The framework takes the following two modules to generate an optimal taxonomy mapping between T and T .Inpartic-ular, we use a distributed computing framework to implement the parallelization in order to reduce the process time :  X  Taxonomy Mapping Ordering Generation. Generating an ordered set  X  The Optimal Taxonomy Mapping Selection. Generating an aggregated 4.3 Threshold Rank Aggregation Algorithm The problem of optimal aggregation of serval quantitatively ordered list has been studied in the context of Web search or database systems. The most efficient general algorithm for this problem is Threshold algorithm [6]. In this section, we present this algorithm from taxonomy metamatching perspective. In what follows, we describe the threshold rank aggregation algorithm in details.
Given two taxonomies T =( C, P, R, I ), T =( C ,P ,R ,I ), and an ensemble of matchers  X  = { M 1 ,...,M m } for T and T . Here, we use  X  M i to represent the weighting parameter for each matcher,  X  = {  X  M 1 ,..., X  M m } is the parameters set. Let  X   X   X  be the set of aggregated ordered taxonomy mappings, which is initialized as an empty set. The best taxonomy mapping  X  (1) can be generated by the threshold rank aggregation algorithm described in Algorithm 1.
Specifically, the algorithm firstly selects the top-ranked taxonomy mapping  X 
M i from each matcher M i (see Lines 1-4). Then, it computes the aggregated score of selected mappings based on thresh old selection (see Lines 5-14). Finally, we acquire the top-ranked mapping for taxonomies T,T (see Lines 15). It is worth mentioning that the algorithm automatically updates the threshold  X  ta parameter (see Lines 7-10) based on existing selected taxonomy mapping. Algorithm Analysis. Let n = | C | and n = | C | denote the number of classes in taxonomy T and T , respectively; m denote the taxonomy matchers size. Our method takes n  X  n steps to compute the class similarities for each individual taxonomy matcher. Let l =max { n, n } , for each taxonomy matcher, the aggre-gated score function F (  X  ) runs in O ( l ) time. Therefore, th e algorithm runs in polynomial time O ( mnn + ml ).
 Algorithm 1. The threshold rank aggregation algorithm In this section, we evaluate the effect iveness of our method TRA for taxonomy matching. We will: (1) compare the precision, recall and F1 measure of our method, to five state-of-the-art taxonomy matching methods. (2) analyze how the performance of our method changes with taxonomies of different size. (3) analyze the adaptability of our method across different domains. 5.1 Experimental Settings All experiments were conducted on two servers running 64-bit Linux OS, with 16 core 2GHz AMD Opteron(tm) 6128 Processors and 32GB RAM. And we compared our method TRA with five methods described in Section 2, namely, SiGMa, YAM++, ServOMap, LogMap and IAMA. Specifically, we evaluated the performance using the standard metr ics of precision, recall and F1 measure, based on the number of semantically equalled class pairs correctly matched. In the experiments, we used two benchmark datasets derived from ontology alignment evaluation initiative 3 (OAEI). The two datasets are available with corresponding ground truth data. We describe these datasets below.
The first dataset was obtained from the large biomedical test case (largebio), which aims at finding alignments between large and semantically rich biomedical ontologies. The test case has been split into two task involving  X  X mall X  and  X  X hole X  fragments of the input ontologies, which aims to test the adaptability of matchers on taxonomies of different size. We used NCI, SNOMED ontologies from this test case as test datasets and UMLS Metathesaurus as ground truth data.

The second one was obtained from the conference test case, whose goal is to find all correct correspondences within a c ollection of ontologies over the domain of organizing conferences. We evaluated the results of the approaches against the blind reference alignments (labeled as ra 1 on the conference web-page), which includes all pairwise combinatio ns between 7 different ontologies.
In the experiments, for the sake of simplicity, the weighting parameter  X  M i used in TRA is set to be 1.0 for each taxonomy matcher. As SiGMa starts with an initial equalled class pair, which is declared as any initial matching pair assumed of good quality [10]. Therefore, in the e xperiments, we selected the root class pair between the benchmark datasets as the initial seed. 5.2 Experimental Results and Analysis In this section, we will evaluate the adaptability of our method TRA and the baseline methods on different scales and different domains of taxonomies. For this purpose, we will firstly test these methods on the small and whole large-bio datasets, and then we will test them both on the largebio dataset and the conference dataset.
 Evaluation on Datasets with Different Size. In this experiment, we tested TRA and the baseline methods on the small and whole fragments of largebio datasets. Table 1 presents the results. From the results, we can see that TRA obtains a relatively higher F1 measure than any of the baseline methods both on the small and whole tasks. Despite TRA X  X  running time slightly higher than the greedy-based method SiGMa, TRA obtains an impressive F1 measure above 76% both on the small and whole largebio datasets, significantly improving over the SiGMa baseline.

In order to explicitly demonstrate the performance changes of these methods on taxonomies with different size, the results in Table 1 is graphically depicted in Figure 2. From Figure 2, it can be seen that all methods perform better on the small task than on the whole task. The most likely reason for this is that larger taxonomies also involve more possible candidate semantically equalled class pairs between two taxonomies, and it is harder to keep high precision without sacrificing recall, and vice versa. In spite of this, our method keeps on achieving the best precision, recall and F1 measure over the small and whole largebio dataset. And as the results shown in Figure 2, TRA exhibits more steady performance both on the small and whole largebio datasets. It is shown that our proposed method TRA performs well on taxonomy matching task, regardless of scales of taxonomies.
 Evaluation on the Different Domains of Datasets. In this section, we will evaluate the performance of our method TRA and the baseline methods on different domains. Therefore, we first ly tested these methods on the largebio dataset, then tested them on the conference dataset. Subsequently, we analyzed the adaptability of these methods both on largebio and conference datasets.
In order to see the whole performance of all the methods on the largebio dataset, we averaged the results on the small and whole largebio dataset. Table 2 presents the average results of these methods on largebio dataset. From Table 2, we can see that the maximal increment o f precision is 7.5% when compared with ServOMap, while the minimal increment is 1.2% when compared with IAMA. And the maximal increment of recall is 21.8% when compared with IAMA, while the minimal is 1.7% when compared with ServOMap. And the maximal increment of F1 measure is 17.8% when co mpared with IAMA, while the minimal is 3.8% when compared with ServOMap. In general, the experimental results indicate that TRA outperforms all the baseline methods on the largebio dataset.
In the following, we tested these methods on the conference dataset. As the conference dataset contain s 7 ontologies, we took the results of these taxonomy matching pairs as a whole to evaluate the performance of TRA and the baseline methods. Table 3 presents comparison of the precision, recall and F1 measure. In Table 3, for each method, the best performance is listed in bold.
From Table 3, we can see that the maximal increment of precision is 34.3% when compared with SiGMa, while the m inimal increment is 2.5% when com-pared with YAM++. And the maximal increment of recall is 38.7% when com-pared with SiGMa, while the minimal increment is 1.1% when compared with YAM++. And the maximal increment of F1 measure is 37.8% when compared with SiGMa, while the minimal increment is 1.8% when compared with YAM++. In general, the experimental results indicate that TRA can achieve better per-formance than the baseline methods on the conference dataset.

Figure 3 graphically depicts the results on the largebio and conference datasets, we can see that compared with all the baseline methods, TRA obtains the high-est precision, recall and F1 measure both on the largebio dataset and conference dataset. Moreover, TRA exhibits more steady performance on the test datasets. It is shown that our proposed method TRA performs well on taxonomy matching task, regardless of taxonomy domains.

As was mentioned above, it can be seen that TRA can not only obtain better performance over taxonomies with different size, but also obtain better per-formance over taxonomies in different domains, which demonstrates the good adaptability of TRA. Furthermore, it is shown that the ensemble method for taxonomy matching is a very useful technique, which demonstrates the combi-nation of an ensemble of taxonomy matchers can make full use of the advan-tages of each taxonomy matcher and potentially compensate for the weakness of each other. Moreover, from the accuracy of knowledge engineering perspective, a slightly improvement is of great importance to applications. It is worth noting that, since we adopt the distributed computing framework to get the taxonomy mappings generated by taxonomy matchers in parallel, the time consumption of ensemble matcher is almost the same as the single matcher, therefore, our method TRA is a useful technique for taxonomy matching. In this paper, we studied the problem of taxonomy matching. Specifically, we proposed taxonomy metamatching, a distributed computing framework for as-sembling taxonomy matchers and generating an optimal taxonomy mapping. And we introduced TRA, a Threshold Rank Aggregation algorithm for this problem. The experimental results show ed that our proposed ensemble method is a useful technique for taxonomy matching. Furthermore, the method performs good adaptability regardless of domains and scales of taxonomies.
 Acknowledgments. This work is supported by National Grand Fundamen-tal Research 973 Program of China (No. 2013CB329602, 2014CB340405), Na-tional Natural Science Founda tion of China (No. 61174152, 61232010, 61402442, 61402022, 61402464, 61303244), Beijing Nova Program (No. Z121101002512063), and the Natural Science Foundation of Beijing (No. 4154086) , National High-tech R&amp;D 863 Program of China (No. 2015AA015803).

