 We introduce the boasting problem , wherein useful trends in historical ordinal data (rankings) are discovered. Claims of the form  X  X ur object was ranked r or better in x of the last t time units, X  are formalized, and maximal claims (boasts) of this form are defined under two natural partial orders. For the first partial order, we give an efficient and opti-mal algorithm for finding all such maximal claims. For the second, we apply a classical result from computational ge-ometry to achieve an algorithm whose running time is sig-nificantly more efficient than that of a na  X  X ve one. Finally, we connect this boasting problem to a novel variation of the problem of finding optimized confidence association rules as originally posed by Fukuda, et al. [2], and give an efficient algorithm for solving a simplification of the new problem. H.2.8 [ Database Applications ]: Data mining Algorithms, Theory
Take a walk through your favorite wine shop. In addi-tion to advertisements proclaiming  X  X  smoky bouquet with a berry finish, X  or some such collection of flowery adjec-tives, you will notice advertisements making claims about the sustained quality of a particular wine, based on adjudi-cated rankings from a variety of wine competitions. Indeed, claims of the form, X  X ur shiraz was ranked 4 or better in 3 of the last 5 years! X  are common.

Such advertising boasts depend on a history of rankings awarded on the basis of a myriad of other attributes. As  X  Supported in part by NSF grant IIS-9907483.
 Copyright 2005 ACM 1-59593-135-X/05/0008 ... $ 5.00. such, these rankings capture summative relative value over a set of items, over time.

The goal of this work is to examine the set of claims that can be made about a single entity, formalize them, and de-termine the set of strongest claims that can be made. In ad-dition, we make a connection between these boastful claims and optimized association rules as defined by Fukuda et al. [2].

The data for the problem consists of at least a rank vari-able and a unique ordered time variable, D = { rank, time, . . . } associated with a single item. A claim is a statement such as  X  X ur item was ranked r or better in x of the last t years, X  where the variables r , x , and t arise from the data. We now define The Boasting Problem :
Given data D = { rank, time, . . . } , and a partial order on claims,  X  c , find all of the maximal claims that can be made for a single item.

In fact, the above is a special case of a more general prob-lem that we solve. More broadly, the  X  X ank X  r can be re-placed with any numeric attribute reflecting some perfor-mance criterion. Our results are easily modified to address claims such as  X  X ur freshman class scored 1350 or better on the SAT exam in seven of the last ten years X , or  X  X ewer than 5 percent of new owners of our vehicles reported dissatifac-tion with the product in twenty of our last twenty-five years of production X .

Here we focus on the boasting problem as defined above, where the data is ordinal, and we consider the more general case in Section 6.

Our results are summarized as follows:
There appears to be scant work that relates directly to this problem. Several authors [1, 3, 6] have considered as-sociation rules for ordinal data. Such a rule is of the form  X  X hen attributes { a 1 , . . . , a n } are present in the data, then P ( a 1 , ..., a n ) holds X , where P is a relational predicate defined only on the ordinal values, for example,  X  a 1  X  a 3  X  a 2 Thus, the problem is similar to traditional association-rule problems, but here the set of attributes is extended to in-clude ordinal relationships among the data. The search is over a large set of data, to find ordinal relationships that hold significantly often. Results have been used to find er-rors in data (ordinal relationships that hold frequently help to point out possible anomalous data when these relation-ships are violated), and also as a means of minimizing the vast number of (traditional) association rules that might otherwise be found on domains with numeric values.
This contrasts with our problem, where we have a single data stream, and seek strong summative claims. In some sense, our problem might be viewed as a variant of the prob-lem of finding optimized confidence association rules as de-fined by Fukuda, et al. [2]. In that problem, the goal is to find an interval within a given numerical attribute, in which the support is above a given threshold, and where the proportion of those supporting records satisfying a given Boolean condition (the confidence) is maximized. In our version of the problem, we find optimized ordinal associa-tion rules : Rather than the complexity arising from search-ing among possible attributes to be included in an unknown pattern, all relevant attributes are known (in this case, ev-ery moment in time is relevant). The problem is to find instantiations of a known rule template that maximize some objective function.

The other aspect of our problem that is not addressed by that of finding association rules over ordinals is its treatment of the different attributes as points in time. In that vein though, there has been an enormous amount of work (see, for example, summaries [4, 5]) on mining time-series data for periodic patterns, episodes, subsequences, or other patterns that are germane to temporal data. Most often, the goal is to find patterns arising from causal relationships among the data, and the time ordering is critical in identifying can-didate patterns. Again, our goal is substantially different. We do not seek particular patterns woven through the time sequence whose ordering presumably has some significance arising from the temporal relationship of the events. In-stead, the timeline is used only as a discrete parameter for a single attribute that gives ordinal values reflecting perfor-mance relative to other entities. Again, rather than finding all frequently occurring patterns, our goal is to summative information that is maximal in the senses to be described below.
Recall that data for the problem consists of at least a rank variable and a unique ordered time variable D = { rank, time, . . . } , associated with a single item, and let | D | = n . Without loss of generality, we can consider the time variable to consist of the ordinal values 1 through n . We can thus define a function on the data rank ( t ) for t = 1 , . . . n , that reports the value of the rank for the data entry whose time value is t . A claim, based on the data, is a triple  X  r, x, t  X   X  N 3 corresponding to the statement  X  X ur item was ranked r or better in x of the last t years. X 
Given this meaning, and given a particular data set D , not all claims are true.

We define accumulation functions f r ( t ) = |{ t 0 : rank ( t r, t 0  X  t }| . That is, f r ( t ) is just the number of years in which the object meets or betters rank r in the time span [0 , t ]. Some characteristics of f r ( t ): for any r , f r ( t ) is monoton-ically non-decreasing in t . Furthermore, if r &lt; s , f f ( t ). That is, we have a non-decreasing family of non-decreasing functions.

Definition 1. A valid claim is one of the form  X  r, x, t  X  , where x  X  f r ( t ) .

We investigate the maximal claims of this kind that can be made about a particular object.

Depending on the application or interpretation of the prob-lem, different criteria may be used to evaluate the relative merits of one claim versus another. As such, there are many partial orders one can choose for making comparisons. We select and analyze two different partial orders. Definition 2. Define two claims C 1 =  X  r 1 , x 1 , t 1  X  , and C 2 =  X  r 2 , x 2 , t 2  X  . The two claims are equivalent , C if x 1 = x 2 , r 1 = r 2 , and t 1 = t 2 . The partial order we define specifies that C 1 &gt; 1 C 2 (read C 1 dominates C is better than C 2 ,) if C 1 6 = C 2 and r 1  X  r 2 , x 1  X  x t  X  t 2 .

So, for example, a claim like  X  X e were ranked 4 or better in 3 of the last 5 years, X  is better than  X  X e were ranked 4 or better in 3 of the last 8 years, X  which is better than  X  X e were ranked 4 or better in 2 of the last 8 years, X  which is better than  X  X e were ranked 5 or better in 2 of the last 8 years. X 
Note, however, that claims like  X  X e were ranked 4 or better in 3 of the last 5 years, X  and  X  X e were ranked 4 or better in 4 of the last 6 years, X  are incomparable.
We solve the problem of finding maximal claims of this type by processing the data in historical order, and asking, at each time, and among reasonable claims for that time, which claims are maximal.

At any time t , there is a large set of valid claims that can be made. Many of these claims, however are not particularly reasonable. For example, suppose that f 5 (20) = 3. That is there were exactly 3 observations of rank 5 or better in the time span 1 . . . 20. We could make a claim such as  X  X e were ranked 5 or better in 2 of the last 20. . . , X  but why would we ever do so? Furthermore, suppose, as before, that f (20) = 3, and also suppose that a rank of 5 was observed in time 1 . . . 20, and that no rank of 6 was observed in that time. While it X  X  true that we could make the claim  X  X e were ranked 6 or better in 3 of the last 20 . . . , X  we know that the same claim could be made about rank 5, which is stronger according to our partial order. In particular, no claim about 6 at any time prior to its first occurrence is maximal, since the same claim could be made about rank 5 (or less). Definition 3. The set of reasonable claims at time t , C , is
The reasonable claims include only those claims that are of the form  X  r, f r ( t ) , t  X  , and where an observance of r has occurred. The only claims excluded from the reasonable set are those that are dominated in this way. Hence, the set of reasonable claims contains the set of maximal claims.
We next consider this set of reasonable claims at time t and argue which of them must be maximal. Note that at any time t there is exactly one reasonable claim for each unique rank seen in time 1 . . . t , | C t |  X  t . Finally, observe that every claim  X  r, x, t  X  1  X  in the set C t  X  1 of reasonable claims for time t  X  1 has a corresponding claim  X  r, y, t  X  in the set C t , where y = x if r &lt; rank ( t ), and y = x + 1 if r  X  rank ( t ).
 be the set of reasonable claims at time t whose ranks are less than rank ( t ), and let B t = { X  r, f r ( t ) , t  X  :  X  t r, r  X  rank ( t ) } , the set of reasonable claims at time t whose ranks are at least rank ( t ). Then C t = A t  X  B t , and A  X  .

The set A t captures all claims in C t whose corresponding claims from time t  X  1 are not improved by the observation of rank ( t ). For these, f r ( t ) = f r ( t  X  1). The set B all claims whose tallies are improved by an observation of rank ( t ). For these, f r ( t ) = f r ( t  X  1) + 1.
Lemma 4. If c =  X  r, f r ( t ) , t  X  is a reasonable claim at time t , c  X  C t , and r  X  rank ( t ) then c is a maximal claim. That is, every claim in set B t is maximal.

Proof. Suppose c is not maximal. Then, there exists another valid claim d =  X  s, f s ( u ) , u  X  so that d &gt; c . We assume that d is a reasonable claim, since if it isn X  X , then it can be replaced by an even better claim, that is reasonable.
By definition of the partial order on claims, s  X  r, f s ( u )  X  f ( t ), and u  X  t. But u  X  t implies f r ( u )  X  f r ( t ) by mono-tonicity of accumulation functions. Furthermore, s  X  r im-plies f s ( u )  X  f r ( u ) since the accumulation functions are a monotone family. Thus, f s ( u )  X  f r ( t ), which means that actually, they are equal.

Now, suppose u &lt; t . Claim  X  s, f s ( u ) , u  X  is a valid claim, and since s  X  r ,  X  r, f s ( u ) , u  X  is a valid claim as well. But since r  X  rank ( t ), f r ( t ) &gt; f r ( u ), contradicting f f ( t ). This implies u = t .

Finally, we have the claims d =  X  s, f r ( t ) , t  X  and c =  X  r, f r ( t ) , t  X  . Suppose s &lt; r . Since d and c are both reasonable, ranks r and s appear sometime in time 0 . . . t . But if that is the case, then at time t , we have seen at least one more instance of rank r or better than we have of rank s But then, d = c , and we are done. Claim c is maximal.
Next we prove that at time t , no claim with rank less than rank ( t ) (no claim in A t ) is maximal. Let c =  X  r, f r A , hence r &lt; rank ( t ). But this implies f r ( t ) = f the number of instances of rank r or better was not increased by observing rank ( t ). But the claim  X  r, f r ( t  X  1) , t  X  1  X  dominates c and so c is not maximal.

We have characterized the set of maximal claims for each time by B t , and now we give an algorithm for producing them. The idea of the algorithm is to maintain over time a sorted list of observed ranks, together with the appropriate value of the accumulation function for each rank and time. The algorithm is shown in Figure 1.

Notice that for each t , the algorithm prints exactly the elements in B t , which was proven to be the set of maximal claims.

In the worst case, and if n is the size of the history, or the size of the database, or the total number of time periods, there are at most O ( n 2 ) maximal claims, and there are at least n maximal claims. Our algorithm is optimal: it runs in time linear in the number of maximal claims, since one claim is delivered on every iteration of every loop.
Under the partial order described in Section 4, such claims as  X  X e were ranked 4 or better in 3 of the last 5 years, X  and  X  X e were ranked 4 or better in 2 of the last 3 years, X  were incomparable. In fact, a reasonable alterna-tive viewpoint is that the second claim is stronger because the fraction of the time the ranking was achieved is higher (2 / 3 &gt; 3 / 5). Our second partial order formalizes this intu-ition.

Definition 5. If C 1 =  X  r 1 , x 1 , t 1  X  and C 2 =  X  r 2 then C 1 &gt; 2 C 2 (or C 1 is stronger than C 2 , or C 1 C ) if C 1 6 = C 2 , r 1  X  r 2 , and f r 1 ( t 1 ) /t 1  X  f other words, one claim dominates another different claim by having better or equal rank and better or equal fraction of success.

Note that we do not distinguish between claims like  X 2 or better in 9 of the last 10 years, X  and  X 2 or better in 90 of the last 100 years. X  Under our current metric, these claims are considered equal.
For a given rank r , consider the function f r ( t ) (augmented with the value f r (0) = 0), and notice that every function value corresponds to a claim whose fraction f r ( t ) /t  X  and thereby, whose value with respect to the partial order since r is fixed  X  is the slope of the line through (0 , 0) and ( t, f Call this slope the cumulative slope. We could find all the maximal claims whose rank is r by examining every point on f ( t ) and reporting the claim(s) corresponding to the point of maximal cumulative slope on the function. If this is done for all r , in increasing order by r , the maximal claims result. Unfortunately, this na  X  X ve implementation has a worst case quadratic running time. In contrast, we offer an algorithm that finds all maximal claims in time O ( n log 3 n ).
Our solution requires an efficient data structure for com-puting f r ( t ) for all r and t , together with a data structure that supports efficient dynamic maintenance of convex hulls.
Before discussing the convex hull data structure and demon-strating its utility, we must discuss the maintenance of the functions f r ( t ). In O ( n log n ) time, we build a tree structure that This usage cost can result in a net savings, because we would spend O ( n 2 ) time to create a table of f r ( t ) values whose elements are available in constant time. As long as we can satisfactorily bound the number of times we employ this function, we are happy. Without loss of generality assume n = 2 k for some k . The data structure is a complete binary tree consisting of n leaves, where n is the size of the (augmented by 0) data. If the leaves of the binary tree are considered in level order, the t th leaf is labeled by the rank assigned at time t , rank ( t ), as given in the data (assign the rank at time 0 to be some very awful large rank M ).

If height ( v ) is the height of node v in the tree, then ev-ery internal node v contains an array whose length is equal to 2 height ( v )  X  1 . This particular array size is chosen to corre-spond to the number of leaves in the left subtree of v because the array will have an entry corresponding to each such leaf. We refer to these arrays as the rank-tally arrays , T v [  X  ]. In addition, the t th leaf node, v , contains a rank-tally array of a single entry.

For internal vertices v , the i th element of the rank-tally array T v , is defined by the minimal rank r such that i = |{ rank ( t )  X  r : t is in the left subtree of v }| . That is, the number of leaves in the left subtree of v with rank T or better, is i . For the t th leaf v , T v [1] = rank ( t ). Another way of characterizing rank-tally array T v [  X  ] is to say T min { r : |{ t : t  X  left subtree of v }| = i } . Finally, define a variable  X  current v  X  for each array that indicates the most recently inserted array element (initialized to 0). Lemma 6. Define P = { v : v a node in the path from the t th leaf to the root } . For each rank r we define a function on the nodes g r ( v ) as follows:
Then g r ( v ) is the exact number of leaves in the left subtree of v with rank less than or equal r . For any r , t , f r P
Proof. We wish to tally the number of leaves in the tree to the left of leaf t , whose ranks are no more than r . Let v , v 2 . . . v t be the leaves to the left of the t th leaf. Each of the v i shares a least common ancestor with v t on path P , where v i is in the left subtree, and v t is in the right (otherwise, v i = v t ). Since every internal node v records a tally of the number of leaves in v  X  X  left subtree with rank less than or equal to r , for any r , the sum of these tallies on P t is what we seek.

Using the tree data structure described above, we can compute g r ( v ) in O (log n ) time by doing binary search on the rank tally array for node v . Furthermore, f r ( t ) is the sum of log n terms corresponding to the log n vertices in P ( t ). Thus, f r ( t ) is computed in time O (log 2 n ).
Data is inserted into the data structure by processing the data in rank order as follows: Let r be the current rank, and let time ( r ) be the time it occurs. (If time ( r ) is not unique, that is, if there are multiple occurrences of rank r , simply process each of these in time order.) Let v 0 , v 1 , . . . v the nodes on the path from the time ( r ) th leaf to the root. Traverse the tree along this path updating the tally-array, if necessary, at each node. If v i  X  1 is the left child of v increment current v i and then insert r into array element current v i . If v i  X  1 is the right child of v i , do nothing. Note that the elements of any tally array are inserted in increasing order by rank. The time taken to build the function tree is thus O ( n log n ).
The following two lemmas connect the problem of finding maximal claims to that of maintaining a convex hull of a set of points.

Lemma 7. Consider the function f r ( t ) for some r , and suppose we are given H ( S ) the (upper) convex hull, of the be the set of vertices on the upper hull, H ( S ) . If then  X  r, y, x  X  is a maximal claim.
Proof. The lemma states that the vertex on the upper hull with least t greater than 0, point ( x, y ), gives maximal claim  X  r, y, x  X  . The upper hull is characterized as a collection of vertices and consecutive sequence of adjacent segments whose slopes are monotonically decreasing, where the first segment has infinite positive slope, and where all points not on the hull are below the hull. The second segment on the hull, in our case the segment whose endpoints are (0 , 0) and ( x, y ), has maximum slope among the rest. Since the slope is y/x , we have our maximal claim.
 Furthermore, we have the following:
Lemma 8. Given a maximal claim  X  r, y, x  X  , all maximal claims with rank r have the form  X  r, ky, kx  X  for some positive k .

Proof. Suppose C 2 =  X  r, x, y  X  is a maximal claim of rank r , and suppose there is some other maximal claim C 1 =  X  r, kx, jy  X  , k 6 = j . But then, either C 2 &gt; C 1 or vice versa since jy kx 6 = y x . This contradicts the maximality of either C or C 2 .

The question, then, is how fast can we maintain convex hulls? We apply a classic data structure from computational geometry for dynamically maintaining convex hulls. The data structure was devised by Overmars and van Leewen in 1981 [7]. Their algorithm computes the convex hull of a set of data points as the union of an upper hull and lower hull. In fact, we are not interested in the entire convex hull structure for the points in a f r ( t ) function, but rather we require only the upper hull.

Space prohibits a technical description of the hull data structure and how it is implemented. The reader is referred to [7] for the general approach or http://icarus.cs.uiuc.edu/boast for a complete explanation of how it is adapted in this context. We treat it as a black-box. For each rank in increasing order, we update the data structure to represent the upper hull of f r ( t ) in time O (log 3 n ). Finally, we report the maximal claim by extracting the second point on the hull in O (log n ) time. Repeating this process for n (not necessarily unique) ranks gives a total running time of O ( n log 3 n ). Efficient updates to the hull are the key to our efficient algorithm.
Recall the founding work in the area of optimized asso-ciation rules by Fukuda et al. [2], who posed the following question (among others): Given a single numerical attribute A , and a Boolean condition on records, what is the interval ( x, y ) in A , whose support meets some minimum threshold, and whose confidence (with respect to the Boolean condi-tion) is maximized? They gave an insightful O ( n ) algorithm for the problem. Now, suppose that we wish to find such in-tervals on a single numerical attribute for a sequence of n Boolean conditions. Employing their algorithm for each of the n problems requires, in total, quadratic running time.
Before we adapt our boasting algorithm in a straightfor-ward way to address a simplification of the problem, we give a definition.

Definition 9. Consider a sequence of Boolean conditions, b , on a data set D , so that b i ( x ) is either true or false for every x  X  D , and  X  i . Let B i = { x : b i ( x ) = true, x  X  D } be the set of records in D satisfying b i . Then the sequence b monotonic if  X  i , B i  X  B i +1 .
 The problem we are solving, then, can be stated as follows:
Definition 10. Given a single numerical attribute A , and a sequence of Boolean conditions b i on the records in the database, if the sequence of Boolean conditions are mono-tonic, find the interval in A , (0 , y ) , whose support meets some minimum threshold, and whose confidence (with re-spect to Boolean condition b i ) is maximized, for each b
We apply a slight adaptation of the boasting algorithm to solve this problem in O ( n log 3 n ) time, where n is the number of records in the database. First, we point out that the boasting problem can be posed as an instance of this optimized association rules problem, where the numerical attribute on which we find association rules is the history attribute from the boasting problem, and the ranking con-ditions such as ( D.rank  X  r ), when processed in rank order, are a sequence of monotone Boolean conditions on the data. Furthermore, the fraction we are trying to maximize in seek-ing the maximal claim using partial order &gt; 2 is exactly the confidence of the interval. Finally, the boasting problem has no minimum support threshold, so we call the minimum support threshold 0. Since the problems are so similar, we make only minor adaptations to the boasting algorithm to solve the slightly more general problem.

The first generalization applies to the sequence of Boolean conditions. In the case of the boasting problem, the num-ber of records satisfying ( D.rank  X  r ) changes by 1 as the rank is incremented to r + 1. That is, B i  X  B i +1 and | B i +1 | = | B i | + 1. In the association rules problem, on the other hand, we only require that | B i +1 | = | B i | + k for some k  X  0. This is an easy generalization to accommodate, however, because we follow the boasting algorithm exactly, making a sequence of k updates to the upper hull as in the boasting algorithm, but we only search for a maximal claim (the maximum confidence interval (0 , y ) for claim B i ) after all k updates to the hull are complete. Note that this mod-ification also allows for non-unique ranks in the boasting problem.

The second generalization results in a simple adaptation of the f r ( t ) function in the boasting algorithm to accom-modate the minimum support threshold requirement of the more general problem. In fact, the data structure and func-tion f r ( t ) are created in exactly the same way as before, the adaptation only occurs in its use. Suppose the mini-mum support threshold is  X  . Define a new function g r ( t ) as follows:
Then we use g r ( t ) rather than f r ( t ) when computing func-tion values. By making this adaptation, we assure that the ranks that occur before time  X  are tallied in f r ( t ) for all t &gt;  X  , but we also guarantee that no segment of the upper hull in the interval (0 ,  X  ) will be considered for maximality.
Any sequence of Boolean conditions arranged so as to re-quire O ( n ) updates to the hull structure can be answered efficiently using our solution. Characterizing a given set of Boolean conditions as bounded in this was is surely a hard problem. On the other hand, if our Boolean conditions are mutually exclusive, that is, no record satisfies more than 1 of the list of conditions, we can answer efficiently. This is an important class of problems since it corresponds to asking Boolean questions about categorical data such as  X  X ind the optimal age ranges among those who drive x cars, X  where x is one of a set of colors.
We have defined and addressed the problem of discovering maximal boasts in historical rank data, under two partial or-ders. For the first, a linear time and optimal solution was given. For the second, considerable speedup was achieved over a na  X  X ve quadratic algorithm by employing a clever con-vex hull data structure from Overmars and van Leeuwen [7].
Finally, we have solved a special case of the related prob-lem of finding a sequence of optimized confidence association rules. The more general problem remains a challenging open question. In particular, we suspect more sophisticated dy-namic data structures will be required. This is a current focus of investigation.
The authors would like to thank Sariel Har-Peled for en-gaging in  X  X he wine problem X  and for pointing out that the convex hull data structure could be applied. [1] O. Buchter and R. Wirth. Discovery of association rules [2] T. Fukuda, Y. Morimoto, S. Morishita, and [3] S. Guillaume. Discovery of ordinal association rules. In [4] E. Keogh. Mining and indexing time series data. In The [5] M. Last, A. Kandel, and H. Bunke. Data Mining in [6] A. Marcus, J. I. Maletic, and K.-I. Lin. Ordinal [7] M. H. Overmars and J. van Leeuwen. Maintenance of
