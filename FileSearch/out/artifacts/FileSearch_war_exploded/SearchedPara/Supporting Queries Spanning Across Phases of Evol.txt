 The problem of managing evolving data has attracted considerable research attention. Researchers have focused on the modeling and querying of schema/instance-level structural changes, such as, ad-dition, deletion and modification of attributes. Databases with such a functionality are known as temporal databases. A limitation of the temporal databases is that they treat changes as independent events, while often the appearance (or elimination) of some structure in the database is the result of an evolution of some existing structure. We claim that maintaining the causal relationship between the two structures is of major importance since it allows additional reason-ing to be performed and answers to be generated for queries that previously had no answers.

We present here a novel framework for exploiting the evolution relationships between the structures in the database. In particu-lar, our system combines different structures that are associated through evolution relationships into virtual structures to be used during query answering. The virtual structures define  X  X ossible X  database instances, in a fashion similar to the possible worlds in the probabilistic databases. The framework includes a query answering mechanism that allows queries to be answered over these possible databases without materializing them. Evaluation of such queries raises many interesting technical challenges, since it requires the discovery of Steiner forests on the evolution graphs. On this prob-lem we have designed and implemented a new dynamic program-ming algorithm with exponential complexity in the size of the input query and polynomial complexity in terms of both the attribute and the evolution data sizes.
 H.m [ Information Systems ]: Miscellaneous Algorithms, Performance  X 
Work partially supported by the ERC Advanced Grant project "Lucretius" Data evolution, Probabilistic Databases; Graph Algorithms
Advances in information and telecommunication technologies of the last two decades have allowed organizations and indi-viduals alike to develop large scale data collections and make them available on-line. These collections are often about enti-ties that persist over time and the changes that occur to their at-tributes/relationships. Considerable effort has gone toward the de-velopment of advanced solutions for managing the evolution of schemas[1, 22, 21], data [5, 23, 3, 19] and schema transforma-tions [27, 26, 13]. Temporal databases are one of the outcomes of this effort, where the notion of versioning has been central [4, 6]. In temporal databases, users have the ability to access and query snapshots of the data at different points in time.

Unfortunately, such work fails to capture the full spectrum of evolutionary phenomena. Specifically, those approaches are founded on the assumption that the nature of each real world en-tity represented in the database persists over time, e.g., students are added, modified, and eventually deleted, but never become profes-sors, with a direct link between the student tuple and the professor one. As such, evolution amounts only to temporal changes of at-tributes/relationships [1, 5, 21]. Evolution of an entity that spans different concepts (e.g., student to professor, research lab to inde-pendent corporate entity) are unaccounted for. And so are evolution phenomena where one entity is split into several (e.g., Germany splitting into East and West Germany at the end of WW II), or the other way around (e.g., East and West Germany amalgamating into one entity at the end of the Cold War). The result of this is that his-torical queries, such as "give me all the heads-of-state of Germany between 1800 and 2000" are hard to deal with, as they essentially require hand-coding of the history of Germany into several queries to be processed separately. Note that this may look similar to ter-minology evolution [25], i.e., using different terms to describe the same real world entity at different points in time, but it actually goes far beyond that.

This form of evolution finds a natural fit in Dataspace Sys-tems [10, 16] that are anchored on the notion of an entity. Such entities may split/merge or otherwise evolve during their life-time. Modeling and supporting evolution relationships for histori-cal query processing finds many additional real-world applications. For instance, modern historians will be able to model and study the chains of human achievements and developments, e.g., how the concept of biotechnology evolved from its beginnings as an agri-cultural technology to the current notion that is coupled to genet-ics and molecular biology. Educators will better track how courses evolve and how the material and educational objectives for a course are  X  X ransferred" and become associated with another. Finally, bi-ologists will become more effective in studying the evolution of a species by querying the dependencies and changes that have taken place since the beginning of life on earth.

We have previously presented a formal foundation for model-ing evolution [24]. This paper focuses on the query facilities re-quired for our proposal and on algorithmic and performance issues. Specifically, our contributions in this paper are as follows: (i) we formally describe new semantics of query answering in which an-swers are returned from virtual instances constructed on-the-fly by merging series of entities representing different evolution phases of a real-world object into one; (ii) we introduce the concept of Steiner forest as a mean of finding the optimal mergings that need to be done to answer a query and devise a dynamic programming algorithm for solving it; (iii) we present an efficient indexing tech-nique that facilitates the above queries, and we show effective eval-uation methods; (iv) we experimentally evaluate our findings on some large publicly available dataset.

The remainder of the paper is structured as follows. Section 2 provides a motivating example and sketches our solution. Sec-tions 3 presents our modeling framework and formally defines queries and evaluations. Section 4 shows the query evaluation strat-egy and Section 5 describes the Steiner forest algorithm. The opti-mization techniques are presented in Section 6. The experimental evaluation results are shown in Section 7. Finally, we conclude in Section 8.
Consider AT&amp;T, a company that over the years has gone through a large number of break-ups, merges and acquisitions. Its famous Bell Labs where many great innovations took place, had a similar fate. It was founded in 1925 under the name Bell Telecommu-nication Laboratories (BTL). In 1984, it was split into Bellcore (to become Telcordia in 1997) and AT&amp;T Bell Laboratories. The latter existed until 1996 when it was split into Bell Labs, that was bought by Lucent, and to AT&amp;T Labs. The Lucent Bell Labs became Alcatel-Lucent Bell Labs Research in 2006 due to the take-over of Lucent by Alcatel. Furthermore, due to the take-over of AT&amp;T by SBC in 2005, the AT&amp;T Labs were merged with the SBC Labs to form the new AT&amp;T Inc. Labs. Despite being research labs of different legal entities, Lucent and AT&amp;T Labs have actually main-tained a special partnership relationship. All the different labs have produced a large number of inventions, as the respective patents can demonstrate. Examples of such inventions are the VoIP (Voice over Internet Protocol), the ASR (Automatic Speech Recognition), the P2P (Peer-to-Peer) Video and the laser. A graphical illustration of the above can be found in Figure 1 where the labs are modeled by rectangles and the patents by ovals.

Assume now a temporal database that models the above informa-tion as illustrated in Figure 1, and consider a user who is interested in finding the lab that invented the laser and the ASR patent. It is true that these two patents have been filed by two different labs, the AT&amp;T Bell Labs and the AT&amp;T Labs Inc. Thus, the query will return no results. However, it can be noticed that the latter entity is an evolution of the former. It may be the case that the user does not have the full knowledge of the way the labs have changed or in her own mind, the two labs are still considered the same. We argue that instead of expecting from the user to know all the details of the evolution granularity and the way the data has been stored, which means that the user X  X  conceptual model should match the one of the database, we X  X  like the system to try to match the user X  X  conceptual model. This means that the system should have the evolution re-lationships represented explicitly and take them into account when evaluating a query. In particular, we want the system to treat the AT&amp;T Bell Labs, the AT&amp;T Labs Inc, and the AT&amp;T Labs as one unified (virtual) entity. That unified entity is the inventor of both the laser and the ASR, and should be the main element of the response to the user X  X  query.

Of course, the query response is based on the assumption that the user did not indend to distinguish between the three aforementioned labs. Since this is an assumption, it should be associated with some degree of confidence. Such a degree can be based, for instance, on the number of labs that had to be merged in order to produce the answer. A response that involves 2 evolution-related entities should have higher confidence than one involving 4.

As a similar example, consider a query asking for all the partners of AT&amp;T Labs Inc. Apart from those explicitly stated in the data (in the specific case, none), a traversal of the history of the labs can produce additional items in the answer, consisting of the partners of its predecessors. The further this traversal goes, the less the likely it is that this is what the user wanted; thus, the confidence of the answer that includes the partners of its predecessors should be reduced. Furthermore, if the evolution relationships have also an associated degree of confidence, i.e., less than 100% certainty, the confidence computation of the answers should take this into consideration as well.
We adopt a concept model [7] that is gaining popularity in many areas including dataspaces [10]. Its fundamental component is the entity which is used to model a real world object. An entity is a data structure consisting of a unique identifier and a set of attributes. Each attribute has a name and a value. The value of an attribute can be an atomic value or an entity identifier. More formally, assume the existence of an infinite set of entity identifiers O , an infinite set of names N and an infinite set of atomic values V .

D EFINITION 3.1. An attribute is a pair  X  n , v  X  , with n  X  X  and v  X  X  X  X  . Attributes for which v  X  X  are specifically referred to as associations . Let A = N X {V X  X } be the set of all the possible at-tributes. An entity is a tuple  X  id , A  X  where A  X  X  , is finite, and id  X  X  . The id is referred to as the entity identifier while the set A as the set of attributes of the entity.

We will use the symbol E to denote the set of all possible enti-ties that exist and we will also assume the existence of a Skolem function Sk [15]. Recall that a Skolem function is a function that provides a unique different value for two different arguments. Each entity is uniquely identified by its identifier, thus, we will often use the terms entity and entity identifier interchangingly if there is no risk of confusion. A database is a collection of entities, that is closed in terms of associations between the entities.
D EFINITION 3.2. A database is a finite set of entities E  X  X  such that for each association  X  n, e 0  X  of an entity e  X  E : e
As a query language we adopt a datalog style language. A query consists of a head and a body. The body is a conjunction of atoms. An atom is an expression of the form e ( n 1 : v 1 , n 2 : v or an arithmetic condition such as = ,  X  , etc. The head is always a non-arithmetic atom. Given a database, the body of the query is said to be true if all its atoms are true. A non-arithmetic atom identifier e and attributes  X  n i , v i  X  for every i =1 ..k . When the body of a query is true, the head is also said to be true. If a head e ( n n : v 2 , . . . , n k : v k ) is true, the answer to the query is an entity with identifier e and attributes  X  n 1 : v 1  X  ,  X  n 2 : v 2  X  , . . . ,  X  n
The components e , n i and v i , for i =1 ..k of any atom in a query can be either a constant or a variable. Variables used in the head or in arithmetic atoms must also be used in some non-arithmetic atom in the body. If a variable is used at the beginning of an atom, it is bound to entity identifiers. If the variable is used inside the parenthesis but before the  X : X  symbol, it is bound to attribute names, and if the variable is in the parenthesis after the  X : X  symbol, it is bound to attribute values. A variable assignment in a query is an assignment of its variables to constants. A true assignment is an assignment that makes the body of the query true. The answer set of a query involving variables is the union of the answers produced by the query for each true assignment.

E XAMPLE 3.3. Consider the query: $ x ( isHolder :$ y ) :-$ x ( name : 0 AT &amp; T LabsInc. that looks for entities called  X  X T&amp;T Labs Inc. X  and are holders of a patent. For every such entity that is found, an entity with the same identifier is produced in the answer set and has an attribute isHolder with the patent as a value.

In order to model evolution we need to model the lifespan of the real world objects that the entities represent and the evolution rela-tionship between them. For the former, we assume that we have a temporal database, i.e., each entity is associated to a time period; however, this is not critical for this work so we will omit that part from the following discussions. To model the evolution relation-ship, on the other hand, we consider a special association that we elevate into a first-class citizen in the database. We call this associa-tion an evolution relationship . Intuitively, an evolution relationship from one entity to another is an association indicating that the real world object modeled by the latter is the result of some form of evolution of the object modeled by the former. In Figure 1, the dot-ted lines between the entities illustrate evolution relationships. A database with evolution relationships is an evolution database .
D EFINITION 3.4. An evolution database is a tuple  X  E ,  X   X  , such that  X  E  X  is a database and  X  is a partial order relation over E . An evolution relationship is every association ( e 1 , e 2 )  X   X  .
Given an evolution database, one can construct a directed acyclic graph by considering as nodes the entities and as edges its evolution relationships. We refer to this graph as the evolution graph of the database.

Our proposal is that entities representing different evolution phases of the same real world object can be considered as one for query answering purposes. To formally describe this idea we in-troduce the notion of coalescence . Coalescence is defined only on entities that are connected through a series of evolution relation-ships; the coalescence of those entities is a new entity that replaces them and has as attributes the union of their attributes (including associations).

D EFINITION 3.5. Given an evolution database  X  E ,  X   X  , The co-alescence of two entities e 1 :  X  id 1 , A 1  X  , e 2 :  X  id through an evolution relationship ev is a new evolution database  X  E 0 ,  X  0  X  such that  X  0 = X   X  ev and E 0 = ( E  X  X  e 1 , e 2 where e new :  X  id new , A new  X  is a new entity with a fresh identi-fier id new = Sk ( id 1 , id 2 ) and A new = A 1  X  A 2 . Furthermore, each  X  n , id new  X  . The relationship between the two databases is denoted as  X  E ,  X   X  ev  X  X  X  X  E 0 ,  X  0  X 
The Skolem function that we have mentioned earlier defines a partial order among the identifiers, and this partial order extends naturally to entities. We call that order subsumption .

D EFINITION 3.6. An identifier id 1 is said to be subsumed by an identifier id , denoted as id 1 and id x 6 = id 1 such that id = Sk ( id 1 , id x ) . An entity e is said to be subsummed by an entity e 2 =  X  id 2 , A 2  X  , denoted as e .  X  e 2 , if id 1 tribute  X  n , v 2  X  X  X  A 2 such that v 1 = v 2 or, assuming that the attribute is an association, v 1
Given an evolution database  X  E ,  X   X  , and a set  X  s  X   X  one can perform a series of consecutive coalescence operations, each one coalescing the two entities that an evolution relationship in the  X  associates.

D EFINITION 3.7. Given an evolution database D :  X  E ,  X   X  and a set  X  s = { m 1 , m 2 , . . . , m m } such that  X  s  X   X  , let D tion database generated by the sequence of coalescence operations D  X  X  X  D 1 m 2  X  X  X  , . . . , m m  X  X  X  D m . The possible world of D according to  X  s is the database D  X  s generated by simply omitting from D its evolution relationships.

Intuitively, a set of evolution relationships specifies sets of enti-ties in a database that should be considered as one, while the pos-sible world represents the database in which these entities have ac-tually been coalesced. Our notion of a possible world is similar to the notion of a possible worlds in probabilistic databases [8]. Direct consequence of the definition of a possible world is the following theorem: T HEOREM 3.8. The possible world of an evolution database D :  X  E ,  X   X  for a set  X  s  X   X  is unique.

Due to this uniqueness, a set  X  s of evolution relationships of a database can be used to refer to the possible world.

According to the definition of a possible world, an evolution database can be seen as a shorthand of a set of databases, i.e., its possible worlds. Thus, a query on an evolution database can be seen as a shorthand for a query on its possible worlds. Based on this observation we define the semantics of query answering on an evolution database.

D EFINITION 3.9. The evaluation of a query q on an evolution database D is the union of the results of the evaluation of the query on every possible world D c of D .

For a given query, there may be multiple possible worlds that generate the same results. To eliminate this redundancy we require every coalescence to be well-justified. In particular, our principle is that no possible world or variable assignment will be considered, unless it generates some new results in the answer set. Further-more, among the different possible worlds that generate the same results in the answer set, only the one that requires the smaller num-ber of coalescences will be considered. To support this, we define a subsumption relationship among the variable assignments across different possible worlds and we redefine the semantics of the eval-uation of a query. Table 1: A fraction of variable assignments for Example 3.11.
D EFINITION 3.10. Let h and h 0 be two variable assignment for a set of variables X . h 0 is said to be subsumed by h , de-noted as h 0  X  h if  X  x  X  X : h ( x )= h 0 ( x )= constant , or h ( x )= e and h ( x )= e 0 , with e and e 0 being entities for which e 0 Given an evolution database D , let W be the set of its possible worlds. The answer to a query q is the union of the results of eval-uating q on every database in W . During the evaluation of q on a database in W , true variable assignments that are subsumed by some other true variable assignment, even in other possible worlds, are not considered.

It is natural to assume that not all possible worlds are equally likely to describe the database the user has in mind when she was formulating the query. We assume that the more a possible world differs from the original evolution database, the less likely it is to represent what the user had in mind. This is also in line with the minimality and well-justification principle described previously. We reflect this as a reduced confidence to the answers generated by the specific possible world and quantify it as a score assigned to each answer. One way to measure that confidence is to count how many evolution relationships have to be coalesced for the pos-sible world to be constructed. The evolution relationships may also be assigned a weight reflecting the confidence to the fact that its second entity is actually an evolution of the first.

E XAMPLE 3.11. Consider again the query of Example 3.3. and assume that it is to be evaluated on the database of Figure 1. Table 1 illustrate a set of true variable assignments for some of the possible worlds of the database. The possible world on which each assignment is defined is expressed through its respective set  X  . The fourth column contains the result generated in the an-swer set from the specific assignment and the last column contains its respective cost, measured in number of coalesces that are re-quired for the respective possible world to be generated from the evolution database. Note that the second and the third assignment (highlighted in bold), are redundant since they are subsumed by the first.

The existence of a score for the different solutions, allows us to rank the query results and even implement a top-k query answer-ing. The challenging task though is how to identify in an efficient way the possible worlds and more specifically the true variable as-signments that lead into correct results.
The straight forward approach in evaluating a query is to gen-erate all the possible worlds and evaluate the query on each one individually. In the sequel, generate the union of all the individ-ually produced results, eliminate duplication and remove answers subsumed by others. Finally, associate to each of the remaining answers a cost based on the coalescences that were performed in order to generate the possible world from which the answer was produced, and rank the answers according to that score. The gen-eration of all possible worlds is a time consuming task. For an evo-lution database with an evolution graph of N edges, there are 2 possible worlds. This is clearly a brut force solution, not desirable for online query answering.
Since the possible worlds do not depend on the query that needs to be evaluated, they can be pre-computed and stored in advance so that they are available at query time. Of course, as it is the case of any materialization technique, the materialized data need to be kept in sync with the evolution database when its data is modified. Despite the fact that this will require some effort, there are already well-known techniques for change propagation [3] that can be used. The major drawback, however, is the space overhead. A possible world contains all the attributes of the evolution database, but in fewer entities. Given that the number of attributes are typically larger than the number of entities, and that entities associated with evolution relationships are far fewer than the total number of enti-ties in the database, we can safely assume that the size of a possible world will be similar to the one of the evolution database. Thus, the total space required will be 2 n times the size of the evolution database. The query answering time, on the other hand, will be 2 times the average evaluation time of the query on a possible world.
An alternative solution is to generate and materialize the possible world D max generated by performing all possible coalescences. For a given evolution database  X  E,  X   X  , this world is the one con-structed according to the set of all evolution relationships in  X  . Any query that has an answer in some possible world of the evolution database will also have an answer in this maximal possible world D max . This solution work has two main limitations. First it does not follow our minimalistic principle and performs coalescences that are not needed, i.e., they do not lead to any additional results in the result set. Second, the generated world fails to include re-sults that distinguish difference phases of the lifespan of an entity (phases that may have to be considered individual entities) but the approach coalesces them in one just because they are connected through evolution relationships.
To avoid any form of materialization, we propose an alternative technique that computes the answers on the fly by performing co-alescences on a need-to-do basis. In particular, we identify the at-tributes that satisfy the different query conditions and from them the respective entities to which they belong. If all the attributes satisfying the conditions are on the same entity, then the entity is added in the answer set. However, different query conditions may be satisfied by attributes in different entities. In these cases we identify sets of entities for each one of which the union of the at-tributes of its entities satisfy all the query conditions. For each such a set, we coalesce all its entities into one if they belong to the same connected component of the evolution graph. Doing the coa-lescence it is basically like creating the respective possible world; however, we generate only the part of that world that is necessary to produce an answer to the query. In more details, the steps of the algorithm are the following. [Step 1: Query Normalization] We decompose every non-arithmetic atom in the body of the query that has more than one condition into a series of single-condition atoms. More specifically, any atom of the form x ( n 1 : v 1 , n 2 : v 2 , . . . , n into a conjunction of atoms x ( n 1 : v 1 ) , x ( n 2 : v [Step 2: Individual Variable Assignments Generation] For each non-arithmetic atom in the decomposed query, a list is constructed that contains assignments of the variables in the respective atom to constants that make the atom true. Assuming a total of N non-arithmetic atoms after the decomposition, let L 1 , L 2 , . . . , L the generated lists. Each variable assignment actually specifies the part of the evolution database that satisfies the condition described in the atom. [Step 3: Candidate Assignment Generation] The elements of the lists generated in the previous step are combined together to form complete variable assignments, i.e., assignments that involve every variable in the body of the query. In particular, the cartesian product of the lists is created. Each element in the cartesian product is a tuple of assignments. By construction, each such tuple will contain at least one assignment for every variable that appears in the body of the query. If there are two assignments of the same attribute bound variable to different values, the whole tuple is rejected. Any repetitive assignments that appear within each non-rejected tuple is removed to reduce redundancy. The result is a set of variable assignments, one from each of the tuples that have remained. [Step 4: Arithmetic Atom Satisfaction Verification] Each assign-ment generated in the previous step for which there is at least one arithmetic atom not evaluating to true, is eliminated from the list. [Step 5: Candidate Coalescence Identification] Within each of the remaining assignments we identify entity-bound variables that have been assigned to more than one values. Normally this kind of assignment evaluates always to false. However, we treat them as suggestions for coalescences, so that the assignment will become a true assignment (ref. previous Section). For each assignment h in the list provided by Step 4, the set V h = { V x 1 , V generated, where V x is the set of different entities that variable x has been assigned in assignment h . In order for the assignments of variable x to evaluate to true, we need to be able to coalesce the entities in V x . To do so, these entities have to belong to the same connected component in the evolution graph of the database. If this is not the case, the assignment h is ignored. [Step 6: Coalescence Realization &amp; Cost Computation] Given a set V h = { V x 1 , V x 2 , . . . , V x k } for an assignment h among those provided by Step 5, we need to find the minimum cost coalescences that need to be done such that all the entities in a set V are coalesced to the same entity. This will make the assignment h a true assignment, in which case the head of the query can be computed and an answer generated in the answer set. The cost of the answer will be the cost of the respective possible world, which is measured in terms of the number of coalescences that need to be performed. Finding the required coalescences for the set V minimizes the cost boils down to the problem of finding a Steiner forest [12],
E XAMPLE 4.1. Let us consider again the query of Exam-ple 3.3. In Step 1, its body will be decomposed into two parts: $ x ( name : 0 AT &amp; T LabsInc. 0 ) and $ x ( isHolder :$ y ) . For those two parts, during Step 2, the lists L and L 2 = {{ $ x = e 1 , $ y = 0 P 2 P V ideo 0 } , { $ x = e 3 , $ y = { $ x = e 4 , $ y = 0 Laser 0 } , { $ x = e 5 , $ y = 0 V oIP ated. Step 3 creates their cartesian product L = {{ $ x = e 1 , $ x = e 1 , $ y = 0 P 2 P V ideo 0 } , { $ x = e 1 , $ x = e 3 , $ y = $ x = e 4 , $ y = 0 Laser 0 } , { $ x = e 1 , $ x = e 5 , $ y = only attribute bound variable is $ y but this is never assigned to more than one different value at the same time so nothing is elim-inated. Since there are no arithmetic atoms, Step 4 makes no change either to the list L . If for instance, the query had an atom $ y 6 = 0 V OIP 0 in its body, then the last element of the list would have been eliminated. Step 5 identifies that the last three elements in L have the entity bound variable $ x assigned to two different val-ues; thus, it generates the candidate coalesences: V 1 = { e 1 , e 3 } , V = { e 1 , e 4 } and V 3 = { e 1 , e 5 } . Step 6 determines that all three coalescences are possible. Entities e 1 , e 2 and e 3 will be coalesced
The last step of the evaluation algorithm presented in the previ-ous section takes as input a set of entity sets and needs to perform a series of coalesce operations such that all the entities within each set will become one. To do so, it needs to find an interconnect on the evolution graph among all the entities within each set. Note that the interconnect may involve additional entities not in the set that unavoidably will also have to be coalesced with those in the set. Thus, it is important to find an interconnect that minimizes the total cost of the coalescences. The cost of a coalescence operation is the weight of the evolution relationship that connects the two entities that are coalesced. Typically, that cost is equal to one, meaning that the total cost is actually the total number of coalescence operations that need to be performed. For a given set of entities, this is known as the problem of finding the Steiner tree [11]. However, given a set of sets of entities, it turns out that finding the optimal solution, i.e., the minimum cost interconnect of all the entities, is not always the same as finding the Steiner tree for each of the sets individually. The specific problem is found in the literature as the Steiner forest problem [12].

The difference in the case of the Steiner forest is that edges can be  X  X sed X  by more than one interconnect. More specifically, the Steiner tree problem aims at finding a tree on an undirected weighted graph that connects all the nodes in a set and has the min-imum cost. In contrast to the minimum spanning tree, a Steiner tree is allowed to contain intermediate nodes in order to reduce its total cost. The Steiner forest problem takes as input sets of sets of nodes and needs to find a set of non-connected trees (branches) that make all the nodes in each individual set connected and the total cost is minimal, even if the cost of the individual trees are not always the minimal. We refer to these individual trees with the term branches . Figure 2 illustrates the difference through an example. Assuming that we have the graph shown in the figure and the two sets of nodes { x , y } and { u , v } . Clearly, the minimum cost branch that connects nodes x and y is the one that goes through the nodes a, b and c. Similarly the minimum cost branch that connects u and v is the one that goes through the nodes e, f and g. Each of the two branches has cost 4 (the number of edges in the branch), thus, the total cost will be 8. However, if instead we connect all the four nodes x, y, u and v though the tree that uses the nodes i, j, k and m, then, although the two nodes in each set are connected with a path of 5 edges, the total cost is 7. Algorithm 1 Steiner tree algorithm Input: graph G , f : E  X  R + , groups V = V 1 , . . . , V Output: ST for each element in f lat ( V ) 1: Q T : priority queue sorted in the increasing order 2: Q T  X  X  X  3: for all s i  X  maxf lat ( V ) do 4: enqueue T ( s i , { s i } ) into Q T ; 5: end for 6: while Q T 6 =  X  do 7: dequeue Q T to T ( v, p ) ; 8: if p  X  f lat ( V ) then 9: ST ( p ) = T ( v, p ) 10: end if 11: if ST has all values then 12: return ST 13: end if 14: for all u  X  N ( v ) do 15: if T ( v, p )  X  ( v, u ) &lt; T ( u, p ) then 16: T ( u, p )  X  T ( v, p )  X  ( v, u ) ; 17: update Q T with the new T ( u, p ) ; 18: end if 19: end for 20: p 1  X  p ; 21: for all p 2 s.t. p 1  X  p 2 =  X  do 22: if T ( v, p 1 )  X  T ( v, p 2 ) &lt; T ( v, p 1  X  p 2 ) then 23: T ( u, p 1  X  p 2 )  X  T ( v, p 1 )  X  T ( v, p 2 ) ; 24: update Q T with the new T ( u, p 1  X  p 2 ) ; 25: end if 26: end for 27: end while
Formally, the Steiner forest problem is defined as follows. Given a graph G =  X  N, E  X  and a cost function f : E  X  R + , alongside a set of groups of nodes V = V 1 , . . . , V L , where V i C  X  E such that C forms a connected component that involves all the nodes of every group V i and the P
The literature contains a number of approximate solu-tions [2][18][14] as well as a number of exact solution using Dy-namic Programming [11][9][20] for the discovery of Steiner trees. However, for the Steiner forest problem (which is known to be NP-hard [12]) although there are approximate solutions [12], no opti-mal algorithm has been proposed so far. In the current work we are making a first attempt toward that direction by describing a solu-tion that is based on dynamic programming and is constructed by extending an existing Steiner tree discovery algorithm.

To describe our solution it is necessary to introduce the set f lat ( V ) . Each element in [ (( V )) is a set of nodes created by tak-ing the union of the nodes in a subset of V . More specifically, f lat ( V )= { U | U = S V 2
L members. We denote by maxf lat ( V ) the maximal element in f lat ( V ) which is the set of all possible nodes that can be found in all the sets in V , i.e., maxf lat ( V )= { n | n  X  V 1  X  . . .  X  V
Our solution for the computation of the Steiner forest consists of two parts. In the first part, we compute the Steiner trees for every member of the f lat ( V ) set, and in the second part we use the computed Steiner trees to generate the Steiner forest on V .
The state-of-the-art optimal (i.e., no approximation) algorithm for the Steiner tree problem is a dynamic programming solu-tion developed in the context of keyword searching in relational data [9]. The algorithm is called the Dynamic Programming Best First (DPBF) algorithm and is exponential in the number of input nodes and polynomial with respect to the size of graph. We ex-tend DPBF in order to find a set of Steiner trees, in particular a Steiner tree for every element in f lat ( V ) . The intuition behind the extension is that we initially solve the Steiner tree problem for the maxf lat ( V ) and continue iteratively until the Steiner trees for ev-ery element in f lat ( V ) has been computed. We present next a brief description of DPBF alongside our extension.

Let T ( v, p ) denote the minimum cost tree rooted at v that in-cludes the set of nodes p  X  maxf lat ( V ) Note that by definition, the cost of the tree T ( s, maxf lat ( V )) is 0, for every s  X  maxf lat ( V ) .
Trees can be iteratively merged in order to generate larger trees by using the following three rules.
 where  X  is an operator that merges two trees into a new one and N ( v ) is the set of neighbour nodes of node v . In [9] it was proved that these equations are dynamic programming equations leading to the optimal Steiner tree solution for maxf lat ( V ) set of nodes. To find it, the DPBF algorithm employs the Dijkstra X  X  shortest path search algorithm in the space of T ( v, p ) . The steps of the Steiner tree computation are shown in Algorithm 1. In particu-lar, we maintain a priority queue Q T that keeps in an ascending order the minimum cost trees that have been found at any given point in time. Naturally, a dequeue operation retrieves the tree with the minimal cost. Using the greedy strategy we look for the next minimal tree which can be obtained from the current min-imal. In contrast to DPBF, we do not stop when the best tree has been found, i.e. when the solution for maxf lat ( V ) has been reached, but we keep collecting minimal trees (lines 7-10) until all elements in f lat ( V ) have been computed (lines 11-13). To prove that all the elements of f lat ( V ) are found during that procedure, it suffices to show that our extension corresponds to the finding of all the shortest paths for a single source in the Dijkstra X  X  algo-rithm. The time and space complexity for finding the Steiner trees is O (3 P l i n + 2 P l i (( P l i + logn ) n + m )) and O (2 tively, where n and m are the number of nodes and edges of graph G , and l i is the size of the i th set V i in the input of set V of the algorithm.

Once all the Steiner trees for f lat ( V ) have been computed, we use them to find the Steiner forest for V . The Steiner forest prob-lem has an optimal substructure and its subproblems overlap. This means that we can find a dynamic programming solution to it. To show this, we first we consider the case for L =1 , i.e., the case in which we have only one group of nodes. In that case finding the Steiner forest is equivalent to finding the Steiner tree for the single set of nodes that we have. Assume now that L&gt; 1 , i.e., the input set V is { V 1 , . . . , V L } , and that we have already computed all the Steiner forests for every set V 0  X  X  . Let SF ( V ) denote the Steiner forest for an input set V . We do not know the exact structure of SF ( V ) , i.e. how many branches it has and what elements of V are included in each. Therefore, we need to test all possible hypothe-ses of the forest structure, which are 2 L , and pick the one that has minimal cost. For instance, we assume that the forest has a branch that includes all nodes in V 1 . The total cost of the forest with that assumption is the sum of the Steiner forest on V 1 and the Steiner forest for { V 2 , . . . , V L } which is a subset of V , hence it is consid-ered known. The Steiner forest on V 1 is actually a Steiner tree. This is based on the following lemma.

L EMMA 5.1. Each branch of a Steiner forest is a Steiner tree. Algorithm 2 Steiner forest algorithm Input: G =  X  N, E  X  , V = { V 1 , . . . , V L } , ST ( s )  X  s  X  f lat ( V ) Output: SF ( V ) 1: for all V i  X  X  do 2: SF ( V i ) = ST ( V i ) 3: end for 4: for i = 2 to L  X  1 do 5: for all H  X  X  and | H | = i do 6: u  X  X  X  7: for all E  X  H and E 6 =  X  do 8: u  X  min ( u, ST ( maxf lat ( E ))  X  SF ( H \ E )) 9: end for 10: SF ( H )  X  u 11: end for 12: end for 13: u  X  X  X  14: for all H  X  X  and H 6 =  X  do 15: u  X  min ( u, ST ( maxf lat ( H ))  X  SF ( V \H )) 16: end for 17: SF ( V )  X  u
P ROOF . This proof is done by contradiction. Assuming that a branch of the forest is not a Steiner tree, it can be replaced with a Steiner tree and reduce the overall cost of the Steiner forest. This means that the initial forest was not minimal.
 We can formally express the above reasoning as: Using the above equation in conjunction with the fact that SF ( V )= ST ( V 1 ) , if V = { V 1 } , we construct an algorithm (Al-gorithm 2) that finds the Steiner forest in a bottom-up fashion. The time and space requirements of the specific algorithm are O (3 L  X  2 L ( L/ 2  X  1)  X  1) and O (2 L ) , respectively. Summing this with the complexities of the first part, it gives a total time complex-ity O (3 P l i n +2 P l i (( P l i + logn ) n + m ))+3 L  X  2 with space requirement O (2 P l i n + 2 L ) .
In the case of top-k query processing there is no need to actually compute all possible Steiner forests to only reject some of them later. It is important to prune as early as possible cases which are expected not to lead to any of the top-k answers. We have devel-oped a technique that achieves this. It is based on the following lemma.

L EMMA 6.1. Given two sets of sets of nodes V 0 and V 00 on a graph G for which V 0  X  X  00 : cost ( SF ( V 0 ))  X  cost ( SF ( V P ROOF . The proof is based on the minimality of a Steiner forest. Let SF( V 0 ) and SF( V 00 ) be Steiner forests for V costs w 1 and w 2 , respectively. If cost ( SF ( V 00 ))  X  cost ( SF ( V then we can remove V 00 \ V 0 from V 00 and cover V 0 with a smaller cost forest than SF ( V 0 ) , which contradicts the fact that SF ( V a Steiner forest.

To compute the top-k answers to a query we do the following steps. Assume that B = {V 1 , . . . , V n } is a set of inputs for the Steiner forest algorithm. First, we find the B min  X  B such that for each V 0  X  B min there is no V 00  X  B such that V 0  X  X  compute the Steiner forest for each element in B min . According to Lemma 6.1 and the construction procedure of B min we ensure that the the Top-1 is among the computed Steiner forests. We re-move the input which corresponds to that Top-1 answer from B and then we continue with the computation of Steiner forests to up-date B min . The above steps are repeated until k answers have been found.
To evaluate the efficiency and effectiveness of our approach we performed two kinds of experiments. First we studied the behavior of the Steiner forest discovery algorithm in isolation, and then we evaluated the performance of the query answering mechanism we have developed and which uses internally the Steiner forest algo-rithm. We also studied the effectiveness of our optimization tech-nique for top-k query answering.

In the experiments we used both synthetic and real data. We used the term non-evolution data to refer to entities and attributes, and the term evolution data to refer to the the evolution relation-ships and more generally to the evolution graph. We noticed that in the real datasets, the non-evolution data were much larger than the evolution data and we maintained a similar analogy during our synthetic data generation.

For the synthetic data generation we used the Erd X s-R X nyi graph generator [17] which can produce random graphs for which the probability to have an edge between two nodes is constant and inde-pendent of other edges. Since many real world data follow a power law distribution, for the non-evolution synthetic data we used the Zipf X  X  distribution. In our own implementation of the Zipfian dis-tribution, as a rank we considered the number of occurrences of  X  State, CA  X  appeared 15 time, its rank was 15 ). This allowed us to model the fact that there are few frequent attribute-value pairs and the majority are rare attributes. The real corpora that we used had similar properties. We will refer to the synthetic dataset gener-ated using this method as ER-SYNTH .

For real dataset we used an extract from the trademark corpora which is available from the United States Patent and Trademark Of-fice 1 . The trademarks are a kind of intellectual property which may belong to an individual or a company. If the owner of some trade-mark changes, the trademark has to be re-registered accordingly. Analyzing the trademark owner lists we could extract sequences of companies that have registered the same trademark, and we used this as an indication for evolution. We constructed the evolution graphs by considering each such a pair as an evolution relationship. The dataset we generated that way from the UPTSO files contained approximately 16K unique companies, 200K attributes (the infor-mation about companies such as name, place where it is registered and so on), and an evolution graph with 573 components of sizes between 5 and 373. To make the dataset extracted from real data even richer, i.e., with components of higher complexity, we used two graph merging strategies. In the first, a new evolution compo-nent is constructed by connecting two components through an arti-ficial evolution relationship edge between two random nodes from the two components. We refer to this kind of merge as CHAIN , because it creates a chain of source graphs. In the second strat-egy, two components are merged, by choosing an arbitrary node from one component and then adding evolution relationship edges to some random node of every other component. We refer to this method as STAR . Datasets generated using these methods will be denoted as REAL-CHAIN and REAL-STAR , respectively.

The naive evaluation strategies that were described in Sec-http://www.uspto.gov/ tions 4.1 and 4.2 are omitted from the discussion since their high complexity makes them practically infeasible to implement. In some sense, the naive case corresponds to the brute force way of finding a minimal Steiner forest, which is exponential in the size of evolution graph.

The experiments were all carried out on a 2.4GHz CPU and 4G memory PC running MS Windows Vista.
To study in detail the Steiner forest algorithm we performed two kinds of experiments. First, we studied the scalability properties of the algorithm for varying inputs, and then the behavior of the algorithm for graphs with different characteristics.
 Scaling the Input . Recall that the input to the Steiner forest algo-rithm is the set V = { V 1 , . . . , V L } . In this experiment we studied the query evaluation time with respect to the size of the input. By size we considered two parameters: (i) the total number of elements in i.e., the value L .

For the former, we started with L =1 and we scaled the P | V each size the average evaluation time of 25 random queries was recorded. The queries were evaluated both on synthetic and on real data. The synthetic graph was obtained using the Erd X s-R X nyi method and had n = 57 nodes and m = 65 edges. The real dataset graph was the one described previously. The results of this experiment are presented in Figure 3(a). The exponential grows in time (note that the time is presented on a logarithmic scale) with respect to a query size is consistent with the theoretical complexity of the Steiner forest algorithm.

To study how the parameter L affects the query execution time we kept the  X  L i =1 | V i | constant but modified the number of the sets L from 1 to 3 , and then we repeated the experiment for values of P i =1 | V i | from 6 to 10 (we assumed that a minimal set size was 2 ). The results of the average of 25 random query execution times are reported in Figure 3(b). The characteristics of the graph were the same as those in the previous experiment. The current experiment showed that the execution time depends fully on the P L i =1 not on L itself. This means that within a reasonable range of query sizes the number of forest branches does not have any influence on the performance.
 Scaling the Graph . In this experiment we studied the Steiner for-est discovery time with respect to the size of the graph. We used three kinds of graph data: ER-SYNTH , REAL-CHAIN and REAL-STAR , with sizes from 25 to 250 nodes with a step of 25 .
For the synthetic dataset the number of edges and nodes was almost the same. We generated 25 random inputs to the Steiner forest problem with L = 2 and | V 1 | =3 , and | V 2 | =3 . The results of this experiment are presented in Figure 3(c). The query evaluation time has a linear trend as expected, and it was interesting that the execution time was always less than a second..

We also studied the scalability of the algorithm in terms of the parameter L . For three queries with P | V i | = 6 and L =1 , 2 and 3 we varied the evolution graph size from 25 to 250 with step 25 . The graph we used was the ER-SYNTH with the same number of nodes and edges as before. The results are shown in Figure 3(d), where it can be observed that the scalability of the algorithm depends on the P L i =1 | V i | , and not on the number of forest branches, i.e., the number L , at least for values of P L i =1 | V i | up to 10.
Apart from experimenting with the Steiner forest algorithm in isolation, we run a number of experiments to evaluate the query answering mechanism we have developed for evolution databases. The query evaluation time depends not only on the evolution graph size and structure but also on the size and structure of the whole evolution database. First, we analyzed the behaviour of the system with respect to the query size. The query size is determined by the number of distinct variables, and their number of occurrences in the query. We started with a 1 -variable query and we observe its behavior as size increases.. Then, we tested the scalability of the query evaluation mechanism as a function of the evolution graph only. Finally, we studied the scalability as a function of the data (i.e., attributes and associations) and we found that their distribu-tion (but not their size) can dramatically affect the performance of the system.

In the synthetic data generation, we generated values that were following the Zipfian distribution for the attributes/associations. We controlled the generation of the ER-SYNTH dataset through four parameters, and in particular, the pool of entities , the exponent that is used to adjust the  X  X teepness X  of the Zipfian distribution, the number of elements that describes the maximum frequency of an attribute or association, and the number of attributes .The values of the parameters for the synthetic data are chosen to coincide with those of the real corpora.
 Scaling the Query . We considered a number of 1 -variable queries with a body of the form: and we performed a number of experiments for different values of N , i.e., the number of atoms in the query. For every atom we randomly chose an attribute-value pair from a pool of available dis-tinct attribute name/value pairs. The ER-SYNTH graph that was generated had 57 nodes and 65 edges. The results are shown in Figure 4(a). The same figure includes the results of the query eval-uation on the real dataset that had a size similar to the synthetic. For the generation of their non-evolution data we had the exponent set to 3 , the number of elements parameter set to 15 and their total number was 537 . The results of the Figure 4(a) are in a logarithmic scale and confirm the expectation that the query evaluation time is growing exponentially as the number of variables in the query grows. If we compare these results with those of the Steiner for-est algorithm for the respective case, it follows that the integrated system adds a notable overhead on top of the Steiner forest algo-rithm execution time. This is was due to the number of coalescence candidates and the number of Steiner forests that needed to be com-puted in order to obtain the cost of the elements in the answer set. Although the parameters for the generation of the synthetic and real data coincided, their trends were different, as Figure 4(c) illustrates.
We further tested how the number of entity variables in the query affect the performance. Note that we are mainly interested in the entity-bound variables. Let M represent the number of distinct entity-bound variables in the query, and M i the number of appear-ances of the i -th variable in the query. Note that the number of distinct variables will require to solve a Steiner forest problem in which the input V = { V 1 , . . . , V L } will have L = M and | V for each i =1 ..M . The total number of variable appearances in the query will naturally be P M i =1 M i .
 In the experiment, we chose a constant value for the P M i =1 and we run queries for M = 1, 2 or 3. As a dataset we used the ER-SYNTH with 57 nodes and 65 edges. 537 attributes were generated with the exponent parameter having the value 3 and the number of elements parameter to have the value 15 .A total of 53 synthetic as-sociations were also generated with the exponent parameter having the value 3 , and the number of elements parameter to have the value 10 . We used 25 randomly generated queries for each of the 3 M values, and took their average execution time. We did multiple runs of the above experiments for different values of P M i =1 4 and 10. The outcome of the experiments is shown in Figure 4(b) in a logarithmic scale. Clearly, the number of branches in a for-est did not affect the query evaluation time, i.e., queries with many variables showed the same increase in time as the 1 -variable query for the same P M i =1 M i .
 Scaling the Data . In this experiment we examined the query eval-uation time with respect to the size of the evolution graph. As evo-lution data, we used both real and synthetic sources. Regarding the real data, we used a series of graphs (and their attributes as non-evolution data) with sizes from 25 to 250 with step 25 . The number of edges was 110% of the number of nodes for all graphs. For the real dataset we used both the REAL-CHAIN and the REAL-STAR data. For each graph we generated 25 random queries with 3 distinct variables, i.e., M =3 , and each variable had M 1 and M 3 = 3 appearances in the query, and we measured the aver-age time required to evaluate them. As a synthetic dataset the ER-SYNTH was used, generated to be the same size as before but with the following Zipfian distribution parameters: exponent 3 , number of elements 15 and number attributes 10 times more than the num-ber of nodes. Note that we did not generate associations because the trademark dataset did not have any association that we could use as a guide. Figure 4(c) depicts the results of this experiment. It shows that there is a linear growth of time which is is accompa-nied with an increasing oscillations which can be explained by the growing exponent of non-evolution data, i.e. the number of coales-cence candidates may become too large for evolution graphs with considerable size.

Furthermore, we studied how the query evaluation time scales for different values of M , i.e. for different distinct variables but with the same total number of variable appearances in the query (i.e., the P M i =1 M i ). We used the ER-SYNTH dataset again with sizes from 25 to 250 , using a step 25 . The number of evolution re-lationships was 110% of the number of entities. For each case, we generated 25 random queries with M =1 having M 1 =6 , M =2 hav-ing M 1 =3 , and M 2 =3 and finally, M =3 having M 1 =3 , M and M 3 =2 . We executed these queries and measured the average evaluation time. The non-evolution data was following the Zipfian distribution with exponent 3 , the number of elements was 15 and the total number of attributes was 10 times more that the number of nodes (entities). For the associations, the exponent was 3 , the num-ber of elements was 10 and their total number was 5 times more that the respective number for nodes. The results are presented in Figure 4(d). Similarly to the previous experiment, we observed a linear growth with increasing oscillations.
 Evolution scalability for different forest structures . We further examined how the number of evolution graph components influ-ence the query evaluation time. For this purpose, we generated data using ER-SYNTH , and in particular 5 datasets of evolution graphs with a total size of 300 nodes and 330 edges. The sets had 1, 2, 3, 4 and 5 evolution graphs respectively. For each set we run 25 random queries with two distinct variables ( L = 2 ) that were appearing in the query 3 times each, i.e., M 1 =3 and M 2 =3 and measured their average execution time. As non-evolution data, we generated at-tributes and associations with varying exponent parameter, 2 . 5 , 3 and 3 . 5 . The total number of elements and attributes/associations were 15 and 1000 in one case, while it was 10 and 100 in the other. Figure 5(a) contains a table with the query evaluation time for each number of branches and exponent values. From the result, we could observe the dramatic decrease in time with respect to the number of evolution graph components. This can be explained by the fact that the query evaluation  X  X meared X  across a number of evolution Figure 5: Query evaluation time for graphs with different num-bers of connected components and for varying exponent of data distribution graph components where each evaluation time becomes consider-ably small.
 Data distribution dependency . Finally, we studied the properties of the system in relation to the data distribution parameter, namely the exponent of Zip X  X  distribution. The query optimizer described in Section 6 was taken into consideration here and we analyzed how the non-evolution data were affecting the top-k query answer-ing. For this experiment we used the following input parameters: 25 random queries with M =2 distinct variables, and M 1 =3 and M 2 =3 respective appearances of each distinct variable in the query. We used an ER-SYNTH dataset, the evolution graph of which had n = 57 nodes and m = 65 evolution edges. We also had 10000 attributes distributed over 30 entities, and 1000 associations dis-tributed over 15 entities. The exponent we used varied from 2 . 25 to 3 . 05 with a step of 0 . 1 . The results of the specific experiment are presented in Figure 5(b). For small exponents the difference between regular query answering and the top-10 or top-1 was sig-nificant. To justify this, recall that the number of pruned candidates depends on how different are the input sets in the Steiner forest al-gorithm input (ref. Section 6), thus, when the exponent is small the input sets share many entities.
In this work we presented a novel framework for dealing with evolution of entities at different granularity levels. We have made first class citizens of the system associations between entities indi-cating that they represent the same real world object but in different evolution phases. We have designed and implemented a technique that allows query answering over such databases even if the evolu-tion model that the user has in mind is of different granularity than the one used in the database. The solution required the computa-tion of a Steiner forest. For the later we have presented a novel algorithm for computing its optimal solution. Finally, we have per-formed a number of extensive experimental evaluation to determine the efficiency of our technique.
 [1] J. Banerjee, W. Kim, H. Kim, and H. F. Korth. Semantics [2] Gaurav Bhalotia, Arvind Hulgeri, Charuta Nakhe, Soumen [3] J. Blakeley, P. A. Larson, and F. W. Tompa. Efficiently Up-[4] P. Buneman, S. Khanna, K. Tajima, and W. Tan. Archiving [5] S. Chawathe, S. Abiteboul, and J. Widom. Representing and [6] S. Chien, V. J. Tsotras, and C. Zaniolo. Efficient Management [7] N. N. Dalvi, R. Kumar, B. Pang, R. Ramakrishnan, [8] Nilesh Dalvi and Dan Suciu. Efficient query evaluation on [9] Bolin Ding, J Xu Yu, Shan Wang, Lu Qin, Xiao Zhang, and [10] X. Dong and A. Y. Halevy. Indexing dataspaces. In SIGMOD , [11] S E Dreyfus and R A Wagner. The Steiner problem in graphs. [12] Elisabeth Gassner. The Steiner Forest Problem revisited. [13] A. Gupta, I. S. Mumick, and K. A. Ross. Adapting Material-[14] Hao He, Haixun Wang, Jun Yang 0001, and Philip S. Yu. [15] R. Hull and M. Yoshikawa. ILOG: Declarative Creation and [16] E. Ioannou, W. Nejdl, C. Niederee, and Y. Velegrakis. Onthe-[17] Richard Johnsonbaugh and Martin Kalin. A graph generation [18] Varun Kacholia, Shashank Pandit, Soumen Chakrabarti, [19] A. M. Keller. Algorithms for Translating View Updates to [20] B. Kimelfeld and Y. Sagiv. New algorithms for com-[21] B. S. Lerner. A Model for Compound Type Changes En-[22] P. McBrien and A. Poulovassilis. Schema Evolution in Het-[23] F. Rizzolo and A. A. Vaisman. Temporal XML: modeling, [24] F. Rizzolo, Y. Velegrakis, J. Mylopoulos, and S. Bykau. Mod-[25] N. Tahmasebi, T. Iofciu, T. Risse, C. Nieder X e, and W. Siber-[26] Y. Velegrakis, R. J. Miller, and J. Mylopoulos. Representing [27] C. Yu and L. Popa. Semantic Adaptation of Schema Mappings
