 Khashayar Rohanimanesh KHASH @ CS . UMASS . EDU The problem of labeling and segmenting sequences of observations arises in many different areas, including bioinformatics, music modeling, computational linguistics, speech recognition, and information extraction. Dynamic Bayesian networks (DBNs) (Dean &amp; Kanazawa, 1989; Murphy, 2002) are a popular method for probabilistic se-quence modeling, because they exploit structure in the problem to compactly represent distributions over multi-ple state variables. Hidden Markov models (HMMs), an important special case of DBNs, are a classical method for speech recognition (Rabiner, 1989) and part-of-speech tag-ging (Manning &amp; Sch  X  utze, 1999). More complex DBNs have been used for applications as diverse as robot naviga-tion (Theocharous et al., 2001), audio-visual speech recog-nition (Nefian et al., 2002), activity recognition (Bui et al., 2002), and information extraction (Skounakis et al., 2003; Peshkin &amp; Pfeffer, 2003).
 DBNs are typically trained to maximize the joint probabil-ity p ( y , x ) of a set of observation sequences x and labels y . However, when the task does not require being able to generate x , such as in segmenting and labeling, mod-Furthermore, generative models often must make problem-atic independence assumptions among the observed nodes in order to achieve tractability. In modeling natural lan-guage, for example, we may wish to use features of a word such as its identity, capitalization, prefixes and suffixes, neighboring words, membership in domain-specific lexi-cons, and category in semantic databases like WordNet X  features which have complex interdependencies. Genera-tive models that represent these interdependencies are in general intractable; but omitting such features or modeling them as independent has been shown to hurt accuracy (Mc-Callum et al., 2000).
 A solution to this problem is to model instead the condi-tional probability distribution p ( y | x ) . The random vector x can include arbitrary, non-independent, domain-specific feature variables. Because the model is conditional, the dependencies among the features in x do not need to be explicitly represented. Conditionally-trained models have been shown to perform better than generatively-trained models on many tasks, including document classification (Taskar et al., 2002), part-of-speech tagging (Ratnaparkhi, 1996), extraction of data from tables (Pinto et al., 2003), segmentation of FAQ lists (McCallum et al., 2000), and noun-phrase segmentation (Sha &amp; Pereira, 2003). Conditional random fields (CRFs) (Lafferty et al., 2001) are undirected graphical models that are conditionally trained. Previous work on CRFs has focused on the linear-chain structure, depicted in Figure 1, in which a first-order Markov assumption is made among labels. This model structure is analogous to conditionally-trained HMMs, and has efficient exact inference algorithms. Often, however, we wish to represent more complex interaction between labels X  X or example, when longer-range dependencies ex-ist between labels, when the state can be naturally repre-sented as a vector of variables, or when performing mul-tiple cascaded labeling tasks on the same input sequence (which is prevalent in natural language processing, such as part-of-speech tagging followed by noun-phrase segmenta-tion).
 In this paper, we introduce Dynamic CRFs (DCRFs) , which are a generalization of linear-chain CRFs that repeat struc-ture and parameters over a sequence of state vectors X  allowing us to represent distributed hidden state and com-plex interaction among labels, as in DBNs, and to use rich, overlapping feature sets, as in conditional models. For example, the factorial structure in Figure 1(b) includes links between cotemporal labels, explicitly modeling lim-ited probabilistic dependencies between two different label sequences. Other types of DCRFs can model higher-order Markov dependence between labels (Figure 2), or incorpo-rate a fixed-size memory. For example, a DCRF for part-of-speech tagging could include for each word a hidden state that is true if any previous word has been tagged as a verb. Any DCRF with multiple state variables can be collapsed into a linear-chain CRF whose state space is the cross-product of the outcomes of the original state variables. However, such a linear-chain CRF needs exponentially many parameters in the number of variables. Like DBNs, DCRFs represent the joint distribution with fewer parame-ters by exploiting conditional independence relations. Within natural-language processing, DCRFs are especially attractive because they are a probabilistic generalization of cascaded, weighted finite-state transducers (Mohri et al., 2002). In general, many sequence-processing problems are traditionally solved by chaining errorful subtasks such as FSTs. In such an approach, however, errors early in pro-cessing nearly always cascade through the chain, causing errors in the final output. This problem can be solved by jointly representing the subtasks in a single graphical model, both explicitly representing their dependence, and preserving uncertainty between them. DCRFs can repre-sent dependence between subtasks solved using finite-state transducers, such as phonological and morphological anal-ysis, POS tagging, shallow parsing, and information extrac-tion.
 We evaluate DCRFs on a natural-language processing task. A factorial CRF that learns to jointly predict parts of speech and segment noun phrases performs better than cascaded models that perform the two tasks in sequence. Also, we compare several schedules for belief propagation on this task, showing that although exact inference is feasible, ap-proximate inference has lower total training time with no loss in performance.
 The rest of the paper is structured as follows. In section 2, we describe the general framework of CRFs. Then, in sec-x y tion 3, we define DCRFs, and explain methods for approx-imate inference and parameter estimation. In section 4, we present the experimental results. We conclude in section 5. Conditional random fields (CRFs) (Lafferty et al., 2001) are undirected graphical models that encode a conditional probability distribution using a given set of features. CRFs are defined as follows. Let G be an undirected model over sets of random variables y and x . As a typical special case, y = { y t } and x = { x t } for t = 1 , . . . , T , so that labeling of an observed sequence x . If C = {{ y is the set of cliques in G , then CRFs define the conditional probability of a state sequence given the observed sequence as: where  X  is a potential function and the partition function Z ( x ) = P y Q c  X  C  X ( y c , x c ) is a normalization factor over all state sequences for the sequence x . We assume the potentials factorize according to a set of features { f which are given and fixed, so that The model parameters are a set of real weights  X  = {  X  one weight for each feature.
 Previous applications use the linear-chain CRF , in which a first-order Markov assumption is made on the hidden variables. A graphical model for this is shown in Fig-are the nodes and edges, so that there are feature functions f the feature functions as potentially depending on the entire input sequence.) Feature functions can be arbitrary. For example, a feature function f nary test that has value 1 if and only if y  X  adjective  X , y with a capital letter. 3.1. Model Representation A Dynamic CRF is a conditionally-trained undirected graphical model whose structure and parameters are re-peated over a sequence. As with a DBN, a DCRF can be specified by a template that gives the graphical structure, features, and weights for two time steps, which can then be unrolled given an instance x . The same set of features and weights is used at each sequence position, so that the parameters are tied across the network. Several example templates are given in Figure 2.
 Now we give a formal description of the unrolling process. Let y = { y y i = ( y i 1 . . . y im ) .
 bitrary DCRFs, we require a way to describe a clique in the unrolled graph independent of its position in the sequence. For this purpose we introduce the concept of a clique in-dex . Given a time t , we can denote any variable y two integers: its index j in the state vector y offset  X  t = i  X  t . We will call a set c = { ( X  t, j ) } pairs a clique index, which denotes a set of variables y by y variables in the unrolled version of clique index c at time Now we can formally define DCRFs: Definition Let C be a set of clique indices, F = { f k ( y t,c , x , t ) } be a set of real-valued weights. Then ( C, F,  X ) is a DCRF if and only if p ( y | x ) = where Z ( x ) = P the partition function.
 Although we define a DCRF has having the same set of features for all the cliques, in practice, we choose feature functions f with some index c clique index has having its own set of features and weights, and speak of f c .
 DCRFs generalize not only linear-chain CRFs, but more complicated structures as well. For example, in this paper, we use a factorial CRF (FCRF) , which has linear chains of labels, with connections between cotemporal labels. We name these after factorial HMMs (Ghahramani &amp; Jordan, 1997). Figure 1(b) shows an unrolled factorial CRF. Con-sider an FCRF with L chains, where Y chain ` at time t . The clique indices for this DCRF are of the form { (0 , ` ) , (1 , ` ) } for each of the within-chain edges and { (0 , ` ) , (0 , ` +1) } for each of the between-chain edges. The FCRF G defines a distribution over hidden states as: p ( y | x ) = where {  X  {  X  ` } are the potentials over the between-chain edges, and Z ( x ) is the partition function. The potentials factorize ac-cording to the features { f  X   X  More complicated structures are also possible, such as semi-Markov CRFs, in which the state transition probabil-ities depend on how long the chain has been in its current state, and hierarchical CRFs, which are moralized versions DBNs, this factorized structure can use many fewer param-eters than the cross-product state space: even the two-level FCRF we discuss below uses less than an eighth of the pa-rameters of the corresponding cross-product CRF. 3.2. Inference in DCRFs Inference in a DCRF can be done using any inference algorithm for undirected models. For an unlabeled se-quence x , we typically wish to solve two inference prob-lems: (a) computing the marginals p ( y cliques y arg max y p ( y | x ) . The Viterbi decoding is used to label a new sequence, and marginal computation is used for pa-rameter estimation (Section 3.3).
 Because marginal computation is needed during training, inference must be efficient so that we can use large train-ing sets even if there are many labels. The largest experi-ment reported here required computing pairwise marginals in 866,792 different graphical models: one for each train-ing example in each iteration of a convex optimization al-gorithm. Since exact inference can be expensive in com-plex DCRFs, we use approximate methods. Here we de-scribe approximate inference using loopy belief propaga-tion.
 Although belief propagation is exact only in certain spe-cial cases, in practice it has been a successful approximate method for general graphical models (Murphy et al., 1999; Aji et al., 1998). In general, belief propagation algorithms iteratively update a vector m = ( m tween pairs of vertices x x where  X ( x forming this update for one edge ( x is called sending a message from x sage vector m , approximate marginals are computed as p ( x u , x v )  X   X   X ( x u , x v ) Y where  X  is a normalization factor.
 At each iteration of belief propagation, messages can be sent in any order, and choosing a good schedule can af-fect how quickly the algorithm converges. We describe two schedules for belief propagation: tree-based and random. The tree-based schedule, also known as tree reparameteri-zation (TRP) (Wainwright et al., 2001; Wainwright, 2002), propagates messages along a set of cross-cutting spanning trees of the original graph. At each iteration of TRP, a span-ning tree T ( i )  X   X  is selected, and messages are sent in both directions along every edge in T ( i ) , which amounts to exact inference on T ( i ) . In general, trees may be selected from any set  X  = {T} as long as the trees in  X  cover the edge set of the original graph. In practice, we select trees randomly, but we select first edges that have never been used in any previous iteration.
 The random schedule simply sends messages across all edges in random order. To improve convergence, we arbi-trarily order each edge e m with V nodes and E edges, TRP sends O ( V ) messages per BP iteration, while the random schedule sends O ( E ) mes-sages.
 To perform Viterbi decoding, we use the same propaga-tion algorithms, except that the summation in Equation 5 is replaced by maximization. Also, the algorithms that we have described apply to DCRFs with at most pairwise cliques. Inference in DCRFs with larger cliques can be per-formed straightforwardly using generalized versions of the variational approaches in this section (Yedidia et al., 2000; Wainwright, 2002). 3.3. Parameter Estimation in DCRFs The parameter estimation problem is to find a set of parameters  X  = {  X  ditional log-likelihood The derivative of this with respect to a parameter  X  ciated with clique index c is  X  L over assignments to the clique y factor p probabilities in the unrolled DCRF.
 To reduce overfitting, we define a prior p ( X ) over parame-ters, and optimize log p ( X  |D ) = L ( X ) + log p ( X ) . We use a spherical Gaussian prior with mean  X  = 0 and covariance matrix  X  =  X  2 I , so that the gradient becomes See Peng and McCallum (2004) for a comparison of differ-ent priors for linear-chain CRFs.
 The function p ( X  |D ) is convex, and can be optimized by any number of techniques, as in other maximum-entropy models (Lafferty et al., 2001; Berger et al., 1996). In the results below, we use L-BFGS, which has previously out-performed other optimization algorithms for linear-chain CRFs (Sha &amp; Pereira, 2003; Malouf, 2002).
 The analysis above was for the fully-observed case, where the training data include observed values for all variables in the model. If some nodes are unobserved, the optimization problem becomes more difficult, because the log likelihood is no longer convex in general (details omitted for space). We present experiments comparing factorial CRFs to other approaches on noun-phrase chunking (Sang &amp; Buchholz, 2000). Also, we compare different schedules of loopy be-lief propagation in factorial CRFs. 4.1. Noun-Phrase Chunking Automatically finding the base noun phrases in a sentence can be viewed as a sequence labeling task by labeling each word as either B EGIN -P HRASE , I NSIDE -P HRASE , or O
THER (Ramshaw &amp; Marcus, 1995). The task is typically performed by an initial pass of part-of-speech tagging, but then it can be difficult to recover from errors by the tagger. In this section, we address this problem by performing part-of-speech tagging and noun-phrase segmentation jointly in a single factorial CRF.
 Our data comes from the CoNLL 2000 shared task (Sang &amp; Buchholz, 2000), and consists of sentences from the Wall Street Journal annotated by the Penn Treebank project (Marcus et al., 1993). We consider each sentence to be a training instance, with single words as tokens. The data are divided into a standard training set of 8936 sentences and a test set of 2012 sentences. There are 45 different POS labels, and the three NP labels.
 We compare a factorial CRF to two cascaded approaches, which we call CRF+CRF and Brill+CRF . CRF+CRF uses one linear-chain CRF to predict POS labels, and another linear-chain CRF to predict NP labels, using as a feature the Viterbi POS labeling from the first CRF. Brill+CRF predicts NP labels using the POS labels provided from the Brill tagger, which we expect to be more accurate than those from our CRF, because the Brill tagger was trained on over four times more data, including sentences from the CoNLL 2000 test set.
 The factorial CRF uses the graph structure in Figure 1(b), with one chain modeling the part-of-speech process and the other modeling the noun-phrase process. We use L-BFGS to optimize the posterior p ( X  |D ) , and TRP to compute the marginal probabilities required by  X  L / X  X  experience with linear-chain CRFs, we use the prior vari-ance  X  2 = 10 for all models.
 We factorize our features as f p on the assignment, and q the input string. Table 2 shows the features we use. All three approaches use the same features, with the obvious exception that the FCRF and the first stage of CRF+CRF do not use the POS features T Performance on noun-phrase chunking is summarized in Table 1. As usual, we measure performance on chunking by precision , the percentage of returned phrases that are correct; recall , the percentage of correct phrases that were returned; and their harmonic mean F and joint accuracy on (POS, NP) pairs. Joint accuracy is simply the number of sequence positions for which all la-bels were correct. The NP label accuracy should not be compared across systems, because different systems use different labeling schemes to encode which words are in the same chunk.
 Each row in Table 1 is the average of five different random subsets of the training data, except for row 8936, which is run on the single official CoNLL training set. All condi-tions used the same 2012 sentences in the official test set. On the full training set, FCRFs perform better on NP chunking than either of the cascaded approaches, includ-ing Brill+POS. The Brill tagger (Brill, 1994) is an estab-lished high-performance tagger whose training set is not only over four times bigger than the CoNLL 2000 data set, but also includes the WSJ corpus from which the CoNLL 2000 test set was derived. The Brill tagger is 97% accu-rate on the CoNLL data. Also, note that the FCRF X  X hich predicts both noun-phrase boundaries and POS X  X s more accurate than a linear-chain CRF which predicts only part-of-speech. We conjecture that the NP chain captures long-run dependencies between the POS labels.
 On smaller training subsets, the FCRF outperforms CRF+CRF and performs comparably to Brill+CRF. For all the training subset sizes, the difference between CRF+CRF and the FCRF is statistically significant by a two-sample t data on which CRF+CRF performed better than the FCRF. The variation over the randomly selected training subsets is small X  X he standard deviation over the five repetitions has mean 0.39 X  X ndicating that the observed improvement is not due to chance. Performance and variance on noun-phrase chunking is shown in Figure 3.
 On this data set, several systems are statistically tied for best performance. Kudo and Matsumoto (2001) report an F1 of 94.39 using a combination of voting support vector machines. Sha and Pereira (2003) give a linear-chain CRF that achieves an F1 of 94.38, using a second-order Markov assumption, and including bigram and trigram POS tags as features. An FCRF imposes a first-order Markov assump-tion over labels, and represents dependencies only between cotemporal POS and NP label, not POS bigrams or tri-grams. Thus, Sha and Pereira X  X  results suggest that more richly-structured DCRFs could achieve better performance than an FCRF.
 Other DCRF structures can be applied to many different language tasks, including information extraction. Peshkin and Pfeffer (2003) apply a generative DBN to extrac-tion from seminar announcements (Frietag &amp; McCallum, 1999), attaining improved results, especially in extracting locations and speakers, by adding a factor to remember the identity of the last non-background label. Our early results with a similar structure seem promising, for example, one DCRF structure performs within 2% F1 of a linear chain CRF, despite being trained on 37% less data. 4.2. Comparison of Inference Algorithms Because DCRFs can have rich graphical structure, and re-quire many marginal computations during training, infer-ence is critical to efficient training with many labels and large data sets. In this section, we compare different infer-ence methods both on training time and labeling accuracy of the final model.
 Because exact inference is feasible for a two-chain FCRF, this provides a good case to test whether the final classifica-tion accuracy suffers when approximate methods are used to calculate the gradient. Also, we can compare different methods for approximate inference with respect to speed and accuracy.
 We train factorial CRFs on the noun-phrase chunking task described in the last section. We compute the gradient using exact inference and approximate belief propagation using random, and tree-based schedules, as described in section 3.2. Algorithms are considered to have converged when no message changes by more than 10  X  3 . In these experiments, the approximate BP algorithms always con-verged, although this is not guaranteed in general. We trained on five random subsets of 5% of the training data, and the same five subsets were used in each condition. All experiments were performed on a 2.8 GHz Intel Xeon with 4 GB of memory.
 For each message-passing schedule, we compare terminat-ing on convergence (Random(  X  ) and Tree(  X  ) in Table 3), to terminating after three iterations (Random (3) and Tree (3)). Although the early-terminating BP runs are less ac-curate, they are faster, which we hypothesized could result in lower overall training time. If the gradient is too inac-curate, however, then the optimization will require many more iterations, resulting in greater training time overall, even though the time per gradient computation is lower. Another hazard is that no maximizing step may be possi-ble along the approximate gradient, even if one is possible along the true gradient. In this case, the gradient descent al-gorithm terminates prematurely, leading to decreased per-formance.
 Table 3 shows the average F1 score and total training times of DCRFs trained by the different inference methods. Un-expectedly, letting the belief propagation algorithms run to convergence led to lower training time than the early cutoff. For example, even though Random(3) averaged 427 sec per gradient computation compared to 571 sec for Random(  X  ), Random(  X  ) took less total time to train, because Random(  X  ) needed an average of 83.6 gradient computations per training run, compared to 133.2 for Ran-dom(3).
 As for final classification performance, the various approx-imate methods and exact inference perform similarly, ex-cept that Tree(3) has lower final performance because max-imization ended prematurely, averaging only 32.6 maxi-mizer iterations. The variance in F1 over the subsets, al-though not large, is much larger than the F1 difference be-tween the inference algorithms.
 Previous work (Wainwright, 2002) has shown that TRP converges faster than synchronous belief propagation, that is, with Jacobi updates. Both the schedules discussed in section 3.2 use asynchronous Gauss-Seidel updates. We emphasize that the graphical models in these experiments are always pairs of coupled chains. On more complicated models, or with a different choice of spanning trees, tree-based updates could outperform random asynchronous up-dates. Also, in complex models, the difference in classifi-cation accuracy between exact and approximate inference could be larger, but then exact inference is likely to be in-tractable.
 In summary, we draw three conclusions about this model. First, using approximate inference instead of exact infer-ence leads to lower overall training time with no loss in ac-curacy. Second, there is little difference between a random tree schedule and a completely random schedule for belief propagation. Third, running belief propagation to conver-gence leads both to increased classification accuracy and lower overall training time than an early cutoff. Dynamic CRFs are conditionally-trained undirected se-quence models with repeated graphical structure and tied parameters. They combine the best of both conditional random fields and the widely successful dynamic Bayesian networks (DBNs). DCRFs address difficulties of DBNs, by easily incorporating arbitrary overlapping input features, and of previous conditional models, by allowing more com-plex dependence between labels. Inference in DCRFs can be done using approximate methods, and training can be done by maximum a posteriori estimation.
 Empirically, we have shown that factorial CRFs can be used to jointly perform several labeling tasks at once, shar-ing information between them. Such a joint model per-forms better than a model that does the individual label-ing tasks sequentially, and has potentially many practical implications, because cascaded models are ubiquitous in NLP. Also, we have shown that using approximate infer-ence leads to lower total training time with no loss in accu-racy.
 In future research, we plan to explore other inference meth-ods to make training more efficient, including expectation propagation (Minka, 2001) and variational approximations. Also, investigating other DCRF structures, such as hier-archical CRFs and DCRFs with memory of previous la-bels, could lead to applications into many of the tasks to which DBNs have been applied, including object recogni-tion, speech processing, and bioinformatics.

