 Accessing both structured and unstructured data in an integrated fashion has become an important research topic that also gain ed commercial interest. As stated by Mudu-nuri[1], in order to achieve useful results, researchers require methods that consoli-date, store and query combinations of structured and unstructured data sets efficiently and effectively. The key to speeding up data access is to create a complete index me-chanism. There are many sophisticated index structure, such as B+ tree, Hash and their distributed variants[2] towards structured data, inverted index and semantics index[3] used to large scale text. However, index for the combinations of structured and unstructured data is still lacking. 
In this paper, we propose an associated index model which can be used to efficient conduct hybrid semantic query leveraging information from structured and unstruc-tured sources as described in [4]. Associated index, is built based on entities co-occurrence (e.g., a person may be occurred in both a document and a database record) between structured and unstructured data. To support semantic query, we also estab-lish the relationships among entities with knowledge of ontology, and define two custom relationships between an entity and its structured and unstructured data source. The index is stored as RDF graphs. Moreover, the index itself can be queried potentially for knowledge discovery and decision making. The associated index model is a hybrid index schema over database and documents stored in DFS. As shown in Fig.1. , the model has two index layers: associated index layer and secondary index layer. The associated index layer is represented as RDF graphs, which describe the semantic relationships among entities that extracted from documents, and two custom relationships  X  X nDoc X  and  X  X nRow X  between an entity and its corresponding structured and unstructured resource identifiers respectively. The resource identifiers namely rowID and termID point to secondary index. The secondary index layer is consists of two separate indexes. One is inverted index for document; the other is index for database, such as B+ tree, hash .etc. When searching for information about a specific entity, the associated index will first be applied to get the resource identifiers through the relatio nships InDoc and InRow with the entity. Then, use the resource identifiers to search secondary indexes separately to get docu-ments and table records that contain information about this entity. 2.1 Associated Index Structure The associated index, as we call it, is to associate unstructured and structured data based on entity co-occurrences, e.g., entity  X  X spirin X  is not only contained in document Doc2, but also described by a record  X  X 4 X  in table Medication. To express the complex rela-tionships explicitly, we store the associated index as RDF graphs. The index graph con-sists of two types of nodes, namely entity node and resource node. The entity nodes are represented as flat circles, and constructed from the entities mentioned in documents. The resource nodes are represented as rectangles, and derived from structured and un-structured resource identifiers. The edges in the graph represent the semantic relation-ships specified in knowledge bases between the connecting entity nodes (e.g., disease Diabetes Mellitus has the  X  X reat X  relationship to medicine Aspirin). In addition, our custom relationships  X  X nRow X  and  X  X nDoc X  also represented as edges to denote that an entity has a related resource in some document or database record. Fig.3. is an asso-ciated index graph for documents and structured table in Fig.2. 2.2 Secondary Index Structure Document indexing is conducted with entity inverted index, which takes into account the extract named entities (called mentions) from documents instead of terms. The inverted the entity. The index item is represented as &lt;mention, docID, position&gt;. As an example, the entity inverted index for the documents Doc1and Doc2 written in natural language in Fig.2 is shown in Fig.4. As for structured data, every record in database can be regard as an entity description. We just use the database X  X  built-in indexing mechanism such as B+ tree to create index on primary key or pseudo ROWID for these records. Data Collection. The structured dataset is collected from an open access medicine database (www.accessmedicine.mhmedical.com), which contains about 8,000 drug records. For each drug name, we executed a Web search on PubMed[12], and col-lected the top five medical literatures as unstructured dataset. Experimental Design. (1)Index storage costs. We tested against three differently sized subsets of dataset collection: 350MB (PM1), 700MB (PM2) and 1G(PM3). The results of index creation experiments are shown in Table 1. Both the index size and creation time grow linearly with size of dataset. Though it is time-consuming to create the index, it can be an offline job. (2) Query performance. We manually constructed time against dataset PM1, PM2, PM3 is shown in Fig.5. The result shows that all queries can be executed efficiently in seconds as dataset size grows. (3) Accuracy. In order to prove the advantage of the associated index, we also compare it with separate index mechanism. The separate index mechanism employs two separate indexes: inverted index for documents and B+ tree index on the drug database. Then we con-struct 10 queries and execute them against the two different index mechanisms. The comparison results in Fig.6 demonstrate that the association index can help query find more comprehensive information than separate indexes. The paper presented an associated index model that tends to index combinations of structured and unstructured data based on entity co-occurrences. Experimental results demonstrated that our proposed index achieved good performance and high accuracy of query processing. However, we are still far from creating big associated index on large-scale structured and unstructured data. In the future, we will study how to con-struct the index under distributed platform and how to maintain the index. 
