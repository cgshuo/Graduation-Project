 One of the central problems with real-life data is data consistency. Indeed, data in the real world is often dirty, with errors, conflicts and discrepancies. Inconsistent data inflicts a daunting cost. For example, it costs US businesses 600 billion dollars annually [5], and errors in medical data may have disastrous consequences such as death [18]. The scale of the problem is even worse in big data, and it poses one of the most pressing challenges to big data management.

To detect data inconsistencies, a number of dependency formalisms have been studied, such as denial constraints [3], conditional functional dependencies ( CFDs ) [7] and conditional inclusion dependencies ( CINDs ) [14]. Using these dependencies as data quality rules, several systems have been developed for detecting errors an d repairing real-life data (see [6] for a recent survey).
These dependencies, however, fall short of effectively catching errors in nu-meric data, e.g., integer and real numbers. Numeric values are widely found in, e.g., medical, scientific and financial data, and should by no means be overlooked. Example 1. (1) A relation r 1 is shown in Fig. 1(a), in which each tuple specifies a composer with his name , year of birth ( Yo B ), year of death ( Yo D ) and origin ( country , town ). The data in r 1 is, however, inconsistent: (a) Bonn is a city in Germany, not in Belgium (tuple t 2 ), and (b) it is normally expected that no one lives more than 120 years, i.e., Yo D  X  Yo B  X  120, in contrast to tuple t 1 .
The error in tuple t 2 can be detected by a CFD  X  1 : town =  X  X onn X   X  country =  X  X ermany X , which asserts that if the town is Bonn then the country is Ger-many. When  X  1 is used as a data quality rule, the inconsistency in t 2 emerges as a violation of  X  1 . However, to detect the inconsistency in t 1 ,itrequiresan arithmetic operation Yo D  X  Yo B on the numeric attributes Yo B and Yo D ,which is, unfortunately, not supported by denial constraints, CFDs or CINDs . (2) Relation r 2 of Fig. 1(b) shows the academic report of a high-school student, one tuple for each course taken, with the distribution of the score into homework ( hw ), tests , lab and projects ( proj ) (ignore Fig. 1(c) for now). Obviously the sum of these elements should be 100%. However, for tuple t 3 , its total percentage is 115%. To detect this error, arithmetic operations are again needed. (3) Relation r 3 of Fig. 1(d) is a sample of data from a bank. A tuple in r 3 specifies a transaction record of a credit card: the card number ( CC #), card holder in the UK ( name , street , city , zip ), when and where the card was physically used, and the amount charged to the card ( amnt ). Note that tuples t 5 and t 6 indicate a possible fraud . Indeed, Edinburgh (Edi) is 5 hours ahead of New York city (NYC), and flights from Edi to NYC take 7 hours. Hence, we have the constraint t NYC, respectively. That is, there is no way for one to use a card in Edinburgh at 21:00, and use the same card again in New York at 22:00 on the same day. The fraud, however, cannot be detected by the dependencies mentioned earlier. (4) Relation r 4 of Fig. 1(e) is a piece of census data from [10]. Each household is identified by an Hid , and within each household, Pid is a key for persons. There is a reference person for each Hid , and every other person in the household specifies a relationship with the reference, e.g., child, spouse, along with age , sex and marital status . One rule for census data is that a parent must be at least 12 t . Unfortunately, the dependencies mentioned earlier are unable to detect this.
This example tells us that to clean real-life data, we need new dependencies to detect errors in numeric attributes. Moreover, as the dependencies will be incorporated into existing data cleaning systems that support, e.g., CFDs ,the extension with the new dependencies should not incur substantial extra costs. Contributions . This paper studies new dependencies in response to the need. (1) We propose numeric functional dependencies ( NFDs , Section 2). NFDs are defined in a QBE -like syntax [16], and support arithmetic operations. We show that CFDs are a special form of NFDs . Hence, NFDs can serve as data quality rules for detecting inconsi stencies commonly found in practice, numeric or not. (2) We show that NFDs do not increase the complexity of the static analyses of data quality rules (Section 3). Indeed, the classical problems  X  the satisfiability and implication problems  X  are NP -complete and coNP -complete for NFDs , respectively, the same as their counterparts for CFDs [7]. (3) We show that error detection with NFDs can be built on top of relational DBMS without requiring any additional functionality (Section 4). Indeed, for each NFD  X  ,an SQL query Q  X  can be automatically generated such that when Q  X  isevaluatedonadataset D , Q  X  ( D ) returns all and only those tuples in D that violate  X  , i.e., data inconsistencies, in low polynomial time ( ptime ). (4) Finally, we present an extension of NFDs and CFDs (Section 5). While NFDs and CFDs are defined on a single table, we show that they can be naturally extended to span across multiple tables, in a QBE -like syntax. Better still, the extended NFDs do not make our lives harder: they retain the same complexity bounds of the static analyses and error detection as their NFD counterparts.
We contend that NFDs are a natural extension of CFDs . They can be readily employed by data cleaning systems that already support CFDs [6], and extend the capabilities of those system to detect numeric errors in real-life data. Related work . A variety of dependencies have been studied as data quality rules for detecting data inconsistencies, from traditional functional and inclu-sion dependencies [2] to CFDs , CINDs and denial constraints [6]. Several data quality systems based on CFDs are already in place, and have proven effective in various applications. However, such dependencies cannot express arithmetic relationships and hence, do not effectively catch inconsistencies in numeric data.
The need for detecting numeric erro rs has long been recognized [4, 9 X  11, 13, 17]. Metric functional dependencie s [13] and sequential dependencies [11] extend functional dependencies by supporting (numeric) metrics and intervals on ordered data, respectively. However, they do not support arithmetic operations and cannot capture the inconsistencies of Example 1. A class of powerful aggre-gation constraints was proposed in [17], defined in terms of aggregate functions ( e.g., max, min, sum, avg, count). Using these constraints as data quality rules, data repairing and consistent query answering were studied in [4]. It is, however, too expensive to use aggregation constraints: it is undecidable even to decide whether a given set of aggregation constraints is satisfiable. There has also been work on repairing numeric data using constraints defined in terms of aggregate functions [9] and disjunctive logic programming [10]. These constraints are far more complicated than data quality rul es that are already employed by data cleaning systems such as CFDs . The complexity of their static analyses (satisfi-ability and implication) is not yet known and is suspected high. In contrast to the previous work, NFDs aim to strike a balance between the complexity of their reasoning and the expressive power needed for detecting numeric inconsistencies commonly found in practice. We want NFDs to be seamlessly incorporated into data quality systems that already use CFDs , without incurring much extra cost.
It is known that the satisfiability and implication analyses of CFDs are NP -complete and coNP -complete, respectively [ 7]. Moreover, for each CFD  X  ,two SQL queries can be automatically generated to detect all violations of  X  in a dataset [7]. We will show that NFDs retain the same complexity and property. Below we first define NFDs . We then show that CFDs are a special case of NFDs . Numeric Functional Dependencies . NFDs are defined on instances of a single relation schema R ( A 1 ,...,A n ). Each A i is an attribute, with domain dom ( A i ).
A numeric functional dependency  X  ( NFD ) defined on R is a pair of tables: (1) a pattern table T p of schema R has two tuples p 1 and p 2 ;for j  X  [1 , 2] and (2) a condition table T c with a single condition tuple of the form e op z ,where Here an arithmetic expression is built up from terms of numeric constants c or variables x in T p with a numeric domain, by closing them under arithmetic operators + ,  X  ,  X  ,  X  and | X | (for absolute value). Note that variables x ( i,j ) and x ( l,s ) that appear in pattern tuples p 1 and p 2 of T p may be identical, asserting condition p j [ A i ]= p s [ A l ]. When p j [ A i ]isaconstant c , it denotes condition p [ A i ]= c .If p 1 and p 2 are identical, T p consists of a single tuple p 1 only. Example 2. (1) An NFD  X  1 =( T P 1 ,T C 1 ) is defined on the composer relation of Fig. 1(a). As shown in Figures 2(a) and 2(b), T P 1 consists of a single pattern tuple t p 1 with t p 1 [ Yo B ]= x and t p 1 [ Yo D ]= y ,and T P 1 consists of a single condition. It is to ensure that for any composer tuple t , t [ Yo D ]  X  t [ Yo B ]  X  120. (2) Figures 2(c) and 2(d) define an NFD  X  2 =( T P 2 ,T C 2 ) on the academic report t [ lab ]+ t [ proj ] of the distribution of the marks should be equal to 100%. (3) Another NFD  X  3 =( T P 3 ,T C 3 ) is given in Figures 2(e) and 2(f), defined on the transaction data of Fig. 1(d). Note that pattern table T P 3 consists of two tuples. The NFD states that for any two transacti on records of the same credit card (specified by p 1 [ CC #] = x c and p 2 [ CC #] = x c ), if it was used in Edi and NYC, then the two transactions had to be at least two-hour apart. Note that constants  X  X di X  and  X  X YC X  are used to specify a pattern, along the same lines as CFDs [7]. In addition, variable x c is used to enforce condition p 1 [ CC #] = p 2 [ CC #]. (4) Finally, an NFDs  X  4 =( T P 4 ,T C 4 ) is given in Figures 2(g) and 2(h), defined on the census relation of Fig. 1(e). It assures that for any two persons in the same household ( p 3 [ hid ]) = x and p 4 [ hid ]= x ), if one is the  X  X eference X  and the other is his/her  X  X hild X , then the parent must be at least 12-years older than the child. Again, constants  X  X eference X  and  X  X hild X  specify patterns.
 Semantics. To give a formal semantics of NFDs , we use an operator defined on constants, variables and  X   X :  X  1  X  2 is interpreted as the truth value true if  X  2 is  X   X , and it is an equality predicate  X  1 =  X  2 otherwise. The operator naturally extends to tuples and produces true or a conjunction of equality atoms , e.g., (Main St, EDI, NYC) ( , x , y ) yields  X  X di X  = x  X   X  X YC X  = y .

Given ,an NFD  X  =( T P ,T C )inthe QBE -like syntax [16] given above can be rewritten into an equivalent first-order logic ( FO ) sentence as follows. Assume that T p has two pattern tuples p 1 and p 2 , T c is e op z , and that all the variables appearing in T P are x 1 ,...,x m .Then  X  can be written as the FO sentence: As remarked earlier, t 1 p 1 and t 2 p 2 yield two conjunctions  X  1 and  X  2 , possibly equal to true . The variables x i are specified in t j p j and used in e and z .
An instance D of relation schema R satisfies the NFD  X  , denoted by D | =  X  , if for all tuples t 1 and t 2 ,if t 1 and t 2 satisfy  X  1  X   X  2 following the standard semantics of first-order logic, then the condition e op z is also satisfied. We say that D satisfies aset  X  of NFDs , denoted by D | =  X  , if for all  X   X   X  , D | =  X  .
Intuitively, if tuples t 1 and t 2 match pattern tuples p 1 and p 2 , respectively, then the predicate e op z defined with arithmetic operations in e and the compar-ison operation op has to be satisfied. Observe that pattern tableau T P supports patterns of semantically related values such as  X  t [ where ] =  X  X di X  like CFDs [7]. Moreover, they also enforce equality by using variables, e.g., t 1 [ CC #] = x c and t [ CC #] = x c entail that t 1 [ CC #] = t 2 [ CC #]. In contrast to traditional FDs that are defined on all tuples in D (see, e.g., [2]), the NFD  X  is applicable only to the subset of tuples in D that match patterns p 1 and p 2 . Note that when T P consists of a single tuple p only, it is equivalent to two identical patterns p 1 = p 2 = p , and hence the semantics given above is also well-defined in this case. Example 3. Consider NFD  X  1 =( T P 1 ,T C 1 ) given in Figures 2(a) and 2(b). It is interpreted as  X  t, x, y t [ Yo B ]= x  X  t [ Yo D ]= y )  X  ( y  X  x  X  120) .
The NFD  X  3 =( T P 3 ,T C 3 ) given in Figures 2(e) and 2(f) is interpreted as  X  t 1 ,t 2 ,x c ,x t ,y t t 1 [ CC #] = x c  X  t 2 [ CC #] = x c  X  t 1 [ where ]= X  X di X  t [ where ] =  X  X YC X   X  ( | t 2 [ when ]  X  t 1 [ when ] | X  2) . The semantics of  X  2 and  X  3 given in Example 2 can be similarly i nterpreted in first-order logic. Taking NFDs and CFDs Together. Recall that CFDs on schema R can be written in a normal form  X  =( X  X  A, t p )[6],where(a) X is a set of attributes of R , A is a single attribute of R ,and(b) t p is a pattern tuple with attributes in X and A such that for each B  X  X  X  X  A } , t p [ B ] is either a constant in dom ( B ) or a wildcard  X   X . An instance D of R satisfies the CFD  X  , denoted by D | =  X  , if for any two tuples t 1 ,t 2  X  D ,when t 1 [ X ] t p [ X ]and t 2 [ X ] t p [ X ], then t [ A ]= t 2 [ A ] t p [ A ](here CFDs restrict  X   X  to constants and  X   X  X nly).
One can readily verify that  X  is equivalent to an NFD  X  of the following form. (1) If t p [ A ]isaconstant c , then the NFD  X  =( T p ,T c ), where T p consists of a single pattern tuple p such that (a) p [ A ] is a distinct variable, and (b) for all the other attributes B of R , p [ B ]= t p [ B ]if B  X  X ,and p [ B ]= X   X  X therwise;and (c) T c is x A = c . Such a CFD is referred to as a constant CFD in [6]. (2) If t p [ A ] is wildcard  X   X , then  X  =( T p ,T c ), where T p consists of two pattern respectively; (b) for all the other attributes B of R , p 1 [ B ]and p 2 [ B ] are defined in the same way as for constant CFDs ;and(c) T c is x 1 = x 2 . Such CFDs are called variable CFDs [6], which subsume traditional functional dependencies [2]. Example 4. The constraint  X  1 given in Example 1 is a constant CFD ,andcan be expressed as an equivalent NFD  X  0 =( T P 0 ,T C 0 ), where Based on the discussions above, one can readily verify the following.
 Proposition 1: CFDs of [7] are a special cases of NFDs .

This tells us that NFDs provide us with a uniform logic formalism to ex-press data quality rules for detecting dat a inconsistencies, numeric or not. In other words, NFDs are capable of capturing all errors that CFDs can catch, and moreover, errors in numeric attributes that CFDs are not able to detect. NFDs are strictly more expressive than CFDs . Indeed, Proposition 1 tells us that NFDs subsume CFDs ;moreover, NFDs can specify arithmetic relationships among numeric attributes such as those in  X  1  X   X  4 ,which CFDs cannot express. Despite the increase in expressive power, we next show that NFDs do not increase the complexity of reasoning about data quality rules. More specifically, we study two classical problems that are asso ciated with any dependency class C . Consider a set  X  of dependencies in C defined on a relation schema R .Touse  X  as data quality rules, we have to answer the following questions.  X  The satisfiability problem for C is to decide, given a set  X  of dependencies  X  The implication problem for C is to determine, given  X  and another depen-
The satisfiability analysis checks whether  X  has conflicts, i.e., whether the data quality rules in  X  are  X  X irty X  themselves. It help us find out what goes wrong in the rules. The implication analysis allows us to optimize our rules by eliminating redundant ones: if  X  | =  X  , then it suffices to use  X  instead of  X   X  X   X  } . When C is the class of traditional functional dependencies, any finite subset  X  of C is satisfiable, and its implication problem is in linear-time [2]. When it comes to NFDs , however, these problems are no longer simple.
 To understand where the complication arises, we consider a special form of NFDs , denoted by AFDs , in which conditions have the form of e op c ,where e is a linear arithmetic expressions defined on numeric attributes, and c is a constant. One can show that AFDs cannot express CFDs (not even constant CFDs ( X  X  A, t p )when A is a non-numeric attribute), and that CFDs cannot express AFDs . We show below that there exists a set of AFDs that is not satisfiable, even when all the attributes in R have an infinite domain. In contrast, for a set of CFDs to be unsatisfiable, the CFDs must be defined on some attributes with a finite domain (see [7] for more details).
 Example 5. Consider a relation schema R ( A, B ), where A and B have an infinite integer domain. Let  X  be a set consisting of two AFDs  X  1 =( T P ,T C 1 )and  X  2 =( T P ,T C 2 ), where T P consists of a single tuple ( x, y ), the condition of T C 1 is x  X  y =0,and T C 2 is y  X  x&gt; 0. Then there exists no nonempty instance D of R such that D | =  X  . Indeed, for any instance D of R , if there exists a tuple t  X  D ,then  X  The good news is that the extra expressive power introduced by NFDs over CFDs does not make our lives harder: their static analyses have the same com-plexity as their counterparts for CFDs [7],andaswellasfor AFDs . Theorem 2. For NFDs , (1) the satisfiability problem is NP -complete, and (2) the implication problem is coNP -complete. For AFDs , (3) the satisfiability and implication problems remain NP -complete and coNP -complete, respectively. Proof Sketch. (1) NFDs . The lower bounds follow from their counterparts for CFDs [7], since CFDs are a special case of NFDs . The upper-bound proofs are far more involved. To see the complications, observe that if arbitrary arithmetic expressions were allowed in NFDs , the satisfiability problem would be undecid-able, which could be verified by reduction from undecidable Diophantine equa-tions [12]. That is why we restrict arithmetic expressions in NFDs to be linear.
For the satisfiability problem, we first show that NFDs have a small model property: given a set  X  of NFDs defined on a schema R , if there exists a nonempty instance of R that satisfies  X  , then there exists an instance D 0 of R such that D values of the attributes of t 0 from a finite domain determined by the domains of the attributes and those constants in  X  . The proof of the small model property is nontrivial and needs to distinguish integers and non-integers. Based on the small model property, one can develop an NP algorithm for satisfiability checking as follows: (a) guess a tuple t 0 with values drawn from the finite domain, and (b) check whether { t 0 }| =  X  . The algorithm is in NP since step (b) is in ptime .
Similarly, the implication problem for NFDs is shown in coNP by establishing a small model property, where D 0 consists of two tuples. (b) AFDs . The upper bounds follow from their counterparts for NFDs ,since AFDs are a special case of NFDs . The lower bound for the satisfiability problem is verified by reduction from the linear integer programming problem ( LIP ), which is NP -complete (cf. [15]). The latter problem is to determine whether a set of linear inequalities has an integer solution. Similarly, the implication problem for AFDs is verified coNP -complete by reduction from the complement of LIP . Recall that we introduce NFDs to detect data inconsistencies. We next present an SQL technique for relational DBMS to detect inconsistencies as violation of NFDs . Consider a set  X  of NFDs defined on a relation schema R , an instance D of R ,andan NFD  X  =( T p ,T c )in  X  ,where T p consists of two pattern tuples p 1 and p 2 ,and T c is a condition e op z (see Section 2 for the definition of NFDs ). We say that a tuple t  X  D is a violation of  X  if there exists a tuple t  X  D such that { t, t } | =  X  , i.e., either t p 1 and t p 2 or t p 1 and t p 2 , but  X  ( e op z ). Here we use  X  ( e op z ) to denote that the condition e op z is not satisfied. For instance, if op is  X = X , then  X  ( e op z )is e = z ,andif op is  X   X   X , then  X  ( e op z ) is e&gt;z . Note that violations of  X  are defined on single tuples.

The error detection problem can then be stated as follows. Given  X  and D , it is to find the set of all tuples in D that are violations of some NFD in  X  , denoted by vio (  X ,D ); i.e., vio (  X ,D )= { t  X  D | X   X   X   X  , t is a violation of  X  } . The main result of this section is as follows.
 Proposition 3: (1) For any NFD  X  defined on a schema R ,thereexistsan SQL query Q  X  such that for any instance D of R , Q  X  ( D ) returns all violations of  X  in D .(2)Foranyset  X  of NFDs defined on R and any instance D of R , vio (  X ,D ) is computable in at most O ( ||  X  ||| D | 2 ) time, where ||  X  || is the cardinality of  X  ( i.e., the number of NFDs in  X  ), and | D | is the size of D .
 To prove Proposition 3, we show how Q  X  is (automatically) generated from  X  . Assume that  X  =( T p ,T c ), T p = { p 1 ,p 2 } ,and T c is condition e op z .Then Q  X  is: select t from Rt , Rt Here  X  1 ( t, t ,p 1 ,p 2 )encodes t p 1 and t p 2 in SQL , as a conjunction of terms such that for each attribute A of R ,(1) t [ A ]= c is a term if p 1 [ A ]isaconstant c ; similarly for t [ A ]= c ;and(2) t [ A ]= t [ A ]isatermif p 1 [ A ]and p 2 [ A ]are the same variable x A . The conjunct C 1 ( t, t ,e,z )encodes  X  ( e op z ) as described above, by substituting attributes of t and t for variables in e or z ;more specifically, each variable x occurring in e or z is replaced with t [ A ]if p 1 [ A ]= x (resp. with t [ A ]if p 2 [ A ]= x ). This is possible since SQL supports arithmetic operations (see, e.g., [1]). Along the same lines,  X  2 ( t, t ,p 1 ,p 2 )encodes t p 2 and t p 1 in SQL ,and C 2 ( t, t ,e,z )encodes  X  ( e op z ) accordingly. Example 6. The NFD  X  1 given in Example 2 can be implemented in SQL as Q 1 : Here we need a single variable t to range over composer tuples in this simple SQL query, since T P 1 has a single pattern tuple. Similarly,  X  4 can be validated by Q 4 : In contrast to Q 1 ,the SQL query Q 4 uses two variables t and t to range over census tuples, since T P 4 consists of two pattern tuples. Similarly, one can get SQL queries to validate the NFDs  X  2 and  X  3 given in Example 2.

As another example, recall the NFD  X  0 of Example 4 for expressing the CFD  X  ;this NFD can be validated by using the following SQL query Q 0 :
One can readily verify that given any instance D of R ,ittakes O ( | D | 2 ) time to evaluate Q  X  ( D ) in the worst case, to compute all violations of the NFD  X  in D (note that |  X  | is determined by the arity of R ). From this it follows that to stantially reduced via, e.g., indexing. This completes the proof of Proposition 3. Remark. Proposition 3 tells us that one can support inconsistency detection based on NFDs directly on top of commercial DBMS , without requiring any additional functionality. We conclude this section with the following remarks. (1) To detect violations of a CFD  X  in a database, an SQL method has been presented in [7], which requires two SQL queries in general. In contrast, we show that a single SQL query Q  X  suffices to validate an NFD  X  , although NFDs are more expressive than CFDs . Nonetheless, the SQL queries in [7] are in O ( |  X  || D | ) time, where |  X  | denotes the size of  X  ,whereasthe SQL query Q  X  takes O ( | D | 2 ) time (although the cost can be reduced as mentioned above). (2) After we have seen the static analyses and validation of NFDs , we now justify the definition of NFDs (Section 2). One might be tempted to extend NFDs by al-lowing (a) non-linear arithmetic expressions in T c , or (b) an unbounded number of pattern tuples in T p insteadofatmosttwo.Howev er, either extension would lead to substantial increase in the complexity. Indeed, (a) non-linear arithmetic expressions in conditions would make the satisfiability and implication analyses of NFDs undecidable, as shown in the proof of Theorem 2; and (b) an unbounded number of pattern tuples would require exponential time to validate an NFD  X  ; more specifically, it would take O ( | D | n ) time to validate  X  in the worst case, where n is the number of pattern tuples of  X  . As remarked earlier, we want to strike a balance between the expressive power and the complexity of NFDs . The current definition of NFDs , on one hand, suffices to catch (numeric) errors commonly found in the real world, and on the other hand, extends CFDs without increasing the complexity of the static analyses of data quality rules. Both NFDs and CFDs are defined on a single relation schema R .Wenextshow that they can be readily extended to detect data inconsistencies across multiple tables, without increasing the complexity of their validation and reasoning. To illustrate the need for such an extension, consider the following example. Example 7. Consider the report relation r 2 of Fig. 1(b) and course relation r 2 of Fig. 1(c). Suppose that the inconsistency in tuple t 1 of r 2 is fixed by the NFD  X  2 of Example 2. Then each of the relations r 2 and r 2 , when taken separately, seems consistent. However, when r 2 and r 2 are put together, incon sistencies emerge: course C 1 specified by tuple s 1 of r 2 and course C 2 given by tuple s 2 overlap with each other for an hour; this accounts for aconflict when some student takes both courses, which is witnessed by tuples t 3 and t 4 in relation r 2 .
Such a conflict cannot be directly captured by NFDs or CFDs that are defined on a single table. Moreover, it cannot be detected by CINDs [14] although CINDs are defined on two tables. To catch this, one may want to compute the natural join r 2 of r 2 and r 2 on attribute cno and then define an NFD on r 2 .Thisisdoable, but costly: to detect such inconsistencies one has to compute a number of joins. Extended NFDs. This motivates us to extend NFDs across multiple tables, so that we can directly catch data inc onsistencies between these tables.
Consider a relational schema R , which is a collection ( R 1 ,...,R m ) of relation schemas. Let k  X  2 be a predefined natural number (a constant). We define an extended NFD  X  on relational schema R to be a pair of ( T p ,T c ), where (1) T p is a set of k pattern tables defined on k relation schemas of R ;each T p (2) T c is the condition table of  X  with a tuple that is either (a) e op z as before, The semantics of extended NFDs is defined along the same lines as NFDs . Example 8. We define an extended NFDs  X  e across report and course relations: It asserts that for any two courses y 1 and y 2 , (a) if there exists a student x taking both (pattern table T Pr ), and (b) if the two courses are on the same day d (table T Pc ), then they do not overlap (condition T C ). To ensure this, we also use an NFD to assert that for any course tuple s , s [ start ] &lt;s [ end ] (omitted). Validating and reasoning about extended NFDs. Extended NFDs do not increase the complexity of validation and static analyses of data quality rules. Along the same lines as the argument of S ection 4, one can verify the following. Corollary 4: (1) For any extended NFD  X  defined on a relational schema R , there exists an SQL query Q  X  such that for any instance D of R , Q  X  ( D ) finds all violations of  X  in D .(2)Foranyset  X  of extended NFDs on R and instance D of R , vio (  X , D ) can be computed in O ( |  X  ||D| 2 ) time, where |  X  | is the size of  X  .
We should remark that Corollary 4 would no longer hold if one would allow either arbitrary number of pattern tables ( i.e., without the constant bound k ) or unbounded number of tuples in a pattern table in extended NFDs .

Extending the proof of Theorem 2, one can verify the following corollary, in which extended AFDs refer to the subclass of extended NFDs in which the conditions are linear arithmetic expressions e op c for some constant c . Corollary 5: For extended NFDs and for extended AFDs , (1) the satisfiability problem is NP -complete, and (2) the implication problem is coNP -complete. We have proposed NFDs and shown the following. (1) NFDs extend CFDs [7] and are capable of detecting i nconsistencies in numeri c attributes. (2) Despite the increased expressive power, NFDs do not increase the complexity of the satisfiability and implication analyses of data quality rules. (3) Better still, NFDs allow us to detect errors in low ptime by using existing relational DBMS , by means of automatically generated SQL queries. (4) In addition, NFDs (and hence CFDs ) can be extended to catch inconsistencies across different tables, without incurring substantial extra overhead. In light of these, we suggest to use NFDs to detect errors, numeric or not, in a uniform logic framework.
Several topics are targeted for future work. (1) It is known that CFDs are finitely axiomatizable [7]: there exists a finite set of axioms for the implication analysis of CFDs . The finite axiomatizability of NFDs remains to be investi-gated. (2) To make practical use of NFDs , algorithms need to be developed for automatically discovering NFDs from (possibly dirty) data, along the same lines as discovery algorithms for CFDs ( e.g., [8]). (3) To simplify the discussion, we prove Proposition 3 by using a separate SQL query for each NFD in a given set  X  of NFDs (Section 4). It is possible to find a fixed number of SQL queries for error detection, regardl ess of the cardinality of  X  , along the same lines as CFDs [7]. (4) Finally, data repairing algorithms based on NFDs should be in place to fix errors detected by NFDs (see [6] for data repairing based on CFDs ). Acknowledgments . Wenfei Fan is supported in part by NSFC 61133002 , 973 Program 2012CB316200 , Guangdong Innovative Research Team Program 2011D005 and Shenzhen Peacock Program 1105100030834361 , China.

