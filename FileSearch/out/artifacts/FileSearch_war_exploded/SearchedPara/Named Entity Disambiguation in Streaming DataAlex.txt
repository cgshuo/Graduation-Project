 Human language is not exact. For instance, an en-tity 1 may be referred by multiple names (i.e., poly-semy), and also the same name may refer to different entities depending on the surrounding context (i.e., homonymy). The task of named entity disambigua-tion is to identify which names refer to the same en-tity in a textual collection (Sarmento et al., 2009; Yosef et al., 2011; Hoffart et al., 2011). The emer-gence of new communication technologies, such as micro-blog platforms, brought a humongous amount of textual mentions with ambiguous entity names, raising an urgent need for novel disambiguation ap-proaches and algorithms.

In this paper we address the named entity disam-biguation task under a particularly challenging sce-nario. We are given a stream of messages from a micro-blog channel such as Twitter 2 and a list of names n 1 , n 2 , . . . , n N used for mentioning a spe-cific entity e . Our problem is to monitor the stream and predict whether an incoming message contain-ing n i indeed refers to e (positive example) or not (negative example). This scenario brings challenges that must be overcome. First, micro-blog messages are composed of a small amount of words and they are written in informal, sometimes cryptic style. These characteristics make hard the identification of entities and the semantics of their relationships (Liu et al., 2011). Further, the scarcity of text in the mes-sages makes it even harder to properly characterize a common context for the entities. Second, as we need to monitor messages that keep coming at a fast pace, we cannot afford to gather information from external sources on-the-fly. Finally, fresh data coming in the stream introduces new patterns, quickly invalidating static disambiguation models.
We hypothesize that the lack of information in each individual message and from external sources can be compensated by using information obtained from the large and diverse amount of text in a stream of messages taken as a whole, that is, thousands of messages per second coming from distinct sources.
The information embedded in such a stream of messages may be exploited for entity disambigua-tion through the application of supervised learning methods, for instance, with the application of bi-nary classifiers. Such methods, however, suffer from a data acquisition bottleneck, since they are based on training datasets that are built by skilled hu-man annotators who manually inspect the messages. This annotation process is usually lengthy and la-borious, being clearly unfeasible to be adopted in data streaming scenarios. As an alternative to such manual process, a large amount of unlabeled data, augmented with a small amount of (likely) posi-tive examples, can be collected automatically from the message stream (Liu et al., 2003; Denis, 1998; Comit  X  e et al., 1999; Letouzey et al., 2000).
Binary classifiers may be learned from such data by considering unlabeled data as negative examples. This strategy, however, leads to classifiers with poor disambiguation performance, due to a potentially large number of false-negative examples. In this pa-per we propose to refine binary classifiers iteratively, by performing Expectation-Maximization (EM) ap-proaches (Dempster et al., 1977). Basically, a partial classifier is used to evaluate the likelihood of an un-labeled example being a positive example or a nega-tive example, thus automatically and (continuously) creating a labeled training corpus. This process con-tinues iteratively by changing the label of some ex-amples (an operation we call label-transition), so that, after some iterations, the combination of la-bels is expected to converge to the one for which the observed data is most likely. Based on such an approach, we introduce novel disambiguation algo-rithms that differ among themselves on the granu-larity in which the classifier is updated, and on the label-transition operations that are allowed.
An important feature of the proposed approach is that, at each iteration of the EM-process, a new clas-sifier (an improved one) is produced in order to ac-count for the current set of labeled examples. We introduce a novel strategy to maintain the classifiers up-to-date incrementally after each iteration, or even after each label-transition operation. Indeed, we the-oretically show that our classifier needs to be up-dated just partially and we are able to determine ex-actly which parts must be updated, making our dis-ambiguation methods extremely fast.

To evaluate the effectiveness of the proposed al-gorithms, we performed a systematic set of ex-periments using large-scale Twitter data containing messages with ambiguous entity names. In order to validate our claims, disambiguation performance is investigated by varying the proportion of false-negative examples in the unlabeled dataset. Our algorithms are compared against a state-of-the-art technique for named entity disambiguation based on classifiers, providing performance gains ranging from 1% to 20% and being roughly 120 times faster. In the context of databases, traditional entity dis-ambiguation methods rely on similarity functions over attributes associated to the entities (de Car-valho et al., 2012). Obviously, such an approach is unfeasible for the scenario we consider here. Still on databases, Bhattacharya and Getoor (2007) and Dong et. al (2005) propose graph-based dis-ambiguation methods that generate clusters of co-referent entities using known relationships between entities of several types. Methods to disambiguate person names in e-mail (Minkov et al., 2006) and Web pages (Bekkerman and McCallum, 2005; Wan et al., 2005) have employed similar ideas. In e-mails, information taken from the header of the mes-sages leads to establish relationships between users and building a co-reference graph. In Web pages, reference information come naturally from links. Such graph-based approach could hardly be applied to the context we consider, in which the implied re-lationships between entities mentioned in a given micro-blog message are not clearly defined.
In the case of textual corpora, traditional disam-biguation methods represent entity names and their context (Hasegawa et al., 2004) (i.e., words, phrases and other names occurring near them) as weighted vectors (Bagga and Baldwin, 1998; Pedersen et al., 2005). To evaluate whether two names refer to the same entity, these methods compute the similar-ity between these vectors. Clusters of co-referent names are then built based on such similarity mea-sure. Although effective for the tasks considered in these papers, the simplistic BOW-based approaches they adopt are not suitable for cases in which the context is harder to capture due to the small num-ber of terms available or to informal writing style. To address these problems, some authors argue that contextual information may be enriched with knowl-edge from external sources, such as search results and the Wikipedia (Cucerzan, 2007; Bunescu and Pasca, 2006; Han and Zhao, 2009). While such a strategy is feasible in an off-line setting, two prob-lems arise when monitoring streams of micro-blog messages. First, gathering information from exter-nal sources through the Internet can be costly and, second, informal mentions to named entities make it hard to look for related information in such sources.
The disambiguation methods we propose fall into a learning scenario known as PU (positive and un-labeled) learning (Liu et al., 2003; Denis, 1998; Comit  X  e et al., 1999; Letouzey et al., 2000), in which a classifier is built from a set of positive examples plus unlabeled data. Most of the approaches for PU learning, such as the biased-SVM approach (Li and Liu, 2003), are based on extracting negative exam-ples from unlabeled data. We notice that existing ap-proaches for PU learning are not likely to scale given the restrictions imposed by streaming data. Thus, we propose highly incremental approaches, which are able to process large-scale streaming data. Consider a stream of messages from a micro-blog channel such as Twitter and let n 1 , n 2 , . . . , n N be names used for mentioning a specific entity e in these messages. Our problem is to continually moni-tor the stream and predict whether an incoming mes-sage containing n i indeed refers to e or not.
This task may be accomplished through the appli-cation of classification techniques. In this case, we are given an input data set called the training cor-pus (denoted as D ) which consists of examples of the form &lt;e, m, c&gt; , where e is the entity, m is a message containing the entity name (i.e., any n i ), and c  X  { , } is a binary variable that specifies whether or not the entity name in m refers to the desired real-world entity e . The training corpus is used to produce a classifier that relates textual pat-terns (i.e., terms and sets of terms) in m to the value of c . The test set (denoted as T ) consists of a set of records of the form &lt;e, m, ? &gt; , and the classifier is used to indicate which messages in T refer to (or not) the desired entity.

Supervised classifiers, however, are subject to a data acquisition bottleneck, since the creation of a training corpus requires skilled human annotators to manually inspect the messages. The cost associ-ated with this annotation process may render vast amounts of examples unfeasible. In many cases, however, the acquisition of some positive examples is relatively inexpensive. For instance, as we are dealing with messages collected from micro-blog channels, we may exploit profiles (or hashtags) that are known to be strongly associated with the desired entity. Let us consider, as an illustrative example, the profile associated with a company (i.e., @bayer). Although the entity name is ambiguous, the sense of messages that are posted in this profile is biased to-wards the entity as being a company. Clearly, other tricks like this one can be used, but, unfortunately, they do not guarantee the absence of false-positives, and they are not complete since the majority of mes-sages mentioning the entity name may appear out-side its profile. Thus, the collected examples are not totally reliable, and disambiguation performance would be seriously compromised if classifiers were built upon these uncertain examples directly. 3.1 Expectation-Maximization Approach In this paper we hypothesize that it is worthwhile to enhance the reliability of unlabeled examples, provided that this type of data is inexpensive and the enhancement effort will be then rewarded with an improvement in disambiguation performance. Thus, we propose a new approach based on the Expectation-Maximization (EM) algorithm (Demp-ster et al., 1977). We assume two scenarios:  X  the training corpus D is composed of a small set  X  the training corpus D is composed of a small
In both scenarios, unlabeled examples are ini-tially treated as negative ones, so that classifiers can be built from D . Therefore, in both scenarios, D may contain false-negatives. In the second scenario, however, D may also contain false-positives. Definition 3.1: The label-transition operation x  X  turns a negative example x  X  D into a positive one x . The training corpus D becomes { ( D  X  x )  X  x } . Similarly, the label-transition operation x  X  , turns a positive example x  X  D into a negative one x . The training corpus D be-comes { ( D  X  x )  X  x } .

Our Expectation Maximization (EM) methods employ a classifier which assigns to each example x  X  D a probability  X  ( x, ) of being negative. Then, as illustrated in Algorithm 1, label-transition operations are performed, so that, in the end of the process, it is expected that the assigned labels con-verge to the combination for which the data is most likely. In the first scenario only operations x  X  are allowed, while in the second scenario operations x  X  are also allowed. In both cases, a crucial issue that affects the effectiveness of our EM-based meth-ods concerns the decision of whether or not perform-ing the label-transition operation. Typically, a tran-sition threshold  X  min is employed, so that a label-transition operation x  X  is always performed if x is a negative example and  X  ( x, )  X   X  min . Simi-larly, operation x  X  is always performed if x is a positive example and  X  ( x, ) &gt;  X  min .
 Algorithm 1 Expectation-Maximization Approach. Given: Expectation step: Maximization step:
The optimal value for  X  min is not known in ad-vance. Fortunately, data distribution may provide hints about proper values for  X  min . In our ap-proach, instead of using a single value for  X  min , which would be applied to all examples indistinctly, we use a specific  X  x min threshold for each exam-ple x  X  D . Based on such an approach, we in-troduce fine-grained EM-based methods for named entity disambiguation under streaming data. A spe-cific challenge is that the proposed methods perform several transition operations during each EM itera-tion, and each transition operation may invalidate parts of the current classifier, which must be prop-erly updated. We take into consideration two possi-ble update granularities:  X  the classifier is updated after each EM iteration.  X  the classifier is updated after each label-Incremental Classifier: As already discussed, the classifier must be constantly updated during the EM process. In this case, well-established classifiers, such as SVMs (Joachims, 2006), have to be learned entirely from scratch, replicating work by large. Thus, we propose as an alternative the use of Lazy Associative Classifiers (Veloso et al., 2006). Definition 3.2: A classification rule is a specialized association rule {X  X  X  X  c } (Agrawal et al., 1993), where the antecedent X is a set of terms (i.e., a termset), and the consequent c indicates if the pre-diction is positive or negative (i.e., c  X  { , } ). The domain for X is the vocabulary of D . The car-dinality of rule {X  X  c } is given by the number of terms in the antecedent, that is |X| . The support of X is denoted as  X  ( X ) , and is the number of exam-ples in D having X as a subset. The confidence of rule {X  X  c } is denoted as  X  ( X  X  X  X  c ) , and is the conditional probability of c given the termset X , that
In this context, a classifier is denoted as R , and it is composed of a set of rules {X  X  X  X  c } ex-tracted from D . Specifically, R is represented as a pool of entries with the form &lt; key, properties &gt; , where key = {X , c } and properties = {  X  ( X ) ,  X  ( X  X  c ) ,  X  ( X  X  c ) } . Each entry in the pool corresponds to a rule, and the key is used to facilitate fast access to rule properties.

Once the classifier R is extracted from D , rules are collectively used to approximate the likelihood of an arbitrary example being positive ( ) or neg-ative ( ). Basically, R is interpreted as a poll, in which each rule {X  X  c }  X  R is a vote given by X for or . Given an example x , a rule {X  X  c } is only considered a valid vote if it is applicable to x . Definition 3.3: A rule {X  X  c }  X  R is said to be applicable to example x if X  X  x , that is, if all terms in X are present in example x .

We denote as R x the set of rules in R that are ap-plicable to example x . Thus, only and all the rules in R x are considered as valid votes when classifying x . Further, we denote as R c x the subset of R x contain-ing only rules predicting c . Votes in R c x have differ-ent weights, depending on the confidence of the cor-responding rules. Weighted votes for c are averaged, giving the score for c with regard to x (Equation 1). Finally, the likelihood of x being a negative example is given by the normalized score (Equation 2). Training Projection and Demand-Driven Rule Extraction: Demand-driven rule extraction (Veloso et al., 2006) is a recent strategy used to avoid the huge search space for rules, by projecting the train-ing corpus according to the example being pro-cessed. More specifically, rule extraction is delayed until an example x is given for classification. Then, terms in x are used as a filter that configures the training corpus D so that just rules that are appli-cable to x can be extracted. This filtering process produces a projected training corpus, denoted as D x , which contains only terms that are present in x . As shown in (Silva et al., 2011), the number of rules ex-tracted using this strategy grows polynomially with the size of the vocabulary.
 Extending the Classifier Dynamically: With demand-driven rule extraction, the classifier R is ex-tended dynamically as examples are given for clas-sification. Initially R is empty; a subset R x pended to R every time an example x i is processed. Thus, after processing a sequence of m examples { x 1 , x 2 , . . . , x m } , R = {R x 1  X  R x 2  X  . . .  X  R x
Before extracting rule {X  X  c } , it is checked whether this rule is already in R . In this case, while processing an example x , if an entry is found with a key matching {X , c } , then the rule in R is used instead of extracting it from D x . Otherwise, the rule is extracted from D x and then it is inserted into R . Incremental Updates: Entries in R may become invalid when D is modified due to a label-transition operation. Given that D has been modified, the clas-sifier R must be updated properly. We propose to maintain R up-to-date incrementally, so that the up-dated classifier is exactly the same one that would be obtained by re-constructing it from scratch. Lemma 3.1: Operation x  X  (or x  X  ) does not change the value of  X  ( X ) , for any termset X . Proof: The operation x  X  changes only the label associated with x , but not its terms. Thus, the num-ber of examples in D having X as a subset is essen-tially the same as in { ( D  X  x )  X  x . The same holds for operation x  X  .
 Lemma 3.2: Operation x  X  (or x  X  ) changes the value of  X  ( X  X  c ) iff termset X  X  x . Proof: For operation x  X  , if X  X  x , then {X  X  } appears once less in { ( D  X  x )  X  x } than in D . Similarly, {X  X  } appears once more in { ( D  X  x )  X  x } than in D . Clearly, if X 6 X  x , the number of times {X  X  } (and {X  X  } ) appears in { ( D  X  x )  X  x } remains the same as in D . The same holds for operation x  X  .
 Lemma 3.3: Operation x  X  (or x  X  ) changes the value of  X  ( X  X  c ) iff termset X  X  x . Proof: Comes directly from Lemmas 3.1 and 3.2.
From Lemmas 3.1 to 3.3, the number of rules that have to be updated due to a label-transition operation is bounded by the number of possible termsets in x . The following theorem states exactly the rules in R that have to be updated due to a transition operation. Theorem 3.4: All rules in R that must be updated due to x  X  (or x  X  ) are those in R x .
 Proof: From Lemma 3.3, all rules {X  X  X  X  c }  X  R that have to be updated due to operation x  X  (or x  X  ) are those for which X  X  x . By definition, R x contains only and all such rules.

Updating  X  ( X  X  ) and  X  ( X  X  ) is straight-forward. For operation x  X  , it suffices to iterate on R x , incrementing  X  ( X  X  ) and decrementing  X  ( X  X  ) . Similarly, for operation x  X  , it suf-fices to iterate on R x , incrementing  X  ( X  X  ) and decrementing  X  ( X  X  ) . The corresponding values for  X  ( X  X  ) and  X  ( X  X  ) are simply obtained 3.2 Best Entropy Cut Method In this section we propose a method for finding the activation threshold,  X  x min , which is a fundamental step of our Expectation-Maximization approach. Definition 3.4: Let c y  X  { , } be the label asso-ciated with an example y  X  D x . Consider N ( D x ) the number of examples in D x for which c y = . Sim-ilarly, consider N ( D x ) the number of examples in D x for which c y = .
 Entropy Minimization: Our method searches for a threshold  X  x min that provides the best entropy cut in the probability space induced by D x . Specifically, given examples { y 1 , y 2 , . . . , y k } in D x , our method first calculates  X  ( y i , ) for all y i  X  D x . Then, the values for  X  ( y i , ) are sorted in ascending order. In an ideal case, there is a cut  X  x min such that:
However, there are more difficult cases, for which it is not possible to obtain a perfect separation in the probability space. Thus, we propose a more general method to find the best cut in the probability space. The basic idea is that any value for  X  x min induces two partitions over the space of values for  X  ( y i , ) (i.e., one partition with values that are lower than  X  x min , and another partition with values that are higher than  X  min ). Our method sets  X  imizes the average entropy of these two partitions. Once  X  x min is calculated, it can be used to activate a label-transition operation. Next we present the basic definitions in order to detail this method. Definition 3.5: Consider a list of pairs O = { . . . , &lt;c y i ,  X  ( y i , ) &gt; , &lt;c y j ,  X  ( y that  X  ( y i , )  X   X  ( y j , ) . Also, consider f a candi-date value for  X  x min . In this case, O f (  X  ) is a sub-list such that for all pairs in O f (  X  ) ,  X  ( y, )  X  f . Sim-O f (  X  ) and O f ( &gt; ) are partitions of O induced by f .
Our method works as follows. Firstly, it calculates the entropy in O , as shown in Equation 3. Then, it calculates the sum of the entropies in each par-tition induced by f , according to Equation 4. Fi-nally, it sets  X  x min to the value of f that minimizes E ( O )  X  E ( O f ) , as illustrated in Figure 1. 0 . 00 1 . 00 0 . 00 1 . 00 0 . 00 1 . 00 0 . 00 3.3 Disambiguation Algorithms In this section we discuss four algorithms based on our incremental EM approach and following our Best Entropy Cut method. They differ among them-selves on the granularity in which the classifier is up-dated and on the label-transition operations allowed:  X  A1: the classifier is updated incrementally after  X  A2: the classifier is updated incrementally after  X  A3: the classifier is updated incrementally after  X  A4: the classifier is updated incrementally af-In this section we analyze our algorithms using standard measures such as AUC values. For each positive + unlabeled (PU) corpus used in our evalu-ation we randomly selected x % of the positive ex-amples (P) to become unlabeled ones (U). This pro-cedure enables us to control the uncertainty level of the corpus. For each level we have a different TPR-FPR combination, enabling us to draw ROC curves.We repeated this procedure five times, so that five executions were performed for each uncertainty level. Tables 2 X 5 show the average for the five runs. Wilcoxon significance tests were performed ( p&lt; 0.05) and best results, including statistical ties, are shown in bold. 4.1 Baselines and Collections Our baselines include namely SVMs (Joachims, 2006) and Biased SVMs (B-SVM (Liu et al., 2003)). Although the simple SVM algorithm does not adapt itself with unlabeled data, we decided to use it in order to get a sense of the performance achieved by simple baselines (in this case, unlabeled data is simply used as negative examples). The B-SVM al-gorithm uses a soft-margin SVM as the underlying classifier, which is re-constructed from scratch after each EM iteration. B-SVM employs a single tran-sition threshold  X  min for the entire corpus, instead of a different threshold  X  x min for each x  X  D . It is representative of the state-of-the-art for learning classifiers from PU data.
 We employed two different Twitter collections. The first collection, ORGANIZATIONS, is com-posed of 10 corpora 3 (O 1 to O 10 ). Each corpus con-tains messages in English mentioning the name of an organization (Bayer, Renault, among others). All messages were labeled by five annotators. Label means that the message is associated with the orga-nization, whereas label means the opposite.
The other collection, SOCCER TEAMS, contains 6 large-scale PU corpora (ST 1 to ST 6 ), taken from a platform for real time event monitoring (the link to this platform is omitted due to blind review). Each corpus contains messages in Portuguese mentioning the name/mascot of a Brazilian soccer team. Both collections are summarized in Table 1. 4.2 Results All experiments were performed on a Linux PC with an Intel Core 2 Duo 2.20GHz and 4GBytes RAM. Next we discuss the disambiguation performance and the computational efficiency of our algorithms. ORGANIZATIONS Corpora: Table 2 shows av-erage AUC values for each algorithm. Algorithm A4 was the best performer in all cases, suggest-ing the benefits of (i) enabling both types of label-transition operations and (ii) keeping the classifier up-to-date after each label-transition operation. Fur-ther, algorithm A3 performed better than algorithm A2 in most of the cases, indicating the importance of keeping the classifier always up-to-date. On average A1 provides gains of 4% when compared against B-SVM, while A4 provides gains of more than 20%. SOCCER TEAMS Corpora: Table 3 shows aver-age AUC values for each algorithm. Again, algo-rithm A4 was the best performer, providing gains that are up to 13% when compared against the base-line. Also, algorithm A3 performed better than al-gorithm A2, and the effectiveness of Algorithm A1 is similar to the effectiveness of the baseline.
Since the SOCCER TEAMS collection is com-posed of large-scale corpora, in addition to high effectiveness, another important issue to be evalu-ated is computational performance. Table 4 shows the results obtained for the evaluation of our algo-rithms. As it can be seen, algorithm A1 is the fastest one, since it is the simplest one. Even though being slower than algorithm A1, algorithm A4 runs, on av-erage, 120 times faster than B-SVM. ST 1 1,565 2,102 9,172 268,216 ST 2 2,086 2,488 11,284 297,556 ST 3 2,738 3,083 14,917 388,184 ST 4 847 1,199 6,188 139,100 ST 5 1,304 1,604 9,017 192,576
ST 6 1,369 1,658 9,829 196,922 In this paper we have introduced a novel EM ap-proach, which employs a highly incremental un-derlying classifier based on association rules, com-pletely avoiding work replication. Further, two label-transition operations are allowed, enabling the correction of false-negatives and false-positives. We proposed four algorithms based on our EM ap-proach. Our algorithms employ an entropy min-imization method, which finds the best transition threshold for each example in D . All these prop-erties make our algorithms appropriate for named entity disambiguation under streaming data scenar-ios. Our experiments involve Twitter data mention-ing ambiguous named entities. These datasets were obtained from real application scenarios and from platforms currently in operation. We have shown that three of our algorithms achieve significantly higher disambiguation performance when compared against a strong baseline (B-SVM), providing gains ranging from 1% to 20%. Also importantly, for large-scale streaming data, our algorithms are more than 120 times faster than the baseline. This research is supported by InWeb  X  The Brazil-ian National Institute of Science and Technology for the Web (CNPq grant no. 573871/2008-6), by UOL (www.uol.com.br) through its UOL Bolsa Pesquisa program (process number 20110215172500), and by the authors X  individual grants from CAPES, CNPq and Fapemig.
