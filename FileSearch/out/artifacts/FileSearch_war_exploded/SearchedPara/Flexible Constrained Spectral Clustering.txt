 Constrained clustering has been well-studied for algorithms like K -means and hierarchical agglomerative clustering. How-ever, how to encode constraints into spectral clustering re-mains a developing area. In this paper, we propose a exi-ble and generalized framework for constrained spectral clus-tering. In contrast to some previous efforts that implicitly encode Must-Link and Cannot-Link constraints by mod-ifying the graph Laplacian or the resultant eigenspace, we present a more natural and principled formulation, which preserves the original graph Laplacian and explicitly encodes the constraints. Our method offers several practical advan-tages: it can encode the degree of belief (weight) in Must-Link and Cannot-Link constraints; it guarantees to lower-bound how well the given constraints are satisfied using a user-specified threshold; and it can be solved deterministi-cally in polynomial time through generalized eigendecom-position. Furthermore, by inheriting the objective function from spectral clustering and explicitly encoding the con-straints, much of the existing analysis of spectral cluster-ing techniques is still valid. Consequently our work can be posed as a natural extension to unconstrained spectral clus-tering and be interpreted as finding the normalized min-cut of a labeled graph. We validate the effectiveness of our ap-proach by empirical results on real-world data sets, with ap-plications to constrained image segmentation and clustering benchmark data sets with both binary and degree-of-belief constraints.
 H.2.8 [ Database Applications ]: Data Mining Algorithms, Experimentation Spectral clustering, constrained clustering
Constrained clustering is a category of techniques that try to incorporate user supervision (side information) into existing clustering algorithms [2]. The typical form of pair-wise constraints are Must-Link (the pair of points must be assigned into the same cluster, ML for short) and Cannot-Link (the pair of points cannot be assigned into the same cluster, CL for short). These types of constraints have been added into many popular clustering algorithms such as K -means clustering, mixture modeling, hierarchical clustering and density-based clustering [2]. However, constrained spec-tral clustering remains a developing area.

Spectral clustering is an important clustering technique that has been extensively studied in the image processing, data mining, and machine learning communities [13 X 15]. It is considered superior to traditional clustering algorithms like K -means in terms of having deterministic and polynomial-time solution and its equivalence to graph min-cut problems. Its advantage has also been validated by many real-world applications, such as image segmentation [14] and mining social networks [18].

The aim of this paper is to combine spectral clustering and pairwise constraints in a principled and flexible man-ner. Most of the existing techniques on constrained spec-tral clustering can be categorized into two different types, based on how they enforce the constraints. The first type of methods [7,8,11,17,19] directly manipulate the graph Lapla-cian (or equivalently, the affinity matrix) according to the given constraints; then unconstrained spectral clustering is applied on the modified graph Laplacian. The second type of methods use constraints to restrict the feasible solution space. For example, the subspace trick introduced by De Bie et al. [5] alters the resultant eigenspace which the clus-tering assignment vector will be projected onto, based on given constraints. This technique was later extended in [3] to accommodate inconsistent constraints. Yu and Shi [20,21] encoded partial grouping information as a subspace projec-tion. Li et al. [10] enforced constraints via the regularization of the spectral embedding.

The aforementioned approaches have two limitations: 1. They are designed to handle binary ML and CL con-2. They aim to satisfy as many constraints as possible,
In this paper, we go beyond binary ML / CL constraints and propose a more flexible framework to accommodate general-type user supervision. The binary constraints are re-laxed to become a degree of belief (real-valued) that two data instances belong to the same class or two different classes. Moreover, instead of trying to satisfy each and every con-straint that has been given, we use a user-specified threshold to lower-bound how well the given constraints are satisfied. Therefore, our method provides maximum flexibility in terms of both representing constraints and satis-fying them .

Specifically, we formulate constrained spectral clustering as a constrained optimization problem by adding a new con-straint to the original objective function of spectral clus-tering (see Section 3.1). Then we show that our objective function can be converted it into a generalized eigenvalue system, which can by solved deterministically in polynomial time (see Section 3.2). This should be considered as a ma-jor advantage over constrained K -means clustering, which produces non-deterministic solutions while being intractable even for K = 2 [4,6]. Furthermore, our algorithm (see Sec-tion 4) guarantees to find the solution if one exists, which is not the case for many constrained clustering algorithms that are sensitive to the ordering of the constraints (See Fig. 1 in [4] for a concrete example). We validate the effective-ness of our approach on several real-world data sets in Sec-tion 5. The results of image segmentation (see Fig. 3 and 4) show that our method can produce semantically meaningful clustering that conforms to human intuition and expecta-tion. The results of clustering benchmarks (see Fig. 5) show quantitatively that our method can significantly improve the resultant clustering with given constraints.

Our contributions are:
In this paper we follow the standard graph model that is commonly used in the spectral clustering literature. We reiterate some of the definitions and properties in this sec-tion, such as graph Laplacian, normalized min-cut, eigende-composition and so forth, to make this paper self-contained. Readers who are familiar with the materials can skip to our contributions in Section 3. Important notations used throughout the rest of the paper are listed in Table 1.
A collection of N data instances is modeled by an undi-rected, weighted graph G ( V ; E ; A ), where each data instance corresponds to a vertex (node) in V ; E is the edge set and A is the associated affinity matrix. A is symmetric and non-negative. The diagonal matrix D = diag( D 11 ; : : : ; D NN called the degree matrix of graph G , where Then is called the graph Laplacian of G . Assuming G is connected (i.e. any node is reachable from any other node), L has the following properties: Property 1. ( Properties of graph Laplacian [15] ) Let L be the graph Laplacian of a connected graph, then we have: 1. L is symmetric and positive semi-de nite. 2. L has one and only one eigenvalue equal to 0, and N  X  1 3. 1 is an eigenvector of L with eigenvalue 0 ( 1 is a con-
Shi and Malik [14] showed that the eigenvector of L as-sociated with the second smallest eigenvalue 1 solves the normalized min-cut ( N-Cut ) problem of graph G (in a re-laxed sense). The objective function can be written as: where vol( G ) = laxed cluster indicator vector; u T L u is the cost of the cut, which is to minimize; the first constraint u T D u = vol( normalizes the cluster indicator vector u ; the second con-straint D u  X  1 rules out the principal eigenvector of L as a trivial solution, because it does not define a meaningful cut on the graph.

In the rest of paper, for the simplicity of notation, we use an equivalent objective function used in [15]. We substitute u by D  X  1 = 2 v , then Eq.(1) becomes: Here is called the normalized graph Laplacian [15]. Again, Eq.(2) is equivalent to Eq.(1) since v  X  is the optimal solution to Eq.(2) if and only if u  X  = D  X  1 = 2 v  X  is the optimal solution to Eq.(1).

Note that the result of spectral clustering is solely decided by the affinity structure of graph G as encoded in the matrix A (and thus the graph Laplacian L ). We will then describe our extensions on how to incorporate additional supervision so that the result of clustering will reflect both the affinity structure of the graph and the structure of the constraint information.
In this section, we show how to incorporate user super-vision into spectral clustering, whose objective function is shown as in Eq.(2). We encode supervision in such a way that we not only allow binary CL / ML constraints, but also a real-valued degree of belief that two data instances belong to the same cluster or two different ones. We propose a new objective function for constrained spectral clustering, which is formulated as a constrained optimization problem. Then we show how to solve the objective function by converting it into a generalized eigenvalue system. Note that the un-constrained spectral clustering problem can be interpreted as the N-Cut of an unlabeled graph. Similarly, our formu-lation can be interpreted as the N-Cut of a labeled graph.
We encode user supervision with an N  X  N constraint matrix Q . Traditionally, constrained clustering only uses binary constraints: Must-Link and Cannot-Link , which can be naturally encoded as follows: Let u  X  { X  1 ; +1 } N be a cluster indicator vector, where u = +1 if node i belongs to cluster + and u i =  X  1 if node i belongs to cluster  X  , then is a measure of how well the constraints in Q are satisfied by the cluster assignment u : the measure will increase by 1 if Q ij = 1 and node i and j have the same sign in u ; the measure will decrease by 1 if 1) Q ij = 1 but node i and j have different signs in u , or 2) Q ij =  X  1 but node i and j have the same sign in u .

Now to accommodate degree-of-belief constraints, we si-multaneously relax the cluster indicator vector u and the constraint matrix Q such that: Q ij is positive if we believe nodes i and j belong to the same class; Q ij is negative if we believe nodes i and j belong to different classes; the magnitude of Q ij indicates how strong the belief is.

Consequently, u T Q u becomes a real-valued measure of how well the constraints in Q have been satisfied, in the relaxed sense. For example, Q ij &lt; 0 means we believe nodes i and j belong to different classes, then in order to improve u
Q u , we should assign u i and u j with values of different signs; similarly, Q ij &gt; 0 means nodes i and j are believed to belong to the same class, then we should assign u i and u with values of the same sign. The larger u T Q u is, the better the cluster assignment u conforms to the given constraints in Q .

Now given this real-valued measure, rather than trying to satisfy all the constraints given in Q , we can lower-bound this measure with a constant  X  R : By substituting u by D  X  1 = 2 v , above inequality becomes where is the normalized constraint matrix.

We append this lower-bound constraint to the objective function of unconstrained spectral clustering in Eq.(2), and we have:
Problem 1. ( Constrained Spectral Clustering ) Given a normalized graph Laplacian  X  L , a normalized constraint matrix  X  Q and a threshold , we want to optimizes the fol-lowing objective function: arg min Here v T  X  L v is the cost of the cut, which is to minimize; the first constraint v T  X  Q v  X  is to lower-bound how well the constraints in Q are satisfied; the second constraint v T vol( G ) normalizes v ; the third constraint v  X  = D 1 = 2 out the trivial solution D 1 = 2 1 . Suppose v  X  is the optimal solution to Eq.(3), then u  X  = D  X  1 = 2 v  X  is the optimal cluster indicator vector.

It is easy to see that the unconstrained spectral clustering in Eq.(2) can be covered as a special case of our formulation where  X  Q = I and = vol( G ).
To solve a constrained optimization problem, we normally use the Karush-Kuhn-Tucker Theorem [9], which describes the necessary conditions for the optimal solution to the prob-lem. We can derive a set of candidates, which are called feasible solutions , that satisfy all the necessary conditions. Then we can find the optimal solution among the feasible solutions using brute-force method, given the size of the fea-sible set is small.

For our objective function in Eq.(3), we introduce La-grange multipliers as follows:  X ( v ; ; ) = v T  X  L v  X  ( v T  X  Q v  X  )  X  ( v T v  X  vol( Then according to the KKT Theorem, any feasible solution to Eq.(3) must satisfy the following conditions: Note that Eq.(5) comes from taking the derivative of Eq.(4) with respect to v . Also note that we dismiss the constraint v  X  = D 1 = 2 1 at this moment, because it can be checked inde-pendently, after we find the feasible solutions.

To solve Eq.(5)-(8), we start with looking at the com-plementary slackness requirement in Eq.(8), which can be broken down into two mutual-exclusive cases:
Case 1: = 0: In this case, the KKT conditions become: This case is easy to check because the feasible solutions gen-erated in this case are still the eigenvectors of  X  L . All we need to do is to remove the ones that fail to satisfy the constraint v Q v  X  .

Case 2:  X  = 0: In this case, for Eq.(8) to hold v T  X  Q v must be 0. Consequently the KKT conditions become: Unfortunately, under the assumption that is arbitrarily given by user and and are independent variables, Eq.(10-13) cannot be solved explicitly, and it may produce infinite number of feasible solutions, if a solution exists.
Thus we introduce an additional variable, , which is de-fined as the ratio between and . Formally: The introduction of brings two computational benefits: 1. It helps convert our problem into a generalized eigen-2. As we will show below, always lower-bounds . Thus
Now we substitute Eq.(14) into Eq.(10) we obtain: or equivalently: We immediately notice that Eq.(15) is a generalized eigen-value problem once is given.

We denote = v T  X  L v , by left-hand multiplying v T to both sides of Eq.(15) we have Then combining Eq.(11) and (12) we have Now recall that L is positive semi-definite (Property 1), and so is  X  L , which means
Consequently, we have
Recall that is the lower-bound of how well the given constraints are satisfied. And now we show that is a lower-bound of . Therefore, instead of letting user assign the value of explicitly, we let user assign the value of , and the output of algorithm will guarantee v T  X  Q v = &gt; .
In summary, our method works as follows (the exact im-plementation is shown in Algorithm 1): 1. Generating candidates : The user specifies a value 2. Finding the feasible set : Removing generalized eigen-3. Choosing the optimal solution : We combine the
Then in retrospect, we can claim that v  X  is the optimal solution to the objective function in Eq.(3) for as given and = v  X  T  X  Q v  X  .
On one hand, our method described above is guaranteed to generate a finite number of feasible solutions. On the other hand, we need to set appropriately so that the gener-alized eigenvalue system in Eq.(15) combined with the KKT conditions in Eq.(10-13) will give rise to at least one feasible solution. In this section, we discuss such a sufficient condi-tion: where max is the largest eigenvalue of  X  Q .

In this case, the matrix on the right hand side of Eq.(15),  X  Q  X  = vol( G ) I , will have at least one positive eigenvalue. Consequently, the generalized eigenvalue system in Eq.(15) will have at least one positive eigenvalue. Moreover, the number of feasible eigenvectors will increase if we make smaller. For example, if we set &lt; min vol( G ), min the smallest eigenvalue of  X  Q , then  X  Q  X  = vol( G ) I becomes positive definite. Then the generalized eigenvalue system in Eq.(15) will generate N  X  1 feasible eigenvectors (the trivial solution D 1 = 2 1 with eigenvalue 0 is dropped). Figure 1: An illustrative example: the affinity struc-ture says { 1 ; 2 ; 3 } and { 4 ; 5 ; 6 } while the node labeling (coloring) says { 1 ; 2 ; 3 ; 4 } and { 5 ; 6 } .
In practice, we normally choose the value of within the range In that range, the greater is, the more the solution will be biased towards satisfying the constraints in Q . Again, note that whenever we have &lt; max vol( G ), the value of will always be bounded by Therefore we do not need to take care of explicitly.
In practice, the pairwise constraints are often generated from known data labels, i.e. a ML is added when two in-stances have the same label and a CL is added when two instances have different labels. Similarly, the constraint ma-trix Q in our formulation can be conveniently generated from a (partially) labeled data set. Let X be an N  X  K matrix, where X ij is positive if we believe data instance i belongs to class j ; and negative otherwise; the magnitude of X ij dicates the degree of that belief. Then Q can be generated by
Note that our model X  X  capacity of incorporating real-valued constraints makes it possible to better handle multi-labeled data set: if node i and j share two labels whereas node k and l only share one label, then our formulation is able to generate constraints in such a way that node i and j are more strongly advised to be assigned into the same cluster than node k and l are.
Unconstrained spectral clustering can be interpreted as finding the N-Cut of an unlabeled graph. Similarly, our formulation of constrained spectral clustering in Eq.(3) can also be interpreted as finding the N-Cut in a labeled/colored graph.
 Specifically, suppose we have an undirected, weighted graph. The nodes of the graph are colored in such a way that nodes of the same color are advised to be assigned into the same cluster while nodes of different colors are advised to be as-signed into different clusters (e.g. Fig. 1). Let v  X  be the solution to the constrained optimization problem in Eq.(3). We cut the graph into two parts based on the values of the as the cost of the cut (in a relaxed sense), which is to min-imize. On the other hand, can be interpreted as the purity of the cut (also in a relaxed sense), according to the color of the nodes in respective sides. For example, if Q ij is a positive number, then u  X  i and u having the same sign will help increase the purity of the cut, whereas their having different signs will decrease the purity of the cut. It is not difficult to see that the purity can be maximized when there is no pair of nodes with different colors that are assigned to the same side of the cut, which is the case where constraints in Q are completely satisfied.
To illustrate how our approach works, we present a toy example as follows. In Fig. 1, we have a graph associated with the following affinity matrix:
Unconstrained spectral clustering will cut the graph at edge (3 ; 4) and split it into two symmetric parts { 1 ; 2 ; 3 and { 4 ; 5 ; 6 } (Fig. 2(a)). Now we introduce constraints as follows: Q is essentially saying that we want to group nodes { 1 ; 2 ; 3 ; 4 into one cluster and { 5 ; 6 } the other. Although this kind of  X  X ull supervision X  does not make sense in practice, it is used here just to make the result more obvious and intuitive.  X 
Q has two distinct eigenvalues: 0 and 2 : 6667. As an-alyzed above, must be smaller than 2 : 6667  X  vol( G ) to guarantee the existence of a feasible solution, and larger means we want more constraints in Q to be satisfied (in a relaxed sense). Thus we set to vol( G ) and 2vol( G ) respec-tively, and see how the results will be affected by different values of . We solve the generalized eigenvalue system in Eq.(15), and plot the resultant cluster indicator vector u Fig. 2(b) and 2(c). We can see that as increases, node 4 is dragged from the group of nodes { 5 ; 6 } to the group of nodes { 1 ; 2 ; 3 } , which conforms to our expectation that greater value implies higher level of constraint satisfaction.
In this section, we discuss the implementation issues of our method.

The routine of our method is similar to that of uncon-strained spectral clustering. The input of the algorithm is an affinity matrix A , the constraint matrix Q (or alternatively the label matrix X ), and the threshold . Then we solve the generalized eigenvalue problem in Eq.(15) and find all the feasible generalized eigenvectors. The output is the optimal (relaxed) cluster assignment indicator u  X  . The algorithm is summarized in Algorithm 1. Note that it only considers the solutions generated from Case 2 in Section 3.2. Those from Case 1 (the trivial case) can be examined separately. Notice that node 4 is biased toward nodes { 1 ; 2 ; 3 } as increases. Algorithm 1: Constrained Spectral Clustering Input : Affinity matrix A , constraint matrix Q , ;
Output : The optimal (relaxed) cluster indicator u  X  ; 1 vol( G )  X  2  X  3 max  X  the largest eigenvalue of  X  Q ; 4 if  X  max vol ( G ) then 5 return u  X  =  X  ; 6 end 7 else 8 Solve the generalized eigenvalue system in Eq.(15); 9 Remove eigenvectors associated with non-positive 10 v  X   X  arg min v v T L v , where v is among the feasible 11 return u  X   X  D  X  1 = 2 v  X  ; 12 end
Our algorithm can be naturally extended to K -way par-tition for K &gt; 2, following what we usually do for uncon-strained spectral clustering [15]: instead of using the optimal generalized eigenvector u  X  , we preserve top-K generalized eigenvectors corresponding to positive generalized eigenval-ues, and perform K -means algorithm in the eigenspace.
Since our model encodes constraints as a degree of belief, inconsistent constraints in Q will not corrupt our algorithm. Instead, they are enforced implicitly by the effort of improv-ing u T Q u . Note that if the constraint matrix Q is generated from the partial label matrix X , then the constraints in Q will always be consistent.

The runtime of our algorithm is dominated by that of the generalized eigendecomposition. In other words, the complexity of our algorithm is on a par with that of un-constrained spectral clustering in big-O notation, which is O ( kN 2 ), N to be the number of data instances and k to be the number of eigenpairs we need to compute.
In this section, we applied our method on several real-world data sets, with comparison to existing techniques. Our goal is to answer the following questions: 1. Does our method generate semantically meaningful re-2. Does our method produce entirely novel clustering when 3. Does our method outperform unconstrained spectral 4. Can our method effectively utilize degree-of-belief con-
All data sets and source codes (in Matlab) used in the experiments are publicly available. Please contact the first author for further information.
First we validate the effectiveness of our approach in the context of image segmentation. We choose image segmenta-tion as a demonstration for several reasons: 1) it is one of the applications where spectral clustering significantly out-performs other clustering techniques, e.g. K -means; 2) the results of image segmentation can be easily interpreted and evaluated by human; 3) instead of generating random con-straints, we can add in semantically meaningful constraints to see if the results of constrained clustering conform to our expectation.

The images we used were chosen from the Berkeley Seg-mentation Dataset and Benchmark [12]. The original im-ages are 480  X  320 grayscale images in jpeg format. For efficiency consideration, we compressed them to 10% of the original size, which is 48  X  32 pixels, as shown in Fig. 3(a) and 4(a). Then affinity matrix of the image was computed using RBF kernel, based on both the positions and the grayscale values of the pixels. As a baseline, we used unconstrained spectral clustering [14] to generate a 2-segmentation of the image. Then we introduced different sets of constraints to see if they can generate expected segmentation. Note that the results of image segmentation vary with the number of segments. To save us from the complications of parameter tuning, which is related to the contribution of this work, we always set the number of segments to be 2.

The results are shown in Fig. 3 and 4. Note that to visual-ize the resultant segmentation, we reconstructed the image using the entry values in the relaxed cluster indicator vec-tor u  X  . In Fig. 3(b), the unconstrained spectral clustering partitioned the elephant image into two parts: the sky (red (c) Constraint Set 1 (c) Constraint Set 1 pixels) and the two elephants and the ground (blue pixels). This is not satisfying in the sense that it failed to isolate the elephants from the background (the sky and the ground). To correct this, we introduced constraints by labeling two 5  X  5 blocks to be 1 (as bounded by the black rectangles in Fig. 3(c)): one at the upper-right corner of the image (the sky) and the other at the lower-right corner (the ground); we also labeled two 5  X  5 blocks on the heads of the two elephants to be  X  1 (as bounded by the white rectangles in Fig. 3(c)). Then we used Eq.(16) to generate the constraint matrix Q : a ML was added between every pair of pixels with the same label and a CL was added between every pair of pixels with different labels. The parameter was set as: where max is the maximum eigenvalue of  X  Q . In this way, is always between 0 : 5 max vol( G ) and 0 : 9 max vol( G it will gradually increase as the number of constraints in-creases. From Fig. 3(c) we can see that with the help of user supervision, our method successfully isolated the two elephants (blue) from the background, which is the sky and the ground (red). Note that our method achieved this with very simple labeling: four squared blocks.

To show the flexibility of our method, we tried a different set of constraints on the same elephant image with the same parameter settings. This time we aimed to separate the two elephants from each other, which is impossible in the unconstrained case because the two elephants are not only similar in color (grayscale value) but also adjacent in space. Again we used two 5  X  5 blocks (as bounded by the black and white rectangles in Fig. 3(d)), one on the head of the elephant on the left, labeled to be 1, and the other on the body of the elephant on the right, labeled to be  X  1. As shown in Fig. 3(d), our method cut the image into two parts with one elephant on the left (blue) and the other on the right (red), just like what a human user would do.
Similarly, we applied our method on a human face image as shown in Fig. 4(a). The unconstrained spectral cluster-ing failed to isolate the human face from the background (Fig. 4(b)). This is because the tall hat breaks the spatial continuity between the left side of the background and the right side. Then we labeled two 5  X  3 blocks to be in the same class, one on each side of the background. As we in-tended, our method assigned the background of both sides into the same cluster and thus isolated the human face with his tall hat from the background(Fig. 4(c)). Again, this was achieved simply by labeling two blocks in the image, which covered about 3% of all pixels. Alternatively, if we labeled a 5  X  5 block in the hat to be 1, and a 5  X  5 block in the face to be  X  1, the resultant clustering will isolate the hat from the rest of the image (Fig. 4(d)).
Next we evaluated our method ( CSP ) by clustering bench-mark data sets from the UCI Archive [1]. We chose six differ-ent data sets with class label information, namely Hepatitis, Iris, Wine, Glass, Ionosphere and Breast Cancer Wiscon-sin (Diagnostic). We performed 2-way clustering simply by partitioning the optimal cluster indicator according to sign: positive entries to one cluster and negative the other. We removed the setosa class from the Iris data set, which is the class that is known to be well-separately from the other two. For the same reason we removed Class 1 from the Wine data set, which is well-separated from the other two. We also re-moved data instances with missing values. The statistics of the data sets after preprocessing are listed in Table 2.
For each data set, we computed the affinity matrix using the RBF kernel. We randomly generated constraints us-ing the groundtruth label information. For each round we randomly chose a certain percentage of data instances and assumed that their labels are known; then we generated the constraint matrix Q following Eq.(16). Note that when no constraint was generated, the unconstrained spectral clus-tering was performed. The quality of the clustering results was measured by Rand index [16], which tells how similar our clustering is as compared to the groundtruth class labels. The only parameter in our method, , was set according to Eq.(17) throughout the experiments.

We compared our method to two existing techniques. The first one ( ModAff ) is from [8], which modifies the affinity ma-trix directly: when a ML constraint is given, it changes the corresponding entries in A to 1; and 0 for CL con-straint. Then unconstrained spectral clustering is performed on the new graph Laplacian. The second one ( GrBias ) is from [20,21], which encodes partial grouping information as a projection matrix. Note that the GrBias method can only accommodate ML constraints. We also implemented the subspace trick in [5] and the affinity propagation algorithm in [11]. We did not present results from those two techniques because overall they did not perform as well as the two we presented.

We report the Rand index of all methods against the per-centage of known labels (from 0 to 100%, by 10% increment) so that we can see how the quality of clustering varies when more constraints are added in. Note that at each stop, we randomly generate 100 sets of constraints and reported the mean, maximum and minimum Rand index of the 100 ran-dom trials, as shown in Fig. 5. From the results we can tell:
Lastly, we show that our method can effectively incorpo-rate degree-of-belief constraints, which may carry richer in-formation that binary constraints cannot accommodate. To make our case, we encode hierarchical (multiple) labels into degree-of-belief constraints, and see if our method can re-cover the hierarchical structure of the data set (only) based on given constraints. We chose a subset of the 20 Newsgroup data set 1 , as shown in Table 3. We randomly sampled about 350 documents from 6 groups. At the highest level, those groups belong to two topics: computer (comp) and recre-ation (rec). We used these two topics as groundtruth labels when computing Rand index.

To generate binary constraints, we added a ML link be-tween two articles within the same group; CL between two articles from different groups. To generate degree-of-belief constraints, we converted the group titles into multiple la-bels, e.g. rec.sport.baseball became rec, sport, and baseball. Then given two articles, we compared the number of com-mon labels they shared. For example, if those two articles came from the same group, we set the corresponding en-try in Q to +3; if one was from rec.sport.baseball and the other from rec.sport.hockey, we set the corresponding entry to +2; if they did not share any label at all, we set the entry to  X  1 (recall that in our model, 0 does not mean CL but no constraints given).

After the constraints were generated, we performed our method with degree-of-belief ( CSP-DoB ) and binary constraints ( CSP-Binary ), respectively. Our task was to cluster the data set into 6 clusters, and then compute the Rand index with respect to the two-topic groundtruth (comp and rec). As shown in Fig. 6, since the binary constraints only captured the group-level relationship, the top-level class information (comp vs. rec) cannot be recovered by using binary con-straints. As a contrast, the degree-of-belief constraints pre-served the hierarchical structure of the data set. Hence, although the number of clusters were assigned to be 6, our http://people.csail.mit.edu/jrennie/20Newsgroups/ Figure 6: Clustering results on the newsgroup data set, with binary and degree-of-belief constraints. method with degree-of-belief constraints tended to merge the articles into 2 clusters: one corresponding to comp and the other rec. The resultant clustering successfully recov-ered the original hierarchical information, as indicated by the steadily increasing Rand index ( CSP-DoB ) in Fig. 6.
This paper addresses the problem of constrained spec-tral clustering. While constrained K -means clustering has been well-studied, existing techniques on constrained spec-tral clustering are limited because they are primarily focused on Must-Link and Cannot-Link constraints, which could be both insufficient and inflexible in practice. To overcome this, we propose a generalized framework for constrained spectral clustering. Our approach is more flexible in the sense that we can deal with both binary constraints and real-valued degree-of-belief constraints. Our approach is also more principled since it can be considered a natural exten-sion to the original objective function of unconstrained spec-tral clustering, as a cut on a labeled graph. Our objective function is formulated as a constrained optimization prob-lem and can be solved in closed form with polynomial time, through generalized eigenvalue decomposition. Our method introduces a user-specified parameter , which serves as a tradeoff factor between the structure as defined by the orig-inal graph Laplacian and that by the constraint matrix. Empirical results justified the effectiveness of our method. We used image segmentation to demonstrate that our method can produce meaningful and intuitive clustering with vari-ous sets of constraints. We also evaluated our method on benchmark data sets. We showed that our method can im-prove the quality of clustering by taking in both binary and real-valued constraints over unconstrained spectral cluster-ing. We also showed the advantage of our approach over existing techniques.
The authors gratefully acknowledge support of this re-search from the NSF (IIS-0801528) and ONR (N000140910712 P00001). [1] A. Asuncion and D. Newman. UCI machine learning [2] S. Basu, I. Davidson, and K. Wagstaff, editors. [3] T. Coleman, J. Saunderson, and A. Wirth. Spectral [4] I. Davidson and S. S. Ravi. Intractability and [5] T. De Bie, J. A. K. Suykens, and B. De Moor. [6] P. Drineas, A. M. Frieze, R. Kannan, S. Vempala, and [7] X. Ji and W. Xu. Document clustering with prior [8] S. D. Kamvar, D. Klein, and C. D. Manning. Spectral [9] H. Kuhn and A. Tucker. Nonlinear programming. [10] Z. Li, J. Liu, and X. Tang. Constrained clustering via [11] Z. Lu and M.  X  A. Carreira-Perpi  X n  X an. Constrained [12] D. Martin, C. Fowlkes, D. Tal, and J. Malik. A [13] A. Y. Ng, M. I. Jordan, and Y. Weiss. On spectral [14] J. Shi and J. Malik. Normalized cuts and image [15] U. von Luxburg. A tutorial on spectral clustering. [16] K. Wagstaff and C. Cardie. Clustering with [17] F. Wang, C. H. Q. Ding, and T. Li. Integrated KL [18] S. White and P. Smyth. A spectral clustering approach [19] Q. Xu, M. desJardins, and K. Wagstaff. Constrained [20] S. X. Yu and J. Shi. Grouping with bias. In NIPS , [21] S. X. Yu and J. Shi. Segmentation given partial
