 An important feature of information systems is the ability to inform users about changes of the stored information. Therefore, systems have to  X  X now X  what changes a user wants to be informed about. This is well known from the field of publish-/subscribe architec-tures. In this paper, we propose a solution for information system designers of how to extend their information model in a way that the notification mechanism can consider semantic knowledge when determining which parties to inform. Two different kinds of im-plementations are introduced and evaluated: one based on aspect oriented programming (AOP), the other one based on traditional combined approach preserving the advantages of both techniques, using Model Driven Architecture (MDA) to create the triggers from a UML model enhanced with stereotypes.
 H.3.4 [ Information Storage and Retrieval ]: Systems and Soft-ware X  User profiles and alert services ; D.2.11 [ Software Engi-neering ]: Software Architectures X  Domain-specific architectures ; H.4.0 [ Information Systems Applications ]: General Design Aspect oriented programming (AOP), database triggers, knowledge management, notification service, publish-/subscribe
Today X  X  information systems contain such a vast amount of infor-The need for  X  X n ideal system [that] would [...] anticipate questions 1998 [1]. To solve this problem, besides regular search facilities, many systems offer the possibility to monitor changes that are ap-components in a loosely coupled system) about the changes.
Since in most cases simple subscriptions of particular objects are not enough, content based subscription techniques based on filters etc. have already been successfully applied to specify more com-plex subscriptions [2]. However, this approach leaves the decision about  X  X hat to subscribe to X  to the subscriber, although many infor-mation system designers often know about interrelations between entities, which should be considered when the system determines which subscribers to notify about changes. Since these interrela-tions are already known at design time, designers should be able to represent and specify them explicitly in their model.

Our paper proposes a new solution that enriches the model of information systems. The novelty of our proposal lies in the fact that information system designers can specify semantic connec-tions between subscribers and publishers, as well as between dif-ferent subscribable information objects. This extra information can be used by the notification mechanism to better determine which subscribers have to be notified about changes. To achieve this, we introduce three concepts: explicit subscriptions , implicit subscrip-tions and notification-propagating references .

Two different implementations of our concept have been evalu-ated with respect to maintainability as well as scalability and per-formance, showing that an ideal implementation is a combination of both approaches.

The remainder of this paper is organized as follows: in the next chapter, we explain our motivation and the use cases we want to handle. Section 3 describes the formal model our approach is based on and the concepts and algorithm of our approach. In section 4, we describe two different implementation alternatives, which are evaluated with respect to efficency and scalability in section 5. The paper ends with an overview of related work (6) and our conclu-sions that determine which future work has to be done (7).
As an example, consider a small information system for univer-sities, where students, lecturers, courses and learning material can be stored. Fig. 1 shows a simplified model. 1 For instance Lecturer and Student would usually be derived from a common class Person .
In a scenario as described above, a common way of offering monitoring functionality to the user would be a subscription mecha-nism: every user can mark the pieces of information he is interested in, and the system can then use these marks to determine which users to inform any time information is updated. We identify three different ways a user might choose to be informed about changes:
The most obvious use case are users explicitly marking the infor-mation they are interested in. For instance, consider a student who be informed in case the telephone number of the lecturer changes. a mark, indicating he wants to be informed about changes of this entity. Maybe another (very eager) student wants to be informed about everything going on about courses.
A more interesting use case can be identified when users want to be informed about changes without setting any marks at all, but because of semantic reasons. Consider a student who is enrolled in a particular course. Since the system knows about him attending the course, he could expect the mechanism to be smart enough to inform him e.g. about a change of the room the course takes place in.
The most sophisticated use case in our example deals with the learning material. Whenever some uploaded script changes or a new exercise sheet is stored, this means that the course(s) the docu-ment(s) belong(s) to change too. By transitively marking the course to be considered changed as well, everybody who wants to be in-formed about the course (by explicit or implicit subscription) has to be notified.
To deal with all three use cases, we propose an approach built on three different concepts: explicit subscriptions , implicit subscrip-tions and notification-propagating references . Before we introduce these concepts, we formalize our model.
Our formal model is based on two graphs: a  X  X odel-graph X  de-scribing the known set of classes and their associations (as it would be modelled in an UML-diagram) and an  X  X bject-graph X  describing the current extensional data conforming to the model.

Definition 1. (Model Graph) Our model graph G =( C , A ) con-sists of a set of vertices representing the different classes and a class of associative edges Since the edges of our model graph can have different cardinalities, we have
Definition 2. (Object Graph) Our object graph g =( O , R ) con-sists of a set of vertices representing the objects and a set of relation edges describing objects in relation to each other. 2
Since every object in the object graph is of a given class, and every relation between objects is of a certain type of association, we introduce two mapping functions, f oc and f ra :
Definition 3. (Mapping Objects to Classes) The mapping func-tion f oc is defined as if instance o is of type c .

Definition 4. (Mapping Associations to their Types) The map-ping function f ra is defined as if association r is of type a .
In our approach, we deal with the three different use-cases by three different means: explicit subscriptions are used to deal with the  X  X sual X  way of signalling interest in an object X  X  changes, while implicit subscriptions and notification-propagating references can be used by information system designers to put semantic knowl-edge into their information model. This additional knowledge can be used to notify subscribers in an enhanced way.

Definition 5. (Subscribers) Subscribers, as known from [2] etc., are denoted as Since we consider subscribers as first-class objects that are usually also handled by the underlying information system, we assume that Consequently, we denote the class all subscribers belong to with
Subscribers are able to define two different types of subscrip-tions: by subscribing directly to changes of a particular object (de-noted by Sub O ) and by subscribing to changes to any object of a given class c , denoted by Sub C .

Definition 6. (Explicit Subscriptions to Classes and Objects) All known subscriptions to objects are denoted by and subscriptions to any object of a given class c by
We assume the cardinalities of the actual relationships conform to the allowed cardinalities of the model.
Implicit subscriptions can be used by information system design-to certain notifications. Remembering the above use cases, if the designer of such a system wants to express that all enrolled stu-dents should be informed about a course X  X  changes, he can do so defined as follows:
Definition 7. (Implicit Subscriptions) Implicit subscriptions are subscribers. They are denoted by
To be able to manage our third use case, we introduce a con-cept named notification-propagating references . A subset of rela-tionships can be marked as notification-propagating, indicating that upon all other objects related to the changed one by a notification-propagating reference. As we will see later, this relationship will be used to transitively determine all information objects that should be considered changed.

Definition 8. (Notification-Propagating References) Notification-propagating references are a subset of all relationships in our model G between classes. They are denoted by
Our algorithm uses all three concepts to determine which sub-scribers to notify about an update. To explain how the algorithm works, let o changed be the object that has been changed.
At first, we determine all objects that should referentially be con-sidered updated. Therefore, we collect all objects that are transi-tively reachable from o changed via any notification-propagating ref-erence: where x  X   X  prop y means that y is transitively reachable from x via notification-propagating associations r with f ra ( r )  X  Sub next step, all explicit subscribers of these objects (by subscribing to the object itself or by subscribing to the class) are collected: Then, all implicit subscribers are determined:
Finally, the list of all subscribers that have to be notified about o erentially) updated objects:
The following pseudo-code shows the abstract implementation of this algorithm: let O changed := { all objects reachable from o changed via for all o  X  O changed
S toBeNotified : = S toBeNotified  X  X  explicit subscribers of o } ;
S toBeNotified : = S toBeNotified  X  X  implicit subscribers of o } ; end for;
To better explain our approach, we recall our introductory exam-ple and the use cases. According to our definitions, we have the following model graph with and where
Fig. 2 shows the data we use in our example. In our formal model, this object graph can be written as with where and To keep our example short, the three students are the only available subscribers, so Modelling the first use case, we identify one explicit subscription to an object and one explicit subscription to a class If the designer of the information system wants to handle the sec-ond use case, he could simply declare the association  X  X ttends X  as an implicit association 3 : Finally, to solve the problem posed in the third use case, the de-propagating reference:
If we look at the change when the script about DataStructures changes, we get According to our algorithm, we first determine all referential change events, so we mark all objects that are connected to o changed the only notification-propagating reference in our example, usedin . Doing this, we get We have one explicit subscription to ProgrammingBasics by S 1 and one explicit subscription to every instance of Course by S 2, so attendants of DataStructures and of ProgrammingBasics have to be notified, leading to So we finally find out all students have to be informed about the change, i.e.

The implementation contains two main functionalities: deter-mining changes about information objects and computing the sub-scribers to be notified. Two different ways of implementation have been evaluated: the first one is an implementation in Java, listen-through Java methods. The second implementation is a solution us-ing database triggers, manifesting both the determination of changes as well as the algorithm within the triggers. Note that students are subscribers, so this is possible
The sandbox application that has been used for evaluation of the two approaches uses the object-relational mapping technique developer. Although this may lead to a slight degradation of per-real-life applications, so we considered it appropriate to use it in our experiments.
The first implementation we tried was based on AspectJ 5 ,anex-tension to the Eclipse IDE 6 . By using aspects, we were able to eas-ily observe changes of information objects (which themselves are implemented as Java objects mapped by Hibernate). Therefore we define a pointcut  X  X istening X  to any update of our objects: pointcut changes(InfoObject o) : target(o) &amp;&amp; execution (public void InfoObject.update*(...); The advice then simply executes the InfoObject X  X  notifySubscribers -method: after (InfoObject o) returning: changes(o) { o.notifySubscribers(); } notifySubscribers is a simple implementation of our algorithm proposed above, a set based implementation collects all InfoObjects reachable from o via notification-propagating references. Then, all every subscriber to be notified, a notification is stored.
The following excerpt shows our implementation of the abstract class InfoObject : 9 abstract class InfoObject { ... // subclasses have to specify // whom to notify implicitly abstract Collection getImplSubs(); // subclasses also have to specify // which InfoObjects to consider // changed as well abstract Collection getNotPropRefs();
Collection getExplSubs() { } void notifySubscribers() { http://www.hibernate.org http://www.eclipse.org/aspectj/ http://www.eclipse.org
Every update-method delegates the method-call to the corre-methods, since these setters are also used by Hibernate. The appli-cation itself uses the update methods, indicating semantic updates.
The efficient delivery of notifications is not within the focus of this paper.
This code has been simplified; e.g. the detection of cycles and the propagating references have been omitted to improve readability. } ... }
The concrete implementations of Course and LearningMaterial look as follows: class Course extends InfoObject { ...

Collection getImplSubs() { }
Collection getNotPropRefs() { } } class LearningMaterial extends InfoObject { ...

Collection getImplSubs() { }
Collection getNotPropRefs() { } }
A more low-level implementation alternative is directly creating database triggers containing both the detection of changes and the storage of the notifications that have to be delivered (in the body of the trigger). The triggers were implemented using DB2 8.2 Basically, their body consists of different SELECT statements, de-termining the subscribers to be notified, putting them together via UNION and then directly inserting the values into our notification table. The detection of changes is coded using the corresponding  X  X FTER UPDATE ... X  statements. The following simplified exam-ple shows one of the triggers we used for our benchmarks: http://www-306.ibm.com/software/data/db2/
We assume that the relational model guarantees that ids of infor-mation objects are unique, independent of their class.
 CREATE TRIGGER example AFTER UPDATE OF name, ectspoints ON course REFERENCING NEW AS new FOR EACH ROW MODE DB2SQL BEGIN ATOMIC --explicit subscribers
FOR sub_cursor AS (SELECT sub.id DO
INSERT INTO notification (time,
VALUES (CURRENT TIMESTAMP,
END FOR; --implicit subscribers (participants)
FOR sub_cursor AS DO
INSERT INTO notification (time,
VALUES (CURRENT TIMESTAMP, END FOR; END
In order to determine a suitable implementation for use in a large scale unversity information system, we did some performance-and scalability tests.

We built a small Hibernate-based information system prototype similar to the one described in our example. Entities of type stu-dent , course and learning material as well as several random sub-scriptions to objects and classes where created. Forty percent of all available InfoObjects were randomly updated and the correspond-ing notifications where computed. The following parameters were used to specifiy our scenario: P denotes the stored number of per-sons, L the number of learning material entities, C the number of courses, % EO the percentage of persons having an explicit sub-scription to an object and % EC the percentage of persons having an explicit subscription to a class.

Scalability has been tested along two dimensions: the size of the extensional database and the number of subscriptions. For every combination of variables, ten tests have been taken, using their av-erage as the final result.
Table 1 shows the response times (in seconds) when gradually increasing the amount of subscriptions. The size of the extensional database was kept constant at P = 400, L = 32, C = 80.
Table 1: Test results with increasing amount of subscriptions
Figure 3 clearly shows that the trigger-based implementation scales much better with higher subscription rates.
 Figure 3: Chart of test results with increasing amount of sub-scriptions
This result is not surprising: in the aspect-based implementa-tion, every update event results in a computation of all subscribers that have to be notified. For this computation, many fine-granular database lookups (to read the subscriptions as well as to read the information objects) are necessary.

Even with all available caching facilities turned on, the commu-nication overhead of the aspect-based implementation compared to
Table 2 shows the response times (in seconds) when gradually increasing the size of the extensional database. The amount of sub-scriptions was kept constant at % EO = 0 . 08 and % EC = 0 . 02.
As figure 4 shows, the trigger-based implementation is signif-icantly faster than the aspect-oriented implementation, especially with large amounts of extensional data.

Recalling the interpretation of the results in section 5.1, we know that the overhead for database accesses in the aspect-oriented solu-tion leads to a constant factor. Since an enlargment of the exten-sional database also leads to an increase of the number of subscrip-means a quadratic rise of read accesses. As a consequence, the re-sponse times of the two alternatives should also scale quadratically. The results shown in Fig. 4 give evidence to that assumption.
The response times themselves are highly dependant on database setup and hardware. However, the important results are the scala-bility and the relative differences between the two approaches, so the detailed configuration should not be mentioned here. Table 2: Test results with increasing extensional database size
Even if -from a theoretical point of view -both alternatives be-differences of the response times are significant enough to disqual-ify the aspect-oriented solution for production use.
 Figure 4: Chart of test results with increasing extensional database size
The publish-/subscribe-paradigm is commonly used for commu-nication between loosely coupled systems. Considering the classi-fication of Eugster et al. [2], our approach belongs to the class of content-based systems. In the extensible architecture proposed by Filho et al. [3], our enhanced events could be handled between the event input buffer and the event dispatcher , being part of both ob-ject model and event model , as identified by Rosenblum and Wolf [4].

Common publish-/subscribe architectures usually distinguish be-tween publishers, event service and subscribers. A lot of work has been done on efficently distributing notification events, e.g. by ex-tending Pastry/Scribe [5]. Other approaches were implemented in the SIENA [6] and READY [7] systems. Of course, security and encryption during the transfer of notifications have to be consid-ered [8]. A P2P-Approach to event distribution is described in [9], another P2P-based publish-/subscribe architecture has been imple-mented in the Corona collaboration tool [10].

The efficient matching between notifications and subscriptions is also in the focus of many publications [11] [12]. In [13], the authors show how to use composite events allowing subscribers to specify combinations of events they want to subscribe to. Eugster et al. describe a precompiler-based approach, extending Java with several constructs that are able to transparently handle subscriptions and publications [14]. Their so called obvents can be aggregated to express the updated data, but they do not allow any specifications of how to trigger the publication of obvents. Similar to our approach, they allow any Java object to be either subscriber or publisher, or both.

While all these approaches handle the event publication service examined in the field of active databases, where event-condition-action rules are commonly used. The active database survey by active database systems. There are also several approaches to the composite events in XML documents [17].
As demonstrated in our example, the approach proposed in this ity, information system designers are given a powerful way to spec-plify both notification mechanisms and their use for the end-user.
Since the concept itself proved capable of our demands, a ro-bust, scalable and maintainable implementation has to be found. We therefore summarize the advantages and disadvantages of both evaluated approaches:
From the above results, the next step must be to find a way to use triggers for our notification service, while avoiding the error-prone and hardly maintainable step of hand-coding them. We therefore will use an extension of UML to enrich the classes and associations of our model with certain stereotypes, so that designers can spec-in the model. This extension of the UML meta-model will be done using UML Profiles. Figure 5 shows what such an enhanced model could look like.
 Figure 5: Example data model with stereotyped associations
Based on this extended UML model (the knowledge model [15]), triggers in an MDA-like way. With that approach, we will be able to use the performance advantages of the trigger-based implemen-tation whilst avoiding the disadvantages of maintainability.
We would like to thank Manuel K X blb X ck for implementing the two alternatives and running the benchmarks. [1] Bernstein, P.A., Brodie, M.L., Ceri, S., DeWitt, D.J., [2] Eugster, T., Felber, P., Guerraoui, R., Kermarrec, A.M.: The [3] Filho, R.S.S., de Souza, C.R.B., Redmiles, D.F.: The design [4] Rosenblum, D.S., Wolf, A.L.: A design framework for [5] Tam, D., Azimi, R., Jacobsen, H.A.: Building content-based [6] Carzaniga, A., Rosenblum, D., Wolf, A.: Design of a [7] Gruber, R., Krishnamurthy, B., Panagos, E.: The architecture [8] Fiege, L., Zeidler, A., Buchmann, A., Kilian-Kehr, R., M X hl, [9] Terpstra, W.W., Behnel, S., Fiege, L., Zeidler, A., [10] Hall, R.W., Mathur, A., Jahanian, F., Prakash, A., [11] Aguilera, M.K., Strom, R.E., Sturman, D.C., Astley, M., [12] Pereira, J., Fabret, F., Llirbat, F., Shasha, D.: Efficient [13] Pietzuch, P.R., Shand, B.: A framework for object-based [14] Eugster, P.T., Guerraoui, R., Damm, C.H.: On objects and [15] Paton, N.W., D X az, O.: Active database systems. ACM [16] Chakravarthy, S., Mishra, D.: Snoop: An expressive event [17] Bernauer, M., Kappel, G., Kramler, G.: Composite events for
