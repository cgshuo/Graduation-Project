 RM aims at finding out pairs of instances referring to the same entity across different databases. Most existing RM solutions rely on string similarity metrics to measure the similarity between key attribute values of instances and then make decisions according to a predefined similarity threshold [ 1 ]. However, an arbitrary threshold hurts either the matching precision or the recall. attribute values may share some non-key attribute values. Based on the obser-vation, this paper works on employing non-key attributes for RM. We can see that non-key attribute values can help us identify the relationship between two instances from Table 1 and Table 2 . Note that our method is orthodox to the existing RM methods based on key attributes. We mainly pay attention on how to use non-key attributes smartly to improve the precision and recall of RM. root part, such that it can accept matched pairs or decline unmatched pairs as early as possible. Based on this intuition, we describe how to build the PRTree. (1)RootNode: After estimating the sufficiency and necessity of every non-key attribute, we select the one with the maximum sufficiency or necessity as the root node. The root node has three branches, i.e., Matched (Y) , Unmatched (N) and Invalid (Null) . (2) Non-Leaf Node: To select an attribute for a non-leaf node, we estimate the sufficiency and necessity of all remaining attributes under the condition of all its ancestor nodes, and select the one with the maximum conditional sufficiency or necessity as the node. (3) Leaf Node: Every leaf node outputs  X  X atched X  or  X  X nmatched X , showing that the two instances are matched pair or not. 2) NokeaRM Algorithm based on PRTree: We describe the NokeaRM algorithm based on PRTree. Basically, every instance pair ( t, s ) visits the PRTree from the root node and stops when they reach a leaf node.Each time the pair ( t, s ) comes to a node with attribute A k , we check whether the two instances in the pair share the same attribute value in the node. If yes, we go to the  X  X atched X  child node of the node, otherwise the  X  X nmatched X  child node of the node. But if some value under this attribute in the two instances are missing, we go to the  X  X nvalid X  child node.When the pair goes to a leaf node, we will output  X  X atched X  or  X  X nmatched X  according to the property of the leaf node. The confidence of the decision is jointly decided by all the nodes the pair passes by from the root to the current node. We have experimented on two real world data sets and one synthetic data set. We compare the precision and recall of our algorithms including Baseline and PRTree (Nokey) -based methods against a state-of-the-art Pure Key -based RM method. Edit distance is the way we use in all algorithms for estimating string similarity. Besides, we also consider a proper way to combine our PRTree-based method with the key-based method and find out that the best way is to also take the key attribute into the tree. So we also use have a PRTree (Key) -based method for comparison. 3.1 Comparison with Previous Methods AsshowninFigure 1 , we can see that pure key-based method reaches the worst precision and recall than the other methods, while the best performance is reached by Baseline and PRTree method using both key and non-key attributes. The PRTree method without key also has an impressive performance, but without the key attribute we miss some important information for RM. Basically, our method can always improve the precision by nearly 15%, and recall by around 20% on all the three data sets.

