 1. Introduction traces for different instances may overlap in time, as illustrated in Fig. 1 .
For the purpose of process mining, the overlapping of work unknown whether any two events belong to the same process instance or not.
The problem we address in this paper is how to recover the work have at least 2 symbols and at least 2 occurrences in the sequence. written as  X  p 1 n 1 , ... , p k n k  X  , where each p i is a pattern (sequence of symbols) and n the generating process. 1.1. Related work
While there is a host of problems and techniques in the area of sequential pattern mining [5 speci fi c knowledge [18] . There are also approaches that focus on mining speci presented there, addressing a related but different problem, does not seem to help solving ours. seem to be directly transferable. 1.2. Previous work can be used to assign a case id to each event. This greedy algorithm pattern.
 1.3. Practical aim have from a few hundred to a few thousand events, with not more than 10 looking for a partition of the input sequence into a set of up to 5 1.4. Structure of the paper fi 2. Preliminaries basis for the approach developed in subsequent sections. 2.1. Notation and conventions N denotes the natural numbers and N + the positive ones.
 We assume that a sequence has an alphabet  X  with a (relatively small) number of symbols E =| contains only the symbols  X  ( S ) occurring in S . A pattern (over contains p as a subsequence (not necessarily as a substring). ac or else of two DOs of ac and two of ba . We denote these respective facts by S where  X  p 1 n 1 , ... , p k n k  X  denotes the multiset of patterns p their shuf fl e product (all interleavings of the argument patterns). For any sequence S (examples will be given for T = abacbc with | T |=6 and 1. S i with 1  X  i  X  | S | is the symbol at position i in S = S from the end, i.e. S  X  1 denotes the last element, S  X  2 the one before last, etc. 2. S [ i : j ] is the substring S i S i +1 ... S j  X  1 S j sequence  X  . 3. Q  X  S denotes the subsequence partial order. The set of subsequences of S is Subs( S )={ X bac }  X  Subs( T )). Q U S denotes the pre fi x partial order, and the set of pre while abc  X  Pref( T )) sequence S (example: occ ( b , T )={2, 5} and noc ( b , T )=2) 5. An occurrence of a pattern p in S is any subsequence y occurrences of p = abc in T ). When referring to a single pattern p , we use p referring to a set of patterns { p 1 , p 2 , ... , p k } we use p 7. A multiset M over a set S is a function M  X  N S that assigns a number to each element of p 11. A multiset of sets of symbols, usually denoted as  X  p 2.2. The problem and its variants The most general formulation of the sequence partitioning problem is as follows: Problem 2.1 . General Sequence Partitioning, GSP INPUT: a sequence S and a set of patterns P over  X  ( S )
OUTPUT: partitions of S into a minimal number of patterns X specify this set.
 ways, and see if any of such combinations covers the sequence exactly. E.g.: fi as an optimization version of the NP-complete exact set cover problem (ESC) [26] . choose any 2 of the fi rst 3 a 's, any 2 of the fi rst 3 b 's and any 2 of the with length n =| S |, a pattern of length k may have n k k x x restriction leads to the following problem. Problem 2.2 .SP  X  INPUT: a sequence S , patterns P p { p  X   X  ( S ) + j | p |
OUTPUT: partitions of S into a minimal number of patterns X edge-coloring problem (Fact 9.1 in Appendix ), which is possible because SP Problem 2.3 . Sequence Partitioning, SP INPUT: a sequence S
OUTPUT: partitions of S into a minimal number of patterns X (beyond their general format) but have to be mined from the sequence. This limits the
We will approach the above problem by solving a more speci Problem 2.4 . Sequence k-Partitioning, SP[k] INPUT: a sequence S , an integer 0 b k  X  | S |/4
OUTPUT: partitions (if any) of S into k patterns from P where P ={ p 2.3. The main algorithm start with  X  a 1  X  ; at the second position, one would get either ba through the successive positions i of the sequence S is de
S can be covered by DOs of a single pattern p , the following underlined modi pre patterns. Our main Algorithm 2.7 utilizes an optimized version of (2.6) but precedes it by an ef Algorithm 2.7 . MinCover(S:Seq)
Output: all minimal solutions, if any such exists, and  X  otherwise 2: for each k := 1 ... |S|/ 4 do 4: R :=  X  5: for each M  X  Cand do 7: if R  X   X  then return R 8: return  X  yielding the fi nal solutions, is described in Section 5 . 3. The trie  X  the number of DOs of patterns full, since it is the main source of complexity.
 means of the pattern key (e.g., T [ ba ], starting at the root , Example 3.1 . For the sequence S = abbaacbcbcc , the general structure of the trie T is as follows: explained using the following example.

Example 3.2 . (3.1 contd). divided into sublists, e.g. T [ bc ] into [6][8][0  X  1  X  ]. Such a cut of a child list [ Y such that, in the parent list X 1 X 2 ... X k , there is some X 37 choose either b :2 or b :3, but not b :7.
 telling the number of matching earlier occurrences of the preceding symbol. The [2:680 pattern.

Fact 3.3 . Let p = p 1 ... p z be a pattern with all symbols distinct, and let S be a shuf p . Then S  X  X  X   X  p m  X  iff P( S , p ), where the latter is de
In words, an S  X  X  X   X  p 1 m , ... , p z m  X  consists of m DOs of p = p symbol of p precedes the n -th occurrence of the ( i +1)-th symbol of p .
Example 3.4 . For the following two sequences S , R  X  X  X   X  a of its occurrences up to each position in the sequence: have 3 b 's and 2 a 's, so R  X  X  X   X  ab 4  X  . Indeed, noc ( ab , R )=3.
S  X 
Q , satisfying the property P( S , p ). By restricting Q to the subsequence Q may be still violated due to unequal numbers of occurrences of various symbols, i.e., because Q now to  X  exclude  X  from such sequence Q  X  the irrelevant symbol occurrences, namely, those Q noc ( p i , Q  X  [1: k ])  X  noc ( p i +1 , Q  X  [1: k ]). The three b 's does not enter a DO of pattern ab , since there are only two matching a 's before. This each pattern.
 Algorithm 3.5 . BuildTrie(S:Seq)
Output: A trie T with pattern occurrences in S where  X  p  X  T 1: T = new Trie 2: for each 1  X  i  X  |S| do
Algorithm 3.6 below assumes the following attributes at every node P of the trie:  X 
P . symb  X  the symbol stored at the node.  X   X 
P . nrOcc  X  the sum of the N -components, namely, for m =| P . pairs |: P . nrOcc =  X  P . children  X  the set of children nodes.
 symbol a ,to pa and in adding the current symbol occurrence a = S several cases: C (line 5) and the number of occurrences is increased as well (line 4).
Algorithm 3.6 . AddToTrie(a:Symbol, i:int, P:NodeOfTrie) 1: for each C  X  P.children do 2: if C.symb = a then 3: if P is the root of the trie then 4: C.pairs 1 .N = C.pairs 1 .N +1 5: C.pairs 1 .L.append ( i ) 6: else if P.nrOcc N C.nrOcc then 7: if P.pairs  X  1 .L  X  1 b C.pairs  X  1 .L 1 then 8: C.pairs  X  1 .N := C.pairs  X  1 .N +1 9: C.pairs  X  1 .L.append ( i ) 10: else 11: C.pairs.append ([1 : i ]) 12: else 13: C.pairs  X  1 .L.append ( i ) 14: else 15: AddToTrie(a,i,C) 17: P.children := P.children  X  {new node ( a, [1 : i ] ,  X  enter an existing sublist in C , or whether it should start a new sublist.  X  Otherwise, if P . pairs the symbol a , the pair [1: i ], and no children. 3.1. Complexity user about the unusual instance.) given sequence S and alphabet  X  with |  X  |= E , we assume in general E repeating symbols is large as a function of E , nP E  X  X  = patterns at each sequence position, i.e., 4. The candidate solutions solutions are generated and how their number can be limited.
 only admit candidate solutions with Symb( M )=Symb( S )=  X  sequence S with an alphabet  X  ={ a 1 , a 2 , ... , a E } can only admit a candidate solution M = where  X  i , j =1 if pattern p j contains symbol a i , and zero otherwise; n number of occurrences of symbol a i in S . In this system, all known directly from (the trie of) S .
 Example 4.2 . For the sequence S = ababbbccbc with the alphabet to the left, with a possible instantiation and solution shown to the right:
The solution means that p 1 contains the symbols { a , b }, p
M = h ab 2 , bc 3 i M 2 = h ab 2 , cb 3 i M 3 = h ba 2 , bc but also the coef fi cients  X  i , j are unknown. These coef them. 6 Furthermore, even after instantiating the coef fi k N
E or k = E . Seen as a system of linear equations over integers, when k with more equations than unknowns), and when k N E it is underdetermined, admitting in
Enumerating all the 2 kE systems of equations and solving each of them for [ n implemented prototype, we produce systematically all possible solutions to the
A solution to the equation system (4.1) de fi nes the set of symbols that each pattern p
Every permutation of the symbols in p j gives a possible pattern, and a pattern p generated from p noc ( p , S )  X  n j .
 permutations for each p j (lines 3  X  6) and, if a given permutation p has n patterns Y j . Having constructed k sets of patterns, Y 1 combines them into candidate solutions for S (line 9). The condition candidate are different, even if they come from identical sets p Algorithm 2.7 for a smaller value of k .) Algorithm 4.3 . Candidates(S:Seq, k:int) Input: Sequence S (its trie T ) and the number of patterns to consider
Output: the set Cand of multisets M of k patterns, with Symb( M ) = Symb( S ) 1: W := solutions to the equation system (4.1) , each in the form h p n 1 2: Cand :=  X  3: for each p n 1 1 ; ... ; p k n k 4: for each j := 1 ... k do 5: Y j =  X  6: for each permutation p of p j do 7: if noc ( p, S )  X  n j then 8: Y j := Y j  X  { p } 9: Cand := Cand  X  p n 1 1 ; ... ; p n k k 10: return Cand
Example 4.4 . The system of equations for S = ababbbccbc and k =2 patterns, admits the solution:
The permutations of p 1 are { ab , ba } and the permutations of p  X  ab 2 , bc 3  X  , M 2 =  X  ab 2 , cb 3  X  , M 3 =  X  ba 2 , bc 3  X  pattern ba has at most one occurrence, which rules out M 3 {  X  ab 2 , bc 3  X  }. 4.1. Complexity
The length of each pattern, i.e., the size of each set p i
Algorithm 4.3 may iterate E ! times, giving the upper bound k of this algorithm is dominated by the number | W | of solutions to the system (4.1) .
Being a linear system, and assuming it to have more than one solution, it will, in general, have in
Consider the number of solutions to a single equation for a single symbol, i.e., let m = noc ( a where m b | S |. The upper bound on the number of its solutions is given by number of solutions is thus limited by the equation having fewest of them. In short, overestimating taking m =| S |, we obtain the seriously overestimated bound O (| S | But even this overestimate shows the complexity polynomial in the length of the sequence.
We record also the potential number 2 kE of possible instances of the matrix algorithm which becomes thus: increases for longer sequences. Our experiments and the case study presented ahead in Section 7 con 5. Verifying the candidates
Given a candidate solution  X  a multiset M =  X  p 1 n 1 , ... of multisets that are generated from M as we proceed through the sequence S = S Algorithm 5.1 and illustrated in Example 5.3 .
 Algorithm 5.1 . Verify (S:Seq, M:multiset) V ( S,M, 0) = { M }
Ch ( X, a )={( X  X   X  ax 1  X  )  X   X  x 1  X  |ax  X  X  X  x  X  E } Verify ( S,M )= V ( S,M, |S| )
The operation Ch ( M , S i ) may producethe empty set if there is no pattern in M beginningwith S
M ). If this happens, veri fi cation fails and the candidate is not a solution. Veri Fact 5.2 . S  X  X  X  M f  X  X  X   X  V ( S , M ,| S |).
 Example 5.3 . For M =  X  ba 1 , ca 1 , bc 1  X  and the sequence S = bbccaa we obtain: case, it is the only element of the result. The same sequence tested for the candidate M while for M  X  = h bca 2 i : bca 2 fi same resulting multiset, but then the fi rst c can be consumed from c section. 5.1. Complexity multiplicities.

Example 5.4 . The values of | V ( S , M , i )| for the sequence S =5 consumed from several elements in each of the current multisets. Given symbol S several offspring via ( X  X   X  ax 1  X  )  X   X  x 1  X  . While there are suf reaching zero) that the number of possible ways to consume the next symbols diminishes. multiplicities, namely,  X  acb 5 , ac 10 , ab 10 , bc 13 , cb gives more possible multisets than uneven one, as explained below. from Example 5.4 has several solutions with only 3 patterns and case d) shows a veri times lower than in the cases b) and c). now S for the length of the sequence should not cause any confusion, while simplifying notation.
At each sequence position, the number of multisets is limited by the actual candidate M = the number of ordered additive partitions of n i into p i multisets for a given i can be, in principle, combined with all multisets for another j case when all multiplied numbers are equal, i.e., n
We calculate S into the exponentiation by k , obtaining
Although the exponent is worryingly high, we rest satis fi this overestimated value. 5.2. The overall complexity limited size E bb | S |, we obtain also the upper bound on the lengths of patterns, p much lower than the number of patterns in the whole alphabet, K the initial building of the trie, is dominated by the maximum of Candidates ( S , k ) X  Verify ( S , reaching the number K of patterns in an actual solution. Taking Candidates ( S , k )= O ( k X E !  X  2 Eq. (5.5) for Verify , we obtain the upper bound for k = K : sequences. 8 6. Improvements and adaptations 6.1. Forward or backward testing candidates. For example, the fi rst steps in the veri fi cation of the candidate M = generate:
However, we can run the same algorithm backward, with all patterns reversed, i.e., for S which starts M  X   X  c cba 1 ; ba 3 backward, by estimating the number of overlapping pre fi xes and suf 6.2. Checking the same set of patterns only once
For example, the sequence S = abbabbaabbaa was built from and is shown to be a solution, other candidates with the same combination of patterns (such as be veri fi ed. 6.3. Specifying patterns, Problem 2.2 ,SP  X  the candidates generated by Algorithm 4.3 , inserting there an additional test: 6: for each permutation p of p i do 7: if noc ( p , S )  X  n i and Pred ( p ) then 8: ... 6.4. Handling repeating symbols generate also solutions where patterns admit repeating symbols. For any solution M = combinations of patterns p i depending on their multiplicities. For instance, since the pair  X  ... , p n , q n , ...  X  by  X  ... , r n , ...  X  with  X  ... , r m , q n  X  m ...  X  instead of  X  ... p n , q problem instance, so that the formation and the number of trials is better left to the user. kinds of patterns. 6.5. Handling loops pattern. For example, if the process is speci fi ed as a  X  fi pattern p and a substring of p in a solution is an indication of such behavior. 6.6. Handling parallelism interleavings is actually observed in practice. In any case, the interleaving of parallel branches minimal solution. 6.7. Coping with noise instances, which correspond to incomplete pattern occurrences.
 suddenly appear.
 fi of pattern that we fi nd the 3 solutions:  X  abc 3 , ab 1  X 
S  X  , then it can be captured as a regular pattern.
 come up as a solution, the user might be tempted to dismiss ab process. 7. Case study management, with a special focus on the implementation of ITIL solutions. moment it is created to its successful ful fi llment.
 user will resume fi lling in the request details at a later time. A to provide a quotation (i.e. the estimated cost) for the service request. A then closed, and at this point the system records an end event. 7.1. Experiment 1 in the event log. For example, the fi rst 5 events extracted from the system were: at all in the event log.

The 364-symbol sequence obtained was the following:
Running Algorithm 2.7 on this sequence produced the following minimal solutions, which can be interpreted as follows:  X 
Both solutions represent the fact that there are only two variants of behavior in this event log. solutions, is the sequence abcdefgh which corresponds, in Fig. 2 , to the project?  X  Plan Request Tasks  X  Assign Request  X  Perform Request  X  abib interpret these solutions would be  X  abcdefgh 43 , abibcdefgh successfully on this candidate and without ever exceeding 2 multisets.  X  reachedwithoutpriorknowledgeabouttheprocessbynotingthatanysequenceintheform xyzyzy be captured both as  X  xy 1 , zy n  X  and  X  xy 1 , yz n  X  depending on whether xy picks up the or  X  abcdefgh 44 , abibibcdefgh 1  X  as solutions of the sequence. However, Verify does not con  X 
In terms of the business process, this means that there were 45 service requests ful were no direct transitions from Request within project? to Perform Request . 1.000.000 patterns. There was only one solution to the equation system (4.1) : both turned out to be a solution. 13 7.2. Experiment 2 equation system is given, with the factors corresponding, in Algorithm 4.3 ,to| Y (permutations) with a suf fi cient number of DOs in S .
 permutations. 14 Verifying such a number of candidates becomes impractical, even if the veri our equipment) on the sequence above with k =5.
 request. From this investigation we obtained the following candidate with k =8, consistent with those in Eq. (7.1) and support the earlier interpretation of the process. 8. Conclusion preclude any kind of complete search.

The proposed solution has several stages:  X 
First, we build a trie to determine the complete set of patterns occurring in the input sequence occurrences by listing the choices for each symbol but not the choices for the overall pattern.  X  may enter a candidate solution.  X  alphabets (|  X  | b 10) and a small number of patterns ( k search space. This represents a signi fi cant progress for a problem that seemed at with further improvements in the ef fi ciency of the implementation. software application. Two experiments were conducted. In the when looking for solutions with 5 patterns, the number of candidates became exceedingly high. context, allow to analyze non-trivial, real-life data. They offer a promising start and con Acknowledgment Appendix A. Proofs one asking also for the list of patterns and their multiplicites, are also NP-hard.) maximum degree in G , for any graph G :  X  ( G )  X   X   X  ( G )
Proof . We reduce the problem of determining the chromatic index of a graph to this variant of SP
E p
V  X  V , we order V totally and let  X 
F ={ ab j ( a , b )  X  E , a b b } be a set of building blocks representing the edges  X 
P ={ p  X  F + j p has no repeated symbols, its F substrings are ordered lexicographically}.  X  S be the concatenation of all elements of F ordered lexicographically, and S ( G )= SS .
Fact 3.3 . Let p = p 1 ... p z be a pattern with all symbols distinct, and let S be a shuf p . Then S  X  X  X   X  p m  X  iff P( S , p ), where the latter is de
Proof .
M =  X  ba 1 , bc 1 , ca 2  X  and arriving at M  X  =  X  a 1 , c establishing the second one, as stated in the text.

Fact 5.2 . The following statements hold: 1. 2. S  X  X  X  M  X   X  X  X   X  V ( S , M ,| S |)
M \\ M =  X  , so the claim is vacuously true. Proceeding by induction on i ,let M or M  X  = X  X   X  a  X  ,forsome X  X  V ( S , M , i  X  1). Any D since 1a holds for Y by IH and a = S i , so it holds also for D . 1b holds trivially for i =0 and we prove the claim by induction for i
Then any shuf fl eof X covering S [ i +1:| S |] begins with a = S from the appropriate pattern. But such an X  X  ax 1  X  x 1 ,or X 2. If S  X  X  X  M then, on completion, S [| S |+1:| S |]=  X  and, by 1b, are non-empty, this requires M  X  =  X  X  X  , since only then  X   X  X  X   X  X  X  of removing the last member of a multiset, i.e., as the child of M
D  X  M \\ M  X  covers S [1:| S |  X  1] which therefore implies that S
References
