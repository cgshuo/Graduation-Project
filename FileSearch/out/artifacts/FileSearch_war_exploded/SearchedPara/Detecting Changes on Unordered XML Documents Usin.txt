 Several relational approaches have been proposed to detect the changes to XML documents by using relational databases. These approaches store the XML documents in the rela-tional database and issue SQL queries (whenever appropri-ate) to detect the changes. All of these relational-based approaches use the schema-oblivious XML storage strategy for detecting the changes. However, there is growing ev-idence that schema-conscious storage approaches perform significantly better than schema-oblivious approaches as far as XML query processing is concerned. In this paper, we study a relational-based unordered XML change detection technique (called Helios )thatusesa schema-conscious ap-proach (Shared-Inlining) as the underlying storage strategy. Helios is up to 52 times faster than X-Diff [7] for large datasets (more than 1000 nodes). It is also up to 6.7 times faster than Xandy [4]. The result quality of deltas detected by Helios is comparable to the result quality of deltas de-tected by Xandy .
 Categories and Subject Descriptors: H.2.4 [Database Management]: Systems  X  Relational databases .
 General Terms: Algorithms, Design, Experimentation. Keywords: XML, change management, change detection.
Recently, a number of techniques for detecting the changes to XML data has been proposed. XyDiff [2] is a main-memory algorithm for detecting the changes to ordered XML documents. In an ordered XML, both the parent-child re-lationship and the left-to-right order among siblings are im-portant. X-Diff [7] is proposed for computing the changes to unordered XML documents. In an unordered XML, the parent-child relationship is significant, while the left-to-right order among siblings is not important. These algorithms suf-fer from scalability problem as they fail to detect changes to large XML data due to lack of main memory.

In [1, 4], we have addressed this scalability problem by using the relational database system. In this approach, given the old and new versions of an XML document, we store both documents in relational database. Next, we is-sue a set of SQL queries to detect the changes. The rela-tional approach-based XML change detection has potential to gain popularity due to its stability, scalability, and its wide spread usage in the commercial world. However, effi-cient change detection in this approach largely determined by the underlying storage approach. Particularly, there are two major approaches for storing XML documents in a rela-tional database. In schema-conscious approach , a relational schema is created based on the DTD/schema of the XML documents. First, the cardinality of the relationships be-tween the nodes of the XML document is established. In the schema-oblivious approach , a fixed schema used to store XML documents is maintained. The basic idea is to capture the tree structure of an XML document. This approach does not require existence of an XML schema/DTD. Also, num-ber of tables is fixed in the relational schema and does not depend on the structural heterogeneity of XML documents.
Our previous approaches for detecting changes to XML data [1, 4] were all based on the schema-oblivious approaches. This is motivated by the fact that schema-oblivious ap-proaches have the following two advantages. First, ability to handle XML schema changes better as there is no need to change the relational schema. Second, there is no need to modify SQL queries to detect changes even if the structure of XML data changes.

In this paper, we present a novel relational approach for detecting the changes to unordered XML documents called Helios ( sc HE ma-conscious xml -enab L ed change detect IO n S ystem )usinga schema-conscious approach (Shared-Inlining [6] in our case). Our effort is motivated by the fact that a growing body of work suggests that schema-conscious ap-proaches perform better than schema-oblivious approaches as far as XML query processing is concerned [3]. Hence, is it possible to design a schema-conscious XML change detec-tion system that can accurately detect all types of changes yet outperform existing XML change detection approaches? In this paper, we address this issue. Note that the char-acteristics of schema-conscious approach raise certain chal-lenges. For instance, in this approach no special relational schema needs to be designed as it can be generated on the fly based on the DTD of the XML document(s). That is, un-like schema-oblivious approaches, the underlying relational schema is DTD-dependent. Consequently, the challenge is to create a general framework for change detection so that the framework is independent of the structural heterogeneity of various XML documents. In other words, given a specific schema-oblivious approach, our framework should be able to detect all changes accurately independent of the changes to the underlying relational schema due to different structure of XML documents. Note that the framework discussed in this paper is only for XML documents whose schemas do not contain recursive elements.

In our approach, first, we store two versions of XML docu-ments in RDBMS by using Shared-Inlining schema [6] gen-erated based on their DTD. Next, our approach starts to detect the changes in bottom-up fashion. Our approach consists of two phases, namely, the finding the best matching subtrees phase (Phase 1) and the detecting the changes phase (Phase 2). For each phase, the algorithm executes several SQL queries. Note that  X  X param] X  in the SQL queries used in the later discussion will replaced the parameter param de-fined in the algorithm. The detected delta will be stored in several relations in RDBMS. We have implemented the pro-totype of Helios using Java on top of Shared-Inlining [6], a schema-conscious storage strategy for XML documents. We compared Helios to Xandy [4], a published schema-oblivious unordered XML change detection system, and X-Diff [7], a published main memory-based approach. We ob-serve that the overall performance of Helios performs up to 6.7 times faster than Xandy . Also, although X-Diff out-performs Helios for small data sets (less than 1000 nodes), for larger data sets, Helios is up to 52 times faster than X-Diff. X-Diff is unable to detect the changes on XML doc-uments that have more than 5000 nodes due to lack of main memory. The result quality of Helios is comparable to the one of Xandy .
The Finding Best Matching Subtrees phase is important because it facilitates the system in finding minimum delta . In this paper, the minimum delta is defined as a delta that has the least number of changed nodes. Given a DTD as de-picted in Figure 1(a), we generate a Shared-Inlining schema. We extend the schema such that an internal node that has in-degree one and out-degre e one in DTD tree is stored as Boolean attribute. This will enable us to detect the in-serted/deleted of this type of internal nodes. For example, node  X  details  X  in the DTD. The modified schema is depicted in Figure 1(b). Note that we use the XML documents de-picted in Figure 2(a) as our running example.
We first present notations that will be used in the later discussion. Suppose we have a Shared-Inlining schema S generated based on DTD U .Schema S consists of a set of tables R ( S )= { r n 1 ,r n 2 , ..., r n x } ,where n p isthenameof therelation. ThenodesinDTD U are categorized into two types as follows. We now define some other symbols to facilitate exposition. Let L v be a set of leaf nodes in the version v of an XML document. Let v be a leaf node in the version v of an XML document, where v  X  L v . The textual content of v is denoted by value ( v ). A set of internal nodes in the version v of an XML document is denoted as I v ,and i v denotes an internal node in version v of an XML document, where i v  X  I v . The name and level of node n are denoted by name ( n )and level ( n ) respectively. The parent node, child node, and ancestor node of n are denoted as parent ( n ), child ( n ), and ancestor ( n ) respectively.

The bestMatchingFinder algorithm (Figure 3) for find-ing the best matching subtrees from two versions of an XML document consists of three steps: finding matching leaf nodes , finding best matching internal nodes ,and collecting best match-ing internal nodes .
The objective of this step is to determine the matching leaf nodes . Informally, the matching leaf nodes are ones that have the same node name, node level, and value. For-mally, the matching leaf nodes are defined as follows. Let x and 2 y be two leaf nodes in the first and second versions of an XML tree respectively. Then, 1 x and 2 y are match-ing leaf nodes (denoted as 1 x  X  2 y )if name ( 1 x )= name ( 2 y ), level ( 1 x )= level ( 2 y ), and value ( 1 Note that we only match the non-inlined leaf nodes in this step. The inlined leaf nodes will be matched when we match internal nodes (Step 2). Consider two versions of an XML document stored in RDBMS as depicted in Figure 2(b). There is only one non-inlined leaf node, namely, info node stored in the Info table. Let n ( p,q ) be a leaf node n stored in the r n table with doc id = p and id = q . There are four match-ing leaf nodes, namely, inf o (1 , 2)  X  inf o (2 , 7) , inf o
Instead of storing the matching leaf nodes directly, we group them according to their parent nodes and store these matching groups in a temporary table in order to reduce storage space requirement. Let G (1 ,pid 1 ) = { 1 1 , 1 2 leaf nodes in the first and second versions of an XML doc-ument respectively, where  X  1 p  X  G 1 have the parent node id pid 1 ,and  X  2 p  X  G 2 havetheparentnodeid pid 2 .Then G G picted in Figure 2(b). Let G ( v,w ) be a matching group in which there is a set of leaf nodes with parent node id w in the version v . We have three matching groups, namely, G
After grouping the matching leaf nodes, we need to mea-sure how similar the matching groups are by calculating their similarity scores .The similarity score of two match-ing groups G 1 and G 2 is defined as follows: ( G 1 ,G 2 )= in G 1 and G 2 ,and | G 1  X  G 2 | is the number of matching leaf nodes in G 1 and G 2 . The value of similarity score is be-tween 0 and 1. If two matching groups have no matching leaf nodes, then their similarity score is 0. The similarity score of two matching groups is equal to 1 if they are identical. For example, the similarity score of G (1 , 1) and G (2 , Given two versions of an XML document shredded in RDBMS, we use three SQL queries encapsulated in the find-MatchingLeafNodes algorithm to find matching groups . The first SQL query is depicted in Figure 4(a). This query is used to find the matching leaf nodes (line 12) and group them into matching groups (lines 13-14). This SQL query is also used to calculate the number of matching leaf nodes in the match-ing groups (line 6). Figure 4(b) depicts the SQL query that is used to calculate total number of leaf nodes in the match-ing groups. The third SQL query that is used to calculate the similarity scores of the matching groups is depicted in Figure 4(c). Given the Info table depicted in Figure 2(b), the findMatchingLeafNodes algorithm results the M Info table that stores the matching groups. The M Info table is the instance of the tempTb1 table as depicted in Figures 6(a) and (b).
The objective of this step is to determine best matching non-inlined internal nodes between two XML documents. Lines 5-14 in Figure 3 are used to find best matching internal nodes . The algorithm works as follows. First, the algorithm determines the highest level of the internal nodes in DTD U . Then, the algorithm starts to find best matching internal nodes in bottom-up fashion. There are two sub steps as follows. First, finding matching internal nodes (line 11). Second, determining best matching subtrees (line 12). Finding matching internal nodes . Informally, two inter-nal nodes are matching internal nodes if they have at least one matching leaf nodes that are their descendants. Let i and i 2 be two internal nodes from the old and new ver-sions of an XML document respectively. Then, i 1 and i 2 are matching internal nodes (denoted by i 1 i 2 )ifthefol-lowing conditions are satisfied: 1) name ( i 1 )= name ( i level ( i 1 )= level ( i 2 ), and 3)  X  1 x  X  2 y such that where i 1 = ancestor ( 1 x )and i 2 = ancestor ( 2 y ). For each non-inlined internal node d x ,the bestMatching-Finder algorithm invokes the findMatchingInternalNodes al-gorithm. The findMatchingInternalNodes algorithm shall execute the SQL query as depicted in Figure 4(d). This SQL query is used to find matching internal nodes from the temporary matching relations of the child nodes of the input node. Lines 14-15 are used to ensure that the parent-child relationship between the matching nodes and the internal nodes that are going to be matched. The result will be grouped by their parent nodes (lines 22-23). Lines 16-21 are used to avoid duplicate matching internal nodes. The result of the SQL query in Figure 4(d) is stored in a tempo-rary matching table M d x that is the instance of the tempTb2 table as depicted in Figures 6(a) and (b).
 If node d x has inlined child leaf nodes, then the find-MatchingInternalNodes algorithm also executes the SQL query depicted in Figure 4(e). Before executing the SQL query, the algorithm prepares one more parameter, namely, moreConditions that is used to replace a part of the SQL query. Formally, the value of moreConditions is as follows. Suppose we have two internal nodes i 1 and i 2 from the old and new versions of XML documents respectively. Nodes i 1 and i 2 are matching internal nodes ( i 1 i 2 )if  X  a 1 z that value ( a 1 z )= value ( a 2 z ), where a 1 z = child ( i child ( i 2 ), and attribute ( a 1 z )= attribute ( a 2 z given the  X  Item  X  table, the value of parameter moreCondi-tions is equal to  X  (A1.PName = A2.PName OR A1.Category = A2.Category OR A1.Price = A2.Price)  X . The result of the SQL query in Figure 4(e) is also stored in a temporary matching table M d x .
 Determining the best matching internal nodes .The best matching internal nodes are formally defined as follows. Let i  X  I 1 be an internal node in the old version of an XML document. Let Z  X  I 2 be a set of internal nodes in new version, where  X  z p  X  Z such that i z p . i and z q are best matching internal nodes (denoted by i z q )iff ( ( i, z q ) &gt; ( i, z p ))  X  0 &lt;p  X | Z | and q = p . For example, in the M Item tablewenoticethat item (1 , 2) can be matched to item (2 , 1) and item (2 , 2) . The similarity score of matching catalog nodes ( catalog (1 , 1) catalog (2 , 2) ) will be maximized That is, ( catalog (1 , 1) , catalog (2 , 2) ) will be  X 0.636 X . Other-wise, ( catalog (1 , 1) , catalog (2 , 2) ) will be  X 0.364 X . Therefore, the task in this step is to find best matching configurations that facilitate us to find best matching internal nodes.
The problem of finding best matching configuration is sim-ilar to the problem of finding maximum weighted bipartite matching . Hence, we are able to solve the problem of find-ing best matching configuration by using the algorithm for finding maximum weighted bipartite matching. In our im-plementation, we use the Hungarian method [5]. Note that we need to update the values of the attributes Counter , To-tal ,and Score accordingly as initially their values are equal to  X 0 X . Intuitively, the value of attribute Counter is equal to ( p + q z ), where p is the number of matching non-inlined leaf nodes, and q z is the number of matching inlined leaf nodes retrieved from the temporary matching table. The value of attribute Total is equal to (2 k + l z ), where k is the total number of non-inlined leaf nodes, and l z the total number of inlined leaf nodes retrieved from the temporary matching table. The SQL query for updating the Score at-tribute is same as the one depicted in Figure 4(c).
The result of the previous step is the best matching inter-nal nodes stored in several relations. The objectives of this step are to merge/collect the best matching internal nodes from different relations and to determine the best matching inlined internal nodes. Lines 15-25 in Figure 3 depict the algorithm. The intuition behind this algorithm is to collect best matching internal nodes in top-down fashion, starting from the root nodes to the highest level of matching internal nodes. To retrieve the best matching internal nodes in each level, the algorithm invokes the retriveMatching algorithm (line 24).

Givenaninternalnode x as the input, the retriveMatch-ing algorithm works as follows. First, the algorithm checks whether node x is a root node, an inlined internal node, or a non-inlined internal node. If node x is a root node, then the algorithm executes the SQL query depicted in Fig-ure 4(f). If node x is a non-inlined internal node, then the algorithm executes the SQL query depicted in Figure 4(g). The intuition behind the SQL query in Figure 4(g) is to find best matching node x in the M x table whose parent nodes are best matching node in the Matching table. If node x is an inlined internal node, the algorithm executes the SQL query depicted in Figure 4(h). Given the temporary match-ing tables (Figures 5(b)-(c)) and the XML documents stored in RDBMS (Figure 2(a)), the retriveMatching algorithm re-sults the Matching table as depicted in Figure 5(d). The semantics of the Matching table is depicted in Figures 6(a) and (b). The Matching table keeps the best matching inter-nal nodes of two XML documents that will be used as the facilitator in detecting the changes (Phase 2).
In section, we discuss how the changes are detected after the best matching subtrees are determined. The changes-Detector algorithm for detecting these types of changes is depicted in Figure 6(c).
Intuitively, the inserted internal node is an internal nodes that is only available in the new version of XML documents. Similarly, the deleted internal node is an internal nodes that is only available in the old version of XML documents. This implies that the inserted and deleted internal nodes must not be best matching internal nodes as best matching internal nodes are available in both versions. The inserted/deleted non-inlined and inlined internal nodes are detected by using the changesDetector algorithm (Figure 6(c), lines 5-9 and lines 10-16 respectively).
 Non-inlined Internal Nodes .Foreach non-inlined inter-nal node d in DTD U ,the changesDetector algorithm de-fines two parameters (line 6), and invokes the detectInserted-InternalNodes (line 7) and detectDeletedInternalNodes func-tions (line 8) for detecting inserted and deleted non-inlined internal nodes respectively. The detectInsertedInternalN-odes function executes SQL query as depicted in Figure 7(a). Lines 7-12 are used to ensure that the inserted internal nodes are not best matching internal nodes. The detectInsertedIn-ternalNodes function returns inserted internal nodes stored in the INS INT table. For example, given the Item table (Fig-ure 2(b)) and the Matching table (Figure 5(d)), the first row of INS INT table depicted in Figure 5(e) is the result of the detectInsertedInternalNodes function.

The detectDeletedInternalNodes function executes a mod-ified SQL query of the SQL query depicted in Figure 7(a). The INS INT in line 1 is replaced by DEL INT .The X  doc id2  X  (line 6) and  X  ID2  X  (lines 7 and 12) are replaced by  X  doc id1  X  and  X  ID1  X  respectively. The detectDeletedInternalNodes function returns deleted internal nodes stored in the DEL INT table. For example, given the Item table (Figure 2(b)) and the Matching table (Figure 5(d)), the first row of DEL INT table depicted in Figure 5(f) is the result of the detectDelete-dInternalNodes function.
 Inlined Internal Nodes .Foreach non-inlined internal node b in DTD U ,the changesDetector algorithm defines four parameters (lines 11-13). Next, the algorithm invokes the detectInsertedInternalNodes (line 14) and detectDeleted-InternalNodes functions (line 15) for detecting inserted and deleted inlined internal nodes respectively.
 The detectInsertedInternalNodes function executes the SQL queries as depicted in Figures 7(b) and (c). The SQL query in Figure 7(b) is used to detect inserted inlined in-ternal nodes whose parent nodes are best matching internal nodes. Lines 9-10 are used to ensure that the inserted in-lined internal nodes are only available in the new version. Lines 11-17 are used to ensure that the parent nodes of the inserted inlined internal nodes are best matching internal nodes. The SQL query depicted in Figure 7(c) is used to de-tect inserted inlined internal nodes whose parent nodes are inserted internal nodes. Line 10 is used to ensure that the parent nodes are inserted internal nodes. Given the Item table (Figure 2(b)) and the Matching table (Figure 5(d)), the second row of the INS INT table depicted in Figure 5(e) is the result of the detectInsertedInternalNodes function. To detect the deleted inlined internal nodes the detect-DeletedInternalNodes function shall also execute two SQL queries derived from the SQL queries depicted in Figures 7(b) and (c). The  X  INS INT  X  in line 1 (Figures 7(b) and (c)) is replaced by  X  DEL INT  X . The SQL query depicted in Fig-ure 7(b) is modified as follows. The  X  I2  X  (line 3),  X  IS NULL  X  (line 9), and  X  IS NOT NULL  X  (line 10) are replaced by  X  I1  X ,  X  IS NOT NULL  X , and  X  IS NULL  X  respectively. We modify the SQL query depicted in Figure 7(c) as follows. The  X  INS INT  X  (line 5) and  X  doc id2  X  (line 11) are replaced by  X  DEL INT  X  and  X  doc id1  X  respectively. For example, given the Item ta-ble (Figure 2(b)) and the Matching table (Figure 5(d)), the secondrowofthe DEL INT table depicted in Figure 5(f) is the result of the detectDeletedInternalNodes function.
Intuitively, the inserted leaf node is a leaf node that is only available in the new version of XML documents. We observe that the new leaf nodes should be either in the best matching subtrees or in the inserted subtrees . Similarly, the deleted leaf node is a leaf node that is only available in the old version of XML documents and should also be either in the best match-ing subtrees or in the deleted subtrees . If an inserted/deleted leaf node is in a best matching subtree, then the parent node of this leaf node must be a best matching internal node. If an inserted leaf node is in a newly inserted subtree, then the parent node of this leaf node must be an inserted internal node. If a deleted leaf node is in a deleted subtree, then theparentnodeofthisleafnodemustbeadeletedinter-nal node. The inserted/deleted non-inlined and inlined leaf nodes are detected by using the changesDetector algorithm (Figure 6(c)) in lines 17-24 and lines 25-32 respectively. Inlined Leaf Nodes .Foreach inlined leaf node a in DTD U ,the changesDetector algorithm defines four parameters (lines 18-20). Next, the algorithm invokes the detectInsert-edLeafNodes (line 21) and detectDeletedLeafNodes functions (line 22) for detecting inserted and deleted inlined internal nodes respectively. Note that line 23 is used to detect up-dated leaf nodes that will be discussed in the later section.
The detectInsertedLeafNodes function executes two SQL queries as depicted in Figures 7(d) and (e). Figure 7(d) is used to detect inserted inlined leaf nodes that are in the best matching subtrees. Lines 10-11 are used to ensure that inserted leaf nodes are only available in the new version. Lines 12-17 are used to guarantee that the parent nodes of inserted leaf nodes are best matching internal nodes. To detect inserted inlined leaf nodes that are in the newly in-serted subtree we use SQL query depicted in Figure 7(e). Lines 12-13 are used to indicate that inserted leaf nodes must be only available in the new version. Lines 10-11 are used to make sure that the parent nodes are inserted in-ternal nodes. Given the Item table (Figure 2(b)) and the Matching table (Figure 5(d)), the tuples marked by  X # X  in the INS LEAF table depicted in Figure 5(g) are the result of the detectInsertedLeafNodes function.

The detectDeletedLeafNodes function executes two modi-fied SQL queries of the SQL queries depicted in Figures 7(d) and (e). The  X  INS LEAF  X  in line 1 (Figures 7(d) and (e)) is replaced by the  X  DEL LEAF  X . The SQL query in Fig-ure 7(d) is modified as follows. The  X  I2  X  in lines 3 and 5isreplacedby X  I1  X . The  X  IS NULL  X  (line 10) and  X  IS NOT NULL  X  (line 11) are replaced by  X  IS NOT NULL  X  X nd  X  IS NULL  X  respectively. The SQL query in Figure 7(e) is modified as follows. The  X  INS INT  X  (line 7) and  X  doc id2  X  (line 12) are replaced by  X  DEL INT  X  X nd X  doc id1  X  X espec-tively. Given the Item table (Figure 2(b)) and the Matching table (Figure 5(d)), the tuples marked by  X # X  in the DEL LEAF table in Figure 5(h) are the result of the detect-DeletedLeafNodes function.
 Non-inlined Leaf Nodes .Foreach non-inlined leaf node c in DTD U ,the changesDetector algorithm defines three parameters (lines 26-27). Next, the changesDetector algo-rithm invokes the detectInsertedLeafNodes (line 29) and de-tectDeletedLeafNodes functions (line 29) for detecting the in-serted and deleted non-inlined leaf nodes respectively. Note that line 30 (Figure 6(c)) is used to detect the updated leaf nodes that will be discussed in the later section. The detectInsertedLeafNodes function shall execute the SQL queries as depicted in Figures 7(f) and (g). Figure 7(f) is used to detect inserted non-inlined leaf nodes that are in the best matching subtrees. Lines 5-8 and lines 10-13 are used to find the non-inlined leaf nodes that are in the new and old versions respectively. Operator  X  EXCEPT ALL  X  in line 9 is used to find non-inlined leaf nodes that are only available in the new version. Figure 7(g) is used to detect inserted non-inlined leaf nodes that are in the deleted sub-trees. Lines 12-13 are used to guarantee that the parent nodes of the leaf nodes are inserted internal nodes. Given the Info table (Figure 2(b)) and the Matching table (Fig-ure 5(d)), the tuples in the INS LEAF table depicted in Fig-ure 5(g) that are not marked with  X # X  are the result of the detectInsertedLeafNodes function.

The detectDeletedLeafNodes function executes the SQL queries as depicted in Figures 7(f) and (g) after slightly modifications. The  X  INS LEAF  X  in line 1 (Figures 7(f) and (g)) is replaced by the  X  DEL LEAF  X . The  X  doc id2  X  in lines 7 and 14 (Figure 7(f)) and line 9 (Figure 7(g)) is replaced by  X  doc id1  X . We replace the  X  doc id1  X  X nline12(Figure7(f)) with  X  doc id2  X . The  X  PID2  X  in lines 7 and 14 (Figure 7(f)) is replaced by  X  PID1  X . We replace the  X  PID1  X  in line 12 (Fig-ure 7(f)) with  X  PID2  X . Given the Info table (Figure 2(b)) and the Matching table (Figure 5(d)), the tuples in the DEL LEAF table depicted in Figure 5(h) that are not marked with  X # X  are the result of the detectDeletedLeafNodes func-tion. The detectInsertedLeafNodes and detectDeletedLeafN-odes functions return the updated non-inlined leaf nodes as these updated leaf nodes can be decomposed into pairs of deleted and inserted leaf nodes. The highlighted tuples in Figures 5(g) and (h) are the updated non-inlined leaf nodes detected as inserted and deleted leaf nodes respectively.
Intuitively, the updated leaf nodes are the leaf nodes that are available in both versions and have the same node names, but have different values. In addition to this, the parent nodes of the updated leaf nodes must be the best matching internal nodes. In the changesDetector algorithm, the up-dated leaf nodes are detected after the inserted and deleted leaf nodes are detected.
 Inlined Leaf Nodes .The detectUpdatedLeafNodes func-tion executes the SQL query as depicted in Figure 8(a). Lines 10-12 are used to ensure that the updated leaf nodes are available in both versions (lines 10-11) and they have different values (line 12). For example, given the Item table (Figure 2(b)) and the Matching table (Figure 5(d)), the de-tectUpdatedLeafNodes function shall result the first tuple of the UPD LEAF table as depicted in Figure 5(i).
 Non-inlined Leaf Nodes .The detectUpdatedLeafNodes function shall execute the SQL query depicted in Figure 8(b). We notice that we join three tables, namely, the DEL LEAF , INS LEAF ,and Matching tables. This is because the up-dated non-inlined leaf nodes are already decomposed into pairs of deleted and inserted non-inlined leaf nodes stored in DEL LEAF and INS LEAF respectively. Line 13 is used to guarantee that the parent nodes of the deleted and inserted leaf nodes are the best matching internal nodes. The up-dated leaf nodes must have the same node name, but differ-ent values (line 14).

We observed that the detectUpdatedLeafNodes function for detecting updated non-inlined leaf nodes may return incor-rect results in some conditions as follows. First, there are more than one updated non-inlined leaf nodes under the same parent nodes. Second, there are deletion/insertion and update of non-inlined leaf nodes occurred under the same parent nodes. In our example, we have node with value  X  Extra 1 year warranty  X  deleted and node with value  X  Se-ries 170S6FG  X  updated. These nodes are under the same parent node. The SQL query depicted in Figure 8(b) re-turns the last two rows of the UPD LEAF table as depicted in Figure 5(i). Therefore, we use the refineUpdatedLeafNodes function to correct the result of the detectUpdatedLeafNodes function. The refineUpdatedLeafNodes algorithm is similar to the one in [4].
 For example, given the DEL LEAF table (Figure 5(h)), the INS LEAF table (Figure 5(g)), and the Matching table (Fig-ure 5(d)), the detectUpdatedLeafNodes function shall result the UPD LEAF table as depicted in Figure 5(i) (the last two tuples). After the changesDetector algorithm invokes re-fineUpdatedLeafNodes function, the highlighted row of the UPD LEAF table as depicted in Figure 5(i) is deleted.
Helios has been implemented entirely in Java. The im-plementation and the database engine were run on a MS Windows 2000 Professional machine having Pentium 4 1.7 GHz processor with 512 MB of memory. The database sys-tem was IBM DB2 UDB 8.1. Appropriate indexes on the relations are created. We used a set of synthetic XML data based on SIGMOD DTD ( http://www.sigmod.org/record/ )and University DTD (Figure 8(e)). The characteristics of the datasets are depicted in Figures 8(c) and (d). We generated the second version of each XML document by using our own change generator. We distributed the percentage changes equally for each type of changes. We compare Helios with Xandy [4] and X-Diff [7] ( http://www.cs.wisc.edu/  X  yuanwang/ xdiff.html ).
 Execution Time vs File Size Figure 9(a) depicts the com-parison of the execution time of Helios , Xandy ,andX-Diff for different file size while we fix the number of nodes to 890 nodes and the percentage of changes to 3%. The perfor-mances of Helios , Xandy , and X-Diff are slightly affected by the increments of the file size.
 Execution Time vs Number of Nodes .Inthissetof experiments, we study the performance of all approaches for different number of nodes. The percentage of changes is set to  X 3% X  and  X 9% X . The threshold  X  is set to  X 0.0 X  which shall give us the upper bound of the execution time. Sigmod Data Sets . Figure 9(c) depicts the comparison of the execution time of Xandy and Helios for the first phase (3% changes). Helios is 3 times faster than Xandy in average. Figure 9(d) depicts the comparison of the exe-cution time of different approaches for the change detection phase (3% changes). Helios performs better than Xandy except for the smallest data set. Helios is 60 times faster than Xandy in average. We notice that the difference of execution time between Helios and Xandy increases as the number of nodes increases. Figures 9(e) and (f) depict the overall performance of each approach when the percentage of change is set to 3% and 9% respectively. X-Diff performs better than Xandy for the first three data sets, and He-lios for the first two data sets. Helios is 3.3 times faster than Xandy in average. Helios is faster than Xandy for the following reasons. As Helios uses the Shared-Inlining schema for storing the XML documents, the leaf and in-ternal nodes are shredded into several tables. Xandy uses SUCXENT schema in which the leaf and internal nodes are stored in the LeafValue and AncestorInfo tables respec-tively. Therefore, there are more tuples to be joined by the SQL queries issued by Xandy . Note that X-Diff is unable to detect the changes on the XML documents that have num-ber of nodes over 5000 nodes due to lack of main memory.
In the next set of experiments, we examine the sub phases in first and second phases. We use the first five data sets. The percentage of changes is set to  X 3% X  and the threshold  X  is set to  X 0.0 X . Figure 9(g) shows the sub phases of the first phase in Helios . We observe that the execution time of the first phase is mostly taken by the execution time of finding the matching article nodes (around 54.23%). Figure 9(h) shows the sub phases of the second phase in Helios .The total execution time of this second phase is mostly taken by the execution time of detecting updates (around 30.2%), of detecting deletion of leaf node (around 28.5%), and of detecting insertion of leaf node (around 27.6%).
 University Data Sets . Figure 9(i) depicts the overall per-formance of Helios and Xandy . We set the percentage of the changes to  X 3% X . We observe that Helios is up to 6.2 times faster that Xandy .

Next, we vary the number of inlined leaf nodes. We in-crease the number of inlined leaf nodes up to eight additional inlined leaf nodes while we fix the numbers of nodes in the first versions of XML documents to 1175 nodes. Figure 9(j) depicts the performance of Helios and Xandy for different number of inlined leaf nodes. We observed that the perfor-mances of Helios and Xandy are influenced by number of inlined leaf nodes. This is because we have less number of subtrees to be matched as we increase the number of inlined leaf nodes and fix the total number of nodes.

In the next experiments, we vary the number of non-inlined leaf nodes. We increase the number of non-inlined leaf nodes up to three additional inlined leaf nodes while the numbers of nodes in the first versions of XML documents are fixed to 2345 nodes. Figure 9(k) depicts the performance of Helios and Xandy for different number of non-inlined leaf nodes. We observed that both approaches are influenced by number of non-inlined leaf nodes. In Helios , we shall have more relations for storing the non-inlined leaf nodes. The size of each relation will be smaller. That is, we have less number of tuples to join for each SQL query.

In the next set of experiments, we examine the effects of the percentages of changes to the performance of each ap-proach. We use dataset  X  X IGMOD-03 X . Figure 9(l) shows the performance of each approach when we vary the percent-ages of changes. We notice that the percentage of changes slightly affects the performances of Helios and Xandy The performance of X-Diff is affected by the percentage of changes.
 Result Quality . In this set of experiments, we examine the result quality of Helios and Xandy by using the  X  UNIV-01  X  dataset. We vary the percentage of change from 3% up to 30%. We calculate the ratio R = x/y ,where x is the num-ber of changed nodes in result delta of Helios and Xandy , and y is the number of changed nodes in the result delta of X-Diff. The ratios are plotted in Figure 9(b). We observed that Xandy is able to detect the optimal or near optimal deltas. We observed that Xandy detects the same deltas as X-Diff until the percentage of the changes reaches 18%. Helios detects the same deltas as X-Diff until the percent-age of the changes reaches 15% The quality ratios of X-Diff and Xandy , and of X-Diff and Helios are smaller than 1 when the percentage of the changes is larger than 20%. This happens because X-Diff detects a deletion and insertion of subtrees as a set of update operations.
In this paper, we present a novel relational approach for detecting the changes on unordered XML documents using a schema-conscious approach (called Helios ). This paper is motivated by the fact that a growing body of work sug-gests that schema-conscious approaches perform better than schema-oblivious approaches as far as XML query process-ing is concerned. The characteristics of schema-conscious approach raise certain challenges. For instance, the under-lying relational schema is DTD-dependent. To address the challenges, we present a general framework that is able to detect all changes accurately independent of the changes to the underlying relational schema due to different structure of XML documents. The experimental results show that Helios is up to 6.7 times faster than Xandy , and up to 52 times faster than X-Diff. The result quality of Helios is comparable to Xandy . As parts of our future work, we would like to extend our framework so that it can handle recursive DTDs.
