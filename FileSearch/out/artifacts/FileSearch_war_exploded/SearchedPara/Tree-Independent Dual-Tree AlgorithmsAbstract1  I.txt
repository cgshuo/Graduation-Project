 Ryan R. Curtin rcurtin@cc.gatech.edu William B. March march@gatech.edu Parikshit Ram p.ram@gatech.edu David V. Anderson anderson@gatech.edu Alexander G. Gray agray@cc.gatech.edu Charles L. Isbell, Jr. isbell@cc.gatech.edu In large-scale machine learning applications, algorith-mic scalability is paramount. Hence, much study has been put into fast algorithms for machine learning tasks. One commonly-used approach is to build trees on data and then use branch-and-bound algorithms to minimize runtime. A popular example of a branch-and-bound algorithm is the use of the trees for near-est neighbor search, pioneered by Bentley (1975), and subsequently modified to use two trees ( X  X ual-tree X ) (Gray &amp; Moore, 2001). Later, an optimized tree struc-ture, the cover tree, was designed (Beygelzimer et al., 2006), giving provably linear scaling in the number of queries (Ram et al., 2009) X  X  significant improvement over the quadratically-scaling brute-force algorithm. Asymptotic speed gains as dramatic as described above are common for dual-tree branch-and-bound al-gorithms. These types of algorithms can be applied to a class of problems referred to as  X  n -body prob-lems X  (Gray &amp; Moore, 2001). The n -point correlation, important in astrophysics, is an n -body problem and can be solved quickly with trees (March et al., 2012). In addition, Euclidean minimum spanning trees can be found quickly using tree-based algorithms (March et al., 2010). Other dual-tree algorithms include ker-nel density estimation (Gray &amp; Moore, 2003a), mean shift (Wang et al., 2007), Gaussian summation (Lee &amp; Gray, 2006), kernel density estimation, fast singu-lar value decomposition (Holmes et al., 2008), range search, furthest-neighbor search, and many others. The dual-tree algorithms referenced above are each quite similar, but no formal connections between the algorithms have been established. The types of trees used to solve each problem may differ, and in addition, the manner in which the trees are traversed can differ (depending on the problem or the tree). In practice, a researcher may have to implement entirely separate algorithms to solve the same problems with different trees; this is time-consuming and makes it difficult to explore the properties of tree types that make them more suited for particular problems. Worse yet, par-allel dual-tree algorithms are difficult to develop and appear to be far more complex than serial implemen-tations; yet, both solve the same problem. We make these contributions to address these shortcomings:  X  A representation of dual-tree algorithms as  X  A meta-algorithm that produces dual-tree al- X  Base cases and pruning rules for a variety of  X  A theoretical framework , used to prove the  X  Implications of our representation, including easy In other works, dual-tree algorithms are described as standalone algorithms that operate on a query dataset S q and a reference dataset S r . By observing common-alities in these algorithms, we propose the following logical split of any dual-tree algorithm into four parts:  X  A space tree (a type of data structure).  X  A pruning dual-tree traversal , which visits nodes  X  A BaseCase() function that defines the action to  X  A Score() function that determines if a subtree We can use this to define a meta-algorithm : In Sections 3 and 4, space trees, traversals, and related quantities are rigorously defined. Then, Sections 5 X 8 define BaseCase() and Score() for various dual-tree algorithms. Section 9 discusses implications and future possibilities, including large-scale parallelism. To develop a framework for understanding dual-tree algorithms, we must introduce some terminology. Definition 1. A space tree on a dataset S  X &lt; N  X  D is an undirected, connected, acyclic, rooted simple graph with the following properties:  X  Each node (or vertex), holds a number of points  X  There is one node in every space tree with no par- X  Each point in S is contained in at least one node.  X  Each node N has a convex subset of &lt; D contain-Notationally, we use the following conventions:  X  The set of child nodes of a node N i is denoted
N  X  The set of points held in a node N i is denoted  X  The convex subset represented by node N i is de- X  The set of descendant nodes of a node N i , de- X  The set of descendant points of a node N i , de- X  The parent of a node N i is denoted Par( N i ). An abstract representation of an example space tree on a five-point dataset in &lt; 2 is shown in Figure 1(a). In this illustration, N r is the root node of the tree; it has no parent and it contains the points x 3 and x 1 (that is, P r = { x 1 ,x 5 } . The node x 5 and has children children and contain points x 2 and x 4 , respectively). In Figure 1(b), the points in the tree and the subsets S r (darker rectangle) and plotted. S c = { x 2 } and S d = { x 4 } are not labeled. Definition 2. The minimum distance between two nodes N i and N j is defined as d Definition 3. The maximum distance between two nodes N i and N j is defined as d Definition 4. The maximum child distance of a node N i is defined as the maximum distance between the centroid C i of S i and each point in P i : Definition 5. The maximum descendant dis-tance of a node N i is defined as the maximum dis-tance between the centroid C i of S i and points in D p i It is straightforward to show that kd -trees, octrees, metric trees, ball trees, cover trees (Beygelzimer et al., 2006), R-trees, and vantage-point trees all sat-isfy the conditions of a space tree. The quantities d easily derived (or bounded, which in many cases is sufficient) for each of these types of trees.
 For a kd -tree, d min ( N i , N j ) is bounded below by the minimum distance between S i and S j ; d max ( N i , N j ) is bounded above similarly by the maximum distance between S i and S j . Both  X  ( N i ) and  X  ( N i ) are bounded above by d max ( C i , N i ).
 For the cover tree (Beygelzimer et al., 2006), each node N i contains only one point p i and has  X  X cale X  s . d min ( N i , N j ) is bounded below by d ( p i ,p j 2 S ,  X  ( N i ) = 0.  X  ( N i ) is simply 2 s i +1 . In general, the nodes of each space tree can be tra-versed in a number of ways. However, there have been no attempts to formalize tree traversal. Therefore, we introduce several definitions which will be useful later. Definition 6. A single-tree traversal is a process that, given a space tree, will visit each node in that tree once and perform a computation on any points contained within the node that is being visited. As an example, the standard depth-first traversal or breadth-first traversal are single-tree traversals. From a programming perspective, the computation in the single-tree traversal can be implemented with a sim-ple callback BaseCase(point) function. This allows the computation to be entirely independent of the single-tree traversal itself. As an example, a simple single-tree algorithm to count the number of points in a given tree would increment a counter variable each time BaseCase(point) was called. However, this concept by itself is not very useful; without pruning branches, no computations can be avoided.
 Definition 7. A pruning single-tree traversal is a process that, given a space tree, will visit nodes in the tree and perform a computation to assign a score to that node. If the score is above some bound, the node is  X  X runed X  and none of its descendants will be visited; otherwise, a computation is performed on any points Algorithm 1 DepthFirstTraversal( N q , N r ) . if Score( N q , N r ) =  X  then return for each p q  X  P q ,p r  X  P r do for each N qc  X  C q , N rc  X  C r do contained within that node. If no nodes are pruned, then the traversal will visit each node in the tree once. Clearly, a pruning single-tree traversal that does not prune any nodes is a single-tree traversal. A prun-ing single-tree traversal can be implemented with two callbacks: BaseCase(point) and Score(node) . This allows both the point-to-point computation and the scoring to be entirely independent of the traversal. Thus, single-tree branch-and-bound algorithms can be expressed in a tree-independent manner. Extensions to the dual-tree case are given below.
 Definition 8. A dual-tree traversal is a process that, given two space trees T q (query tree) and T r (reference tree), will visit every combination of nodes (
N each visit ( N q , N r ) , a computation is performed be-tween each point in N q and each point in N r . Definition 9. A pruning dual-tree traversal is a process which, given two space trees T q (query tree) and T r (reference tree), will visit combinations of nodes ( N q , N r ) such that N q  X  T q and N r  X  T r no more than once, and perform a computation to assign a score to that combination. If the score is above some bound, the combination is pruned and no combinations (
N visited; otherwise, a computation is performed between each point in N q and each point in N r .
 Similar to the pruning single-tree traversal, a prun-ing dual-tree algorithm can use two callback functions BaseCase( p q , p r ) and Score( N q , N r ) . An exam-ple implementation of a depth-first pruning dual-tree traversal is given in Algorithm 1. The traversal is started on the root of the T q and the root of T r . Algorithm 1 provides only one example of a commonly-used pruning dual-tree traversal. Other possibilities not explicitly documented here include breadth-first traversals and the unique cover tree dual-tree traversal described by Beygelzimer et al. (2006), which can be adapted to the generic space tree case.
 The rest of this work is devoted to using these concepts to represent existing dual-tree algorithms in the four parts described in Section 2.
 k -nearest neighbor search is a well-studied problem with a plethora of algorithms and results. The prob-lem can be stated as follows: Given a query dataset S q  X &lt; n  X  d , a reference dataset S r  X  &lt; m  X  d , and an integer k : 0 &lt; k &lt; m , for each point p q  X  S q , find the k nearest neighbors in S r and their distances from p q . The list of nearest neighbors for a point p q can be referred to as N p q and the dis-tances to nearest neighbors for p q can be referred to as D p q . Thus, the k -th nearest neighbor to point p q N p q [ k ] and D p q [ k ] = k p q  X  N p q [ k ] k . This can be solved using a brute-force approach: com-pare every possible point combination and store the k smallest distance results for each p q . However, this scales poorly  X  O ( nm ); hence the importance of fast algorithms to solve the problem. Many existing algo-rithms employ tree-based branch-and-bound strategies (Beygelzimer et al., 2006; Cover &amp; Hart, 1967; Fried-man et al., 1977; Fukunaga &amp; Narendra, 1975; Gray &amp; Moore, 2001; Ram et al., 2009).
 We unify all of these branch-and-bound strategies by defining methods BaseCase( p q , p r ) and Score( N q , N r ) for use with a pruning dual-tree traversal. At the initialization of the tree traversal, the lists N p and D p q are empty lists for each query point p q . After the traversal is complete, for a query point p q , the set { N p q [1] ,...,N p q [ k ] } is the ordered set of k nearest neighbors of the point p q , and each D p q [ i ] = k p N p q [ i ] k . If we assume that D p q [ i ] =  X  if i is greater than the length of D p q , we can formulate BaseCase() as given in Algorithm 2 3 .
 With the base case established, only the pruning rule remains. A valid pruning rule will, for a given query node N q and reference node N r , prune the reference subtree rooted at N r if and only if it is known that there are no points in D p r that are in the set of k nearest neighbors of any points in D p q . Thus, at any point in the traversal, we can prune the combination ( N q , N r ) if and only if d min ( N q , N r )  X  B 1 ( N q ), where Now, we can describe this bound recursively. This is important for implementation; a recursive function Algorithm 2 k -nearest-neighbors BaseCase()
Input: query point p q , reference point p r , list of k nearest candidate points N p q and k candidate dis-tances D p q (both ordered by ascending distance)
Output: distance d between p q and p r d  X  X  p q  X  p r k if d &lt; D p q [ k ] and BaseCase( p q , p r ) not yet called then return d can cache previous calculations for large speedups.
B Suppose we have, at some point in the traversal, two points p 0 ,p 1  X  D p q for some node N q , with D p 0 [ k ] =  X  and D p 1 [ k ] &lt;  X  . This means there exist k points r ,...,p { 1 ,...,k } . Because p 0 ,p 1  X  D p q , we can apply the tri-angle inequality to see that d ( p 0 ,p 1 )  X  2  X  ( N q ). There-Using this observation we can construct an alternate bound function B 2 ( N q ): which can, like B 1 ( N q ), be rearranged to provide a recursive definition. In addition, if p 0  X  P q and p 1  X  D q , we can bound d ( p 0 ,p 1 ) more tightly with  X  (  X  (
N B Both B 1 ( N q ) and B 2 ( N r ) provide valid pruning rules. We can combine both to get a tighter pruning rule by taking the tighter of the two bounds. In addi-tion, B 1 ( N q )  X  B 1 ( N c ) and B 2 ( N q )  X  B 2 ( N all N c  X  C q . Therefore, we can prune ( N q , N r d Algorithm 3 k -nearest-neighbors Score() Input: query node N q , reference node N r
Output: a score for the node combination ( N q , N r ), or  X  if the combination should be pruned if d min ( N q , N r ) &lt; B ( N q ) then return  X  These observations are combined for a better bound:
B ( N q ) = min max max As a result of this bound function being expressed re-cursively, previous bounds can be cached and used to calculate the bound B ( N q ) quickly. We can use this to structure Score() as given in Algorithm 3.
 Applying the meta-algorithm in Section 2 with any tree type and any pruning dual-tree traversal gives a correct implementation of k -nearest neighbor search. Proving the correctness is straightforward; first, a (non-pruning) dual-tree traversal which uses BaseCase() as given in Algorithm 2 will give correct results for any space tree. Then, we already know that B (
N the traversal, will not prune any subtrees which could contain better nearest neighbor candidates than the current candidates. Thus, the true nearest neighbors for each query point will always be visited, and the results will be correct.
 We now show that this algorithm is a generalization of the standard kd -tree k -NN search, which uses a pruning dual-tree depth-first traversal. The archety-pal algorithm for all-nearest neighbor search ( k -nearest neighbor search with k = 1) given for kd -trees in Alex Gray X  X  Ph.D. thesis (2003) is shown here in Algorithm 4 with converted notation.  X  nn q is the bound for a node N q and is initialized to  X  ; D p q represents the nearest distance for a query point p q , and N p q represents the nearest neighbor for a query point p q . N q .left repre-sents the left child of N q and is defined to be N q if N has no children; N q .right is similarly defined. The structure of the algorithm matches Algorithm 1; it is a dual-tree depth-first recursion. Because this is a depth-first recursion,  X  nn q =  X  for a node N q if no descendants of N q have been recursed into. Otherwise, Algorithm 4 AllNN( N q , N r ) (Gray, 2003) if d min ( N q , N r )  X   X  nn q , then return if N q is leaf and N r is leaf then AllNN( N q . left, closer-of( N r .left, N r .right) ) AllNN( N q . left, farther-of( N r .left, N r .right) ) AllNN( N q . right, closer-of( N r .left, N r .right) )
AllNN( N q . right, farther-of( N r .left, N r .right) )  X  q is the maximum of D p q for all p q  X  is,  X  nn q = B 1 ( N q ). Thus, the comparison in the first line of Algorithm 4 is equivalent to Algorithm 3 with B The first two lines of the inside of the for each loop (the base case) are equivalent to Algorithm 2 with k = 1. kd -trees only hold points in leaves; therefore, the base case is called for all combinations of points in each node combination, identical to the depth-first traverser (Algorithm 1).
 A kd -tree is a space tree and the dual depth-first re-cursion is a pruning dual-tree traversal. Also, we showed the equivalency of the pruning rule (that is, the Score() function) and the equivalency of the base case. So, it is clear that Algorithm 4 is produced using our meta-algorithm with these parameters. In addi-tion, because B ( N q ) is always less than B 1 ( N q ), Al-gorithm 3 provides a tighter bound than the pruning rule in Algorithm 4.
 This algorithm is also a generalization of the stan-dard cover tree k -NN search (Beygelzimer et al., 2006). The cover tree search is a pruning dual-tree traver-sal where the query tree is traversed depth-first while the reference tree is simultaneously traversed breadth-first. The pruning rule (after simple adaptation to the k -nearest-neighbor search problem instead of the nearest-neighbor search problem) is equivalent to where p q is the point contained in N q (remember, each node of a cover tree contains one point). This is equiva-lent to B 2 ( N q ) because  X  ( N q ) = 0 for cover trees. The transformation from the algorithm given by Beygelz-imer et al. (2006) to our representation is made clear in Appendix A (supplementary material) and in the k -nearest neighbor search implementation of the C++ library MLPACK (Curtin et al., 2011); this is imple-mented in terms of our meta-algorithm.
 Specific algorithms for ball trees, metric trees, VP trees, octrees, and other space trees are trivial to cre-ate using the BaseCase() and Score() implementa-tion given here (and in MLPACK). Note also that this implementation will work in any metric space.
 An extension to k -furthest neighbor search is straight-forward. The bound function must be  X  X nverted X  by changing  X  X ax X  to  X  X in X  (and vice versa); in addition, the distances D p q [ i ] must be initialized to 0 instead of  X  , and the lists D and N must be sorted by descend-ing distance instead of ascending distance. Lastly, the comparison d &lt; D p q [ k ] must be changed to d &gt; D With these simple changes, we have easily solved an entirely different problem using our meta-algorithm. An implementation using our meta-algorithm for both kd -trees and cover trees is also available in MLPACK. Range search is another popular neighbor searching problem related to k -nearest neighbor search. In addi-tion to being a fairly standard machine learning task, it has numerous uses in applications such as databases and geographic information systems (GIS). A treatise on the history of the problem and solutions is given by Agarwal &amp; Erickson (1999). The problem is: Given query and reference datasets S q ,S r and a range [  X  , X  2 ], for each point p q  X  S q , find all points in S such that  X  1  X  k p q  X  p r k  X   X  2 . As with k -nearest neighbor search, refer to the list of neighbors for each query point p q as N p q and the corresponding distances as D p q . These lists are not sorted in any particular order, and at initialization time, they are empty. In different settings, the problem of range search may not be stated identically; however, our results are eas-ily adaptable. A BaseCase() implementation is given in Algorithm 5, and a Score() implementation is given in Algorithm 6. The only bounds to consider are [  X  , X  2 ], so no complex bound handling is necessary. While range search is sometimes mentioned in the con-text of dual-tree algorithms (Gray &amp; Moore, 2001), the focus is usually on k -nearest neighbor search. As a re-sult, we cannot find any explicitly published dual-tree algorithms to generalize; however, a single-tree algo-rithm was proposed by Bentley and Friedman (1979). Thus, the BaseCase() and Score() proposed here can be used with our meta-algorithm to produce entirely novel range search implementations; MLPACK has kd -tree and cover tree implementations. Finding a Euclidean minimum spanning tree has been a relevant problem since Bor  X uvka X  X  algorithm was Algorithm 5 Range search BaseCase() .

Input: query point p q , reference point p r , neighbor list N p q , distance list D p q
Output: distance d between p q and p r d  X  X  p q  X  p r k if  X  1  X  d  X   X  2 and BaseCase( p q , p r ) not yet called then return d Algorithm 6 Range search Score() .
 Input: query node N q , reference node N r
Output: a score for ( N q , N r ), or  X  if the combi-nation should be pruned if  X  1  X  d min ( N q , N r )  X   X  2 then return  X  proposed in 1926. Recently, a dual-tree version of Bor  X uvka X  X  algorithm was developed (March et al., 2010) for kd -trees and cover trees. We unify these two algorithms and generalize to other types of space tree by formulating BaseCase() and Score() functions. For a dataset S r  X  &lt; N  X  D , Bor  X uvka X  X  algorithm con-nects each point to its nearest neighbor, giving many  X  X omponents X . For each component c , the nearest point in S r to any point of c that is not part of c is found. The points are connected, combining those components. This process repeats until only one component X  X he minimum spanning tree X  X emains.
 During the algorithm, we maintain a list F made up of i components F i : { E i ,V i } where E i is the list of edges and V i is the list of vertices in the component F i (these are points in S r ). Each point in S r belongs to only one F i . At initialization, | F | = | S r | and F in S r . For p  X  S r we define F ( p ) = F i if F i is the component containing p . During the algorithm, we maintain N ( F i ) as the candidate nearest neighbor of component F i and p c ( F i ) as the point in component F i nearest to N ( F i ). Then, D ( F i ) = k p c ( F i )  X  N ( F Remember that F ( N ( F i )) 6 = F i .
 To run Bor  X uvka X  X  algorithm with a space tree T r built on the set of points S r , a pruning dual-tree traversal is run with BaseCase() as Algorithm 7, Score() as Al-gorithm 8, T r as both of the trees, and F as initialized before. Note that Score() uses B ( N q ) from Section 5 with k = 1. Upon traversal completion, we have a list N ( F i ) of nearest neighbors of each component F i . The Algorithm 7 Bor  X uvka X  X  algorithm BaseCase() .
Input: query point p q , reference point p r , nearest candidate point N ( F ( p q )) and distance D ( F ( p q ))
Output: distance d between p q and p r if p q = p r then if F ( p q ) 6 = F ( p r ) and k p q  X  p r k &lt; D ( F ( p return k p q  X  p r k Algorithm 8 Bor  X uvka X  X  algorithm Score() .
 Input: query node N q , reference node N r
Output: a score for the node combination ( N q , N r ), or  X  if the combination should be pruned if d min ( N q , N r ) &lt; B ( N q ) then return  X  edge ( N ( F i ) ,p c ( F i )) is added to F i for each F any components in F with shared edges are merged into a new list F 0 where | F 0 | &lt; | F | . The pruning dual-tree traversal is then run again with F = F 0 and the traversal-merge process repeats until | F | = 1. When | F | = 1, then F 1 is the minimum spanning tree of S r . To prove the correctness of the meta-algorithm, see Theorem 4.1 in March et al. (2010). That proof can be adapted from kd -trees to general space trees. Our representation is a generalization of their algorithms; our meta-algorithm to produces their kd -tree and cover tree implementations with a tighter distance bound B (
N rect dual-tree algorithm with any type of space tree. Much work has been produced regarding the use of dual-tree algorithms for kernel density estimation (KDE), including by Gray &amp; Moore (2001; 2003b) and later by Lee et al. (2006; 2008). KDE is an important machine learning problem with a vast range of applica-tions, such as signal processing to econometrics. The problem is, given query and reference sets S q ,S r , to es-timate a probability density f q at each point p q  X  S q using each point p r  X  S r and a kernel function K h The exact probability density at a point p q is the sum of K ( k p q  X  p r k ) for all p r  X  S r .
 In general, the kernel function is some zero-centered probability density function, such as a Gaussian. This means that when k p q  X  p r k is very large, the contri-bution of K to f q is very small. Therefore, we can approximate small values using a dual-tree algorithm to avoid unnecessary computation; this is the idea set forth by Gray &amp; Moore (2001). Because K is a func-tion which is decreasing with distance, the maximum difference between K values for a given combination (
N B The algorithm takes a parameter ; when B K ( N q , N r ) is less than / | S r | , the kernel values are approximated using the kernel value of the centroid C r of the refer-ence node. The division by | S r | ensures that the total approximation error is bounded above by . The base case on p q and p r merely needs to add K ( k p q  X  p r k ) to the existing density estimate f q . When the algorithm is initialized, f q = 0 for all query points. BaseCase() is Algorithm 10 and Score() is Algorithm 9.
 Again we emphasize the flexibility of our meta-algorithm. To our knowledge cover trees, octrees, and ball trees have never been used to perform KDE in this manner. Our meta-algorithm can produce these implementations with ease. We have now shown five separate algorithms for which we have taken existing dual-tree algorithms and con-structed a BaseCase() and Score() function that can be used with any space tree and any dual-tree traver-sal. Single-tree extensions of these four methods are straightforward simplifications.
 This modular way of viewing tree-based algorithms has several useful immediate applications. The first Algorithm 9 KDE Score( N q , N r ) .
 Input: query node N q , reference node N r
Output: a score for ( N q , N r ) or  X  if the combina-tion should be pruned return d min ( N q ,N r ) Algorithm 10 KDE BaseCase( p q , p r ) .

Input: query point p q , reference point p r , density estimate f q
Output: distance between p q and p r if BaseCase( p q , p r ) already called then return f q  X  f q + K h ( k p q  X  p r k ) return k p q  X  p r k is implementation. Given a tree implementation and a dual-tree traversal implementation, all that is re-quired is BaseCase() and Score() functions. Thus, code reuse can be maximized, and new algorithms can be implemented simply by writing two new functions. More importantly, the code is now modular. ML-PACK (Curtin et al., 2011), written in C++, uses tem-plates for this. One example is the DualTreeBoruvka class, which implements the meta-algorithm discussed in Section 7, and has the following arguments: This means that any class satisfying the constraints of the TreeType template parameter can be de-signed without any consideration or knowledge of the DualTreeBoruvka class or of the TraversalType class; it is entirely independent . Then, assuming a TreeType and TraversalType without bugs, the dual-tree Bor  X uvka X  X  algorithm is guaranteed to work. An immediate example of the advantage of this is that cover trees were implemented for MLPACK for use with k -nearest neighbor search. This cover tree imple-mentation could, without any additional work, be used with DualTreeBoruvka  X  X hich was never an intended goal during the cover tree implementation but still a particularly valuable result! Of course, the utility of these abstractions are not lim-ited to implementation details. Each of the papers cited in the previous sections describe algorithms in terms of one specific tree type. March et al. (2010) discuss implementations of Bor  X uvka X  X  Algorithm on both kd -trees and cover trees and give algorithms for both. Each algorithm given is quite different and it is not easy to see their similarities. Using our meta-algorithm, any of these tree-based algorithms can be expressed with less effort X  X specially for more complex trees like the cover tree X  X nd in a more general sense. In addition, correctness proofs for our algorithms tend to be quite simple. These proofs for each algorithm here can be given in two simple sub-proofs: (1) prove the correctness of BaseCase() when no prunes are made, and (2) prove that Score() does not prune any subtrees on which the algorithm X  X  correctness depends. The logical split of base case, pruning rule, tree type, and traversal can also be advantageous. A strong ex-ample of this is the function B ( N q ) devised in Section 5, which is a novel, tighter bound. When not consider-ing a particular tree, the path to a superior algorithm can often be simpler (as in that case). 9.1. Parallelism Nowhere in this paper has parallelism been discussed in any detail. In fact, all of the given algorithms seem to be suited to serial implementation. However, the pruning dual-tree traversal is entirely separate from the rest of the dual-tree algorithm; therefore, a par-allel pruning dual-tree traversal can be used without modifying the rest of the algorithm.
 For instance, consider k -nearest neighbor search. Most large-scale parallel implementations of k -NN do not use space trees but instead techniques like LSH for fast (but inexact) search. To our knowledge, no freely available software exists that implements distributed dual-tree k -nearest neighbor search.
 As a simple (and not necessarily efficient) proof-of-concept idea for a distributed traversal, suppose we have t 2 machines and a  X  X aster X  machine for some t &gt; 0. Then, for a query tree T q and a reference tree T , we can split T q into t subtrees and one  X  X aster tree X  T qm . The reference tree T r is split the same way. Each possible combination of query and reference subtrees is stored on one of the t 2 machines, and the master trees are stored on the master machine. The lists D and N can be stored on the master machine and can be updated or queried by other machines. The traversal starts at the roots of the query tree and reference tree and proceeds serially on the mas-ter. When a combination in two subtrees is reached, Score() and BaseCase() are performed on the ma-chine containing those two subtrees and that subtree traversal continues in parallel. This idea satisfies the conditions of a pruning dual-tree traversal; thus, we can use it to make any dual-tree algorithm parallel. Recently, a distributed dual-tree algorithm was devel-oped for kernel summation (Lee et al., 2012); this work could be adapted to a generalized distributed pruning dual-tree traversal for use with our meta-algorithm. We have proposed a tree-independent representation of dual-tree algorithms and a meta-algorithm which can be used to create these algorithms. A dual-tree algorithm is represented as four parts: a space tree, a pruning dual-tree traversal, a BaseCase() function, and a Score() function. We applied this representa-tion to generalize and extend five example dual-tree algorithms to different types of trees and traversals. During this process, we also devised a novel bound for k -nearest neighbor search that is tighter than existing bounds. Importantly, this abstraction can be applied to help approach the problem of parallel dual-tree al-gorithms, which currently is not well researched. Agarwal, P.K. and Erickson, J. Geometric range searching and its relatives. Contemporary Mathe-matics , 223:1 X 56, 1999.
 Bentley, J.L. Multidimensional binary search trees used for associative searching. Communications of the ACM , 18(9):509 X 517, 1975.
 Bentley, J.L. and Friedman, J.H. Data structures for range searching. ACM Computing Surveys (CSUR) , 11(4):397 X 409, 1979.
 Beygelzimer, A., Kakade, S.M., and Langford, J.
Cover trees for nearest neighbor. In Proceedings of the 23rd International Conference on Machine Learning (ICML  X 06) , volume 23, pp. 97, 2006. Cover, T.M. and Hart, P.E. Nearest neighbor pattern classification. Information Theory, IEEE Transac-tions on , 13(1):21 X 27, 1967.
 Curtin, R.R., Cline, J.R., Slagle, N.P., Amidon, M.L., and Gray, A.G. MLPACK: a scalable C++ machine learning library. In BigLearning: Algorithms, Sys-tems, and Tools for Learning at Scale , 2011.
 Friedman, J.H., Bentley, J.L., and Finkel, R.A. An algorithm for finding best matches in logarithmic expected time. ACM Transactions on Mathematical Software (TOMS) , 3(3):209 X 226, 1977.
 Fukunaga, K. and Narendra, P.M. A branch and bound algorithm for computing k-nearest neighbors.
Computers, IEEE Transactions on , 100(7):750 X 753, 1975.
 Gray, A.G. Bringing Tractability to Generalized N-
Body Problems in Statistical and Scientific Com-putation . PhD thesis, Carnegie Mellon University, 2003.
 Gray, A.G. and Moore, A.W.  X  X -Body X  problems in statistical learning. In Advances in Neural Informa-tion Processing Systems 14 (NIPS 2001) , volume 4, pp. 521 X 527, 2001.
 Gray, A.G. and Moore, A.W. Rapid evaluation of mul-tiple density models. In Advances in Neural Infor-mation Processing Systems 16 (NIPS 2003) , volume 2003 of NIPS  X 03 , 2003a.
 Gray, A.G. and Moore, A.W. Nonparametric den-sity estimation: Toward computational tractability.
In SIAM International Conference on Data Mining (SDM) . Citeseer, 2003b.
 Holmes, M.P., Gray, A.G., and Isbell Jr., C.L. QUIC-SVD: Fast SVD using cosine trees. Advances in
Neural Information Processing Systems (NIPS) , 21, 2008.
 Lee, D. and Gray, A.G. Faster Gaussian summation: Theory and experiment. In In Proceedings of the
Twenty-second Conference on Uncertainty in Arti-ficial Intelligence (UAI) , 2006.
 Lee, D. and Gray, A.G. Fast high-dimensional ker-nel summations using the monte carlo multipole method. Advances in Neural Information Processing Systems (NIPS) , 21, 2008.
 Lee, D., Gray, A.G., and Moore, A.W. Dual-tree fast
Gauss transforms. In Advances in Neural Informa-tion Processing Systems 18 , pp. 747 X 754. MIT Press, Cambridge, MA, 2006.
 Lee, D., Vuduc, R., and Gray, A.G. A distributed kernel summation framework for general-dimension machine learning. In SIAM International Confer-ence on Data Mining , volume 2012, pp. 5, 2012. March, W.B., Ram, P., and Gray, A.G. Fast Eu-clidean minimum spanning tree: algorithm, anal-ysis, and applications. In Proceedings of the 16th
ACM SIGKDD International Conference on Knowl-edge Discovery and Data Mining (KDD  X 10) , pp. 603 X 612, 2010.
 March, W.B., Connolly, A.J., and Gray, A.G. Fast al-gorithms for comprehensive n-point correlation esti-mates. In Proceedings of the 18th ACM SIGKDD in-ternational conference on Knowledge discovery and data mining , pp. 1478 X 1486. ACM, 2012.
 Ram, P., Lee, D., March, W.B., and Gray, A.G.
Linear-time algorithms for pairwise statistical prob-lems. Advances in Neural Information Processing Systems 22 (NIPS 2009) , 23, 2009.
 Wang, P., Lee, D., Gray, A.G., and Rehg, J.M. Fast mean shift with accurate and stable convergence.
In Workshop on Artificial Intelligence and Statistics
