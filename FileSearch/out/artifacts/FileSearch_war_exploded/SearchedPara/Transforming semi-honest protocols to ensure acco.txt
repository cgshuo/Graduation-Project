 1. Introduction
Privacy and data utility are often perceived to be at odds. An omniscient data source would have many mandating protection of confidential data, such as the European Community privacy standards [1] ,US healthcare laws [2] , and California SB1386. However, this protection comes with a real cost through both added security expenditure and penalties and costs associated with disclosure. For example, CardSystems was terminated by Visa and American Express after having credit card information stolen [3] . ChoicePoint benefits of a global data source.

Secure multi-party computation (SMC) [4 X 6] has recently emerged as an answer to this problem. Infor-nizing this, the research community has developed many SMC protocols, for applications as diverse as fore-the protocol and thus could not have been disclosed by other parties.

Formal definitions of SMC exist for two adversary models: semi-honest and malicious. In the semi-honest sary may attempt to compute additional information from the messages received during execution. In the malicious model, a party can diverge arbitrarily from normal execution of the protocol. It has been proven evidence that achieving security against a malicious adversary adds significant complexity and expense.
An SMC-protocol secure under the semi-honest model (or an SSMC-protocol) rarely provides sufficient learned and disclosed the data, and should share liability.) For example, two competing transportation semi-honest protocol provides no guarantees. However, if cheating can be prevented or caught, contractual penalties can be used to overcome trust issues and enable collaboration. An SMC-protocol secure under the malicious model (or an MSMC-protocol) generally provides such a guarantee, but the complexity of an MSMC-protocol commonly prevents it from being adopted in practice.
 Fortunately, our proposed AC-framework can be utilized to design more practical and efficient protocols.
The idea behind the AC-framework is that a party who correctly followed the protocol can be proven to have done so and consequently prove that it did not know (and thus could not have disclosed) private data. This a behavior could be detected under the AC-framework. Furthermore, since the AC-framework does not need honest protocols are insufficient.
 under a two-party SSMC-protocol can be computed under the AC-framework. Although an MSMC-protocol simplified version of the AC-framework. Section 4 shows how to transform any SSMC-protocol to satisfy the simplified AC-framework based on certain techniques adopted in Pinkas X  compiler. Section 5 provides an alternative transformation utilizing threshold homomorphic encryption. To demonstrate additional utilities of the AC-framework, Section 6 presents a game theoretic model using the framework to achieve Nash Equi-librium. Section 7 concludes the paper. 2. Related work stand the rest of the paper. We then discuss previously proposed ideas that appear similar to our proposed
AC-framework, and highlight the differences. 2.1. Secure multi-party computation
Yao first proposed the two-party comparison problem and developed a provably secure solution [6] . This tiparty computation and proved that computing a function privately is equivalent to computing it securely [10] .
 tation in the semi-honest model is: Let T i be the input of party i , protocol f and s i be the result computed from f . f is secure if of the simulated image is computationally indistinguishable from tocol do not have to fear seeing data they are not supposed to. A formal definition can be found in [10] .
The malicious model (guaranteeing that a malicious party cannot obtain private information from an hon-prematurely. 2.2. Other verification-based methods
Ideas proposed in [11,12] appear similar to what we have presented in this paper. However, both of them methods.

In addition, the framework presented in [11] adopts a game-theoretic approach in that participants are information. The AC-framework proposed in this paper does not assume any such setting. On the other hand, The general AC-framework was presented in [13] , which presents AC-protocol to mine frequent itemsets. presents an alternative transformation to construct an AC-protocol using threshold homomorphic encryption. Furthermore, this paper shows how to use the AC-framework to design a game theoretic model that achieves
Nash Equilibrium. 3. The simplified AC-framework
We now present a simplified version of the AC-framework. Before presenting details, we clarify the follow-ing terminologies: putation (SMC);  X  MSMC-protocol : a protocol secure under the malicious model under the context of SMC;  X  AC-protocol : a protocol that satisfies the AC-framework.
 the paper, and the term  X  X  X ecure X  X  means secure against an adversary computationally bounded in the tradi-tional cryptographic sense (i.e., only capable of polynomial-time computations; unable to otherwise defeat the cryptographic schemes used in polynomial time).
 The full AC-framework is proposed in [13] ; here we provide its key definitions and simplified structures.
Suppose U is a protocol satisfying all the requirements under the AC-framework. In general, the AC-frame-work provides means to examine if what participating parties have done during the execution of U is con-sistent with honest behaviors (expected under the semi-honest model). For instance, whether or not a party has followed the prescribed execution procedures of a protocol could be proved in the framework. The next two definitions define key components and conditions that a protocol needs to guarantee in the AC-framework.
 validates the verification process of U .

Definition 2 ( AC-protocol ). An AC-protocol U must satisfy the following three requirements: (2) Basic structure : The execution of U consists of two phases: (3) Sound verification : U is sound providing that
Note that unlike the computation phase, the verification phase stated in Definition 2 is optional for each run of an AC-protocol. The verification process is performed merely when there is a need to verify ing party did not behave honestly and thus may have obtained or disclosed information which should not accused party who correctly follows the protocol to prove it has not obtained information it should not have.
 third party. Some privacy-preserving protocols utilize a third party to perform certain computations. The
Because the verification phase (used only when needed) under the AC-framework does not leak any additional information regarding the participating parties X  private inputs, and because the verification phase can be than for most third party protocols.
This simplified version of the AC-framework, especially the verification phase along with its soundness of detecting any malicious behaviors that can be prevented under the malicious adversary model, and at process.

The running time or complexity of an AC-protocol (verification phase) can be as or possibly even more inefficient than an MSMC-protocol; however, the computation phase of an AC-protocol should be more efficient because the verification phase of the protocol is not needed for every run. If the com-plexity of the computation phase of an AC-protocol were comparable to an MSMC-protocol, the MSMC-protocol would be sufficient and more effective than the AC-protocol for practical purposes. Therefore, a challenge in designing an AC-protocol is to ensure that the computation phase is efficient.
In general, the implementation of an AC-protocol X  X  computation phase is the same as that of an SSMC-protocol, except that additional information needs to be computed for the verification phase. Steps pro-needs to be proven. 4. SSMC to AC based on Pinkas X  Compiler
For the rest of the paper, we use the term AC-framework to mean the simplified AC-framework introduced in Section 3 . The goal of this section is to prove the following claim: generic circuit-based SSMC-protocol.

By generic protocols, we mean that protocols are represented as boolean circuits. It has been shown that for any polynomial-time algorithm, there exists a polynomial time generic secure protocol that achieves the same functionality [4,6] . Thus, to prove the above claim, we construct a generic AC-protocol from a circuit-based SSMC-protocol. Then we show that the generic AC-protocol provides security guar-antees allowing detection of any behavior prevented by the corresponding generic MSMC-protocol. Next we briefly discuss the concept of two-party circuit-based secure function evaluation under the semi-honest model.

Algorithm 1: Circuit construction [15] 4.1. Secure circuit evaluation
Suppose Alice and Bob want to securely compute a function f based on their private inputs x and y . Let f f ( x , y )= f B ( x , y ), f consists of gates g 1 , ... , g sage and r is a random value.
 Algorithm 2: Secure function evaluation (SFE) Require : x , y , f Following the description in [15] , Algorithm 1 highlights key steps for constructing a scrambled circuit. evaluates the circuit. Since AND and NOT are sufficient for constructing any boolean circuit, Bob merely needs to know how to encrypt the two gates. Gates are encrypted using a set of random values corre-sponding to input or output values of every gate. To evaluate the encrypted circuit, Alice first obtains random values related to her and Bob X  X  input values. Using these, she can decrypt one entry of every top level gate to get a new set of random values. Continuing this process, Alice will eventually obtain random values corresponding to the output. Using pre-defined mappings from Bob, Alice can obtain the actual result. More details can be found in [4,15,6] . Using the procedures presented in Algorithm 2 ,
Alice and Bob can compute any function securely, and Algorithm 2 provides certain key steps. Note that input.
 ple shows how to compute it securely between Alice and Bob.

Example 1 ( Refer to Fig. 1 ). Bob randomly generates s-bit strings: r / 1  X fh r 1 ; 1 i ; h r 1 ; 0 ig , / x  X fh r x ; 0 i ; h r x strings: m 1 , m 2 , m 3 and m 4 and compute the following:
Bob constructs four pairs:
Bob sets S 1 = p ({ p 1 , p 2 , p 3 , p 4 }). Now suppose x = 1 and y = 1, then Bob sends S 1 X 2 OT, Alice gets r x (since / x  X  r x  X  X  1) from Bob. Based on r pairs in S 1 to get m 2 and m 2 . 3 Because m 2 m 2  X  r f (1, 1) = / 1 ( r 1 )=1.

In the previous example, f A ( x , y )= f B ( x , y ) = 1, so at the end, Alice simply sends 1 or r 4.2. From SSMC to AC
The circuit evaluation approach presented in Algorithm 1 and 2 is secure under the semi-honest model, but handle situations where parties refuse to participate, input modification, or premature termination. Thus, guarantee that: (1) Bob correctly constructs the garbled circuit C g f of C (2) Alice sends the correct f g B  X  x ; y  X  value to Bob.

For the rest of this section, we show how to guarantee these two conditions under the AC-frame work. To compile an SSMC-protocol into an MSMC-protocol). The basic idea is that during the construction of C
Bob randomizes the output value. For the output wire / t , Bob chooses a random binary key k 2 {0, 1}. If k = 0, the mapping / t is not changed; otherwise, the ordering of the entries in / ified / t is sent to Alice.

At the end of the evaluation of C g f , Alice knows the permuted 0 or 1 value of the output wire. Alice done directly as described because a party who gets the value first has an advantage by not sending his or her value to the other party. Therefore, this step should be performed via gradual release timed commit-denotes a regular commitment for a random chosen value r . Alice and Bob first exchange the commit-to send and verify alternate hint messages for a number of rounds until they can open their received com-mitments. If one party aborts the protocol, say Bob, Alice can open the next commitment in polynomial time without Bob X  X  hint. Although the protocol does not provide complete fairness, Bob only has a slight advantage. Plus, Alice is able to know, in polynomial time, the bit that Bob learned by cheating. (A con-struction of such gradual release timed commitments can be found in [17] .)
The above steps do not guarantee that the commitments are related to the actual output of C correctness of Bob X  X  commitment can be justified when the first condition is met. We will come back signature scheme [19,20] in that Bob can sign Alice X  X  commitment without knowing its actual value. An example is Chaum X  X  signature scheme: an RSA pair ( N , e ), and secret key d . Let H be a hash function (e.g., SHA [21] , MD5 [22] ) whose range is in Z N . The signature of a message M is defined as ( H ( M )) mod N .

Alice constructs the commitment as follows: For the output wire of g and c (1) for bit values 0 and 1, respectively. She chooses a random value r 2 c (0) = r e  X  H ( c (0)) and c h (1) = r e  X  H ( c (1)). Alice sends the two pairs h c both commitments: ( c h (0)) d = r  X  ( H ( c (0))) d and ( c on the random permutation k and the mappings h c h (0), 0 i and h c r  X  ( H ( c (1))) d to the 0 and 1 entries of the output table / cuit C g f along with the commitment c ( k )of k .

After the evaluation of C g f , Alice gets either r  X  ( H ( c (0))) r  X  ( H ( c (0))) d . She unblinds the signature to get h c (0), ( H ( c (0))) a 1-commitment when Bob receives c (0) and ( H ( c (0))) d ify if c (0) corresponds to the correct output value by checking the signature ( H ( c (0)))
Bob a value other than c (0), she is not able to compute a valid signature. As a consequence, Alice can be detected as being malicious. Finally, both parties gradually open their timed commitments to get the expected result.
 the AC-framework. During the verification phase, Alice sends C sends the verifier: r x ; r x , r y ; r y , h c h (0), 0 i and h c can decrypt C g f and examine whether C g f correctly computes the function f .
 the AC-framework (AC-SFE). Keep in mind that the AC-SFE protocol can detect any malicious behavior defined under the malicious model, if verification is performed. Key steps of the AC-SFE protocol are pre-to previous discussions, Algorithm 3 is straightforward. The computation phase of AC-SFE adopts a secure signature scheme denoted by Sign (e.g., RSA [23] ) which is used during the verification process. computed in Algorithm 3 . Algorithm 3 (AC-SFE: Computation phase) concatenation operator
The next example shows how AC-SFE is executed in practice. We follow the same settings and notations as in Example 1 (where f is a logic AND function). For illustration purpose, we assume every message passed between Alice and Bob is valid, so certain values (e.g., commitments in I (1), III (1, 3, 5) and IV of Algorithm 3 ) are implicit or omitted in the following example.
Algorithm 4 (AC-SFE: verification phase)
Example 2 ( Refer to Fig. 2 ). Bob randomly generates s-bit strings: r /  X fh r x ; 0 i ; h r x ; 1 ig and / y  X fh r y ; 1 i ; h r y this example. Based on the values h c h (0), 0 i and h c /  X fh r 1 ; r  X  H  X  c  X  0  X  X  X  d i ; h r 1 ; r  X  H  X  c  X  1  X  X  X 
Example 1 . We also assume x = 1 and y = 1, then Bob sends S
Alice. Using 1 X 2 OT, Alice gets r x (since / x  X  r x  X  X  1) from Bob. Based on r pair in S 1 to get m 2 and m 2 . Because m 2 m 2  X  r 1 , from / ( H ( c (0))) d . According to the c (0) value she generated before, Alice is able to know ( H ( c (0))) value k and Bob gets the value 0 (the committed value of c (0)). Alice can compute f Bob can compute f B ( x , y )=0 k =1.

Note that as stated previously, k = 1 implies the ordering in the output table / output computed from C g f (e.g., 0) XOR with k produces the actual output. 4.2.1. Security and soundness of AC-SFE
The key difference between SSMC-SFE and AC-SFE X  X  computation phase is that the messages, passed between Alice and Bob in AC-SFE, contain additional commitments. Due to the (computationally or perfect) hiding property of the commitment scheme, these commitments do not convey any more information than these messages themselves. Therefore, the security analysis of AC-SFE is the same as that of SSMC-SFE. Next, we show that the verification phase of AC-SFE is sound.
 terminate prematurely and Alice and Bob did not collude.
 Proof. Two conditions need to be examined: whether Alice sent Bob the correct commitments, and whether the verifier initially needs to be certain about the authenticity of the garbled circuit C construct the circuit. Steps 3 X 4 of Algorithm 4 achieve this requirement with reasons as follows: since we assume that the computation phase of AC-SFE did not abort, Alice did receive the correct message and sig-ticated information to verify the two conditions.

Now the first condition can be verified if c h (0) and c h a correct commitment signals that Alice did not follow the protocol to compute the expected commitments. the values to scramble the circuit. After f r x ; r x ; r Then, it is easy to see if C g f computes f correctly. h
We need to emphasize that the verification phase of AC-SFE does not disclose any information regarding the private inputs x and y to the verifier because the verifier only has values used to construct C situation where the protocol terminates prematurely. The aborting of a protocol is a very complex issue dles such situations. 4.3. AC vs. SSMC
The computation phase of AC-SFE ( Algorithm 3 ) is not much different from SFE under the semi-honest model (SSMC-SFE, Algorithm 2 ). The AC-SFE protocol requires computing additional commitments for the bounded by the number of gates in C f which is the same as SSMC-SFE.
 decrypt every garbled gate, its complexity is also linearly bounded by the number of gates in C both computation phase and verification phase of AC-SFE are virtually as efficient as SSMC-SFE under the assumption that the number of the output gates is much smaller than that of C
On the other hand, AC-SFE is more powerful than SSMC-SFE since the verification phase of AC-SFE can detect any malicious behavior defined under the malicious model. Therefore, the AC-SFE protocol provides an example that an AC-protocol is more useful and practical than an SSMC-protocol and yet almost without any efficiency loss. 4.4. AC vs. MSMC
Given an SSMC-protocol, the compiler proposed in [17] can be utilized to transform it into a secure pro-tocol under the malicious model (MSMC-SFE). The basic steps involve: Bob creates 2 l copies of C in MSMC-SFE.

It has been shown that for any polynomial-time algorithm, there exists a polynomial time secure protocol
AC-SFE is based on a generic protocol under the semi-honest model, the construction of the AC-SFE proto-col validates Claim 1 . 5. SSMC to AC based on homomorphic encryption
In this section and under the random oracle model [24] , we present an alternative construction based on homomorphic encryption to prove Claim 1 . We first provide a brief description of threshold homomorphic cryptosystem. Based on that, we give an overview of how Alice and Bob can securely compute any two party function f ( x , y ) represented as a boolean circuit C f the transformation from SSMC to AC. Note that under the context of this section, the term SSMC (MSMC or
AC)-SFE actually means SSMC (MSMC or AC)-SFE whose implementation relies on threshold homomor-phic encryption.
 5.1. Threshold homomorphic cryptosystems
Let E : R  X  X ! Y be a probabilistic public key encryption scheme, where R , X and Y are finite domains identified with an initial subset of integers and D : Y ! X be a private decryption algorithm, such that " ( r , x ) 2 R  X  X , D ( E ( r , x )) = x . Furthermore, the scheme has the following properties:  X  The encryption function is injective with respect to the second parameter, i.e., " ( r
E ( r 1 , x 1 )= E ( r 2 , x 2 ) ) x 1 = x 2.  X  The encryption function is additive homomorphic, i.e., " ( r
E ( r 2 , x 2 )= E ( r 3 , x 1 + x 2 ), where r 3 can be computed from r not provide additional information about the plaintext to an adversary with polynomial-bounded comput-ing power.  X  The domain and the range of the encryption system is suitable.

Paillier X  X  public key encryption scheme [26] has these properties. Honest behaviors in the malicious model can be enforced using efficient zero-knowledge ( ZK ) proofs [27] under the random oracle model [24] .In order to utilize ZK proof techniques, the Paillier X  X  scheme has following additional properties (two-party case) [28] :  X  Threshold decryption : Given a public X  X rivate key pair (e.g., k shares ( k 1 pr ; k 2 pr ) privately distributed between two parties;
For instance, suppose c is computed by party Alice, then Alice can also efficiently generate ZK proof, encryption of some value Alice has;  X  M j  X  D
ZK ( M j ) can be used to show the decryption is performed correctly;  X  M 1 and M 2 can be combined to produce M , but either M regarding M .  X  Given a constant k and a ciphertext E ( r , M ), k  X  h E ( r , M )= E ( r with its ZK proof.

For the rest of the paper, we adopt E ( M ) and D ( c ) to represent E ( r , M ) and D clear. 5.2. Secure function evaluation using threshold homomorphic encryption used as a threshold homomorphic encryption scheme and C f logic gates) to compute a function f .

Before Alice and Bob start evaluating the circuit C f , Alice encrypts her i th input bit x encrypted bit E ( x i ) to Bob. Bob encrypts his i th input bit y
Note that Alice and Bob cannot decrypt each other X  X  encrypted inputs because they just have a share of the secret key. Now given the encrypted inputs to the circuit C
AND and NOT gates on encrypted input bits without revealing anything until they calculate the last output gates.
 encrypted output of the AND gate given its encrypted input bits E ( b
E ( b 1 ) and E ( b 2 ), how can Alice and Bob calculate E ( b and homomorphic properties, Alice and Bob can independently calculate E ( b b  X  b 2 ).
 Algorithm 5 (SFE of AND using homomorphic encryption)
Require E ( b 1 ), E ( b 2 ) and N (the public key as in Pallier X  X  system)
The procedures described above enable Alice and Bob to calculate the encrypted output of any intermediate
Bob to jointly decrypt the final output of the circuit C f 5.3. From SSMC to AC using ZK proofs
Here, we briefly discuss how to construct an AC-SFE based on Algorithm 5 using ZK proofs. The compu-tation phase of the AC-SFE is the same as the SSMC-SFE (constructed based on threshold homomorphic prematurely.

Under these assumptions, implementation of the verification phase is straightforward. To ensure honest rectly and (2) each AND gate is evaluated correctly. To check the first condition, Alice and Bob generate
ZK proofs corresponding to the encrypted input values, and send the verifier the encrypted input values and4of Algorithm 5 . For instance, Fig. 4 shows how a verifier can check if E ( b Bob at step 1. As shown in the figure, during the verification phase, Bob needs to compute the ZK proof of
E ( d 2 )( ZK ( E ( d 2 ))) and sends ZK ( E ( d 2 )) to the verifier. Alice sends E ( d
E ( d that, the verifier can use ZK ( E ( d 2 )) to check if E ( d soundness ( Definition 2 ) of the verification phase is guaranteed by the properties of ZK proof.
The MSMC-SFE (presented in [29] ) requires computation and verification of ZK-proofs regarding the encrypted input values and values for evaluating every AND gates. Thus, the AC-SFE X  X  computation phase is more efficient than the MSMC-SFE since all the expensive computation and verification of ZK proofs are
We have presented two constructions to prove Claim 1 : the first approach is based on Pinkas X  compiler and
AND gate, it does provide a simpler implementation. In addition, since ZK proofs are independent from one tradeoff between an error bound and a selected sample size in the future. 6. A game theoretic model utilizing AC the AC-framework can be utilized to design a game theoretic model to answer the following question: how will cheat if and only if cheating is profitable for them.

For simplicity, we model the case where only Alice wants to verify whether Bob has cheated or not. The caught cheating, he needs to pay a penalty of g p , and Alice gains g the computation phase of an AC-protocol.

To analyze the above two party strategic game, we need some basic definitions from game theory. Let p the computation phase. Furthermore, we can define the expected utilities for Alice ( u and Fig. 5 : Using the above utility functions and notations, we next define Nash Equilibrium. the verification game with utility functions u A , u B if the following inequalities hold: where 0 6 p , p * , q , q * 6 1.
 then no player has an incentive to deviate from the equilibrium strategy. Using the Nash Equilibrium definition, we can prove the following theorem: p * = 0 and q * = 0 if f b P g and has a equilibrium p  X  g f and 2 . Given q * = 0, we can show that p * is the best strategy as follows: Clearly u A (0, p ) is a decreasing function in p . Therefore, p = 0 maximizes u satisfied.
 rewrite the u B ( q , 0) as follows: satisfied.

We first calculate u A ( q * , p ):
As before, we can calculate u B ( q , p * ): 2 . h
Theorem 4 indicates two different Nash Equilibria. The first equilibrium corresponds to case where Bob has we can guarantee that other party cannot gain more by cheating, we do not need to verify at all.
In the second case (i.e., f b &lt; g ) we have a Nash Equilibrium where Alice verifies with probability probability of verification at the equilibrium point decreases. Similarly, since q  X  1 practice. 7. Conclusion
Confidentiality is an extremely important issue in privacy-preserving data mining (PPDM). SMC-tech-niques are among basic tools in designing PPDM applications. An SSMC-protocol, if followed, prevents information disclosure. However, it may be possible for a dishonest party to undetectably cause disclosure ficult to design. Fortunately, the AC-framework has opened up the opportunity for more efficient protocols and maintain strong security against malicious adversaries.

In this paper and through the generic construction of two AC-SFE protocols, we have shown that for any polynomial-time algorithm, there exists a polynomial-time AC-protocol that achieves the same functionality and is capable of detecting any malicious behaviors that can be prevented under the malicious adversary ification phase of AC-SFE does not disclose any information regarding each party X  X  private input, and AC-of the AC-framework, we have designed a simple game theoretic model that achieves Nash Equilibrium.
The game theoretic setting also allows us to determine under what settings the AC-framework is better than the malicious model. Informally, if the gain from cheating g is high relative to the penalty g cost of running the malicious protocol, the malicious protocol becomes more attractive. ever, some gates or ZK-proofs may be more critical to achieving a gain from cheating; it is possible that amortized cost/benefit than the analysis of Section 6 .
 using the protocol, both parties should agree on the penalty when any malicious behavior is detected.
In theory, we have showed that the two generic constructions of AC-SFE X  X  computation phase are more and precisely how efficient the two constructions of AC-SFE can be in practical terms comparing to both SSMC-SFE and MSMC-SFE.

References
