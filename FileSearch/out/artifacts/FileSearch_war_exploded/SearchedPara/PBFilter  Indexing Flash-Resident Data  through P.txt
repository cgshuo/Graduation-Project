 NAND Flash has become the most popul ar persistent data storage medium for mobile and embe dded devices. The hardware characteristics of NAND Flash (e.g. page granularity for read/write with a block-erase-before-rewrite constraint, limited number of erase cycles) preclude in-place updates. In this paper, we propose a new indexing scheme, called PBFilter, de signed from the outset to exploit the peculiarities of NAND Flash. [Operating Systems]: File Systems Management  X  Access methods, file organization.
 General Terms : Algorithms, Performance, Design. Keywords : Indexing method, NAND Fl ash, Bloom Filter. NAND Flash memory stands out as th e best adapted storage medium for an ever wider spectrum of m obile and embedded devices (PDAs, cell phones, cameras, sensors, smar t cards, USB keys, mp3 readers etc), because of its excellent properties such as shock resistance, size, energy consumption, performance a nd ease of on-chip integration. However, NAND Flash exhibits sp ecific hardware characteristics making database manage ment very challenging. Reads and writes more time and energy consuming th an reads. In addition, a page cannot be rewritten before erasing th e complete block containing it, a costly operation. Finally, a block wears out after 10 5 to 10 write/erase cycles. Due to this, updates are usually performed  X  X ut-of-place X , meaning that a page is copied in another location before being modified, entailing address tr anslation and garbage collection overheads. Database storage models dedi cated to NAND Flash have been buffering approach hiding the Flash peculiarities to the upper layers of the DBMS. Updates in Flash are delayed thanks to a log stored in each physical block and the accurate version of each page is rebuilt at load time. The updates are physically applied to a page when the corresponding log region becomes full. While elegant, this general method is not well suited to manage hot spot data like index pages because of frequent log overflows. Recent works addressed this issue by adapting B+Tree-like structures to NAND Flash [2, 6, 7]. While different in realization, these met hods rely on a similar approach: to delay the index updates thanks to a log dedicated to the index and batch them with a given frequency with the objective to group updates related to a same inde x node. We call these methods batch methods hereafter. Batch methods entail a new trade-off between the number of reads and writes but good performance for both is difficult to achieve at once due to the Flash characteristics. In addition, read/write performance is no longer the sole metrics of interest in the Flash context. Fi rst, RAM consumption is a primary concern in many mobile and em bedded devices, today the main target of Flash chip manufacturers. Second, the data organization in Flash impacts the costs of address translation and stale data reclamation. These indirect cost s have been shown high and not easily predictable [6]. Hence, we argue that a larger set of metrics has to be considered when designing an indexing techni que for Flash-resident data, namely:  X  M1: Read cost at lookup time.  X  M2: Read and write cost at insertion time.  X  M3: Flash usage in terms of space occupancy and effort to  X  M4: RAM consumption.  X  M5: Performance and resource consumption predictability. Instead of adapting traditional inde xes, as batch methods do, this paper proposes a new indexing sche me, called PBFilter, designed to exploit natively the peculiarities of NAND Flash. PBFilter performs index updates eagerly and makes this acceptable by organizing the complete database as a set of seque ntial data structures, as pictured in Figure 1. The objective is to transform database updates into append operations so that writes are produced sequentially, an optimal scenario for NAND Flash. When a new record is inserted, it is added at the end of the record area (RA). Then, a new index entry composed by a couple &lt;key, pt&gt; is added at the end of the key area (KA), where key is the primary key of the inserted record and pt is the record physical address record is deleted, its identifier is in serted at the end of the delete area (DA) but no update is performed in RA nor in KA. A record modification is implemented by a deletion (of the old record) followed by an insertion (of the new record value). To search for a record by its key, the lookup operation first scans KA, retrieves the required index entry if it exists, check that pt  X  DA and gets the record in RA. Assuming a buffering policy allocating one buffer in RAM per sequential data structure, this database updating process never incurs rewriting a same page in Flash. The benefits provided by this si mple database organization are obvious with respect to the metrics introduced above. Indeed, a lower bound is reached in terms of reads/writes at insertion time (metric M2) and in terms of Flash space occupancy (metric M3), a single RAM buffer of one page is required per sequential structure RA, KA and DA (metric M4) and finally PBFilter can bypass the FTL address translation layer 2 and avoids the need for garbage collection, two major sources of performance unpredictability (metric M5). The drawbacks of this organi zation are obvious as well. The performance for metric M1 reaches (  X  KA  X  /2 +  X  DA  X  + 1) on the average, where  X   X  denotes the page cardinality of a structure. We introduce two additional principles to circumvent this drawback with a minimal degradation of the benefits listed above. Summarization: Summarization condenses each KA page into a summary record. Summary records are sequentially inserted into a new structure called SKA through a new RAM buffer of one page. Then, lookups do a first sequential scan of SKA and a KA page is accessed for every match in SKA in order to retrieve the requested key (if it exists). Summarization in troduces an interesting trade-off between the compression factor c (c=  X  KA  X  /  X  SKA  X  ) and the fuzziness factor f (i.e., probability of false positives) of the summary, the former decreasing the I/O required to traverse SKA and the latter decreasing the I/O required to access KA. The net effect is replacing the lookup cost in KA by (  X  KA  X  /2c + f  X  X  X  KA  X  X  X  /2) on the average, where  X  X  X   X  X  X  denotes the element cardinality of a structure. The positive impact on metrics M1 and M5 can be very high for favorable values of c and f . The negative impact on M4 is limited to a single new buffer in RAM. The negative impact on M2 and M3 is linear with  X  SKA  X  and then depends on c . Different algorithms can be considered as candidate  X  X ondens ers X , with the objective to reach the higher c with the lower f , if only they respect the following property: summaries must allow membership tests with no false negatives . In [8], we show that Bloom Filter [3] is a very good condenser and provides subtle t uning capabilities for c and f. Bloom Filter summaries can then adapt to different requirements in terms of lookup performance and targeted hardware platform. Partitioning: the idea is to vertically split a sequential structure into p partitions so that only p  X &lt; p partitions have to be scanned at lookup time. PBFilter applies partitioning to SKA in such a way that the membership test can be done w ithout considering the complete summary value. The larger p , the higher the partitioning benefit and the better the impact on metrics M1 and M5. On the other hand, the larger p , the higher the RAM consumption ( p buffers) or the higher the number of writes into the partitions (less than p buffers) with the bad consequence of reintroduc ing page moves and garbage collection. Again, different partiti oning strategies can be considered with the following requirement: to increase the number of partitions with neither significant increase of RAM consumption nor need for garbage collection . In [8], we propose a dynamic partitioning mechanism for Bloom Filter summaries which matches the above requirements at the price of intr oducing a few reads and extra writes at insertion time. NAND Flash has become the most popular persistent storage medium for mobile and embedde d devices, urging the database community to design Flash-aware indexing methods. Previous works in this area defer index updates tha nks to a log and batch them with the objective to decrease the cost of writes in Flash. This introduces a complex trade-off between read and write performance and entails side-effects on the RAM consump tion, Flash consumption and garbage collection cost. PBFilter is an alternative to batc h methods, particularly well suited to mobile and embedded devices. It s effectiveness on all metrics at once has been shown in [8] through a comprehensive analytical performance study. PBFilter has been implemented and integrated in the storage manager of an embedded DBMS dedicated to the management of secure portable folders [1]. The prototype runs on an experimental secure USB Flash platform provided by Gemalto. Thanks to its tuning capabilities, PBF ilter is easily adaptable to other Flash-based environments and can meet various application requirements in terms of file size, key size, read/write tradeoffs. Investigating other summarization and partitioning strategies could ever enlarge the application domain of PBFilter (e.g. indexing secondary keys), which is part of our current and future work. The authors wish to thank Luc Bouganim and Dennis Shasha for valuable comments on this paper. A sp ecial thank is also due to Jean-Jacques Vandewalle from Gemalto for his technical support. This work is partially supported by the French National Research Agency (ANR) and the Natural Science Foundation of China. [1] Anciaux, N., Benzine, M., Bouganim, L., Jacquemin, K., Pucheral, P., [2] Bityutskiy, A-B., JFFS3 Design Issues. Tech. report , Nov. 2005. [3] Bloom, B. Space/time tradeoffs in ha sh coding with allowable errors. [4] Kim, G., Baek, S., Lee, H., Lee, H., and Joe, M. LGeDBMS: A Small [5] Lee, S-W., and Moon, B. Design of Flash-Based DBMS: An In-Page [6] Nath, S., and Kansal, A. FlashDB: Dynamic Self-tuning Database for [7] Wu, C., Chang, L., and Kuo, T. An Efficient B-Tree Layer for Flash-[8] Yin, S., Pucheral, P., Meng X. PBFilter: Indexing Flash-Resident Data 
