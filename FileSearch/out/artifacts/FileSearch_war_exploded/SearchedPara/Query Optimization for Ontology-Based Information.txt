 In recent years, there has been an explosion of publicly avail-able RDF and OWL data sources. In order to effectively and quickly answer queries in such an environment, we present an approach to identifying the potentially relevant Semantic Web data sources using query rewritings and a term index. We demonstrate that such an approach must carefully han-dle query goals that lack constants; otherwise the algorithm may identify many sources that do not contribute to even-tual answers. This is because the term index only indicates if URIs are present in a document, and specific answers to a subgoal cannot be calculated until the source is physi-cally accessed -an expensive operation given disk/network latency. We present an algorithm that, given a set of query rewritings that accounts for ontology heterogeneity, incre-mentally selects and processes sources in order to maintain selectivity. Once sources are selected, we use an OWL rea-soner to answer queries over these sources and their corre-sponding ontologies. We present the results of experiments using both a synthetic data set and a subset of the real-world Billion Triple Challenge data.
 H.3.4 [ Systems and Software ]: Distributed systems Theory Semantic Web, Information Integration, Ontology
In the Semantic Web, the definitions of resources and the relationship between resources are described by ontologies. The resources in the Web are independently generated and distributed in many locations. In such an environment, we often need to integrate the ontologies and their data sources and access them without regard to the heterogeneity and the dispersion of the ontologies. In order to support this require-ment, we proposed an index-based mechanism for ontology-based information integration [2]. According to this method, each RDF and OWL data source in the Semantic Web can be treated as a bag of URIs and Literals. Then, a term in-dex is created to integrate these sources. If we reformulate a conjunctive query into a set of Boolean subgoals, then we can use this index to only access those sources that might be relevant to the query. However, because the term index only indicates if URIs or Literals are present in a document, specific answers to a subgoal of the given query cannot be calculated until the sources are physically accessed -an ex-pensive operation given disk/network latency. In addition, in the real world, the number of sources related to a sub-goal could be so large that it is impossible to load all of them into a reasoner that can then answer the queries. To address these issues, we present a query optimization algorithm for ontology-based information integration using a term index. Given a set of query rewritings that accounts for ontology heterogeneity, this algorithm incrementally selects and pro-cesses sources. Once sources are selected, we use an OWL reasoner to answer queries over these sources and their cor-responding ontologies. The contributions of this paper are as following: The remainder of the paper is organized as follows: In Section 2, we review related work. In Section 3, we describe the query optimization algorithm for ontology-based infor-mation integration using the term index. Section 4 presents the experiments that we have conducted to evaluate the pro-posed algorithm. Finally, in Section 5, we conclude and dis-cuss future work.
Currently, there are mainly three areas of work related with our paper: RDF query optimization, query answering over distributed ontologies and database query optimization.
In RDF query optimization, Hexastore [8] creates all 6-way indexes (SPO, SOP, PSO, POS, OPS, OSP): one for each sorting order of subject, predicate and object. It has been demonstrated that this strategy results in good re-sponse time for conjunctive queries. The major disadvan-tages are that it relies on centralized knowledge bases and that the indexes are quite expensive in terms of space. GRIN [7] developed a novel index for graph-matching queries in RDF. This index identifies selected central vertices and the distance of other nodes from these vertices. However, it is still not clear how GRIN could be adapted for a distributed context. In query answering over distributed ontologies, T. Tran et al. proposed Hermes [6], which translates a keyword query into a federated query and then decomposes this into separate SPARQL queries. A number of indexes are used, including a keyword index, mapping index, and structure index. The main drawback is that it does not account for schema heterogeneity. Stuckenschmidt et al. [5] suggested a global data summary for locating data matching query an-swers in different sources and t he query optimization. How-ever, this method does not consider the heterogeneity of the distributed ontologies. In the database field, Selinger et al. [4] proposed query optimization ideas including using statis-tics about the database instance to estimate the cost of a query evaluation plan, considering only plans with binary joins in which the inner relation is a base relation (left-deep plans) and postponing Cartesian product after joins with predicate. However, in the Semantic Web, it is very com-mon that data from the same relation is spread among many files. In such situations, query plans need to be developed incrementally.
As stated in the introduction, our flat-structure query op-timization algorithm is based on a term index that is used to integrate the distributed and heterogeneous semantic web ontologies and data sources. Basically, the term index is an inverted index, where each term is either a full URI (taken from the subject, predicate or object of a triple) or a string literal value. Due to limited space, we do not present details of the term index. Please see our technical report [1] for details. Given a set of conjunctive query rewritings, our al-gorithm employs a source selection strategy that prioritizes selective subgoals of the query and uses the sources that are relevant to these subgoals to provide constraints that could make other subgoals more selective. This optimization algo-rithm can be combined with any query rewriting algorithm that produces a set of conjunctive queries. We begin by pro-viding a brief overview of the architecture of our system and then discuss the details of our proposed query optimization algorithm.

In our system, the Indexer is periodically run to create the term index for all of the data sources, which are committing to different heterogeneous domain ontologies. These ontolo-gies are integrated by mapping ontologies and the predicates defined in them are spread among many data sources. All ontologies are expressed in OWLII, a fragment of OWL [3]. The Indexer translates the axioms in these ontologies into GAV/LAV rules. Given a conjunctive query, the Reformula-tor uses the domain and mapping ontologies to determine all possible conjunctive query rewritings. In our current imple-mentation, we use the algorithm proposed by Qasem et al. [3] to generate query rewritings. For each rewriting, we em-ploy our proposed optimization algorithm to incrementally collect relevant data sources. Once sources are selected, the Loader reads the selected sources together with their cor-responding ontologies and inputs them into a sound and complete OWL reasoner, which is then queried to produce results. Since the selected sources are loaded in their entirety into a reasoner, any inferences due to a combination of these selected sources will also be computed by the reasoner.
As mentioned earlier, the flat-structure algorithm priori-tizes selective query triple patterns (QTPs) to incrementally select relevant sources and solve queries. Thus, given a con-junctive query, our algorithm first computes the selectivity of each query triple pattern (QTP) contained in this query. We have found that typically the selectivity of a QTP is closely related to the number of sources that the term in-dex determines are relevant to it. Therefore, in the follow-ing parts, when we mention a QTP X  X  selectivity, we mean with respect to the number of relevant sources. Through the comparison of all QTPs X  selectivities, we start with the most selective one and evaluate it by asking the reasoner. Then, the substitutions obtained from last step are applied to those QTPs having a shared variable (join condition in database terminology) with the chosen QTP and their re-spective selectivities are updated correspondingly. Then, we will start with the next most selective QTP and repeat the previous steps. This process is iteratively executed until all QTPs have been evaluated. Finally, the query answers and its relevant sources can be identified.

Figure 1 shows us an example. In this tree, each node consists of three fields: the available substitutions, the QTP node and the selected sources. This sample query includes three QTPs: ? p , swrc : affiliation , lehigh -univ ( qtp ? pap , foaf : maker ,? p ( qtp 2 )and ? pap , akt : has -title ,  X  semantic -web  X  ( qtp 3 ). Using the term index, we might find that these QTPs X  selectivities are 80, 4 million and 75 respectively. Since qtp 3 is the most selective, we load and Figure 2: Flat-structure query optimization algo-rithm evaluate its sources first. Then, we apply the obtained sub-stitutions for ? pap into qtp 1 and qtp 2 . After this step, their selectivities are updated to be 80 and 90 respectively. Then, we start to evaluate the next most selective QTP, qtp 1 ,and apply its substitutions for ? p into qtp 2 . After this step, we only have qtp 2 left and evaluate it. Finally, the numbers of sources selected by each QTP are 75 for qtp 3 ,80for qtp 1 and 9 for qtp 2 . Therefore, the total number of sources iden-tified by the given query is 75+80+9 = 164. Note, in this process, we keep track of all sources that have been loaded, and do not repeat the loading of any source while answering aparticularquery.

The details of our approach are given in Algorithm 1. It takes a conjunctive query rewriting as its input. First, we initialize the selectivity of each QTP contained in sibs by executing a term index lookup (Lines 5-6). Then, we assign the most selective QTP to on and collect its relevant sources (Lines 8-10). Meanwhile, we remove on from sibs (Line 11) and evaluate on to get its substitutions (Lines 12-13). Each substitution  X  is then applied to on  X  X  siblings to constrain their individual selectivity (Line 7). Based on the new selec-tivity, the next most selective node is chosen and the above process is repeated until all QTPs have been processed (Line 3). Finally, the sources collected by q are returned (Line 14).
In this section, we have conducted experiments on both synthetic and real world data sets to evaluate our query opti-mization algorithm. The evaluations are done on a worksta-tion with Xeon 2.93G CPU and 6G memory running UNIX. For both experiments, we use the queries automatically gen-erated by a graph-based synthetic query generator. These queries range from one to four triples, have at most four variables each, and each QTP of each query satisfies the join condition with at least one sibling QTP. For more de-tails, see our technical report [1]. Our implementation of the Indexer uses Lucene to build the inverted index. In all cases, we use KAON2 as our Reasoner.
Our first experiment compares the flat-structure algorithm to our original  X  X on-structure X  algorithm [2] with respect to Figure 3: Average query response time with increas-ing number of unconstrained QTPs query response time, source selectivity and number of in-dex accesses. We conducted this experiment with 20 ontolo-gies, 8000 data sources, and a diameter of 6, meaning that the longest sequence of mapping ontologies between any two domain ontologies is six. It took 21.5 seconds to build the 75.3MB index. We issue 100 random queries and for each query compute the response time, number of selected sources and number of index accesses. We then group queries based on the number of unconstrained QTPs , and compute aver-age for each group. We define an unconstrained QTP as one with variables for both its subject or object, or with the rdf : type predicate and a constant object.

Figure 3(a) displays the comparison of the average query response time for both algorithms. We can see that the flat-structure algorithm performs better than the non-structure algorithm in all cases. Furthermore, we can conclude that the flat-structure algorithm scales better with an increasing number of unconstrained QTPs than the non-structure al-gorithm does. This is because more unconstrained QTPs lead to more opportunities to optimize the query by in-telligently selecting sources. At the same time, because our flat-structure algorithm has a better selectivity shown in Figure 3(b), the query response time does not increase sharply as the non-structure algorithm does. Figure 3(b) displays the comparison of the average number of selected sources for both algorithms. We can see the selectivity of the flat-structure algorithm is roughly linear, while the non-structure algorithm is exponential the number of un-constrained QTPs. Figure 3(c) displays the comparison of the average number of index accesses for both algorithms. Figure 4: Experimental results of the flat-structure algorithm over the real world data set It shows that the flat-structure algorithm has more index accesses than the non-structure algorithm when the num-ber of unconstrained QTPs increases. The reason is that in case of the flat-structure algorithm, one QTP can appear in multiple query rewritings and consequently has a greater number of index lookups.
In this section, we evaluate our system X  X  scalability by using a set of real world data sources. We chose a subset of the Billion Triple Challenge (BTC) 2009 data set, fo-cusing on four collections: http : //data . semanticweb . org/ , http : //sws . geonames . org/ , http : //dbpedia . org and http : // dblp . rkbexplorer . com . The total number of triples in this dataset is 73,889,151, which are scattered in 21,008,285 doc-uments. The size of documents varies from roughly 5 to 50 triples each. In order to enable integration of these hetero-geneous documents, we manually created a set of mapping ontologies. Our index construction time is approximately 58 hours and the size of the resulting index is approximately 18GB. Each document takes around 10ms on average to be indexed. The Lucence configurations are 1500MB for RAMBufferSize and 1000 for MergeFactor, which are the best tradeoff between index building and searching for our experiment.

Because the non-structure algorithm does not propagate constant constraints when answering queries, it cannot scale to the BTC data set since most of our synthetic queries have at least one unconstrained QTP. For example, consider the query Q : { ? x 0 , swrc : affiliation , X  lehigh -univ  X  . ? x akt : has -title , X  Hawkeye  X  . ? x 2 , foaf : maker ,? x akt : full -name ,? x 1 } . For the non-structure algorithm, the number of sources that can potentially contribute to solv-ing ? x 2 , foaf : maker ,? x 0 is 3,485,607, which is far too many to load into a memory-based reasoner. However, the flat-structure algorithm can easily handle this query because the number of sources for the same QTP becomes 114 after join constants are considered. Thus, we only give the exper-imental results of the flat-structure algorithm on BTC data set.

As shown in Figure 4, the flat-structure algorithm scales well in source selectivity and index accesses even though the query response time is exponential. According to the experimental results, for the whole query set, the average query response time is 35.5s, the average number of index accesses is around 4.8 and the average number of selected sources is around 511.3.

Since our algorithm does not yet select all relevant sources with owl : sameAs information, we assume an environment where any relevant owl : sameAs information is already sup-plied to the reasoner. We do this by initializing the KB with the necessary owl : sameAs statements.
In this paper, we proposed a flat-structure query optimiza-tion algorithm for information integration of many sources committing to different ontologies. The experiments demon-strated that our new algorithm is better than our prior work [2] in that it has better query response time, because al-though it requires more index accesses, its source selectivity is less affected by the number of unconstrained QTPs. We have also shown the system scales to reasonable problem sizes, allowing randomly generated queries against 20 mil-lion heterogeneous data sources to complete in 30 seconds. However, there is still signifi cant room for improvement. First, it is relatively more expensive to use our current algo-rithm to compute the set of rewritings for the given conjunc-tive query. We intend to develop a better query optimization algorithm that will further improve query response time and better source selectivity, while also reducing the cost of cal-culating query rewritings. Second, our algorithm needs to be adapted to locate relevant owl : sameAs statements. We believe that solving such problems will lead to a pragmatic solution for querying a large, distributed, and ever changing Semantic Web. [1] Y. Li and J. Heflin. Query optimization for [2] Y. Li, A. Qasem, and J. Heflin. A scalable indexing [3] A. Qasem, D. A. Dimitrov, and J. Heflin. Efficient [4] P. G. Selinger, M. M. Astrahan, D. D. Chamberlin, [5] H. Stuckenschmidt, R. Vdovjak, J. Broekstra, and [6] T. Tran, H. Wang, and P. Haase. Hermes: Data web [7] O. Udrea, A. Pugliese, and V. S. Subrahmanian. GRIN: [8] C. Weiss, P. Karras, and A. Bernstein. Hexastore:
