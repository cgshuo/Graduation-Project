 The cost of reachability query computation using traditional algorithms such as depth first search or transitive closure has been found to be prohibitive and unacceptable in massive graphs such as biological interaction networks, or pathways. Contemporary solutions mainly take two distinct approaches -precompute reachability in the form of transitive closure (trade space for time) or use state space search (trade time for space). A middle ground among the two approaches has recently gained popularity. It precomputes part of the reach-ability information as a complex index so that most queries can be answered within a reasonable time. In this approach, the main cost now is creation of the index, and response gen-eration using it as well as the space needed to materialize the structure. Most contemporary solutions favor a combination of these costs to be efficient for a class of applications. In this paper, we propose a hierarchical index based on graph segmentation to reduce index size without sacrificing query efficiency. We present experimental evidence to show that our approach can achieve significant space savings, and im-prove efficiency. We also show that our index need not be rebuilt for a large class of updates, a feature missing in all other contemporary systems.
 H.3.1 [ Information Storage and Retrieval ]: Content Analysis and Indexing  X  Indexing methods Algorithm, Design, Performance
Given two vertices u and v in a directed graph G = ( V, E ), reachability queries ask whether there is a path from u to  X 
Research supported in part by National Science Foundation grant IIS 0612203.
 v in G ? Reachability in massive graphs has always been a challenging question partly because neither online query processing nor index pre-computation offer a pragmatic solu-tion for this well researched problem. But its applicability in many diverse areas, especially in biological domain (such as metabolic pathways, protein protein interaction networks), has elevated the need for an efficient reachability answering method that not only supports fast query response, but also requires moderate amount of indexing.

Helden and his colleagues [11] presented several impor-tant example queries applicable to biological networks which can be modeled as graph reachability queries. For example, queries such as  X  X ind whether a reaction is influenced by a specific gene product X  . But, traditional reachability query answering approaches are not suitable mainly due to the massive size of biological networks. Generally, Depth First Search (DFS) relies on runtime graph traversal requiring unacceptable query response time for large graphs, though no index is needed. Another approach is to pre-compute and store the entire Transitive Closure (TC) using which it is possible to answer reachability queries in constant time, but it requires quadratic index space making it a least fa-vored approach for biological networks. Nonetheless, most of the existing reachability answering approaches lie in be-tween these two extremes.

The existing approaches are principally based on building a tree cover of G . A tree cover ( T ) is a spanning tree of G which by definition contains all its nodes. Edges present in T are called tree edges, and the remaining edges (of G ) are called non-tree edges. While tree reachability is answered by interval based labeling, to answer reachability prevailing due to the remaining t non-tree edges, either an index (TC) on the t edges has to be created [12], or recursive querying has to be performed at run time [10]. For sparse graphs ( t n , n = | V | ) these approaches work well, but for denser graphs ( t &gt; 2 n ), they require prohibitively large amount of indexing (or recursive querying).

In this paper, we propose a novel method for answering graph reachability that aims to reduce the size of the index and at the same time avoid recursive search during query time. Our approach is similar to other existing approaches in a sense that we also perform interval based labeling for answering tree reachability. But unlike them, we apply a dif-ferent method for answering non-tree reachability. Rather than creating TC on the non-tree edges, we use them to segment the tree cover into multiple autonomous segments, and then maintain a global segment graph ( G s ) to preserve reachability among the partitioned segments. Our motiva-tion lies in the observation that each non-tree edge connects two subtrees in the underlying spanning tree, thus incorpo-rating extra reachability information. By substituting each such subtree with a single node (in the segment graph), we can reduce the number of nodes in which non-tree reacha-bility has to be stored. Through this segmentation, we are also able reduce the number of non-tree edges without losing any reachability information. Considering the space ( O ( t and time ( O ( t 3 )) complexity of TC creation, the reduction in non-tree edges is quite significant. Moreover, using the benefit of the segmentation, updates in the graph can be easily incorporated. In contrast, the entire index structure has to be recomputed in the event of an update in systems such as [10] and [12].
As discussed earlier, existing approaches to graph reach-ability essentially are a tradeoff between pure search and pure indexing. For the sake of brevity and want of space, we briefly discuss related research in this section that includes major approaches such as chain decomposition, compressed transitive closure, and interval based indexing [12, 10, 4]. For the ensuing discussion, let G = ( V, E ) be a graph where n is the number of vertices ( n = | V | ), m is the number of edges ( m = | E | ), and t is the number of non-tree edges. Chain decomposition basically partitions the given graph G into several pair-wise disjoint chains so that each vertex appears in one and only one chain. For answering whether any vertex u reaches a vertex v , we only need to check if u reaches any vertex p in v  X  X  chain such that p appear X  X  before v in the chain. Simon used chain decomposition to compute a compressed transitive closure for answering reachability [9]. But, a critical disadvantage of this approach is that the compression rate is limited by the constraint that each node can have only one immediate successor, making it less than attractive for large biological networks.

Wang et al. proposed an interval based approach [12] capable of answering reachability queries in constant time, but it requires a TC to be built on the non-tree edges. Though, this method (called dual labeling) is suitable for sparse graphs ( t n ), the index size remains uncompressed for dense real world graphs ( t &gt; n ). A similar approach, called GRIPP [10], adapts recursive querying to answer non-tree reachability. While index size and creation time are low for this method, query response time is relatively higher which can be a problem for large biological networks.
Our proposed method can be divided into three parts  X  1) building and labeling the tree cover, 2) segmentation of the graph, and 3) indexing of the segment graph. In our approach, we only focus on directed acyclic graph (DAG) without any loss of generality since a cyclic graph can be converted into a DAG by coalescing each strongly connected component into a node.
As we pointed out earlier, we used interval based labeling of G in order to answer tree reachability. Interval based labeling enforces the condition that a node v (labeled [ c , d ]) is reachable from a node u (labeled [ a , b ]), through tree edges, if the labels of v are completely within the range of the labels of u (i.e. a  X  c &lt; d  X  b ) [10]. We used DFS for building the tree cover ( T ) and for labeling its nodes. We assume that the graph has exactly one root node. For graphs with multiple root nodes, we can make one virtual root node and apply our method.

DFS starts from the root node. During DFS, each node is assigned a preorder and a postorder value. A node v with p incoming edges, where p &gt; 1, is reached p times on edges e , 1  X  i  X  p . The edge e i on which we reach v for the first time is called a tree edge . We assign a preorder value to v and proceed up the depth-first traversal. After all the child nodes have been labeled, v receives its postorder value. Then we reach v for p  X  1 times more. Suppose we arrive at v over an edge e j , e j 6 = e i . Then, e j will be labeled as a non-tree edge. If the non-tree edge is from a node labeled [ a, b ] to a node labeled [ c, d ], then we denote it by a  X  [ c, d ]. For all such edges, we prune the depth first traversal. In this way, each node of the graph will have its unique label and a list of non-tree edges will be formed. Figure 1(b) depicts the interval based labeling of the graph in figure 1(a).
The non-tree edges obtained from the labeling step are ordered in a specific direction. If leftmost DFS is used, the non-tree edges are ordered from right to left, otherwise they will be tree edges. The opposite is true for rightmost DFS. Without any loss of generality, we take the non-tree edges from right to left order (leftmost DFS). For all non-tree edge ( u, v ), we make the subtree rooted at v a new segment (a new node in segment graph G s ), unless it is already in G For each such ( u, v ), we add an edge ( seg( u ) , seg( v ) ) in G If such an edge existed previously, we just keep the record that ( seg( u ) , seg( v ) )  X  G s actually represent more than one edge in G . Lastly, we mark ( u, v ) as a boundary edge for seg( u ) . In figure 1(c), dashed edges represent the non-tree edges. Thus, after segmentation we have three segments S = { A , C , F , K } , S 1 = { R, I, J } and S 2 = { B, D, S, U } . The resulting segment graph is shown in figure 1(d). The the-oretical soundness of the proposed segmentation method is discussed in detail in an extended version of this paper and may be found in [3].
After constructing the segment graph, we perform index-ing on it to answer reachability in G s . Reachability through the tree edges can be answered by applying the interval based labeling method (described in section 3.1) that also lists the non-tree edges of G s . For efficient answering of non-tree reachability, an index on the non-tree edges is created which we shall describe later in this section. We leverage the observation made in [12] that there is a non tree path series of m non-tree edges, i 1  X  [ j 1 , k 1 ], ..., i m such that i 1  X  [ a, b ], c  X  [ j m , k m ] , and i m 0  X  [ j hold, for all 1 &lt; m 0  X  m .

However, testing the condition described above requires iterative searching which can be costly. For efficient search-ing, we compute the TC of the non-tree edges. Thus, given two non-tree links p 1  X  [ q 1 , r 1 ] and p 2  X  [ q 2 , r new edge p 1  X  [ q 2 , r 2], if p 2  X  [ q 1 , r 1 ] hold. For example, in figure 1(c) (though its G , but the same is applicable to G ), there are two non-tree edges, 16  X  [10,15] and 11  X  [1,8]. Now, as 11  X  [10,15], 16  X  [1,8] is also in the transitive closure. This process continues until no new link is found. To sum-marize, node u and v , with label [ a, b ] and [ c, d ] respectively, are reachable iff a &lt; c and d &lt; b , or there is a non-tree edge p  X  [ q, r ] in TC such that p  X  [ a, b ] and c  X  [ q, r ] hold.
When u (source) and v (destination) are in the same seg-ment, we can answer reachability using their interval labels only. Otherwise, we check if there is a path from S segment) to S 2 ( v  X  X  segment) in G s . If not, they are un-reachable. Otherwise, we try to find a boundary edge ( p, q ) of S 1 such that p is reachable from u and ( p, q ) leads a path from S 1 to S 2 . u can reach v iff such a path exists. Algo-rithm 1 captures the process we just described for answering reachability.
 Algorithm 1: Reach( u , v )
To understand the algorithm, let us revisit figure 1(c) and figure 1(d). Intuitively, given two nodes u = A and v = K in the same segment, and their labeling, it is clear that K is reachable from A , i.e., Reach( A , K )=true . Similarly, given u = I and v = J , Reach( I , J )=false . Now, if u = I and v = U are in different segments, then algorithm 1 will find that U  X  X  segment S 2 is reachable from I  X  X  segment S G ). Also, ( I, B ) is a boundary edge and I is reachable from I . So, Reach( I , U )= true .
 Figure 2: Update Flexibility and Non-tree Edge Compression
The primary focus of our method was to use a hierarchi-cal segment graph to reduce the amount of precomputation needed for answering reachability queries. We now present experimental results to show that our method compares well with contemporary approaches and produces significant in-dex size reduction. We used real life networks such as Agro-cyc [7], Vchocyc [7], Hpycyc [7], Xmark [1] and Ecoo157 [7] in our experimental setup. However, as real life networks are not always DAGs, and likely to contain cycles, we em-ployed a preprocessing step to merge the strongly connected components into representative nodes where cycles exist.
As discussed before, our intention was to exploit the fact that each non-tree edge basically connects unreachable sub-trees in the spanning tree. Hence, we represent such subtrees as nodes of the segment graph and store non-tree reachabil-ity in G s , rather than in G (as was done in [12]) which has many more nodes. Figure 3(a) shows the amount of com-pression our segmentation method achieves when compared to dual labeling [12].

The most significant improvement though is the reduction in the number of non-tree edges. This reduction takes place when G s is created from G . If S 1 and S 2 are two segment nodes, and if there is more than one edge (in G ) from vertices of S 1 to the root of S 2 , then those edges are represented by a single edge in G s . From figures 2(a) and 2(b) this claim is quite evident (see [3] for details). Three boundary edges from S 0 to S 1 , ( C, S ), ( F, S ) and ( D, S ), are represented by a single edge ( S 0 , S 1 ) in G s . So, two non-tree edges get reduced when G s is created from G . Dual labeling [12] is not capable of this reduction even after applying the technique in [2] to find the optimum tree cover. Compared to the quadratic space requirement ( O ( n 2 )) of TC in general, this compression is quite large. Figure 3(b) compares the index (TC) size built on G with that of G s and shows that for all datasets, the index created on G s is substantially smaller.
As the construction complexity of TC is O ( n 3 ), the afore-mentioned reduction also expedites the index creation time. Figure 3(c) presents a comparison between our approach and dual labeling [12] based on index creation time. From the figure, it is quite evident that our method outperforms dual labeling [12] due to significantly faster index creation time.
It appears that dual labeling has better query performance than our approach as it creates index for every node of G despite having a greater index size. It was reported that dual labeling requires on average 0.8 ms regardless of the size of the graph [10] 1 . Query time for our method ranges
We must mention here that at the time of writing this article, we did not have access to the GRIPP system, and hence we have used their published performance to compare with our system on identical datasets in table 1. In [3], we from 0.5ms to 5.0ms when tested on real life networks [7, 1, 6, 5, 8]. Though it is slightly higher than dual labeling, we still achieve performance comparable to GRIPP. We present performance comparison of GRIPP with our approach in table 1 using three real life graphs  X  KEGG [6], Reactome [5] and Amaze [8] to show that our approach has similar or better performance than GRIPP.

The new and improved methods of generating large scale interaction data in Life Sciences are making it extremely ur-gent that we develop efficient methods to store, maintain and analyze these datasets. In that direction, our proposed method contributes positively because we can accommodate updates in the interaction graphs more gracefully than most contemporary approaches. If the update is entirely within a segment and it does not impact the tree property, then we just need to relabel the nodes of that segment only, not the entire graph. For example in figure 1(c), if a new child is added to D , we just need to relabel the nodes of S 2 , not the entire graph. If we use the update method in [2], we can even avoid relabeling the nodes of S 2 . In contrast, GRIPP [10] and dual-labeling [12] will have to recompute the entire index structure to incorporate such updates. For updates violating the tree property within a segment, our method needs to recompute reachability just in G s , not in G . Sup-pose, an edge ( S, U ) is added to the graph of figure 1(c). It will be a non-tree edge and will violate the tree property of S . As a result, S 2 will get divided and a new G s (figure 2(c)) will result. Here, S 3 is the segment rooted at node U . Now, we just need to relabel G s , and recompute TC on non-tree edges if necessary. Note that though we added a non-tree edge in S 2 , non-tree edges in G s did not increase (compare figure 2(c) and figure 1(d)). As a result, transitive closure re-computation can be skipped. Above all, as G s expected to have less number of nodes and non-tree edges than G , this update scheme is computationally less costly.
To store, maintain and analyze rapidly growing biological and social network databases, we need novel and improved computational methods. Many such analysis need correct and efficient answering of graph reachability queries. The proposed approach offers an interesting and novel way to address this issue. To our knowledge no previous work has will include a standard performance comparison with all the contemporary systems including GRIPP. approached graph reachability through segmenting of the original graph. We have shown that reduction of the index size as well as its creation time is possible using our ap-proach while maintaining acceptable query response time. We supported our claims experimentally using several real world graphs, especially massive sparse graphs, although re-designing the presented indexing technique to improve query response time remains as one of our future research goals. [1] XMARK: The XML-benchmark project . [2] Agrawal, R., Borgida, A., and Jagadish, H. V.
 [3] Dey, S. K., and Jamil, H. A hierarchical approach [4] Jagadish, H. V. A compression technique to [5] Joshi-Tope, G., et al. Reactome: a knowledgebase [6] Kanehisa, M., et al. The KEGG resource for [7] Keseler, I. M., et al. EcoCyc: a comprehensive [8] Lemer, C., et al. The aMAZE LightBench: a web [9] Simon, K. An improved algorithm for transitive [10] Trissl, S., and Leser, U. Fast and practical [11] van Helden, J., Naim, A., Mancuso, R., and [12] Wang, H., He, H., Yang, J., Yu, P. S., and Yu,
