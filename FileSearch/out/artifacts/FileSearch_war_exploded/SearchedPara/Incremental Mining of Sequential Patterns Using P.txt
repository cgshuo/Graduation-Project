 The goal of Sequential pattern mining is to find frequent subsequences from a sequence database [1]. In many domains, the contents of databases are updated in-crementally. In order to get all sequential patterns, the mining algorithm has to be run whenever the database changes, because that some sequences which were not fre-quent in old database may become frequent in updated database. Obviously, to dis-study of the incremental mining algorithm of sequential patterns. When new se-quences are added into old databases, the incremental mining algorithm minimizes the computational and I/O costs by re-using the information from the previous mining results from old database. 
Currently, several incremental mining algorithms of sequential patterns have been proposed. But most of them are priori-like, which would generate huge set of candi-date sequences when the sequence database is huge. Chen [2] proposed an incre-mental mining algorithm based on PrefixSpan in KDD X 04, named IncSpan. In find complete sequential patterns. They classified these shortcomings and proposed a new algorithm called IncSpan+, which is an improvement of IncSpan. But we find complete sequential patterns. 
In this paper, we first argue that in general, IncSpan+ cannot find complete set of sequential patterns. Therefore, we propose a new incremental mining algorithm of sequential patterns based on prefix tree, called PBIncSpan. PBIncSpan first constructs tinuously scans the incremental element set to maintain the tree structure, using some advanced pruning techniques named width pruning and depth pruning to eliminate the search space. completeness of the IncSpan+. PBIncSpan is proposed in section 5 in detail. We evaluate PBIncSpan in section 6. Finally, this paper is concluded in Section 7 . huge set of candidate sequences, another approach that mining sequential patterns by SPIRIT [6], MEMISP [7]. Accordingly, the general incremental sequential pattern other is projection-based. The former includes GSP+ [8], ISM [9], ISE [10] and growth approach to mine the sequential patterns. It can avoid generating huge candi-date sequences. Hence, IncSpan is proposed for incremental mining over multiple database increments, taking the advantage of PrefixSpan. IncSpan+ makes an im-provement to IncSpan. IncSpan+ claims that it can find complete sequential patterns. But our study finds this is incorrect. We prove this in section 4. a  X  b When an element has multiple items, the results may be deduced by analogy.
 sequence id and s is a sequence. |D| denotes the number of sequences in D. The (abso-The task of sequential pattern mining is to find all sequential patterns in D. terns efficiently in D X  when D updates to D X . 
In general, an incremental mining algorithm should satisfy the following condi-tions [3]:Completeness and Efficiency. sequence into D, denoted as INSERT. and 3)appending a new item or itemset to a exist-ing sequence, denoted as APPEND. Like IncSpan ,IncSpan+ and other algorithms, we consider the updates of database only refer to INSERT and APPEND. Fig.1 shows the detail. We can regard the INSERT operator as a special case of APPEND, for inserting a new sequence is equal to append a new sequence to an empty sequence. 
According to [2], given s=&lt; e 1 ,e 2 ...e n &gt;  X  D, s a =&lt; e X  1 ,e X  2 ...e X  m &gt; called an appended sequence of s. If s is empty, s X = s a, which means insert a new se-quence s a to D. otherwise, it means append a sequence s a to s. Obviously, s X  define LDB ={s X  X s X  IncSpan+ proves that IncSpan provides incomplete results. The pruning technique that Span+ demonstrates that itself is correctness, which means IncSpan+ can find com-plete sequential patterns. The algorithm outline is list as follows [3]: The pruning technique used in algorithm 1 is based on theorem 1 in [2].  X  )*min_support, then there is no sequence p X  having p as prefix changing from infre-quent in D to frequent in D X . The proof of theorem 1 can be found in [2]. According to line (9) (10) in the algorithm of IncSpan+, the pruning is based on theo-rem 1 and can happen in every node. But theorem 1 only guarantees that a sequential infrequent pattern p in D changes into semi frequent in D X . If a pattern p is currently Span+ fails to discover this kind of patterns. So even a sequence p satisfies pletely. The IncSpan+ is not complete. We can illustrate by example 1. Example 1. Sequence database is shown in table 1 1 . Let min_support be 3,  X  be 0.6.  X  frequent or frequent when the support of that sequence is equal to or above 2. Assum-ing an item C is appended in the seqID 2. For a sequence AA, supLDB(AA) = 1 &lt; (1- X  )*min_support=1.2, so PrefixSpan(AA,D X  X AA, u*min_support, FS X , SFS X  ) is not executed. The semi frequent pattern AAC can not be added into SFS X . 5.1 Prefix Tree of a Sequence Database mining sequential patterns in a sequence database using PrefixSpan algorithm. We illustrate how to build prefix tree by an example. Example 2. Sequence database is shown in table 1. Let min_support be 2. The steps of construction a prefix tree w.r.t sequence database in table 1 is shown in Fig.2. 5.2 Width Pruning For every node in prefix tree as shown in Fig.2, its child node comes from the scan of the database remains unchanged when D updates to D X , its child node will not change. Example 3. Sequence database is shown in table 1. Let min_support be 2. Assuming an item C is appended in the seqID 1. The A-projected database and B-projected da-tabase do not change after appending item C. Thus node A, B and their child nodes do when D updates to D X . Definition 1(IASIDS). IASIDS (insert and append sequence id) is a set of seqID w.r.t the sequences in LDB. In example 3, the IASIDS={1}. Theorem 2(width pruning). Let  X  be a prefix of any sequence in D, pSeqId={seqId | seqId child nodes in the prefix tree do not change when D updates to D X . we have to check weather its seqIDs are included in IASIDS. One way to optimize the algorithm is to move the LDB to the top of D X , maintaining a global various min_Seq_ID=size of LDB. When the first sequence id in a projected database, say  X  -and LDB are mutually exclusive, we can use width pruning on node  X  . 5.3 Depth Pruning Definition 2(incremental element set, IES). Let  X  be a prefix of any sequence in D, pSeqId={seqId | seqId a set of items that append to D and their sequence ids are in IPIDS, denoted as IES  X  Theorem 3(depth pruning). Assuming node  X   X  X  parent node does not insert any tree w.r.t D X . Example 4. Sequence database is shown in table 1. Let min_support be 2. Item B and using width pruning, but IES BC ={B,F}, BC X  X  sibling node is sNode ={A, C}. IES BC  X  {C}  X  sNode =  X , so BC can be pruned by using depth pruning, do not need to scan BC-projected database. 5.4 The Algorithm of PBIncSpan Based on width and depth pruning, PBIncSpan is given as follows: Theorem 4(Completeness of PBIncSpan). PBIncSpan outputs the complete set of sequential pattern. than traditional one. Because PBIncSpan is based on PrefixSpan, we compare these two algorithms. We implement PrefixSpan using pseudoprojection. All experiments were conducted on a P4 2.5GHZ PC with 768 megabytes main memory, running windows XP Professional. All algorithms are implemented using C++ STL library with IDE vs2003.net. 
For the real dataset, we get Gazelle from the author of BIBE. This dataset has been dataset contains 29,369 sequences, 87,546 sessions and 1423 items. More detail in-formation could be found in [12]. 
We store the original sequence database D 1 as File 1. When D 1 appends or inserts new sequences, it becomes D 2 and is saved as File 2. The last updated sequence data-inserted and appended sequences have a distribution d. In our test, we let k be four. 
Every time when the sequence database is updated, we run PrefixSpan to mine se-quential patterns from scratch. While PBIncSpan works in incremental way. The results are shown as in Fig 3 with different parameters. Form the figure 3, we can find that when the dataset is small, the performance of time. When sequence database grows large, PBIncSpan outperformed PrefixSpan. tern. Based on PrefixSpan, we use the prefix tree to maintain the sequential patterns. When database updated, we use width pruning and depth pruning to reduce the times of scanning the updated database. But using prefix tree need more storage space when database is huge. Although we can store every branch into disk, but how to maintain a big tree is challenge. Another problem is that depth pruning is based on Apriori prop-erty and is not very effective when the prefix tree has lots of nodes. Further more, the stability of the algorithm should be strengthen. We will try to solve these problems in the future. We would like to thank the anonymous reviewers for their valuable comments and suggestions of this paper. This work is also supported by the Jiangsu Provincial Key Laboratory of Computer Information Processing Technology No.KJS0605. 
