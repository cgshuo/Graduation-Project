
Guoqiang Li 1 , 2 , Lejian Liao 1 , Dandan Song 1 , , Jingang Wang 1 , Fuzhen Sun 1 , Service-oriented architecture has beco me a mainstream technology for business process integration. However, in complex network environments, composite ser-vices may encounter unexpected risks, e. g. network breaking down, or a service unavailability. Therefore, service-oriented systems should be equipped with self-healing ability in order to run without interruption.

The main idea of our approach is that each failure instance can be taken as a failure case. We engage in using previ ous experiences to understand and solve new problems, which is the core ideology of the case-based reasoning (CBR). Its advantages include: (1) proposing solutions to problems quickly, (2) allowing us to make assumptions and predictions based on the past, (3) remembering previous experiences to avoid repeating past mistakes. (4) adapting to changes of the environment [1]. To the best of our knowledge, our work is the first one to use CBR in the service adaptive domain.

The remainder of this paper is struct ed as follows. In Section 2 we present the related work. The self-healing frame work is described in Section 3. Section 4 sets forth a case representation, a retrieval algorithm and a reuse approach in detail. In Section 5 we pres ent experiments of our work. At last, in Section 6 we discuss conclusion and future work. Although WSBPEL 1 specifies business processes behavior as a standard, its fault-handling mechanism is limited as it is difficult for users to consider the dy-namic information of services and their running environment in advance. Many works extended BPEL engine to enhance their fault-handling capabilities. A multi-layered control loop is proposed in [2], which focuses on the framework structure. VieDAME [3] monitors BPEL process according to Quality of Service (QoS) and replaces existing partner services based on various strategies. In [4], AOP (aspect-oriented programming) i s used to extend the engine ActiveBPEL by using ECA (event-condition-action) rule paradigm. In [5], Web service Re-covery Language is defined inspired by the ECA rule paradigm with emphasis on the process recovery. Similarly, in [6], ECA rules are designed to change the component X  X  states according to the fault events. In addition, vital and non-vital components are distinguished to express the importance of activities in the workflow. In Dynamo [7] and DISC [8], JBOSS rule and EC (event calculus) model are used respectively. But in the above mentioned works, it is difficult for designers to design the complete set of rules and event models before the process execution. Our approach can automatically generate the failure cases on the basis of the fault information. With this advantage, our approach is easier to be accepted by the users.

When QoS constraints are violated durin g the execution, the problem of select-ing supplementary service is formalized as a mixed integer linear programming problem in [9], where negotiation techniques are exploited to find a feasible so-lution. In [10], a staged approach generates multiple workflows for one template (abstract workflow), and some workflows are selected as an IP optimization problem by considering QoS parameters. In [11], a reconfigurable middleware is proposed, covering the whole cycle of adaptation management including moni-toring, QoS analysis and substitution-based reconfiguration. In [12], failures are classified into several categories from the perspective of a service composition. Then process reorganization, substitution and retrial/data mediation are pro-posed to react to the failures. In [13], a region-based reconfiguration algorithm is designed to minimize the reconfiguration cost. Supplementary services are se-lected as a backup source for recovery by using the linear programming. In [14], DSOL re-planning technique is leveraged by Q-DSOL to optimize the orches-tration supporting QoS in presence of faults. Different from previous works, our chief consideration is on the selection of adaptive action according to the typical fault information considering QoS constraints. We carry on the candidate chain search based on the similarity using pre vious experiences as much as possible. There are three parts in our framework. The first part is the business process which achieves user X  X  requirements. The framework is shown in Figure 1. The second part extractor gets the fault information (FIN), services X  functional in-formation (FI) and non-functional information (NFI) which are passed to the third part case-based reasoner. After reasoning, a case with solution (CWS) is returned to the business process and the satisfied solution keeps the process running forward rightly. A case without solution (CWOS) is viewed as a new fault. We assume that fault information has been caught using some method(e.g. AOP). The reasoning pseudo code is presented in Algorithm 1.
 Algorithm 1. Implementation of CBR Suppose there is a case base CB = ( C 1 , C 2 , C 3 ) and a services composition SC = { all services by using sequence, condition and loop structures. QoSC denotes the user X  X  constraints about QoS. So, our task is to find a case C i whose solution can deal with a failed service S j and satisfy QoSC simultaneously. 4.1 Case Representation In our approach, FI and NFI information can be easily extracted from WSDL files. FIN is represented by using the HTTP status codes as in [15]. The case symptoms (CS) can be described as a t riple: CS = (FI, NFI, FIN), where FI = (input, output), NFI = (availability, cost, successability, response time), FIN = (fri, nfri). Their definitions refer to WSBPEL and [15]. Here we only give one part as follows: 1. functional information(FI) 2. nonfunctional information(NFI) 3. fault information(FIN) We classify adaptive actions into two categories repeat and replace which are commonly used in previous works, e.g.[12]. For example, the code 404 denotes that service is not found, so replace should be chosen. There are 20 standard faults defined in WSBPEL specification where they are distinguished according to whether they are related to input data. For example, the fault  X  X nvalidEx-pressionValue X  is data related, and repeat can be used. Analysis shows only  X  X issingReply X  and  X  X issingRequest X  can be thought as data unrelated.
We construct a case represen tation with solution and solution templates shown in Table 1 and 2 respectively. Codes with the prefix  X  X  X  can be defined by the users in the first column in Table 2. Codes with prefix  X  X  X  come from WSBPEL and the prefix is added by us. The remaining codes come from [15]. The under-lined tasks in template column will be repl aced with a concrete service in Table 2. A new problem is a case without the solutions part of Table 1. 4.2 Retrieval Algorithm In light of our initial study, the case base is stored in a linear list. In real word, we can index the cases according to attr ibutes of the service to improve the retrieval efficiency. Due to the fact that attributes of QoS vary in units, they should be normalized to be [0,1]. A QoS attribute matrix is shown in Eq. (1) same as the one in [16].
 where q ij is in the range [0,1]. So, we use the Euclidean distance to compute two cases X  similarity: The factor  X  k is the weight denoting the user X  X  preference for an attribute of QoS and sum of these factors is 1. C ik comes from the matrix A of C i . 4.3 Reuse Approach After retrieving top N cases, we use the solutions to achieve adaption. Two conditions are considered.
  X  Condition 1: if the adaptive action is repeat , the failed service can be re- X  Condition 2: if the adaptive action is replace , the solution is verified to check Our approach automatically generates two alternatives for one new case. Assume S , S 2 and S 3 occur in the case base corresponding to C 1 , C 2 and C 3 . C 2 is similar to C 1 and its solution is: replace S 2 with S 3 .So, C 3 is also a candidate of C 1 . Even though their similarity may be bigger than the similarity threshold, we think that our method has a great success rate as long as the threshold is as small as possible.

Finally, we transform the validation of solution against QoS requirements into a constraint satisfaction problem. In our paper, it is assumed that the candidate service of the failed service can be found in the case base. The reason is that the business process will return to a correct state by using the compensation handler in WSBPEL. How to implement this compensation mechanism with CBR is a future research topic. The QWS dataset 2 is used in our experiments including 2,507 Web services. We use five attributes: response time, availability, throughput, successability, reliability. We assume all services are functionally equivalent and the services composition uses sequential structure including 20 services. We record the com-parison times(CPT) about the failed services which are generated randomly.
We build the case base only using the first 2400 services. In the first experi-ment, we do not limit the search step ( SS ). The results in Figure 2(a) show that CPT is not proportional to the number of failed services. We can see that the CPT is very high at point 8 and 10, where the CPT of point 10 is 938.2 because there are 30% of found services coming from the remaining 107 services. So, it is very important to build a case base as completely as possible.

In the second experiment, two condition s are compared: step-limited and step-unlimited. The latter is our reuse approach and the value of SS is equal to 5. In Figure 2(b), we can see that the CPT of step-unlimited is lower than that of step-limited. In particu lar, when there are 9 faile d services, the comparison times reduce 26 times. So, our method takes less time to achieve the adaption.
At last, we make a further study on the influence on CPT by different search steps . In Figure 2(c), the results show that the CPT can be reduced significantly with the increase of search steps. But, it does not mean that the bigger steps are better. For example, when SS is equal to 4 and 5, the comparison times are very close. So, in practice, we should determ ine a proper value of the search steps. We presented a framework by means of the c ase-based reasoning. This framework can dynamically adapt to the failure of co mposite services efficiently. According to the principle of the case-based reasoning, we focus on the developments of the case representation, the retrieval algorithm and the reuse approach. Experiments are conducted to show the effectiveness of our approach with real dataset.
In practice, the case base may become very large. So, how to maintain the base will be a challenge to use this method in the future. An interesting research direction is to determine how the efficien cy of our approach is affected by complex services composition structures.
 Acknowledgment. This work is funded by the National Program on Key Ba-sic Research Project(973 Program, Grant No.2013CB329605), Natural Science Foundation of China (NSFC , Grant Nos. 60873237 and 61003168).
 We are very grateful to Qusay H. Mahmoud for providing the QWS Dataset.
