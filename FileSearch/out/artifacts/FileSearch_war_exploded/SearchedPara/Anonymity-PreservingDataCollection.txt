 Protection of priv acy has become an imp ortan t problem in data mining. In particular, individuals have become increas-ingly unwilling to share their data, frequen tly resulting in individuals either refusing to share their data or pro viding incorrect data. In turn, suc h problems in data collection can a ect the success of data mining, whic h relies on sucien t amoun ts of accurate data in order to pro duce meaningful re-sults. Random perturbation and randomized resp onse tech-niques can pro vide some level of priv acy in data collection, but they have an asso ciated cost in accuracy . Cryptographic priv acy-preserving data mining metho ds pro vide good pri-vacy and accuracy prop erties. However, in order to be ef-cien t, those solutions must be tailored to speci c mining tasks, thereb y losing generalit y.

In this pap er, we prop ose ecien t cryptographic tech-niques for online data collection in whic h data from a large num ber of resp onden ts is collected anon ymously , without the help of a trusted third part y. That is, our solution allo ws the miner to collect the original data from eac h resp onden t, but in suc h a way that the miner cannot link a resp onden t's data to the resp onden t. An adv antage of suc h a solution is that, because it does not change the actual data, its success does not dep end on the underlying data mining problem. We pro vide pro ofs of the correctness and priv acy of our so-lution, as well as exp erimen tal data that demonstrates its eciency . We also extend our solution to tolerate certain kinds of malicious beha vior of the participan ts.
 E.3 [ Data ]: Data Encryption Algorithms; Securit y.

This work was supp orted by the National Science Founda-tion under Gran t No. CCR-0331584.
 data. Warner prop osed randomized resp onse techniques, to-gether with statistical techniques for reconstructing distri-butions from the perturb ed resp onses [37]. Di eren t ran-dom perturbation metho ds have been prop osed and applied in di eren t data mining algorithms [2, 1, 12, 28, 11, 9]. Ran-dom perturbation is very ecien t, but in general it can in-duce a tradeo between priv acy of resp onden ts and accuracy of the data mining result: the more priv acy eac h resp on-den t has, the less accurate the result of mining is, and vice versa. Although some perturbation techniques lead to good accuracy plus good priv acy in speci c data mining prob-lems, these perturbation techniques would pro duce inaccu-rate results when used in other data mining problems. The priv acy-preserving prop erties of the perturbation techniques are further explored in [21].

Priv acy-preserving data mining solutions have also been prop osed based on cryptographic techniques (c.f. [23, 34, 38, 39]). However, the design of the cryptographic proto col dep ends on the speci c mining task, unless a prohibitiv ely exp ensiv e general-purp ose secure multipart y computation is used [40, 15].

A class of closely related work studies how to measure priv acy in data mining. This includes priv acy de nitions based on con dence interv als [2], based on mutual informa-tion [1], and based on priori and posterior kno wledge [11, 8]. Priv acy de nitions motiv ated by cryptographic notions of con den tialit y are given by Gilburd et al. [13] and Dw ork and Nissim [10], resp ectiv ely.

We note that our problem could be solv ed if an anon ymous comm unication channel were available. However, building an anon ymous channel is a non trivial task. General-purp ose ways to build anon ymous channels include mix net works [3, 24, 29, 20, 18], dining cryptographer net works (DC-nets) [4, 36, 17] and k -anon ymous message transmission [35], all of whic h are still under activ e study . Compared with mix net-works, our work can be view ed as a (non trivial) application of certain techniques in their design to the scenario of dis-tributed data collection, whic h eliminates the burden of in-troducing a set of mix serv ers while keeping analogous secu-rity guaran tees. Compared with DC-nets and k -anon ymous message transmission, our solution pro duces more ecien t results for our setting. For example, the comm unication cost of k -anon ymous message transmission is cubic in the num-ber of users; in comparison, our solutions in this pap er have linear comm unication costs.

Systems like Cro wds [27] and Hordes [22] pro vide practi-cal anon ymit y for web access without assuming an existing anon ymous channel. Similarly , our work pro vides anon ymit y for data collection without assuming an existing anon ymous channel. However, Cro wds and Hordes assume eavesdrop-pers involved are local (i.e., can only eavesdrop comm uni-cations within one hop). They do not guaran tee anon ymit y when an adv ersary is able to eavesdrop comm unications in the entire system. In con trast, our solutions in this pap er can work against global eavesdropp ers.

In con trast to our setting, work on k -anon ymization [32, 31, 30, 7] deals with the complemen tary problem of ensuring that data does not rev eal the iden tity of the data sub ject, by pro cessing a database table to de-asso ciate priv acy-sensitiv e attributes from the corresp onding iden ti ers. We note that the goal of k -anon ymization is somewhat di eren t: in k -anon ymization, making the data anon ymous is the target, but how it is comm unicated to the data miner in the rst to be sim ultaneously online. 1 Our requiremen t is that eac h resp onden t should be \hidden" in the N resp onden ts in her group. In other words, the miner should get N pieces of data from a group, but should not kno w whic h piece came from whic h group mem ber.

In the sequel, we restrict our discussion to one group of resp onden ts and denote the N resp onden ts in this group by 1, . . . , N . We assume that there is a priv ate and authen ti-cated comm unication channel between eac h resp onden t and the miner. (Note that suc h comm unication channels can be implemen ted using standard proto cols like SSL and IPSec. We do not go into details of the implemen tation of chan-nels in this pap er.) Although comm unication channels be-tween resp onden ts may exist in some practical situations, to mak e the problem as general as possible, we do not assume their existence in our problem. Figure 1 illustrates the re-sulting layered architecture of our solution. Our anon ymit y-preserving data collection solution runs over any priv ate and authen ticated channels between resp onden ts and miner, and the miner can use any data mining tools thereafter.
We denote by d i the piece of data owned by resp onden t i , whose length is bounded by a securit y parameter . There are two possible ways for the miner to violate resp onden t i 's anon ymit y: either d i con tains some information about resp onden t i (lik e resp onden t i 's iden ti er, telephone num-ber, or zip code) and by looking at this information the miner is able to asso ciate d i with resp onden t i , or during the data collection pro cess the miner observ es that d i comes from resp onden t i . As noted before, in this pap er we focus on the second possibilit y. In particular, we assume that d i does not con tain information that can be used to asso ciate it with resp onden t i ; 2 in this case, resp onden t i will remain anon ymous as long as the data collection pro cess preserv es her anon ymit y.
 Anon ymit y-Preserving Data Collection (This paper)
In this pap er, we allo w for the possibilit y that some of the resp onden ts may be corrupted and colluding with the miner. Informally , the data collection pro cess preserv es eac h hon-est resp onden t's anon ymit y if, when we arbitrarily switc h the data between honest resp onden ts, the miner (with the help of dishonest resp onden ts) cannot see any di erence in the data collection pro cess. Mathematically , let be an ar-the result of arbitrarily switc hing data between resp onden ts. We further require that ( i ) = i for any corrupted resp on-den t i , whic h means only the honest resp onden ts' data are switc hed. The anon ymit y requiremen t is that the miner can-
Even this requiremen t can be remo ved if certain memb ers of the group (called \leaders" in our solutions) remain on-line until the data collection pro cedure in this group is com-pleted.
This can be achiev ed by having resp onden t i remo ve from her submitted data any information related to her iden tity. have been used extensiv ely in mix net works, e.g., [24, 29, 20, 18].

Let G ( j G j = q , where q is a large prime) be a cyclic group in whic h the discrete logarithm is hard 3 , and let g be a gen-erator of G . The ElGamal encryption scheme uses a key pair ( x; y ) suc h that y = g x mo d q , where x is a priv ate key and y is a public key 4 . In this scheme, to encrypt a message M using the public key y , one computes C = ( M y r ; g r ), where the exp onen tiations are done mo dulo q and r is chosen uni-formly at random from [0 ; q 1]. (Throughout the pap er, all exp onen tiations are mo dulo q .) To decrypt the ciphertext C using the priv ate key x , one computes M = C (1) = ( C (2) ) x , where C (1) and C (2) denote the rst and the second com-ponen ts of C , resp ectiv ely. It has been sho wn in [33] that (under standard complexit y-theoretic assumptions,) the El-Gamal encryption scheme is secure in the sense of semantic security . (See [16] for the de nition of seman tic securit y).
In the ElGamal encryption scheme, one cleartext has man y possible encryptions, since the random num ber r can tak e on man y di eren t values. ElGamal supp orts rerandomization, whic h means computing a di eren t encryption of M from a given encryption of M . A related operation is perm utation of the order of items, whic h means randomly rearranging the order of items. If we rerandomize and perm ute a sequence of ciphertexts, then we get another sequence of ciphertexts with the same multiset of cleartexts but in a di eren t order. Looking at these two sequences of ciphertexts, the adv ersary cannot determine any information about whic h new cipher-text corresp onds to whic h old ciphertext.
 In our solution, t of the N resp onden ts act as \leaders". Leaders have the special dut y of anon ymizing the data. At the beginning of the proto col, all resp onden ts encrypt their data using a public key whic h is the pro duct of all leaders' public keys. Note that the priv ate key corresp onding to this public key is the sum of all leaders' priv ate keys; without the help of all leaders, nob ody can decrypt any of these encryp-tions. The leaders then rerandomize these encryptions and perm ute them. Finally , the leaders join tly help the miner to decrypt the new encryptions, whic h are in an order inde-penden t of the original encryptions.

For notational con venience, we assume in the sequel that the leaders are resp onden ts 1 through t . In practice, the choice of leaders can be arbitrary or can be dep enden t on the application.
Eac h resp onden t i has a key pair ( x i ; y i ) ( x i 2 [0 ; q 1], y i 2 G ) suc h that y i = g x i in G . (All computations throughout this pap er tak e place in G ). Here, the public key y i is kno wn to all participan ts, while the priv ate key x i is kept secret by resp onden t i . In the sequel, let
The discrete logarithm problem is a standard computa-tional problem used in cryptograph y. Man y cryptographic tools are based on the assumed hardness of the discrete log-arithm.
Throughout this pap er, by \key" we mean a cryptographic key rather than a database key. 2, ( C 1 ; : : : ; C N ) represen ts the encryptions of a perm utation of ( d 1 ; : : : ; d N ). Since 1 ; : : : ; d 0 N ) is a perm utation of ( d 1 ; : : : ; d N ).
Theorem 3. The protocol of Section 3.3 preserves the anonymity of each honest respondent against the miner and t 1 corrupte d respondents in the semi-honest model.
Proof. By con tradiction. Assume that this proto col does not preserv e the anon ymit y. Based on this proto col, we give a probabilistic polynomial-time algorithm that distinguishes the ElGamal encryptions of two di eren t cleartexts, whic h con tradicts the well kno wn result that ElGamal is seman ti-cally secure.

Clearly it suces to consider the case in whic h all the t 1 corrupted customers are leaders. The above assump-tion of not preserving anon ymit y means that there exist ( d 1 ; : : : ; d N ), a perm utation on f 1 ; : : : ; N g suc h that 8 i 2 I; ( i ) = i , a probabilistic polynomial algorithm D , and a polynomial f () suc h that for in nitely man y , Now we use a hybrid argument (see [14]): since is a per-mutation on f 1 ; : : : ; N g suc h that 8 i 2 I; ( i ) = i , we can decomp ose it to a num ber of simple perm utations where eac h simple perm utation only switc hes the order of two ele-men ts outside I (that are not equal). Formally , there exist perm utations 1 ; : : : ; m ( m &lt; N ( t 1)) on f 1 ; : : : ; N g suc h that for j = 1 ; : : : ; m , 8 i 2 I; j ( i ) = i and that De ne and for j = 1 ; : : : ; m , Then clearly , By Equation 3.1, we kno w there exists j 2 [0 ; m ] suc h that and sim ulates the ciphertexts ( C 1 ; : : : ; C N ) at the end of The corresp onding sim ulated messages and coin ips can be easily computed from these sim ulated ciphertexts.

In Phase 3, the sim ulated messages and coin ips can be easily computed from the sim ulated ciphertexts ( C 1 ; : : : ; C N ) at the end of round t in Phase 2 together with their decryp-
Applying D to the views of the adv ersary generated in the sim ulated executions, A can compute and where D ( e ) denotes the decryption of e . If o 1 = 1 and o 2 = 0, A outputs 1; if o 1 = 0 and o 2 = 1, A outputs 0; otherwise A outputs a uniformly random bit.

Now we analyze the probabilities of outputing 1 with in-put ciphertext of d ` or d ` . For con venience, let and When the input ciphertext is an encryption of d ` , the prob-abilit y that we have output equals 1 is Pr[ A ( d ` ) = 1] = p 1 (1 p 2 ) + p 1 p 2 = 2 + (1 p 1 )(1 p 2 ) = 2 : When the input ciphertext is an encryption of d ` , the prob-abilit y that we have output equals 1 is Pr[ A ( d ` ) = 1] = p 2 (1 p 1 ) + p 2 p 1 = 2 + (1 p 2 )(1 p 1 ) = 2 : Com bining the above two equations, we have The last inequalit y is due to Equation 3.3. However, this con tradicts the seman tic securit y of ElGamal.
In our proto col, the computational overhead of a non-leader resp onden t is 2 mo dular exp onen tiations. The ma jor computational overhead of a leader is 3 N + 2 mo dular ex-ponen tiations. The ma jor computational overhead of the miner is N t mo dular multiplications and N mo dular divi-sions. The overall comm unication is at most (6 t + 2) N bits.

To measure the eciency of our proto col in practice, we implemen ted it using the Op enSSL libraries 5 and measured the computational overhead. Since the time spent on com-munication highly dep ends on the net work bandwidth, we
Available at http://www.openssl.org . did not measure the comm unication overhead in our exp eri-men ts. In our exp erimen ts, the length of cryptographic keys is 1024 bits. The environmen t used is the NetBSD operat-ing system running on an AMD Athlon 2GHz pro cessor with 512M memory .

We measure the computation times of the three types of participan ts: regular (i.e., non-leader) resp onden ts, leaders, and the miner. For eac h of these times, we measure how it varies with di eren t N and t . All our exp erimen tal results are consisten t with our theoretical analysis.

Figure 2 illustrates our measuremen ts of a regular resp on-den t's computation time: it is alw ays about 15ms regard-less of N and t . Figure 3 illustrates our measuremen ts of a leader's computation time: it is linear in N and does not dep end on t . For a typical scenario where N = 20, the computation time of a leader is about 0 : 47 seconds. Fig-ure 4 illustrates our measuremen ts of the miner's computa-tion time: it is linear in both N and t . For a typical scenario where N = 20 and t = 3, the computation time of the miner is about 40ms.
In this section, we extend our solution to a mo del in whic h the miner is malicious and the corrupted resp onden ts are still semi-honest. In Section 5, we study the case in whic h the corrupted resp onden ts may beha ve maliciously .
Recall that a malicious participan t can deviate from the proto col arbitrarily . It is more dicult to preserv e anon ymit y when the miner is malicious. For example, the miner may choose two resp onden ts i and j and replace the encryption of d j with the encryption of d i . When the proto col nishes, there will be a piece of data with two copies. The miner can then easily link this piece of data to resp onden t i . To disal-low suc h beha vior and force the miner to follo w the proto col, we use a well-kno wn cryptographic tool, digital signatur es , as we now describ e.
A digital signature scheme allo ws eac h participan t to gen-erate a signature on her message using her priv ate key. Any-body can verify this signature using her public key, but it is infeasible for any other part y to forge her signature. For-mally , we denote by s = S x ( M ) a signature on message M using priv ate key x . We denote by V y ( M; s ) the veri cation function of digital signature using public key y . Thus, for any key pair ( x; y ) and any message M we have Furthermore, without kno wing x it is infeasible to forge a digital signature s suc h that V y ( M; s ) = accept .
Note that in our solution in the semi-honest mo del, eac h message sen t from the miner to any resp onden t originally came from a resp onden t|the miner only forw ards the mes-sage. Therefore, if the original sender of the message signs it and the receiv er of the message veri es the signature, then a cheating miner who deviates from the proto col can be de-tected.
This proto col assumes that eac h resp onden t i has another and y 0 i is a public key), in addition to the key pair ( x i ; y i )
The only di erence between this proto col and the proto col in the semi-honest mo del is that her, messages are signed and signatures are veri ed. Consequen tly, when all parties follo w the proto col, the miner nally obtains a perm utation of ( d 1 ; : : : ; d N ).

This proto col preserv es the anon ymit y of eac h honest re-sponden t against a malicious miner, because if the miner drops or tamp ers with any message to any resp onden t, the resp onden t will detect it (by chec king the num ber of mes-sages and verifying the signatures).
In this proto col, the computational overhead of a non-leader resp onden t is 2 mo dular exp onen tiations and 1 sign-ing operation. The ma jor computational overhead of a leader is 3 N +2 mo dular exp onen tiations, N +1 signing operations and 2 N + 1 veri cation operations. The ma jor computa-tional overhead of the miner is N t mo dular multiplications and N mo dular division. The overall comm unications are at most (6 t + 2) N + (4 t + 1) 0 N bits, where 0 is the length of a digital signature, typically 512 or 1024 bits.
We also implemen ted this proto col and measured the com-putation times in the environmen t describ ed in Section 3.6. The digital signature scheme we use is DSA and the length of eac h signature is 512 bits.

Figure 5 illustrates our measuremen ts of a regular resp on-den t's computation time: it is alw ays about 16ms regardless of the values of N and t . Compared with 15ms for the proto-col in the semi-honest mo del, the increase in computational overhead is minimal. Comp. Time (ms) Figure 5: Regular responden t's computation time with malicious miner
Figure 6 illustrates our measuremen ts of a leader's com-putation time: it is linear in N and does not dep end on t . For a typical scenario where N = 20, the computation time whic h can be carried out nonin teractiv ely (i.e., with only a single message ow): Metho ds to carry out these pro ofs can be found in, e.g., [18].
This proto col extends the proto col in the semi-honest mo del by adding a num ber of ZKPs. In the data submission phase, eac h resp onden t i computes a pro of, z i = PoK ( C i ), pro ving she kno ws the cleartext of C i . Along with C i , resp onden t i sends z i to the miner. The miner forw ards ( C i ; z i ) to all other resp onden ts. Eac h resp onden t veri es the pro ofs sen t by the other N 1 resp onden ts. If any pro of is missing or invalid, the resp onden t aborts the proto col.
In the t -round anon ymization phase, during round i , leader i generates a pro of whic h means the new ciphertexts ( R 1 ; ; R N ) are a per-muted rerandomization of the old ciphertexts ( C 1 ; ; C N ). When leader i sends the new ciphertexts to the miner, she also sends w i . The miner forw ards them to all other re-sponden ts, who verify the pro of. If the pro of is missing or invalid, then the resp onden ts abort the proto col.
In the decryption phase, eac h leader i computes a pro of whic h means p j;i is a partial decryption computed by rais-ing C (2) j to the priv ate key corresp onding to the public key y . Eac h leader i sends the pro of v i along with the partial decryption to the miner, and the miner then forw ard v i with partial decryptions to all other resp onden ts. Eac h resp on-den t veri es the pro ofs. If any pro of is missing or invalid, the proto col is aborted.

In summary , we use ZKP to force the miner and the mali-cious resp onden ts to follo w the proto col. If they do not fol-low the proto col, their malicious beha vior will be detected and the proto col will be aborted.
In this pap er, we prop ose anonymity-pr eserving data col-lection , a new approac h to protect priv acy in data mining. This approac h allo ws a data miner to collect data from a po-ten tially large num ber of resp onden ts but prev ents the miner from nding out whic h resp onden t has submitted whic h piece of data. We presen t three proto cols with pro vable [13] B. Gilburd, A. Schuster, and R. Wol . k-TTP: a new [14] O. Goldreic h. Foundations of Crypto graphy , volume 1. [15] O. Goldreic h, S. Micali, and A. Wigderson. How to [16] S. Goldw asser and S. Micali. Probabilistic encryption. [17] P. Golle and A. Juels. Dining cryptographers [18] P. Golle, S. Zhong, D. Boneh, M. Jak obsson, and A. [19] HIP AA. The health insurance portabilit y and [20] Markus Jak obsson. Flash mixing. In Proceedings of the [21] H. Kargupta, S. Datta, Q. Wang, and K. Sivakumar. [22] B. N. Levine and C. Shields. Hordes -a multicast [23] Y. Lindell and B. Pink as. Priv acy preserving data [24] C. Park, K. Itoh, and K. Kurosa wa. Ecien t [25] Europ ean Parliamen t. Directiv e 95/46/EC of the [26] Europ ean Parliamen t. Directiv e 97/66/EC of the
