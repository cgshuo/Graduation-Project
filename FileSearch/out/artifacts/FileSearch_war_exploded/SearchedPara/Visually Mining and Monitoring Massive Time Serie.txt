 Moments before the launch of every space vehicle, engineering discipline specialists must make a critical go/no-go decision. The cost of a false positive, allowing a launc h in spite of a fault, or a false negative, stopping a potentially successful launch, can be measured in the tens of millions of dollars, not including the cost in morale and other more intangible detriments. The Aerospace Corporation is responsible for providing engineering assessments critical to the go/no-go decision for every Department of Defense space vehicle. These assessments are made by constantly monitoring streaming telemetry data in the hours before launch. We will introduce VizTree, a novel time-series visualization tool to aid the Aerospace analysts who must make these engineering assessments. VizTree was developed at the University of California, Riverside and is unique in that the same tool is used for mining archival data and monitoring incoming live telemetry. The use of a single tool for both aspects of the task allows a natural and intuitive transfer of mined knowledge to the monitoring task. Our visualization approach works by transforming the time series into a symbolic representation, and encoding the data in a modified suffix tree in which the frequency and other properties of patterns are mapped onto colors and other visual properties. We demonstrate the utility of our system by comparing it with state-of-the-art batch algorithms on several real and synthetic datasets. H.3.3 [ Information Search and Retrieval ]: Information filtering, Query formulation, Selection process . H.2.8 [ Database Applications ]: Data mining, Scientific databases.
 Algorithms, Design, Experime ntation, Human Factors. Time Series, Visualization, Motif Discovery, Anomaly Detection, Pattern Discovery One of the crucial responsibilities of The Aerospace Corporation is to provide engineering assessments for the government engineering discipline specialists who make the critical go/no-go decision moments before the launch of every space vehicle launched by the DoD. The cost of a false positive, allowing a launch in spite of a fault, or a false negative, stopping a potentially successful launch, can be measured in the tens of millions of dollars, not including the cost in morale and other more intangibl e detriments to the U.S. defense program. The launch monitoring facilities at Aerospace are similar to the familiar Hollywood movie recreations [26]. There are several rows of work cells, each with a computer display and a headset. Each work cell is devoted to one analyst, for example, propulsion, guidance, electrical, etc. Each display presents some common data (say vehicle location and orientation), as well as data specific to that discipline. The analyst making the engineering assessments has access to data from previous launches and must constantly monitor streaming telemetry from the current mission. Currently, the analysts use electronic strip charts similar to those used to record earthquake shock on paper rolls. However, while these charts illustrate the recent history of each sensor, they do not provide any useful higher-level information that might be valuable to the analyst. To reduce the possibility of wrong go/no-go decisions, Aerospace is continually investing in research. There are two major directions of research in this area.  X  Producing better techniques to mi ne the archival launch data  X  Producing better techniques to visu alize the streaming telemetry Although these two tasks are quite di stinct, and are usually tackled separately, the contribution of this work is to introduce a single framework that can address both. Having a single tool for both tasks allows knowledge gleaned in the mining stage to be represented in the same visual language of the monitoring stage, thus allowing a more natural and intuitive transfer of knowledge. More concretely, we propose VizTree, a time series pattern discovery and visualization system based on augmenting suffix trees. VizTree simultaneously visually summari zes both the global and local structures of time series data. In addition, it provides novel interactive Dr. Keogh is supported by NSF Career Award IIS-0237918 solutions to many pattern di scovery problems, including the discovery of frequently occurring pa tterns (motif discovery) [7, 29, 38], surprising patterns (anomaly det ection) [9, 24, 36], and query by content [11, 15, 21, 34]. The user interactive paradigm allows users to visually explore the time series , and perform real-time hypotheses testing [1, 19]. We employ the widely referenced  X  Overview, zoom &amp; filter, details on demand  X  paradigm of Dr. Ben Shneiderman of the University of Maryland [37]. As we will show in th is paper, our work fits neatly into these principles. We give an overview of the global structure of an arbitrarily long time series in constant space, while we allow the user to zoom in on particular local structures and patterns, and provide details on demand for patterns and regularities that the user has tentatively identified. While there are several systems for visualizing time series in the literature, our approach is unique in several respects. First, almost all other approaches assume highly periodic time series [40, 41], whereas ours makes no such assump tion. Other methods typically require space (both memory space, and pixel space) that grows at least linearly with the length of the time series, making them untenable for mining massive datase ts. Finally, our approach allows us to visualize a much richer sets of features, including global summaries of the differences between two time series, locally repeated patterns, anomalies, etc. While the evaluation of visualizati on systems is often subjective, we will evaluate our system with objective experiments by comparing our system with state-of-the-art batch algorithms on several real and synthetic datasets. The rest of the paper is organized as follows. In Section 2 we review necessary background material a nd survey related work. We introduce our system VizTree in Section 3. In Section 4, we extend the idea to further allow comparison and contrast between two time series. Section 5 contains a de tailed empirical evaluation of our system. We conclude in Section 6. and monochromatic printing. We enc ourage the interested reader to visit [27] to view high-re solution full-color examples. We begin this section by briefly reviewing the most important time series data mining tasks. We will th en consider current visualization techniques and explain why they are unsuited to the problem at hand. For lack of space, this brief introduction to the important time series data mining tasks is necessarily subjective and somewhat domain driven. Nevertheless, these three tasks cover the majority of time series data mining research [6, 7, 9, 11, 15, 18, 22, 24, 29, 30, 31, 38]. Sequence matching is perhaps the most widely studied area of time series data mining [11, 15]. The ta sk has long been divided into two categories: whole matching and s ubsequence matching [11, 21].  X  Whole Matching : a query time series is matched against a  X  Subsequence Matching : a short query subs equence time series While there are literally hundreds of methods proposed for whole sequence matching (see, e.g., [22] and references therein), in practice, its application is limite d to cases where some information about the data is known a priori . Subsequence matching can be gene ralized to whole matching by dividing sequences into non-overla pping sections. For example, we may wish to take a long electrocardiogram and extract the individual heartbeats. This informal idea has been used by many researchers and is also an optional feature of Vi zTree. We will therefore formally name this transformation chunking, and define it below. 
Definition 1 . Chunking : the process where a time series is broken into individual time series by either a specific period or, more arbitrarily, by its shape. The former usually applies to pe riodic data, for example consider power usage data provided by a Dutch research facility (this dataset is used as a running example in th is work, see Figures 3 and 15): the data can be chunked by days, weeks, etc. The latter applies to data having regular structure or repetitive shape, but not necessarily having the same length for each occurrence. Electrocardiogram data are such an example, and they can be separated into individual heartbeats. There is increasing awareness that for many data mining and information retrieval tasks, very fast approximate search is preferable to slower exact search [5]. This is particularly true for exploratory purposes and hypotheses testing. Consider the stock market data. While it makes sense to look for a pproximate patterns, for example,  X  X  pattern that rapidly decreases after a long plateau , X  it seems pedantic to insist on exact matches. As we will demonstrate in Section 5.1, our application a llows rapid approximate sequence matching. In time series data mining and mon itoring, the problem of detecting anomalous/surprising/novel patterns ha s attracted much attention [9, 30, 36]. In contrast to subseque nce matching, anomaly detection is identification of previously unknown patterns. The problem is particularly difficult because what constitutes an anomaly can greatly differ depending on the task at hand. In a general sense, an anomalous behavior is one that de viates from  X  X ormal X  behavior. While there have been numerous de finitions given for anomalous or surprising behaviors, the one given by Keogh et. al. [24] is unique in that it requires no explicit formulati on of what is anomalous. Instead, they simply defined an anomalous pattern as one  X  whose frequency of occurrences differs substantia lly from that expected, given previously seen data  X . Their definition was implemented in an algorithm (called  X  X arzan X ) that was singled out by NASA as an algorithm that has  X  great promise in the long term  X  [17]. As it will become clearer later, a subset of the system that we propose here includes what may be considered a visual encoding of Tarzan. In bioinformatics, it is well doc umented that overrepresented DNA sequences often have biological significance [2, 10, 35]. Other applications that rely heavily on overrepresented (and underrepresented) pattern discovery include intrusion detection, fraud detection, web usage prediction, financial analysis, etc. A substantial body of literature ha s been devoted to techniques to discover such overrepresented patterns in time series; however, each work considered a different definition of pattern [3, 32]. In previous work, we unified and formalized th e problem by defining the concept of  X  X ime series motif X  [29]. Time series motifs are close analogues of their discrete cousins, although the definitions must be augmented to prevent certain degenerating soluti ons. This definition is gaining acceptance, and now being used in animation [4], mining human motion data [38], and several othe r applications. The na X ve algorithm to discover motifs is quadratic in the length of the time series. In [29], we demonstrated a simple technique to mitigate the quadratic complexity by a large constant factor; nevertheless this time complexity is clearly untenable for most real datasets. As we shall demonstrate in Section 5.2, VizTree allows users to visually discover approximate motifs in real time. Time series is perhaps the most common data type encountered in data mining, touching as it does, al most every aspect of human life, including medicine (ECG, EEG data), finance (stock market data, credit card usage data), aerospace (l aunch telemetry, satellite sensor data), entertainment (music, movies) [4], etc. Because time series datasets are often massive (in gigaby tes or even terabytes), time-and space-complexity is of paramount importance. Surprisingly, although the human eye is often advocated as the ultimate data-mining tool [19, 37, 39], there has been relatively little work on visualizing massive tim e series datasets. We have reimplemented the three most refere nced approaches in the literature. Below, we will briefly review them and explain why they are not suited to the task at hand. TimeSearcher [14] is a time series exploratory and visualization tool that allows users to retrieve time series by creating queries. This is achieved by use of  X  X imeBoxes X , which are rectangular query locators that specify the region(s) in which the users are interested within any given time series. In Fi gure 1, three TimeBoxes have been drawn to specify time series that start low, increase, then fall once more. The main advantage of this tool is its flexibility. In particular, unlike conventional query-by-content similarity search algorithms, TimeSearcher allows users to specify different regions of interest from a query time series, rather than feeding the entire query for matching. This is useful when us ers are interested in finding time series that exhibit similar behavior as the query time series in only specific regions. While TimeSearcher and VizTree proposed here both serve as visualization and exploratory tools for time series, their functionalities are fundamentally different. For example, TimeSearcher is a query-by-exampl e tool for multiple time series regions in order to find similar pa tterns. In other words, some knowledge about the datasets may be needed in advance and users need to have a general idea of what is interesting. On the other hand, VizTree serves as a true pattern di scovery tool for a long time series that tentatively identifies and isolat es interesting patterns and invites further inspection by the analyst. The functionality of TimeSearcher for similarity search is implicit in the design of our system: similar patterns are automatically grouped together. Furthermore, TimeS earcher suffers from its limited scalability, which restricts its utility to smaller datasets, and is impractical for the task at hand. Another time series visualization system is cluster and calendar-based, developed by [40]. The tim e series data are chunked into sequences of day patterns, and these day patterns are in turn clustered using a bottom-up clustering algorithm. This visualization system displays patterns represented by cluster averages, as well as a calendar with each day color-coded by the cluster that it belongs to. Figure 2 shows just one view of this visualization scheme. While the calendar-based approach provides a good overview of the data which has some regularity impos ed on it by social or financial dependence on the calendar. This approach is of little utility for data without obvious daily/weekly patterns and/or a priori knowledge about such patterns. In short, th is system works well to find patterns within a specific, known time scal e, while our system aims to discover previously unknown patterns with little or no knowledge about the data. Weber et. al developed a tool that visualizes time series on spirals [41]. Each periodic section of time series is mapped onto one  X  X ing X  and attributes such as color and line thickness are used to characterize the data values. The main use of th is approach is the identification of periodic structures in the data. Howe ver, the utility of this tool is limited for time series that do not e xhibit periodic behaviors, or when the period is unknown. We reimplemented the spiral a pproach and ran it on the power consumption dataset. A screenshot of the resulting spiral is shown in Figure 3 Note that one can clearly visualize the normal  X 9-to-5 X  working week pattern. In addition, one can see seve ral other interesting events. For example, while it is apparent that no one works during weekends in general, on one Saturday in late summer, there was a power demand suggestive of a full days shift. Surprisingly, this idea for visualizing time series predates computers, with elegant hand drawn examples dating back to at least the 1880 X  X  [12, 39]. While the Spiral approach is elegant, it does not meet our requirements for several reasons. As mentioned, it works well only for periodic data (based on the original authors X  claims and our own experiments). More importantly, it requires pixel space linear in the length of the time series; this is simply untenable for our purposes. Our visualization approach works by transforming the time series into a symbolic representation, a nd encoding the data in a modified suffix tree in which the frequency a nd other properties of patterns are mapped onto colors and other visual properties. Before explaining our approach in detail, we will present a simple problem that motivates our work. Two sets of binary sequences of length 200 were generated: the first set by the pseudo-random-number gene rator by the computer, and the second set by hand by a group of volunteers. The volunteers were asked to try and make the bit strings as random as possible, and were offered a prize to motivate them. Figure 4 shows one sample sequence from each set. By simply looking at the original bit strings, it X  X  difficult, if not impossible, to distinguish the co mputer-generated from the human-constructed numbers. However, if we represent them with a tree structure where the frequencies of subsequences are encoded in the thickness of branches, the distinction becomes clear. For clarity, the trees are pruned at depth three. Each tree represents one sequence from each set, and each node in the tree has exactly two branches: the upper branch represents 1, and the lower branch represents 0. The tree is constructed as follows: starting from the beginning of each sequence, subsequences of length three are extracted with a sliding window that slides across the sequen ce one bit at a time. So for the first sequence we get a set of subse quences {(0,1,0), (1,0,1), (0,1,1), ... } . For the tree shown on the left in Figure 4, the branches at any given level have approximately the same thickness, which means that the probabilities of subsequences at any given level are approximately evenly distributed. In contrast, the tree on the right shows that subsequences of alternating 0 X  X  and 1 X  X  dominate the whole sequence. The  X  X otifs X  for the sequence, 101 and 010, can be easily identified, since they appear more frequently than the other subsequences. The non-randomness, which can be seen very clearly in this example, implies that humans usually try to  X  X ake X  randomness by alternating patterns [16]. Undoubtedly, there exist other solutions to uncover these  X  X atterns X  (entropy, Hi dden Markov models, etc.). Nonetheless, what this visua lization scheme provides is a straightforward solution that allows users to easily identify and view the patterns in a way intuitive to human perception. The simple experiment demonstr ates how visualizing augmented suffix trees can provide an overall visual summary, and potentially reveal hidden structures in the data . Since the strings represented in the tree are in fact  X  X ubsequences X  rather than  X  X uffixes, X  we call such trees subsequence trees.
 This simple experiment motivates our work. Although time series are not discrete, they can be discretized with little loss of information, thus allowing the use of suffix/subsequence trees. Our system is partly inspired by Visualysis [25], a visualization tool for biological sequences. Visualysis uses a suffix tree to store the biological sequences and, through the properties of the tree, such as bushiness, branch distribution, etc, and user navigation, interesting biological information can be discovered [25]. Visualysis incorporates algorithms that utili ze suffix trees in computational biology; more specifically, exact sequence matching and tandem repeat algorithms. At a first glance, our visualization system is similar to Visualysis in the sense that it also has the objective of pattern discovery using a tree structure. However, several characteristics that are unique to our application make it more diversely functional than its com putational-biology counterpart. First, although the tree structure needs the data to be discrete, the original time series data is not. Using a time-series discretization method that we introduced in an earlier work [28], continuous data can be transformed into discrete domain, with certain desirable properties such as lower-bounding distance, dimensionality reduction, etc. Second, instead of using a suffix tree, we use a subsequence tree that maps all subs equences onto the branches of the tree. Thus, given the same para meters, the trees have the same overall shape for any dataset. This approach makes comparing two time series easy and anomaly detection possible. In [28], we introduced Symbolic Aggregate approximation (SAX), a novel symbolic representation for time series. It is ideal for this application since, unlike all previously proposed discretization methods for time series, SAX allows lower-bounding distance measures to be defined on the symbolic space. In addition, its dimensionality reduction feature ma kes approximating large dataset feasible, and its ability to convert the data using merely the local information, without having to access the entire dataset, is especially desirable for streaming time series. The utility of SAX has been demonstrated in [28], and the ad aptation or extension of SAX by other researchers further shows its impact in diverse fields such as medical and video [6, 33]. For th ese reasons, we choose to use SAX as the discretization method for the input time series data. Before converting a time series to symbols, it should be normalized. The importance of normalization has been extensively documented in the past [22]. Without normalizati on, many time series data mining tasks have little meaning [22]. After normalization divided into w equal-sized segments; the values in each segment are then approximated and replaced by a single coefficient, which is their average. Aggregating these w coefficients form the Piecewise Aggregate Approximation (PAA) representation of T. Next, to convert the PAA coefficien ts to symbols, we determine the breakpoints that divide the distribution space into  X  equiprobable regions, where  X  is the alphabet size specified by the user. In other words, the breakpoints are determined such that the probability of a segment falling into any of the regions is approximately the same. If the symbols were not equi-probable, some of the substrings would be more probable than others. As a consequence, we would inject a probabilistic bias in the process. In [8], Crochemore et. al. showed that a suffix tree automation algorith m is optimal if the letters are equiprobable. Once the breakpoints are determined, each region is assigned a symbol. The PAA coefficients can then be easily mapped to the symbols corresponding to the regions in which they reside. In [28], the symbols are assigned in a bottom-up fashion so the PAA become clear in the next section, we reverse the assigning order, so the regions will be labeled top-down instead (i.e. the top-most region is labeled  X  X , X  the one below it  X  X , X  and so forth). Figure 5 shows an example of a time series being converted to string acdcbdba . Note the general shape of the time series is preserved, in spite of the massive amount of dimensionality reduction, and the symbols are equiprobable. The discretization technique can be applied to VizTree by calling SAX repeatedly for each subsequence. More specifically, subsequences of specified lengths are extracted from the input time series and normalized to have a mean of zero and a standard deviation of one. Applying SAX on these subsequences, we obtain a set of strings. From this point on, the steps are identical to the motivating example shown in the be ginning of Section 3: the strings are inserted into the subsequence tree one by one. Figure 6 shows a screen shot of VizTree. When the program is executed, four blank panels and a parameter-setting area are displayed. To load a time series data set, the user selects the input file using a familiar dropdown menu. The input time series is plotted in the top left-hand panel. Next to the time series plotting window is the parameter setting area; the analyst can enter the sliding window length, the number of SAX segm ents per window, and select alphabet size from a dropdown menu. Once the parameters are entered, the user can click on the  X  X how Tree X  button to display the subsequence tree on the bottom left panel. smog emissions from a motor vehicle. The length of the time series is 2478. The length of the sliding wi ndow is set to 53; the number of segments (i.e., the depth of the tr ee) is four, and the alphabet size (i.e., the number of children for each node) is four. Each branch represents one pattern . As mentioned in the previous section, we reverse the assigning order of the symbols from bottom-up to top-down. The reason is that when the symbols are arranged this way, it is more consistent with the natural shape of the tree. For example, for any given node, a branch at a higher position denotes segments with higher values. Tr aversing breadth-first from the top-most branch of any given node, the symbols that represent the branches are a, b, c , and d , respectively. Each level of the tree represents one segment (or one symbol ). To retrieve any string, we simply traverse down the appropriate branches. 
Definition 2 . Pattern : a pattern p is the SAX representation of a subsequence in the time seri es, denoted by the string s formed by following any path down the subsequence tree. The frequency of p in time series A is denoted by f(p A ) , which is the number of occurrences of p over the number of all occurrences in A. The frequency of a pattern is encoded in the thickness of the branch. For clarity, the full tree is drawn. Branches with zero frequency are drawn in light gray, while others are drawn in red with varying thicknesses. On the right hand side of VizTree, there are two panels. The upper one shows the zoom-in of the tree show n in the left panel. This is very useful especially for deep and bushy trees. The user can click on any node (on the subsequence tr ee window, or recursively, on the zoom-in window) and the sub-tree rooted at this node will be displayed in this upper panel. The sub-tree shown in Figure 6 is rooted at the node representing the string  X  abxx , X  where the  X  xx  X  denotes don X  X -care since we are not at the leaf level. If the user clicks on any branch, then the actual subsequences having the string represented by this particular bran ch will be displayed in the bottom panel and highlighted in the time series plot window. In the figure, subsequences encoded to  X  abdb  X  are shown. Three parameters need to be dete rmined: the length of the sliding window, the number of segments, and the alphabet size. In [29] we showed the trade-off between th e number of segments and the alphabet size. In general, VizTree works very well even with massive dimensionality reduction, as we will demonstrate in Section 5 (in the experiments we used no mo re than 5 segments). The length of the sliding window is data-depe ndent; however, the user can drag a range over any pattern of intere st on the time series plot window and the window size will be filled in automatically. Subsequence matching can be done ve ry efficiently with VizTree. Instead of feeding another time seri es as query, the user provides the query in an intuitive way. Recall that each branch corresponds to one of the equiprobable regions that are used to convert the PAA coefficients to symbols. The t op branch corresponds to the region with the highest values, and the bottom branch corresponds to the region with the lowest values. Therefore, any path can be easily translated into a general shape and can be used as a query. For example, the top-most branch at depth one (i.e., string  X  axxx  X ) represents all subsequences that start with high values, or more precisely, whose values in the first segment have the mean value that resides in the highest region. In the previous example, the user is interested in finding a concave-down pattern (i.e., a U-shape). This particular pattern, according to the domain experts, corresponds to a change of gears in the motor vehicle during the smog emission test. From the U shape, the user can approximate the query to be something that goes down and comes up, or a string that starts and ends with high branches, with low branches in the middle. As a result, clicking on the branch representing  X  abdb  X  as shown in the figure uncovers the pattern of interest. VizTree provides a straightforward way to identify motifs. Since the thickness of a branch denotes the frequency of the subsequences having the same, corresponding strings , we can identify approximate motifs by examining the subseque nces represented by thick tree paths. A feature unique to VizTree is that it allows users to visually evaluate and inspect the patterns retu rned. This interactive feature is subsequences, such as those that differ by only one symbol. In addition, the user can prune off uninteresting or expected patterns to improve the efficiency of the system and reduce false positives. For example, for ECG data, the motif algorithm will mostly likely return normal heart beats as the most important motif, which is correct but non-useful. Allowing user to ma nually prune off this dominant pattern, secondary yet more interes ting patterns may be revealed. Figure 7 shows such an example. The dataset used here is a real , industrial dataset,  X  X inding, X  whic h records the angular speed of a reel. The subsequences retrieved in the lower right panel have the string representation  X  dacb . X  Examining the motifs in this dataset allowed us to discover an intere sting fact: while the dataset was advertised as real, we noted that repeated patterns occur at every 1000 points. For example, in Figure 7, the two nearly identical subsequences retrieved are located at offsets 599 and 1599, exactly 1000 points apart. We checked with the original author and discovered that this is actually a synthetic dataset composed from parts of a real dataset, a fact that is not obvious from inspection of the original data. The complementary problem of motif discovery is anomaly detection. While frequently occu rring patterns can be detected by thick branches in the Viztree, simple anomalous patterns can be detected by unusually thin bran ches. Figure 8 demonstrates both motif discovery and simple anomal y detection on an MIT-BIH Noise Stress Test Dataset (ECG recordi ngs) obtained from PhyioBank [13]. Here, motifs can be identified very easily from the thick branches; more remarkably, there is one very thin line straying off on its own (the path that starts with  X  X  X ). Th is line turns out to be an anomalous heart beat, independently annotated by a cardiologist as a premature ventricular contraction. While anomalies can be detected th is way for trivial cases, in more complex cases, the anomalies are usually detected by comparing the time series against a normal, reference time series. Anything that differs substantially from this reference time series can signal described in the next section. We have described how global st ructures, motifs, and simple anomalies can be identified by a subs equence tree. In this section, we extend these ideas to further allow the comparison of two time tree, X  and as the name implies, shows the distinction between two time series. The construction of a diff-tree is fairly straightforward with the use of subsequence tree, since the overall tree shape is the same regardless of the strings, provi ded that the parameters selected (i.e., alphabet size, number of segment, etc) are the same. The diff-tree is constructed by computing the difference in thickness (i.e., frequency of occurrence) for each branch. Intuitively, time series data with similar structures can be exp ected to have similar subsequence trees, and in turn, a sparse diff-tree. In contrast, those with dissimilar structures will result in distinctiv ely different subsequence trees and therefore a relatively dense diff-tree. One or two datasets can be loaded to VizTree simultaneously. If only one is loaded, then its subse quence tree will be shown. If two datasets are loaded, the user has the option of viewing the subsequence tree of either one, or th eir diff-tree. The branches in the difference tree are color-coded to distinguish between the overrepresented and underrepresente d patterns. Given two time series A and B, where A is the basis for comparison (the reference time series), and B is the added time series, we can define the following terms: 
Definition 3. Overrepresented Pattern: a pattern is over-represented in B if it occurs more frequently in B than it does in A. 
Definition 4 . Underrepresented Pattern : a pattern is under-represented in B if it occurs more frequently in A than it does in B. 
Definition 5. Degree of Difference : the degree of difference for any pattern p between A and B is defined as follows: Simply stated, D p measures how a pattern (i.e. branch) differs from one time series to another, by computing the difference of frequencies between A and B a nd dividing by the maximum frequency in A and B. If p occurs less frequently in B than in A, then overrepresented and D p &gt; 0. This is the measure en coded in the diff-tree as the thickness of the branch. Currently, discrete co lors are used to distinguish overrepresentation from underrepr esentation: overrepresented patterns are drawn in green (same color as the test time series); underrepresented patterns in blue (same color as the basis time series); and if the frequency is the same, then the branch is drawn in red. However, color intensity can be used to further highlight the degrees of difference. The datasets used for anomaly det ection, constructed independently of the current authors and provided by the Aerospace Corporation for sanity check, are shown in Figure 9. The one on the top is the normal time series, and the one below is similar to a normal time series, except it has a gap in the middle as anomaly. Figure 10 shows a screenshot of the anomaly detection by diff-tree. The tree panel shows the diff-tree between the two datasets. The two thick paths denote the beginning and the end of the anomaly, respectively. This is a very trivial example fo r demonstration purpose. However, the effect is similar for more complex cases. In this section we evaluate (a nd demonstrate) our approach on datasets which are either very intu itive to the average person or have been extensively annotated by domain experts. In particular, we will evaluate our work on human motion data and the power demand data. Note that all datasets used here are available for free from the UCR archive [20]. This experiment incorporates bot h subsequence matching and motif discovery. The dataset used is the human motion data of yoga postures. A model postured yoga rou tines in front of a green screen, and her motion was captured by vari ous sensors. The motion capture is transformed into a time series by computing the aspect ratio of the minimum-bounding rectangle formed around her body. The length of the time series is approximately 26,000 (i.e. there are approximately these many frames in the original video). Suppose we are interested in finding a yoga sequence like the one in Figure 11: Then we would expect the shape of the query to descend rapidly after the first position (the width-to-hei ght-ratio decreases), ascend slowly after the second position, descend again, and finally ascend once more. Assume that we set the num ber of segments to be five (an arbitrary choice), then a reasona ble start would be the branch  X  adxxx . X  Since there are only two paths extending from the node  X  ad , X  the matches are found very quick ly without much refinement in the search space. The result is shown in Figure 12 and the actual yoga sequences for the matches are outlined in Figure 13. The subsequence length is 400 (i.e. a bout 6.5 seconds). As the figure shows, the two sequences are very similar with only very minor distinction. There are several advantages of the approximate subsequence matching by VizTree. One is that this feature is built-in to the application, and it is relatively easy to specify the query without explicitly providing it. More importantly, the system retrieves the results very efficiently since the information is already stored in the tree. With the current state-of-the-art exact subsequence matching algorithms, retrieval is much too slow for a real time interaction. For the motif discovery experiment, we will continue with the previous human-motion example. There are obviously some noticeable motifs such as the long spikes that occur throughout the sequence (see the time series plot in Figure 12). They denote the posture where the model is lying fl at on the ground, when the aspect ratio is at its maximum. However, one of the desirable features of VizTree is that it allows users to visually identify secondary yet more interesting motifs. The matches found in the previous section are such example. We can zoom-in on these subsequences and examine their similarity. From Figure 14 we can see that these two subsequences are indeed very similar to each other. Note that they both have a small dip towards the end of the sequence. However, there is a slight difference there  X  the dip for the firs t sequence occurs before that for the second sequence, and is followe d by a plateau. Examining the motion captures we discover that the dip corresponds to the 6 position shown in Figure 13, right before the model stretched her model held that last position for a longer period of time, thus the plateau following the dip. These subtle differences are difficult to notice without the motif discovery and/or the subsequence matching features in VizTree. For comparison, we ran the fastest known exact motif discovery algorithm [29] . Although the same motif can also be successfully identified, it takes minutes to compute, while VizTree gives instant (less than one second) feedback on the results. Even with the approximate motif discovery algorithm [7], it takes tens of seconds to complete. In addition, the visualization power of VizTree allows the user to see exactly where the motif occurs and how it maps to the original time series. For anomaly detection, we used th e power demand data that was also used in Figure 3. Electricity c onsumption is recorded every 15 minutes; therefore, for the year of 1997, there are 35,040 data points. Figure 15 shows the resulting tree with the sliding window length set to 672 (exactly one week of data ), and both alphabet size and number of segments to 3. The majority of the weeks follow the regular Monday-Friday, 5-working-day pattern, as shown by the thick branches. The thin branches denote the anomalies. The one circled is from the branch  X  bab . X  The zoom-in shows the beginning of the three-day week during Christmas (Thursday and Friday off). The other thin branches denote other anomalies 3 such as New Year X  X  Day, Good Friday, Queen X  X  Birthday, etc. While other anomaly detection algorithms such as the TSA-Tree Wavelet-based algorithm by Shahabi et. al. [36] and the Immunology-based algorithm (IMM) by Dasgupta and Forrest [9] can potentially find these anomalies as well given the right parameters, both are much more computationally intensive. While VizTree requires input of parameters, the results are almost instant. In the contrary, the TSA-Tree takes tens of seconds, and IMM needs re-training its data with every adjustment of parameters, with each training session taking several minutes. This is clearly untenable for massive datasets. In addition to the fast computa tional time, anomaly detection by VizTree does not always require a tr aining dataset. As demonstrated, simple anomalies can be identified as an inverse to the motifs. The pixel space of the subsequence tree is determined solely by the number of segments and alphabet size. In particular, we note that the pixel size of the tree is constant and independent to the length of time series. We have already shown that large amounts of dimensionality reduction do not greatly affect the accuracy of our results (in Section 5.3, the dimensionality is reduced from 672 to 3, a compression ratio of 224-to-1). However, the size of the dataset plays a role in memory subsequences. However, SAX allo ws efficient numerosity reduction to reduce the number of subsequences being included into the tree, in addition to alleviating the problem associated with trivial matches (see below) [23, 29]. In [29] we showed that the best matches for a subsequence tend to be its immediate neighbors: the subse quence one point to the right and the subsequence one point to the le ft. We defined these matches to be the  X  X rivial matches. X  In the smooth regions of the time series, the amount of trivial matches might be la rge. If we include them in any sliding-window algorithms, the trivial matches will dominate over the true patterns due to over-counting, and the results will likely be distorted, or worse, become mean ingless [23]. Therefore, when extracting subsequences from the time series by a sliding window, the trivial matches should be excluded. Different definitions can be used to identify trivial matches. The easiest way is to compare the SAX strings and only record a subsequence if its string is different from the last one recorded. In other words, no two consecutive strings should be the same. Additionally, we can check two strings symbol-by-symbol and consider them trivial matches of one another if no pair of symbols is more than one alphabet apart. This extra check is based on the same idea as the previous numerosity reduction option, that similar subsequences have the same SAX repr esentation. However, it is also likely that similar subsequences do not have exactly the same SAX representations; rather, they might have alphabets that differ by at most one at any given position (i.e. th e values could be very close but reside on different si des of a breakpoint). Furthermore, the second option can be extended to also exclude non-monotonic strings. Depending on the nature of the datasets, users might only be interested in finding patterns with ups and downs. Finally, the ultimate numerosity reduction can be achieved by chunking, which allows no overlapping subsequences. This has been used for many approaches; however, we would like to note that it is only useful if the dataset exhibits re gular patterns, either by shape or by period. For example, if we use chunking for the power consumption data used in Section 5.3, then we get an even more distinctive tree. We proposed VizTree, a novel vi sualization framework for time series that summarizes the global and local structures of the data. We demonstrated how pattern discovery can be achieved very efficiently with VizTree. As mentioned, VizTree will be formally evaluated by The Aerospace Corp in the summer of 2004, and we will incorporate the feedback into the system. We believe that researchers from other sectors of the industry can greatly benefit from our system as well. For example, it could potentially be used for inde xing and editing video sequences. We plan to have domain experts in other fields such as medicine and animation evaluate our system. In the beginning of the paper we mention that the system can be used for monitoring and mining time series data. While we mainly focus on the  X  X ining X  aspect in this paper, we will extend VizTree to accept online streaming data for monitoring purposes. Reproducible Research Statement: All datasets and code used in this work will be freely availabl e. For higher-quality images and more information, please visit Thanks to Victor Zordan and Bhrigu Celly for providing the yoga postures data. 
