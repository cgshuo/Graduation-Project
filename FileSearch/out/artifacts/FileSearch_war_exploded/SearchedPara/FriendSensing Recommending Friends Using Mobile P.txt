 We propose FriendSensing , a framework that automatically suggests friends to mobile social-networking users. Using short-range technologies (e.g., Bluetooth) on her mobile phone, a social-networking user  X  X enses X  and keeps track of other phones in her proximity. FriendSensing processes proximity records using a variety of algorithms that are based on social network theories of geographical proximity and of link prediction. It then returns a personalized and au -tomatically generated list of people the user may know. We evaluate the extent to which FriendSensing helps users find people they know against real mobility and social network data.
 H.3.3 [ Online Information Services ]: Web-based ser-vices.
 Algorithms Social matching systems, recommender systems, Web 2.0
Finding and confirming friends on social-networking web-sites is a tedious and time-consuming task. To automate the process, different ways of recommending friends have been proposed and scrutinized. These are based on either social-networking profiles (e.g., they recommend people wi th shared interests) or audio recordings from collar devices ( e.g., they recommend people with whom one has had lengthy face-to-face contacts). The former requires users to creat e fairly detailed profiles, and is thus nonetheless tedious th an finding friends in the first place. The latter has had so far very limited applicability, as it requires the usage of inva sive technology (i.e., collar devices) for data collection.
Interestingly, a less invasive and more widely available form of data collection exists. This is to simply have mo-bile phones keep their Bluetooth on to track other phones in proximity. Since people usually carry their mobile phones [ 12], this way of collecting data is appealing for its simplicity a nd consequently begs an important research question: can prox -imity data from Bluetooth be used to recommend friends? We demonstrate that the answer is  X  X es X , and we do so by making two main contributions:
To enable (new) members of social-networking websites automatically discover their friends, we have designed the FriendSensing framework. FriendSensing automatically cre-ates personalized recommendations of people a user may know, and it does so in two steps:
Step 1. Logging Encounters -using short-range radio tech-
Step 2. Recommending Friends -colocation records are
We now present algorithms for proximity processing and for network navigation in general terms, and defer a discus-sion about the implications of different architectural depl oy-ments to our evaluation (Section 3).
Once colocation logs have been collected, FriendSensing must filter out irrelevant encounters from relevant ones; that is, for each user A , it must identify which of A  X  X  encounters are likely to be A  X  X  friends. FriendSensing does so by com-puting the probabilities of A befriending other individuals ( A  X  X  friendship probabilities) from proximity data.
Researchers have already suggested ways of computing these probabilities from geographical proximity , based on the intuition that friendship probability increases with g eo-graphic proximity -the closer two individuals are, the like -lier they are to be friends. Kleinberg [7, 8], for exam-ple, modeled the probability of A and B being friends as p ( A  X  B )  X  dist ( A, B )  X  r . That is, the probability of be-ing friends with a person at a distance d decays as d  X  r some power of r (typically r = 2). As later demonstrated by Liben-Nowell et al. [11], the absolute value of geographic dis-tance alone is insufficient to model friendship. To see how, consider that A and B live 500 meter apart: at the very same distance, A and B would likely be next-door neigh-bors in the countryside, while complete strangers in centra l London. This suggests that one also needs to consider pop-ulation density . Libel-Nowell et al. [11] did so in a simple way -they replaced the absolute distance dist ( A, B ) with a ranked distance : p ( A  X  B )  X  1 / ( rankDist A ( B ) + 1). The denominator is A  X  X  rank of B , which is the number of people who are closer to A than B is, and it is expressed as: In other words, the probability of A befriending B depends on the number of people within distance dist ( A, B ). The more dense the population between A and B , the lower B ranks. Consequently, at the same distance, B is more likely to befriend A in the countryside than in central London. This model was successfully evaluated on half a million pro-files collected from the LiveJournal blogging website, sug-gesting that geography is a good predictor of friendship. However, geographical information is not widely available on mobile phones; should localization technology like GPS become a commodity, it would still fail to capture indoor encounters (e.g., at home, in the office, on the tube, in the pub). We thus need to reformulate the problem based on  X  X obile phone proximity X .

Using mobile phones, we keep track of: how many times a user A has met (e.g., it has been within Bluetooth range of) user B (frequency freq ( A, B )), and how much time it has spent with B (duration dur ( A, B )). So we now need to express the friendship probability as a function of fre-quency or duration. One plausible way of doing so is to consider that the probability of A befriending B increases with freq ( A, B ) and with dur ( A, B ) respectively. However, as with geographical information, we cannot consider fre-quency or duration alone to compute friendship probabil-ities, because both of them are non-uniformly distributed. Indeed, individuals do have skewed mobility patterns; this has been shown not only for college students [4] (against whose movements we will run our evaluation), but also for conference attendees [2], and for hundreds of thousands of mobile users [5]. Rather than using absolute frequency and duration values, we have thus taken their rank. From fre-quency , the friendship probability becomes: rankF req A ( B ) = |{ C : freq ( A, C ) &gt; freq ( A, B ) }| + 1 Consequently, the probability of A befriending B depends on the number of people who have met A more frequently than B has done.

Similarly, by replacing frequency with duration , the friend-ship probability becomes: rankDur A ( B ) = |{ C : dur ( A, C ) &gt; dur ( A, B ) }| + 1 Again, the probability of A befriending B depends not on freq ( A, B ) itself but on the number of people who have met A for longer than B has done.

From the proximity logs, the above friendship probabil-ities can be computed and used to infer a weighted social network of encounters : each mobile device is represented as a node, and a link is added between any pair of individu-als who have met at least twice (this is to remove encoun-ters caused by chance). Each link A  X  B is then weighted using either friendship probability p ( A  X  B ) or friendship ranking (i.e., A  X  X  ranking of B , which is computed from the friendship probability itself). We explain when to opt for probabilities and when for ranks next. Once the network of encounters has been computed, Friend-Sensing processes it to compute personalized lists of peopl e each user may know, that is, to predict which of A  X  X  encoun-ters are likely to be A  X  X  friends. In the literature of social networks, this problem is called  X  X ink prediction X  and dif-ferent methods have been proposed to tackle it [10]. These methods assigns a score ( A, B ) to a pair of nodes ( A, B ) fol-lowing one of two possible strategies: Shortest Path -The score between a pair of nodes A and Markov Chain Algorithms -For this class of algorithms,
The FriendSensing framework thus offers eight strategies for recommending friends, derived from combining a strat-egy for processing proximity data into friendship probabil -ities (either frequency or duration ), with one of the link-prediction algorithms ( shortest path , PageRank , HITS , and KMarkovChain ).
The goal of FriendSensing is to recommend to its users people they may know. To ascertain the effectiveness of FriendSensing at meeting this goal, we set up a simulation driven by real data collected as part of the Reality Min-ing project at MIT [4]. The MIT traces contain coloca-tion information from 96 subjects (staff and students) at the MIT campus over the course of the 2004-2005 academic year, to whom Bluetooth-enabled Nokia 6600 phones were given; colocation information (roughly 10 meters range) wa s collected via frequent (5 minute) Bluetooth device discove r-ies. Beside providing mobility traces, the MIT dataset also implicitly includes information about the users X  social ne t-work. In fact, it logs both the text messages sent, and the phone calls made by each phone in the study. Using this information, we have extracted a social network whereby a link between user A and user B is created if A sent a text message or made a phone call to B .

In our simulations, we used the MIT mobility traces to log encounters; using these logs, we ran FriendSensing and computed friends X  recommendations. We then compared these recommendations with the MIT actual social network (largest connected component) and computed the fraction of the social network X  X  ties correctly predicted by FriendSen s-ing. We refer to this fraction as  X  good recommendations X  g , and we study how g varies while we increase the percentage r of people recommended to each user from 0 to 100%.
To study the effect of the colocation processing strategy separately from the link prediction strategy, we performed two sets of experiments. (1) Frequency vs. Duration. In the first set of exper-iments, we aimed to compare the effectiveness of frequency as a colocation processing strategy, as opposed to duration . We did so by disabling any link propagation strategy, and by using the ranking produced by the frequency / duration colocation processing strategies locally. This is equival ent to running FriendSensing on people X  X  mobile devices, without reporting their proximity logs to the social-networking we b-site (where the full FriendSensing approach, including lin k propagation, could be executed). Figure 1(a) plots g (good recommendations) versus r (recommended people) for these strategies with respect to a random selection of people to recommend. For the random strategy, g increases linearly with r -the random strategy fluctuates around a straight line (dashed in the figure). That is because the more people are recommended, the likelier to get some of them right. At the extreme of r = 100% (all users have been recommended to each user), g reaches 100% (for all strategies). As for the two remaining strategies, they both perform significantly bett er than random. Note that duration discovers friends faster than frequency . To see now which strategy performs better over another, we compare frequency and duration against the random one. We do so by defining the gain factor over random as: where g strategy is the fraction of good recommendations for strategy = duration | frequency , and g random is that for ran-dom . A gain factor of one means the strategy performs no better than random (no gain); a factor of two means that the strategy performs twice as better as random. Figure 1(b) shows that duration gains more than frequency -especially so for the first 20% of people recommended. As one expects, frequency and duration die off up to a point where both of them flatten toward random (no gain). That is because, af-ter recommending most friends, any strategy has left only few friends to recommend, and those are hard to predict. (2) Duration and  X  X ink Prediction X . The second set of experiments compared the four different link predic-tion strategies presented in Section 2.2. We did experiment s whereby these strategies were executed on a social network of encounters built using duration information and frequency information. Since results obtained with duration were con-sistently better than those obtained with frequency , we re-port results for the former case only. Figure 1(c) plots g versus r for all the four strategies. We also plot the re-sults obtained with our baseline random strategy, as well as when using duration without propagation, to highlight what privacy-conscious users would miss by not sharing their col o-cation information for propagation processing. PageRank , (a) Predicted ties g vs. recommended people r. HITS , and KMarkovChain perform equally and only show small differences due to confidence on the results. Those re-sults are similar and come from the common use of Markov chains by the three algorithms. Also, one would be better off using only duration rather than combining it with those three algorithms. That is not necessarily bad news as it sug-gests that, by relying only on her own proximity information , a user both gets quality recommendations and, while doing so, she retains control of her own data. In line with the literature, shortest path performs best. Indeed, Figure 1(d) shows that it gains more than duration , and it does so con-sistently. That is because, unlike duration , shortest path is able to suggest to a user A also those friends who belong to the A  X  X  social circle but have not been met by A yet.
We have presented FriendSensing , a framework that ex-ploits human co-location information to automate the pro-cess of finding friends on social-networking websites.
To go from inferring friends to accurately inferring so-cial networks, FriendSensing needs to be refined. First, the combination of duration and frequency of colocation could be investigated. Non-geographic information should then b e considered, as research has shown that friendship does not only depend on geographic factors, but also on whether in-dividuals have similar occupation, cultural backgrounds, or roles within a company [1, 3]. We thus aim to reason not only on how long people have been co-located but also, for example, where and when they have been so.

Unlike existing friends-of-friends approaches that infer so-cial relationships by exposing sensitive information, Fri end-Sensing suits privacy conscious individuals better: in fac t, they could run FriendSensing with the duration strategy that, as shown experimentally, produces quality recommen-dations while relying on proximity information collected b y their own device only.
