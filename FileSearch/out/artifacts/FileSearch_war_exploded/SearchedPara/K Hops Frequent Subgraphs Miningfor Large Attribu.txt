 With the rapidly increasing amount of data in Web and related applications, more and more data can be represented by graphs. Most mechanism and algo-rithms can only work on labeled graphs, e.g. a vertex has only one label, while vertices in many real graph data have more than one label, and this kind of graphs are named multi-labeled graphs [1], such as graphs describing social net-work and proteins. Attribute graph is characterized as a kind of multi-labeled graph. There are a set of attributes asso ciated with each vertex in attribute graph, and each attribute has an exacted name.

Mining frequent subgraphs from graph databases is of great importance in graph data mining. Frequent subgraphs are useful in data analysis and data mining tasks, such as similarity search, graph classification, clustering and in-dexing [2]. In similarity search and classification, frequent subgraphs are usually used as feature leading to exact results and high scalability. In graph clustering, frequent subgraphs can be used as a solution for traditional algorithms such as k-means. Similarity searching is an important issue in many applications of graph data. The task is considered NP-compl ete and is inefficient for large graph.
Existing research on frequent subgraphs mining is conducted mainly on two types of graph database. The first one is transaction graph databases [3] that consist of a set of relatively smaller graphs. Transaction graph databases are prevalently used in scientific domains suc h as chemistry, bioinformatics, etc. The Second one is a graph with a large number of vertices such as social networks [4]. This paper focuses on the latter type of graph database with several attributes in each vertex.

Mining frequent subgraphs is a iterative processing consists of two main steps [5]: candidates generation and subgraphs counting. In the first step, candidates can be mined extending. In the second step, subgraph isomorphism will be in-vestigated for counting. Subgraph isomorphism is an NP-complete problem [6] and it is time-consuming for large graphs.

Considering the increasing importance of frequent subgraphs mining, this paper will present a mechanism for mining frequent subgraphs from a large attribute graph. Attribute graph will be transformed into labeled graphs by projection firstly. Then algorithm FSGen will be performed to mining k hops frequent subgraphs by extending, joining and isomorphism testing. Finally, fre-quent labeled subgraphs will be merged into attribute subgraphs by integration according to designated attributes. There is no candidates generation in algo-rithm FSGen, and isomorphism testing is optional. Thus, the time occupation of our mechanism for mining frequent labeled subgraphs is better than existing works.

The rest of this paper is organized as follows. Related works are summa-rized in section 2 on subgraph mining algorithms for graph databases consist of multiple small labeled graphs. Sectio n 3 is dedicated to basic concepts and general definitions of frequent subgraphs mining. We present the k hops frequent subgraph mining algorithm FSGen consisting of extending, joining and isomor-phism testing procedures in section 4. Sect ion 5 shows experimental studies for our technique and section 6 concludes our work. Frequent subgraph mining has been widely studied for graph databases consist of multiple small labeled graphs. To the best of our knowledge, no mechanisms can be directly performed in frequent subgraphs mining from graph databases consist of one large attribute graph.

One popular approach for frequent subgraphs mining is raised in Apriori algo-rithm. AGM [7] defines induced subgraph G =( V ,E ) which satisfies V  X  V and E  X  E where E includes all edges connecting vertices in V . In the algo-rithm, all frequent induced subgraphs were mined according to designed support by using vertices for candidates. FSG [8] algorithm stores labels of all (k-1)-subgraphs (subgraphs including k-1 edges), then the common structure between two k-graphs can be found by computing intersection of the label sets of their subgraphs. As a result, a large amount of common subgraphs are generated as candidates, which reduces effi ciency of the algorithm.

The other popular approach for frequent subgraphs mining is based on extend-ing. Extending-based approaches usually use depth first search to find frequent subgraphs. Initially, frequent subgraphs are frequent vertices. Then, a new vertex extending from each subgraphs by another edge is added to the subgraph in order to generate a new subgraph. Isomorphism testing is used to determine whether the new subgraph is frequent. All subgraphs can be mined by repeating these steps. But this case creates many redundant candidates. So all existing methods based on extending attempt to reduce the generation of redundant candidates. gSpan [9] defines DFS (Depth First Search) Lexicographic Order and DFS code of a graph. GraphGen [6] improves gSpan by mining frequent subtree instead of frequent subgraph in order to reduce the complexity of time. When preforming a depth first search in a graph, a DFS tree is constructed. One graph can have sev-eral DFS trees and respective DFS codes. Because the minimum DFS code of a graph is unique, a DFS tree can be denot ed by this minimum DFS code. Isomor-phism testing can be performed based on minimum DFS codes of each subgraph. gSpan and GraphGen can only extend v ertices in the right path of DFS tree. Candidates can only generate from finite vertices or edges for reducing redun-dant subgraphs. FFSM [10] designs canonical adjacent matrix (CAM) as formal data model for graphs and guarantee all frequent subgraphs are enumerated unambiguously. FFSM uses two operations: FFSM-Join and FFSM-Extension to generate candidates efficiently and completely avoids subgraph isomorphism testing by maintaining an embedding set for each frequent subgraph. Indeed, in FFSM, edges extending and isomorphism testing has been transformed into operations on CAMs. And the complexity of FFSM concentrates on operations of CAMs. CAMs will be larger together with the increasing scale of graphs and mining frequent subgraphs in large graph is inefficient.

We can summary from existing works that candidates generation and isomor-phism testing is essential stages for mining subgraphs. Since the complexity of isomorphism testing cannot be actually reduced (including substitution of iso-morphism testing stage in FFSM), all researches focus on reducing creation of candidates. We will present a new algorithm FSGen for k hops frequent sub-graphs mining from a large labeled graph. Under the restriction of k , candidates generation and isomorphism testing can be avoided by the mechanism. For simplicity of presentation, we restrict our discussion to undirected, multi-attributes graphs. And graph database consists of only one large attribute graph. However, our approach can be applied to directed graphs and labeled graphs with minor changes.

Agraph G is defined as a binary ( V,E ), where V is the set of vertices, E is the set of edges. A labeled graph G L is defined as a triple ( V,E,L ), where V and E is the same as G , L is a labeling function that assigns a label to each vertex and edge. L ( v )= l denotes that the label of vertex v is l . An attribute graph G A is extending the function L to multiple attributes, as definition 1 interprets.
 Definition 1. Attribute Graph. An Attribute Graph G A is a triple ( V,E,F A ) where V is a set of vertices and E  X  V  X  V is a set of edges. A denotes the set of attributes. F A = n j =1 m i =1 f a i ( v j ) (Assuming there are n vertices in V and m denotes to the value of attribute a i of vertex v j ( a i  X  A , v j  X  V ).
Fig. 1 shows examples of graph, labeled graph and attribute graph. In the attribute graph, each vertex has three attributes: id , name and major . Definition 2. K Hops Neighbor.  X  v  X  V , N ( v, k ) denotes to a set of vertices that are at most k hops from v .Eachvertex u  X  N ( v, k )isa k hops neighbor of vertex v . For example, in Fig. 1(c) N ( v 1 , 1) = { v 3 ,v 4 } .

In this paper, attribute graph will be transformed into labeled graphs by projection according to attributes. Thus, following definitions in this section are designed for labeled graphs.
 Definition 3. Support. The support of a subgraph G S in labeled graph G L is denoted by Sup ( G S ) and is given as the total quantity of its occurrence in G L . Sup ( v ) denotes the support of vertex v by counting the occurrences of L ( v ). Sup ( e ) denotes the support of edge e by counting the occurrences of e whose labels of begin and end vertices are the same respectively.
 Definition 4. Frequent. Given a minimum support MinSup and a labeled graph G L ,avertex v  X  V is a frequent vertex iff. Sup ( v )  X  MinSup .Anedge e  X  E is a frequent edge iff. Sup ( e )  X  MinSup . A subgraph g  X  G L is frequent iff. Sup ( g )  X  MinSup .
 Definition 5. K Hops Frequent Subgraph. A k hops frequent subgraph G f =( V f ,E f ,L f ) of labeled graph G L satisfies: (1) V f of G f in G is not less than a given MinSup , (3)minimum hops (distance) between all vertices and a designated root vertex are not more than a given constant k , where the root vertex is one of frequent vertices in G L . For example, in Fig. 1(b), assuming k =1 and MinSup =2, 1 hop frequent subgraphs in the labeled graph are edges ( a , b )and( a , c ). In this section, we discuss algorithms for mining k hops frequent subgraphs in a large attribute graph. Attribute graph is transformed into labeled graphs by projection firstly. Then, algorithm FSGen for k hops frequent subgraph mining in a large labeled graph will be proposed. Finally, integration will be described in order to merge frequent labeled subgraphs into frequent attribute subgraphs by designated attributes. 4.1 Projection Attribute graph will be transformed into labeled graphs by projection before frequent subgraphs mining. Projection can simplify the complexity of attribute graph. And mechanisms for processing labeled graphs can be used to work on attribute graph after projection.
 Definition 6. Projection. Given attribute graph G A =( V,E,F A ), a labeled  X  a  X  A then L ( v )  X  f Fig. 2 shows labeled graphs transformed from the attribute graph shown in Fig. 1(c) by projection. For e ach attribute, a projection g pi can be used as a labeled graph for frequent subgraph mining algorithm presented in next subsec-tion. And integration will be performed to combine mining results as frequent attribute subgraphs.

For each projection of an attribute, a linear scanning will be performed to get each value of the attribute as label of related vertex in labeled graph. Then a double iteration will be executed to g et edges of labeled graph according to the attribute. Assuming there are m attributes in each vertex of n vertices in the attribute graph G A . The complexity of time in projection stage is O ( n 2 )as the number of attributes m is a constant. 4.2 K Hops Frequent Subgraph Mining Algorithm In this subsection, k hops frequent subgraph mining algorithm FSGen will be presented. In FSGen, frequent subgraphs are extended from root vertices until k steps. In each extending step, the subgraphs extended from previous steps are frequent. Thus, the ultimate extending structures after k steps are frequent. This idea is based on property 1.
 where L ( v 1 )= L ( v 2 )= ... = L ( v n )and Sup ( v i )  X  MinSup (1  X  i  X  n ). If  X  u MinSup ,thenvertex u hj is frequent and subgraph g i =( V i ,E i ,L i )isfrequent Proof : The occurrence of L ( u hj )isnolessthangiven MinSup ,soinall N ( v i ,h ), Sup ( u hj )  X  MinSup ,andvertex u hj is frequent.  X  e  X  E i , the start and end vertices of e is frequent, so edge e is frequent according to definition 3 and 4. In labeled graph g i ,  X  v  X  V i and e  X  E i ,Sup ( v i )  X  MinSup and Sup ( e i )  X  MinSup , then all components of g i are frequent. As a result, g i is frequent.
V R is considered as the set of root vertices. An iterated processing will be invoked to get root vertices. If a frequent vertex is not contained in any frequent subgraph, it will be extracted as new root vertex until all frequent vertices are contained in frequent subgraphs. Frequ ency of vertices in a labeled graph will be calculated by a polynomial time scanning, and the worst complexity of time is O ( n 2 ).

In order to brief mining processing, we attempt to avoid overlaps among fre-quent subgraphs mined by each stage in the algorithm. Overlap is a repeated structure in subgraph, such as paths, subgraphs and so on. We discuss the prob-ability of overlap basing on property 2.
 then the frequent subgraphs extended from v and u are probably overlap. Proof : Given a constant k as the number of hops, assuming  X  u 1  X  N ( u, 1), u  X  N ( u, 2), ..., u N ( w, k  X  1), where L ( u i )= L ( w i ), 1  X  i  X  k  X  1. Subgraphs consist of paths u, u 1 ,u 2 , ..., u ( k  X  1) and w, w 1 ,w 2 , ..., w ( k  X  1) are overlap.
Based on above properties, our algorithm for mining frequent subgraph has following features: (1) Vertices and edg es in each extending step are frequent in all N ( v r ,h )(1  X  h  X  k ), where v r  X  V R is a root vertex. (2) The same edge (labels of start and end vertices are the same respectively) occurs once in each extending step.

K hops frequent subgraph mining algorithm FSGen consists of three stages: ex-tending, joining and isomorphism testing. Frequent subgraphs are initially denoted as frequent vertices, and then these vertices will be extended by other frequent vertices and edges until k hops in extending stage. Frequent subgraphs obtained from extending stage are constructed as tree model. So in joining stage, frequent edges in labeled graph will be added into extended k hops frequent sub-graphs where they do not occur. After above two stages, k hops frequent subgraphs can be enumerated. If we want to summarize all k hops frequent subgraphs, iso-morphism testing will be performed and this stage is optional according to actual requirements. In order to complete our algorithm, isomorphism testing will be pre-sented along with the other two stages in this subsection. Algorithm 1 shows FS-Gen performed on labeled graphs by projection. The algorithm consists of three main procedures: Extending, Joining and Isomorphism Testing.
 Algorithm 1. FSGen
As each G p is a labeled graph, an inverted table will be built as index for each label and sorted by frequency. Then root vertices can be chosen by the inverted table. In extending stage, frequent ver tices that do not occur in any extended frequent subgraphs can be used as new root vertices in the iteration. Extending is a recursive procedure as Algorithm 2 shows and the complexity of time is O (2 n ). We design h as the current number of hops. In each steps of extending, a frequent vertex and a related frequent edge will be added into frequent subgraph extended in previous steps as line 6 to line 8 shows. In order to avoid overlap, we use a list of vertices for N ( v, 1) which include non-repeated neighbors of vertex v . While h is equal to k , the procedure will return and g will be extended in vertices set and edges set. Algorithm 2. Extending
Joining procedure is shown in Algorithm 3 and double iteration will be per-formed in the procedure. Assuming n is the number of frequent vertices in the labeled graph which is a projection of attribute graph G A and m is the number of edges in the edges set of frequent subgraph G f . Time occupation is O ( n 2  X  m ). Since m is approximately a constant. The complexity of time in Joining proce-dure is O ( n 2 ).
 Algorithm 3. Joining
Algorithm 4 shows Isomorphism Testing procedure. All k hops frequent sub-graphs in labeled graph can be enumerated after executing Extending and Join-ing procedure. If we want to summarize the set of k hops frequent subgraphs, repeated subgraphs will be reduced, and Isomorphism Testing procedure will be performed. In existing works, isomorphism testing is considered as NP-complete problem. In our mechanism, the procedure will be replaced by a approximated solution named Graph Edit Distance(GED) [11]. GED can be computed in poly-nomial time O ( m 3 )( m denotes to the larger number of vertices in two graphs) by the idea of dynamic programming. If GED between two frequent subgraphs is no more than a given threshold of similarity, these two frequent subgraphs are considered similar subgraph and one of them will be removed from G f . The total complexity of time in isomorphism testing is O ( m 3  X  n 2 )where m is the number of vertices in each frequent labeled subgraph and n denotes the number of all frequent labeled subgraphs. By the restriction of k , the number of vertices in a frequent subgraph can be considered as a constant, so the complexity of time in Isomorphism Testing procedure is O ( n 2 ).
 Algorithm 4. Isomorphism Testing
K hops frequent subgraphs mining algorithm FSGen consists of three proce-Therefore, the total complexity of the algorithm FSGen is O (2 n + n 2 + n 2 ), which can be merged into O (2 n ) no matter what including the stage of isomorphism testing. 4.3 Integration Attribute graph is transformed into labeled graphs by projection. Algorithms are performed on labeled graphs for mining k hops frequent subgraphs. Each frequent subgraph is also a labeled subgraph. In order to merge frequent la-beled subgraphs into attribute subgraphs, integration will be used. Integration described in definition 7 is the opposite operation of projection.
 Definition 7. Integration. Given n labeled graphs g p 1 ,g p 2 , ..., g pn ,where g pi = ( V pi ,E pi ,L pi ). Integration is a aggregated attribute graph G A =( V,E,F A ),
According to the definition of integration, many operations of intersection computing will be carried out. Common solution as definition 7 shows is time-consuming. On the other hand, there may be no frequent subgraphs mined from labeled subgraphs for attributes whose values are unique. While integrating all frequent labeled subgraphs, no frequent attribute subgraphs will be obtained. Thus, the mining results are not significant. In order to solve problems presented above, we adopt a flexible method for integration. We add a flag for each attribute of a vertex, if value of the attribute is frequent, the flag will be set to 1, and otherwise set to 0. Then we can designate attributes and its related frequent labeled subgraphs for integration. In each frequent labeled subgraph, scanning the set of vertices, if flags of the values in designated attributes of a vertex are equal to 1, the vertex will be selected as a frequent vertex and added to vertices set of frequent attribute subgraph. This processing is a linear scanning and the complexity of time is O ( m ), where m is the number of vertices in the scanned frequent subgraph. For all frequent subg raphs, the total complexity of time for integration is O ( m  X  n )where n is the number of frequent labeled subgraphs mined by FSGen. The mechanism presented in this paper is written in C++ using Microsoft Visual Studio.net 2008. All experiments are carried out on a PC with Intel core i7 CPU 2.67GHz, 4GB memory and Microsoft Windows 7.

The experiment consists of two parts t o demonstrate the effectiveness of our work. Firstly, we perform our mechanism for mining frequent subgraphs in at-tribute graph with different k , different size of data and different support. And then testing time occupation in each case . Secondly, we perform algorithm FSGen for mining frequent subgraphs in labeled graphs together with other traditional algorithms including gSpan, FFSM and GraphGen, which must be rewritten for large labeled graph instead of multiple small graphs, to compare the time occu-pations of these algorithms. We obtain large attribute graph data by crawling from YouTube API and arrange each item to a vertex of graph including 9 at-tributes. We choose three attributes: category , length and views for frequent subgraphs mining. 5.1 Mining in Attribute Graph K is the number of hops denoting distance from root vertex to another in each frequent subgraph. In this experiment, we firstly discuss the impact of k in time occupation while running the k hops frequent subgraph mining algorithm FS-Gen on labeled graphs transformed from the attribute graph based on YouTube dataset. And then testing the effectiven ess with different size of data and differ-ent support.

Fig. 3 shows time occupation according to different k .Wecanseefromthe figure that the time occupation is increasing along with the growth of k while the number of vertices in attribute graph is 500K. The same tendency occurs in Fig. 4 while the number of hops is set to 3, with the growing amount of vertices, time occupation of our work will increase. The time occupation is also related to the support as Fig. 5 shows. The values of x axis is denoted by the ratio between support (given by definition 3) and total number of vertices in the labeled graph. More time will be occupied while the support is low because low support will bring more subgraphs.
 5.2 Mining in Labeled Graph In this experiment, we compare algorithm FSGen presented in this paper with gSpan, FFSM and GraphGen. All the algorithms comparing to FSGen can be used to mine frequent subgraphs in a large labeled graph with few modification. As a result, these algorithms can be us ed to mining frequent subgraphs from labeled graph transformed from attribute graph by projection. The same pro-cessing of projection and integration will be performed while executing gSpan, FSSM, GraphGen and FSGen. We only discu ss the effectiveness of mining fre-quent subgraphs from large labeled graph for these algorithms.

Designing the size of attribute graph (assuming 500K vertices in the experi-ment) and the number of hops (assuming k = 3). We can see from Fig. 6, FSGen is more efficient than any other algorithms. With the size of graph data grow-ing, this advantage becomes more and more apparent. And the same tendency will occur when we compare the time occupation with given supports as Fig. 7 shows. We introduced a new mechanism for mining k hops frequent subgraphs in large attribute graph. In our work, large attribute graph was transformed into labeled graphs by projection, and then algorithm FSGen for mining k hops frequent sub-graphs in large labeled graph was presen ted. Finally, integration was performed to merge frequent labeled subgraphs into frequent attribute subgraphs. Experi-mental studies show that our mechanism can efficiently mining k hops frequent attribute subgraphs. Comparing with ex isting algorithms for mining frequent subgraphs in large labeled graph, algorithm FSGen presented in this paper is more efficient than gSpan, FFSM and GraphGen on real datasets.
 Acknowledgments. This work is partly supported by the National Natural Science Foundation of China under Grant Nos. 61170184, 61070089; the Na-tional High Technology Development 863 Programs of China under Grant No. 2013AA013204; the Ph.D. Progr ams Foundation of Ministry of Education of China under G rand No. 20120031120038.

