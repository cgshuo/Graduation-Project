 Relational learning is concerned with predicting unknown values of a relation, given a database of entities and ob-served relations among entities. An example of relational learning is movie rating prediction, where entities could in-clude users, movies, genres, and actors. Relations encode users X  ratings of movies, movies X  genres, and actors X  roles in movies. A common prediction technique given one pairwise relation, for example a #users  X  #movies ratings matrix, is low-rank matrix factorization. In domains with multiple relations, represented as multiple matrices, we may improve predictive accuracy by exploiting information from one re-lation while predicting another. To this end, we propose a collective matrix factorization model: we simultaneously factor several matrices, sharing parameters among factors when an entity participates in multiple relations. Each rela-tion can have a different value type and error distribution; so, we allow nonlinear relationships between the parameters and outputs, using Bregman divergences to measure error. We extend standard alternating projection algorithms to our model, and derive an efficient Newton update for the pro-jection. Furthermore, we propose stochastic optimization methods to deal with large, sparse matrices. Our model gen-eralizes several existing matrix factorization methods, and therefore yields new large-scale optimization algorithms for these problems. Our model can handle any pairwise re-lational schema and a wide variety of error models. We demonstrate its efficiency, as well as the benefit of sharing parameters among relations.
 H.1.1 [ Information Systems ]: Models and Principles; G.1.6 [ Optimization ]: Nonlinear programming, Stochastic pro-gramming Algorithms, Theory, Experimentation
Relational data consists of entities and relations between them. In many cases, such as relational databases, the num-ber of entity types and relation types are fixed. Two impor-tant tasks in such domains are link prediction , determining whether a relation exists between two entities, and link re-gression , determining the value of a relation between two entities given that the relation exists.

Many relational domains involve only one or two entity types: documents and words; users and items; or academic papers where links between entities represent counts, rat-ings, or citations. In such domains, we can represent the links as an m  X  n matrix X : rows of X correspond to enti-ties of one type, columns of X correspond to entities of the other type, and the element X ij indicates either whether a relation exists between entities i and j . A low-rank fac-torization of X has the form X  X  f ( UV T ), with factors U  X  R m  X  k and V  X  R n  X  k . Here k &gt; 0 is the rank, and f is a possibly-nonlinear link function . Different choices of f and different definitions of  X  lead to different models: min-imizing squared error with an identity link yields the singu-lar value decomposition (corresponding to a Gaussian error model), while other choices extend generalized linear mod-els [26] to matrices [14, 17] and lead to error models such as Poisson, Gamma, or Bernoulli distributions.

In domains with more than one relation matrix, one could fit each relation separately; however, this approach would not take advantage of any correlations between relations. For example, a domain with users, movies, and genres might have two relations: an integer matrix representing users X  rat-ings of movies on a scale of 1 X 5, and a binary matrix repre-senting the genres each movie belongs to. If users tend to rate dramas higher than comedies, we would like to exploit this correlation to improve prediction.

To do so, we extend generalized linear models to arbitrary relational domains. We factor each relation matrix with a generalized-linear link function, but whenever an entity type is involved in more than one relationship, we tie factors of different models together. We refer to this approach as collective matrix factorization .

We demonstrate that a general approach to collective ma-trix factorization can work efficiently on large, sparse data sets with relational schemas and nonlinear link functions. Moreover, we show that, when relations are correlated, col-lective matrix factorization can achieve higher prediction ac-curacy than factoring each matrix separately. Our code is available under an open license. 1
Source code is available at http://www.cs.cmu.edu/
The building block of collective factorization is single-matrix factorization, which models a single relation between two entity types E 1 and E 2 . If there are m entities of type E 1 and n of type E 2 , we write X  X  R m  X  n for our matrix of observations, and U  X  R m  X  k and V  X  R n  X  k for the low-rank factors. A factorization algorithm can be defined by the fol-lowing choices, which are sufficient to include most existing approaches (see Sec. 2.2 for examples): 1. Prediction link f : R m  X  n  X  R m  X  n 2. Loss function D ( X,f ( UV T ))  X  0, a measure of the 3. Optional data weights W  X  R m  X  n + , which if used must 4. Hard constraints on factors, ( U,V )  X  X  5. Regularization penalty, R ( U,V )  X  0.
 For the model X  X  f ( UV T ), we solve: The loss D (  X  ,  X  ) quantifies  X  in the model. It is typically convex in its second argument, and often decomposes into a weighted sum over the elements of X . For example, the loss for weighted SVD [32] is where denotes the element-wise product of matrices.
 Prediction links f allow nonlinear relationships between UV T and the data X . The choices of f and D are closely related to distributional assumptions on X ; see Section 2.1. Common regularizers for linear models, such as ` p -norms, are easily adapted to matrix factorization. Other regular-izers have been proposed specifically for factorization; for example, the trace norm of UV T , the sum of its singular values, has been proposed as a continuous proxy for rank [33]. For clarity, we treat hard constraints C separately from regularizers. Examples of hard constraints include orthogo-nality; stochasticity of rows, columns, or blocks (for exam-ple, in matrix co-clustering each row of U and V sums to 1); non-negativity; and sparsity or cardinality.
A large class of matrix factorization algorithms restrict D to generalized Bregman divergences: e.g. , singular value de-composition [16] and non-negative matrix factorization [21].
Definition 1 ([17]). For a closed, proper, convex func-tion F : R m  X  n  X  R , the generalized Bregman divergence between matrices Z and Y is where A  X  B is the matrix dot product tr( A T B ) = P ij A If F  X  is differentiable, this is equivalent to the standard defi-nition [10, 11], except that the standard definition uses argu-ments Z and  X  F  X  ( Y ) instead of Z and Y . If F decomposes into a sum over components of Z , we can define a weighted ~ajit/cmf . A longer version of the paper is available as a technical report [31] divergence, overloading F to denote a single component of the sum, Examples include weighted versions of squared loss, F ( x ) = x , and I-divergence, F ( x ) = x log x  X  x . Our primary focus is on decomposable regular Bregman divergences [6], which correspond to maximum likelihood in exponential families:
Definition 2. A parametric family of distributions  X  F = { p
F ( x |  X  ) :  X  } is a regular exponential family if each density has the form where  X  is the vector of natural parameters for the distri-bution, x is the vector of minimal sufficient statistics, and F (  X  ) is the log-partition function A distribution in  X  F is uniquely identified by its natural parameters. For regular exponential families where the matching prediction link is f (  X  ) =  X  F (  X  ) [15, 4, 14, 6]. Minimizing a Bregman divergence under a matching link is equivalent to maximum likelihood for the correspond-ing exponential family distribution.

The relationship between matrix factorization and expo-nential families is seen by treating the data matrix X as a collection of samples, X = { X 11 ,...,X mn } . Modeling X = f ( UV T ), we have that X ij is drawn from the distribu-tion in  X  F with natural parameter ( UV T ) ij .

Decomposable losses, which can be expressed as the sum of losses over elements, follows from matrix exchangeabil-ity [2, 3]. A matrix X is row-and-column exchangeable if permuting the rows and columns of X does not change the distribution of X . For example, if X is a document-word matrix of counts, the relative position of two documents in the matrix is unimportant, the rows are exchangeable; likewise for words. A surprising consequence of matrix ex-changeability is that the distribution of X can be described by a function of a global matrix mean, row and column ef-fects ( e.g. , row biases, column biases), and a per-element effect ( e.g. , the natural parameters UV T above). The per-element effect leads naturally to decomposable losses. An example where decomposability is not a legitimate assump-tion is when one dimension indexes a time-varying quantity.
The simplest case of matrix factorization is the singular value decomposition: the data weights are constant, the pre-diction link is the identity function, the divergence is the sum of squared errors, and the factors are unregularized. A hard constraint that one factor is orthogonal and the other or-thonormal ensures uniqueness of the global optimum (up to permutations and sign changes), which can be found using Gaussian elimination or the Power method [16].

Variations of matrix factorization change one or more of the above choices. Non-negative matrix factorization [21] maximizes the objective where 1 is a matrix with all elements equal to 1. Maximiz-ing Equation 2 is equivalent to minimizing the I-divergence D H ( X || log( UV T )) under the constraints U,V  X  0. Here H ( x ) = x log( x )  X  x . The prediction link is f (  X  ) = log(  X  ).
The scope of matrix factorizations we consider is broader than [17], but the same alternating Newton-projections ap-proach (see Sections 4-5) can be generalized to all the fol-lowing scenarios, as well as to collective matrix factoriza-tion: (i) constraints on the factors, which are not typically considered in Bregman matrix factorization as the result-ing loss is no longer a regular Bregman divergence. Con-straints allow us to place methods like non-negative matrix factorization [21] or matrix co-clustering into our framework. (ii) non-Bregman matrix factorizations, such as max-margin matrix factorization [30], which can immediately take ad-vantage of the large scale optimization techniques in Sec-tions 4-5; (iii) row and column biases, where a column of U is paired with a fixed, constant column in V (and vice-versa). If the prediction link and loss correspond to a Bernoulli dis-tribution, then margin losses are special cases of biases; (iv) methods based on plate models, such as pLSI [19], can be placed in our framework just as well as methods that factor data matrices. While these features can be added to collec-tive matrix factorization, we focus primarily on relational issues herein.
A relational schema contains t entity types, E 1 ... E t . There are n i entities of type i , denoted { x ( i ) e } n i e =1 tween two types is E i  X  u E j ; index u  X  N allows us to distinguish multiple relations between the same types, and is omitted when no ambiguity results. In this paper, we only consider binary relations. The matrix for E i  X  u E j has n rows, n j columns, and is denoted X ( ij,u ) . If we have not observed the values of all possible relations, we fill in un-observed entries with 0 (so that X ( ij,u ) is a sparse matrix), and assign them zero weight when learning parameters. By convention, we assume i  X  j . Without loss of generality, we assume that it is possible to traverse links from any entity type to any other; if not, we can fit each connected compo-nent in the schema separately. This corresponds to a fully connected entity-relationship model [12].

We fit each relation matrix as the product of latent fac-U ( j )  X  R n j  X  k ij for k ij  X  X  1 , 2 ,... } . Unless otherwise noted, the prediction link f ( ij ) is an element-wise function on ma-trices. If E j participates in more than one relation, we allow our model to use only a subset of the columns of U ( j ) for each one. This flexibility allows us, for example, to have relations with different latent dimensions, or to have more than one relation between E i and E j without forcing ourselves to pre-dict the same value for each one. In an implementation, we would store a list of participating column indices from each factor for each relation; but to avoid clutter, we ignore this possibility in our notation.
For concision, we introduce collective matrix factorization on the three-entity-type schema E 1  X  E 2  X  E 3 , and use simplified notation: the two data matrices are X = X (12) and Y = X (23) , of dimensions m = n 1 , n = n 2 , and r = n . The factors are U = U (1) , V = U (2) , and Z = U (3) The latent dimension is k = k 12 = k 23 . The weight matrix for X is W , and the weight matrix for Y is  X  W . Since E participates in both relations, we use the factor V in both reconstructions: X  X  f 1 ( UV T ) and Y  X  f 2 ( V Z T ).
An example of this schema is collaborative filtering: E are users, E 2 are movies, and E 3 are genres. X is a matrix of observed ratings, and Y indicates which genres a movie belongs to (each column corresponds to a genre, and movies can belong to multiple genres).

One model of Bregman matrix factorization [17] proposes the following decomposable loss function for X  X  f 1 ( UV L ( U,V | W ) = D F 1 ( UV T || X,W ) + D G (0 || U ) + D H where G ( u ) =  X u 2 / 2 and H ( v ) =  X v 2 / 2 for  X , X  &gt; 0 corre-sponds to ` 2 regularization. Ignoring terms that do not vary with the factors the loss is L ( U,V | W ) = W  X  F ( UV T )  X  X  X  UV T  X  + G  X  ( U )+ H  X  Similarly, if Y were factored alone, the loss would be
L 2 ( V,Z |  X  W ) = D F 2 ( V Z T || Y,  X  W ) + D H (0 || V ) + Since V is a shared factor we average the losses:
L ( U,V,Z | W,  X  W ) =  X L 1 ( U,V | W ) + (1  X   X  ) L 2 ( V,Z | where  X   X  [0 , 1] weights the relative importance of relations.
Each term in the loss, L 1 and L 2 , is decomposable and twice-differentiable, which is all that is required for the al-ternating projections technique described in Section 4.1. De-spite the simplicity of Equation 3, it has some interesting im-plications. The distribution of X ij given x (1) i and x the distribution of Y jk given x (2) j and x (3) k , need not agree on the marginal distribution of x (2) j . Extending the notion of row-column exchangeability, each entity x (2) j corresponds to a record whose features are the possible relations with entities of types E 1 and E 3 . Let F 2 , 1 denote the features cor-responding to relations involving entities of E 1 , and F features corresponding to relations involving entities of E If the features are binary, they indicate whether or not an entity participates in a relation with x (2) j . The latent repre-sentation of x (2) j is V j  X  , where UV T j  X  and V j  X  Z the distribution over F 2 , 1 and F 2 , 3 respectively.
Equation 3 is convex in any one of its arguments. We ex-tend the alternating projection algorithm for matrix factor-ization, fixing all but one argument of L = L ( U,V,Z | W, and updating the free factor using a Newton-Raphson step. Differentiating the loss with respect to each factor:  X  U L =  X   X  W  X  f 1 ( UV T )  X  X  X  X  V +  X  G  X  ( U ) , (4)  X  V L =  X   X  W  X  f 1 ( UV T )  X  X  X  X  T U +  X  Z L = (1  X   X  )  X   X  W  X  f 2 ( V Z T )  X  Y  X  X  T V +  X  I  X  Setting the gradients equal to zero yields update equations for U , V , and Z . Note that the gradient step does not require the divergence to be decomposable, nor does it re-quire that that the matching losses be differentiable; simply replace gradients with subgradients in the prequel. For ` regularization on U , G ( U ) =  X  || U || 2 / 2,  X  G  X  ( U ) = U/ X  . The gradient for a factor is a linear combination of the gra-dients with respect to the individual matrix reconstructions the factor participates in.
 A cursory inspection of Equations 4-6 suggests that an Newton step is infeasible. The Hessian with respect to U would involve nk parameters. However, if L 1 and L 2 are each decomposable functions, then we can show that almost all the second derivatives of L with respect to a single factor U are zero. Moreover, the Newton update for the factors reduces to row-wise optimization of U , V , and Z . For the subclass of models where Equations 4-6 are differentiable and the loss is decomposable, define q ( Z i  X  ) = (1  X   X  )  X   X  W  X  i  X  f 2 ( V Z T i  X  )  X  Y Since all but one factor is fixed, consider the derivatives of q ( U i  X  ) with respect to any scalar parameter in U :  X  Because U js only appears in q ( U i  X  ) when j = i , the deriva-tive equals zero when j 6 = i . Therefore the Hessian  X  is block-diagonal, where each non-zero block corresponds to a row of U . The inverse of a block-diagonal matrix is the inverse of each block, and so the Newton direction for U , [  X 
U L ][  X  2 U L ]  X  1 , can be reduced to updating each row U applies to V and Z as well, since the loss is a sum of per-matrix losses and the derivative is a linear operator.
Any (local) optima of the loss L corresponds to roots of the equations { q ( U i  X  ) } m i =1 , { q ( V i  X  ) } n i =1 derive the Newton step for U i  X  , where we suggest using the Armijo criterion [28] to set  X  . To concisely describe the Hessian we introduce terms for the contribution of the regularizer, and terms for the contribution of the reconstruction error, D D The Hessians with respect to the loss L are q 0 ( Z i  X  )  X  X  X  q ( Z i  X  ) = (1  X   X  ) V T D 4 ,i V + I i q 0 ( V i  X  )  X  X  X  q ( V i  X  ) =  X U T D 2 ,i U + (1  X   X  ) Z Each update of U , V , and Z reduces at least one term in Equation 3. Iteratively cycling through the update leads to a local optima. In practice, we simplify the update by taking one Newton step instead of running to convergence.
In addition to weighing the importance of reconstructing different parts of a matrix, W and  X  W serve other purposes. First, the data weights can be used to turn the objective into a per-element loss by scaling each element of X by ( nm ) and each element of Y by ( nr )  X  1 . This ensures that larger matrices do not dominate the model simply because they are larger. Second, weights can be used to correct for differ-ences in the scale of L 1 ( U,V ) and L 2 ( V,Z ). If the Bregman divergences are regular, we can use the corresponding log-likelihoods as a consistent scale. If the Bregman divergences are not regular, computing averaged over uniform random parameters U , V , and Z , provides an adequate estimate of the relative scale of the two losses. A third use of data weights is missing values. If the value of a relation is unobserved, the corresponding weight is set to zero.
The three-factor model generalizes to any pairwise rela-tional schema, where binary relations are represented as a set of edges: E = { ( i,j ) : E i  X  X  j  X  i &lt; j } . Let [ U ] denote the set of latent factors and [ W ] the weight matrices. The loss of the model is L ([ U ] | [ W ]) = X where F ( ij ) defines the loss for a particular reconstruction, and G ( i ) defines the loss for a regularizer. The relative weights  X  ( ij )  X  0 measure the importance of each matrix in the reconstruction. Since the loss is a linear function of individual losses, and the differential operator is linear, both gradient and Newton updates can be derived in a manner analogous to Section 4.1, taking care to distinguish when U ( i ) acts as a column factor as opposed to a row factor.
In optimizing a collective factorization model, we are in the unusual situation that our primary concern is not the cost of computing the Hessian, but rather the cost of com-puting the gradient itself: if k is the largest embedding di-mension, then the cost of a gradient update for a row U ( i ) the same row is O ( k 3 + k 2 P j : E smaller than the number of entities, and so the Newton up-date costs only a factor of k more. (The above calculations assume dense matrices; for sparsely-observed relations, we can replace n j by the number of entities of type E j which are related to entity x ( i ) r , but the conclusion remains the same.)
The expensive part of the gradient calculation for U is to compute the predicted value for each observed rela-tion that entity x ( i ) r participates in, so that we can sum all of the weighted prediction errors. One approach to re-ducing this cost is to compute errors only on a subset of observed relations, picked randomly at each iteration. This technique is known as stochastic approximation [7]. The best-known stochastic approximation algorithm is stochas-tic gradient descent; but, since inverting the Hessian is not a significant part of our computational cost, we will recom-mend a stochastic Newton X  X  method instead.
 Consider the update for U i  X  in the three factor model. This update can be viewed as a regression where the data are X i  X  and the features are the columns of V . If we denote a sample of the data as s  X  { 1 ,...,n } , then the sample gradient at iteration  X  is  X  q Similarly, given subsets p  X  { 1 ,...,n } and q  X  { 1 ,...,r } , the sample gradients for the other factors are  X  q  X  q ( Z i  X  ) = (1  X   X  )  X   X  W si  X  f ( V s  X  Z T i  X  )  X  Y si The stochastic gradient update for U at iteration  X  is and similarly for the other factors. Note that we use a fixed, decaying sequence of learning rates instead of a line search: sample estimates of the gradient are not always descent di-rections. An added advantage of the fixed schedule over line search is that the latter is computationally expensive.
We sample data non-uniformly, without replacement, from the distribution induced by the data weights. That is, for a row U i  X  , the probability of drawing X ij is W ij / P This sampling distribution provides a compelling relational interpretation: to update the latent factors of x ( i ) r ple only observed relations involving x ( i ) r . For example, to update a user X  X  latent factors, we sample only movies that the user rated. We use a separate sample for each row of U : this way, errors are independent from row to row, and their effects tend to cancel. In practice, this means that our actual training loss decreases at almost every iteration.
With sampling, the cost of the gradient update no longer grows linearly in the number of entities related to x ( i ) only in the number of entities sampled. Another advantage of this approach is that when we sample one entity at a time, | s | = | p | = | q | = 1, stochastic gradient yields an online algorithm, which need not store all the data in memory.
As mentioned above, we can often improve the rate of convergence by moving from stochastic gradient descent to stochastic Newton-Raphson updates [7, 8]. For the three-factor model the stochastic Hessians are where  X  D  X  D To satisfy convergence conditions, which will be discussed in Section 5.1, we use an exponentially weighted moving average of the Hessian: When the sample at each step is small compared to the em-bedding dimension, the Sherman-Morrison-Woodbury lemma ( e.g. , [7]) can be used for efficiency. The stochastic Newton update is analogous to Equation 7, except that  X  = 1 / X  , the gradient is replaced by its sample estimate  X  q , and the Hessian is replaced by its sample estimate  X  q .
We consider three properties of stochastic Newton, which together are sufficient conditions for convergence to a local optimum of the empirical loss L [8]. These conditions are also satisfied by setting the Hessian to the identity,  X  q (  X  ) = I  X  i.e. , stochastic gradient.
 Local Convexity : The loss must be locally convex around its minimum, which must be contained in its domain. In alternating projections the loss is convex for any Bregman divergence; and, for regular divergences, has R as its domain. The non-regular divergences we consider, such as Hinge loss, also satisfy this property.
 Uniformly Bounded Hessian : The eigenvalues of the sample Hessians are bounded in some interval [  X  c,c ] with proba-bility 1. This condition is satisfied by testing whether the condition number of the sample Hessian is below a large fixed value, i.e. , the Hessian is invertible. Using the ` ularizer always yields an instantaneous Hessian  X  q that is full rank. The eigenvalue condition implies that the elements of  X  q and its inverse are uniformly bounded.
 Convergence of the Hessian : There are two choices of conver-gence criteria for the Hessian. Either one suffices for prov-ing convergence of stochastic Newton. (i) The sequence of inverses of the sample Hessian converges in probability to the perturbation of the sample Hessian from its mean is bounded. Let P  X   X  1 consist of the history of the stochas-tic Newton iterations: the data samples and the parameters for the first  X   X  1 iterations. Let g  X  = o s ( f  X  ) denote an almost uniformly bounded stochastic order of magnitude. The stochastic o -notation is similar to regular o -notation, except that we are allowed to ignore measure-zero events and E [ o s ( f  X  )] = f  X  . The alternate convergence criteria is a concentration of measure statement: For Equation 8 this condition is easy to verify: since P  X   X  1 contains  X  q  X   X  1 . Any perturbation from the mean is due to the second term. If  X  q is invertible then its ele-ments are uniformly bounded, and so are the elements of E [ X  q  X  |P  X   X  1 ]; since this term has bounded elements and is scaled by 2 / X  , the perturbation is o s (1 / X  ). One may fold in an instantaneous Hessian that is not invertible, so long as the moving average  X  q remains invertible. The above proves the convergence of a factor to the value which minimizes the expected loss, assuming the other factors are fixed. With respect to the alternating projection, we only have conver-gence to a local optima of the empirical loss L .
Collective matrix factorization provides a unified view of matrix factorization for relational data: different methods correspond to different distributional assumptions on indi-vidual matrices, different schemas tying factors together, and different optimization procedures. We distinguish our work from prior methods on three points: (i) competing methods often impose a clustering constraint, whereas we cover both cluster and factor analysis (although our exper-iments focus on factor analysis); (ii) our stochastic Newton method lets us handle large, sparsely observed relations by taking advantage of decomposability of the loss; and (iii) our presentation is more general, covering a wider variety of models, schemas, and losses. In particular, for (iii), our model emphasizes that there is little difference between fac-toring two matrices versus three or more; and, our opti-mization procedure can use any twice differentiable decom-posable loss, including the important class of Bregman di-vergences. For example, if we restrict our model to a single relation E 1  X  E 2 , we can recover all of the single-matrix models mentioned in Sec. 2.2. While our alternating pro-jections approach is conceptually simple, and allows one to take advantage of decomposability, there is a panoply of al-ternatives for factoring a single matrix. The more popular ones includes majorization [22], which iteratively minimize a sequence of convex upper bounding functions tangent to the objective, including the multiplicative update for NMF [21] and the EM algorithm, which is used both for pLSI [19] and weighted SVD [32]. Direct optimization solves the non-convex problem with respect to ( U,V ) using gradient or second-order methods, such as the fast variant of max-margin matrix factorization [30].
 The next level of generality is a three-entity-type model E 1  X  E 2  X  E 3 . A well-known example of such a schema is pLSI-pHITS [13], which models document-word counts and document-document citations: E 1 = words and E 2 = E 3 = documents, but it is trivial to allow E 2 6 = E 3 . Given relations E  X  X  2 and E 2  X  X  3 , with corresponding integer relationship matrices X (12) and X (23) , the likelihood is
L =  X X (12)  X  log  X  UV T  X  + (1  X   X  ) X (23)  X  log  X  V Z T where the parameters U , V , and Z correspond to probabil-ities u ik = p ( x (1) i | h k ), v ik = p ( h k | x (2) i h ) for clusters { h 1 ,...,h K } . Probability constraints re-quire that each column of U , V T , and Z must sum to one, which induces a clustering of entities. Since different enti-ties can participate in different numbers of relations ( e.g., some words are more common than others) the data ma-trices X (12) and X (23) are usually normalized; we can en-code this normalization using weight matrices. The objec-tive, Equation 9, is the weighted average of two probabilistic LSI [19] models with shared latent factors h k . Since each pLSI model is a one-matrix example of our general model, the two-matrix version can be placed within our framework.
Matrix co-clustering techniques have a stochastic constraint: if an entity increases its membership in one cluster, it must decrease its membership in others clusters. Examples of ma-trix and relational co-clustering include pLSI, pLSI-pHITS, the symmetric block models of Long et. al. [23, 24, 25], and Bregman tensor clustering [5] (which can handle higher arity relations). Matrix analogues of factor analysis place no stochastic constraint on the parameters. Collective ma-trix factorization has been presented using matrix factor analyzers, but the stochastic constraint, that each row of U ( r ) sums to 1, distributes over the alternating projection to an equality constraint on each update of U ( r ) i  X  . This ad-ditional equality constraint can be folded into the Newton step using a Lagrange multiplier, yielding an unconstrained optimization ( c.f. , ch. 10 [9]). Comparing the extension of collective matrix factorization to the alternatives above is a topic for future work. It should be noted that our choice of X = UV T is not the only one for matrix factorization. Long et. al. [23] proposes a symmetric block model X  X  C 1 AC T where C 1  X  X  0 , 1 } n 1  X  k and C 2  X  X  0 , 1 } n 2  X  k are cluster indi-cator matrices, and A  X  R k  X  k contains the predicted output for each combination of row and column clusters. Early work on this model uses a spectral relaxation specific to squared loss [23], while later generalizations to regular exponential families [25] use EM. An equivalent formulation in terms of regular Bregman divergences [24] uses iterative majorization [22, 34] as the inner loop of alternating projection. An im-provement on Bregman co-clustering accounts for systematic biases, block effects, in the matrix [1].

The three-factor schema E 1  X  E 2  X  E 3 also includes su-pervised matrix factorization. In this problem, the goal is to classify entities of type E 2 : matrix X (12) contains class la-bels according to one or more related concepts (one concept per row), while X (23) lists the features of each entity. An example of a supervised matrix factorization algorithm is the support vector decomposition machine [29]: in SVDMs, the features X (23) are factored under squared loss, while the labels X (12) are factored under Hinge loss. A similar model was proposed by Zhu et al. [37], using a once-differentiable variant of the Hinge loss. Another example is supervised LSI [35], which factors both the data and label matrices un-der squared loss, with an orthogonality constraint on the shared factors. Principal components analysis, which fac-tors a doubly centered matrix under squared loss, has also been extended to the three-factor schema [36].

Another interesting type of schema contains multiple par-allel relations between two entity types. An example of this sort of schema is max-margin matrix factorization (MMMF) [30]. In MMMF, the goal is to predict ordinal values, such as a user X  X  rating of movies on a scale of { 1 ,...,R } . We can reduce this prediction task to a set of binary threshold problems, namely, predicting r  X  1 ,r  X  2 ,...,r  X  R . If we use a Hinge loss for each of these binary predictions and add the losses together, the result is equivalent to a collec-tive matrix factorization where E 1 are users, E 2 are movies, and E 1  X  u E 2 for u = 1 ...R are the binary rating prediction tasks. In order to predict different values for the R different relations, we need to allow the latent factors U (1) and U to contain some untied columns, i.e. , columns which are not shared among relations. For example, the MMMF authors have suggested adding a bias term for each rating level or for each (user, rating level) pair. To get a bias for each (user, rating level) pair, we can append R untied columns to U (1) and have each of these columns multiply a fixed column of ones in U (2) . To get a shared bias for each rating level, we can do the same, but constrain each of the untied columns in U (1) to be a multiple of the all-ones vector.
Our experiments focus on two tasks: (i) predicting whether a user rated a particular movie: israted ; and (ii) predicting the value of a rating for a particular movie: rating . User ratings are sampled from the Netflix Prize data [27]: a rat-ing can be viewed as a relation taking on five ordinal values (1-5 stars), i.e. , Rating(user, movie). We augment these rat-ings with two additional sources of movie information, from the Internet Movie Database [20]: genres for each movie, encoded as a binary relation, i.e. , HasGenre(movie, genre); and a list of actors in each movie, encoded as a binary rela-tion, i.e. , HasRole(actor, movie). In schema notation E 1 responds to users, E 2 corresponds to movies, E 3 corresponds to genres, and E 4 corresponds to actors. Ordinal ratings are denoted E 1  X  1 E 2 ; for the israted task the binarized ver-sion of the ratings is denoted E 1  X  2 E 2 . Genre membership is denoted E 2  X  X  3 . The role relation is E 2  X  X  4 .
There is a significant difference in the amount of data for the two tasks. In the israted problem we know whether or not a user rated a movie for all combinations of users and movies, so the ratings matrix has no missing values. In the rating problem we observe the relation only when a user rated a movie X  X nobserved combinations of users and movies have their data weight set to zero.
For consistency, we control many of the model and opti-mization parameters across the experiments. In the israted task all the relations are binary, so we use a logistic model: sigmoid link with the matching log-loss. To evaluate test er-ror we use mean absolute error (MAE) for both tasks, which is the average zero-one loss for binary predictions. Since the data for israted is highly imbalanced in favour of movies not being rated, we scale the weight of those entries down by the fraction of observed relations where the relation is true. We use ` 2 regularization throughout. Unless other-wise stated the regularizers are all G ( U ) = 10 5 || U || Newton steps, we use an Armijo line search, rejecting up-dates with step length smaller than  X  = 2  X  4 . In Newton steps, we run till the change in training loss falls below 5% of the objective. Using stochastic Newton, we run for a fixed number of iterations.
Our claim regarding relational data is that collective fac-torization yields better predictions than using a single ma-trix. We consider the israted task on two relatively small data sets, to allow for repeated trials. Since this task in-volves a three factor model there is a single mixing factor,  X  in Equation 3. We learn a model for several values of  X  , starting from the same initial random parameters, using full Newton steps. The performance on a test set, entries sampled from the matrices according to the test weights, is measured at each  X  . Each trial is repeated ten times to provide 1-standard deviation error bars.

Two scenarios are considered. First, where the users and movies were sampled uniformly at random; all genres that occur in more than 1% of the movies are retained. We only use the users X  ratings on the sampled movies. Second, where we only sample users that rated at most 40 movies, which greatly reduces the number of ratings for each user and each Figure 1: Test errors (MAE) for predicting whether a movie was rated, and the genre, on the dense rat-ing example. Figure 2: Test errors (MAE) for predicting whether a movie was rated, and the genre, on sparse rating example. movie. In the first case, the median number of ratings per user is 60 (the mean, 127); in the second case, the median number of ratings per user is 9 (the mean, 10). In the first case, the median number of ratings per movie is 9 (the mean, 21); in the second case, the median number of ratings per movie is 2 (the mean, 8). In the first case we have n 1 = 500 users and n 2 = 3000 movies and in the second case we have n 1 = 750 users and n 2 = 1000 movies. We use a k = 20 embedding dimension for both matrices.

The dense rating scenario, Figure 1, shows that collec-tive matrix factorization improves both prediction tasks: whether a user rated a movie, and which genres a movie belongs to. When  X  = 1 the model uses only rating infor-mation; when  X  = 0 it uses only genre information.

In the sparse rating scenario, Figure 2, there is far less information in the ratings matrix. Half the movies are rated by only one or two users. Because there is so little infor-mation between users, the extra genre information is more valuable. However, since few users rate the same movies there is no significant improvement in genre prediction.
We hypothesized that adding in the roles of popular ac-tors, in addition to genres, would further improve perfor-mance. By symmetry the update equation for the actor factor is analogous to the update for the genre factor. Since there are over 100,000 actors in our data, most of which appear in only one or two movies, we selected 500 popu-lar actors (those that appeared in more than ten movies). Under a wide variety of settings for the mixing parameters {  X  (12) , X  (23) , X  (24) } there was no statistically significant im-provement on either the israted or rating task. (a) Training Loss (Log-loss) Figure 3: Behaviour of Newton vs. Stochastic New-ton on a three-factor model.
Our claim regarding stochastic optimization is that it pro-vides an efficient alternative to Newton updates in the al-ternating projections algorithm. Since our interest is in the case with a large number of observed relations we use the israted task with genres. There are n 1 = 10000 users, n 2 = 2000 movies, and n 3 = 22 of the most common genres in the data set. The mixing coefficient is  X  = 0 . 5. We set the embedding dimension of both factorizations to k = 30.
On this three factor problem we learn a collective ma-trix factorization using both Newton and stochastic Newton methods with batch sizes of 25, 75, and 100 samples per row. The batch size is larger than the number of genres, and so they are all used. Our primary concern is sampling the larger user-movie matrix. Using Newton steps ten cycles of alternating projection are used; using stochastic Newton steps thirty cycles are used. After each cycle, we measure the training loss (log-loss) and the test error (mean absolute error), which are plotted against the CPU time required to reach the given cycle in Figure 3. This experiment was re-peated five times, yielding 2-standard deviation error bars.
Using only a small fraction of the data we achieve results comparable to full Newton after five iterations. At batch size 100, we are sampling 1% of the users and 5% of the movies; yet its performance on test data is the same as a full Newton step given 8x longer to run. Diminishing returns with respect to batch size suggests that using very large batches is unnecessary. Even if the batch size were equal to max { n 1 ,n 2 ,n 3 } stochastic Newton would not return the same result as full Newton due to the 1 / X  damping factor on the sample Hessian.

It should be noted that rating is a computationally sim-pler problem. On a three factor problem with n 1 = 100000 users, n 2 = 5000 movies, and n 3 = 21 genres, with over 1.3M observed ratings, alternating projection with full New-ton steps runs to convergence in 32 minutes on a single 1.6 GHz CPU. We use a small embedding dimension, k = 20, but one can exploit common tricks for large Hessians. We used the Poisson link for ratings, and the logistic for genres; convergence is typically faster under the identity link.
In this section we provide an example where the addi-tional flexibility of collective matrix factorization leads to better results; and another where a co-clustering model, pLSI-pHITS, has the advantage.

We sample two instances of israted , controlling for the number of ratings each movie has. In the dense data set, the median number of ratings per movie (user) is 11 (76); in the sparse data set, the median number of ratings per movie (user) is 2 (4). In both cases there are 1000 randomly selected users, and 4975 randomly selected movies, all the movies in the dense data set.

Since pLSI-pHITS is a co-clustering method, and our col-lective matrix factorization model is a link prediction method, we choose a measure that favours neither inherently: rank-ing. We induce a ranking of movies for each user, measur-ing the quality of the ranking using mean average precision (MAP) [18]: queries correspond to user X  X  requests for rat-ings,  X  X elevant X  items are the movies of the held-out links, we use only the top 200 movies in each ranking 2 , and the averaging is over users. Most movies are unrated by any given user, and so relevance is available only for a fraction of the items: the absolute MAP values will be small, but relative differences are meaningful. We compare four differ-ent models for generating rankings of movies for users: CMF-Identity : Collective matrix factorization using iden-tity prediction links, f 1 (  X  ) = f 2 (  X  ) =  X  and squared loss. Full Newton steps are used. The regularization and opti-mization parameters are the same as those described in Sec-tion 7.1.1, except that the smallest step length is  X  = 2 The ranking of movies for user i is induced by f ( U i  X  V CMF-Logistic : Like CMF-Identity, except that the match-ing link and loss correspond to a Bernoulli distribution, as in logistic regression: f 1 (  X  ) = f 2 (  X  ) = 1 / (1 + exp pLSI-pHITS : Makes a multinomial assumption on each matrix, which is somewhat unnatural for the rating task X  a rating of 5 stars does not mean that a user and movie participated in the rating relation five times. Hence our use of israted . We give the regularization advantage to pLSI-pHITS. The amount of regularization  X   X  [0 , 1] is chosen at each iteration using tempered EM. The smaller  X  is, the stronger the parameter smoothing towards the uniform dis-tribution. We are also more careful about setting  X  than Cohn et. al. [13], using a decay rate of 0 . 95 and minimum  X  of 0.7. To have a consistent interpretation of iterations be-tween this method and CMF, we use tempering to choose the amount of regularization, and then fit the parameters from a random starting point with the best choice of  X  . Movie rankings are generated using p ( movie | user ).
 Pop : A baseline method that ignores the genre information. It generates a single ranking of movies, in order of how fre-quently they are rated, for all users.
 In each case the models, save popularity ranking, have em-bedding dimension k = 30 and run for at most 10 iterations. We compare on a variety of values of  X  , but we make no claim that mixing information improves the quality of rank-ings. Since  X  is a free parameter we want to confirm the relative performance of these methods at several values. In Figure 4, collective matrix factorization significantly out-performs pLSI-pHITS on the dense data set; the converse is true on the sparse data set. Ratings do not benefit from mixing information in any of the approaches, on either data set. While the flexibility of collective matrix factorization has its advantages, especially computational ones, we do not claim unequivocal superiority over relational models based on matrix co-clustering.
The relations between the curves in Figure 4 are the same if the rankings are not truncated. Figure 4: Ranking movies for users on a data set where each movie has many ratings (dense) or only a handful (sparse). The methods are described in Section 7.4. Errors bars are 1-standard deviation.
We present a unified view of matrix factorization, building on it to provide collective matrix factorization as a model of pairwise relational data. Experimental evidence suggests that mixing information from multiple relations leads to better predictions in our approach, which complements the same observation made in relational co-clustering [23]. Un-der the common assumption of a decomposable, twice differ-entiable loss, we derive a full Newton step in an alternating projection framework. This is practical on relational do-mains with hundreds of thousands of entities and millions of observations. We present a novel application of stochas-tic approximation to collective matrix factorization, which allows one handle even larger matrices using a sampled ap-proximation to the gradient and Hessian, with provable con-vergence and a fast rate of convergence in practice. The authors thank Jon Ostlund for his assistance in merg-ing the Netflix and IMDB data. This research was funded in part by a grant from DARPA X  X  RADAR program. The opinions and conclusions are the authors X  alone.
