 Complutense University of Madrid Uppsala University
Dependency trees used in syntactic parsing often include a root node representing a dummy word prefixed or suffixed to the sentence, a device that is generally considered a mere technical convenience and is tacitly assumed to have no impact on empirical results. We demonstrate that this assumption is false and that the accuracy of data-driven dependency parsers can in fact be sensitive to the existence and placement of the dummy root node. In particular, we show that a greedy, left-to-right, arc-eager transition-based parser consistently performs worse when the dummy root node is placed at the beginning of the sentence (following the current convention in data-driven dependency parsing) than when it is placed at the end or omitted completely.
Control experiments with an arc-standard transition-based parser and an arc-factored graph-based parser reveal no consistent preferences but nevertheless exhibit considerable variation in results depending on root placement. We conclude that the treatment of dummy root nodes in data-driven dependency parsing is an underestimated source of variation in experiments and may also be a parameter worth tuning for some parsers. 1. Introduction
It is a lesson learned in many studies on natural language processing that choosing the right linguistic representation can be crucial for obtaining high accuracy on a given task.
In constituency-based parsing, for example, adding or deleting nodes in syntactic trees can have a substantial impact on the performance of a statistical parser. In dependency parsing, the syntactic representations used offer less opportunity for transformation, given that the nodes of a dependency tree are basically determined by the tokens of the input sentence, except for the possible addition of a dummy word acting as the root of the tree. In this article, we show that even this seemingly trivial modification can make a difference, and that the exact placement of the dummy root node can have a significant impact on the accuracy of a given parser. This suggests that the placement of the dummy root is a parameter worth tuning for certain parsing systems as well as a source of variation to be taken into account when interpreting experimental results. 2. Dependency Graphs
Dependency-based approaches to syntactic parsing assume that the syntactic structure of a sentence can be analyzed in terms of binary dependency relations between lexical of the sentence. It is very natural to represent this structure by a directed graph, with nodes representing input tokens and arcs representing dependency relations.
In addition, we can add labels to arcs in order to distinguish different dependency types or grammatical functions (e.g., subject, object, adverbial). We call such a graph a dependency graph .
 such as the single-head constraint, which forbids more than one incoming arc to a node, and the acyclicity constraint, ruling out cyclic graphs. Many dependency theories and annotation schemes further require that the graph should be a tree, with a unique root token on which all other tokens are transitively dependent, whereas other frameworks allow more than one token to be a root in the sense of not having any incoming arc. A simple and elegant way of reconciling such cross-framework differences and arriving at a single formalization of dependency structures is to add a dummy root node , a special node that does not correspond to any input token, and to require that the dependency graph is a tree rooted at this node. The original tree constraint can then be enforced by requiring that the special node has exactly one child, but not all frameworks need to enforce this constraint. An additional advantage of adding a dummy root node is that its outgoing arcs can be labeled to indicate the functional status of what would otherwise simply be unlabeled root nodes. With a slight misuse of terminology, we call such labels informative root labels . 1 defined position in the node sequence defined by the word order of a sentence and could in principle be inserted anywhere (or nowhere at all). One option that can be found in the literature is to insert it at the end of this sequence, but the more common convention in contemporary research on dependency parsing is to insert it at the beginning, hence treating it as a dummy word prefixed to the sentence. This is also the choice implicitly assumed in the CoNLL data format, used in the CoNLL shared tasks on dependency parsing in 2006 and 2007 (Buchholz and Marsi 2006; Nivre et al. 2007) and the current de facto standard for exchange of dependency annotated data.
 a harmless technicality permitting us to treat different dependency theories uniformly, and whether its placement in the input sequence is purely arbitrary, or whether both of these choices may in fact have an impact on the parsing accuracy that can be achieved with a given parsing model. In order to investigate this question empirically, we define three different types of dependency graphs that differ only with respect to the existence and placement of the dummy root node: 1. None: Only nodes corresponding to tokens are included in the graph. 2. First: A dummy root node is added as the first token in the sentence. 3. Last: A dummy root node is added as the last token in the sentence. 6
Figure 1 illustrates the three types of dependency graphs with examples taken from the Penn Treebank of English (Marcus, Santorini, and Marcinkiewicz 1993) converted to dependency structure using the procedure described in Nivre (2006), and the Prague
Dependency Treebank of Czech (Haji  X  c et al. 2001; B  X  ohmov  X  a et al. 2003). In the former case, it is assumed that the dummy root node always has exactly one child, with a dummy dependency label ROOT . In the latter case, the dummy root node may have several children and these children have informative root labels indicating their func-tion (Pred and AuxK in the example). Note also that the Czech dependency graph of type None is not a tree, but a forest, because it consists of two disjoint trees. 3. Experiments
In order to test the hypothesis that the existence and placement of the dummy root node can have an impact on parsing accuracy, we performed an experiment using two widely used data-driven dependency parsers, MaltParser (Nivre, Hall, and Nilsson 2006) and
MSTParser (McDonald 2006), and all the 13 data sets from the CoNLL 2006 shared task on multilingual dependency parsing (Buchholz and Marsi 2006) as well as the
English Penn Treebank converted to Stanford dependencies (de Marneffe, MacCartney, and Manning 2006). We created three different versions of each data set, corresponding to the representation types None, First, and Last, and used them to evaluate MaltParser with two different transition systems X  X rc-eager (Nivre 2003) and arc-standard (Nivre 2004) X  X nd MSTParser with the arc-factored non-projective algorithm (McDonald et al. 2005). The results are shown in Table 1.
 task as None, because it does not include the dummy root node as an explicit input token. In this representation, the tokens of a sentence are indexed from 1 to n and the dependency graph is specified by giving each word a head index ranging from 0 to n , where 0 signifies that the token is not a dependent on any other token in the sentence.
The First version was created by adding an extra token at the beginning of the sentence with index 1 and head index 0, increasing all other token and head indices by 1, meaning that all tokens that previously had a head index of 0 would now be attached to the new 8 dummy root token. The Last version was created by adding an extra token at the end of the sentence with index n +1, and changing every head index that previously was 0 to n +1. In both First and Last, we made sure that the new dummy token had a unique word form and unique values for all other features, so that it could not be mistaken for any real word. For First and Last, we applied an inverse transformation to the parser output before evaluation.
 ginning of the sentence internally before parsing, so we had to modify the parsers so that they only considered arcs involving nodes corresponding to input tokens. For
MaltParser this only required setting a flag that makes the parser start with an empty stack instead of a stack containing an extra dummy root node. modified the parser implementation so that it extracts a maximum spanning tree that is still rooted in an extra dummy root node but where the score of a tree is based only on the scores of arcs connecting real token nodes. Finally, because MaltParser with the arc-eager and arc-standard transition systems can only construct projective dependency graphs, we projectivized all training sets before training the MaltParser models using the baseline pseudo-projective transformation of Nivre and Nilsson (2005). these modifications, all parsers were run with out-of-the-box settings. 3.1 Deterministic Arc-Eager Parsing
The arc-eager transition-based parser first described in Nivre (2003) parses a sentence and greedily choosing the highest-scoring parsing action at each point. The arc-eager opportunity, which means that right-dependents are attached to their head before they have found their own right-dependents. This can be an advantage because the early attachment neither implies nor precludes the later addition of right-dependents, but it can also be a drawback because it forces the parser to make an early commitment about right-dependents. In this context, it is especially relevant that the addition of a dummy root node at the beginning of the sentence (First) forces the parser to make an early commitment regarding dependents of this root node. By contrast, if a dummy root node is added at the end of a sentence (Last), decisions regarding root dependents will be postponed until the end. Similarly, if no root node is added (None), then these decisions will not be explicitly modeled at all, meaning that whatever nodes remain on the stack after parsing will be treated as root dependents.
 the First condition, with an average unlabeled attachment score (UAS) of 83.67 over the 14 languages, to be compared with 84.35 for None and Last. The difference in accuracy between First and None/Last ranges from 0.10 for Dutch to 1.72/1.78 for Slovene, and the difference in means is highly statistically significant (p &lt; 0 . 001, Wilcoxon signed-rank test). The difference between None and Last is never greater than 0.20 (and very far from statistically significant), indicating that either postponing or excluding root attachment decisions leads to very similar performance for the arc-eager parser. The same pattern is found for labeled attachment score (LAS), but here we can only directly compare First and Last because the Arabic, Czech, Portuguese, and Slovene data sets contain informative root labels that cannot be predicted under the None condition (cf. footnote 2). The difference in means between First and Last is 0.80 and again highly statistically significant (p &lt; 0 . 001, Wilcoxon signed-rank test). A closer look at the root accuracy suggests that most of the difference stems from a lower recall on root depen-dents with the First representation, but this pattern is not completely consistent across languages and Arabic, Czech, and Dutch actually have higher recall. For Czech and
Dutch this is accompanied by lower precision, but for Arabic the First representation actually gives the best recall and precision of root dependents (but nevertheless the worst overall attachment score). It is probably significant that the Arabic data set has the longest sentences with the root word often appearing early in the sentence. Hence, an early commitment to root attachment is more likely to be correct in this case, even if it is more error prone in general. 3.2 Deterministic Arc-Standard Parsing
The arc-standard transition-based parser first described in Nivre (2004) is similar to the arc-eager parser in that it parses a sentence in a single pass from left to right, using a stack to store partially processed tokens and greedily choosing the highest-scoring parsing action at each point. It differs by postponing the attachment of right-dependents until the complete subtree under the dependent itself has been built. As a consequence, the dependency tree is built strictly bottom X  X p, which means that attachment to a dummy root node will always happen at the end, regardless of whether the dummy root node is positioned at the beginning or at the end of the sentence. There is therefore no reason to expect that the placement of the dummy root node should have the same impact as for the arc-eager parser.
 tion, with the three conditions giving very similar mean UAS (84.41 for None, 84.44 for
First, 84.38 for Last) and none of the differences being statistically significant. For LAS, we can again only directly compare First and Last, but there is practically no difference noting that, for individual languages, differences in scores can be quite substantial.
Thus, for Dutch, the First condition outperforms the None/Last condition by 0.80/0.78 in UAS and 0.40/0.42 in LAS. Conversely, for Japanese, the None/Last conditions are better than First by 0.73/0.71 in UAS and 1.02/0.88 in LAS. Although the general trend there are also cases like Chinese where None and First are both slightly better than
Last. Zooming in on root accuracy, we see a clear gain in precision (and marginal drop in recall) for the First representation, which is probably an effect of the arc-standard strategy where the attachment of right-dependents often have to be delayed whereas left-dependents can be attached eagerly. 3.3 Maximum Spanning Tree Parsing
The maximum spanning tree parser described in McDonald et al. (2005) uses a very different parsing model compared with the two transition-based parsers. Instead of scoring individual parsing actions, it scores all possible dependency arcs in the sentence and then uses exact inference to extract the highest-scoring complete dependency tree 10 under an arc-factored model, where the score of each tree is the sum of the scores of its component arcs. Because the parsing algorithm does not impose any ordering at all on different attachments, we would expect even less impact from the placement of the dummy root node than for the deterministic arc-standard parser.
 from 86.44 for the Last condition to 86.60 for the First condition, and the mean LAS statistically significant on the aggregate level, differences can be quite substantial for individual languages, with First outperforming Last by a whole percentage point in
UAS for Portuguese (but only 0.30 in LAS) and None outperforming both First and Last by 0.64 for Arabic (and 0.32 in LAS). The fact that LAS differences tend to be smaller than UAS differences can probably be explained by the fact that MSTParser uses a two-stage approach, where the second labeling stage is the same for all three conditions. With respect to root accuracy, the most interesting observation is that both First and
Last seem to given higher precision than None, which suggests that it is an advantage to represent root attachments explicitly so that features over these arcs can contribute to the overall score of a parse tree. It is also worth noting that these features are different for First and Last, despite the arc-factored model, because of the so-called  X  X n-between features X  that record the part-of-speech tags of words occurring between the head and the dependent of an arc, which in turn explains why these two conditions do not always give the same results. 4. Discussion
The main conclusion we draw from this experiment is that the addition of a dummy word prefixed or suffixed to a sentence is not a mere technical convenience without impact on empirical results. Whether we include a dummy word representing the root of the dependency tree and, if so, where we place this word in the sequence of input tokens, can have a non-negligible effect on parsing accuracy for different parsers X  X n some cases resulting in statistically significant differences with a magnitude of several percentage points according to standard evaluation metrics.
 used. Whereas the deterministic arc-eager parser gives consistently worse results with a dummy root node positioned at the beginning of the sentence, neither the deterministic arc-standard parser nor the maximum spanning tree parser has any clear preference in this respect. Although the overall patterns emerging when averaging over many data sets can largely be explained in this way, there is also considerable variation across data sets that we do not yet fully understand, however. Zooming in on root accuracy has allowed us to start forming hypotheses, such as the impact of long sentences in com-bination with predominantly head-initial structures for Arabic, but a full exploration of the interaction of parsing models and language-specific properties is clearly outside the current study is that it only examines three different parsers, and although this is clearly sufficient to prove the existence of the phenomenon it will be interesting to see whether the same patterns can be found if we examine more recent state-of-the-art methods, going from deterministic parsing to beam search for transition-based parsing and from arc-factored to higher-order models for graph-based parsing. In this context, and Dell X  X rletta (2009), which have tried to improve parsing accuracy by switching or combining parsing directions, which implicitly has the effect of changing the position of the root node (if present).
 our experiments. The first is that, for certain parsing models, the existence and place-ment of the dummy root node is in fact a parameter worth tuning for best performance.
Thus, for the deterministic arc-eager parser, it seems that we can obtain higher parsing accuracy by placing the dummy root node at the end of the sentence (or omitting the norm in data-driven dependency parsing. The second lesson is that, because the differences observed between different conditions are sometimes at least as large as the differences considered significant when comparing different parsing models, the status of the dummy root node may be an underestimated source of variation and a variable that needs to be controlled for in experimental evaluations. The current practice ensuring comparability of results, but given the arbitrariness of this decision together with our experimental results, it may be worth exploring other representations as well. Acknowledgments References 12
