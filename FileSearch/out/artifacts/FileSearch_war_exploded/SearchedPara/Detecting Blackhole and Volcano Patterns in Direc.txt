 Financial institutions and government agencies, such as U.S. Securities and Exchange Commission (SEC), are facing some daunting challenges in the field of financial fraud detection. The sophistication of criminals X  tactics makes detecting and preventing fraud difficult, especially as the number of trading accounts and the volume of transac-tions grow dramatically. Indeed, the trading networks are vulnerable to these fast-growing accounts and the volume of transactions. Particularly, criminals know fraud detection systems are not good at correlating user behavior across multiple trading accounts. This weakness opens the door for cross-account collaborative fraud, which is difficult to discover, track and resolve because the activities of the fraudsters usually appear to be normal trading activities. For instance, consider a trading network with a large number of nodes and directed edges, a trader or a group of traders can perform trading only within several accounts for the purpose of manipulating the market. This kind of illegal trading activities is widely known as trading ring.
In this paper, we study a special type of trading-ring patterns, called blackhole and volcano patterns. Given a directed graph, a blackhole pattern is a group which is made of a set of nodes in a way such that there are only inlinks to this group from the rest nodes in the graph. In contrast, a volcano pattern is a group which only has outlinks to the rest nodes in the graph. To the best of our knowledge, this is the first time to have the concepts of blackhole and volcano patterns in the directed graphs. In fact, both blackhole and volcano patterns can be observed in real-world trading networks. For example, a blackhole pattern can represent a group of traders who are manipulating the market by performing transactions on a specific stock among themselves for a specific time period. In other words, the overall shares of the target stock in their trading accounts can only increase during this time period, while these traders have produced a large volume of transactions on this stock. After the stock price goes up to a certain degree, these traders start selling off their shares to the public. In this stage, these trading accounts form a volcano pattern which only has outlinks to the rest public accounts.

However, the process for finding blackhole and volcano patterns can be computationally prohibited, since this is a combinatorial problem in nature. To address this challenge, we first prove that the blackhole pattern mining problem is a dual problem of finding volcano patterns. Therefore, we can focus on finding the blackhole patterns. Along this line, we design two pruning schemes to guide the blackhole pattern mining process. In the first pruning scheme, we identify a set of pattern-size-independent pruning rules by studying the structural graph properties of blackhole patterns. These pruning rules can be used for pruning the search space no matter the size of the patterns is. Based on the first pruning scheme, we design an iBlackhole algorithm for finding blackhole patterns. In contrast, the second pruning scheme follows a divide-and-conquer strategy to further exploit the pruning results from the first pruning scheme. Specifically, because a target directed graph have been divided into several disconnected subgraphs by the first pruning scheme, it becomes much more efficient to find blackhole patterns in each disconnected subgraphs rather than in a large graph. Based on these two pruning schemes, we develop an even more effective algorithm, named iBlackhole-DC, for mining blackhole patterns in directed graphs. Furthermore, we have provided the proof of the completeness and correctness of both iBlackhole and iBlackhole-DC algorithms.

Finally, experimental results on several real-world data sets are provided to show the pruning effect of two pruning schemes. As shown in experiments, the iBlackhole algorithm has a huge computational advantage over the brute-force approach. Also, the iBlackhole-DC algorithm is several orders of magnitude faster than the iBlackhole algorithm. Finally, we show the effectiveness of blackhole patterns for finding some interesting stock movement patterns.
In this section, we introduce some basic concepts and notations that will be used in this paper.

First, consider a directed graph  X  =(  X , X  ) [1], where  X  is the set of all nodes and  X  is the set of all edges. Assume that  X  has no self-loop and has no more than one edge from one node to another. A directed edge  X  in  X  is denoted as  X  =(  X ,  X  ) , where  X  and  X  are nodes of  X  and an arc is directed from  X  to  X  . Each edge  X  has a positive weight, denoted as  X   X  , associated with this edge.

Definition 1 (in-weight / out-weight): Given a directed graph  X  =(  X , X  ) ,  X  is a set of nodes and  X   X   X  . Let  X  =  X   X   X  .The in-weight of  X  is defined as:  X   X  X  X  (  X  )= the out-weight of B is:  X   X  X  X  X  (  X  )=
Figure 1 shows an example of the in-weight and out-weight of a set of nodes. The number associated with each edge is the weight of that edge. In this figure, the in-weight of  X  is 6+5=11 , while the out-weight is 3+3+1+2=9 .
Next, we give the definition of blackhole and volcano in a directed graph as follows.

Definition 2 (blackhole): Given a directed graph  X  = (  X , X  ) , we say that a set of nodes  X   X   X  form a blackhole, if and only if the following two conditions are satisfied: 1)  X   X   X  X  X  2 , and the subgraph  X  (  X  ) induced by  X  is weakly connected, and 2)  X   X  X  X  (  X  )  X   X   X  X  X  X  (  X  ) &gt; X  , where  X  defined positive threshold and is typically a very large value.
Definition 3 (volcano): Given a directed graph  X  = (  X , X  ) , we say that a set of nodes  X  X  X  X   X   X  form a volcano, if and only if the following two conditions are satisfied: 1)  X   X  X  X  X   X  X  X  2 , and the subgraph  X  (  X  X  X  X  ) induced by  X  X  X  X  is weakly connected, and 2)  X   X  X  X  X  (  X  X  X  X  )  X   X   X  X  X  (  X  X  X  X  ) &gt; X   X  is a pre-defined positive threshold and is typically a very large value.

In this section, we formulate the problems of detecting blackhole and volcano patterns in a directed graph. A. A General Problem Formulation
Given a directed graph  X  =(  X , X  ) , the goal of detecting blackhole patterns in  X  is to find out the blackhole set, denoted as  X  X  X  X  X  X  X  X  X  X  X  X  X  , such that, 1) for each element  X   X   X  X  X  X  X  X  X  X  X  X  X  X  X  ,  X   X   X  and  X  satisfies the definition of blackhole , and 2) for any other set of nodes  X   X   X  and  X   X   X   X  X  X  X  X  X  X  X  X  X  X  X  X  , C does not satisfy the definition of blackhole . The problem of detecting volcano patterns can be formulated in a similar fashion.

Next, we show that the problem of detecting blackhole patterns is a dual problem of detecting volcano patterns.
Theorem 1: The problem of finding out the blackhole set in a directed graph is a dual problem of finding out the volcano set in the same directed graph.
 (  X , X   X  ) be the inverse graph of  X  , where all the nodes in are the same as in  X  ; while for each edge  X  =(  X ,  X  )  X   X  there is an edge  X   X  =(  X , X  )  X   X   X  , and the weight associated with  X   X  are exactly the same as the weight associated with Therefore, the in-weight of a set of nodes  X  in  X  are exactly the same as the out-weight of  X  in  X   X  , and vice versa. If is a blackhole in  X  , which means  X   X  X  X  (  X  )  X   X   X  X  X  X  (  X  ) &gt; X   X  , then in  X   X  ,wehave  X   X  X  X  X  (  X  )  X   X   X  X  X  (  X  ) &gt; X  . Therefore, forms a volcano in  X   X  . As a result, the problem of finding out the blackhole set in  X  is equivalent to the problem of finding out the volcano set in  X   X  .

Now that we know the problem of detecting the blackhole set in the original directed graph is equivalent to the problem of detecting the volcano set in the inverse graph. Therefore, in the rest of this paper, we can focus on detecting blackhole patterns in a directed graph.
 B. A Simplified Problem Formulation
The above general problem of detecting blackhole patterns is very complex. Instead, in this paper, we focus on a more practical version of this problem. Specifically, we exploit two constraints to simplify the general problem as follows. 1) The weights associated with all edges are all equal to This constraint results that the in-weight of a node becomes the in-degree and the out-weight becomes the out-degree; 2) Instead of considering the general version of a blackhole, which satisfies  X   X  X  X  (  X  )  X   X   X  X  X  X  (  X  ) &gt; X  , we simplify the  X  X  X  X  X  X  X  X  X  X  X  X  X  definition with  X   X  X  X  X  (  X  )=0 .

Figure 2 shows an example of the simplified blackhole patterns. In this figure, there are two blackhole patterns, which have been highlighted by dashed circles.

In this section, we introduce the algorithms for detecting blackhole patterns in a directed graph.
 A. A Brute-Force Approach
First, we present a brute-force approach for finding black-hole patterns. From the definition, a set of nodes  X   X   X  is a simplified blackhole, if and only if: 1)  X   X   X  X  X  2 , and the subgraph  X  (  X  ) induced by  X  is weakly connected, and 2)  X   X  X  X  X  (  X  )=0 . Therefore, the intuition is really simple: all the possible combinations of the nodes in  X  are checked using the exhaustive search method. For each combination  X  , if the subgraph  X  (  X  ) induced by  X  is weakly connected and  X   X  X  X  X  (  X  )=0 , then  X  is a blackhole in  X  .

In real-world scenarios, it is typically computational pro-hibited to find all blackhole patterns, since the number of combinations of the nodes is exponentially increased as the number of nodes increase. A practical way is to find blackhole patterns which include only limited number of nodes. Here, we introduce a concept of  X  - X  X  X  X  X  X   X  X  X  X  X  X  X  X  X  X  X  X  X 
Definition 4 (n-node blackhole): Given a directed graph  X  =(  X , X  ) , we say that a set of nodes  X   X   X  is an n-node blackhole, if and only if the following two conditions are satisfied: 1)  X  is a blackhole in  X  , and 2)  X   X   X  (  X  ) , where  X  (  X  ) is the set of all possible subsets containing  X  nodes in V; that is,  X   X   X  =  X  .

Figure 3 shows the pseudocode of the brute-force algo-rithm to detect 2 through n-node blackhole patterns in a directed graph  X  . Since we have considered all the possible combinations of nodes in  X  from 2 through n, this algorithm is complete. Also, since for each combination of nodes, we have checked whether it satisfies the definition of blackhole, this algorithm is correct.
 B. A Scheme of the iBlackhole Algorithm
In general, finding blackhole patterns in a directed graph is a combinatorial problem. Therefore, as the number of nodes  X  increases, the computation time increases exponentially, making the brute-force algorithm unrealistic to obtain the result for a large  X  value. To this end, we introduce some pattern-size-independent pruning rules to reduce the search space. The key idea behind these pruning rules is to find out irrelevant nodes that have no chance to form an n-node blackhole as many as possible, and eliminate these nodes from the candidate search list. In this way, the search space can be reduced dramatically. The algorithm developed based on these pruning rules is named as iBlackhole .

Figure 4 shows the scheme of the iBlackhole algorithm for detecting 2 through n-node blackhole patterns in a directed graph  X  . In this algorithm, all blackhole patterns are identified one by one according to their number of nodes. In each step of finding the i-node blackhole patterns, a potential list  X   X  is first established. Only the nodes in this potential list have possibilities to form an i-node blackhole. In other words, nodes that are not in this list have no chance to be in an i-node blackhole pattern. Then nodes in  X   X  will be examined one after another and irrelevant nodes will be deleted based on some pruning rules. The results of this pruning form a candidate list  X   X  . For each node v in  X   X  we will check it again and remove irrelevant nodes from  X  using some additional pruning rules. Finally, we will have the final search list  X   X  , and then we can apply the brute-force algorithm on  X   X  to find out all i-node blackhole patterns. More details about this algorithm will be given after we introduce some pruning rules.
 C. Pruning Rules
In this section, we introduce pruning rules associated with the potential list, the candidate list, and the final search list.
Definition 5 (directed path): Given a directed graph  X  = (  X , X  ) ,  X  0 , X  1 , X  2 ,..., X   X   X   X  ,  X  1 , X  2 ,..., X   X   X   X  where  X   X  =(  X   X   X  1 , X   X  ) . We say that the sequence of  X   X  1  X  1  X  2  X  2 ... X   X   X   X  forms a directed path from  X  0 if  X   X   X  =  X   X  for all 0  X   X ,  X   X   X  ,  X   X  =  X  . The length of this directed path is  X  .

Definition 6 (reachable): Given a directed graph  X  = (  X , X  ) ,  X ,  X   X   X  . We say that  X  is reachable from  X  if there is a directed path that starts from  X  and ends at  X 
Definition 7 (predecessor and successor): Given a di-rected graph  X  =(  X , X  ) ,  X ,  X   X   X  .If  X  is reachable from  X  , then we say  X  is a predecessor of  X  , and  X  is a successor of  X  . If there is an edge from  X  to  X  , then  X  is a direct predecessor of  X  , and  X  is a direct successor of  X  .
Lemma 1: If a node  X   X   X  , where  X   X   X  is a blackhole, then all the direct successors of  X  are all in  X  . that there is at least one of  X   X   X  direct successors  X  , and  X   X   X   X  , then we have  X   X  X  X  X  (  X  )  X  1 since  X  =(  X , X  )  X   X  and  X   X   X   X  . This contradicts with the definition of blackhole. Therefore, all direct successors of  X  should be in  X  . Based on Lemma 1, we have the following lemma.

Lemma 2: In an n-node blackhole  X  , the maximum out-degree of any node in  X  is  X   X  1 .
 there is a node  X  with out-degree at least  X  in an n-node blackhole  X  , then  X  should have at least  X  direct successors, denoted as  X  1 , X  2 ,..., X   X  . According to Lemma 1, if  X   X   X  all of  X  1 , X  2 ,..., X   X  should be in  X  , which makes the size of this blackhole at least  X  +1 . Then we find a contradiction here. Therefore, the maximum out-degree of any node in an n-node blackhole should be no greater than  X   X  1 .
According to Lemma 2, we can derive the following theorem for pruning the potential list  X   X  .

Theorem 2: For the potential list  X   X  , only nodes with out-degree less than  X  need to be considered.
 node in an n-node blackhole is  X   X  1 . In other words, nodes with out-degree greater than  X   X  1 have no chance to be in an i-node blackhole. Therefore, only nodes with out-degree less than  X  needs to be included in the potential list  X   X 
According to Theorem 2, only the nodes with out-degree less than  X  are used to establish the potential list  X   X  .After having  X   X  , some additional pruning rules can be applied to remove irrelevant nodes from  X   X  to get the candidate list
Lemma 3: For each node  X   X   X   X  , if there is at least one of  X   X   X  direct successors  X   X   X   X   X  , then  X   X   X   X   X  .  X   X   X   X   X  , this means  X  has no chance to be in an i-node blackhole. Assume that finally  X  belongs to an i-node blackhole  X  . According to Lemma 1, all  X   X   X  direct successors, which include  X  , will also belong to  X  . Then we have a contradiction here. Therefore,  X  has no chance to form an i-node blackhole, and thus  X  can be removed from  X   X  safely; that is,  X   X   X   X   X  .

After a node is removed from  X   X  , there are some other nodes associated with it can also be removed from  X   X  .
Lemma 4: If a node  X  is removed from  X   X  , then all of its direct predecessors can also be removed from  X   X  .  X   X   X  direct successor. Since  X  has been removed from  X   X  then  X   X   X   X   X  . According to Lemma 3,  X  should also be removed from  X   X  . Therefore, all  X   X   X  direct predecessors can be removed from  X   X  .
By Lemma 4, when removing a node  X  from  X   X  , all its direct predecessors should also be removed. Then, the newly removed direct predecessors become the new  X  X   X   X  X  s. Finally, the cascading delete will spread to all  X   X   X  predecessors. Figure 5 shows an example of the cascading delete process when removing node  X  from the potential list  X  3 .The shadow nodes in the figures are nodes removed from  X  3 . In Figure 5 (  X  ) ,  X  has an out-degree of 3 , which makes it exclude from  X  3 at the first place. When nodes in  X  3 are checked one after another, it can be noticed that  X  has a successor  X  not in  X  3 . Therefore,  X  is removed from  X  3 Then all of  X   X   X  direct predecessors are all deleted from as shown in Figure 5 (  X  ) , and this process spreads to all predecessors in Figure 5 (  X  ) .

By applying Lemma 3 and Lemma 4, we prune rules irrelevant nodes from  X   X  , and get the candidate list  X   X  Before going any further, we would like to introduce another concept first.
Definition 8 (closure): Given a directed graph  X  = (  X , X  ) ,  X   X   X  . The closure of  X  , denoted as  X  + , is defined as:  X  + = {  X   X  there is a directed path from v to s }
Figure 6 shows an example of the closure of node  X  .In this figure,  X  + = {  X , X , X , X , X , X  } . Indeed, the closure of a node has an important feature as the following.
 Theorem 3: The closure of a node  X  is a blackhole. Moreover, it is a subset of any blackhole that contains  X  nition of closure ,  X  + is the set of all nodes reachable from  X  , together with  X  .If  X  + does not form a blackhole, there have to be at least an edge  X  =(  X ,  X  )  X   X  , such that  X   X   X  + and  X   X   X   X  + .If  X  =  X  , then  X  is reachable from  X  ,wehave  X   X   X  + ;If  X   X  =  X  , since there is a directed path from and  X  =(  X ,  X  ) ,  X  can be reached from  X  . We can also have  X   X   X  + . In either condition, we can have a contradiction here. Therefore,  X  + is a blackhole.

For the second part of this theorem, if a blackhole  X  contains  X  , by Lemma 1, all  X   X   X  direct successors should all be in  X  . And then these direct successors become the new  X  X   X   X  X  s. Eventually, this procedure will be spread to all the successors. The above leads to  X  +  X   X  .

The feature of closure (Theorem 3) can be used to derive some pruning rules to remove some irrelevant nodes from  X  , and finally lead to the final search list  X   X  .
Lemma 5: For each node  X   X   X   X  ,if  X   X  +  X  &gt; X  , then  X  all its predecessors are not in  X   X  .
 which contains  X  . Suppose  X  is in an i-node blackhole  X  . Then we have  X  +  X   X  .So  X   X   X  X  X  X   X  +  X  &gt; X  . We can have a contradiction here. Therefore,  X  has no chance to form an i-node blackhole, and we can remove  X  from  X   X  safely. Then, the similar cascading delete procedure can be applied, and thus all the  X   X   X  predecessors can be deleted from  X  Therefore,  X  and all its predecessors will not be in  X   X  .
Lemma 6: For each node  X   X   X   X  ,if  X   X  +  X  =  X  , then  X  + can be outputted as an i-node blackhole. Also,  X  and all its predecessors can be removed from  X   X  .
 Since  X   X  +  X  =  X  ,  X  + can be outputted as an i-node blackhole. Assume that  X  will also be in another blackhole  X  .By Theorem 3,  X  +  X   X  .If  X   X   X  &gt; X  ,  X  is not an i-node blackhole and cannot be outputted as an i-node blackhole; If  X   X   X  =  X  then  X  is exactly  X  + , and has already been out putted as an i-node blackhole. In either situation, we can remove  X  from  X   X  . Then the similar cascading delete procedure can be applied, and finally all  X   X   X  predecessors will be deleted from  X   X  .

Lemma 5 and Lemma 6 are used as pruning rules to prune the candidate list  X   X  and get the final search list  X   X  .After having  X   X  , we can apply the brute-force approach on  X   X  find out all i-node blackhole patterns. In the next subsection, we will give the details of the iBlackhole algorithm. D. The iBlackhole Algorithm
The iBlackhole algorithm exploits the pruning rules stated from Lemma 1 to Lemma 6. Figure 7 shows the detailed pseudocode of the iBlackhole algorithm. Specifically, Line 3 establishes the potential list  X   X  . Lines 4 -11 remove irrelevant nodes from  X   X  , and get the candidate list  X   X  12 -23 remove irrelevant nodes from  X   X  , and get the final search list  X   X  . Lines 24 -30 apply the brute-force approach on  X   X  to find out all i-node blackhole patterns.
Completeness and Correctness . In the iBlackhole algo-rithm, since only the nodes that have no chance to form an i-node blackhole pattern are removed in each iteration  X  (this is guaranteed by Lemma 1 through Lemma 6). In other words, all the possible combinations of nodes have been checked to produce  X   X  , this algorithm is complete. Also, for each candidate blackhole pattern, since we have checked whether this candidate pattern satisfies the definition of blackhole or not, this algorithm is correct.

Figure 8 shows an example of the procedure of the iBlackhole algorithm when searching the 3-node blackhole patterns. The shadow nodes in the figures are nodes which have been deleted. In Figure 8 (  X  ) ,  X  has an out-degree of so  X  can be deleted from  X  3 at the first place. In Figure 8 when we check the nodes in  X  3 one after another, we notice that  X  has a successor  X  not in  X  3 . Therefore, we can remove  X  from  X  3 . Then, all the direct predecessors of  X  can be cascaded deleted from  X  3 , and this delete process spreads to all  X   X   X  predecessors. Finally, we have the candidate list  X  3 = {  X ,  X ,  X ,  X ,  X ,  X  } . In Figure 8 (  X  ) , we find that Therefore, we output  X  + = {  X ,  X ,  X  } as a 3-node blackhole, and delete  X  from  X  3 . Now, we have the final search list  X  3 = {  X ,  X ,  X ,  X ,  X  } . In Figure 8 (  X  ) , we examine each 3-combination of nodes in  X  3 , and find out a 3-node blackhole {  X ,  X ,  X  } . Therefore, there are two 3-node blackhole patterns in this example, {  X ,  X ,  X  } and {  X ,  X ,  X  } respectively. E. The iBlackhole-DC Algorithm
While the search space has been reduced dramatically in the iBlackhole algorithm, it is still possible to develop some pruning strategies for the graphs with some special characteristics. Indeed, for a node  X   X   X  ,  X  can only form a blackhole pattern with nodes within the same weakly connected component in  X  by the blackhole definition. Therefore, if a directed graph has several weakly connected components, which are not connected to each other, a divide-and-conquer pruning strategy can be exploited for first identifying these weakly connected components and the blackhole finding method can be conducted in each weakly connected component. This pruning strategy can drastically divide a large exponential growth search space into several much smaller exponential growth search space, and thus reducing a lot of computational cost.

Along this line, we combine the iBlackhole algorithm with this divide-and-conquer pruning strategy and develop an even more effective algorithm, named iBlackhole-DC, for finding blackhole patterns. Figure 9 shows the scheme of this algorithm for finding out 2 through n-node blackhole patterns in a directed graph  X  .
 The completeness and correctness of the iBlackhole-DC algorithm is straightforward. Since the only difference between iBlackhole and iBlackhole-DC is the use of the divide-and-conquer strategy. We know that the iBlackhole algorithm is complete and correct. Also, the divide-and-conquer strategy only separates the nodes which cannot form blackhole patterns. Therefore, the iBlackhole-DC algorithm is also complete and correct.

In this section, we present the experimental results to evaluate the performances of Brute-Force, iBlackhole and iBlackhole-DC algorithms.
 A. The Experimental Setup
Experimental Data. The experiments were conducted on four real-world data sets: Wiki , Amazon , Roget , and Stock . Table I shows some basic characteristics of these data sets.

Wiki Data Set. There are 7,115 nodes and 103,689 edges in the Wiki data set [2]. To make the brute-force algorithm runnable, we derived three subgraphs from the original graph, with the number of nodes 500, 1,000, and 1,500 respectively. These subgraphs are named as Wiki500 , Wiki1000 , and Wiki1500 separately. In addition, we synthesized a weakly connected directed graph, named as Wiki1500-full , by adding some edges to Wiki1500 data set.

Amazon Data Set. There are 262,111 nodes and 1,234,877 edges in the Amazon data set [3]. Similar to the Wiki data set, we derived a subgraph Amazon1000 with 1000 nodes, and synthesized a weakly connected directed graph Amazon500-full from the original graph.

Roget Data Set. There are 1,022 nodes and 5,075 edges in the Roget data set [4]. Also, we synthesized a weakly connected directed graph Roget-full from the original graph, by adding some edges to it.

Stock Data Set. This is a data set generated by our-selves. Specifically, we collected daily stock prices from Wharton Research Data Services [5] of 3,081 instruments in the U.S. stock market over a period of 125 consecutive trad-ing days from Jan 2, 2008 to Jun 30, 2008. We tried to avoid selecting the period with a strong movement trend in the stock market, since the movements of all instruments during that period tend to have high correlations among each other. As can be seen in Figure 10, there was no strong trend in the Dow Jones index during the selected period. Then we re-moved instruments in Dow Jones and S&amp;P 500 indexes from our collection. Those instruments are more representative in the stock market and therefore tend to have high correlations with the other instruments. Since we target on finding out some not-so-obvious blackhole patterns, we only consider instruments not in Dow Jones and S&amp;P 500 indexes. After that, we constructed the Stock data set as follows. 1) Nodes in this data set correspond to instruments. There are 2,453 nodes in this data set; 2) we build a vector  X   X  = {  X  is the closing price of instrument  X  on day  X  ; 3) we create a Boolean vector  X   X  = {  X   X  1 , X   X  2 ,..., X   X   X  ,..., X   X  on  X   X  , where  X   X   X  =1 , X  X  X   X   X   X  +1  X   X   X   X  ,  X  X  X  X  X  X  X  X  X  X  X  X  X  0  X  = {  X  1 ,..., X   X  ,..., X   X  } and  X  = {  X  1 ,..., X   X  ,..., X   X   X  X  X  (  X  ) is the lagged correlation when  X  is delayed by  X  A symmetric situation can be applied to get  X   X  X  (  X  ) .We compute the lagged correlations  X   X  X  X  (1) and  X   X  X  X  (1) for each pair of instrument  X  and  X  ; 5) there is an edge from node node  X  ,if  X   X  X  X  (1) &gt; X  , where  X  is a pre-defined threshold, and vice versa. Since we compute the lagged correlation of 1-day delay between two instruments, if there is an edge from node  X  to node  X  , it indicates the movement of instrument followed the movement of instrument  X  on the previous day. Here, we specify  X  as 0 . 35 to get Stock-0.35 data set.
Note that the method we used to construct the Stock data set is similar to the way in [6]. However, there are some differences. We used the lagged Pearson correlation among instruments, and ended up with a directed graph. While Boginski et al [6] employed the general Pearson correlation and constructed an undirected graph.

Experimental Platform. All the experiments were per-formed on a Dell Optiplex 960 Desktop with Intel Core 2 Quad Processor Q9550 and 4 GB of memory running the Windows XP Professional Service Pack 3 operating system. B. An Overall Comparison In this subsection, we provide an overall comparison of Brute-Force, iBlackhole, and iBlackhole-DC algorithms.
First, we compare the performances of three algorithms on different data sets with almost the same number of nodes. In this experiment, we choose data sets Wiki1000 , Amazon1000 , and Roget . Figure 11 shows the running time of these algorithms. As can be seen, both Brute-Force and iBlackhole algorithms are runnable within certain number of nodes, while iBlackhole can go a litter bit further than Brute-Force. In contrast, the iBlackhole-DC algorithm is runnable for finding n-node blackhole patterns with a large  X  value.

The running time of three algorithms for detecting black-hole patterns with different number of nodes forms three approximately straight lines in logarithm scale for all three data sets. (For iBlackhole-DC, it is more clear if we only focus on  X   X  4 ). This indicates that the running time for those algorithms follow an exponential increasing time. Also, the slopes of three performance curves for each data set are significantly different. For Brute-Force, since we do the exhaust search at the beginning and the number of nodes of the three data sets are almost the same, the slopes in those three subfigures are almost the same. For iBlackhole, as well as iBlackhole-DC, they are a little different. The slope of the curve on the Wiki1000 data set is larger than slopes in Amazon1000 and Roget . For both iBlackhole and iBlackhole-DC, we prune irrelevant nodes from each data set. However, the pruning effect depends on the graph properties of each data set (i.e. the average in-degree and out-degree plays an important role). This makes the running time of iBlackhole and iBlackhole-DC algorithms vary for different data sets, but after all, much less than the Brute-Force algorithm.

Next, we compare the performances of three algorithms on the same data set with different number of nodes. In this experiment, we choose data sets Wiki500 , Wiki1000 , and Wiki1500 . Figure 12 shows the running time of these three algorithms on those three data sets.

The overall performances of these three algorithms are very similar to the first experiment. However, there are still something interesting here. We can observe that the slopes of the three lines in these three data sets are almost the same. (For iBlackhole-DC, it is more clear if we only focus on  X   X  4 ). Since these three subgraphs are derived from the same network, the inherent graph properties of these data sets are similar. The above might be the reason that similar slopes are observed in the results.
 C. iBlackhole vs. iBlackhole-DC
In this subsection, we compare the performances of iBlackhole and iBlackhole-DC algorithms. We show how significant the divide-and-conquer strategy im-proves the performance of iBlackhole. In this experi-ment, we choose three synthetical weakly connected di-rected networks, Amazon500-full , Roget-full , and Wiki1500-full .

Figure 13 shows the running time of these two algorithms on those three data sets. In the figure, we can see that the performance of iBlackhole-DC is several orders of magnitude faster than the performance of iBlackhole, since it drastically divides a large exponential growth search space into several much smaller exponential growth search space, and thus reduces a lot of computational cost.
Related work can be grouped into two categories. The first category includes the work on frequent subgraph mining, which studies how to efficiently find frequent subgraphs in the graph data. For instance, Jiang et al. [8] proposed a measure for mining globally distributed frequent subgraphs in a single labeled graph. Meanwhile, there are many works in mining frequent subgraphs in multiple labeled graphs [9], [10], [11], [12], [13], [14]. The problem of detecting black-hole patterns is different from the above works for two reasons. First, the definition of blackhole patterns is different from the definition of frequent subgraphs. Second, blackhole patterns are identified whether they are frequent or not.
The second category includes the works for detecting community structures in large networks. Communities in a network are groups of nodes within which connections are dense, but between which connections are sparse [15]. There are a lot of works on how to detect communities in a network. For instance, Newman and Girvan [16], [17] proposed a betweenness-based method, Hopcroft [18] proposed a stable method, and Ghosh [19] proposed a global influence based method to detect community structures. All these methods detect community structures based on certain definitions and criteria. However, the definition of blackhole patterns is different from the above definitions of communities. Also, once a network has been decided, the number of n-node blackhole patterns is determined. In contrast, it is usually difficult to know how many community structures are in the network.

In this paper, we formulated a problem of finding black-hole and volcano patterns in directed networks. Both black-hole and volcano patterns can be observed in real-world scenarios, such as the trading ring for market manipulation. Indeed, it is essentially a combinatorial problem for mining blackhole or volcano patterns. To reduce the complexity of the problem, we first proved that the problem of finding blackhole patterns is a dual problem of finding volcano pat-terns. Thus, we could be only focused on mining blackhole patterns. To that end, we derived two pruning schemes. The first scheme is based on a set of size-independent pruning rules which can help to prune the candidate search space effectively and thus can dramatically reduce the computa-tional cost of blackhole mining. Based on the first pruning scheme, we developed the iBlackhole algorithm for mining blackhole patterns. In addition, the second scheme is to take advantage of an unique graph property; that is, we could search in each individual subgraphs if the target directed graph contains several disconnected subgraphs. Therefore, by exploiting these two pruning schemes, we developed the iBlackhole-DC algorithm for finding blackhole patterns.
Finally, as shown in the experimental results, the prun-ing effect of both pruning schemes is significant and the iBlackhole-DC algorithm is several order-of-magnitude faster than the iBlackhole algorithm, which outperforms a brute-force approach by several orders of magnitude as well. The authors were supported in part by National Science Foundation (NSF) via grant number CCF-1018151, and National Natural Science Foundation of China (NSFC) via project number 60925008.

