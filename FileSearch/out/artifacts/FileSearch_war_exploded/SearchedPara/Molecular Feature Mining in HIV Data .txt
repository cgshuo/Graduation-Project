 larities. Furthermore, they provide a query language (and inductive database management system) that supports the querying of both patterns and data. Ideally, the query lan-guage should allow the data miner to declaratively specify the patterns of interest using a number of constraints on e.g. frequency, generality, syntax, etc. Today, several proposals for inductive database query languages exist (cf. [15, 8, 10, 5]). Most of them support the mining of association rules (and their variants). 
In this paper, we present a domain specific inductive database called MOLFEA (Molecular Feature Miner) for use in computational chemistry. MOLFEA mines for fragments in chemicals. Fragments are (linear) substructures of com-pounds. The compounds are stored in the SMILES format [21] and fragments are formulated in the SMARTS language (see also [11]). SMILES and SMARTS are commonly used in computational chemistry; they are supported by many tools, such as, e.g., the Daylight toolkits [11]. Within MOLFEA, the user can declaratively specify the fragments of interest using simple but powerful primitives. Primitives that are supported include mining for fragments that have a mini-mum (resp. maximum) frequency on a set of compounds, that are more general (resp. more specific) than a given fragment, etc. As an example query, consider finding all fragments that are frequent on the active compounds, infre-quent on the inactives and that are a subfragment of a spec-ified compound, and extend a specified fragment. MoLFEA efficiently computes the solutions to inductive queries using the levelwise version space algorithm that we have intro-duced elsewhere [6, 13]. The levelwise version space algo-rithm integrates Mitchell's version space algorithm [17] with the well-known levelwise algorithm [14] underlying Apriori [1]. 
The effectiveness of MOLF~.A is demonstrated here on an important scientific discovery application: MOLFEA was used to analyze a set of 43576 compounds from the DTP AIDS antiviral screen database (http://dtp. nei. nih. gov). In this domain, the problem is to find structural properties that are related to the protection of human cells from HIV-1 infection [23]. 
The paper is organized as follows: in section 2, an overview of the molecular feature miner MOLFEA is given; in section 3, we present the DTP AIDS antiviral screen database; in section 4, we report on the experiments and the findings in the data; finally, in section 5, we touch upon related work and conclude. The final SMILES code for the overall compound in Fig-ure 1 can then be regarded as a nitrogen (hydrogens are implicitly added), followed by a benzene ring which is connected by an oxygen to a chlorinated benzene ring: 'Nclccc(Oc2ccc(C1)cc2)ccl'. 
While the SMILES notation is not unique, it is possible to use the so-called canonical SMILES notation [22], which guarantees that the resulting string encoding the compound is unique. Also note that, e.g., for matching a pattern against an example compound, an internal data structure is constructed and used. 
There are three key advantages of using SMILES for data mining applications in computational chemistry. Firstly, SMILES is a language designed, understood and "spoken" by (computational) chemists. Secondly, SMILES code is ex-tremely compact for storage and manipulation as compared to other representations. Indeed, on the website of Day-light Chemical Information Systems one finds the statement that "a typical SMILES will take 50% to 70% less space than an equivalent connection table." A database of 23,137 structures is said to require only an average of 1.6 bytes per atom. Using Ziv-Lempel compression, this can further be reduced to 0.42 bytes per atom. 
As another illustration, consider the Prolog formulation for use in multi-relational data mining or inductive logic programming of the compound in Figure 1. It occupies 2100 bytes. Contrast this with the 26 bytes needed for SMILES. Thirdly, efficient and optimized tools exist for testing whether a fragment matches a compound. Using SMILES (and SMARTS, cf. below) one can rely on the ex-isting state-of-the-art computational chemistry technology. As we will see, MOLFEA employs the SMILES and SMARTS toolkits from Daylight Chemical Information Systems as the underlying computational chemistry tool. 
The aim of MOLFEA is to mine for molecular fragments (sometimes also called features) of interest in chemical data. To represent such fragments we use a subset of the language SMARTS, which is derived from SMILES in order to specify substructures. Almost all SMILES specifications are valid SMARTS targets. However, SMARTS also allows one to make abstraction of specific elements in the fragment. E.g. the notation '.J is used to denote any type of bond, the char-acter '*' denotes any type of atom. Further abstractions are built into SMARTS [11]. Also, the semantics of a SMARTS construct is different than that of a SMILES one. SMARTS encode fragments, SMILES encode molecules, and these can be quite different, cf. [11]. In the present implementation maximum one on a set of inactive ones. E.g. the following constraint: queries for all fragments that include the sequence 'C -O ', axe not a subsequence of 'C -O -S -C -O -S', have a frequency on Act that is larger than 95 percent and a frequency on lnAct that is smaller than 5 percent. 
In this subsection, we show that the solution space sol(oA version space and can therefore be represented by its bor-ders. 
Due to the fact that the primitive constraints ci are inde-pendent of one another, it follows that 
So, we can find the overall solutions by taking the inter-section of the primitive ones. 
Secondly, each of the primitive constraints c is monotonic or anti-monotonic w.r.t, generality (el. [14]). A constraint c is monotonic (resp. anti-monotonic) w.r.t, generality when-ever (resp. replace _&lt; by &gt;). The basic anti-monotonic con-straints in our framework are: (f &lt; p),freq(f,D) &gt;_ m, the basic monotonic ones are (p &lt;_ f), freq(f, D) &lt; m. Fur-thermore the negation of a monotonic constraint is anti-monotonic and vice versa. 
Monotonic and anti-monotonic constraints are important because their solution space is bounded by a border. This fact is well-known in both the data mining literature (cf. [14]), where the borders are often denoted by BD +, as well as the machine learning literature (cf. [17]), where the sym-bols S and G are typically used. 
To define borders, we need the notions of minimal and maximal elements of a set w.r.t, generality. Let F be a set of fragments, then define rain(F) = {f 6 F ] "-,3q E F: f &lt; q} max(F) = {f E F I ~3q E F : q &lt;_ f}. 1 We can now define the borders S(c) and G(c) 2 of a primitive constraint c as Anti-monotonic constraints c will have G(c) = {-i-} and for proper constraints S(c) ~ {.L}; proper monotonic con-straints have S(c) = {.L} and G(c)  X  {T}. Furthermore, as in Mitchell's version space framework we have that  X  Note that rain gives the minimally general elements, and max the maximally general ones. In contrast, g &lt; s denotes that g is more general than s. 2At this point, we will follow Mitchell's terminology, because he works with two dual borders (a set of maximally general solutions G and a set of maximally specific ones S). In data mining, one typically only works with the S-set. 
It is also possible to modify the above algorithm (exploit-/~ := {p [ p 6 Lt and p satisfies constraint c} Fi := L~ -It the set of frequent fragments considered 
Lt+z := {P ] Bq e F~: p E p,(q) and Ss e S : p &lt;_ s and pg(p) N (Ujlj) = O } i:=i+1 
In [6], we also introduced dual variants of these algorithms Various optimizations to the algorithms are possible. 
First, though we have adopted the standard levelwise al-
Secondly, Apriori-style algorithms can be made more ef-Thirdly, we keep track of the fragments in canonical form. 
Fourthly, one problem with the implementation of the For the implementation, we used functions from the rain(CA) --13, max(CM) = 8 active (CA). Compounds neither active nor moderately ac-tive were listed as confirmed inactive (CI). 
We used the conversion tool babel (http://smog.com/ chem/babel) to generate SMILES strings from the con-nection tables provided by the DTP's Drug Information System, which generated 41768 syntactically correct com-pounds: 40282 of class CI, 1069 of class CM and 417 of class CA. In this subsection, we describe the queries posed to MOLFEA for feature mining in the HIV domain. We will assume that there are two sets of examples, D1 and D2. 3 Furthermore, E = D1 U D2. During feature mining we will take into account the class information. This is akin to e.g. [19], but contrasts with [3]. Class information is taken into account using the following type of query fragments that are frequent in example set D1 and infre-quent in D2. Features that are a solution to these types of formation. The choice ofe and 6 is essentially free. E.g., one can choose these parameters in such a way that the resulting fragments are significant w.r.t, the class distribution. 
Our main interest in the experiments was to mine for frag-aWe wish to stress that it is easy to generalize the techniques for n classes. Some of the techniques can also be generalized for other learning tasks such as e.g. regression. and under-represented in the inactive (resp. moderately ac-tive) compounds. So, we used the x2-Test applied to a 2  X  2 contingency table with the class as one variable and the oc-currence of the fragment as the other one to determine the maximum allowable frequency in the non-active examples. 
In this way, we obtained a minimum frequency of 13 in ac-tive compounds and a maximum frequency of 516 in inactive compounds for the first task at hand (discriminating actives and inactives). Given these frequencies, the occurrence of a fragment in the active class is not due to chance at a sig-nificance level of 0.999. Likewise, we obtained a minimum frequency of 13 in the actives (class CA) and a maximum frequency of 8 in moderately actives (class CM) for the sec-ond task at hand (discriminating actives and moderately actives). 
In this section, we summarize our results and find-ings from applying MOLFEA to the AIDS Antiviral Screen Database. After presenting a few quantitative results, we continue with an interpretation of the discovered fragments. 
In Table 1, the quantitative results of our experiments are shown. The left part of the table contains the results for the first task (distinction between active and inactive compounds) and the right part the results for the second task (distinction between active and moderately active com-pounds). For each level of the search, 4 we list the num-ber of fragments in the solution space, and the time (in CPU seconds) spent for this level solving the minimum fre-quency constraint (Tmi,,.f) and solving the maximum fre-quency constraint (Tma X _f)-It can be seen that the solution space for the first task is larger than for the second task. 4Note that the level is corresponding to the length of the fragments. 
Similarly other families of compounds with an activity 
The presented work is related to a variety of different 
MOLFEA actually has its roots in inductive logic program-
MOLFEA can and should also be considered an induc-
Finally, despite the domain specificity of MOLFEA, we [16] C. Meliish. The description identification problem. [17] T.M. Mitchell. Generalization as search, Artificial [18] A. Inokuchi, T. Washio, H. Motoda. An Apriori-based [19] A. Srinivasan, R. King. Feature construction with [20] A. Srinivasan, R.D. King, D.W. Bristol. An [21] D. Weininger. SMILES 1. Introduction and encoding [22] D. Weininger, A. Weininger, J.L Weininger. SMILES [23] Weislow, O.S., 1~. Kiser, D.L. Fine, J.P. Bader, R.H. 
