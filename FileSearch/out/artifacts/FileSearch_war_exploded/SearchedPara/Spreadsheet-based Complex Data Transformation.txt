 Spreadsheets are used by millions of users as a routine all-purpose data management tool. It is now increasingly neces-sary for external applications and services to consume spread-sheet data. In this paper, we investigate the problem of transforming spreadsheet data to structured formats required by these applications and services. Unlike prior methods, we propose a novel approach in which transformation logic is embedded into a familiar and expressive spreadsheet-like for-mula mapping language. Popular transformation patterns provided by transformation languages and mapping tools are supported in the language via formulas. Consequently, the language avoids cluttering the source spreadsheets with transformations and turns out to be helpful when multiple schemas are targeted. We implemented a prototype and evaluated the benefits of our approach via experiments in a real application. The experimental results confirmed the benefits of our approach.
 D.2.12 [ Interoperability ]: Data mapping Design, Languages Data transformation, Spreadsheets
Spreadsheets are ubiquitous tools used for the storage, analysis and manipulation of data [14]. There are several reasons for their popularity. Spreadsheet-based data man-agement offers important flexibility in data formatting over a tabular grid [2]. Data can be organized according to sub-jective importance, preferences, and styles (e.g., by placing important data in the top-left corner or placing related el-ements of data next to each other). Furthermore, spread-sheets offer a simple, but effective formula language using spatial relationships that shield users from the low-level de-tails of traditional programming [8, 15]. To use the lan-guage, a user only needs to master two concepts, namely cells as variables and functions for expressing relations between cells. Consequently, spreadsheets are widely used by millions of knowledge workers (e.g., accountants, project managers, teachers) who play a key role in critical enterprise activi-ties [6].

Given the ubiquity and utility of spreadsheets, it is in-creasingly necessary to allow data stored in spreadsheets to interact with external applications and services 1 . There has been a proliferation of online spreadsheet-like applications including Google Spreadsheets 2 and Zoho Spreadsheet 3 To enable other applications to consume or generate spread-sheet data, some of these applications provide Web service interfaces (APIs). The authors in [6] report that spread-sheets often serve as hubs for organizing and manipulating information, which is later transferred to other services for archiving or processing.

In this paper, we consider the problem of transforming spreadsheet data into structured formats required by ex-ternal applications and services (i.e., spreadsheet-based data transformation ). We believe that facilitating interopera-tion between spreadsheets, applications and Web services will profoundly improve the effectiveness of information and services management in a variety of domains. However, the problem is challenging because of the nature of spreadsheets: (i) the data they contain does not conform to a predefined schema; (ii) there may be a mismatch between the organi-zation of spreadsheet data and the structure expected by an external application. For example, the spreadsheet in Fig-ure 1(a) contains data arranged in a table while the schema used by a bar chart (Figure 1(d)) consists of a list of labels, each comprising a list of bars.

Mainstream solutions to data transformation rely on spec-ifying mappings between elements of the source and target schemas to transform a source instance to the target for-mat [5]. However, there are many cases in which the schema of the source instance is unknown and transformation is per-formed directly from the source instance to the target for-mat. For example, end-user visualization websites [16, 1] let users upload a data set (i.e., a source instance) and assist http://www.altova.com/mapforce/excel-mapping.html http://docs.google.com http://sheet.zoho.com/ them in transforming it to the format required by a given visualization type (e.g., chart, map, and timeline) with its own target schema.

There are three main existing approaches. The first ap-proach, namely schema-based , allows users to specify schemas of spreadsheets via a layout specification language [7], and then transformation can be performed at schema level us-ing either low-level transformation languages (e.g., XSLT), or high-level mapping tools, such as Clio [5], Clip [10], and +Spicy [9]. However, users must learn a new language, e.g., by creating correspondences between the source and target elements and annotating those correspondences with one or more unfamiliar functions (e.g., functions of XSLT/XQuery, Java) in the case of mapping tools [13]. This flowchart-like mapping interface is cluttered when schemas are large and mappings are complex [12]. On the contrary, spread-sheet users are familiar with formulas and an incremental approach to building applications with instant feedback [15].
The second approach, namely column-based , enables users to specify simple mappings between spreadsheet columns and target attributes (atomic elements) via drag-and-drop operations [11, 4]. This approach requires direct correspon-dences between spreadsheet column contents and the values of target attributes. For example, after dragging attribute Y of scatter plot (Figure 1(c)) onto source column Infec-tion Rate (Figure 1(a)), the values of the column are copied to values of the attribute. Such straightforward correspon-dences, however, are unlikely when the target application and the spreadsheet have been developed independently. For instance, while the infection rate is expressed per million in the source, the target scatter plot expects a rate of per one hundred thousand. To correct this issue, the source spread-sheet must be modified, e.g., the values of column Infection Rate must be changed.

The third approach, visualization specific, supports simple mappings in the context of visualization [16]. It compares atomic types of source columns and target attributes of visu-alization types to suggest mappings to users. For example, to visualize the Swine Flu data set (Figure 1(a)) using a pie chart (Figure 1(b)), one of five candidate columns Confirmed Cases , Deaths , Infection Rate , Death Rate , Population can be mapped to attribute Value since all of them have the same type float. Similar to the column-based approach, source column data directly corresponds to the values of tar-get attributes.

In summary, all three approaches suffer from at least one of the following drawbacks: (i) Existing programming expe-rience of spreadsheet users (e.g., spreadsheet formulas with instant feedback at each step) is not leveraged; (ii) The transformation may be tedious to accomplish since it can involve multiple manipulations on the spreadsheet. It can also clutter the original organization of the spreadsheet with transformations. This issue may be aggravated if users need to interact with several different target applications, e.g., if requesting quotations by interacting with various supplier Web services or if targeting several visualizations as depicted in Figure 1.

To address these issues, we propose a novel approach, namely TranSheet, which enables users to perform mappings via a familiar and expressive spreadsheet-like formula lan-guage. The main contributions of this paper are as follows:
Spreadsheet data model . A spreadsheet is modeled as a two-dimensional matrix of cells. We use the coordi-nate  X  x,y  X  to denote the cell corresponding to column x and row y . While x is numbered starting from 1 and can also be denoted using capital letters, y is denoted by num-bers. For example, cell  X  1 , 5  X  can also be denoted as cell A5. Each cell has an atomic value with associated type  X   X  a ::= empty | int | float | string | datetime . The type empty represents the special case of an empty cell.

Target data model. We focus on transformation of spreadsheet data to XML, which is a popular standard for heterogeneous data exchange [13]. We use the nested rela-tional model proposed in [5, 10]. Note that it is straight-forward to convert XML to JSON, which is a standard for-mat for Web mashups. A schema is modeled as a set of typed labels (i.e., elements)  X  t :  X  t ::=  X  a | SetOf [ l Rcd ( l 1 :  X  t 1 ,...,l n :  X  n t ) where l i s are label names and  X  their respective types. The symbol SetOf represents repeat-ing elements as an unordered set of the same label and Rcd represents tuples. For user interface presentation, we use an equivalent notation illustrated in Figure 2(b), where the symbol [ ] is used to denote the SetOf construct.
Table 1: Transformation patterns of TranSheet
While atomic labels hold actual values, structural labels control the structural information of schema. Thus, we con-sider two kinds of mappings, namely value mapping (map one or more cells to an atomic label) and structural mapping (map a range of cells to a SetOf label). A mapping formula has the form l = formula , where l is a target label and for-mula is a spreadsheet formula. Due to space limitations, we demonstrate mainly via examples that popular transfor-mation patterns provided by transformation languages (e.g., XSLT/XQuery) and mapping tools [3] are supported in our language via formulas (Table 1). A full description of the language X  X  semantics can be found in [17].
This pattern simply copies a cell value to a target value of a label. For example, in Figure 2(b), we have the fol-lowing mappings: Id =A1 copies the value corresponding to A1 to the value of Id . Instant feedback for the mapping is provided in the curly brackets { 0042 } adjacent to label Id ; ProdName =C3:C5 copies three values of cells C3, C4, and C5 to the values of label ProdName . In the last example, a mono-dimensional range expression is associated to an atomic label. In spreadsheet programming, range expres-sions are only used as function parameters (e.g., for com-puting the total sum of a collection of cells). TranSheet, however, leverages the familiarity users have with the range notation to conveniently express mappings of schema labels with cell collections called range formulas . A range formula is valid only for an atomic label that has a SetOf label as ancestor. To show that the OrderDetails label allows rep-etition of label ProdName , the text  X  (3 items)  X  (the number of label ProdName ) is displayed as an additional metadata.
Special care needs to be taken for range formulas associ-ated with atomic labels. Suppose that instead of the map-ping shown in Figure 2(b), the user inputs the mapping formulas Quantity =B3:B17 (15 Quantity items) and Prod-Name =C3:C5 (3 ProdName items). Taken together, these two mapping formulas violate the schema constraint which states that the target document should contain the same number of Quantity and ProdName labels.
In some special cases, a constant must be copied to a tar-get value where the constant value is independent of the source. For example, in Figure 2(b) the mapping formulas Login = X  X yLogin X  and Password = X  X yPass X  associate con-stants to the values of Login and Password , respectively. This kind of mapping allows users to use one or more Excel-like functions on strings (e.g., upper , lower , trim ), numbers (e.g.,  X + X ,  X * X ,  X - X ,  X / X , abs , ceiling , round ), and dates (e.g., date , time , hour ) to bring the format of a cell value to the required format of a target value. For exam-ple, in Figure 2(b): Mapping Quantity =B3:B5*10 uses a range formula to state that values of Quantity correspond to three values in the spreadsheet multiplied by 10; Mapping Price =round(A3:A5,0) rounds values in the range A3:A5 to the nearest integers and copies to values of Price .
This pattern merges multiple cell values into one value of a target label. For example, in Figure 2(b), the mapping formula Address =concatenate(B2, X   X ,C2, X   X ,D2) merges the values of three cells B2, C2, D2, which contain information on street, city, state, respectively, into the value of label Ad-dress with delimiters whitespace  X   X  using Excel-like func-tion concatenate .
This kind of mapping is used when splitting one cell value into one or multiple target values. For example, mapping formulas FirstName =left(A2, search( X   X , A2)) and Last-Name =right(A2, len(A2)-search( X   X ,A2)) in Figure 2(b) split the value of cell A2, which contains information on customer name, into the values of labels FirstName and LastName ac-cording to the whitespace  X   X  using Excel-like functions left , search , right , and len .
When using a structural mapping l s = f , formula f is in-terpreted in terms of mapping formulas associated with the atomic children labels of structural label l s . To intuitively illustrate this formula inheritance, the structural mapping OrderDetails =B3:C5 in Figure 2 is interpreted in terms of lower level mapping formulas in the following two steps:
As can be seen, by using formula inheritance, the atomic children labels Quantity and ProdName of label OrderDe-tails obtain values from ranges (columns) B3:B5 and C3:C5.
Figure 3 presents a simple structural mapping Orders =A2:E50, where several orders are organized in a single de-normalized table (nested table). The interpretation process, as presented so far, uses certain defaults: (i) TranSheet as-sumes that data is organized in a table with attributes as columns and tuples as rows; (ii) TranSheet also takes advan-tage of the same ordering of columns in the source spread-sheet and target atomic labels (e.g., quantity comes  X  X e-fore X  product name in both the spreadsheet and the target schema). These defaults can be overridden: the first by us-ing function transpose to indicate that a table is represented with attributes as row and tuples as column; the second by the schema restructuring features described in [17].
The mapping illustrated in Figure 3 is potentially ambigu-ous since two distinct target instances are possible: either (i) grouping products per order, as could be expected, or (ii) mimicking the data organization of the spreadsheet doc-ument with as many order labels as there are products. In this example, both generated documents satisfy the map-ping specification as well as the target schema. However, the document where products are grouped per orders is of-ten desirable [5]. By default, the target document is nested according to order identifier, first name, and last name.
This kind of structural mapping allows users to select data from a set of source tuples according to specific filtering conditions. For example, in Figure 3 the user wants to se-lect orders from the source whose product name is equal to  X  X owel X  and quantity is greater than 1. This can be obtained by associating a filtering predicate filterexp to the structural mapping Orders = A2:E50. Filterexp is a combination of Excel-like logical functions AND , OR , and NOT . For exam-ple, the following mapping is employed for the above exam-ple: Orders =A2:E50[AND(D2:D50= X  X owel X , E2:E50 &gt; 1)]
This kind of structural mapping allows users to sort tuples in the source spreadsheet according to values of columns. It is defined via function sort(column1, order1, column2, order2,...) , where column i is a column specified by a one-dimensional range, and order i is the corresponding sorting order of column i with value  X  X scending X  or  X  X escending X . For example, the list of orders in Figure 3 can be sorted according to product name in ascending order, and then according to quantity in descending order as follows:
In this example, the user wants to group the source spread-sheet in Figure 3(a) by order identifier, first name, and last name. Excel-like aggregate functions (e.g., count , sum , avg , min , and max ) can then be used together with grouping to calculate values for product name and quantity in each group. The target schema to be mapped is as follows:
The following mappings are employed: Orders =A2:E50[ groupby(A2:A50, B2:B50, C2:C50) ] where function groupby( column1, ...) groups a set of tuples according to values in columns column 1 , column 2 , and so on. This structural mapping is then refined at leaf level on atomic labels Prod-Name and Quantity ; ProdName =count(D2:D50) counts the number of products for each order; Quantity =max(E2:E50) finds the maximum value in the set of quantities associated with an order.
Suppose that the source spreadsheet in Figure 3(a) is di-vided into tables A2:C6 and D2:F3 where table A2:C6 con-tains order details and table D2:F3 contains customer infor-mation:
The two above tables are joined according to order iden-tifiers and mapped to the target schema in Figure 3(b). This can be achieved via function join(table1, table2, join-condition) where table1 and table2 are two tables defined by two-dimensional ranges and joincondition is an optional condition to join these two tables. We have the following mappings:
When joincondition is missing, a full Cartesian product is computed between the two tables.
Function union allows users to union two tables with the corresponding signature union(table1, table2,...) , where ta-ble1 , table2 ,... are tables to be unioned. By default, union is duplicate-eliminating. For example, the user wants to union the following two tables with duplicate removal and map them to the target schema shown in Figure 3(b):
The following structural mapping is associated with la-bel Orders : Orders =union(A1:E3, A5:E6). Other set op-erators intersect and minus can be specified via functions intersect(table1, table2,...) and minus(table1, table2,...) .
This kind of mapping allows users to map different sets of data to a target label depending on the outcome of a preset condition. It is specified via Excel-like function if(condition, value if true, value if false) . For example, suppose that there is an additional attribute, namely Description , located right below element Quantity of the target schema in Figure 3(b) to indicate whether the quantity of an order item is small or large. The following mapping is used: Description =if(E2:E50 &gt; 20,  X  X arge X ,  X  X mall X )
That is if the quantity of an order item is greater than 20, then attribute Description is assigned  X  X arge X ; otherwise it is associated with  X  X mall X .
A complex transformation is typically composed of multi-ple patterns of structural and value mappings. For example, the user can perform sorting and then filtering in Figure 3: Orders =A2:E50[sort(D2:D50, ascending), D2:D50= X  X owel X  X .
Additionally, a formula specified on a label may collide with a formula inherited from one of its ancestor labels. Re-garding mapping Orders =A2:E50 in Figure 3, the user can see that, by inheritance, the values associated to label Prod-Name are { 150, 2, . . . } which is a copy of the quantity column of the spreadsheet. However, the user expects that values of label Quantity should correspond to values of this column multiplied by 10. In such situation, the user can specify mapping formulas at structural labels and refine them at a lower level (e.g., leaf level). These will have precedence over the values derived by the automated mechanism. For instance, mapping Quantity =E2:E50*10 is used to correct the problem. Architecture. TranSheet has been implemented as an Excel plug-in using C# 3.0 and Visual Studio 2008. The ar-chitecture of TranSheet consists of the following main com-ponents: (i) GUI enables users to specify mappings via for-mulas. While spreadsheet data is imported using the built-in functionality of Excel, target schemas are imported using TranSheet functionality; (ii) Mapping interpretation engine takes mapping formulas from GUI and generates XQuery; (iii) Execution engine is responsible for executing XQuery and then returning the transformation result to GUI for validation. TranSheet currently employs the open-source execution engine Saxon 4 .

User interface. The user interface of TranSheet is shown in Figure 4. While the left side corresponds to the source spreadsheet, the target schema is located in the Excel task pane on the right. To specify a mapping, the user selects a target label and enters a formula into the formula editor located in the task pane. Instant feedback for the mapping is then displayed adjacent to the target labels.

Experiments. We selected 5 real data sets from the public repositories of Australian government agencies 5 and ManyEyes [1]. The NSW Crime dataset is a table showing crimes level in New South Wales -Australia by offence type, month and local government area from 1995 to 2009 with 184 columns and 10541 rows. The Economic Stimulus Package data set contains national building -economic stimulus plan projects of Australia with 29 columns and 4271 rows. The School Locations data set consists of addresses of schools in Victoria -Australia with 12 columns and 2294 rows. The Frog Atlas contains various kinds of frogs in South Australia recorded at different places with 13 columns and 6732 rows. The expensive cities data set indicates the most expensive cities in the world from 2002 to 2009 with 9 columns and 144 rows. Our test schemas are five structurally different http://saxon.sourceforge.net/ http://data.australia.gov.au/ visualization types Pie Chart , Scatter Plot , Bar Chart , Map of ManyEyes [16, 1], and Time Line of the SIMILE project 6 Eight popular mapping scenarios commonly used by the ManyEyes community for visualization [1, 16] are considered in these experiments (copying, merging, derivation, split-ting, sorting, filtering, grouping with aggregation, and nest-ing). Detailed information can be found on in [17].
Prior to implementing these mapping scenarios, we famil-iarized ourselves with all functionalities offered by EXM and ManyEyes. For each mapping scenario, if it can be imple-mented using a system, we record manipulation operations on the source data set, if any.

In a nutshell, TranSheet can implement all mapping sce-narios using mapping formulas without modifying data sets. On the other hand, both EXM and ManyEyes need mul-tiple manipulations on data sets to accomplish the map-ping scenarios. EXM generally requires fewer manipulations than ManyEyes and multiple manipulations of EXM can be done using graphical wizards. This is because Excel pro-vides many advanced features to support data manipula-tion. However, EXM cannot implement mapping scenario nesting. While EXM supports only one nesting level in the target schema, a bar chart consists of two nesting levels.
EXM supports copying by dragging target attributes onto columns containing local government area and crimes in De-cember 2009. In the case of ManyEyes, while the column containing local government area is selected from 4 candi-dates to map with the text target attribute, the column containing crimes in December 2009 is selected from 180 candidates to map with the numeric target attribute. How-ever, 10530 unwanted rows must be deleted for both tools. TranSheet supports copying via either range formulas.
To implement derivation, EXM and ManyEyes require 6731 values in the sighting date column must be converted to the mm/dd/yyyy format. Similarly, a new column is inserted and its values are changed in the case of the split-ting or merging scenario to store splitting/merging values. TranSheet supports derivation, merging, and splitting via applying functions on range formulas.

EXM requires fewer manipulations than ManyEyes in im-plementing sorting and filtering since Excel provides graphi-cal wizards for users to implement these mapping scenarios. The user needs to perform these manually in the case of ManyEyes. TranSheet supports filtering and sorting by per-forming structural mappings via formulas or wizards.
To implement grouping with aggregation using EXM, a new table is created with 2 columns and 5 rows, in which each row contains a program type and its average funding. In the case of ManyEyes, the user must create a new table and then deletes 29 old columns to avoid default grouping. TranSheet supports this mapping scenario by grouping the data set according to program type and then using the ag-gregate function average .
 Since EXM does not support nesting, we only consider ManyEyes. To implement this scenario using ManyEyes, a new table with is created with 2 columns and 69 rows, where each row contains different types of crimes in October 2009, except the header row. In addition, 184 old columns must be deleted. TranSheet supports nesting by mapping range formulas to 2 attributes of the bar chart. http://www.simile-widgets.org/
Transformation Languages and Mapping Tools. A language for the description of spreadsheet content as a se-ries of relational tables is proposed in [7]. Once defined, the schema can be used with either low-level transformation lan-guages (e.g., XSLT/XQuery) or visual mapping tools (e.g., Clio [5], Clip [10], and +Spicy [9] to perform transforma-tion. However, spreadsheet users must learn a new complex language to perform transformations and their existing pro-gramming experience is not leveraged. By contrast, Tran-Sheet provides a familiar spreadsheet-like formula mapping language.

Exportation of spreadsheet data. Several existing approaches support the exportation of spreadsheet data to structured formats [11, 4, 16]. Regarding these approaches, data representation or structural mismatches between a source spreadsheet and target XML schema are addressed by mod-ifying the spreadsheet document before exportation. Most of the transformation logic is embedded in modifications of the source spreadsheet. By contrast, TranSheet separates the transformation logic from source manipulations through the notion of mapping formulas. The benefits are increased expressiveness and preservation of the original source.
Since a significant amount of the world X  X  data is stored in spreadsheets, we believe TranSheet has numerous appli-cations in data exchange for both desktop and Web-based environments. Additional interesting features of TranSheet, including mapping generalization and mapping formula in-terpretation, can be found in [17].
