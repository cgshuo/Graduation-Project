 Time-series data are the sequences of re al numbers representing values at spe-cific points in time. Typical examples of time-series data include stock prices, exchange rates, biomedical measurements, and financial data [1, 4, 11]. The time-series data stored in a database are called data sequences ,andthosegiven by users are called query sequences . And, finding data sequences similar to the given query sequence from the database is called similar sequence match-ing [1, 4, 8]. In many similar sequence matching models, two sequences X = said to be similar if the distance D ( X, Y ) is less than or equal to the user-specified tolerance [1, 4]. In this paper, we use the Euclidean distance, which has been widely used in [1, 4, 6, 7, 8, 9], as the distance function D ( X, Y ), and define that X and Y are in -match if D ( X, Y )islessthanorequalto .
In this paper we focus on the subsequence matching that supports moving average transform. Here, the subsequence matching [4, 8] is the problem of finding subsequences, contained in data sequen ces, similar to a query sequence of arbi-trary length. And, moving average transform [3, 10], which has been widely used in econometrics [3], converts a given seq uence into a new sequence consisting of the averages of k consecutive values in the sequence, where k is called the mov-ing average order or simply the order [6]. The moving average transform is very useful for finding the trend of the time-series data by reducing the effect of noise, and has been used in various applications [3]. Since the users want to control the degree of the noise reduction depending on the characteristics of data sequences to be analyzed [5], efficient support of arb itrary orders is also necessary. Table 1 summarizes the notation to be used throughout the paper.

In this paper we focus on the subsequence matching model that supports moving average transform of arbitrary order [6]. That is, the focused model uses the distance between two k -moving average transformed sequences Q ( k ) and S to determine whether the two sequences are in -match or not. We call this similarity model as moving average transformed subsequence matching .Previous research results [4, 6, 8], however, do not provide an efficient solution because of incurring index overhead.

In this paper we propose a single index approach for the moving average transformed subsequence matching. To explain our approach, we first provide the notion of poly-order moving average transform (or simply poly-order trans-form ) by generalizing the original definition of moving average transform. The poly-order transform is different from the original moving average transform in a manner of using moving average orders. While the original transform uses only one specific order, the poly-order transform uses a set of moving average orders. That is, while the original transform makes a transformed sequence from an original sequence, the poly-order transform generates a set of transformed sequences from an original sequence. In th is paper we show that, if constructing a single index using the poly-order transform and using the index, we are able to perform the moving average transformed subsequence matching correctly.
By applying the poly-order transform to both Faloutsos et al. X  X  method [4] (called FRM for convenience) and DualMatch [8], we propose two different mov-ing average transformed subsequence matching methods. The first one is an FRM-based algorithm, which divides data sequences into sliding windows and a query sequence into disjoint windows. The second one is a DualMatch-based algo-rithm, which divides data sequences into disjoint windows and a query sequence into sliding windows. Experimental results show that two proposed matching methods improve performance significantly over the sequential scan regardless of selectivity ranges and query lengths.
 The rest of this paper is organized as follo ws. Section 2 describes related work. Section 3 presents the concept of poly-order transform and explains the proposed matching algorithms. Section 4 presents the results of performance evaluation. Section 5 concludes the paper. We first review Agrawal et al. X  X  whole matching solution [1]. The whole matching solution consists of index building and similar sequence matching algorithms. In the index building algorithm, each data sequences of length n is transformed into f -dimensional points ( f n ), and the transformed points are stored into an R  X  -tree [2]. In the similar sequence matching algorithm, a query sequence is similarly transformed to an f -dimensional point, and a range query is constructed using the point and the tolerance . Then, by evaluating the range query using the index, the candidates are identified. This metho d guarantees there be no false dismissal , but may cause false alarms because it uses only f features instead of n .Thus,itperformsthe post-processing step that eliminates false alarms by accessing the actual data sequences from the disk [1].

Faloutsos et al. have proposed a subsequence matching solution (FRM) as a generalization of the whole matching[4]. FRM uses the window construction method of dividing data sequences into sliding windows and a query sequence into disjoint windows. In the index building algorithm, FRM divides data se-quences into sliding windows and transforms each window to an f -dimensional point. However, dividing data sequences into sliding windows causes a serious problem of generating too many points to be stored into the index [4, 8]. To solve this problem, FRM does not store individual points directly into the R  X  -tree, but stores only MBRs (minimum bounding rectangles) that contains hundreds or thousands of the f -dimensional points. In the subsequence matching algorithm, FRM performs subsequence matching based on the following Lemma 1 [4]. Lemma 1. If two sequences S and Q are in -match, then at least one of the dis-joint window pairs ( s i ,q i ) are in / Eq. (1) holds: According to Lemma 1, FRM divides a query sequence into disjoint windows, transforms each window to an f -dimensional point, makes a range query using the point and the tolerance , and constructs a candidate set by searching the R -tree. Finally, it performs the post-pro cessing step to eliminate false alarms.
DualMatch [8] and GeneralMatch [9] have improved performance significantly in subsequence matching by using different window construction methods from FRM. In constructing windows, DualMatch is a dual approach of FRM, and Gen-eralMatch is a generalized approach of F RM and DualMatch. Except difference in window construction mechanism, index building and subsequence matching algorithms of DualMatch and GeneralMatch are similar to those of FRM.
Loh and Kim [6] have first proposed a subsequence matching method that supports moving average transform of arbitrary order. In the index building al-gorithm, the method builds an m -index by performing m -moving average trans-form on data sequences, by dividing the transformed sequences into windows, and by mapping the windows into lower-dimensional points. In the subsequence matching algorithm, given the order k that may or may not be equal to m ,the method uses the m -index to perform k -order moving average transform. How-ever, the method has a serious drawbac k that it is necessary to modify existing algorithms and node structures used in the R  X  -tree. Also, Loh and Kim have proposed the index interpolation [7] that constructs multiple m -indexes for arbi-trary orders. However, this index interpo lation causes another critical drawback that, as the number of m -indexes increases, much more space would be required for the indexes, and index maintenance overhead would be increased to maintain multiple indexes. 3.1 The Concept The motivation of the research is on how we can use Lemma 1, which has been used for a theoretical basis in many subsequence matching methods. If using Lemma 1, we can perform subsequence matching efficiently since we can reduce the index search range from to / Lemma 2 by applying k -moving average transform to Lemma 1.
 Lemma 2. If two k -order moving average transformed sequences S ( k ) and Q ( k ) Len ( Q ( k ) ) / X  ) . That is, the following Eq. (2) holds: Proof : We omit the proof since it can be easily done using Lemma 1. To use Lemma 2 in moving average transformed subsequence matching without any modification, however, we have to build a lot of indexes since we require each index for every possible order k . To solve this problem, we propose an efficient approach that uses only one index rather than multiple indexes.
 To support moving average transform of arbitrary order in FRM and Dual-Match without incurring the problem of multiple indexes, we generalize the definition of moving average transform as the following Definition 1. Definition 1. Given a window S [ a : b ] contained in a sequence S andaset K of orders, k 1 ,k 2 ,  X  X  X  ,k m ,the poly-order moving average transformed window set, S K ) [ a : b ], of S [ a : b ]on K is defined as follows: To represent an area of containing multiple windows, we now rewrite the defini-tion of MBR using a set of windows as follows.
 Definition 2. Given a set W of windows, W 1 ,W 2 ,  X  X  X  ,W m , of the same size  X  ,an MBR of the set W , MBR ( W ) ,isdefinedasan  X  -dimensional MBR that contains every  X  -dimensional point W i in W .
 According to Definitions 1 and 2, the poly-order transformed window set of s i on K is denoted by s ( K ) i , and the MBR of containing all windows in s ( K ) i is denoted by MBR ( s ( K ) i ).

If using the poly-order transform, we can perform the moving average trans-formed subsequence matching correctly, i.e., we do not incur any false dismissal. To explain the correctness, we present Le mma 3 that represents the relationship between k -order transform and the poly-order transform on K containing k . -match with MBR ( s ( K ) i ) . That is, the following Eq. (4) holds: Proof : We omit the proof due to space limitation.
 Based on Lemmas 2 and 3, we now derive Theorem 1, which provides a theoret-ical basis of the algorithms to be proposed.
 Theorem 1. When k  X  K ,if Q ( k ) is in -match with S ( k ) [ a : b ] ,thenatleast is, the following Eq. (5) holds: where p = Len ( Q ( k ) ) / X  ,and Len ( S ( k ) [ a : b ]) = Len ( Q ( k ) ) . Proof : We can prove the theorem using Lemmas 2 and 3. We omit the detailed proof due to space limitation.
 Theorem 1 guarantees that the candidate set consisting of the subsequences S /  X  dismissal.

To use Theorem 1 for the FRM-based (or DualMatch-based) moving average transformed subsequence matching method, we need to construct a set of win-dows for each window of data sequences. That is, the methods to be proposed first construct an MBR that contains multiple poly-order transformed windows. The methods then transform the MBR to a lower-dimensional MBR, and finally build an index by storing the MBR. 3.2 FRM-MAT: FRM with Moving Average Transform In this subsection we explain FRM-MAT, the moving average transformed sub-sequence matching method that is derived from FRM [4] by using the poly-order moving average transform.

Figure 1 shows the index building algorithm of FRM-MAT. In Step (1), we divides a data sequence S into sliding windows of length  X  . In Steps (2)  X  (6), for each sliding window, we construct an MBR and store the MBR into the multidimensional index. First, in Step (3), we make a set of transformed windows from a sliding window by performing the poly-order transform on a given set of orders. Next, in Step (4), we construct an f -dimensional MBR by using the lower-dimensional transformation on the set of windows. Last, in Step (5), we store the MBR into the multidimensional index with the starting offset of the corresponding sliding window.

Like FRM, however, FRM-MAT has a problem of generating a lot of MBRs to be stored in the index since it divides data sequences into sliding windows. To solve this problem, FRM has constructed an MBR that contains multiple points corresponding to multiple sliding windows [4]. Thus, in FRM-MAT, we also construct an MBR that contains multiple MBRs corresponding to multiple sliding windows. That is, in the index building algorithm, we construct an MBR that represents multiple consecutive sliding windows and store the MBR with the starting offsets of the first and the last windows. For easy explanation and understanding, however, we describe the algorithm in Figure 1 as that FRM-MAT stores an individual MBR for each sliding window directly.
 Next, Figure 2 shows the subsequence matching algorithm of FRM-MAT. In Steps (1) and (2), for a give query sequence Q ,weobtain p disjoint windows i from the k -order moving average transformed sequence Q ( (8), for each disjoint window q ( k ) i , we find candidate subsequences by searching the index using the window and the given tolerance .First,inStep(4),we transform the corresponding window to an f -dimensional point using lower-dimensional transformation. Second, in Step (5), we construct a range query using the point and / index using the range query and find the MBRs that are in / point. Last, in Step (7), we obtain candidate subsequences using offset ,whichis stored in the record with the MBR as the starting position of the sliding window. Finally, in Step (9), the post-processing step, we select only similar subsequences by discarding false alarms from the candidate set. 3.3 DM-MAT: DualMatch with Moving Average Transform DM-MAT can also be derived from DualMatch [8] by using the poly-order trans-form. Since algorithms of DM-MAT are similar to those of FRM-MAT except difference in constructing windows, we omit the detailed algorithms of DM-MAT. 4.1 Experimental Data and Environment We have performed extensive experiments using two types of data sets. A data set consists of a long data sequence and has the same effect as the one consisting of multiple data sequences [4, 8, 9]. The fi rst data set, a real stock data set used in FRM [4] and DualMatch [8], consists of 329,112 entries. We call this data set STOCK-DATA . The second data set, also used in FRM and DualMatch, contains random walk synthetic data consisting of one million enties: the first entry is set to 1.5, and subsequent entries are obtained by adding a random value in the range (-0.001,0.001) to the previous one. We call this data set WALK-DATA .
We have performed experiments on the following five matching methods:  X  SEQ-SCAN : As a sequential scan solution, we find similar subsequences by  X  FRM-MAT : The FRM-based solution proposed in Section 3.2.  X  FRM-ORG : As a simple solution obtained from FRM, we build each index  X  DM-MAT : The DualMatch-based solution proposed in Section 3.3.  X  DM-ORG : As a simple solution obtained from DualMatch, we build each in-
The hardware platform for the experiment is a PC equipped with an Intel Pen-tium IV 2.80 GHz CPU, 512 MB RAM, and a 70.0GB hard disk. The operating system is GNU/Linux Version 2.6.6. We use the R  X  -tree [2] as a multidimensional index and extract six features[4, 8] from a window using Discrete Fourier Trans-form [4]. We use 256 as the minimum query length to be given, and accordingly, we set the window sizes for FRM-MAT and FRM-ORG to 256 [4], and those for DM-MAT and DM-ORG to 128 [8]. Next, we let K = { 2 , 4 , 8 , 16 , 32 , 64 , 128 } . Therefore, we build only one index for FRM-MAT (or for DM-MAT) on K , but seven indexes for FRM-ORG (or for DM-ORG) for each order in K .

For the experimental results, we measure the elapsed time as the metric of effi-ciency and the storage space as the metric of overhead for the indexes. To avoid effects of noise, we experiment with 10 d ifferent query sequences of the same length and use the average as the result. We obtain the desired selectivity[4, 8] by controlling the tolerance . 4.2 Experimental Results We conduct three different experiments: Experiment 1) measures the elapsed time by changing order k on different selectivities; Experiment 2) measures the elapsed time by changing order k on different query lengths; and Experiment 3) shows each index storage space required for the methods.
 Experiment 1) The elapsed times on different selectivities Figure 3 shows the experimental results for STOCK-DATA while changing order k on each selectivity of 0.0001, 0.001, and 0.01. Here, we use 512 as the query length. As shown in the figure, the proposed methods, both FRM-MAT and DM-MAT, reduce the elapsed time significantly over the sequential scan regardless of selectivity ranges. In summary, comparing with the sequential scan, FRM-MAT reduces the elapsed time by 22.4 times on the average, and DM-MAT by 33.8 times on the average. However, the elapsed times of FRM-MAT and DM-MAT are slighlty longer than those of FRM-O RG and DM-ORG respectively. It is be-cause the sizes of MBRs stored in the index in FRM-MAT and DM-MAT, which build only one index for all orders, is relatively larger than those in FRM-ORG and DM-ORG, which build each index for all orders. And, in the figure, DM-MAT shows better performance than FRM-MAT. It is because DM-MAT like DualMatch can use the index-level filtering but FRM-MAT like FRM cannot [8]. Experimental results for WALK-DATA are very similar to those of STOCK-DATA. We omit the results due to space limitation.
 Experiment 2) The elapsed times on different query lengths Figure 4 shows the experimental results for STOCK-DATA while changing order k on each query length of 256, 512, and 1024. Here, we use 0.0001 as the selectiv-ity. Figure 4 (a) is the case of using 256 as the query length, (b) for 512, and (c) for 1024. As shown in the figure, the proposed FRM-MAT and DM-MAT also reduce the elapsed time significantly over the sequential scan regardless query lengths. In summary of the results, FRM-MAT and DM-MAT reduce the aver-age elapsed time by 20.2  X  42.6 times compared with th e sequential scan. And, the results of WALK-DATA are also similar to those of STOCK-DATA.
 Experiment 3) Storage space requir ed for multidimensional indexes Table 2 shows index storage spaces of five matching methods. The space for the sequential scan is 0 since it does not use any index. As shown in the table, FRM-ORG needs about seven times more storage space than FRM-MAT since it builds total seven indexes while FRM-MAT builds only one index. Similarly, DM-ORG needs about seven times more storage space than DM-MAT. Likewise, the number of indexes, i.e., index storage space, required for FRM-MAT (or DM-MAT) is only 1 / | K | of that for FRM-ORG (or DM-ORG). And accordingly, our methods can also reduce the index maintenance overhead, which are required to support insertion, deletion, and u pdate of data sequences, by up to 1 / | K | . Moving average transform is known to reduce the effect of noise and has been used in many areas such as econometrics since it is useful in finding overall trends. The previous researches on subsequence matching with moving average transform, however, would incur a critical overhead both in index space and in index maintenance. To solve this problem, we have proposed a single index approach for the moving average transformed subsequence matching.

The contribution of the paper can be summarized as follows. First, we have analyzed the problems that occur when we apply the previous matching algo-rithms to the moving average transformed subsequence matching. Second, we have formally defined the poly-order moving average transform by generalizing the original definition of moving average transform. Third, we have presented a related theorem to guara ntee correctness of the pol y-order transform-based subsequence matching and formally proven the theorem. Fourth, we have pro-posed two different moving average transformed subsequence matching algo-rithms, FRM-MAT and DM-MAT. Last, we have empirically shown superiority of the proposed methods through the extensive experiments on various data types, selectivity ranges, and query lengths. Experimental results for real-stock data show that our approach improves average performance by 22.4  X  33.8 times over the sequential scan. And, when comparing with the cases of building each index for all orders, our approach reduces the storage space and maintenance effort required for indexes significantly by sacrificing only a little performance degradation.
 This work was supported by the Ministry of Science and Technology (MOST)/ Korea Science and Engineering Foundation (KOSEF) through the Advanced In-formation Technology Research Center (AITrc).

