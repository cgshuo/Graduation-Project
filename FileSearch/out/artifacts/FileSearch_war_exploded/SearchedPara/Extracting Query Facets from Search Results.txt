 Web search queries are often ambiguous or multi-faceted, which makes a simple ranked list of results inadequate. To assist information finding for such faceted queries, we ex-plore a technique that explicitly represents interesting facets of a query using groups of semantically related terms ex-tracted from search results. As an example, for the query  X  X aggage allowance X , these groups might be different air-lines, different flight types (domestic, international), or dif-ferent travel classes (first, business, economy). We name these groups query facets and the terms in these groups facet terms. We develop a supervised approach based on a graphical model to recognize query facets from the noisy candidates found. The graphical model learns how likely a candidate term is to be a facet term as well as how likely two terms are to be grouped together in a query facet, and captures the dependencies between the two factors. We pro-pose two algorithms for approximate inference on the graph-ical model since exact inference is intractable. Our evalu-ation combines recall and precision of the facet terms with the grouping quality. Experimental results on a sample of web queries show that the supervised method significantly outperforms existing approaches, which are mostly unsuper-vised, suggesting that query facet extraction can be effec-tively learned.
 H.3.3 [ Information Storage and Retrieval ]: Information Search and Retrieval X  Clustering, Query formulation Algorithms, Experimentation Query Facet, Semantic Class Extraction, Multi-faceted Query Web search queries are often ambiguous or multi-faceted [27]. Current popular approaches try to diversify the result list to account for different search intents or query subtopics [24]. A weakness of this approach is that the query subtopics are hidden from the user, leaving him or her to guess at how the results are organized.

In this work, we attempt to extract query facets from web search results to assist information finding for these queries. We define a query facet as a set of coordinate terms  X  i.e., terms that share a semantic relationship by being grouped under a more general hypernym ( X  X s a X  relationship). For example, for the query mars landing , three possible query facets are shown in Table 1.

The first query facet, { Curiosity , Opportunity , Spirit } , in-cludes different Mars rovers. The second query facet, { USA , UK , Soviet Union } , includes countries relevant to Mars land-ings. These are both facets where the terms are instances of the same semantic class. Somewhat differently, the last facet, { video , pictures , news } , includes labels for different query subtopics. These labels can be viewed as instances of a special semantic class, the subtopics of the query mars landing .

Query facets can be used to help improve search experi-ence in many ways. Like in faceted search [6], query facets can help users to navigate through different topics of the search results by applying multiple filters. Using the exam-ples in Table 1, for query baggage allowance , a user can select Delta , international , business class , quantity from each of its facets, to find pages discussing the number of bags allowed on Delta X  X  international business class flights. Query facets can also be used as query suggestions or clarification ques-tions to help users specify search intent. For example, for the query mars landing , a system might suggest the query facet { video , pictures , news } or generate clarification questions like  X  Which Mars rover are you looking for? a) Curiosity, b) Opportunity, c) Spirit  X . Query facets are also useful for exploratory search since they succinctly summarize interest-ing facts for the issued query. For example, facets for the query mr bean list episodes titles, characters and casts for the Mr. Bean television series.

In this paper we develop a supervised method based on a graphical model for query facet extraction. The graphical model learns how likely it is that a term should be selected and how likely it is that two terms should be grouped to-gether in a query facet. Further, the model captures the dependencies between the two factors. We propose two al-gorithms for approximate inference on the graphical model since exact inference is intractable. Also, we design an eval-uation metric for query facet extraction, which combines recall and precision of the facet term, with the grouping quality.

The rest of this paper is organized as follows. We discuss related work in Section 2, and then present the problem formulation in Section 3. Section 4 describes the general framework we use for query facet extraction. Section 5 de-scribes our graphical model based approach in detail. Sec-tion 6 briefly describes two alternate approaches that we use as baselines. We describe the dataset as well as the metrics we used for evaluation in Section 7, and report experimen-tal results in Section 8. Finally, we conclude the work in Section 9.
Related work of query facet extraction can be divided into the following topics.
Search result diversification has been studied as a method of tackling ambiguous or multi-faceted queries while a ranked list of documents remains the primary output feature of Web search engine today[24]. It tries to diversify the ranked list to account for different search intents or query subtopics. A weakness of search result diversification is that the query subtopics are hidden from the user, leaving him or her to guess at how the results are organized. Query facet extrac-tion addresses this problem by explicitly presenting different facets of a queries using groups of coordinate terms.
Search results clustering is a technique that tries to orga-nize search results by grouping them into, usually labeled, clusters by query subtopics [4]. It offers a complementary view to the flat ranked list of search results. Most previous work exploited different textual features extracted from the input texts and applied different clustering algorithms with them. Instead of organizing search results in groups, there is also some work [14, 15, 16] that summarizes search results or a collection of documents in a topic hierarchy. For example, Lawrie et al. [14, 15] used a probabilistic model for creating topical hierarchies, in which a graph is constructed based on conditional probabilities of words, and the topic words are found by approximately maximizing the predictive power and coverage of the vocabulary. Our work is different from these work in that our target is to extract different facets of a query from search results, instead of organizing the search results.
To address multi-faceted queries, much previous work stud-ied mining query subtopics (or aspects). A query subtopic is often defined as a distinct information need relevant to the original query. It can be represented as a set of terms that to-gether describe the distinct information need [29, 31, 5] or as a single keyword that succinctly describes the topic [28]. Dif-ferent resources have been used for mining query subtopics, including query logs [30, 11, 32, 29, 31, 33], document cor-pus [2] and anchor texts [5].

A query subtopic is different from a query facet in that the terms in a query subtopic are not restricted to be coor-dinate terms, or have peer relationships. Query facets, how-ever, organize terms by grouping  X  X ibling X  terms together. For example, { news , cnn , latest news , mars curiosity news } is a valid query subtopic for the query mars landing , which describes the search intent of Mars landing news, but it is not a valid query facet, given our definition, since the terms in it are not coordinate terms. A valid query facet that de-scribes Mars landing news could be { cnn , abc , fox } , which includes different news channels. In a recent work [7], Dou et al. developed a system to extract query facets from web search results and showed the potential of doing so. How-ever, the unsupervised method they proposed is far from optimal, and it does not improve by having human labels available. Also, to the best of our knowledge, their evalu-ation can be problematic in some cases, which will be dis-cussed in Section 7.2.3.
Semantic class mining can be used to help query facet extraction. Class attribute extraction [17, 18] aims to extract attributes for a target semantic class usually spec-ified by as a set of representative instances. For example, given a semantic class country , together with some instances like USA , UK , China , some class attributes can be capital city , president , population . Those extracted class attributes can be used as query subtopics. However, class attribute ex-traction targets semantic classes, not general search queries.
Semantic class extraction aims to automatically mine semantic classes represented as their class instances from certain data corpus. Existing approaches can be roughly divided into two categories: distributional similarity and pattern-based [25]. The distributional similarity approach is based on the distributional hypothesis [8], that terms occur-ring in analogous contexts tend to be similar. Different types contexts has been studied for this problem, including syntac-tic context [20] and lexical context [21, 1, 19]. The pattern-based approach applied textual patterns [9, 22], HTML pat-terns [26] or both [34, 25] to extract instances of a semantic class from some corpus. The raw semantic class extracted can be noisy. To address this problem, Zhang et al. [34] used topic modeling to refine the extracted semantic classes. Their assumption is that, like documents in the conventional setting, raw semantic classes are generated by a mixture of hidden semantic class. In this paper, we apply pattern-based semantic class extraction on the top-ranked Web documents to extract candidates for finding query facets.
Faceted search is a technique for accessing information or-ganized according to a faceted classification system, allowing users to digest, analyze and navigate through multidimen-sional data. It is widely used in e-commerce and digital libraries [6]. Faceted search is similar to query facet extrac-tion in that both of them use sets of coordinate terms to represent different facets of a query. However, most existing works for faceted search are build on as specific domain or predefined categories [7], while query facet extraction does not restrict queries in a specific domain, like products, peo-ple, etc.
Query facet extraction is the problem of finding query facets for a given query q from available resources, such as web search results. A query facet F = { t } is a set of coordinate terms, terms that are part of a semantic set, which we call facet terms . These facet terms can be in-stances of a semantic class, for example Curiosity , Opportu-nity , Spirit are all Mars rovers. They can be labels for query subtopics, such as video , pictures , news for the query mars landing . We use F = { F } to denote the set of query facets. T
F = { t | t  X  F, F  X  X } is the set of all the facets terms that appear in F .

Query facets can be extracted from a variety of differ-ent resources, such as a query log, anchor text, taxonomy and social folksonomy. In this work, we only focus on ex-tracting query facets from the top k web search results D = { D 1 ,D 2 ,...,D k } . We intend to explore the use of other information sources for this problem in future work.
In this section, we describe the general framework we use for extracting query facet from web search results. Given a query q , we retrieve the top k search results, D , as input to our system. Then query facets F are extracted by, first, extracting candidates from search results D and then finding query facets from the candidates.
Similar to Dou et al. [7], we use pattern-based seman-tic class extraction approach [25] to extract lists of coordi-nate terms from search results as candidates for query facets. In pattern-based semantic class extraction, patterns are ap-plied on the corpus to discover specific relationships between terms. For example, the pattern  X  NP such as NP , NP , ..., and NP  X  can be used to extract coordinate terms and their hypernyms from text. Besides lexical patterns, HTML pat-terns are often used on HTML documents to extract co-ordinate terms from some HTML structures, like &lt; UL &gt; , &lt; SELECT &gt; and &lt; TABLE &gt; .
 Type Pattern Lexical item , { , item }  X  , (and | or) { other } item
HTML We use both of the two types of patterns, summarized in Table 2. In the table, all items in each pattern are extracted as a candidate list. For example, from the text sentence  X  ... Mars rovers such as Curiosity, Opportunity and Spirit  X , according to the lexical pattern, we will extract a candidate list { Curiosity , Opportunity , Spirit } . For the lexical pattern, we also restrict those items to be siblings in the parse tree of that sentence. We use the PCFG parser [12] implemented in Stanford CoreNLP 1 for parsing documents. For HTML tables, following Dou et al. [7], lists from each column and each row are extracted.

After extracting the lists from the top ranked results D , we further process them as follows. First, all the list items are normalized by converting text to lowercase and removing non-alphanumeric characters. Then, we remove stopwords and duplicate items in each lists. Finally, we discard all lists that contain fewer than two item or more than 200 items. After this process, we have a set of candidate lists L = { L } , where each list L = { t } is a set of list items.
The candidate lists extracted are usually noisy [34], and could be non-relevant to the issued query, therefore they cannot be used directly as query facets. Table 3 shows four candidate lists extracted for the query mars landing . L contains list items that are relevant to mars landing , but they are not coordinate terms. L 2 is a valid query facet, but it is incomplete  X  another Mars rover Spirit appears in L . L 3 is extracted from the sentence,  X  It is bigger than the 400-pound Mars Exploration rovers, Spirit and Opportunity, which landed in 2004  X . The list item  X  the 400 pound mars exploration rovers  X  is an extraction error.
 Table 3: Four candidate lists for query mars landing
L 1 : curiosity rover, mars, nasa, space
L 2 : curiosity, opportunity
L 3 : the 400 pound mars exploration rovers, spirit, opportunity
L 4 : politics, religion, science technology, sports, ...
Since the candidate lists are frequently noisy, we need an effective way to find query facets from extracted candidate lists. More formally, given a set of candidate lists L = { l } , the task is to find a set of query facets F , where T F  X  T Similar to T F , T L = { t | t  X  L, L  X  L} is the set of all list items in L . To address this problem, we develop a graphical model, which learns how likely a list item is a facet term, how likely two list items should be grouped in a query facet, and capture the dependencies between the two factors.
In this section, we describe the directed graphical model we use to find query facts form noisy candidate lists. A di-rected graphical model (or Bayesian network) is a graphical model that compactly represents a probability distribution a directed acyclic graph in which each vertex represents a variable, and 2) a set of conditional probability distribu-tions that describe the conditional probabilities of each ver-tex given its parents in the graph.

We treat the task of finding query facets from candidate lists as a labeling problem, in which we are trying to predict http://nlp.stanford.edu/software/corenlp.shtml 1) whether a list item is a facet term, and 2) whether a pair of list items is in one query facet. Then, we used a directed graphical model to exploit the dependences that exist be-tween those labels. Similar to conditional random fields [13], we directly model the conditional probability P ( y | x ), where y is the label we are trying to predict and x is the observed data  X  list items and item pairs. Thus, it avoids model-ing the dependencies among the input variables x , and can handle a rich set of features. For our graph model, exact maximum a posteriori inference is intractable; therefore, we approximate the results using two algorithms. First we define all the variables in our graphical model. Let Y = { y i } , where y i = 1 { t i  X  T F } is a label indicating whether a list item t i is a facet term. Here 1 { X } is an indi-cator function which takes on a value of 1 if its argument is true, and 0 otherwise. p i,j denotes the list items pair ( t ,t j ), and P L = { p i,j | p i,j = ( t i ,t j ) , t i ,t denotes all the items pairs in T L . Let Z = { z i,j z i,j = 1 { X  F  X  F , t i  X  F  X  t j  X  F } is a label indicates whether the corresponding item pair p i,j should be grouped together in a query facet. The vertices in our graphical model are V = T L  X  P L  X  Y  X  Z . Note that the list items T , and item pairs P L are always observed.

As shown in Figure 1, there are three types of edges in the graph: 1) edges from each list item t i to its corresponding labels y i ; 2) edges that point to each item pair label z from the two corresponding list items y i and y j ; 3) edges from each item pair p i,j to its corresponding label z i,j Figure 1: A graphical model for candidate list data
We use logistic-based conditional probability distributions (CPDs) for variable y i and z i,j , defined as in Equation 1 and Equation 2.
 f k and g k are features that characterize a list item and a item pair respectively.  X  and  X  are the weights associated with f k and g k respectively. Compared to a conventional logistic function, Equation 2 has an extra term, y i y j , in the numerator. When y i = 0 or y j = 0, we have P ( z i,j 1 | p i,j ,y i ,y j ) = 0. This means when either of the two list items is not a facet term, the two items can never appear in a query facet together. When both of the t i and t j are facet terms, P ( z i,j = 1 | p i,j ,y i ,y j ) becomes a conventional logistic function, which models the probability of t i and t being grouped together in a query facet, given the condition that both t i and t j are facet term.

The joint conditional probability for the graphical model is calculated as
P ( Y,Z | T L ,P L ) = Y where the CPDs are defined in Equation 1 and Equation 2.
The training set for the graphical model can be denoted as { T
L ,P L ,Y  X  ,Z  X  } , where Y  X  , Z  X  are the ground truth labels for the list items T L and item pairs P L . The conditional probability of the training set can be calculated according to Equation 4.
 The log-likelihood l (  X , X  ), can be calculated as follows, terms of Equation 6 and Equation 7 are served as regular-izers which penalize large values of  X  ,  X  .  X  and  X  are reg-ularization parameters that control the strength of penalty. Notice that, in the train set, for those item pairs p i,j any of its list item not being a facet term, their labels z i,j = 0. According to Equation 2, for those item pairs, l (  X  ), and thus l p (  X  ) can be simplified as where Z 0 is a subset of Z , which contains only the labels for item pairs with both of its list items being facet terms.
We can see that Equations 6 and 8 are exactly the same as log-likelihoods for two separated logistic regressions. In fact, Equation 6 learns a logistic regression model for whether a list item is a facet term, and Equation 8 learns a logis-tic regression model for whether two facet terms should be grouped together. The parameter  X  and  X  can be learned by maximizing the log-likelihood using gradient descent, ex-actly same as in logistic regression.
When given a new labeling task, we could perform max-imum a posteriori inference -compute the most likely la-bels Y  X  ,Z  X  by maximizing the joint conditional probability P ( Y,Z | T L ,P L ). After that, the query facet set F can be easily induced from the labeling Y  X  ,Z  X  . (Collect list items with y i = 1 as facet terms, and group any two of them into a query facet if the corresponding z i,j = 1.) Note that the graphical model we designed does not enforce the labeling to produce strict partitioning for facet terms. For example, when Z 1 , 2 = 1, Z 2 , 3 = 1, we may have Z 1 , 3 = 0. There-fore, an optimal labeling results may induce an overlapping clustering. To simplify the problem, we add the strict par-titioning constraint that each facet term belongs to exactly one query facet. Also, to directly produce the query facets, instead of inducing them after predicting labels, we rephrase the optimization problem as follows. First, we use the fol-lowing notations for log-likelihoods, Using the notations above, the log-likelihood l ( F ) for a par-ticular query facet set F formed from L can be written as In the right hand side of Equation 9, the first term is the intra-facet score, which sums up s p (  X  ,  X  ) for all the item pairs in each query facet. The second term is the inter-facet score, which sums up the s p (  X  ,  X  ) for each item pair that appears in different query facets. Then the optimization target be-comes F = arg max F X  F l ( F ), where F is the set of all possi-ble query facet sets that can be generated from L with the strict partitioning constraint.

This optimization problem is NP-hard, which can be proved by a reduction from the Multiway Cut problem [3]. There-fore, we propose two algorithms, QF-I and QF-J , to ap-proximate the results.
QF-I approximates the results by predicting whether a list item is a facet term and whether two list items should be grouped in a query facet independently, which is ac-complished two phases. In the first phase, QF-I selects a set of list items as facet terms according to P ( y this way, the algorithm predicts whether a list item t a facet term independently, ignoring the dependences be-tween y i and its connected variables in Z . In our imple-mentation, we simply select list items t i with P ( t i ) &gt; w as facet terms. (For convenience, we use P ( t i ) to denote P ( y i = 1 | t i ).) In the second phase, the algorithm clusters the facet terms T F selected in the first phase into query P ( z i,j = 1 | p i,j ,y i = 1 ,y j = 1)). Many clustering algorithm can be applied here, using P ( t i ,t j ) as the distance mea-sure. For our implementation, we use a cluster algorithm based on WQT [7], because it considers the importance of nodes while clustering. We use P ( t i ) as the measure for facet term importance, and d t ( t i ,t j ) = 1  X  P ( t i distance measure for facet terms. The distance between a cluster and a facet term is computed using complete linkage distance, d f ( F,t ) = max t 0  X  F d ( t,t 0 ), and the diameter of a cluster can be calculated as dia ( F ) = max t i ,t j  X  F The algorithm is summarized in Algorithm 1. It processes the facet terms in decreasing order of P ( t ). For each facet term remaining in the pool, it builds a cluster by iteratively including the facet term that is closest to the cluster, until the diameter of the cluster surpasses the threshold d max Algorithm 1 WQT for clustering facet term used in QF-I Input: T F ,P ( t ) ,d f ( F,t ) ,dia ( F ) ,d max Output: F = { F } 2: repeat 4: F  X  X  t } 5: iteratively include facet term t 0  X  T pool that is closest 6: F  X  X   X  X  F } , T pool  X  T pool  X  F 7: until T pool is empty 8: return F
QF-I finds query facets based on the graphical model by performing inference of y i and z i,j independently. The sec-ond algorithm, QF-J, instead tries to perform joint inference by approximately maximizing our target l ( F ) with respect to y i and z i,j iteratively. The algorithm first guesses a set of list items as facet terms. Then it clusters those facet terms by approximately maximizing l p ( F ), using a greedy approach. After clustering, the algorithm checks whether each facet term  X  X its X  in its cluster, and removes those that do not fit. Using the remaining facet terms, the algorithm repeats the process (clustering and removing outliers) until convergence.

QF-J is outlined in Algorithm 2. The input to the al-gorithm are the candidate list item set T L , and the log-items according to s t ( t ) as the initial facet terms, because it is less sensitive to the absolute value of the log-likelihood. In our experiment, n is set to 1000 to make sure most of the correct facet terms are included. Then, the algorithm improves l ( F ) by iteratively performing functions Cluster and RemoveOutliers . Cluster performs clustering over a given set of facet terms. In step 10 to 12, it puts each facet terms into a query facet by greedily choosing the best facet, or creates a singleton for the list item, according to the re-sulting log-likelihood, l p ( F ). We choose to process these list items in decreasing order of s t ( t ), because it is more likely to form a good query facet in the beginning by doing so. Re-moveOutliers removes facet terms according to the joint term to see if it fits in the facet, and removes outliers. F the set of facet terms the algorithm selected when processing each facet F .
The output of QF-I and QF-J is a query facet set F . To produce ranking results, we defined a score for a query facet as score F ( F ) = P t  X  F P ( t ), and rank the query facets ac-cording to this scoring, in order to present more facet terms in the top. Facet terms within a query facet are ranked according to score t ( t ) = P ( t ). Algorithm 2 QF-J Input: T L = { t } ,l,l p Output: F = { F } 1: T F  X  top n list items from T L according to s t (  X  ) 2: repeat 3: F  X  Cluster ( T F ,l p ) 4: T F  X  RemoveOutliers ( F ,l ) 5: until converge 6: return F 7: 8: function cluster ( T F ,l p ) 9: F  X  X  X  10: for each t  X  T F in decreasing order of s t ( t ) do 11: Choose to put t into the best facet in F or add 12: end for 13: return F 14: end function 15: 16: function RemoveOutliers ( F ,l ) 17: T F  X  all facet terms in F 18: for each F  X  X  do 19: F 0 =  X  20: for each t  X  F in decreasing order of s t (  X  ) do 21: choose to add t into F 0 or not, whichever has 22: if not, T F  X  X   X  X  t } 23: end for 24: end for 25: return T F 26: end function 27: return F
There are two types of features used in our graphical model, summarized in Table 4.

Item features , f k ( t ) in the graphical model, character-ize a single list item. To capture the relevance of item t to the query, we use some TF/IDF-based features extracted from the top k search results, D . For example, snippetDF is the number of snippets in top k search results that con-tain item t . snippetDF and other frequency-based features are normalized using log ( frequency + 1). To capture how likely item t is to be an instance of a semantic class, we use features extracted from candidate lists. For example, listTF is the frequency of t in the candidate lists extracted from D . Some list items occur frequently in candidate lists across different queries, such as home , contact us and pri-vacy policy . They are treated as stopwords, and removed from the candidate lists. We also use listIDF to cope with this problem. listIDF is the IDF of a list item in a general collection of candidate lists we extracted (see Section 7.1). It is calculated as listIDF ( t ) = log N  X  N t +0 . 5 N the total number of lists in the collection, N t is the number of lists contain t . The same form is used for clueIDF , IDF in ClueWeb09 2 collection.

Item Pair Features , g ( p i,j ) in the graphical model, are used to capture how likely a pair of list items should be grouped into a query facet, given that the two list item both http://lemurproject.org/clueweb09 length Number of words in t clueIDF IDF of t in ClueWeb09 collection TF Term frequency of t in D
DF Document frequency of t in D wDF Weighted DF. Each document count
SF Site frequency. Number of unique titleTF TF of t for the titles of D titleDF DF of t for the titles of D titleSF SF of t for the titles of D snippetTF TF of t for the snippets of D snippetDF DF of t for the snippets of D snippetSF SF of t for the snippets of D listTF Frequency of t in candidate lists listDF Number of documents that contain t listSF Number of unique websites that listIDF IDF of t in a general candidate list
TF.clueIDF TF  X  clueIDF listTF.listIDF listTF  X  lisIDF lengthDiff Length difference, | len ( t i )  X  len ( t j ) | listCooccur Number of candidate lists extracted textContextSim Similarity between text contexts listContextSim Similarity between list contexts are facet terms. This can be measured by context similar-ity [25]. For textContextSim , we use window size 25, and represent text context as a vector of TF weights. Cosine similarity is used as the similarity measure. Similarly, we use the candidate lists that contain the list item as its list context, and calculate listContextSim in the same way as textContextSim .
In this section, we describe two alternative approaches for finding query facets from candidate lists. They are used as baselines in our experiments.
Dou et al. [7] developed QDMiner/QDM for query facet extraction, which appears to be the first work that addressed the problem of query facet extraction. To solve the problem of finding query facets from the noisy candidate lists ex-tracted, they used an unsupervised clustering approach. It first scores each candidate list by combining some TF/IDF-based scores. The candidate lists are then clustered with bias toward important candidate lists, using a variation of the Quality Threshold clustering algorithm [10]. After clus-tering, clusters are ranked and list items in each clusters are ranked/selected based on some heuristics. Finally, the top k clusters are returned as results. This unsupervised approach does not gain by having human labels available. Also, by clustering lists, they lose the flexibility of breaking a candidate list into different query facets.
In semantic class extraction, Zhang et al. [34] proposed to use topic models to find high-quality semantic classes from a large collection of extracted candidate lists. Their assumption is, like documents in the conventional setting, candidate lists are generated by a mixture of hidden topics, which are the query facets in our case. pLSA and LDA are used in their experiments. We find this approach can be di-rectly used for finding query facets from candidate lists. The major change we need to make is that: in semantic class ex-traction, topic modeling is applied globally on the candidate lists (or a sample of them) from the entire corpus; in query facet extraction, we apply topic modeling only on the top k search results D , assuming the coordinate terms in D are relevant to the query. Then, the topics are returned as query facets, by using the top n list items in each topic (accord-ing to the list item X  X  probability in the topic). Though this topic modeling approach is more theoretically motivated, it does not have the flexibility of adding different features to capture different aspects such as query relevance.
Queries . We constructed a pool of 232 queries from dif-ferent sources, including random samples from a query log, TREC 2009 Web Track queries 3 , example queries appear-ing in related publications [32, 29] and queries generated by our annotators. Annotators were asked to select queries that they are familiar with from the pool for annotating. Overall, we collect annotations for 100 queries (see Table 5).
Search results . For each query, we acquire the top 100 search results from a commercial Web search engine. A few search results are skipped due to crawl errors, or if they are not HTML Web pages. For the 232-query set, we crawled 22,909 Web pages, which are used for extracting feature listIDF described in Section 5.3. For the 100 annotated queries, the average number of crawled Web pages is 98.7, the minimum is 79, both the maximum and the median are 100.

Query facet annotations . We asked human annotators to construct query facets as ground truth. For each query, we first constructed a pool of terms by aggregating facet terms in the top 10 query facets generated by different models, including two runs from QDM, one run from each of pLSA and LDA using top 10 list items in each query facets, and one run for our graphical model based approach. Then, annotators were asked to group terms in the pool into query facets for each query they selected. Finally, the annotator was asked to give a rating for each constructed query facet, http://trec.nist.gov/data/web/09/wt09.topics.queries-only regarding how useful and important the query facet is. The rating scale of good=2/fair=1 is used. Annotation statistics are given in Table 6. There are 50 query facets pooled per query, with 224.8 distinct facet terms per query.

Query facet extraction can be evaluated from different as-pects. We use standard clustering and classification evalua-tion metrics, as well as metrics designed for this particular task to combine different evaluation aspects.

Notation : we use  X   X   X  to distinguish between system gen-erated results and human labeled results, which we used as ground truth. For example, F denotes the system generated query facet set, and F  X  denotes the human labeled query facet set. For convenience, we use T to denote T F in this section, omitting subscript F . T  X  denotes all the facet terms in human labeled query facet set. We use r F  X  to denote the rating score for a human labeled facet F  X  .
One aspect of query facet extraction evaluation is how well a system finds facet terms. This can be evaluated using standard classification metrics as follows, where facet term F1 is denoted as FT (the T stands for facet term ) to avoid confusion with a query facet F and cluster-ing F1 defined below. These metrics do not take clustering quality into account.
To evaluate how well a system groups facet terms cor-rectly, similar to Dou et al. [7], we use several existing cluster metrics, namely, Purity, NMI/Normalized Mutual Informa-tion and F1 for clustering. To avoid confusion with facet term F1, FT, we call F1 for facet term clustering facet clus-tering F1 , and denote it as FP (with P standing for term pair ).

In our task, we usually have T 6 = T  X  . The facet terms in the system generated and human labeled clustering re-sults might be different: the system might fail to include some human identified facet terms, or it might mistakenly include some  X  X ncorrect X  facet terms. These standard clus-tering metrics cannot handle these cases properly. To solve this problem, we adjust F as if only facet terms in T  X  were clustered by the system, since we are only interested in how well the  X  X orrect X  facet terms are clustered from these met-rics. The adjusting is done by removing  X  X ncorrect X  facet terms ( t  X  T  X  T  X  ) from F , and adding each missing facet term ( t  X   X  T  X   X  T ) to F as singletons. By this adjusting, we do not take into account the effectiveness of finding correct facet terms. To evaluate the overall quality of query facet extraction, Dou et al. [7] proposed variations of nDCG (Normalized Dis-counted Cumulative Gain), namely fp-nDCG and rp-nDCG. It first maps each system generated facet F to a human la-beled facet F  X  that covers the maximum number of terms in F . Then, it assigns the rating r F  X  to F , and evalu-ates F as a ranked list of query facets using nDCG. The discounted gains are weighted by precision and/or recall of facet terms in F , against its mapped human labeled facet F . For fp-nDCG, only precision are used as weight, | F  X   X  F | For rp-nDCG, precision and recall are multiplied as weight, | F  X  || F | . However, to the best of our understanding, this metric can be problematic in some cases. When two facets F 1 and F 2 are mapped to a same human labeled facet F  X  , only the first facet F 1 is credited and F 2 is simply ignored, even if it is more appropriate to map F 2 to F  X  (e.g. F 2 exactly same as F  X  , while F 1 contain only one facet term in F ).

The quality of query facet extraction is intrinsically multi-faceted. Different applications might have different empha-sis in the three factors mentioned above -precision of facet terms, recall of facet terms and clustering quality of facet terms. We propose a metric PRF  X , X  to combine the three factors together, using weighted harmonic mean. Let p = P ( T,T  X  ), r = R ( T,T  X  ), f = FP ( F , F  X  ), then PRF be expressed as follows, where  X  and  X  are used to adjust the emphasis between the three factors. When  X  =  X  = 1, we omit the subscript part for simplicity, i.e. PRF  X  PRF 1 , 1 .

While PRF  X , X  has the flexibility to adjust emphasis be-tween the three factors, it does not take into account the dif-ferent ratings associated with query facets. To incorporate ratings, we use a weighted version of P ( T,T  X  ), R ( T,T FP ( F , F  X  ) in PRF  X , X  . We call the new metric wPRF  X , X  The weighted facet term precision, recall and FT are defined as follows where w ( t ) is the weight for facet term t , and assigned as follows Similarly, wFP ( F , F  X  ) is computed by weighting its pair-wise precision and recall in the same fashion as the weighted facet term precision and recall above. Instead of w ( t ), we need weight for a pair of facet terms w ( t 1 ,t 2 ) in this calcu-lation. We assign weight for facet term pair w ( t 1 ,t 2 their sum, w ( t 1 ) + w ( t 2 ). We compare effectiveness of the five models, QDM, pLSA, LDA and QF-I, QF-J, on the 100-query data set. All the models take the same candidate lists extracted/cleaned (see Section 4.1) as input. We perform 10-fold cross validation for training/testing and parameter tuning in all experiments and for all models (if applicable). When training the graph-ical model, we standardize features by removing the mean and scaling to unit variance. We set both of the two reg-ularizers  X  and  X  in Equation 5 to be 1. There are too many negative instances ( y i = 0, z i,j = 0) in the training data, so we stratify samples by labels with the ratio of posi-tive:negative to be 1:3. For QDM, we tune the two parame-ters used in the clustering algorithm Dia max (the diameter threshold for a cluster) and W min (the weight threshold for a valid cluster), as well as two parameters used for selecting facet terms in each facet ( S t | F &gt;  X  | Sites ( F ) | and S For pLSA and LDA, we tune the number of facet terms in a query facet. For QF-I, we tune the weight threshold for facet terms, w min , and the diameter threshold, d max . For QF-J, there are no parameter need to be tuned. We returned top 10 query facets from all the five models in all evaluation.
To evaluate effectiveness in finding facet terms, we tune all the models on wFT, which combines both precision and recall, and takes into account facet term weighting. Table 7: Facet term precision, recall and F1 tuned on wFT
Model P wP R wR FT wFT pLSA 0.284 0.385 0.562 0.561 0.351 0.430 LDA 0.292 0.394 0.595 0.593 0.364 0.446 QDM 0.407 0.523 0.378 0.388 0.360 0.420 QF-I 0.347 0.458 0.644 0.652 0.427 0.514 QF-J 0.426 0.534 0.525 0.526 0.449 0.511 Table 8: Average number of facet terms in output per query for different models
Table 7 shows facet term precision, recall and F1 and their weighted version described in Section 7.2. QF-I and QF-J perform relatively well for both precision and recall. Their improvements over the other three models shown are all significant (p &lt; 0.05, using paired t-test), except the im-provements of QF-J over QDM for P and wP. The two topic model based approaches, pLSA and LDA, have relatively high recall and low precision. Contrarily, QDM has high precision and low recall. This difference can be explain by Table 8, which gives the number of facet terms output per query from each models. QDM only outputs 68 facet terms per query, while pLSA and LDA both output over twice that number. One possible reason for the low precision of pLSA and LDA is that they select facet terms solely according to term probabilities in the learned topics (query facets in our case) and do not explicitly incorporate query relevance. We find most of their facet terms are frequently-occurring list items, which are not necessary relevant to the query. While the number of facet terms QF-I outputs is similar to pLSA and LDA, QF-I obtain much higher precision and shows the five most important item features according to the absolute values of learned weights. Not surprisingly, list TF/IDF features which are used to capture the likelihood of being a coordinate term have relatively high weights, as well as some features that are used to capture query relevance, e.g. TF.clueIDF .
 Table 9: Top 5 item features, ranked by absolute weights
From Table 7, we also find the the weighted metrics are usually consistent with their corresponding unweighted met-ric. One exception is that QF-J performs better than QF-I in FT, but it does slightly worse than QF-J in wFT. This is likely to be caused by the high recall for QF-I, which may include more highly rated facet terms.
Table 10 shows clustering performance of the five models, which are tuned on wFP. The improvements of QF-I and QF-J over the other three models shown are all significant (p &lt; 0.05, using paired t-test). pLSA and LDA do not perform well in clustering, which could be caused by data sparsity. There are on average 5159 candidate lists per query, but only 3.9 items per list.
 Table 10: Facet clustering performance tuned on wFP Table 11: Weights learned for item pair features
The better performance in clustering for QF-I and QF-J can be explained by their incorporating factors other than list item co-occurrence information. In Table 11, we list the weights learned for item pair features. Besides one item co-occurrence related feature, listContextSim , we also find that textContextSim has a relatively high weight. textCon-textSim is used to capture the similarity of the two list items using their surrounding text, so it can help to group two facet terms together even if they might not co-occur a lot in candidate lists. As an example, for the query baggage allowance , we find different airlines do not co-occur a lot in candidate lists, (e.g. delta and jetblue only co-occur twice), but they tend to have high textContextSim (e.g. textContextSim ( delta,jetblue ) = 0 . 81), and are therefore grouped together by QF-I and QF-J.
To compare overall effectiveness of the five models, we tune all the models on wPRF, and the results are reported in Table 12.
 Table 12: Overall performance tuned on wPRF
Unweighted metrics are very similar to their correspond-ing weighted metrics in terms of conclusions, and are omit-ted due to space limitation. Results here are consistent with the results that were tuned on wFT or wFP. pLSA and LDA have high recall, but low precision and FP. QDM has rela-tively high precision, but low recall and FP. It has on average 68 facet terms per query as output, and fails to improve the overall effectiveness when including more facet terms in its output. QF-I and QF-J are among the best two models according to both PRF and wPRF.

Since wPRF does not account for facet ranking effective-ness, we also report fp-NDCG and rp-NDCG tuned on them-selves in Table 13. QF-J gives the best performance for both fp-NDCG and rp-NDCG. The improvements of QF-I and QF-J over the other three models shown in the Table 12 and 13 are all significant (p &lt; 0.05, using paired t-test), ex-cept the improvements of QF-J over QDM for wP and QF-I over QDM for fp-nDCG.
 Table 13: fp-nDCG and rp-nDCG tuned on them-selves
In this paper, we studied the problem of extracting query facets from search results. We developed a supervised method based on a graphical model to recognize query facets from the noisy facet candidate lists extracted from the top ranked search results. We proposed two algorithms for approxi-mate inference on the graphical model. We designed a new evaluation metric for this task to combine recall and pre-cision of facet terms with grouping quality. Experimental results showed that the supervised method significantly out-performs other unsupervised methods, suggesting that query facet extraction can be effectively learned.
This work was supported in part by the Center for In-telligent Information Retrieval and in part under subcon-tract #19-000208 from SRI International, prime contractor to DARPA contract #HR0011-12-C-0016. Any opinions, findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect those of the sponsor. [1] E. Agirre, E. Alfonseca, K. Hall, J. Kravalova, [2] J. Allan and H. Raghavan. Using part-of-speech [3] N. Bansal, A. Blum, and S. Chawla. Correlation [4] C. Carpineto, S. Osi  X nski, G. Romano, and D. Weiss. A [5] V. Dang, X. Xue, and W. B. Croft. Inferring query [6] D. Dash, J. Rao, N. Megiddo, A. Ailamaki, and [7] Z. Dou, S. Hu, Y. Luo, R. Song, and J.-R. Wen. [8] Z. Harris. Distributional structure. The Philosophy of [9] M. A. Hearst. Automatic acquisition of hyponyms [10] L. Heyer, S. Kruglyak, and S. Yooseph. Exploring [11] Y. Hu, Y. Qian, H. Li, D. Jiang, J. Pei, and Q. Zheng. [12] D. Klein and C. D. Manning. Accurate unlexicalized [13] J. D. Lafferty, A. McCallum, and F. C. N. Pereira. [14] D. Lawrie, W. B. Croft, and A. Rosenberg. Finding [15] D. J. Lawrie and W. B. Croft. Generating hierarchical [16] C. G. Nevill-manning, I. H. Witten, and G. W. [17] M. Pa  X sca. Organizing and searching the world wide [18] M. Pa  X sca and E. Alfonseca. Web-derived resources for [19] P. Pantel, E. Crestan, A. Borkovsky, A.-M. Popescu, [20] P. Pantel and D. Lin. Discovering word senses from [21] P. Pantel, D. Ravichandran, and E. Hovy. Towards [22] M. Pasca. Acquisition of categorized named entities [23] J. Pearl. Probabilistic reasoning in intelligent systems: [24] T. Sakai and R. Song. Evaluating diversified search [25] S. Shi, H. Zhang, X. Yuan, and J.-R. Wen.
 [26] K. Shinzato and K. Torisawa. Acquisition of [27] C. Silverstein, H. Marais, M. Henzinger, and [28] R. Song, M. Zhang, T. Sakai, M. Kato, Y. Liu, [29] X. Wang, D. Chakrabarti, and K. Punera. Mining [30] X. Wang and C. Zhai. Learn from web search logs to [31] F. Wu, J. Madhavan, and A. Halevy. Identifying [32] X. Xue and X. Yin. Topic modeling for named entity [33] X. Yin and S. Shah. Building taxonomy of web search [34] H. Zhang, M. Zhu, S. Shi, and J.-R. Wen. Employing
