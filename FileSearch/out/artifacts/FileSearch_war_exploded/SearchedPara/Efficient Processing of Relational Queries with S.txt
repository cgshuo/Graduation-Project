 query processing and optimization, as illustrated by the following example. Meal Example. Consider a database storing nutr itional information for single Fruits, and Beverages. All four relations have the same schema: name, cal, Vb6, Vc, fat, chol. Suppose that a meal consists of single servings of each of the four kinds of food. We are interested in finding meals t hat satisfy various nut ritional requirements, such as restrictions on the number of calories, grams of saturated fat, and amount of Vitamin C. For example, the daily USDA recommendations for a 30-year old female, who is moderately active, are 1800-2200 calories, less than 18g of saturated fat and 300mg of cholesterol, and at least 4mg of Vitamin B6 and 76mg of Vitamin C. Assuming that a main meal carries about half of the daily nutritional values, we can find all such meals with the following SQL query: This type of query is commonly encountered in the context of document retrieval [1], multimedia data retrieval [2], geographic information system [3, 4], e-commerce [5], dynamic resource allocation on the grid [6], and supply chain management. For example, in the context of supply chain management, a product supplier may constrain the total cost accord ing to a budget by carefully combining different service providers involved in producing, shipping and distributing products to construct a supply chain. Guha [7] shows that the decision-making process for supply chain an aggregate of attribute values. In the cont ext of Internet computing [8], applications need to find a set of computation resources with desired total memory size and CPU speed to run in order to get good performance and high efficiency. Assuming computation resources are stored in relatio ns, Liu [9] modeled resource allocation as over the sum of attribute values. multiple attributes. A sum constraint query is a query containing multiple sum constraints in its query condition. 
Conventional approaches implement this type of query by composing pair-wise joins. Because each condition refers to attributes from more than two relations, pair-wise join operators may fail to remove intermediate results based on these conditions, thus producing Cartesian products of relations that can lead to high memory and computation costs. Previous work improves the efficiency of query processing by either extending current database query processing engines (e.g. introducing new search algorithms [2] and new join operators [1, 9]), or by using sophisticated indexes [7]. In this paper we address the following question: Can we introduce efficient support for such query conditions into relational database systems without requiring significant modifications to the underlying database engine and building extra index structures? Note that our approach does not intend to replace previous methods. Instead, our method can be combined with previous methods to allow more efficient execution of sum constraint queries on relational database systems. In this paper, we make the following contributions: 
We introduce query rewriting techniques for sum constraint queries. The techniques create new query conditions that can be used by join operators to remove intermediate results that do not lead to any results at the early stage of the execution. Our experimental results show that the rewriting achieves significant reductions in query response time. 
We propose a framework for sorting tuples based on their likelihood of satisfying all sum constraints in a query. Using this framework, we consider the problem of producing partial results for a sum constraint query. We compare our method with that our method is more robust and efficient in handling sum constraint queries. problem. A multi-join operation combines information from multiple relations to Multi-joins are usually implemented by a set of pair-wise operations [10]. This method is efficient when the join condition consists of only equality or inequality comparisons of attributes from two join relations, as each individual join can eliminate tuples that do not satisfy its condition. Algorithms have been proposed for ordering pair-wise joins so as to obtain a minimal search space [11, 12]. (It is also possible to speed up queries by pair-wise strategy does not work well for sum constraint queries. Since a sum constraint involves tuples from multiple relations, a pair-wise join operator cannot test the constraint are determined. Thus, a purely pair-wise strategy may generate many intermediate results that cannot lead to any solutions. 
Guha et al. [7] and Agarwal et al. [15] address queries with sum constraints by results in [7] or precise results in [15]) for sum constraint queries efficiently. Creating problems). Thus, these approaches may cause an extra load to maintain the index on relation with constraints involving two or three attributes. Our approach can be applied to sum constraint queries for tuples from many different relations. 
Algorithms proposed by Fagin et al. [2] and Ilyas et al. [1] for top-k queries can be extended to implement queries with a constraint on the value of a monotone function, only use one constraint to guide the search process, which is not efficient when there are multiple constraints. In this paper, we introduce an approach using all constraints to guide the search process, and show that our method can be integrated with existing algorithms to further improve the search performance. combinatorial search problem. Combinatorial search problem has been widely studied Constraint programming [16] and mathematical programming [17] have been developed to solve this problem. Liu et al. [9] integrated constraint-programming techniques with can be implemented it without modifying existing database engines. Most current database systems use a left-deep query plan with pair-wise joins to implement a sum constraint query. As an example, Fig. 1(a) shows the execution plan for the sum constraint query from the Meal example. The problem with this execution plan is that join operators cannot remove intermediate results based on a sum constraint until the values of all attributes involved in this sum constraint are decided. Cartesian product of all involved relations. 
To solve this problem, we want an execution plan as shown in Fig. 1(b). This new filter tuples that cannot lead to a solution. Second, we introduce new query conditions that can be used by join operators to remove intermediate results. 3.1 Rewriting Techniques The essence of our method is rewriting each sum constraint in the query condition as filter tuples, and provide constraints for join operators to reduce intermediate results. 3.1.1 Selection Operators Selection operators use range constraints on one attribute to filter tuples from relations. We present a method to rewrite a sum constraint into a set of range constraints as follow. A sum constraint has the following general form: 
Here, c is a constant, A i ( i= 1.. n) are attributes that app ear in this constraint, and comp_op represents a comparison operator that could be  X &gt; X ,  X &lt; X ,  X   X   X , and  X   X   X . From (1) we can derive the following: 
We can calculate the lower and upper bounds of the expression on the right side of comp_op in (2) as follows: 
Here, max(A i ) and min(A i ) represent the maximum and minimum of attribute A i in the database instance. Using L k and H k we can create a range constraints for attribute A constraints greater-than constraints, and derive the following range constraint for A k : derive the following range constraint for A k : 
Any value not in the derived range cannot possibly satisfy the sum constraint shown in (1). Through (3) and (4), we obtain a range constraint for each attribute in constraints to filter out tuples that will not lead to any query result. 3.1.2 Join Operators expensive because it needs to calculate the Ca rtesian product of the involved relations after being processed by the selection operators. Another possible improvement is to use the join operators in order to remove intermediate results not leading to any query values of the attributes involved in a constraint are determined. 
To this end, for each join operator, we rewrite a sum constraint into new constraints that only contain attributes a ppearing in intermediate results produced by this join operator. For the example in Fig. 1, we create, for the join operator between relation M and F, constraints containing attributes from only these two relations. Join satisfy these constraints. 
For a join operator containing k attributes A j (j=1...k), we create new constraints in (i = k+1...n) to the right side of the formula. The result is shown below: The left side is the sum of the first k attributes. We can calculate the bounds (SH k and SL formula: 
Then we can create constraints on the sum of the first k attributes as follows. If the original sum constraint was greater-than : 
Or, if the original sum constraint was less-than : 
New constraints contain only attribute A j (j=1...k), and can be used by the targeted join operator to remove intermediate results. Using this rewriting technique, we rewrite the meal query, and show a part of the new query: We only show the newly created constraints from the two sum constraints on the Cal attributes due to space limitation. Besides the original sum constraints, the new query contains range constraints on Cal attributes that can be used by selection operators to which can be used by the join operator between M and F, and the join operator between M, F, and B to remove intermediate results. 
When rewriting a query, we assume that we already know the order of the join on the size of filtered relations [10]. 
In summary, we rewrite a sum constraint into a set of simpler constraints that can be used by selection operators and join operators to improve the query performance. Although this rewriting technique adds more constraints to the query condition that may cause some extra computations to validat e a result, this cost is trivial compared to the gains archived by reducing tupl e reading operations and by reducing the order to quantify the performance improvements. In contrast to previous method require modifications of database query engines or building complex index structures, and can be easily deployed on current database systems. given number K results. Besides the query rewriting techniques, we propose an approach to find any K results of a sum constraint query. We focus on finding any K defined for our problem. 4.1 Tuple Quality consider  X  X ood X  tuples first. For Meal Example in order to find meals with enough vitamin C (represented as Vc ), we sort relation Fruits, Meats, Vegetables, and Beverages based on Vc , and combine tuples with bigger Vc first. 
However, a query may contain multiple  X  X onflicting X  sum constraints. For example, a query may ask for meals with calories and vitamin C more than some required values. The constraint on vitamin C  X  X onflicts X  with the constraint on calories because foods containing more vitamin C usually have less calories. Therefore, trying combinations of foods with more Vitamin C (or calories) does not necessarily help to improve the performance of the query for K results. As some of our experimental results show (Section 5.2) sorting tuples based on only one constraint can sometimes hurt performance. 
For a query with multiple sum constraints, instead of ordering tuples based on just one constraint, we need to consider all constraints, and try combinations of tuples that query. 
For a greater-than constraint C requiring the sum of attributes A to be greater than a value d, we define a quality of tuple t as: constraint. If the attribute value is more than d, this tuple fully satisfies this constraint satisfies t.A/d fraction of the requirement. 
For a less-than constraint C requiring the sum of attributes A to be less than a value d, we define a quality of tuple t as: 
Because the constraint requiring the sum of attribute values less than a value d, constraint. If the attribute value is more than d, this tuple cannot satisfy this constraint assuming all attribute are positive. We represent its contribution as a minimal value. If the attribute value is less than d, this tuple uses up t.A/d percent of the range specified in the constraint. each constraint. Among all constraints, some are difficult to satisfy than others. valuable than tuples that contribute to the satisfaction of easy constraints. 4.2 Constraint Difficulty Meal example to illustrate our method. Below, we show the median values of the attributes of all four relations. We represent the difficulty of a constraint by H. For a greater-than constraint C, we define H as the ratio between the sum of median values of the attributes and d. For a less-than constraint, we define H as: 
The intuition behind the quantity H is that the bigger H is, the smaller the number of tuples that can satisfy this constraint. The difficulty (H) values of the six constraints of the Meal query are shown below: 
We calculate the quality of a tuple for a query by aggregating its quality values for each constraint using (16). Using the constraint difficulty as a factor when summing up the quality for each constraint, this formula gives more weight to tuples with a high quality for difficult constraints. We sort tuples in relations according to their quality for the query, and join higher quality tuples first. In this way, we check combinations of tuples that most likely satisfy all sum constraints in a query first. In order to evaluate the rewriting technique and sorting framework we propose in this paper, we performed several experiments using real-world data. 
We use a food database published by the USDA [18]. This database contains nutritional facts for more than 7000 types of food. From this database we created four relations: Fruits, Vegetables, Beverages, and Meats containing information about their eponymous types of food. The sizes of these relations are as follows: Fruits 273, Vegetables 717, Beverages 199, and Meats 1602. 
We created this database and run all queries on a PostgreSQL 8.0.3 relational database system. The system is running on a Linux machine with 4 Intel Xeon CPU 3GHz processors, and 2GB of main memory. 5.1 Evaluating the Query Rewriting Technique We evaluated the efficiency of our rewriting technique by comparing the response time of several sum constraint queries with and without rewriting. Another way to our experiments we studied how these two methods interact under different scenarios. We compared six different combinations of these two methods as shown in values, and uses rewriting. In this section, we focus on the traditional sorting methods: ordering tuples according to one a ttribute. We consider our new sorting algorithm in the next section. 
We evaluated these 6 plans on several sum constraint queries. In this section, we report on two of them, with representative performance, shown in Fig. 2. QA contains range of Min_cal and Min_cal + 200. AND M.cal+V.cal+B.cal+F.cal &lt; Min_cal+200 (QB only)
First, consider QA, containing only the constraint that specifies the minimal obviously not an appropriate choice to consider foods with lower number of calories first (plans III, IV). 
We ran QA with K=20 . We varied the required calories (represented by Min_cal ) Fig. 3(a). 
We note that the rewriting technique improves the query performance by comparing plan II, which rewrites the query, and plan I, which does not use any optimizations. When the number of required calories (Min_cal) is relatively small (around 700), the two plans have similar response times because there are many query needs to check more combinations of foods to find 20 meals, and shows increasingly high response time. In comparison, plan II consistently shows low response time. 
We also consider which one of the two approaches (sorting and query rewriting) is more effective in improving query performance. Although both approaches outperform plan I, the sorting-based method (plan III) consistently outperforms the rewriting-based approach (plan II) for QA. Note that plan IV, which uses both query rewriting and sorting, does not show any significant performance gain or loss compared to plan III. Thus, the query rewriting technique does not further improve the performance of the sort-based method for QA, which contains only one sum constraint. 
However, we found that rewriting does improve the performance of queries containing multiple conflicting sum constraints. We use QB as the benchmark for this type of queries. QB contains two  X  X onflicting X  constraints that specify an upper bound because the lower bound constraint favors tuples with higher calories, while the upper which sorting order is better for this query, we compare all six execution plans for this query, and show the results in Fig. 3(b). 
We first show that sorting approaches do not always improve the query performance for queries containing  X  X onflicting X  constraints. Plan III (Plan V), which ranks tuples based on the attribute cal and considers foods with higher (lower) calories first, shows long response time when Min_cal is small (large). Since QB asks that violate the upper (lower) bound of the range at the beginning of the search process. Plan I, which does not use any optimization, performs better than plan III and IV. This shows that sorting actually hurts the query performance of QB. 
In comparison, plan II, which uses the rewriting technique, shows a stable query performance and consistently outperforms sorting based methods. 
From the experimental results of the two benchmark queries, we can see that our proposed rewriting techniques improve the query performance consistently for different types of sum constraint queries. Sorting-based plans, on the other hand, show only good performance for queries with one sum constraint (QA in our case). 
Also, by comparing sorting only plans (plan III and Plan V) with plans using both the performance of sorting-based plans for QA, and remarkably improves the performance of sorting-based plans for QB. Therefore, we can conclude that rewriting techniques can be efficiently used with sorting-based approaches to improve query performance. 5.2 Evaluating the Sorting Framework performance of our sorting framework that takes into account all constraints. 
We use the Meal query as the benchmark query. This query asks for K combinations of single servings of meats, vegetables, fruits, and beverages with the required nutritional values. We compared the response time of 6 execution plans, attribute as traditional sorting methods do. For example, plan I sorts tuples based on other hand, sorts tuples based on their quality which takes into account all constraints. 
We rewrite this query and vary the number of required query results (K) in order to The response time is the average query response time over 100 runs. 
Our approach (Plan N) outperforms all other plans by a large margin when K is small. It shows that the proposed sorting method, which takes into account all constraints, improves the performance of quer ies with multiple conflicting constraints. The experimental results also show that the performance differences between plans shrink with the increase of K. Intuitively, sorting-based approaches only help when users ask for a small number of query results. In the extreme case when a query asks for all results, sorting-based approaches do not help at all. 
