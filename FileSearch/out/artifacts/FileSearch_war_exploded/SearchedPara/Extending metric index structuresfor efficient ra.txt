 SHORT PAPER Karin Kailing  X  Hans-Peter Kriegel  X  Martin Pfeifle  X  Stefan Sch  X  onauer Abstract Databases are getting more and more important for storing complex ob-jects from scientific, engineering, or multimedia applications. Examples for such data are chemical compounds, CAD drawings, or XML data. The efficient search for similar objects in such databases is a key feature. However, the general prob-lem of many similarity measures for complex objects is their computational com-plexity, which makes them unusable for large databases. In this paper, we combine and extend the two techniques of metric index structures and multi-step query pro-cessing to improve the performance of range query processing. The efficiency of our methods is demonstrated in extensive experiments on real-world data includ-ing graphs, trees, and vector sets.
 Keywords Complex objects  X  Metric indexing  X  Multi-step query processing  X  Density-based clustering 1 Introduction Databases are getting more and more important for storing complex objects from chemical compounds, CAD drawings, XML data, web sites, or color images. The efficient search for similar objects in such databases, for example to classify new objects or to cluster database objects, is a key feature in those application domains. Often a feature transformation is not possible, therefore a simple distance function like the Euclidean distance cannot be used. In this case, the use of more complex distance functions like the edit distance for graphs or trees is necessary. However, a general problem of all such measures is their computational complexity, which disqualifies their use for large databases.
 tering, one of the primary data mining tasks. Density-based clustering has proved to be successful for clustering complex objects [ 8 , 10 ]. Density-based clustering algorithms like DBSCAN [ 6 ]orOPTICS[ 2 ] are based on range queries for each database object. These algorithms are only applicable to large collections of com-plex objects if those range queries are supported efficiently. When working with complex objects, the necessary distance calculations are the time-limiting factor. For complex objects, distance calculations are often significantly more expensive than disk accesses.
 refinement architecture. The core idea is to apply a filter criterion to the database objects in order to obtain a small set of candidate answers to a query. The final result is then retrieved from this candidate set through the use of the complex sim-ilarity measure. This reduces the number of expensive object distance calculations and speeds up the search process.
 cient access methods for similarity search in metric spaces are presented. In most real-world applications, a static index structure is not acceptable, so dynamic in-dex structures like the M-tree [ 5 ] are applied.
 index structures, have only been used separately. We claim that these concepts can beneficially be combined and that through the combination a significant speed-up compared to both separate approaches can be achieved. In this paper, we discuss how the two approaches can be combined and present some other techniques to improve the efficiency of range query processing. Filters can easily be used to speed-up the creation and the traversing of a metric index structure like the M-tree. Additionally, caching can be used to prevent the same distance calculations to be performed more than once.
 some recent work in the field of indexing and clustering complex objects. Sec-tion 3 presents our techniques used to save costly distance calculations while performing range queries. The performance gain of our new techniques is pre-sented in Sect. 4 , while Sect. 5 concludes the paper and gives some hints at future work. 2 Motivation and related work In the next section, we present three promising and approved modeling approaches and distance measures for complex objects (see Fig. 1 for an illustration). The evaluation part will show that in all those cases we achieve a performance gain using our new techniques. Afterwards, we present some recent approaches for clustering and query processing on complex objects.
 The main purpose of this section is to motivate the necessity of new techniques which allow efficient similarity range queries on complex objects.
 2.1 Data types of complex objects In [ 10 ], an effective and flexible similarity model for complex 3D CAD data is traditional approach of describing one object by a single feature vector, but instead an object is mapped onto a set of feature vectors, i.e. an object is described by a vector set. The similarity measure for comparing two such vector sets has cubic time complexity, which makes calculating even a single similarity distance an expensive operation.
 carry some kind of internal structure, which often forms a hierarchy. A successful approach is to use degree-2 edit distance [ 18 ], which has been applied to trees for web site analysis [ 17 ], structural similarity of XML documents [ 14 ], shape recognition [ 15 ], or chemical substructure search [ 17 ].
 the known similarity measures for attributed graphs are either limited to a special type of graph or are computationally extremely complex, i.e. NP complete. A new measure for attributed graphs with cubic time complexity has recently been presented in [ 11 ]. 2.2 Clustering complex objects In recent years, the research community spent a lot of attention to clustering re-sulting in a large variety of different clustering algorithms. However, most of those algorithms were designed for vector data, so there is still a need for research on clustering complex objects.
 rithms like DBSCAN [ 6 ]andOPTICS[ 2 ], which are based on  X  -range queries. Density-based clustering algorithms provide the following advantages: 1. They can be used for all kinds of metric data spaces and are not confined to 2. They are robust concerning outliers. 3. They have proved to be very efficient and effective in clustering all sorts of 4. OPTICS is  X  in contrast to most other algorithms  X  relatively insensitive to 5. Traditional clustering algorithms are based on one representation space, usu-6. In [ 3 ] the authors show how visualizing the hierarchical clustering structure of 2.3 Query processing on complex objects 2.3.1 Multi-step query processing The main goal of a filter-refinement architecture, as depicted in Fig. 2 , is to reduce the number of complex and, therefore, time consuming object distance calcula-tions in the query process. To achieve this goal, query processing is performed in two or more steps. The first step is a filter step, which returns a number of candi-date objects from the database. For these candidate objects, the exact object dis-tance is then determined in the refinement step and the objects fulfilling the query predicate are reported. To reduce the overall search time, it is essential that the filter predicate is considerably easier to evaluate than the exact similarity measure and a substantial part of the database objects must be filtered out. Additionally, the completeness of the filter step is essential, i.e. all database objects satisfying the query condition are included in the candidate set. Available similarity search algo-rithms guarantee completeness if the distance function in the filter step fulfills the lower-bounding property. Using a multi-step query architecture requires efficient algorithms, which actually make use of the filter step. Agrawal et al. [ 1 ] proposed such an algorithm for range search. 2.3.2 Metric index structures In some applications, objects cannot be mapped into feature vectors. However, there still exists some notion of similarity between objects, which can be expressed as a metric distance between the objects, i.e. the objects are embedded in a met-ric space. Several index structures for pure metric spaces have been proposed in the literature (see [ 4 ] for an overview). A well-known dynamic index structure for metric spaces is the M-tree [ 5 ]. The M-tree, which is explained in detail in Sect. 3.1 , aims at providing good I/O performance as well as reducing the number of distance computations. 3 Efficient range queries on complex objects So far, the concepts of multi-step query processing and metric index structures have only been used separately. We claim that these concepts can beneficially be combined and that, through the combination, a significant speed-up compared to both separate approaches can be achieved. In the following, we will demonstrate the ideas for range queries with the M-tree as index structure and arbitrary filters fulfilling the lower-bounding criterion. It is worth noting that the techniques can also be applied to similar metric index structures like the Slim-tree [ 16 ]. for similarity range queries using the M-tree, we present the concept of  X  X ositive pruning X  in Sect. 3.2 . In Sect. 3.3 , we combine the two worlds of direct metric in-dex structures and multi-step query processing based on filtering. Finally, we show in Sect. 3.4 how caching can be applied to accelerate the processing of similarity range queries. 3.1 Similarity range queries using the M-tree The M-tree ( metric tree )[ 5 ] is a balanced, paged and dynamic index structure that partitions data objects not by means of their absolute positions in the multi-dimensional feature space but on the basis of their relative distances in this feature objects is metric. Thus, the M-tree X  X  domain of applicability is quite general, and all sorts of complex data objects can be organized with this index structure. or references to them are stored in the leaf nodes of an M-tree, along with their ner nodes contain so-called routing objects , which correspond to database objects to whom a routing role was assigned by a promoting algorithm that is executed whenever a node has to be split. In addition to the object description and the dis-tree of O r . For all objects O d in this covering tree, the condition holds that the induces a hierarchical structure of an M-tree, with the covering radius of a parent object always being greater or equal than all covering radii of their children and the root object of an M-tree storing the maximum of all covering radii. the answer set is defined to contain all the objects O d from the database that have a distance to the query object O q of less than or equal to  X  .
 Definition 1 (similarity range query) Let O be a domain of objects and DB  X  O be a database. For a query object O q  X  O and a query range  X   X  IR + 0 ,the similarity range query simRange : O  X  IR + 0  X  2 DB returns the set query simRange ( O q , X ) starts at the root node of an M-tree and recursively tra-verses the whole tree down to the leaf level, thereby pruning all subtrees which certainly contain no result objects.
 rangeSearch used to traverse the M-tree is given in Fig. 3 .
 d (
O p , O q ) , minus the distance between O r and O p is greater than the covering radius of O r plus  X  : already been computed when accessing a node N , subtrees can be pruned without further distance computations (see line 5 of the algorithm in Fig. 3 ). 3.2 Positive pruning A hierarchical index structure, like the M-tree, is composed of directory nodes T ( of range queries on the original M-tree is based on the concept of  X  X egative prun-ing X . During the query processing, certain subtrees are excluded from the search rithm in Fig. 3 ).
 node is completely covered by the query range, we can report all objects on the leaf level of the M-tree without performing any cost intensive distance computations (cf. Fig. 4 ).
 Lemma 1 Let O q  X  O be a query object and  X   X  IR + 0 a query range. Further-more, let O r be a routing object in an M-tree with a covering radius r ( O r ) and a subtree T ( O r ) . Then the following statement holds: Proof The following inequalities hold for all O  X  T ( O r ) due to the triangle in-equality and due to d ( O r , O q ) + r ( O r )  X   X  : d (
O , O q )  X  d ( O , O r ) + d ( O r , O q )  X  r ( O r ) + d ( O r , O q )  X   X  T ( of positive pruning, we skip all the distance calculations involved in the recursive tree traversal if the query range completely covers the covering radius r ( O r ) .In this case, we can report all objects stored in the corresponding leaf nodes of this subtree without performing any further distance computations. Figure 5 shows how this concept can be integrated into the original method rangeSearch depicted in Fig. 3 .
 complex objects. DBSCAN, for instance, only needs the information whether an object is contained in simRange ( O q , X ) ={ O  X  DB | d ( O , O q )  X   X  } but not the actual distance of this object to the query object O q . 3.3 Combination of filtering and indexing The M-tree reduces the number of distance calculations by partitioning the data space even if no filters are available. Unfortunately, the M-tree may suffer from the navigational cost related to the distance computations during the recursive tree traversal. On the other hand, the filtering approach heavily depends on the quality of the filters.
 the filter distances to optimize the required number of exact object distance cal-compared to the original M-tree, as the same nodes are traversed, but we save a lot of costly distance calculations necessary for the traversal. The filtering M-tree stores the objects along with their corresponding filter values within the M-tree. A similarity query based on the filtering M-tree always computes the filter dis-tance values prior to the exact distance computations. If a filter distance value is already a sufficient criterion to prune branches of the M-tree, we can avoid the ex-act distance computation. If we have several filters, the filter distance computation always returns the maximum value of all filters.
 filters and the clustering properties of the index structure. In the following, we will show that the number of distance calculations used for range queries as well as for the creation and update of an M-tree can be optimized by using lower-bounding filters.
 3.3.1 Range queries Similarity range queries are used to retrieve all objects from a database which are within a certain similarity range from the query object (cf. Definition 1 ). By com-puting the filter distance prior to the exact distance, we can save on many distance computations. Based on the following lemma, we can prune many subtrees with-out computing the exact distances between a query object O q and a routing object O r (cf. Fig. 6 ).
 Lemma 2 Let O be a set of objects and D B  X  O a database. Furthermore, let d , d d For each routing object O r  X  D B with covering radius r ( O r )  X  IR + 0 and subtree T (
O r ) the following statement holds: Proof As  X  O 1 , O 2  X  O : { ( O  X  , O  X  )  X  ( O  X  , O  X  ) holds, the following state-ment is true: can proof the aforementioned lemma as follows: on the leaf level with the assumption that their  X  X overing radius X  is 0. Figure 7 shows how this concept can be integrated into the original method rangeSearch of Fig. 3 . 3.3.2 Construction and update Filters can also be used for accelerating the creation and update of an M-tree. For the necessary adaptations of the insertion and split algorithms, we refer the reader to [ 7 ]. 3.4 Caching distance calculations In this section, we present a further technique which helps to avoid costly distance computations for index construction and query processing.
 caching distance calculations. During the navigation through the M-tree directory, though each object O is stored only once on the leaf level of the M-tree, it might be used several times as routing object. Furthermore, we often have the situation that distance calculations carried out on the directory level have to be repeated at the leaf level.
 recursion resulting in a depth-first search. We suggest to keep all distance compu-tations in main memory which have been carried out on the way from the root to the actual node. After leaving the node, i.e. when exiting the recursive function, we delete all distance computations carried out at this node. This limits the actual main memory footprint to O ( h  X  b ) ,where h denotes the maximum height of a tree and b denotes the maximum number of stored elements in a node. Even in multi-user environments, this rather small worst-case main memory footprint is tolerable. The necessary adaptations of the rangeSearch algorithm are drafted in Fig. 8 .
 4 Evaluation To show the efficiency of our approach, we chose the applications and data types described in Sect. 2 and performed extensive experiments. All algorithms were implemented in Java 1.4 and the experiments were run on a workstation with a Xeon 1.7 GHz processor and 2 GB main memory under Linux. We implemented the M-tree as described in [ 5 ]. As in all cases, the time for distance calculations was dominating the runtime of a range query, we only show the number of distance calculations and not the runtime. 4.1 CAD vector set data For the experiments with this data type, we used the similarity model presented in [ 10 ], where CAD objects were represented by a vector set consisting of seven vectors in 6D. All experiments were carried out on a data set containing 5000 CAD objects from an American aircraft producer. As distance measure between sets of feature vectors we used the minimal matching distances which can be computed in O ( k 3 ) ,where k denotes the cardinality of the point set, by means of the Kuhn X  Munkres algorithm [ 12 , 13 ]. As filter, we used the centroid filter introduced in [ 10 ].
 processing depend on the chosen  X  value. Figure 9 shows that for the investigated data set, the original M-tree is the worst access method for all  X  values. On the other hand, the pure filter performs very well. For this data set, reasonable  X  val-ues for density-based clustering would be about 1 for DBSCAN and about 2 for OPTICS. In this parameter range, our approach clearly outperforms both the filter and especially the original M-tree.
 M-tree, whereas for higher values, we benefit from caching and positive pruning. basis for the visual data mining tool presented in Sect. 2.2 . With a suitable param-eter setting for OPTICS we achieved a speed-up of 16% compared to the centroid filter, 33% compared to the original M-tree, and 104% compared to the sequential scan. Let us note that the average cardinality of the result set of each range query was almost 2000, which limits the best achievable speed-up to 150%. 4.2 Image data Image data are a good example for multi-represented complex objects. A lot of different similarity models exist for image data, each having its own advantages alike. Using color histograms instead, the images are clustered according to the distribution of color in the image. The approach for clustering multi-represented objects presented in [ 8 ] is able to get the best out of all these different types of representations. We present some experiments for image data represented as trees or graphs, where the efficiency of range query processing is especially important. 4.2.1 Tree structured image data Images can be described as segmentation trees. Thereby, an image is first divided into segments of similar color, then a tree is created from these segments by itera-tively applying a region growing algorithm, which merges neighboring segments if their colors are sufficiently alike. As similarity measure for the resulting trees, we used the degree-2 edit distance and implemented the filter-refinement archi-For the experiments, we chose reasonable epsilon values for the multi-represented clustering algorithm.
 nal M-tree. As can be seen, we also outperform the pure filtering approach. 4.2.2 Graph structured image data To extract graphs from the images, they were segmented with a region growing technique and neighboring segments were connected by edges to represent the neighboring relationship. We used the edge matching distance and the image data set as described in [ 11 ]. The filter presented in this paper is almost optimal, i.e. the number of unnecessary distance calculations during query processing is very low. Even in this case, our techniques is as good as the filter.
 duced it in a stepwise process. We weighted the original filter distances with con-stant factors to decrease the filter selectivity. Figure 12 shows that independent of the filter selectivity, our approach outperforms the original M-Tree by a factor of almost 2 and is at least as good as the pure filtering approach. 5 Conclusions The similarity measures used for complex objects are often computationally very complex, which makes them unusable for large databases. To overcome the effi-ciency problems, metric index structures or multi-step query processing are ap-plied. We combined and extended these approaches to achieve the best from two worlds. More precisely, we presented three improvements for metric index struc-tures, i.e. positive pruning, the combination of filtering and indexing, and caching. In a broad experimental evaluation based on real-world data sets, we showed that a significant speed-up for similarity range queries is achieved with our approach. By means of our new techniques, application areas like visually mining through cluster hierarchies of complex objects or clustering of complex multi-represented objects can be extended to larger databases.
 References Author Biographies
