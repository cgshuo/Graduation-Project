 The connection of the Web and databases bring many challenges and new oppor-tunities for creating advanced database applications. Web sites are also increas-ingly powered by accessing their databas es directly. However, the limited access capability, the lack of concurrency control and loosely structured information make querying the Web different from querying a conventional database. These essential aspects have significantly effects on the computability of queries [1,2].
The theory of database queries has grown into a rich research area, which includes the expressiveness and complexity of query languages, the domain inde-pendence and the safety of queries, query translation and optimization. However, the development of Internet technol ogy has occurred very rapidly and much of the above traditional framework of data base theory needs to b e re-investigated computability and local property of Web queries.

The most common technology currently used for searching the Web depends on sending information retrieval requests to  X  X ndex servers X  that provide asso-ciative access to a large collection of pre -computed data. However, these index servers and similar search engines do not guarantee they have indexed every Web object, nor do they give any guarantee of currency of the index [1]. One problem with these index servers is that queries cannot exploit the structure and topol-ogy of the Web objects network. We argue that designing feasible Web query languages and investigating fundamental aspects of querying the Web are still demanding and important. There are some interesting and challenging problems for these languages.

Expressiveness of database query languages is one of the major research top-ics in finite model theory. Most database query languages have limited power and some tools have been developed for analyzing these query languages. How-ever, most of those tools are only applicable to first-order logic and some of its extensions but they do not apply to languages querying the Web. We are es-pecially interested in computability and local property of query languages that are applied to the Web. By locality, we mean that the result of a query can be determined by looking at a certain predetermined portion of the input. The conventional approach in database theory is to estimate query evaluation time as a function of the size of the database. The classical complexity and expres-sivity is irrelevant in the Web context. For a query to be practical, it should not attempt to access too much of the network. The goal of this paper is to give a general study of local property of queries in the context of Web scenario, which goes beyond the pure first-order case, and then analyze expressive power of Web queries including XQuery.

In the relational database framework, queries are defined as generic and com-putable mapping from database instances to well-typed results. Three query paradigms have been developed, and these are Calculus , Algebra , Datalog .Ide-ally, we expect that every formula of a query language can serve as a query. If of k -tuples which satisfy the formula in the intended structure. In practice, not every formula can be accepted as a query as finite and effectively computable conditions required by database systems.

The notions of  X  X omain independence X  and  X  X afety X  have been developed to capture intuitive properties related to the finite query results criterion. Due to the different scale of volume of the W eb databases, the limited data access capabilities, the lack of concurrency control, and the dynamic nature of the Web, the notions of the above computability and safety are quite different from the finite relational model. For example, a query such as  X  X ind nodes with no  X 
Link ( y, x, ... )) } , which is not computable in the context of Web. The work of [1,3] has dealt this issue in the context of the Web.

Unlike relational calculus, playing the role of relational completeness ,thereare no well-accepted yardsticks for expressi veness of query languages in the context of the Web. The query languages for the Web attract much attention. Some languages are targeted at querying the Web as a whole, while others are aimed at semi-structured data and XML [4,5,6,7,8,9]. We consider complex value query languages as Web information is easily modeled in the complex value data model.
The main contributions of this paper are as follows:  X  We generalize the notions of local query to the Web context and show that  X  An algorithm for providing a sufficient condition for a calculus query being  X  We define the notion of  X  X ontinuous X  for Web queries and investigate its  X  We analyze the expressive power of Core XPath and XQuery fragments. The benefit of this study is that the results enhance our understanding of some fundamental aspects of querying the Web and could be used in practice for designing appropriate Web query languages.

The remainder of this paper is organized as follows. Section 2 briefly reviews basic concepts. Section 3 investigates th e local property of Web queries. Section 4 analyzes the expressive power of XPath and XQuery. Finally, we provide some conclusions in Section 5. The World Wide Web is a large, heterogeneous, distributed collection of Web objects connected by hyperlinks. It c an be viewed as a graph whose nodes are Web objects that are identified by a uniform resource locator (URL). We use the complex value data model as a model of the Web that captures the Web X  X  graph nature, and the semi-structured information it holds. Intuitively, the global Web database can be viewed as a finite complex value data structure over the fixed schema S which contains DB , Node and Link schemas.
 DB = { R 1 , ..., R n } Node = { id,title,subject,date,length,... } Link = { source, Ref ( label, destination, parameters ) } DB is a finite set of base relations containing the relevant data such as book-marks, local files, etc. It also contains semantic predicates that a Web query may apply. Relation Node specifies the set of Web objects. The Web objects may refer to Web pages, Web sites, or other objects on the Web. Complex value labels associated with them.
In relational databases, it is usually required that the query be generic , domain independent and computable .Let I be a Web instance. A Web query q over particular object in I , a subset of the Web node structure. The object o is the starting point (or source) of the query. The semantics for Web query follows the query q which is expressed as follows. where d is the domain of a Web instance I , i.e., the set of valid values in I .An isomorphism  X  is a mapping that is one-to-one, onto mapping from domain d to d . Each isomorphism is extended to Web instance in the obvious way. Definition 1. A Web query q is generic iff for any Web instance ( o , I )and each isomorphism  X  , q (  X  ( o ) , X  ( I )) =  X  ( q ( o, I )) .
 The above definition captures the data independence principle in databases. It means that the result only depends on the information in I and is independent of any particular encoding scheme.
 Definition 2. A Web query q is domain independent iff any Web instance I = ( d ; DB, Node, Link) and each pair of domains d 1 , d 2 , q ( d 1 ;DB,Node,Link) = q ( d 2 ;DB,Node,Link).
 We adopt the Web query model of [1]. As stated in that article, a Web machine is a Turing machine augmented with an oracle. It has two input tapes, an ordinary tape on which the input DB base relations are encoded, and an oracle tape on which the Node and Link relations are encoded. It also has an ordinary working tape and an oracle working tape. The result of the computation is written to the output tape in a standard append only manner. In the dynamic Web environment, we view a Web as an infinite sequence of Node and Link relation pairs. We review the notion of computable query proposed by Abiteboul and Vianu [2].
 Definition 3. A Web query q is finitely computable if there exists a Web ma-chine that computes on input tape enc( I ), halts and produces enc(q( I )) on the output tape.
 Definition 4. Aquery q is eventually computable if there exists a Web machine whose computation on input enc( I ) has the following properties:  X  The content of the output tape at each computation step forms a prefix of  X  For each tuple in enc(q( I )), its encoding occurs on the output tape after a We study queries on the Web structures. Informally, by locality of query in the finite relational model, we mean that in order to check if a tuple belongs to the result of a query, one has to look at a certain predetermined portion of the input. Now we would like to define local query in the Web scenario. Given the schema S S t is a k -ary tuple.
 Given a tuple t ,its r -neighborhood N r ( t ) is defined as a Web structure &lt; S ( t ) ,R | S R | definition of locality which is adopted from [10].
 Definition 5. Given a query  X  , its locality rank is the minimum number r  X  N such that, for every structure S and for every two vectors t 1 , t 2 of elements of is local if it has a finite locality rank.
 Intuitively, the above definition states that the result of a query  X  can be deter-to the definition, r is the minimum number for which the case holds. It implies that we only need to look at a small neighborhood of the arguments of the query.
As stated in [10], every first-order (relational calculus) query is local in the finite model setting.
 A Complex Value Calculus In the complex value data model, the calculus is a many-sorted calculus. Cal-culus variables may denote sets so the calculus will permit quantification over sets. The calculus, denoted CALC cv , is a strongly sorted extension of first order logic [11]. The vocabulary of the calculus language is defined as follows. 1. parentheses (, ); 2. logical connectors  X  ,  X  ,  X  ,  X  ; 3. quantifiers  X  ,  X  ; 4. equality =, membership  X  , and containment  X  symbols; 5. sorted predicate symbols; 6. sorted tuple functions &lt;&gt; , and sorted set functions {} . Definition 6. Terms of the complex value calculus language are defined as fol-lows: 1. complex value constants of some sort  X  ; 2. variables whose sorts can be inferred from the context, and 3. if x is a tuple variable and C is an attribute of x ,then x.C is a term. Definition 7. Atomic formulas (positive literals) are sorted expressions of the form where R is a relation predicate and t i , t ,and t are terms or function symbols with the obvious sort compatibility restrictions.
 Formulas are defined from atomic formulas using standard connectives and quantifiers.
 Example 1. The replacement of the second co mponent of tuples of relation R: { &lt; y.A  X  x.B = count ( y.B )) } ,where count is a function which computes cardinality of a set. The goal of this section is to investigate whether or not (eventually) computable Web queries possess local property. Informally, our results show that not every eventually computable query has loca l property even if it can be specified as a positive fragment of first order logic expression. We also show that if a query is not eventually computable, then it is not local, i.e., we cannot just look at  X  X mall neighborhoods X  of its arguments in order to check if a tuple belongs to the result of a query.

We will develop an algorithm for providing a sufficient condition for a calculus query being finitely computable. Then we show that every finitely computable query is local in the context of Web. 3.1 Safe Calculus Queries We adopt a syntactic condition, called range-restricted, that ensures calculus queries are finitely computable, given an input Web instance [2]. Based on the notion of range-restricted condition, we define safe formulas. A formula is safe to each variable have a finite proof.

As in complex value databases, we define the set of range-restricted variables of a formula using the following procedure, which returns either the symbol (which indicates that a quantified variable is not finitely computable) or the set of free has a finite proof; each variable may have finite set of computation values).
In the following algorithm, if several rules are applicable, the one which re-turns the largest set of safe-range variables is chosen. procedure range-restricted ( rr ) Input: a calculus formula  X  Output: a subset of the free variables of  X  or begin ( pred is a predicate in { = , = ,  X  ,  X  X  ) if for some parameterized query { x |  X  } occurring as a term in  X  , x  X  rr (  X  ) then return case  X  of R ( t ): if R  X  DB then rr (  X  )= free ( t ) Node ( a, x 1 , ..., x n ): rr (  X  )= free ( Node ) Link ( a, Ref ( y 1 , ..., y n )) : rr (  X  )= free ( Link )  X  ( x 1 , ..., x n )  X 
Link ( x i ,Ref ( y 1 , ..., y k )) : if  X  is safe then  X  ( x 1 , ..., x n )  X 
Node ( x i ,y 1 , ..., y k ): if  X  is safe then tpredt  X   X  : if  X  is safe and free ( t )  X  free (  X  ) tpredt : if free ( t )= rr ( t )  X   X  ( u )  X  X   X  2 ( v ): if  X  1 and  X  2 ( v )aresafe, v  X  u  X  x X  1 : if x  X  rr (  X  1 )  X   X  : rr (  X  )=  X  end  X   X  1  X  X   X  2 before the above algorithm is applied.

We say that a formula is safe if rr (  X  )= free (  X  ), and a query is safe if its associated formula is safe. Every safe Web query is finitely computable. However, characterizing the (largest) class of Web queries that is finitely computable is an open problem.
 Example 2. The query: Find the set of nodes which are directly linked by a node So it is finitely computable.
 We first investigate the relationship between the notion of locality and com-putability. The positive first order language FO + is eventually computable [2]. We show that local property of FO + that was conjectured to hold, fails in the context of Web scenario.

As stated in [2], FO + is eventually computable. There is a query in FO + which cannot be terminated in finite time. So we cannot just look a predetermined por-Fact : In the context of Web scenario, not every query expressed in FO + is local.
Now we consider safe calculus queries. A complex value calculus formula is strongly safe range , denoted CALC CV  X  , if it is safe and the inclusion predicate does not occur in it.
 Theorem 1. Every safe query expressed in first-order (or CALC CV  X  ) language is local.
 Proof Sketch . The answer of finitely computable query is always finite and computable by a halting Web machine. For each such query, it reads a finite input and produces a finite output. This aspect is equivalent to the first order query language in the finite model. So it is local.
 Example 3. Consider query: Find all node objects referencing the node object o. This query could be expressed as the following CALC calculus formula. It is eventually computable. However, i t cannot be effectively computed in finite time. So it is not a local query.
 Note that safe CALC cv may not be local, for example, transitive closure query canbeexpressedin CALC cv but it is not a local query.
 In the finite model, not every local query is generic or domain independent. For example, every first-order query is local [10] but not every firs-order query is domain independent.

For a graph G ,itsdegree deg ( G ) is the cardinality of the set of all possible in-and out-degrees that are realized in G .Aquery q is said to have the bounded for every structure S ,where k is the maximum degree in G .
 Corollary 1. Every finitely computable query has bounded degree property and all queries expressed in safe FO are local and domain independent in the context of the Web.
 Theorem 2. If a query is not eventually computable, then it is not local. Proof Sketch .If q is a query which is not eventually computable. Suppose that q is local, then for each tuple we only need to look at a predetermined portion of the input to check whether it belongs to the result. So this query would be eventually computable.
 Example 4. The query: Find all objects that do not belong to a cycle, is not eventually computable. So it is not local.
 We now explore the local property in the dynamic Web environment. As de-scribed in [1], we view a Web as an infinite sequence of Node and Link relation pairs. A dynamic Web machine is exactly like a Web machine, except that the or-acle can non-deterministically switch from one Node, Link pair to the next one in the sequence. There are three classes of q ueries in the dynamic Web environment: dynamic computable Web queries, dynamic semi-computable Web queries and eventually computable dynamic Web queries. Dynamic computable Web queries can be evaluated by a terminating program. Dynamic semi-computable Web queries could be evaluated by a terminating computation if the computation were sufficiently faster than the update rate. The following theorem shows that the first two classes are local.
 Theorem 3. Dynamic computable and dynamic semi-computable queries are local.
 Proof Sketch This class of Web queries consi sts of queries that could be evaluated by a terminating computation if the computation were sufficiently faster than the update rate. This class q ueries can be specified by first-order or complex value logic. So it is local.
 Now we define the notion of  X  X ontinuous X  for Web queries. First we define an  X  X pproximation X  of a database instance. Suppose that I 1 =( d 1 ; DB 1 , Node 1 , I define the least upper bound of a directed family of Web databases. Let I be a finite set of Web database instances. We say that I is directed iff it is nonempty and for any I 1 , I 2 ,thereexists I  X  X  such that I 1 I and I 2 I . For a directed define its least upper bound I def =( d ; DB, Node, Link ), where d is the union of the domains of all Web databases in I , DB = i DB i , Node = i Node i , Link = i Link i .
 Definition 8. Aquery q is called continuous iff for any directed set of Web database instances I , { q ( I ) | I  X  X } exists and q ( I )= { q ( I ) | I  X  X } . Here { q ( I ) | I  X  X } denotes the least upper bound of the results q ( I )with I  X  X  .

Intuitively, the concept of continuity captures the property that the result of a query depends only on a finite approximation of the database. During the computation we can inspect only a finite fragment of a potentially infinite input. Observation that not each local query is continuous.
 where p and q are relation predicates in DB . It is local. But it is not continuous as it is not monotonic.
 Example 6. Consider the query: Find all objects which are not referenced by any other object. We can express this query as follows. { query is not continuous. By definition, this query is not eventually computable. So it is not local by Theorem 2.

We end this section with a brief comments on safety, locality, computability expressed in FO or CALC cv  X  is finitely computable and domain independent. Locality and continuity are independent concepts but relevant. These two notions help us to inspect only a finite fragment of a potentially infinite input during any computation of a query. In this section, we check whether some languages for data exchange on the web, namely XPath and XQuery exhibit the locality property. XPath 1.0 is a variable free language designed to specify paths between nodes in XML documents. Core XPath [13] is the logical core of XPath 1.0 language that contains just what is needed to define paths in, and select nodes from an XML document tree. It is the fact that Core XPath without descendant axis relation (i.e., //) possesses local property.
 When evaluated at node n , it yields an answer set consisting of nodes n such that the axis relation goes from n to n , the node tag of n is node label ,andthe expression filter evaluates to true at n .
 Core XPath is not powerful enough to express every first-order definable path. We describe the language FO tree [14] which captures the class of first-order definable paths.
 Definition 9. The language FO tree is defined as follows:  X  if  X  ,  X  are formulas, then  X   X  ,  X   X   X  ,and  X  x X  are formulas. where R  X  and R  X  denote the descendant and the following sibling relation re-spectively.
 There exists a natural expansion of Core XPath, called Conditional XPath, which the first-order tree language FO tree does not possess the local property. We establish that XQuery and FO tree are not local, as follows.
 Theorem 4. Conditional XPath, FO tree and XQuery are not local.
 Proof Sketch. Conditional XPath is expressively complete for first-order defin-able paths [14]. Conditional XPath can express the reflexive and transitive closure  X  ditional XPath path expression. So FO tree is not local either. Note that XQuery supports (possibly recursive) user-defined functions and is capable of expressing transitive closure, which is known to be non-local.
 Our framework considers two kinds of query languages. One is targeted at query-ing the Web as a whole, while the other is aimed at semi-structured data and XML. However, our opinion is that feasible Web query languages should com-bine these two functions and build the latter technology on top of the framework proposed in Section 3. We studied the local property of comput able query in the context of Web. We have shown that all queries expressed in safe first order logic (or CALC CV  X  )are local. The problem of which fragments of FO tree and XQuery possessing local property is worthy of investigating and the expected results could be helpful for updating XML views and query processing in XQuery query engine.
 This work was supported by a grant (No. 418205) from the Research Grants Council of the Hong Kong Special Administrative Region, China.

The authors would like to thank Byron Koon Kau Choi for his fruitful discus-sions and helpful comments. Part of the work performed while the first author was visiting The Chinese University of Hong Kong.

