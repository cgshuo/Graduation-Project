 1. Introduction preferred in the first dimension and  X  X  X maller X  is preferred in the last two dimensions. imizing a function, say f , is equivalent to minimizing its reciprocal 1 tions of the basic concepts necessary to understand skyline queries as described in the sequel.
Definition 1 ( Dominance ). Given two d -dimensional points p  X  X  p if there is at least one dimension i with p i &lt; q i and for all the other dimensions j  X  i , we have p
Definition 2 ( Dominance in sub-space). Given two d -dimensional points p  X  X  p parameter k specifying the k -dimensional sub-space  X  k 6 is at least one dimension i in the k -dimensional sub-space with p and 1 6 j 6 d ) satisfies p j 6 q j .
 point q 2 U that dominates p .
 space, say k ss  X  k 6 d  X  , a point p 2 U is said to be a skyline in sub-space k inates p in sub-space k ss .
 under the second category which is more challenging.
 on the skyline query, for instance,  X  X  X ileage P 100 ; 000 km X  and  X  X  X rice constraint is specified as  X  X  X ileage P 100 ; 000 km X  and  X  X  X rice cess explicitly returns c 2 ; c 3 , and c 4 , and then determines c base first (it returns c 1 ; c 4 , and c 5 ); the constraint then filters these skylines to return only c the search space at query time.

In summary, contributions of the work described in this paper can be enumerated as follows: is commutative with the selection operator. able in traditional relational databases. employ the reported information to prune the search space. art approach.

In comparison with SUBSKY, our method has the following advantages: queries with constraints. 2. Our method is progressive whereas SUBSKY is not. 3. Our method is suitable for dynamic databases whereas SUBSKY (with multiple anchors) is not. this property.

Armed with the above enumerated contributions and advantages of our method, we proceed to describe its different aspects.
 2. Related work skyline problem in the database environment. Two main algorithms were proposed in [4]. results to obtain skylines of the whole data set. point is compared with the points in the candidate set and the candidate set is updated accordingly. is progressive but still need to scan the whole database.
 lists change under different sub-spaces.
 BBS is only suitable for low-dimensional spaces.
 based dominance test as done by BBS . The Z-address has 2 desirable properties: order of Z -addresses in the ZB -tree, dominating points are always placed before dominated points. stronger pruning power.
 low.
 could be roughly classified into two categories: 1. Pre-materializing the sub-space skylines, e.g., [29,39,38,30] ; 2. Using index, e.g., [33].
 ing, pre-materialization methods are storage-inefficient because a d -dimensional space may have 2 databases.
 f  X  p  X  X  MAX i  X  1 ; ... ; d  X  1 p  X  i  X  , where p  X  i denotes the i th coordinate of point p ; f  X  p  X  is the L queried sub-space) if f  X  p  X  &lt; MIN i 2 SUB  X  1 p sky  X  i  X  , where SUB specifies the queried sub-space and p rithm also maintains the current set of candidate skyline points and the corresponding largest MIN of the skyline points and the search efficiency, it redefined f  X  p  X  to be the L satisfied.

The SUBSKY method has the following disadvantages: 1. The stop condition compares the maximum value (the f -value) to the minimum value  X  MIN dynamic databases because the anchors are selected by clustering and once selected, the anchors are never changed no matter how the database is updated. disadvantage when real-time and time critical applications are considered. are the k skylines that maximize the number of points being dominated. tion [43], Mindolin and Chomicki [50] studied the relative importance of skyline attributes. empty. 3. Skyline query with constraints formalize the description.
 a constant). Thus, skyline queries with constraints could be expressed by T then apply on the constraints on them. On the other hand, constrained skyline queries report S whole data set. So, it is obvious that in general S x  X  T expensive; in particular evaluating T y  X  S x  X  U  X  X  is more expensive than evaluating S only consider conjunctive constraints, i.e., constraints consisting of conjunction of conditions, e.g.,  X  X  y disjunctive constraints, like  X  X  y 1 &lt; c 1 OR y 2 &gt; c
T Lemma 1. T y  X  S x  X  U  X  X  # S x  X  T y  X  U  X  X  .

Proof. Assume there exists a point q 2 T y  X  S x  X  U  X  X  , but q R S conditions in T y , we have q 2 T y  X  U  X  . Thus, q must be dominated by some point in T q R S x  X  U  X  ; a contradiction to q 2 T y  X  S x  X  U  X  X  . Therefore, for any point q 2 T
S  X  T y  X  U  X  X  . h
Lemma 2. If Y # X and Y only has  X  X  6  X  selection conditions, then S
Proof 1. From Lemma 1 , we have T y  X  S x  X  U  X  X  # S x  X  T y  X  U  X  X  . 2. Let p be an arbitrary point in S x  X  T y  X  U  X  X  , i.e., p is a skyline of T (a) p satisfies all the selection conditions of T y . (b) Since Y only has  X  X  6  X  conditions and Y # X , no point in U T (c) As p is a skyline of T y  X  U  X  in sub-space X , no point in T p 2 T y  X  S x  X  U  X  X  .As p is arbitrarily selected, we have proved that S
Combining (1) and (2), we have S x  X  T y  X  U  X  X  X  T y  X  S x following Theorem 1 only holds for conjunctive constraints.

Theorem 1. S x  X  T y  X  U  X  X  X  T y  X  S x  X  U  X  X  if and only if Y # X and Y only has  X  X  Proof. The proof for the  X  X  X f X  direction follows from Lemma 2 .

Next we will prove the  X  X  X nly if X  direction. As Lemma 1 shows that T the conditions is violated (i.e., Y X  X  / or Y has  X  X  P  X  selection condition), there may exist point p 2 S p R T y  X  S x  X  U  X  X  .
T y  X  U  X  . For a point p 2 S x  X  T y  X  U  X  X  , there may exist a point q 2 U T
U . Thus, we have p R T y  X  S x  X  U  X  X  because all the points in T 2. If there exist one dimension y 2 Y and y R X ; since y R X , the points that are excluded from T bound on sub-space X . That is, there may exist a point q 2 U T skyline of U ,so p R T y  X  S x  X  U  X  X  . h conditions are met, we may evaluate S x  X  T y  X  U  X  X  instead of T advantage.
 the selection conditions in Y do not satisfy Theorem 1 , we may divide the selection conditions into 2 parts Y
Y contains the selection conditions satisfying Theorem 1 and Y T  X  S X  X  T Y 1  X  X  . 4. Algorithm for sub-space skyline queries with constraints signed an index specifically for skyline queries, we just make use of the B
Here we assume that all the dimensions are numerical and each dimension is indexed by a B relational database management systems.
 space skyline queries with constraints in an equivalent form. Given a skyline query on sub-space X with  X  X  space Y # X , where the constraint is expressed in conjunctive form as: y to q) on sub-space Y . The following discussion is based on this equivalent form. gives the smallest number. For example, for 3-dimensional space and a given q  X  X  q dimension shows that 30% of the points have the first coordinate not larger than q sion shows that 60% of the points have the second coordinate not larger than q shows that 10% of the points have the third coordinate not larger than q query optimization.
 understanding, we will introduce the algorithm in two stages: 1. Depth-first search of the index to filter a candidate skyline set. 2. Verification of the candidates to produce the answer set.
 it is worth noting that the basic symbols used are listed in Table 2 . 4.1. Depth-first search with best dominating point . We search the index in depth-first manner.

Definition 5 ( Best dominating point (BDP) ). Let G be a group of d -dimensional points, and let p p 2 G ; define L i  X  Min f p i j 8 p 2 G g , for i  X  1 ; 2 ; ... ; d . That is, L does not exist a point that is dominated by L and can dominate G .
 this way, we can substantially reduce the search space without having to visit every point. contains the 3-dimensional points ( p 1 to p 6 ) listed in the Table 3 . sub-tree rooted at c is pruned without further search.
 The process for this stage is depicted in Algorithm 1.

Algorithm 1 1: S : a stack used for depth-first index search; R : the root of the index 2: M = q ( v )/ * q ( v ) denotes q  X  X  coordinate on the selected dimension 3: S.push ( R ) 4: while  X  S  X  / ) do 5: N  X  S . popup () 6: if ( N is non-leaf node) then 7: for (each child-node c of N , visited in right-to-left order) do 8: if ( c : key 6 M and ( c .BDP dominates or is equal to q in sub-space Y )) then 9: S . push ( c ) 10: end if 11: end for 12: else //deal with leaf node 13: for (each point p 2 N ) do 14: if ( p dominates or is equal to q in sub-space Y ) then 15: insert p to candidate set W 16: end if 17: end for 18: end if 19: end while niques to speedup the verification process. 4.2. Skyline verification
As described in Section 4.1, we search the index (for the selected dimension points are visited (if not pruned) in non-descending order of values on dimension to check if a point would be dominated by points visited before it. However, the B points with different values on dimension v . For a bunch of points with the same value on dimension sub-spaces.

For the verification process, we maintain the following information: 1. A candidate set W in a queue; 2. The value of function T  X  W  X  X  max f min f w i j i 2 X gj 8 w 2 W g ; 3. The value of function F  X  W  X  X  min f max f w i j i 2 X gj 8 w 2 W g , where w 4. A point f 2 W with max  X  f  X  X  F  X  w  X  ; candidate set w contains the points listed in Table 4 , where attribute A is the indexed dimension.
At this time, T  X  W  X  X  0 : 4 (the value of p 4  X  X  attribute B ) and F  X  W  X  X  0 : 6 (the value of p when a point p is added to W ; T  X  w  X  ; F  X  w  X  and f are updated as follows: If  X  min  X  p  X  &gt; T  X  W  X  X  If  X  max  X  p  X  &lt; F  X  W  X  X  where min ( max ) gives the smallest (largest) coordinates of p in sub-space X . point in w : 1. Compare the largest coordinate of p , denoted by max ( p ), with T  X  W  X  ;if max  X  p  X  dominates in w points that share the same value on dimension skyline.
 satisfied.
 by the index. In Example 3 , when point p 4 is visited, points p other words, our method is progressive.
 it is possible to have the former condition satisfied when the latter condition is not satisfied. The complete (index search and verification) process is described in Algorithm
Algorithm 2. Subspace_skyline( q , X ) 2: Use the percentile to decide on the index to search, say, for dimension 3: M = q ( v )/ * q ( v ) denotes q  X  X  coordinate on dimension 4: R = the root of the index 5: W  X  / ; T  X  W  X  X 1 ; F  X  W  X  X  X 1 6: S.push ( R ) 7: while  X  S  X  /  X  do 8: N  X  S . popup () 9: if ( N is non-leaf node) then 10: for (each child-node c of N , visited in right-to-left order) do 12: S . push ( c ) 13: end if 14: end for 15: else //deal with leaf node 16: for (each point p 2 N ) do 17: report the points in w that have value smaller than p on dimension 18: if ( p dominates or is equal to q in sub-space Y ) then 19: if  X  max  X  p  X  6 T  X  W  X  X  then 20: W.insert (p)//insert p to w 21: check if p dominates the points in w that share the same value as p on dimension 22: update T  X  W  X  ; F  X  W  X  and f 23: else 24: if  X  min  X  p  X  &gt; F  X  W  X  X  then 25: break 26: else 27: compare p to each point in W to update W , T  X  W  X  ; F  X  W  X  and f 28: end if 29: end if 30: end if 31: end for 32: end if 33: end while 34: report the points in W that have not been reported 4.3. Correctness of the algorithm
Theorem 2. Given a database U of d-dimensional points, a k-dimensional(k cated otherwise.
 do not dominate (and are not equal to) q or those that are not skylines. not dominate (and are not equal to) q are pruned  X  ( we mark this as ( * )). ( *** )).

Now, we have three marked facts: ( * ) shows that all points in W dominate (or are equal to) q ; ( ** ) shows that all skylines dominating (or equal to) q are in W ; ( *** ) shows that all points in W are incomparable; Simply combining the above three statements is not enough to guarantee that W only contains skylines.  X ( we mark this as ( **** )).
 equal to) q . h 5. General sub-space skyline queries some general case skyline queries using information gathered from the results of previous queries.
Lemma 3. Given two sub-spaces V and W with V # W (i.e., V is sub-space of W), and let M that skylines of V and W have on dimension i, respectively, we have M
Proof. Assume there exists a dimension i 2 V such that M v skylines of V and W have on dimension i . Let P be the skyline of V that has value on dimension i equals to M the skyline of W that has value on dimension i equals to M
M i 2 V , we have M v  X  i  X  6 M w  X  i  X  . h once the skylines of sub-space W are computed, we record the largest value on each dimension of the skylines, M i 2 V could be used to speedup the query processing. First, compare the recorded M find their positions and pick the index for the dimension along which M
M to visit points with values on dimension i not larger than M there exist M -values of W 1 and W 2 , such that V # W 1 and V # W
M 1  X  i  X  and M w 2  X  i  X  ; the selected M -values are used to pick the index and form the query point. Next we will compare our method with SUBSKY on an example in order to show that SUBSKY does not always work. defined in the SUBSKY paper [33]; here, f  X  p  X  X  max i 2f x ; y ; z g skylines, U  X  max f min i 2f x ; y g  X  1 p sky  X  i  X j 8 p 1. S  X f p 3 g ; U  X  0 : 5 2. S  X f p 4 g ; U  X  0 : 5 because p 3 is dominated by p 4 3. S  X f p 4 ; p 1 g ; U  X  0 : 5 4. S  X  { p 4 ; p 1 }, U  X  0 : 5 because p 6 is dominated by p 5. S  X f p 4 ; p 1 g ; U  X  0 : 5 because p 5 is dominated by p 6. S  X f p 4 ; p 1 g ; U  X  0 : 5 because p 2 is dominated by p 7. S  X f p 4 ; p 1 g ; U  X  0 : 5 because p 8 is dominated by p 8. S  X f p 4 ; p 1 g ; U  X  0 : 5 because p 7 is dominated by Sp skylines.
 puted. In this example, the skylines of f x ; y ; z g are f p ble, i.e., the largest values on each dimension of the skylines.

M 0.5 0.5 0.4
Using the above example, the stop condition of SUBSKY is:
For ease of discussion, we rewrite the stop condition in its equivalent form as: example data set, SUBSKY is not guaranteed to work. 6. Maintaining the M -table
We still need to deal with the following problems for maintaining the M -table: 1. Given a d -dimensional space, the number of different non-empty sub-spaces is 2 the M -values would be recorded.
M -values. We need a method to maintain the M -table when insertion/deletion occurs. 6.1. Update the M-table after skyline queries ory space to hold the M -table is fixed and not large enough to contain the M -values of all sub-spaces. could be minimized by replacing locally least popular values, i.e., by treating each diverse group independently. 6.2. Maintain the M-values after updating the database deletion invalidates an M -value which can no longer be used as upper-bound. (b) If p i 6 M V  X  i  X  ; 8 i 2 V , then P does not invalidate the M -values for sub-space V ; (c) If 9 i 2 V with p i &lt; M V  X  i  X  and 9 j 2 V with p to limit the search space. (b) Otherwise, P invalidates the M -values of V . The invalidated M -values are removed from the M -table. 7. Conclusions some interesting results.

References
