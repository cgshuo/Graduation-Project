 1. Introduction
Much of the power of a database management system stems from the presence of a schema that describes the structure of the database. When the data is versioned, a schema helps even more, because it expresses the commonality among the different versions, as well as indicating which parts of the data can change, and how.
The schema is the solid ground upon which the data structures stand. But when the schema itself is versioned, there is no solid ground. How schema versioning is supported makes the difference between a fluid motion between versions and floundering in quicksand.

An increasing amount of data is being published in XML. The W3C XML Schema recommendation defines the structure and data types for XML documents [15] . XML Schema lacks explicit support for time-varying XML documents. We previously proposed a data model and architecture, called s XSchema [9] , for creating a temporal schema from a base schema, a temporal annotation, and a physical annotation.
The annotations specify which portion(s) of an XML document can vary over time, how the document can change, and where timestamps should be placed. The advantage of using annotations to denote the time-vary-ing aspects is that logical and physical data independence for temporal schemas can be achieved while remain-ing fully compatible with both existing XML Schema documents and the XML Schema recommendation.
In this paper we extend s XSchema to also support schema versioning . In doing so, we leverage both con-ventional XML Schema and related tools (principally, validator parsers), as well as s V versioning.

In a dynamic environment, as organizational contexts and user requirements change, it is natural to see consequent changes in application schemas. Schema designers often edit their schemas, refining and adding element and attribute types. As an example, the Botanic Garden and Botanical Museum in Berlin X  X ahlem (BGBM 1 ) maintains a repository of XML Schemas 2 related to index terms, keywords, biodiversity data about specimens and observations, meta-level data about collections, organizations, and networks, and various wrapper and configuration files. Most of these XML schemas have had multiple versions over the last 2 X 3 years. The BioCASE Collection Profile is up to version 1.24; the Access to Biological Collection Data is up to version 2.06. The Pharmacogenetics Knowledge Base (PharmGKB clinical information collected from ongoing pharmacogenetic studies. X  X  The evolution of its schema has reached version 4.0. 4
One challenge is that in this potential quicksand, anything can change, and thus must be versioned: the snapshot documents, the base schema, the temporal annotations, the physical annotations, the schema docu-ments included by these documents, even the schemas of these schema components. And, because the physical annotations can change, the concrete representation within a temporal XML document can vary. How can one even define validation in such a fluid environment? 2. Approach
There are several key ideas to our solution. First, a temporal bundle (or simply, a bundle) serves the anal-ogous purpose of an XML Schema document for a static document. So we have a single point of reference for the schema of a temporal document. Of course, the bundle may itself contain versions within it. That means that the temporal documents it references must also have associated bundles as their schemas. The bundle is all the user needs for describing the temporal document, just as the conventional XML Schema is all the user needs for describing an XML document.

Second, as with quicksand, as you venture outward, eventually you reach solid ground. So eventually you reach a bundle containing no versions, or else you reach a static XML Schema document.

The third key idea, which we call schema-constant periods , first appeared in a paper by one of the authors on temporal aggregation [21] . It is possible, even with versioned schemas having themselves versioned schemas, to identify contiguous periods of time when there are no schema changes, anywhere . Now, during such schema-constant periods the data may be (and probably is) versioned, but at least you have a fixed base schema and fixed temporal annotations, each of which has a fixed schema. And since the physical annotations are fixed, the representation is also fixed, so it is possible to read and interpret the temporal document during that schema-constant period, and even to validate that portion of the document. (This is just the situation discussed in our previous papers, of a single schema and versions of the data.) So a general temporal document can be viewed as a sequence of data-varying documents, each over a single schema-constant period. Since we can validate within each schema-constant period, given the approaches elaborated on earlier, all we have to do is validate across schema changes.

The final key idea first appeared in the original presentation of s XSchema [9] : the representational schema (a) is derivable solely from information in the bundle, (b) can be designed to enable some of the temporal integrity constraints to be checked by a conventional validator, and (c) can be computed and cached within s V ALIDATOR , completely unbeknown to the user.
 most of the approach.

In the remainder of this paper, we introduce the architecture through a running example, then describe how the validator can be extended to validate documents in this seemingly precarious situation of data that changes over time, while its schema and even its representation are also changing over time.

All times mentioned in this paper are from the transaction time dimension [20] , though s XSchema also sup-ports valid time for data versioning. While schema versioning has been considered in the context of valid time [8] , doing so is quite complex and in our opinion not worth this complexity. Thus in s XSchema schemas vary and are versioned only over transaction time.

We also note that the emphasis here is on capturing a time-varying schema and validating documents against such a schema. Our approach applies to unmanaged environments, where each schema is originally in a separate document paired with one or more data documents at particular points of time. We also support managed environments, where a schema editor would be used to maintain the schema(s), with the schema changes captured in a temporal document. How the schema changes are made, or what kinds of schema evo-lution operations are provided, are beyond the scope of this paper. 3. Example and architecture
The P HARM GKB XML schema was designed conventionally, without an architecture that supports schema versioning. As new releases of this schema were developed (on May 12, 2004 Version 4.0 was released), all
XML documents that were instances of this schema were rendered invalid, with the maintainers responsible for updating their XML documents. The architecture proposed here retains past data and past schemas, while always allowing the current data and schema to be extracted, for tools that are not schema-versioning aware.
While our architecture does not limit the kinds of changes a designer can make to a schema, typically as a schema is edited, each new version will add to or refine an existing version rather than entirely replace it. Prior to Version 3.2, the h ExperimentClass i element of P mentioned the unique identifier of the sample set, which was moved to the top of the document, with a phar-mgkbId attribute. (The AccessionObjectClass includes an attribute pharmgkbId to specify this unique identifier, not shown here.) In Version 4.0 an h ExperimentClass i can now cross-reference more than one h sampleSet i (cf. Fig. 3 : note unbounded for maxOccurs ). Additionally, though not shown in the figure, a h sampleSet i is now a set of h sample i s instead of a set of h subject i s (logically!).
Now let us examine how this could have been done using s XSchema. (Our emphasis in this paper is on how to validate a time-varying document against a time-varying schema. Hence, we only describe s XSchema to the point where we can explain validation. For more discussion of s XSchema per se, please consult prior papers [9,11] .)
Fig. 4 illustrates the architecture of s XSchema. This figure is central to our approach, so we describe it in detail and illustrate it with the P HARM GKB schema. We note that although the architecture has many com-ponents, only those components which are shaded in the figure are specific to an individual time-varying doc-ument and need to be supplied by a user. We also note that to this point, the schemas (boxes 4, 5, 6, and 7) are static. We will later relax this assumption.
 The designer starts with the base schema (box 4). In the case of P It xsd:import s and xsd:include s other schemas such as  X  X  http://www.pharmgkb.org/schema/ sequence.xsd  X  X , which itself xsd:include s experiment.xsd . The designer annotates the base schema with temporal annotations (box 6). The temporal annotations together with the base schema form the logical schema . The temporal annotations specify a variety of characteristics such as whether an element or attribute varies over valid time or transaction time, whether its lifetime is described as a continuous state or a single event, whether the element itself may appear at certain times (and not at others), and whether its content changes. Elements that are not described as time-varying are static and must have the same content and exis-tence across every XML document in box 8.

The schema for the temporal annotations document is given by TXSchema (box 2), which in turn utilizes temporal values defined in a short XML Schema TVSchema included in the TXSchema. (Due to space lim-itations, we will not describe in detail these annotations X  X ore detail can be found elsewhere [9]  X  X ut it should be clear what aspects are specified there.)
The next design step is to create the physical annotations (box 7). In general, the physical annotations spec-ify the timestamp representation options chosen by the user. Physical annotations may also be nested, inher-iting the specified attributes from their parent; these values can be overridden in the child element. Physical annotations play two important roles. They help to define where in the document tree the physical timestamps will be placed (versioning level). The location of timestamps is largely independent of which components vary over time. Timestamps can be located either on time-varying components (as specified by the temporal anno-tations) or somewhere above such components. Two documents with the same logical information will look very different if we change the location of their physical timestamps. The physical annotations also define the kind of timestamp (for both valid time and transaction time). Changing an aspect of even one timestamp can make a big difference in the representation. The schema for the physical annotations document is PXSchema (box 3).
 s XSchema supplies a default set of physical annotations. (Again, space limitations do not allow us to describe these annotations in detail, for more see [9] .) We emphasize that our focus is on capturing relevant challenging. Also, since the temporal and physical annotations are orthogonal and serve two separate goals, we choose to maintain them independently. A user can change where the timestamps are located, independent of specifying the temporal characteristics of a particular element. In the future, when software environments for managing changes to XML files over time are available, the user could specify temporal and physical anno-tations for an element together (by annotating a particular element to be temporal and also specifying that a timestamp should be located at that element), but these would remain two distinct aspects from a conceptual standpoint.

The base schema, temporal annotations, and physical annotations, which are all XML documents, are ref-erenced by a temporal bundle . An example bundle for P HARM provides information about how timestamps are formatted; here we use XML Schema date s, but other for-mats are possible, e.g., SQL datetimes. A h bundleSequence i contains a sequence of h schemaAnnota-tion i elements, each referencing a snapshot (base) schema, a temporal annotation, and a physical annotation. Note that any of these three documents referenced by a h schemaAnnotation i element can include other schemas. For example, a base schema, root.xsd , can include a gene sequence schema, sequence.xsd , which itself includes a schema for experiment data, experiment.xsd .

At this point we can contend with time-varying data. Box 8 of the architecture shows a sequence of non-temporal documents, each an instance of the P HARM GKB schema ( root.xsd ). The temporal XML document (box 9) is essentially a timestamped representation of this sequence of non-temporal XML data files (box 8).
The timestamps are based on the characteristics defined in the temporal and physical annotations (boxes 6 and 7). The sequence of non-temporal documents can be S QUASH is the representational document rep.xml ), with its XML schema shown as box 10, generated by S
CHEMA M APPER from information in the temporal bundle. The schema of the temporal document is its associated representational schema (an XML Schema document). The tools are described in greater detail elsewhere [9] .

The defining schema of the temporal document (box 9) is the temporal bundle ( bundle.xml ). However, the conventional XML validator does not understand time-varying documents nor their schema, so we have developed s V ALIDATOR , a stand-in for the regular validator (see Fig. 5 ). Within s V divided into two separate analyses. In one analysis, the conventional validator is applied to the document to check the temporal document against the representational schema. That schema is generated internally by the S CHEMA M APPER , then handed to the conventional validator. However, there are limitations of XML
Schema in checking temporal constraints. For example, a regular XML Schema validating parser has no way of checking something as basic as  X  X  X he time boundaries of a parent element must encompass those of its child. X  X  These temporal checks are implemented during a second analysis by the time-varying data checker, operating over the temporal document. s V ALIDATOR , by checking the temporal data, effectively checks the non-temporal constraints specified by the base schema simultaneously on all the instances of the non-temporal data (box 8), as well as the constraints between snapshots, which cannot be expressed in a conventional schema. To reiterate, using the conventional approach, the user would start with the daunting task of manually generating a representational schema (box 10); our proposed approach is to have the user add two sets of annotations to a base schema, with the rep-resentational schema automatically generated. 4. Supporting versioned schemas We now generalize the architecture to also support versioned schemas. As noted previously, the P
HARM GKB schema has undergone a series of changes. This implies that box 4 is actually a sequence of base schemas, three of which are excerpted in Figs. 1 X 3 . Not only do these base schemas change over time, but the schemas included by them (e.g., sequence.xsd , experiment.xsd ) can vary over time. Similarly, the tem-poral annotations (box 6) and those annotations included by them and the physical annotations (box 7) and those annotations included by them all can vary over time, resulting in multiple versions.
This versioning is handled by timestamping the h schemaAnnotation i element in the bundle. To each such element is added a h tTime i element that specifies when that annotation element became applicable.
So our P HARM GKB schema would have many annotation elements, with version 3.1 becoming applicable on April 25, 2003, version 3.2 on May 21, 2003, and version 4.0 on May 12, 2004.

The schema annotation elements reference individual base schemas. One approach is to have a different document (file) for each version, similar to what is shown in box 8. So we might have files named root.4.25.03.xsd , etc., or perhaps root.3.1.xsd , etc. Each of these files would reference subsidiary sche-mas, such as sequence.v3.1.xml.xsd or experiment.4.25.03.xsd . As one can imagine, this becomes rather cumbersome. The problem with this approach is that whenever a subsidiary schema changes, a new ver-sion is produced, with its own URI, which requires the referencing schema document to be changed. So a new version of experiment.xsd requires a new version of sequence.xsd , which requires a new version of root.xsd .

While this approach is allowed, s XSchema also permits temporal schemas , in place of multiple versions of conventional schemas. Consider the sequence of root schemas: root.1.0.xsd , root.2.0.xsd , ... We write a simple temporal bundle for these and invoke the S QUASH utility, which produces a single temporal document, tv _ snapshot.xml which is then referenced by multiple schema annotation elements. Similarly, we use S QUASH to generate temporal schemas for sequence.xsd and experiment.xsd .

This rather involved state of affairs, with time-varying documents and time-varying schemas, is illustrated given on the left arm of the  X  X  X  X  X  (for example, for S CHEMA the input is the logical schema document, bundle.xml ), the name of the translator is given at the base of the representational schema, rep.xsd ). The name of these diagrams was to the best of our knowledge given by McKeeman, Horning, and Wortman in their classic compiler book [17] .

We extend these diagrams to allow multiple inputs, which unfortunately complicates them somewhat. As shown in Fig. 7 ,S QUASH takes both a bundle and a sequence of snapshot documents and produces a temporal document, and U NSQUASH does just the opposite (this is illustrated for the temporal annotations, which are S QUASH ed into a single tv _ temp _ anno.xml document, then U timeslices).

In this figure we show a bundle ( bundle.xml , right in the middle of the figure, with the arrows pointing left) referencing two temporal schemas, one of the base schema and one of the physical annotations; the bun-dle also references several temporal annotation documents. Note that the base schema for the base schema (!) is XSchema _ bundle.xml , which has as its base schema XMLSchema.xsd . 5. Validating against a time-varying schema To validate a time-varying document associated with a time-varying schema, s V ventional validator to the document, using the representational schema produced by S
Fig. 8 ). It then determines the times when the schema changes, thus determining the periods when the schema is constant, termed the schema-constant periods . These periods will be non-overlapping and continuous; between the periods are schema-change walls . For each such period, the time-varying data checker is invoked to check the temporal integrity constraints over the time-varying data, with the single base schema, temporal annotation, and physical annotation.

During this process, s V ALIDATOR treats each URI it encounters as the specification of a temporal timeslice operation to select the appropriate version. The timeslice is as of the time of the document or context that contains the URI. For example, consider the excerpt in Fig. 9 . root.xsd is a time-varying document, con-taining several schema versions. In this context, s V ALIDATOR 2003 X  X  to extract a single version of the root schema. To do so, it calls U (b) the temporal document, and (c) a timestamp. It passes the same information for all the schemas included by that schema, such as sequence and ExperimentClass . The underlying semantics ensures that at any point in time, there is a single base schema, a single temporal annotation, and a single physical annotation.
Of course, one can carry this further. Because the base schema is versioned, it is associated with a temporal bundle which could itself have multiple schema annotation elements. s V so that at any point in time, there is a single schema in effect.
 Let us examine how s V ALIDATOR depicted in Fig. 8 could handle the versioned schema for P Recall that prior to Version 3.2, the h ExperimentClass i element of P pleSet i elements (cf. Fig. 1 ). In Version 3.2, this was replaced with a h
Fig. 2 ), that just mentioned the unique identifier of the sample set, which was moved to the top of the docu-ment, with a pharmgkbId attribute.
This change is reflected in two versions of experiment.xsd , one for version 3.1 and one for version 3.2, as well as moving the definition of the h sampleSet i element to a new sampleset.xsd subschema docu-ment and changing root.xsd to also include the new sampleset subschema. We could write a very short experimentBundle.xml , then use S QUASH to create a temporal experiment.xml schema, and do the same for the root schema.
 What do we do with an actual XML document (such as 3.1.xml , version 3.1 of P schema is the original root schema ( root.3.1.xsd )? We take each instance of the h sampleSet i element out of its enclosing h ExperimentClass i element and move it up to beneath the root of the document (the h pharmgkb i element), replacing it with a h sampleSetXref i element. Then we take the two documents, the first using the old schema ( 3.1.xml ) and the second the updated document ( 3.2.xml ) and S into a temporal document ( rep.xml ). (Even better, we could use a temporally aware XML editor to make these changes to the document. Such an editor would output the temporal document. This is the managed environment mentioned earlier.)
What would the representational schema look like for this temporal document? We could see that schema directly by running S CHEMA M APPER on our bundle. A portion of the temporal document is shown in Fig. 10 .
Note that every change of the base schema (which is what occurred here) or in the physical annotation results in a new h tv _ version _ i i element within the time-varying root (with these names being generated by S
MA M APPER ). The conventional validator can thus check to ensure that prior to the schema change on May 25, h
ExperimentClass i elements contained an h sampleSet i element, and afterward, an h element. (S QUASH will ensure that the appropriate h version i is used in the generated temporal document; s V ALIDATOR will also check this.)
Continuing with the example, in Version 4.0 an h ExperimentClass i can now cross-reference more than one h sampleSet i (cf. Fig. 3 : note unbounded for maxOccurs ). Additionally, a h sampleSet i is now a set of h sample i instead of a set of h subject i . The latter change can be checked by the conventional validator because such sub-elements would themselves be enclosed in a new h tv _ version _ 3 i element. The former change, however, possibly cannot be checked by the conventional validator.

A temporal constraint is termed as sequenced with respect to a similar snapshot constraint in the schema document, if the semantics of the temporal constraint can be expressed as the semantics of the snapshot con-straint applied at each point in time [19] . Given a snapshot XML Schema constraint, we can define the cor-responding temporal semantics in s XSchema in terms of a sequenced constraint. In the earlier schema, with a maxOccurs of 1, the temporal semantics of this integrity constraint is the sequenced constraint,  X  X  at every point in time , there can be a maximum of one such element. X  X  However, depending on the physical annotations, it may be that the h sampleSet i element is itself versioned, which implies that an h ExperimentClass i ele-ment could have several h sampleSet i elements, each resident at non-overlapping periods, so that at any one time, there would not be more than one. In this case, this integrity constraint would need to be checked sep-arately by the time-varying data checker component in s V integrity constraint (from the bundle), and thus could check for a maximum of one only before Version 4.0 went into effect. In some cases, the representational schema can be designed such that many sequenced con-straints can be checked directly by the conventional validator. s V ALIDATOR is a direct replacement for the conventional validator. If it is provided with a conventional schema and a conventional XML document (such as root.1.0.xsd and 1.0.xml ), it simply invokes the conventional validator. The U NSQUASH tool is similarly configured. If it is given a temporal document (e.g., rep.xml ) that references a temporal bundle (versioned or not; here, bundle.xml ), it will produce a conventional XML document by taking a timeslice at now ( 4.0.xml ); this conventional document will refer-ence a conventional XML Schema ( root.4.0.xsd ), formed by slicing the bundle at now .IfU given a static XML document, it simply returns that document. Hence U any conventional XML tools. In this way, temporal upward compatibility [2] is ensured.

This arrangement works very well. However, there are four remaining aspects that do not show up with time-varying data, but rather are unique to versioned schemas: (1) an evolving definition of keys, (2) accom-modating gaps in lifetimes, (3) the semantics of mixed data and schema changes within a single transaction, and (4) checking non-sequenced constraints across schema changes. We examine each in turn. 6. Accommodating evolving keys
When documents vary over time, it is important to identify which elements in successive snapshots are in actuality the same item , An item is an element that exists in one or more snapshots. Each change to an item creates a new version of that item. We refer to the process of associating elements that persist across various snapshots as gluing the elements. So the elements are glued to create an item. S time-varying data checker within s V ALIDATOR must also on occasion glue elements.

Determining which elements should be glued into an item depends on two factors: the type of the element, and how the gluing is accomplished [11] .

When a schema-change wall is encountered, items across the wall need to be associated. This process is called cross-wall gluing ,or bridging . Fig. 11 depicts the concepts of gluing and bridging.
In this figure, individual elements in individual versions of an XML document are depicted as small circles in the center of the figure. Here we see six elements, three of which are determined to be versions of the same item (A1) and three of which are determined to be versions of another item (A2). The wall indicates that the schema was changed between the third and fourth version of the document.

Gluing uses the item identifier to associate the first three elements with an item and likewise the second three elements. Bridging determines that the element, that is version 3 of item A1 and the element, that is ver-sion 1 of item A2 are actually versions of the same item, item A. So in fact item A has six versions, the three elements before the schema change (indicated in the figure as the wall) and the three elements after the schema change. Gluing and bridging occur in different stages within the validator; both conspire to realize an item across schema changes, which is the first step in checking the temporal constraints associated with that item X  X  definition in the schema.
 What is relevant for our purposes here is that each item identifier is specified in the temporal annotations.
Usually the item identifier is the same as the (snapshot) key of the corresponding element type [5] as given in the base schema. The identifier is used by s V ALIDATOR to extract the items from the temporal document and to check the temporal constraints on those items.

What if either the snapshot key (specified in the base schema) upon which an item identifier is defined, or if quicksand. Even worse is when the underlying element type of an item changes. For example, in Version 3.3 of P
HARM GKB schema, the h assay i element was replaced with h sequencingAssay i and h genotypingAs-say i elements. An item that was a particular h assay i element before the schema change could be associated with a particular h sequencingAssay i element in the snapshot document associated with the latter schema.
Our solution is to put in the h schemaAnnotation i element, which signals a change in some aspect of the schema, an h itemIdentifierCorrespondence i element, specifying how old item identifiers are to be mapped to new item identifiers. This element has four attributes: oldRef , a string naming an item that appears in the old schema, newRef , a string naming an item that appears in the new schema, mappingType , an XML Schema enumeration, and optionally a mappingLocation , which is a URI. We have defined four mapping types. (1) useNew : The new identifier must also be present in the old element. (2) useOld : The old identifier must also be present in the new element. (3) useBoth : An attribute X  X  name is changed, but its value is not. (4) replace : Use an externally defined mapping.

This is best described with an example. Say that in March the item identifier is the assayNumber attribute of the h assay i element. In May, this attribute is renamed assayID ; we specify a mapping type of useBoth .
In May, the item identifier is changed to the name attribute, with a mapping type of useNew . (This attribute has been around since March, but it was not used as a key until May.) In June we add a new attribute, assayKey , and specify that as the item identifier, with a mapping type of useOld . Finally, in July we replace the h assay i element with a h genotypingAssay i element, with a genoID attribute as the item identifier and a mapping type of replace .

The gluing of elements into items is then done in the following way. Before May, the assayNumber is used for gluing. When the schema change occurs sometime in May, we glue across the schema change by matching the assayNumber value of the element before the schema change with the assayID value after the change: these (integer) values must match for the two elements to be glued. In May, we glue across the schema change by matching up old elements and new elements that have the same (string) value for their name attribute, the was not being used as a key. In a consistent fashion, in June we also glue using the name attribute, which was the old item identifier.

July is the most complex. We need to glue an assay element with an item identifier of assayKey with a genotypingAssay element with an item identifier of genoID . For this, the MappingLocation attribute in the bundle points to a mapping table that provides a list of pairs, each with an assayKey and a genoID value.
 which the other three mapping types, which have no need for storing instance information in the schema, are inappropriate.
 Of course, the mapping location document can also be time-varying; s V slice with U NSQUASH . We will see shortly how this is useful in the presence of gaps. 7. Accommodating gaps
Bridging is more involved when there are gaps in the lifetime of an item. Gaps make the process of finding the correspondence between the items from consecutive schema-constant periods more difficult. If there are gaps in the lifetime of an item, bridging becomes even more complex.

Fig. 12 shows three cases that may arise while bridging the items from consecutive schema-constant peri-ods. It shows the data and schema changes along the transaction time dimension, from left to right. The schema-change walls are shown as bold vertical lines. The horizontal lines depicts the evolution of a particular item (in this case, three separate items). The bridging process is shown by the jumpers over schema-change walls. A dotted line indicates when the item did not exist in the database. The first item existed during the item: it ceased to exist sometime during P 1 but reappeared in P pearing only in P 3 .

We now examine each item in turn. 1. The item A (the first horizontal line) is present throughout schema-constant periods P last snapshot of P 1 and the first snapshot of P 2 contains versions of item A . Here, no extra work is needed as the items can be bridged directly using one of the above four methods. 2. The item B (the second horizontal line) disappeared for some time in P through in P 2 . Thus the last snapshot of P 1 and first snapshot of P
Bridging these two items in this case involves virtually extending period of item B  X  X  last version until the the start of P 3 ; and then performing the bridging using one of the above four methods. Each virtual exten-sion is depicted as a dashed line with an arrow indicating the direction the extension was made. In an imple-mentation, this could be done by simply checking item X  X  last version from P 3. An item could also disappear for one or more schema-constant periods and then reappear again. Item C (the bottom horizontal line) was present for initial part of P and again appeared in the later half of P 3 . For such cases, bridging involves virtually extending the period of the item C  X  X  last version from P 1 over multiple schema-constant periods followed by bridging using one of above methods. So P 1  X  X  version is extended to the wall, then bridged to a virtual element over all of P then bridged to the extended element in P 3 .
 Fig. 13 illustrates the most complex situation of cross-gap gluing over multiple schema-constant periods.
Documents in the top right part of the figure show the temporal bundle documents corresponding to schema-change walls in March, May, and July, respectively. The two time lines correspond to an h assay i item. The top time line is that contained in the March document; the bottom one is that contained in the July document. The replace and useNew methods are used for item correspondences in July and September, the h assay i element with a h genotypingAssay i element, with a genoID attribute as the item identifier and a mapping type of replace . In September the item identifier is changed back to the name attribute, with a mapping type of useNew .

The item is present during the initial part of schema-constant period P
June, as indicated by a terminated line in the middle of P is absent during P 2 , no item correspondence is necessary in the replace mapping list.

A second schema-change takes place in the month of September. An h genotypingAssay i element, that is in fact a version of the old h assay i element present in January reappears sometime in November. At this point the user wants to associate this new element with the old one from P assay. In order to perform this association, the user will need to add a pair of identifiers to the old replace mapping list for the month of July to handle this virtually extended element. Multiple versions of the replace mapping list could also be maintained as a temporal document; the temporal validator would then extract the relevant snapshot from it.
 8. Transaction semantics
A data change in XML documents can coexist with schema changes within a single transaction, and hence can occur at exactly the same (transaction commit) time. With schema changes coming into picture, we also need to consider other factors like name and relative path changes for item identifier fields and other elements that constitute the content of an item, complicating the process of bridging and hence validation.
We considered three ways to handle this situation. 1. Disallow all data change in any transaction containing a schema change. This is the most stringent option and makes the user X  X  job more difficult, forcing her to split the task into multiple transactions. This may not be always feasible from real world point of view. Consider a situation where an element is modified to have a new  X  X equired attribute X , data change is mandatory in this case and hence cannot be separated from schema change. It could be argued that this is achievable with the addition of a new  X  X ptional X  attribute, followed by required data changes and then making the attribute required. But the burden of work falls on the user. 2. Allow schema changes to coexist with data changes, except for schema changes to item identifier fields. This will eliminate the need to have a replace mapping list since the bridging could always be done using one of the three options  X  useNew  X ,  X  useOld  X , or  X  useBoth  X . 3. Allow data changes to coexist with schema changes within a transaction without any restrictions.
We decided to go with the third approach, as it is the most general. In doing so a refined transaction management semantics was needed. Specifically, we consider any data change in the first snapshot of a schema-constant period to have taken place after any schema changes within that same transaction. Thus, even if the timestamps for the schema change and the data change are identical (as both changes occurred in the same transaction), an assumption is made that the data change took place following the schema change. 9. Non-sequenced constraints
A constraint is non-sequenced if it is applied to a temporal item as a whole (including the lifetime of the data entity) rather than to individual timeslices. Non-sequenced constraints are defined in the temporal annotation as an extension of snapshot XML Schema constraints. An example of a non-sequenced (cardinality) constraint is:  X  X  X n item cannot change more than three times in a year. X  X  This type of constraint cannot be validated using the conventional validator and thus needs to be validated using the  X  X emporal Constraint Checker X  module of s V
As mentioned in Section 2 , schemas vary only over transaction time. Hence, non-sequenced constraint val-idation is easier in valid time, as schema changes cannot occur.

We considered two alternatives for the applicability of a non-sequenced constraint across schema changes. (1) The constraint is applicable only within the schema-constant period in which it is defined. (2) The constraint once defined becomes applicable to the entire document.

As per the first approach, any violation of a constraint during previous schema-constant periods is ignored, while in the second approach, the constraint may be violated even when first defined.

Consider a situation shown in Fig. 14 . It maintains the same conventions as Fig. 12 . Changes to an item are shown by X X  X . A new non-sequenced constraint is introduced during third schema-constant period P that  X  X  X n item cannot change more than three times in a year. X  X  But the item has already undergone four changes during previous schema-constant periods P 1 and P
According to first alternative listed above, the constraint is not violated as long as the item does not change more than three times in the third schema-constant period. Until there are four changes made after the schema change, the constraint is not considered to be violated.
According to the second alternative semantics, there is immediately a violation of the constraint, due to activity during the previous two schema-constant periods. This situation could be handled in at least two pos-sible ways. (1) Flag an error and do not perform any further validations. (2) Flag a warning saying that the item has violated the constraint over previous schema-constant periods.
We decided on the second alternative in both cases: to apply a non-sequenced constraint to all previous schema-constant periods, as it is a more general approach. If such a situation is encountered, the validator would show a warning and would not allow any further changes to that item. Users can find out about the reasons for the violation using some query language (e.g., XQuery) over the previous versions of data. The first approach can be simulated by restricting the applicability period of the constraint to a particular schema-constant period.

This completes the picture. For each schema-constant period, the time-varying data checker is invoked to check the temporal integrity constraints over the time-varying data, with the single base schema, temporal annotation, and physical annotation. Then the temporal constraint checker glues across the schema change walls and performs the temporal checks across these walls. For example, if a temporal annotation states that there can be at most three such values within a year (a rather complex kind of temporal constraint), the tem-poral constraint checker will ensure that the number of unique values before the wall and the number of unique values after the wall do not together exceed three. For most temporal constraints, it suffices to just check independently before and after the wall. Only for certain kinds of non-sequenced constraints [19] does the temporal constraint checker get involved.

The pseudo-code is shown in Fig. 15 . Here, variables are in italics and helper functions are in boldface. The timeVaryingDataChecker returns items encountered in each constant period p . These items are bridged by the temporalConstraintChecker to coalesce into items that cross schema change walls.
 10. Related work
Methods to represent temporal data and documents on the web have been actively researched. This research has covered a wide range of issues that include architectures for collecting document versions (cf. quency of data change (cf. [7] ), and temporal query languages (cf. [13] ). Grandi has created a bibliography of previous work in this area [14] .

There are only two previous papers on validation of time-varying XML documents: our paper that intro-duced s XSchema but did not discuss schema versioning [9] and our paper that introduced cross-schema-change validation [12] . The present work extends the latter paper by discussing how to accommodate gaps in the existence time of an item, transaction semantics, and how to accommodate non-sequenced integrity con-straints and augments the discussion with additional figures and pseudo-code.

Schema versioning has been previously researched in the context of temporal databases [18] . But an XML schema is a grammar specification, unlike a (relational) database schema, so new techniques are required.
Though various XML schema languages have been proposed in the literature and in the commercial arena (cf. [15] ) for a summary, none model schema changes nor provide for versioning. We chose to base our research on XML Schema because it is backed by the W3C and is the most widely used schema language.
Recently there has been interest in the incremental validation of XML documents [3] using static schemas, which has application in the area of data streaming. To the best of our knowledge, the effect of changes to the schema during incremental validation is an open area of research. We do not address incremental validation in this paper. 11. Conclusion
This paper shows how schema versioning can be integrated with support for time-varying documents in a fashion consistent and upwardly compatible with XML, XML Schema, and conventional XML validators.
Schema versioning in its full generality is supported, including (time-varying) schemas that include or refer-ence other (time-varying) schemas. Bundles are used uniformly to denote the schema of a temporal document; S CHEMA M APPER is used to generate a representational schema when needed.

By identifying when schema changes occur, the schema-constant periods can be identified. Such periods have the very useful property that there is an unchanging schema (comprise a single base schema, a single tem-poral annotation document, and a single physical annotation). The dance between the conventional validator, the time-varying data checker, and the temporal constraint checker ensures that most of the checking is done by the conventional validator, with most of the remaining checking done by the time-varying data checker. In the future, we plan to integrate s XSchema with a schema-aware XML-based editor like XMLSpy. Schema-aware editors generate easy-to-use templates for updating each type of element defined in a schema.
But they do not track changes to either the schema or the data. Enabling versioning for both will support unlimited undo/redo, improve change tracking, and aid in cooperative editing. Another direction of future work is to add versioning to XUpdate. XUpdate is a language for specifying changes to an XML document.
By specifying how the evaluation of an XUpdate statement on an XML Schema document modifies a bundle, we should be able to support schema versioning in XUpdate.
 Acknowledgments We thank Lingeshwaran Palaniappan and Eric Roeder for their help in the development of S
M APPER ,S QUASH ,U NSQUASH , and s V ALIDATOR . NSF Grants IIS-0100436, IIS-0415101, and EIA-0080123 and grants from the Boeing Corporation, Microsoft, and the Arizona Technology and Research Initiative
Fund through the University of Arizona Internet Technology, Commerce and Design Institute provided par-tial support for this work.

References
