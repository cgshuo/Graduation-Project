 Beihang University Microsoft Research Microsoft Research Microsoft Research Beihang University be handled the same way as simple and straightforward sentiment expressions in a unified and probabilistic way. We formulate the sentiment grammar upon Context-Free Grammars (CFGs), and provide a formal description of the sentiment parsing framework. We develop the parsing data sets show significant improvements over baseline sentiment classification approaches. 1. Introduction both research and industry communities in recent years. Sentiment classification, which identifies sentiment polarity (positive or negative) from text (sentence or document), have been two mainstream approaches for sentiment classification. The lexicon-based approach (Turney 2002; Taboada et al. 2011) aims to aggregate the sentiment polarity learning-based approach (Pang, Lee, and Vaithyanathan 2002) treats sentiment polarity from a set of sentences (or documents) annotated with their corresponding sentiment polarity.
 commonly created manually by experts. It has been widely recognized that sentiment
Twitter 1 and movie reviews on IMDb 2 as examples, people use very casual language as well as informal and new vocabulary to comment on general topics and movies. In practice, it is not feasible to create and maintain sentiment lexicons to capture sentiment expressions with high coverage. On the other hand, the learning-based approach relies on large annotated samples to overcome the vocabulary coverage and deals with varia-tions of words in sentences. Human ratings in reviews (Maas et al. 2011) and emoticons in tweets (Davidov, Tsur, and Rappoport 2010; Zhao et al. 2012) are extensively used to collect a large number of training corpora to train the sentiment classifier. However, Vaithyanathan 2002) in sentiment classification.
 challenging problems in sentiment analysis. Compositionalities such as negation, inten-sification, contrast, and their combinations are typical cases. We show some concrete examples here: can change the polarity (Examples (1), (3), (4), (5)), strength (Examples (2), (3), (5)), or both (Examples (3), (5)) of the sentiment of the sentences. We do not need any detailed explanations here as they can be commonly found and easily understood in people X  X  266 results either used as features (Choi and Cardie 2008; Moilanen, Pulman, and Zhang 2010) in learning-based methods or hand-crafted rules (Moilanen and Pulman 2007; Jia,
Yu, and Meng 2009; Klenner, Petrakis, and Fahrni 2009; Liu and Seneff 2009) in lexicon-based methods. However, even with the difficulty and feasibility of deriving the senti-ment structure from syntactic parsing results put aside, it is an even more challenging nature and has a high ratio of out-of-vocabulary words. The accuracy of the linguistic parsers trained on standard data sets (e.g., the Penn Treebank [Marcus, Marcinkiewicz, and Santorini 1993]) drops dramatically on user-generated-content (reviews, tweets, unfortunately, will propagate downstream in the process of sentiment analysis methods building upon parsing results.
 fashion as statistical syntactic parsing, which aims to find the linguistic structure of a sentence. This idea creates many opportunities for developing sentiment classifiers from a new perspective. The most challenging problem and barrier in building a statistical sentiment parser lies in the acquisition of training data. Ideally, we need examples of for constituents within a sentence, as with the Penn TreeBank for training traditional linguistic parsers. However, this is not practical as the annotations will be inevitably time-consuming and require laborious human efforts. Therefore, it is better to learn the sentiment parser only utilizing examples annotated with the polarity label of the whole sentence. For example, we can collect a huge number of publicly available reviews and rating scores on the Web. People may use the movie is gud ( X  X ud X  is a popular informal expression of  X  X ood X ) to express a positive opinion towards a movie, and not a fan to gud, but I am still not a fan to indicate a negative opinion. We can then use these two fragments and the overall negative opinion of the sentence to deduce sentiment rules automatically from data. These sentiment fragments and rules can be used to analyze the sentiment structure for new sentences.
 formulate a Context-Free Grammar (CFG) X  X ased sentiment grammar. We then develop a statistical parser to derive the sentiment structure of a sentence. We leverage the CYK algorithm (Cocke 1969; Younger 1967; Kasami 1965) to conduct bottom X  X p parsing, and use dynamic programming to accelerate computation. Meanwhile, we propose using the polarity model to derive sentiment strength and polarity of a sentiment parse tree, and the ranking model to select the best one from the sentiment parsing results. We train the parser directly from examples of sentences annotated with sentiment polarity labels tences. Therefore we can obtain training data easily. In particular, we train a sentiment parser, named s.parser , from a large number of review sentences with users X  ratings principled and scalable framework to support the sentiment composition and inference which cannot be well handled by bag-of-words approaches. We show that complicated phenomena in sentiment analysis (e.g., negation, intensification, and contrast) can be handled the same way as simple and straightforward sentiment expressions in a unified and probabilistic way.
Section 2. We present the statistical sentiment parsing framework, including the parsing model, polarity model, and ranking model, in Section 3. Learning methods for our model are explained in Section 4. Experimental results are reported in Section 5. We conclude this article with future work in Section 6. 2. Related Work problem in a parsing manner, which is a significant departure from most previous research. 2.1 Sentiment Classification of text granularity, existing works can be divided into phrase-level, sentence-level, or document-level sentiment classification. We focus on sentence-level sentiment classifi-cation in this article. Regardless of what granularity the task is performed on, existing approaches deriving sentiment polarity from text fall into two major categories, namely, lexicon-based and learning-based approaches.
 timent lexicon to derive sentiment polarity. These methods often use a set of manually defined rules to deal with the negation of polarity. Turney (2002) proposed using the review to predict its sentiment orientation. Yu and Hatzivassiloglou (2003) calculated a modified log-likelihood ratio for every word by the co-occurrences with positive and negative seed words. To determine the polarity of a sentence, they compare the average approach for extracting sentiment from text. They used dictionaries of words with anno-tated sentiment orientation (polarity and strength) while incorporating intensification and negation. The lexicon-based methods often achieve high precisions and do not need 268 any labeled samples. But they suffer from coverage and domain adaption problems. Moreover, lexicons are often built and used without considering the context (Wilson, Wiebe, and Hoffmann 2009). Also, hand-crafted rules are often matched heuristically. ated manually, or automatically using seed words to expand the list of words. Kamps synonym and antonym relations) in WordNet to expend a set of seed words. Some other methods learn lexicons from data directly. Hatzivassiloglou and McKeown (1997) used a log-linear regression model with conjunction constraints to predict whether conjoined adjectives have similar or different polarities. Combining conjunction constraints across many adjectives, a clustering algorithm separated the adjectives into groups of different polarity. Finally, adjectives were labeled as positive or negative. Velikovich et al. (2010) constructed a term similarity graph using the cosine similarity of context vectors. They performed graph propagation from seeds on the graph, obtaining polarity words and phrases. Takamura, Inui, and Okumura (2005) regarded the polarity of words as spins of electrons, using the mean field approximation to compute the approximate probability function of the system instead of the intractable actual probability function. Kanayama and Nasukawa (2006) used tendencies for similar polarities to appear successively in contexts. They defined density and precision of coherency to filter neutral phrases and lexicon learning to an optimization problem, and used integer linear programming to solve it. Kaji and Kitsuregawa (2007) defined the  X  2 -based polarity value and PMI-based polarity value as a polarity strength to filter neutral phrases. de Marneffe, Manning, and Potts (2010) utilized review data to define polarity strength as the expected rating value. Mudinas, Zhang, and Levene (2012) used word count as a feature template and garded the weights as polarity strengths. Krestel and Siersdorfer (2013) generated topic-dependent lexicons from review articles by incorporating topic and rating probabilities defined in WordNet are not used because of its coverage. Furthermore, most of these optimization algorithms and sentence-level sentiment labels to learn polarity strength learn the polarity strength values of phrases from data. However, our primary objective is to obtain correct sentence-level polarity labels, and use them to form the sentiment grammar.
 tences or documents into two (negative and positive) or three (negative, positive, and neutral) classes. Previous research has shown that sentiment classification is more dif-ficult than traditional topic-based text classification, despite the fact that the number machine learning methods to produce automated classifiers to generate class labels for movie reviews. They tested them on Na  X   X ve Bayes, Maximum Entropy, and Support
Vector Machine (SVM), and evaluated the contribution of different features includ-ing unigrams, bigrams, adjectives, and part-of-speech tags. Their experimental results suggested that a SVM classifier with unigram presence features outperforms other competitors. Pang and Lee (2004) separated subjective portions from the objective by finding minimum cuts in graphs to achieve better sentiment classification perfor-mance. Matsumoto, Takamura, and Okumura (2005) used text mining techniques to extract frequent subsequences and dependency subtrees, and used them as features classifying polarity at different levels of granularity. This model allowed classification
Yue, and Cardie (2010) used sentence-level latent variables to improve document-level only using document-level annotations to learn sentence-level sentiment labels, and
T  X  ackstr  X  om and McDonald (2011b) improved it by using a semi-supervised latent vari-able model to utilize manually crafted sentence labels. Agarwal et al. (2011) and Tu et al. (2012) explored part-of-speech tag features and tree-kernel. Wang and Manning (2012) used SVM built over Na  X   X ve Bayes log-count ratios as feature values to classify polarity.
They showed that SVM was better at full-length reviews, and Multinomial Na  X   X ve Bayes models, we derive polarity labels from tree structures parsed by the sentiment grammar. sis is compositional. Sentiment classification can be solved by deriving the sentiment of a complex constituent (sentence) from the sentiment of small units (words and phrases) (Moilanen and Pulman 2007; Klenner, Petrakis, and Fahrni 2009; Choi and
Cardie 2010; Nakagawa, Inui, and Kurohashi 2010). Moilanen and Pulman (2007) pro-posed using delicate written linguistic patterns as heuristic decision rules when com-puting the sentiment from individual words to phrases and finally to the sentence. The manually compiled rules were powerful enough to discriminate between the different (negative) and too sad (negative). Nakagawa, Inui, and Kurohashi (2010) leveraged a conditional random field model to calculate the sentiment of all the parsed elements in the dependency tree and then generated the overall sentiment. It had an advantage over the rule-based approach (Moilanen and Pulman 2007) in that it did not explicitly denote any sentiment designation to words or phrases in parse trees. Instead, it modeled their sentiment polarity as latent variables with a certain probability of being positive or negative. Councill, McDonald, and Velikovich (2010) used a conditional random field model informed by a dependency parser to detect the scope of negation for sentiment analysis. Some other methods model sentiment compositionality in the vector space.
They regard the composition operator as a matrix, and use matrix-vector multiplica-recursive neural network model that learned compositional vector representations for phrases and sentences. Their model assigned a vector and a matrix to every node in a parse tree. The vector captured the inherent meaning of the constituent, and the matrix captured how it changes the meaning of neighboring words or phrases. Socher et al. parser (Klein and Manning 2003). The sentiment treebank included polarity labels of phrases that are annotated using Amazon Mechanical Turk. The authors trained recur-sive neural tensor networks on the sentiment treebank. For a new sentence, the model predicted polarity labels based on the syntactic parse tree, and used tensors to handle compositionality in the vector space. Dong et al. (2014) proposed utilizing multiple com-position functions in recursive neural models and learning to select them adaptively.
Most previous methods are either rigid in terms of handcrafted rules, or sensitive to the performance of existing syntactic parsers they use. This article addresses sentiment 270 compositions by defining sentiment grammar and borrowing some techniques in the parsing research field. Moreover, our method uses symbolic representations instead of vector spaces. 2.2 Syntactic Parsing and Semantic Parsing
The work presented in this article is close to traditional statistical parsing, as we borrow some algorithms to build the sentiment parser. Syntactic parsers are learned from the
Treebank corpora, and find the most likely parse tree with the largest probability. In this article, we borrow some well-known techniques from syntactic parsing methods (Charniak 1997; Charniak and Johnson 2005; McDonald, Crammer, and Pereira 2005; K  X  ubler, McDonald, and Nivre 2009), such as the CYK algorithm and Context-Free
Grammar. These techniques are used to build the sentiment grammar and parsing polarity label of a sentence, instead of obtaining the parse tree. We only have sentence-polarity pairs as our training instances instead of annotated tree structures. Moreover, in the decoding process, our goal is to compute correct polarity labels by representing sentences as latent sentiment trees. Recently, Hall, Durrett, and Klein (2014) developed a discriminative constituency parser using rich surface features, adapting it to sentiment analysis. Besides extracting unigrams and bigrams as features, they learned interactions between tags and words located at the beginning or the end of spans. However, their method relies on phrase-level polarity annotations.
 is used to parse meaning representations for given sentences. Most existing semantic parsing works (Zelle and Mooney 1996; Kate and Mooney 2006; Raymond and Mooney 2006; Zettlemoyer and Collins 2007, 2009; Li, Liu, and Sun 2013) relied on fine-grained annotations of target logical forms, which required the supervision of experts and are relatively expensive. To balance the performance and the amount of human annotation, some works used only question-answer pairs or even binary correct/incorrect signals as their input. Clarke et al. (2010) used a binary correct/incorrect signal of a database query to map sentences to logical forms. It worked with FunQL language and trans-formed semantic parsing as an integer linear programming (ILP) problem. In each iter-ation, it solved ILP and updated the parameters of structural SVM. Liang, Jordan, and
Klein (2013) learned a semantic parser from question-answer pairs, where the logical form was modeled as a latent tree-based semantic representation. Krishnamurthy and
Mitchell (2012) presented a method for training a semantic parser using a knowledge base and an unlabeled text corpus, without any individually annotated sentences.
Artzi and Zettlemoyer (2013) used various types of weak supervision to learn a grounded Combinatory Categorial Grammar semantic parser, which took context into consideration. Bao et al. (2014) presented a translation-based weakly supervised seman-tic parsing method to translate questions to answers based on CYK parsing. A log-linear model is defined to score derivations. All these weakly supervised semantic parsing methods learned to transform a natural language sentence to its semantic representation bottom X  X p fashion. We use the log-linear model to score candidates generated by beam search. Instead of using question-answer pairs, sentence-polarity pairs are used as our weak supervisions. We also use the parameter estimation algorithm proposed by Liang,
Jordan, and Klein (2013). 3. Statistical Sentiment Parsing
We present the statistical parsing framework for sentence-level sentiment classification cal parsing process. Figure 1 shows the overview of the statistical sentiment parsing framework. There are three major components. The input sentence s is transformed into and represented by sentiment trees derived from the parsing model (Section 3.2), using the sentiment grammar defined in Section 3.1. Trees are scored by the ranking model in Section 3.3. The sentiment tree with the highest ranking score is treated as the best derivation for s . Furthermore, the polarity model (Section 3.4) is used to compute polarity values for the sentiment trees.
 the sentence s and its polarity label y in training data. In other words, we train the model directly from the examples of sentences annotated only with sentiment polarity labels but without any syntactic annotations or polarity annotations of the constituents within sentences. To be specific, we first learn the sentiment grammar and the polarity model from data as described in Section 4.2. Then, given the sentence and polarity label pairs s , y , we search the latent sentiment trees t and estimate the parameters of the ranking model as detailed in Section 4.1.
 using an example sentence, The movie is not very good, but i still like it . The sentiment polarity label of the above sentence is  X  X ositive. X  There is negation, intensification, and contrast in this example, which are difficult to capture using bag-of-words classification methods. This sentence is a complex case that demonstrates the capability of the pro-posed statistical sentiment parsing framework, which motivates the work in this article.
The statistical sentiment parsing algorithm may generate a number of sentiment trees for the input sentence. Figure 2 shows the best sentiment parse tree. It shows that the statistical sentiment parsing framework can deal with the compositionality of sentiment in a natural way. In Table 1, we list the sentiment rules used during the parsing process.
We show the generation process of the sentiment parse tree from the bottom X  X p and process. 272 grammar in Section 3.1. We then present the details of the parsing model in Section 3.2, the ranking model in Section 3.3, and the polarity model in Section 3.4. 3.1 Sentiment Grammar
We develop the sentiment grammar upon CFG (Context-Free Grammar) (Chomsky a set of rewrite rules (or production rules) of the form A  X  c where A  X  V and c  X  non-terminal N represents the negative polarity, and the non-terminal P represents the positive polarity. The rules in R s are divided into the following six categories: tence from the bottom X  X p. The glue rules are used to combine polarity informa-order to tackle the OOV problem, we treat a text span that consists of OOV words as empty text span, and derive them to E . The OOV text spans are combined with other
We can use the sentiment grammar to compactly describe the derivation process of a sentence. 3.2 Parsing Model
We present the formal description of the statistical sentiment parsing model following deductive proof systems (Shieber, Schabes, and Pereira 1995; Goodman 1999) as used in traditional syntactic parsing. For a concrete example, 274 which represents if we have the rule A  X  BC and B  X   X  w k obtain A  X   X  w j i . By adding a unary rule with the binary rule in Equation (6), we can express the standard CYK algorithm for
CFG in Chomsky Normal Form (CNF). And the goal is [0, S , n ], in which S is the start symbol and n is the length of the input sentence. In the given CYK example, the term in deductive rules can be one of the following two forms: a sentiment rule, and H k denotes an item. When we refer to both rules and items, we employ the word terms .
 the CYK algorithm to conduct parsing. Because the maximum number of non-terminal parsing based on a customized CYK algorithm that is similar to the work of Chiang statistical sentiment parsing are summarized in Figure 3. 3.3 Ranking Model with the highest score is treated as the best representation for sentence s . We extract a parse tree. Let  X   X  R d be the parameter vector for the features. We use the log-linear indicate how likely the trees are to produce correct predictions. Given the sentence s and parameters  X  , the log-linear model defines a conditional probability: ( X  X  w j i ) [ i , X , j ] ( X  X  X 1 X 2 ) [ i , X 1 , k ] [ k , X 2 , j ] ( E  X  w j i ) [ i , E , j ] ( X  X  E X 1 ) [ i , E , k ] [ k , X 1 , j ] ( X  X  X 1 E ) [ i , X 1 , k ] [ k , E , j ] where X , X 1 , X 2 represent N or P .
 model is a discriminative model, and it is widely used in natural language pro-decoding process, because p ( t | s ; T ,  X  )  X   X  ( s , t ) order. 3.4 Polarity Model
The goal of the polarity model is to model the calculation of sentiment strength and the rules used in the parsing process. We expand the notations in the inference rule (8) to incorporate the polarity model. The new form of inference rule is: in which r , H 1 , ... , H K are the terms described in Section 3.2. Every item H polarity strength  X  k : of subspans as input. 276 ized to 1, namely, P ( X | w j i ) + P ( X | w j i ) = 1. Notably, X = polarity of X .
 following part, we define the polarity model for the different types of rules. If the rule is a dictionary rule X  X  w j i , its sentiment strength is obtained as: where X  X  X  N , P } denotes the sentiment polarity of the left hand side of the rule, X is the opposite polarity of X , and  X  P ( X | w j i ),  X  P ( X | w estimated from training data. where h ( x ) = 1 represent N or P . As specified in the polarity model, we have P ( X | w lated by their product, and normalized to 1.
 they are combined with in-vocabulary phrases by the auxiliary rules, the polarity values are determined by the text span with polarity and the OOV text span is ignored. More specifically, regression can be regarded as putting linear combination of the subspans X  polarity prob-abilities into a logistic function (or sigmoid function). We will show that the negation, intensification, and contrast can be well modeled by the regression-based method. It is formally shown as example, if the span w j i can match N  X  not P and P  X   X  w the polarity model is defined as where polarity probability is calculated by P ( N | w j i verses the sentiment polarity and corresponding sentiment strength. However, consider not great , which is unreasonable. Another potential problem of switch negation is that
Inkpen 2006). For example, not very good turns out to be even more negative than not good , given the fact that very good is more positive than good . Therefore, Taboada et al. of reversing polarity strength, shift negation shifts it toward the opposite polarity by 278 a fixed amount. This method can partially avoid the aforementioned two problems.
However, they set the parameters manually, which might not be reliable and extensible enough to a new data set. Using the regression model, switch negation is captured by the negative scale item  X  k ( k &gt; 0), and shift negation is expressed by the shift item  X  (downtoner) the semantic intensity of its neighboring item (Quirk 1985). For example, extremely good should obtain higher strength of positive polarity than good , because it is modified by the amplifier ( extremely ). Polanyi and Zaenen (2006) and Kennedy and decreases for downtoners. Taboada et al. (2011) propose a method, called percentage intensification , to associate each intensification word with a percentage scale, which is larger than one for amplifiers, and less than one for downtoners. The regression model can capture these two methods to handle the intensification. The shift item  X  the polarity addition and subtraction directly, and the scale item  X  polarity by a percentage.
 negation and intensification methods. For a specific rule, the parameters and the com-positional method are automatically learned from data (Section 4.2.3) instead of setting them manually as in previous work (Taboada et al. 2011). In a similar way, this method can handle the contrast. For example, the inference rule for N  X  P but N is: where the polarity probability of the rule N  X  P but N is computed by P ( N | w  X 
P ( P | w j 1 i  X  , and  X  2 .
 constraint, we may get P ( N | w j i ) =  X  0 . 6 + P ( P | w probability ranges from zero to one. Figure 5 intuitively shows that the logistic function truncates polarity values to (0, 1) smoothly.
  X   X  3.5 Constraints
We incorporate additional constraints into the parsing model. Those are used as pruning conditions in the derivation process not only to improve efficiency but also to force the derivation towards the correct direction. We expand the inference rules in Section 3.4 as, where C is a side condition . The constraints are interpreted in a Boolean manner. If the constraint C is satisfied, the rule can be used, otherwise, it cannot. We define two constraints in the parsing model.
 non-terminals, we denote the corresponding polarity label of non-terminal X as X . Following this notation, we describe the first constraint as where X is the opposite polarity of X . For instance, if rule P  X  not N matches the text the polarity obtained by the polarity model should be positive ( P ).
 needs to exceed a predefined threshold  X  (  X  0 . 5). Specifically, for combination rules X  X  w where K is the number of subspans in the rule, and X k is the corresponding polarity label of non-terminal X k in the right hand side. If P ( X 280  X  , we regard the polarity of phrase w j k i the combination rule P  X  a lot of P or N  X  a lot of N for the phrase a lot of people . This constraint avoids improperly using the combination rules for neutral phrases. Notably, when  X  is set as 0.5, this constraint is the same as the first one in Equation (19). rules do not have any constraints, and the constraint C 1
The constraint C 2 is only applied for the combination rules. 3.6 Decoding Algorithm
In this section, we summarize the decoding algorithm in Algorithm 1. For a sentence s , the CYK algorithm and dynamic programming are used to obtain the sentiment tree with the highest score. To be specific, the modified CYK parsing model parses the input spans. For every text span w j i , we match the rules in the sentiment grammar (Section 3.1) model described in Section 3.4. We also use the constraints described in Section 3.5 to prune search paths. The constraints improve the efficiency of the parsing algorithm and make derivations that meet our intuition. where h ( x ) = 1 represent N or P . As specified in the polarity model, we have P ( X | w Algorithm 1 Decoding Algorithm Input: w n 0 : Sentence
Output: Polarity of the input sentence 1: score [, , ]  X  X } 2: for l  X  1 ... n do . Modified CYK algorithm 3: for all i , j s . t . j  X  i = l do 5:  X   X  calculate polarity value for r . Polarity model 6: if constraints are satisfied then . Constraint 7: sc  X  compute score for this derivation by ranking model . Ranking 8: if sc &gt; score [ i , j , X ] then 9: score [ i , j , X ]  X  sc 10: return arg max X  X  X  N , P } score [0, X , n ] the sentiment tree. So the dynamic programming technique can be used to compute the derivation tree with the highest ranking score. For a span, the scores of its subspans are used to calculate the local scores of its derivations. For example, the score of the the score of applying the rule r . As described in Section 3.3, the score of using rule r is w , and  X  is the weight vector of the ranking model. The k highest score trees satisfying sentence. The time complexity is the same as the standard CYK X  X . 4. Model Learning
We described the statistical sentiment parsing framework in Section 3. We present the model learning process in this section. The learning process consists of two steps. First, the sentiment grammar and the polarity model are learned from data. In other words, the rules and the parameters used to compute polarity values are learned. These basic sentiment building blocks are then used to build the parse trees. Second, we estimate the parameters of the ranking model using the sentence and polarity label pairs. At this sentiment grammar and polarity model.
 polarity model. 4.1 Ranking Model Training 282 candidates. Then, we describe the objective function used in the optimization algorithm.
Finally, we introduce the algorithm for parameter estimation using the gradient-based method. 4.1.1 Features. We extract a feature vector  X  ( s , t )  X  R
The feature vector is used in the log-linear model. In Figure 7, we present the features organized into feature templates. Each of them contains a set of features. These feature templates are shown as follows: ment tree. Another intuitive lexical feature template is [combination rule + word]. For
However, if this feature is fired frequently, the phrase very good would be learned as a dictionary rule and can be used in the decoding process. So we do not use this feature Feature Template Feature Feature Value Number of combination rules C OMB H IT 3 Combination rule C OMB R ULE [ P  X  very P ] 1 Number of dictionary rules D ICT H IT 3 Dictionary rule D ICT R ULE [ P  X  the movie is] 1 decompose along structures of sentiment trees, enabling us to use dynamic program-ming in the CYK algorithm. 4.1.2 Objective Function. We design the ranking model upon the log-linear model to score candidate sentiment trees. In the training data D , we only have the input sentence s and its polarity label L s . The forms of sentiment parse trees, which can obtain the correct obtaining the correct polarity label L s , (Equation (10)) is the log-partition function with respect to T ( s ).
 sists of two terms. The first term is the sum of marginal log-likelihood over training instances that can obtain the correct polarity labels. The second term is a L regularization term on the parameters  X  . Formally, imize the objective function O (  X  , T ). According to Wainwright and Jordan (2008), the derivative of the log-partition function is the expected feature vector where E p ( x ) [ f ( x )] = P x p ( x ) f ( x ) for discrete x . 4.1.3 Parameter Estimation. The objective function O (  X  , T ) is not concave (nor convex), hence the optimization potentially results in a local optimum. Stochastic Gradient De-scent (SGD; Robbins and Monro 1951) is a widely used optimization method. The SGD algorithm picks up a training instance randomly, and updates the parameter vector  X  according to where  X  is the learning rate, and  X  O (  X  )  X  X  respect to parameter  X  j . The SGD is sensitive to  X  , and the learning rate is the same for all dimensions. As described in Section 4.1.1, we mix sparse features together with dense features. We want the learning rate to be different for each dimension. We use
AdaGrad (Duchi, Hazan, and Singer 2011) to update the parameters, which sets an adaptive per-feature learning rate. The AdaGrad algorithm tends to use smaller update 284 steps when we meet a feature many times. In order to compute efficiently, a diagonal approximation version of AdaGrad is used. The update rule is where we introduce an adaptive term G ( t ) j . G ( t ) j decreases the update step for dimension j . Compared with SGD, the only cost is to store and update G ( t ) j for each parameter.

With the candidate parse trees and objective function, the parameters  X  are updated to make the parsing model favor correct trees and give them a higher score. Because there are many parse trees for a sentence, we need to calculate Equation (23) efficiently. As indicated in Section 4.1.1, the features decompose along the structure of sentiment trees.
So dynamic programming can be utilized to compute E p ( t | s ; T ,  X  ) obtain the correct polarity labels. As this constraint does not decompose along the tree structure, there is no efficient dynamic program for this. Instead of searching all the parse trees spanning s , we use beam search to approximate this expectation. Beam beam search algorithm generates the K -best trees with the highest score  X  ( s , t ) T  X  for each span. These local optimums are used recursively in the CYK process. The K -best trees for the whole span are regarded as the candidate set approximate Equation (23) as in Liang, Jordan, and Klein (2013).
 better parameters, we can obtain better candidate trees; (2) with better candidate trees, we can learn better parameters. Thus the optimization problem is solved in an iterative manner. We initialize the parameters as zeros. This leads to a random search and gen-erates random candidate trees. With the initial candidates, the two steps in Algorithm 2 lead the parameters  X  towards the direction achieving better performance. 4.2 Sentiment Grammar Learning
In this section, we present the automatic learning of the sentiment grammar as defined in Section 3.1. We need to extract the dictionary rules and the combination rules from data. In traditional statistical parsing, grammar rules are induced from annotated parse trees (such as the Penn TreeBank), so ideally we need examples of sentiment structure from examples of sentences annotated with sentiment polarity labels without using any syntactic annotations or polarity annotations of constituents within sentences. The Algorithm 2 Ranking Model Learning Algorithm Input: D : Training data { ( s , L s ) } , S : Maximum number of iteration
Output:  X  : Parameters of the ranking model 1:  X  (0)  X  (0, 0, ... , 0) T 2: repeat 3: ( s , L s )  X  randomly select a training instance in D 4:  X  T ( t )  X  B EAM S EACH ( s ,  X  ( t ) ) . Beam search to generate K-best candidates 7: t  X  t + 1 8: until t &gt; S sentences annotated with sentiment polarity labels are relatively easy to obtain, and we use them as our input to learn dictionary rules and combination rules.
 express positive or negative opinions using very simple and straightforward sentiment expressions again and again in their reviews. Intuitively, we can mine dictionary rules from these massive review sentences by leveraging the redundancy characteristics.
Furthermore, there are many complicated reviews that contain complex sentiment structures (e.g., negation, intensification, and contrast). If we already have dictionary rules on hand, we can use them to obtain basic sentiment information for the fragments within complicated reviews. We can then extract combination rules with the help of the dictionary rules and the sentiment polarity labels of complicated reviews. Because the simple and straightforward sentiment expressions are often coupled with complicated expressions, we need to conduct dictionary rule mining and the combination rule mining in an iterative way. 4.2.1 Dictionary Rule Learning. The dictionary rules G blocks used in the parsing process. Each dictionary rule in G the polarity model. To build G D , we regard all the frequent fragments whose occurrence frequencies are larger than  X  f and lengths range from 1 to 7 as the sentiment fragments.
We further filter the phrases formed by stop words and punctuations, which are not used to express sentiment.
 ment f is calculated by being the polarity. It should be noted that Laplace smoothing is used in Equation (26) to deal with the zero frequency problem. 286 occurrence frequency. For example, in the review sentence this movie is not good (nega-tive), the naive counting method increases the count #( good , N ) in terms of the polarity frequency directly. The examples indicate why some polarity probabilities of phrases counting from data are different from our intuitions. These unreasonable polarity probabilities also make trouble for learning the polarity model. Consequently, in order consideration when learning sentiment fragments.
 f is covered by a negation rule r that negates the polarity of f . The word cover here means that f is derived within a non-terminal of the negation rule r . For instance, the negation rule N  X  not P covers the sentiment fragment good in the sentence this is not a good movie (negative), that is, the good is derived from P of this negation rule. So we ignore the occurrence for #(good, N ) in this sentence. It should be noted that we still increase the count for #(not good, N ), because there is no negation rule covering the fragment not good .
 ities by counting the frequencies in negative and positive classes. Only the fragments whose occurrence numbers are larger than threshold  X  the combination rules into consideration to acquire more reasonable G subsequence of a frequent fragment must also be frequent. This is similar to the key insight in the Apriori algorithm (Agrawal and Srikant 1994). When we learn the dic-tionary rules, we can count the sentiment fragments from short to long, and prune the infrequent fragments in the early stages if any subsequence is not frequent. This pruning method accelerates the dictionary rule learning process and makes the procedure fit in memory.
 Algorithm 3 Dictionary Rule Learning Input: D : Data set, G C : Combination rules,  X  f : Frequency threshold
Output: G D : Dictionary rules 3: for ( s , L s ) in D do . s : w 0 w 1  X  X  X  w | s | X  1 , L 4: for all i , j s . t . 0  X  i &lt; j  X | s | do . w j i : w 5: if no negation rule in G C covers w j i then 6: #( w j i , L s ) ++ 9: for f in G D 0 do 10: if #( f ,  X  )  X   X  f then 11: compute P ( N | f ) and P ( P | f ) using Equation (26) 12: add dictionary rule ( L f  X  f ) to G D . L f = arg max 13: return G D 4.2.2 Combination Rule Learning. The combination rules G dictionary rules. They are used to handle the compositionality and process unseen phrases. The learning of combination rules is based on the learned dictionary rules and their polarity values. The sentiment fragments are generalized to combination rules by replacing the subsequences of dictionary rules with their polarity labels. For instance, as shown in Figure 8, the fragments is not (good/as expected/funny/well done) are all negative.
After replacing the subspans good , as expected , funny , and well done with their polarity label P , we can learn the negation rule N  X  is not P .
 of sentiment fragment f , we replace it with the corresponding non-terminal L
P ( L the polarity L rule. Otherwise, we further compare their polarity values. If this rule makes the polarity value become larger (or smaller), it will be treated as a strengthen (or weaken) rule. To obtain the contrast rules, we replace two subsequences with their polarity labels in a similar way. If the polarities of these two subsequences are different, we categorize this rule to the contrast type. Notably, these two non-terminals cannot be next to each other.
After these steps, we get the rule candidate set G C 0 and the occurrence number of each rule. We then filter the rule candidates whose occurrence frequencies are too small, and occurrence numbers. to calculate the polarity probabilities using the sentiment grammar. In this section, we present how to learn the parameters of the polarity model for the combination rules. 288 Algorithm 4 Combination Rule Learning
Input: D : Data set, G D : Dictionary rules,  X  p ,  X   X  ,  X 
Output: G C : Combination rules 3: for ( X  X  f ) in G D do . f : w 0 w 1  X  X  X  w | f | X  1 4: for all i , j s . t . 0  X  i &lt; j  X | f | do 5: if P ( L w j 7: if X 6 = L w j 8: #( r , negation ) ++ 9: else if P ( X | f ) &gt; P ( L w j 10: #( r , strengthen ) ++ 11: else if P ( X | f ) &lt; P ( L w j 12: #( r , weaken ) ++ 13: add r to G C 0 14: for all i 0 , j 0 , i 1 , j 1 s . t . 0  X  i 0 &lt; j 0 18: #( r , contrast ) ++ 19: add r to G C 0 21: for r in G C 0 do 22: if #( r ,  X  ) &gt;  X  r and max 23: add r to G C 24: return G C frequent sentiment fragments with their polarity labels. Both the replaced fragment and the whole fragment can be found in the dictionary rules, so their polarity probabilities have been estimated from data. We can use them as our training examples to figure out how context changes the polarity of replaced fragment, and learn parameters of the polarity model.
 denote the input vector x = (1, P ( X 1 | w j 1 i
Then we can rewrite Equation (15) as (  X   X  of the polarity model.
 polarity probabilities and the values computed from data. We define the cost function as where x m , y m is the m -th training instance.
 partial derivative of J (  X  ) with respect to  X  j is
Descend algorithm to minimize the cost function. For the instance ( x , y ), the parameters are updated using Algorithm 5 Polarity Model Learning Algorithm Input: G C : Combination rules,  X  : Stopping condition,  X  : Learning rate
Output:  X  : Parameters of the polarity model 2: for all combination rule r  X  G C do 3:  X  (0)  X  (0, 0, ... , 0) T 4: repeat 5: x , y  X  randomly select a training instance 7: t  X  t + 1 9: assign  X  ( T ) as the parameters of the polarity model for rule r 290 Algorithm 6 Sentiment Grammar Learning
Input: D : Data set { ( s , L s ) } , T : Maximum number of iteration . L
Output: G D : Dictionary rules, G C : Combination rules 2: repeat 5: until iteration number exceeds T 7: return G D , G C through the training examples x , y in a random order, and update the parameters  X  according to Equation (30). The stopping condition is  X  indicates the parameters become stable. 4.2.4 Summary of the Grammar Learning Algorithm. We summarize the grammar learning process in Algorithm 6, which learns the sentiment grammar in an iterative manner. frequencies in negative and positive classes. Only the fragments whose occurrence num-bers are larger than the threshold  X  f are kept. As mentioned in Section 4.2.1, the context can essentially change the distribution of sentiment fragments. We take the combination rules into consideration to acquire more reasonable G D . In the first iteration, the set of combination rules is empty. Therefore, we have no information about compositionality to improve dictionary rule learning. The initial G D contains some inaccurate sentiment distributions. Next, we replace the subsequences of dictionary rules to their polarity labels, and generalize these sentiment fragments to the combination rules G trated in Section 4.2.2. At the same time, we can obtain their compositional types and learn parameters of the polarity model. We iterate over these two steps to obtain refined G
D and G C . 5. Experimental Studies
In this section, we describe experimental results on existing benchmark data sets with extensive comparisons with state-of-the-art sentiment classification methods. We also present the effects of different experimental settings in the proposed statistical senti-ment parsing framework. 5.1 Experiment Set-up
We describe the data sets in Section 5.1.1, the experimental settings in Section 5.1.2, and the methods used for comparison in Section 5.1.3. 5.1.1 Data Sets. We conduct experiments on sentiment classification for sentence-level reviews from Rotten Tomatoes 3 and IMDb. 4 We balance the positive and negative instances in the training data set to mitigate the problem of data imbalance. Moreover, the Stanford Sentiment Treebank 5 contains polarity labels of all syntactically plausible phrases. In addition, we use the MPQA 6 data set for the phrase-level task. We describe these data sets as follows.
 reviews.
 positive and 5,331 negative snippets written by critics from Rotten Tomatoes. This data set is widely used as the benchmark data set in the sentence-level polarity classification task. The data source is the same as RT-C.

The sentences are parsed to parse trees. Then, 215,154 syntactically plausible phrases are extracted and annotated by workers from Amazon Mechanical Turk. The experimental settings of positive/negative classification for sentences are the same as in Socher et al. (2013).
 level sentiment classification, we filter out user reviews that are longer than 200 char-words. Following previous work on polarity classification, we use the review score to select highly polarized reviews. For the user reviews from Rotten Tomatoes, a negative review has a score &lt; 2.5 out of 5, and a positive review has a score &gt; 3.5 out of 5. comments and short summaries (usually a sentence) to summarize the overall sentiment expressed in the reviews. We use the review summaries as the sentence-level reviews.
The average length is 6.6 words. For user reviews of IMDb, a negative review has a score &lt; 4 out of 10, and a positive review has a score &gt; 7 out of 10.
 testing data set for RT-C. Note that we exclude these from the training data set (i.e., RT-C).
 RT-U).

Cardie 2005). The authors manually annotate sentiment polarity labels for the ex-examples in this data set. The average number of words per example is 3.1. 292 at http://goo.gl/WxTdPf . 5.1.2 Settings. To compare with other published results for PL05-C and MPQA, the training and testing regime (10-fold cross-validation) is the same as in Pang and Lee regime is the same as in Socher et al. (2013). We use C-TEST as the testing data for RT-C, and U-TEST as the testing data for RT-U and IMDB-U. There are a number of settings that have trade-offs in performance, computation, and the generalization power of our model. The best settings are chosen by a portion of training split data that serves as the validation set. We provide the performance comparisons using different experimental settings in Section 5.4.
 using more data leads to better performance. By default, all the training data is used in our experiments. We use the same size of training data in different methods for fair comparisons.
 2011) as the optimization algorithm in the learning process. The algorithm starts with randomly initialized parameters, and alternates between searching candidate sentiment trees and updating parameters of the ranking model. We treat one-pass scan of training data as an iteration.
 and the computation cost. Moreover, an appropriate beam size can prune unfavorable candidates. We set K = 30 in our experiments.
 over-fitting. The value used in the experiments is 0 . 01.
 ties when the fragment appears very few times. Hence, a minimum fragment frequency that is too small will introduce noise in the fragment learning process. On the other hand, a large threshold will lose much useful information. The minimum fragment
IMDB-U, and 2 for PL05-C and MPQA. expressions than unigrams and bigrams. So it would be useful to use long fragments to capture polarity information. According to the experimental results, as the maximum fragment length increases, the accuracy of sentiment classification increases. The maxi-mum fragment length is set to 7 words in our experiments. 5.1.3 Sentiment Classification Methods for Comparison. We evaluate the proposed statis-tical sentiment parsing framework on the different data sets, and compare the results with some baselines and state-of-the-art sentiment classification methods described as follows.
 timent classification task (Pang and Lee 2005). Though unigrams and bigrams are reported as the most effective features in existing work (Pang and Lee 2005), we use high-order n -gram (1  X  n  X  m ) features to conduct fair comparisons. Hereafter, m has the same meaning. We use LIBLINEAR (Fan et al. 2008) in our experiments because it can handle well the high feature dimension and a large number of training examples. the validation set.
 (MNB) often outperforms SVM for sentence-level sentiment classification. We uti-probability problem. High order n -gram (1  X  n  X  m ) features are considered in the experiments.
 of word sequences. It is used for sentiment analysis in Cui, Mittal, and Datar (2006).
Probability of generating sentence s is calculated by P ( s ) = Q w 0 denotes the word sequence w 0 ... w i  X  1 . We use Good-Turing smoothing (Good 1953) to overcome sparsity when estimating the probability of high-order n -gram. We train language models on negative and positive sentences separately. For a sentence, its polarity is determined by comparing the probabilities calculated from the positive and negative language models. The unknown-word token is treated as a regular word (denoted by &lt; UNK &gt; ). The SRI Language Modeling Toolkit (Stolcke 2002) is used in our experiment.
 sentence is decided by the voting of each phrase X  X  prior polarity. The polarity of phrases that have odd numbers of negation phrases in their ancestors is reversed. The results are reported by Nakagawa, Inui, and Kurohashi (2010).
 (2010). The polarity of a subjective sentence is deterministically decided based on rules, by considering the sentiment polarity of dependency subtrees. The polarity of a mod-ifier is reversed if its head phrase has a negation word. The decision rules are applied from the leaf nodes to the root node in a dependency tree. We use the results reported by Nakagawa, Inui, and Kurohashi (2010).
 method using conditional random fields with hidden variables. In this model, the polarity of each dependency subtree is represented by a hidden variable. The value of the hidden variable of the root node is identified as the polarity of the whole sentence.
The experimental results are reported by Nakagawa, Inui, and Kurohashi (2010). 294 encoders to learn vector space representations for multi-word phrases and predict sentiment distributions for sentences. We use the results with pre-trained word vectors learned on Wikipedia, which leads to better results compared with randomized word vectors. We directly compare the results with those in Socher et al. (2011). long phrases through matrix-vector recursive neural networks. This model assigns a vector and a matrix to every node in the parse tree. Matrices are regarded as opera-tors, and vectors capture the meaning of phrases. The results are reported by Socher et al. (2012, 2013). cess. In other words, the derivations that contain the fewest rules are used for all text spans. In addition, the dictionary rules are preferred to the combination rules if both of them match the same text span. The dynamic programming algorithm is used in the implementation. as N  X  not P ) learned from data. 5.2 Results of Sentiment Classification different data sets in Table 4. The top three methods on each data set are in bold, and the best methods are also underlined. The experimental results show that s.parser achieves better performance than other methods on most data sets.
 points from the best results of SVM, MNB, and LM, respectively. On PL05-C, the 4.4 percentage points from the best results of SVM, MNB, and LM, respectively.
Compared to Voting-w/Rev and HardRule, s.parser outperforms them by 16.4 per-centage points and 16.6 percentage points. The results indicate that our method significantly outperforms the baselines that use manual rules, as rule-based methods lack a probabilistic way to model the compositionality of context. Furthermore, s.parser achieves an accuracy improvement rate of 2.2 percentage points, 1.8 percentage points, and 0.5 percentage points over Tree-CRF, RAE-pretrain, and MV-RNN, respectively. On
SST, s.parser outperforms SVM, MNB, and LM by 3.4 percentage points, 1.4 percentage points, and 3.8 percentage points, respectively. The performance is better than MV-RNN with an improvement rate of 1.8 percentage points. Moreover, the result is compara-without depending on syntactic parsing results.
 results. More specifically, on the data set RT-U, s.parser outperforms the best results of
SVM, MNB, and LM by 1.7 percentage points, 2.9 percentage points, and 1.5 percentage points, respectively. On the data set IMDB-U, our method brings an improved accuracy SVM, MNB, and LM, respectively. We find that MNB performs better than SVM and
LM on the critics review data sets RT-C and PL05-C. Also, SVM and LM achieve better results on the user review data sets RT-U and IMDB-U. The s.parser is more robust for the different genres of data sets. 1.1 percentage points, and 14.8 percentage points from the best results of SVM, MNB, and LM, respectively. Compared with Voting-w/Rev and HardRule, s.parser achieves 4.5 percentage point and 4.4 percentage point improvements over them. As illustrated in Table 3, the size and length of sentences in MPQA are much smaller than those in the other four data sets. The RAE-pretrain achieves better results than other methods on this data set, because the word embeddings pre-trained on Wikipedia can leverage resources (i.e., Wikipedia), the accuracy of RAE on MPQA is 85.7%, which is lower than
Tree-CRF and s.parser. The results indicate that s.parser achieves the best result if no external resource is used. 296
The s.parser-LongMatch utilizes the dictionary rules and combination rules in the longest matching manner, whereas s.parser-w/oComb removes the combination rules ranking model and the combination rules play a positive role in the model. The ranking model learns to score parse trees by assigning larger weights to the rules that tend to ob-tain correct labels. Also, the combination rules generalize these dictionary rules to deal process unseen phrases. Furthermore, s.parser-LongMatch achieves better results than pronounced than the ranking model.
 words that appear many times in a document. The redundancy characteristics provide strong evidence for sentiment classification. Even though some phrases of a document are not estimated accurately, it can still result in a correct polarity label. However, for short text, such as a sentence, the compositionality plays an important role in sentiment classification. Tree-CRF, MV-RNN, and s.parser take compositionality into considera-tion in different ways, and they achieve significant improvements over SVM, MNB, and
LM. We also find that the high order n -grams contribute to classification accuracy on most of the data sets, but they harm the accuracy of LM on PL05-C. The high-order n -grams can partially solve compositionality in a brute-force way. 5.3 Effect of Training Data Size
We further investigate the effect of the size of training data for different sentiment clas-sification methods. This is meaningful as the number of the publicly available reviews is increasing dramatically nowadays. The methods that can take advantage of more training data will be even more useful in practice.
 set RT-C using different training data size. In order to make the figure clear, we only present the results of SVM/MNB/LM-1/5 here. As shown in Figure 9, we find that the size of training data plays an important role for all these sentiment classification methods. The basic conclusion is that the performance of all the methods rise as the data size increases, especially when the data size is smaller than a certain number. It than 200,000. The comparisons illustrate that s.parser significantly outperforms these increases. The convergence of s.parser X  X  performance is slower than the others. It in-data set. With more training data, s.parser learns more dictionary rules and combina-tion rules. These rules enhance the generalization ability of our model. Furthermore, contrast, the bag-of-words based approaches (such as SVM, MNB, and LM) cannot of the combination rules of s.parser leads to better performance, and take advantage sets. 5.4 Effect of Experimental Settings
In this section, we investigate the effects of different experimental settings. We show the results on the data set RT-C by only changing one factor and fixing the others. ment length. Specifically, Figure 10a indicates that a minimum fragment frequency probabilities for infrequent fragments. However, a minimum fragment frequency that is too large will discard too much useful information. As shown in Figure 10b, we find that accuracy increases as the maximum fragment length increases. The results illustrate 298 combination rules with a larger maximum fragment length, and long dictionary rules capture more precise expressions than unigrams. This conclusion is the same as that in Section 5.2.
 tion, and beam size affect the results. As shown in Figure 11a, we try a wide range of regularization parameters  X  in Equation (22). The results indicate that it is insensitive to the choice of  X  . Figure 11b shows the effects of different beam size K in the search process. When beam size K = 1, the optimization algorithm cannot learn the weights.
In this case, the decoding process is to select one search path randomly, and compute its polarity probabilities. The results become better as the beam size K increases. On the other hand, the computation costs increase. The proper beam size K can prune some candidates to speed up the search procedure. It should be noted that the sentence length also effects the run time. 5.5 Results of Grammar Learning
The sentiment grammar plays a central role in the statistical sentiment parsing frame-work. It is obvious that the accuracy of s.parser relies on the quality of the automatically learned sentiment grammar. The quality can be implicitly evaluated by the accuracy of sentiment classification results, as we have shown in previous sections. However, there combination rules to further illustrate the results of the sentiment grammar learning process as detailed in Section 4.2.
 learned from the data sets. As shown in Table 5, the results indicate that we can learn more dictionary rules and combination rules from the larger data sets. Although we learn more dictionary rules from RT-C than from IMDB-U, the number of combination rules learned from RT-C is less than from IMDB-U. It indicates that the language usage of RT-C is more diverse than that of IMDB-U. For SST, more rules are learned because of its constituent-level annotations. | G number of dictionary rules, and present the distribution of dictionary rule length. As illustrated in Figure 12a, we find that the relation between total number of dictionary rules | G D | and minimum fragment frequency  X  f obeys the power law, that is, the log appear few times, and only some of them appear frequently. Notably, all the syntacti-sentence-level data sets. Figure 12b shows the cumulative distribution of dictionary rule length l . It presents most dictionary rules as short ones. For all data sets except SST, more than 80% of dictionary rules are shorter than five words. The length distributions of data sets RT-C and IMDB-U are similar, whereas we obtain more high order n -grams from RT-U and SST.
 shows some dictionary rules with polarity probabilities learned by our method and 300 naive counting on RT-C. We notice that if we count the fragment occurrence number directly, some polarities of fragments are learned incorrectly. This is caused by the effect of context as described in Section 4.2.1. By taking the context into consideration, we obtain more reasonable polarity probabilities of dictionary rules. Our dictionary rule learning method takes compositionality into consideration, namely, we skip the count if there exist some negation indicators outside the phrase. This constraint tries to ensure that the polarity of fragments is the same as the whole sentence. As shown in the results, the polarity probabilities learned by our method are more reasonable and meet people X  X  intuitions. However, there are also some negative examples caused by  X  X alse subjective. X 
For instance, the neutral phrase to pay it tends to appear in negative sentences, and it is learned as a negative phrase. This makes sense for the data distribution, but it may lead to the mismatch for the combination rules.
 the data set RT-C. The first two examples are negation rules. We find that both switch negation and shift negation exist in data, instead of using only one negation type in and the corresponding polarity strength. For instance, the i do not like it very much is more negative than the i do not like it . As shown in Figure 13b, the  X  N  X  is not P  X  is a shift negation that reduces a fixed polarity strength to reverse the original polarity.
Specifically, the is not good is more negative than the is not great , as described in Sec-likely to decrease the polarity intensity. We find that this rule is a fixed intensification reduces more strength for stronger polarity. The last two rules in Figure 13e and Fig-polarity strength of the sub-fragments. These cases indicate that it is necessary to learn how the context performs compositionality from data. In order to capture the composi-tionality for different rules, we define the polarity model and learn parameters for each rule. This also agrees with the models of Socher et al. (2012) and Dong et al. (2014), 302 which use multiple composition matrices to make compositions specific and is an improvement over the recursive neural network that employs one composition matrix. 6. Conclusion and Future Work
In this article, we propose a statistical parsing framework for sentence-level sentiment classification that provides a novel approach to designing sentiment classifiers from a new perspective. It directly analyzes the sentiment structure of a sentence other than relying on syntactic parsing results, as in existing literature. We show that complicated phenomena in sentiment analysis, such as negation, intensification, and contrast, can be handled in a similar manner to simple and straightforward sentiment expressions in a unified and probabilistic way. We provide a formal model to represent the sentiment grammar built upon Context-Free Grammars. The framework consists of: (1) a parsing model to analyze the sentiment structure of a sentence; (2) a polarity model to calculate ranking model to select the best parsing result from a list of candidate sentiment parse trees. We show that the sentiment parser can be trained from the examples of sentences annotated only with sentiment polarity labels but without using any syntactic or senti-ment annotations within sentences. We evaluate the proposed framework on standard sentiment classification data sets. The experimental results show that the statistical sen-timent parsing notably outperforms the baseline sentiment classification approaches. in which many different grammars and parsing algorithms have been proposed in pre-viously published literature. It will be an interesting direction to apply and adjust more advanced models and algorithms from the syntactic parsing and the semantic parsing to our framework. We leave it as a line of future work. Second, we can incorporate target and aspect information in the statistical sentiment parsing framework to facilitate the target-dependent and aspect-based sentiment analysis. Intuitively, this can be done by introducing semantic tags of targets and aspects as new non-terminals in the sentiment grammar and revising grammar rules accordingly. However, acquiring training data will be an even more challenging task, as we need more fine-grained information.
Third, as the statistical sentiment parsing produces more fine-grained information (e.g., structure trees), we will have more opportunities to generate better opinion summaries.
Moreover, we are interested in jointly learning parameters of the polarity model and the parsing model from data. Last but not the least, we are interested in investigating the domain adaptation, which is a very important and challenging problem in sentiment analysis. Generally, we may need to learn domain-specific dictionary rules for different domains, whereas we believe combination rules are mostly generic across different domains. This is also worth consideration for further study.
 Acknowledgments 304 306
