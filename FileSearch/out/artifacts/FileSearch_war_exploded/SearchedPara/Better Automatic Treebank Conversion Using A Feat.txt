 In the field of syntactic parsing, research efforts have been put onto the task of automatic conversion of a treebank ( source treebank ) to fit a different stan-dard which is exhibited by another treebank ( tar-get treebank ). Treebank conversion is desirable pri-marily because source-style and target-style annota-tions exist for non-overlapping text samples so that a larger target-style treebank can be obtained through such conversion. Hereafter, source and target tree-banks are named as heterogenous treebanks due to their different annotation standards. In this paper, we focus on the scenario of conversion between phrase-structure heterogeneous treebanks (Wang et al., 1994; Zhu and Zhu, 2010).

Due to the availability of annotation in a source treebank, it is natural to use such annotation to guide treebank conversion. The motivating idea is illustrated in Fig. 1 which depicts a sentence anno-tated with standards of Tsinghua Chinese Treebank (TCT) (Zhou, 1996) and Penn Chinese Treebank (CTB) (Xue et al., 2002), respectively. Suppose that the conversion is in the direction from the TCT-style parse (left side) to the CTB-style parse (right side). The constituents vp:[  X  /will  X   X  /surrender], dj:[  X   X  /enemy  X  /will  X   X  /surrender], and np:[  X   X  /intelligence  X   X  /experts] in the TCT-style parse strongly suggest a resulting CTB-style parse also bracket the words as constituents. Zhu and Zhu (2010) show the effectiveness of using brack-eting structures in a source treebank (source-side bracketing structures in short) as parsing constraints during the decoding phase of a target treebank-based parser.

However, using source-side bracketing structures as parsing constraints is problematic in some cases. As illustrated in the shadow part of Fig. 1, the TCT-style parse takes  X   X   X  /deems X  as the right bound-ary of a constituent while in the CTB-style parse,  X   X   X   X  is the left boundary of a constituent. Ac-cording to the criteria used in Zhu and Zhu (2010), any CTB-style constituents with  X   X   X   X  being the left boundary are thought to be inconsistent with the bracketing structure of the TCT-style parse and will be pruned. However, if we prune such  X  X nconsistent X  constituents, the correct conversion result (right side of Fig. 1) has no chance to be generated.

The problem comes from binary distinctions used in the approach of Zhu and Zhu (2010). With bi-nary distinctions, constituents generated by a target treebank-based parser are judged to be either con-sistent or inconsistent with source-side bracketing structures. That approach prunes inconsistent con-stituents which instead might be correct conversion side bracketing structures as guiding information. Meanwhile, we aim to avoid using binary distinc-tions. To achieve such a goal, we propose to use a feature-based approach to treebank conversion and to encode source-side bracketing structures as a set of features. The advantage is that inconsistent con-stituents can be scored with a function based on the features rather than ruled out as impossible.
To test the efficacy of our approach, we conduct experiments on conversion from TCT to CTB. The results show that our approach achieves a 1 . 31% ab-solute improvement in conversion accuracy over the approach used in Zhu and Zhu (2010). 2.1 Generic System Architecture To conduct treebank conversion, our approach, over-all speaking, proceeds in the following steps. Step 1: Build a parser (named source parser ) on a Step 2: Build a parser on pairs of golden target-Step 3: In the testing phase, the heterogeneous
To instantiate the generic framework described above, we need to decide the following three factors: (1) a parsing model for building a source parser, (2) a parsing model for building a heterogeneous parser, and (3) features for building a heterogeneous parser. In principle, any off-the-shelf parsers can be used to build a source parser, so we focus only on the latter two factors. To build a heterogeneous parser, we use feature-based parsing algorithms in order to easily incorporate features that encode source-side bracketing structures. Theoretically, any feature-based approaches are applicable, such as Finkel et al. (2008) and Tsuruoka et al. (2009). In this pa-per, we use the shift-reduce parsing algorithm for its simplicity and competitive performance. 2.2 Shift-Reduce-Based Heterogeneous Parser The heterogeneous parser used in this paper is based on the shift-reduce parsing algorithm described in Sagae and Lavie (2006a) and Wang et al. (2006). Shift-reduce parsing is a state transition process, where a state is defined to be a tuple h S, Q i . Here, S is a stack containing partial parses, and Q is a queue containing word-POS pairs to be processed. At each state transition, a shift-reduce parser either shifts the top item of Q onto S , or reduces the top one (or two) items on S .

A shift-reduce-based heterogeneous parser pro-ceeds similarly as the standard shift-reduce parsing algorithm. In the training phase, each target-style parse tree in the training data is transformed into a binary tree (Charniak et al., 1998) and then de-composed into a (golden) action-state sequence. A classifier can be trained on the set of action-states, where each state is represented as a feature vector. In the testing phase, the trained classifier is used to choose actions for state transition. Moreover, beam search strategies can be used to expand the search space of a shift-reduce-based heterogeneous parser (Sagae and Lavie, 2006a). To incorporate in-formation on source-side bracketing structures, in both training and testing phases, feature vectors rep-resenting states h S, Q i are augmented with features that bridge the current state and the corresponding source-style parse. 2.3 Features This section describes the feature functions used to build a heterogeneous parser on the training data of a target treebank. The features can be divided into two groups. The first group of features are derived solely from target-style parse trees so they are referred to as target side features . This group of features are completely identical to those used in Sagae and Lavie (2006a).

In addition, we have features extracted jointly from target-style and source-style parse trees. These features are generated by consulting a source-style parse (referred to as t target-style parse into an action-state sequence. Here, s stack, and q end of the queue. We refer to these features as heterogeneous features .
 Constituent features F This feature schema covers three feature functions: F ( s 1 , t s ) , F c ( s 2 , t s ) , and F c ( s 1  X  s 2 decide whether partial parses on stack S correspond to a constituent in the source-style parse t F ( s i , t s )=+ if s i has a bracketing match (ignoring grammar labels) with any constituent in t represents a concatenation of spans of s Relation feature F We first position the lowest node N which dominates the span of s function F the relationship of N is identical to or a sibling of N F ( N s ( s 1 ) , N s ( s 2 )) =+ .
 Frontier-words feature F A feature function which decides whether the right frontier word of s phrase in t any phrase which dominates no other phrases. Path feature F Syntactic path features are widely used in the litera-ture of semantic role labeling (Gildea and Jurafsky, 2002) to encode information of both structures and grammar labels. We define a string-valued feature function F frontier word of s
To better understand the above feature func-tions, we re-examine the example depicted in Fig. 1. Suppose that we use a shift-reduce-based heterogeneous parser to convert the TCT-style parse to the CTB-style parse and that stack S currently contains two partial parses: s  X   X  )] and s 1 : (VV  X   X  ). In such a state, we can see that spans of both s constituents in t N N values of these features are collected in Table 1. 3.1 Data Preparation and Performance Metric In the experiments, we use two heterogeneous tree-banks: CTB 5.1 and the TCT corpus released by the CIPS-SIGHAN-2010 syntactic parsing competi-two corpora, that is, articles 001-270 and 400-1151 (18,100 sentences, 493,869 words) of CTB 5.1 and the training data (17,529 sentences, 481,061 words) of TCT.

To evaluate conversion accuracy, we use the same test set (named Sample-TCT ) as in Zhu and Zhu (2010), which is a set of 150 sentences with manually assigned CTB-style and TCT-style parse trees. In Sample-TCT, 6 . 19% (215/3473) CTB-style constituents are inconsistent with respect to the TCT standard and 8 . 87% (231/2602) TCT-style con-stituents are inconsistent with respect to the CTB standard.

For all experiments, bracketing F1 is used as the performance metric, provided by EVALB 3 . 3.2 Implementation Issues To implement a heterogeneous parser, we first build a Berkeley parser (Petrov et al., 2006) on the TCT training data and then use it to assign TCT-style parses to sentences in the CTB training data. On the  X  X pdated X  CTB training data, we build two shift-reduce-based heterogeneous parsers by using max-imum entropy classification model, without/with beam search. Hereafter, the two heterogeneous parsers are referred to as Basic-SR and Beam-SR , re-spectively.

In the testing phase, Basic-SR and Beam-SR con-vert TCT-style parse trees in Sample-TCT to the CTB standard. The conversion results are evalu-ated against corresponding CTB-style parse trees in Sample-TCT. Before conducting treebank conver-sion, we apply the POS adaptation method proposed in Jiang et al. (2009) to convert TCT-style POS tags in the input to the CTB standard. The POS conver-sion accuracy is 96 . 2% on Sample-TCT. 3.3 Results Table 2 shows the results achieved by Basic-SR and Beam-SR with heterogeneous features being added incrementally. Here, baseline represents the systems which use only target side features. From the table we can see that heterogeneous features improve con-version accuracy significantly. Specifically, adding the constituent ( F SR) achieves a 2 . 79% ( 3% ) improvement, adding the relation ( F yields a 0 . 79% ( 0 . 98% ) improvement, and adding the path ( F provement. The path feature is not so effective as expected, although it manages to achieve improve-ments. One possible reason lies on the data sparse-ness problem incurred by this feature.

Since we use the same training and testing data as in Zhu and Zhu (2010), we can compare our approach directly with the informed decoding ap-proach used in that work. We find that Basic-SR achieves very close conversion results ( 84 . 05% vs. 84 . 07% ) and Beam-SR even outperforms the in-formed decoding approach ( 85 . 38% vs. 84 . 07% ) with a 1 . 31% absolute improvement. For phrase-structure treebank conversion, Wang et al. (1994) suggest to use source-side bracketing structures to select conversion results from k-best lists. The approach is quite generic in the sense that it can be used for conversion between treebanks of different grammar formalisms, such as from a de-pendency treebank to a constituency treebank (Niu et al., 2009). However, it suffers from limited variations in k-best lists (Huang, 2008). Zhu and Zhu (2010) propose to incorporate bracketing struc-tures as parsing constraints in the decoding phase of a CKY-style parser. Their approach shows signifi-cant improvements over Wang et al. (1994). How-ever, it suffers from binary distinctions (consistent or inconsistent), as discussed in Section 1.
The approach in this paper is reminiscent of co-training (Blum and Mitchell, 1998; Sagae and Lavie, 2006b) and up-training (Petrov et al., 2010). Moreover, it coincides with the stacking method used for dependency parser combination (Martins et al., 2008; Nivre and McDonald, 2008), the Pred method for domain adaptation (Daum  X  e III and Marcu, 2006), and the method for annotation adap-tation of word segmentation and POS tagging (Jiang et al., 2009). As one of the most related works, Jiang and Liu (2009) present a similar approach to conversion between dependency treebanks. In con-trast to Jiang and Liu (2009), the task studied in this paper, phrase-structure treebank conversion, is rel-atively complicated and more efforts should be put into feature engineering. To avoid binary distinctions used in previous ap-proaches to automatic treebank conversion, we pro-posed in this paper a feature-based approach. Exper-iments on two Chinese treebanks showed that our approach outperformed the baseline system (Zhu and Zhu, 2010) by 1 . 31% .
 We thank Kenji Sagae for helpful discussions on the implementation of shift-reduce parser and the three anonymous reviewers for comments. This work was supported in part by the National Science Founda-tion of China (60873091; 61073140), Specialized Research Fund for the Doctoral Program of Higher Education (20100042110031), the Fundamental Re-search Funds for the Central Universities and Nat-ural Science Foundation of Liaoning Province of China.

