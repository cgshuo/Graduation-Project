
Previous studies have shown mining closed patterns pro-vides more benefits than mining the complete set of frequent patterns, since closed pattern mining leads to more compact results and more efficient algorithms. It is quite useful in a data stream environment where memory and computation power are major concerns. This paper studies the prob-lem of mining closed sequential patterns over data stream sliding windows. A synopsis structure IST (Inverse Closed Sequence Tree) is designed to keep inverse closed sequen-tial patterns in current window. An efficient algorithm Se-qStream is developed to mine closed sequential patterns in stream windows incrementally, and various novel strate-gies are adopted in SeqStream to prune search space ag-gressively. Extensive experiments on both real and syn-thetic data sets show that SeqStream outperforms PrefixS-pan, CloSpan and BIDE by a factor of about one to two orders of magnitude.
In many real applications such as web click stream anal-ysis, network monitoring, telecommunication data manage-ment and sensor networks, data are generated in the form of data streams [4]. A data stream is a continuous, unbounded flow of data elements. Mining data streams introduces a lot of new challenges due to the characteristics of stream data [10]. First, data streams are continuous, high-speed and un-bounded. Keeping all streaming data in memory (even disk) is impossible, and nearly real time requirements are often posed on mining algorithms. Second, since distribution of data is varying at different time, analysis results, such as fre-quent patterns and classification models, often keep chang-ing. The results given by a mining algorithm should be able to reflect recent data changes.

In this work, we explore how to mine sequential patterns over data stream windows. A sequence is an ordered list of items. The problem of sequential pattern mining is to find frequent repeating sequences in a sequence database. A se-quence is called a frequent sequential pattern if it occurs in no less than a user-specified number ( min sup )ofse-quences. In a data stream environment, a sequence database is generated dynamically from continuous data elements. A data stream sliding window of size w is composed of w re-cent data elements, for example the elements generated in past three days. Mining algorithms adopting sliding win-dow models [5] can capture recent data changes and trends users mostly care about. A data stream window continu-ously changes when new elements come and obsolete el-ements are removed. The problem is how to efficiently mine sequential patterns in a continuously changed window. There have been several efficient algorithms [15, 6, 20, 7] developed to mine frequent sequential patterns over data streams. However, existing methods suffer from the fol-lowing limitations.

First, most methods mine the set of all frequent patterns [7] or a set of approximate patterns whose supports are ap-proximately estimated [15, 6, 20]. For an approximate so-lution, there may be a lot of false positive and false negative patterns. Obviously, it is not perfect, since users may be frequently annoyed by false patterns. On the other hand, methods mining all frequent patterns may produce a mas-sive number of frequent patterns when the min sup value is low or there are long frequent sequences. As an example, there are only two sequences { a 1 a 2 ...a 80 , a 1 a 2 ...a in a database and the min sup value is 1. There will be 2 80 -1 frequent patterns { a 1 :2, a 2 :2, ..., a 79 :1, a a 1 a 2 :2, ..., a 1 a 2 ...a 80 :1 } in the database. Obviously, it is difficult for users to find potential knowledge in such a huge set of patterns. Moreover, in a data stream environ-ment, frequent patterns often need to be maintained in mem-ory to answer user queries. To store or enumerate so many frequent sequences is intractable for current hardware. Pre-vious studies [22, 21] have proposed mining closed patterns to alleviate this problem. A frequent sequential pattern is closed if there does not exist a frequent supersequence with the same support. The number of closed patterns may be or-ders of magnitude smaller than that of all frequent patterns, and the exact support of a frequent subsequence can be eas-ily obtained from the set of closed patterns by finding the closed superpattern with the largest support. In the above example, there are only two closed patterns { a 1 a 2 ...a a
Second, most stream sequence mining methods [15, 6, 20] regard each coming data element as a new sequence in-serted into current sequence database and update sequential patterns over the updated database. However, in many ap-plications, such as web click stream analysis and customer purchase sequence mining, a new element may be a tail sub-sequence of an existing sequence. For example, when a web user clicks a new page, the page-id should be appended to the user X  X  browsing history sequence instead of regarding the page-id as a new sequence with only one item. In ad-dition, at a time interval (such as one second), there may be many active users who update their browsing sequences simultaneously. Thus, a data element generated at a time interval may include many items from different users. The problem setting adopted by existing methods is a special-ization of the new case, since inserting a new sequence can be regarded as appending a sequence to an empty sequence. Existing algorithms can not be easily adapted to deal with the more general problem.

Thus, in this work, we explore mining closed sequential patterns over stream sliding windows and adopt the more general problem setting to overcome the limitations of ex-isting methods. To the best of our knowledge, this is the first piece of work for mining closed sequences over data streams. In this paper, a synopsis structure IST is designed to keep closed sequential patterns in memory. An IST is a prefix tree, and it has three kinds of nodes: c-nodes, t-nodes and i-nodes. Closed sequential patterns in the inverse se-quences of current sliding window are saved in an IST. It can be shown that there is a bijective relation between the set of closed patterns of a sequence database and that of its inverse database. By keeping inverse closed patterns in IST and storing sequences in a sliding window in an inverse order, a sliding operation is transformed from appending a new stream element to the back (removing an obsolete ele-ment from the front) of current sliding window to inserting the new element to the front (removing the obsolete element from the back) of current window. This greatly improves the performance of sliding operations due to the reduction of tree node extension operations. An efficient algorithm SeqStream is developed to mine closed patterns incremen-tally. Various new strategies are proposed to prune search space aggressively. Extensive experiments on both real and synthetic databases show that SeqStream outperforms Pre-fixSpan, CloSpan and BIDE by a factor of about one to two orders of magnitude.
 Related Work For frequent sequential pattern mining, effi-cient algorithms, such as GSP [2], PrefixSpan [18], SPADE [23] and SPAM [3] were developed. CloSpan [22] and BIDE [21] are two fast algorithms for mining closed se-quential patterns.

According to mining results presented to users, meth-ods for mining sequential patterns over data streams can be divided into two categories: approximate methods [15, 6, 20, 9] and exact ones [7, 11, 12]. In [15], the authors proposed a sequence alignment based approach SMDS for mining approximate sequential patterns in web usage data streams. eISeq [6] is another approximate sequential pattern extraction method for data streams. All currently significant sequences are maintained in a monitoring tree. Upon re-ceiving a new sequence s , eISeq updates supports of subse-quences of s using an approximate method. In [20], SPEED was proposed to manage the frequencies of sequential pat-terns in a tilted time window manner. SSM [9] uses three types of data structures D-List, PLWAP tree and FSP-tree to mine frequent sequences over data streams in a batch mode. The above four algorithms can only present approximate an-swers upon users X  requests.

MILE [7] is a sequential pattern mining algorithm across multiple streams. The problem definition used by MILE is completely different from that defined in this work. Inc-SPAM [11] is a stream sliding window algorithm for mining all sequential patterns. It is based on SPAM [3] which uses a vertical format representation of sequences. Like SPAM, IncSPAM suffers from huge memory consumption. In [12], the authors proposed a method for mining the complete set of sequential patterns in recent time period of interest.
Other related work includes [19], which proposed a reservoir sampling algorithm over data streams, and some incremental algorithms [8, 13, 14, 16, 17] which are de-signed to maintain the complete set of sequential patterns upon incremental update.
Let I = { i 1 ,i 2 ,...,i N } be a set of all items .A sequence is an ordered list of items 1 , which is denoted by s 1 s 2 ...s l , where s j is an item, i.e. s j  X  I for 1  X  j  X  l . U = { u 1 ,u 2 , ..., u M } is a set of all users . Each user has a unique identifier and a sequence. Some-times, the identifier of a user is used to reference its se-quence. The inverse sequence of a sequence s , denoted by s , can be obtained by inverting the item order of s .For example, the inverse sequence of abacd is dcaba .A sequence  X  =  X  1  X  2 ... X  l is called a subsequence of an-other sequence  X  =  X  1  X  2 ... X  m , if there exist integers 1  X  j 1 &lt;j 2 &lt; ... &lt; j l  X  m , such that  X  1 =  X   X  sequence of  X  , denoted as  X   X  .If  X  ( )  X  and  X  =  X  ,  X  is a proper subsequence (supersequence) of  X  , denoted as  X   X  (  X   X  ) . For example, aba is a supersequence of aa , and it is also a proper supersequence of aa .
A data stream is a continuous, unbounded flow of data elements. At each time interval (such as one second), there is a data element generated and each time interval is as-signed an identifier t i ( i  X  1 ). t 1 is the start time interval of a data stream. t i is later than t j if i&gt;j . Here, we as-sume that at a time interval t , each user generates at most one item. This is a reasonable assumption, since we can al-ways find such an interval. A data element generated at a time interval t , denoted as e t ,isasetof( user id, item ) pairs, in which each user identifier is distinct with others. The el-ement size of e t is the number of pairs in it. For example, denotes users u 1 and u 5 have items i 2 and i 3 generated re-spectively, and the element size is 2. A data stream win-dow of size w contains w most recent data elements. Figure 1 shows a stream window of size 8 at t 9 which contains el-ements generated from t 2 to t 9 . At each time interval, there is a new element added to a data stream window and an ob-solete element generated at w time intervals ago is removed from the window.

The set of sequences in current stream window is called the current database , denoted by D . The current database contained in the stream window in Figure 1 has 6 sequences, { f bda , abae , f bcda , bcdae , ebcda , aeac } .The support of a sequence  X  in D , denoted by sup D (  X  ) ,is the number of sequences in D that contain  X  . If the sup-port of a sequence  X  is greater than or equal to a minimal support  X  (  X &gt; 0 ),  X  is call a frequent sequential pat-tern . A frequent sequential pattern  X  is closed , if there does not exist a frequent sequential pattern  X  , such that sup D (  X  )= sup D (  X  ) and  X   X  . Let the minimal sup-port  X  be 3, the set of all frequent sequential patterns in the sliding window shown in Figure 1 has 17 patterns { a :6, ae :3, b :5, ba :5, bc :3, bca :3, bcd :3, bcda :3, bd :4, bda :4, c :4, ca :3, cd :3, cda :3, d :4, da :4, e :4 } . The set of closed sequential patterns in the slid-ing window includes only 7 patterns, { a :6, ae :3, c :4, ba :5, bda :4, bcda :3, e :4 } .
 Definition 1 (Problem of Mining Closed Sequential Pat-terns over a Stream Window) The problem is to mine closed sequential patterns in the database contained in current sliding window, which includes most recent w data stream elements.

In order to better present SeqStream algorithm, the fol-lowing definitions are needed. Given two sequences  X  =  X  1  X  2 ... X  l and  X  =  X  1  X  2 ... X  m , s =  X   X  means  X  concatenates with  X  . For a sequence s = s 1 s 2 ...s n  X  =  X  1  X  2 ... X  m (1  X  m  X  n ) is called a prefix of s if s =  X  i (1  X  i  X  m ) . As an example, a , ab , aba and abac are all prefixes of abac .An s -projected database in D [18] is defined as D s = {  X  |  X   X  D,  X  =  X   X  such that  X  is the minimum prefix (of  X  ) containing s } . The size of s -projected database D s , denoted as R ( D s ) , is the number of items in the database. In the above definition,  X  can be empty (denoted by  X  ). For example, b -projected database in the database in the sliding window of Figure 1 is { da , ae , cda , cdae , cda } and the e -projected database is {  X  ,  X  , bcda , ac } . The size of b -projected database is 14 and that of e -projected database is 6.

The inverse database of D , denoted by D , is defined as { s | s  X  D } , i.e., the set of inverse sequences of sequences in D . Let the elements generated at current time interval t tively. The database in current sliding window after insert-ing e t c (but before removing e t c  X  w ) is called an interme-diate database , denoted by D . In the inverse database of D , the set of sequences from users that appear in e t denoted by D + , and the set of sequences from users that moval database , denoted by D  X  . In the running exam-ple, before removing e t 2 , the intermediate database D af-ter inserting e t 10 is { f bda , abaec , f bcdac , bcdae , ebcdaf , aeac } . The inverse database of D , i.e. D ,is { adbf , ceaba , cadcbf , eadcb , f adcbe , caea } . The insertion database and removal database are { ceaba , cadcbf , f adcbe } , and { cadcbf , eadcb , f adcbe } respectively.
Figure 2. The sliding window storing inverse sequences at t 9
At current time interval t c , there is a new element e t generated. The element should be inserted into current slid-ing window, and the obsolete element e t c  X  w should be re-moved from current window. The set of closed patterns in the new window needs to be mined. In order to eliminate the cost of mining closed patterns from scratch, a succinct data structure IST is designed to keep inverse closed sequential patterns in a sliding window. An IST is a prefix tree which is built upon D , the inverse database of D in current slid-ing window. It is this feature that makes it possible that SeqStream algorithm can deal with element removals ef-ficiently without expensive node extension operations. In this section, we first introduce the properties of an inverse sequence database. Then the structure of inverse sequence tree is described. Finally, the SeqStream algorithm is de-signed.
The following theorem provides the basis for mining the inverse sequence database of a sliding window.
 Theorem 1 ( Closed Pattern Equivalence ) Let the sets of closed sequential patterns of the sequence database D in a sliding window and its inverse sequence database D be P and  X  P respectively. There is a bijection relation between P and  X  P such that for each pattern p  X  P , there is a pattern p  X   X  P which is the inverse sequence of p and sup D ( p )= sup D ( p ) , and vice versa. 2
According to Theorem 1, we can store the sequences in current sliding window in an inverse order and mine closed patterns in it. The closed patterns in D can be obtained eas-ily by inverting patterns in  X  P . The sliding window in Figure 2 shows the sliding window in Figure 1 after inverting se-quences in it.
If we store the sequences in a sliding window in an in-verse order, the insertion of a new element is changed from appending it to the tail of the window to inserting the ele-ment to the front of the window, and the removal of an ob-solete element is changed from deleting the element from the front of the window to removing the element from the back of the window. Keeping the closed patterns in D in an IST has one key benefit. The removal of an element from the sliding window does not need to extend any IST node. This will be clear in the following sections.
An IST is used to keep closed sequential patterns in the inverse sequence database of current sliding window. Fig-ure 3(a) shows the IST for the sliding window in Figure 2. It is a rooted prefix tree and represents part of sequence space of D which includes all frequent closed sequences and some other frequent sequences that are used to facilitate the maintenance of IST when current window is moved.
A node n of an IST corresponds a sequence that starts from the root node to that node, and the sequence is denoted by s n . The root node of an IST is a NULL node which represents an empty sequence  X  . Except for the root node, nodes of an IST can be divided into three types.  X  c-node (closed node): If s n is a closed sequential pat- X  t-node (termination node): n is a t-node if 1) there  X  i-node (intermediate node): If s n is frequent, n is nei-Each node n in an IST stores its type, item, support, ID-Sum, PDBSize and tag, where IDSum is the sum of the identifiers of users whose sequences contain s n and PDB-Size is R ( D s n ) . The usage of these fields will be introduced when SeqStream is described.

In order to check whether a node is a t-node, we need to compare the projected database of that node with those of other nodes. According to the property [22] that, for two sequences  X  and  X  ,  X   X  , D  X  = D  X  if and only if R ( D  X  = R ( D  X  ) , we can compare their PDBSizes instead.
Here, we give an example to show how an IST changes when the corresponding sliding window is moved. In the running example, after e t 10 is inserted to and e t 2 is deleted from the window in Figure 2, the IST of the new window is shown in Figure 3(b). After the movement, some new nodes have been added to the old IST (Figure 3(a)) and some nodes have been dropped. Furthermore, supports of some nodes have changed and some nodes have changed their types. For example, node a at depth 2 (under c )isa newly added node and node b at depth 4 in Figure 3(a) has been deleted. Node e at depth 1 has changed from a c-node to an i-node.

Although part of the IST has changed after the window is moved, the structure of the tree is not changed a lot. Most of nodes in the original tree are kept and only part of them change their supports. In frequent sequence mining algo-rithms [22, 21, 18], search space extension is expensive. It is because projected databases need to be constructed and support counting of items in them should be made. An IST keeps search space of the past window and it is often slightly changed after one slide of the window. Thus a nat-ural question is how could we utilize the IST of the past window to reduce the cost of search space extension when calculating closed patterns in the new window? SeqStream is such an algorithm that makes full use of a past IST to get an up-to-date IST.
There are two main tasks in SeqStream. The first one is to efficiently update supports of tree nodes under element insertion and removal. The second one is to exclude nodes that do not need to update or extend to eliminate the re-lated support counting and node extension costs as much as possible. SeqStream utilizes the insertion database and re-moval database to update the support information of current IST. These two databases are usually much smaller than the whole database in the sliding window. Therefore the sup-port update task can be completed quickly. For the second task, SeqStream adopts various pruning strategies to safely skip nodes that do not need to be handled.
 Algorithm 1 SeqStream( root, elem ) Input: (1) root : the root node of current IST Output: the updated IST Method:
Phase I: Element Insertion 1: get D + and D from D and elem ; 2: call ElemInsert( root, D ,D + , elem );
Phase II: Element Removal 3: get D  X  from D and elem ; 4: call ElemRemove( root, X ,D  X  );
Phase III: State Update 5: call StateUpdate( root ); The outline of SeqStream is shown in Algorithm 1. There are three phases in SeqStream. In the first phase, it inserts items in elem to the front of sequences and gets the insertion database D + . ElemInsert is called to update sup-ports of IST nodes and extend the IST to reflect the insertion of the element to current window. In the second phase, the obsolete element is dropped from the sliding window and ElemRemove is called to update the IST. After the first two phases, nodes in the updated IST have had up-to-date sup-ports and some of the nodes may have changed their types. Thus, in the third phase, it updates types of tree nodes with the help of a hashing index. In the following subsections, we explain the algorithms line by line. 3.3.1 Stream Element Insertion When a new element is inserted to current sliding window, ElemInsert is called to update the IST. The method is shown in Algorithm 2. It first calls IncUpdateIST to update at-tribute values (including support, IDSum and PDBSize) of affected nodes, then it calls ExtendIST to extend newly fre-quent nodes or changed t-nodes, since some initially infre-quent sequences may become frequent after the insertion Algorithm 2 ElemInsert( root, D ,D + ,elem ) Input: (1) root : the root node of current IST Output: the IST after element insertion Method: 1: call IncUpdateIST( root, X ,D + ); 2: call ExtendIST( root,  X , D ); Procedure IncUpdateIST( n, s, D + s ) 3: if n is the root node then /* Depth-1 Node Pruning */ 4: let NS be the set of child nodes whose items appear 5: else 6: let NS be the set of child nodes of n ; 7: for each node t  X  NS do 8: construct s t -projected database in D + s ; 9: update attribute values of t ; 10: record potential local freq-items when scanning D + s 11: for each non-termination node t  X  NS do 12: if t does not satisfy CI-Node Pruning condition then 13: IncUpdateIST ( t, s t ,D + s t ) ; 14: set n  X  X  tag value; Procedure ExtendIST( n, s, D s ) 15: if there are some potential local freq-items then 16: scan D s to count these freq-items; 17: add child nodes for new frequent items; 18: for each node t such that t is changed t-node or new 19: make the full projection of t ; 20: if t is a changed t-node or new frequent node then 21: extend t ; 22: else and initially t-nodes may change their types now.
In IncUpdateIST, only sequences in the insertion database is used. The number of these sequences is equal to the number of items in the new element. At lines 3-4, if node n is the root node, we let NS be the set of nodes whose items occur in the new element. If a node whose item does not appear in the element, it is skipped according to the following theorem.
 Theorem 2 ( Depth-1 Node Pruning ) If a depth-1 node whose item does not occur in the newly coming element, nodes under that node will not change their attribute val-ues (support, IDSum and PDBSize) and any t-node under it does not change its type after inserting the element.
Thus, a large part of the tree may be skipped by this property. At lines 7-8, it constructs projected databases for nodes in NS . The projected databases 3 can be collectively built by scanning D + s once. If n is the root node, projected databases of its child nodes can be constructed specially to eliminate irrelevant projected sequences. For a node t at depth 1, only sequences in D + whose first items are the same as t.item are used to construct t  X  X  projected database. It is because other sequences do not contribute to the change of attribute values (including support, IDSum and PDBSize) of t .

In the process of projected database construction, the at-tribute values of the nodes can be updated. The attribute values of node t can be updated as follows. If s t appears in the original sequence, the updated sequence does not contribute to its support and IDSum changes. However, its PDBSize may be changed. If s t does not appear in the orig-inal sequence, its support, IDSum and PDBSize may all be changed. As an example, let s t be ac , an updated se-quence be a bcac whose first item is a newly added item. Since ac occurs in the original sequence bcac , the up-dated sequence does not contribute to the support and ID-Sum increase of t while t.PDBSize is increased by 2.
When scanning D + s to build projected databases (lines 7-9), potential local freq-items are also recorded (line 10). A potential local freq-item i here denotes an initially infre-quent sequence s i which has support increased after the element insertion. Supports of these local items will be counted in ExtendIST. A full projection of a sequence  X  is a projected database of  X  in D . A changed t-node refers to a node which has changed its PDBSize or support. If the support and PDBSize of a t-node do not change, exten-sion of the node in ExtendIST is avoided according to the following theorem.
 Theorem 3 ( Termination Node Pruning ) After inserting a new element, if the PDBSize and support of a t-node do not change, it will keep to be a t-node.

At line 12, a node (c-node or i-node) that has its support and PDBSize unchanged is skipped according to Theorem 4. It is because there should be no new frequent node that will be added under that node and t-nodes under it do not need extension. At line 13, the algorithm is called recur-sively for internal nodes in NS that do not satisfy the prun-ing condition. Finally, if there are some potential local freq-items, changed t-nodes or at least one child node t which needs a full projection, n is tagged as a node that needs a full projection used in tree node extension, i.e., t.tag  X  true (line 14).
 Theorem 4 ( CI-Node Pruning ) After inserting a new ele-ment, if the PDBSize and support of a c-node or t-node n Algorithm 3 ElemRemove( n, s, D  X  s ) Input: (1) n : current node of the IST Output: the IST after element removal Method: 1: for each child node t of n do 2: construct s t -projected database in D  X  s ; 3: update attribute values of t ; 4: if t.sup &lt;  X  then 5: delete t and its subtree; 6: for each child node t of n s.t. D  X  s t has non-empty se-7: ElemRemove( t, s n t.item ,D  X  s n t.item ); do not change, the infrequent sequences with n as a prefix will not change their supports, and t-nodes under that node will not change their types too.

In ExtendIST, if there are some potential local freq-items under n , it scans D s once to count them (lines 15-16). If they become frequent, new child nodes of n are inserted (line 17). For those changed t-nodes and new frequent nodes or nodes that have some changed t-nodes or potential frequent nodes as descendants (i.e., tag = true), the proce-dure computes their full projections (line 19). For a newly frequent node or changed termination node, the procedure extends it (line 21). There are two alternative methods to extend a node. The simpler one is to directly extend all the frequent nodes under that node without closure check-ing. If there are some t-nodes under the node, they will be dropped in StateUpdate routine. The other method is to check whether a newly added node is a t-node, if it is, stop extending the node further. To identify a t-node, similar to the method used in [22], an auxiliary hash index can be used to compare the PDBSize of a new node with those of nodes in the hash index. Initially, the hash index is filled with the nodes of the IST after calling IncUpdateIST. Building the index and comparing each new node with existing ones do not come without cost. It is useful to do these when there are long patterns in the sliding window, since long patterns may generate numerous non-closed patterns. In this work, when the depth of the initial IST is greater than a heuris-tic value (15 in our implementation), the second method is used; otherwise, the first method is used. Finally, the proce-dure recurses on those nodes that have their full projection tags as true (line 23). 3.3.2 Stream Element Removal After the new element is inserted to the front of sliding win-dow, the obsolete element generated at t c  X  w is removed Algorithm 4 StateUpdate( n ) Input: (1) n : current node of the IST Output: the final IST for current sliding window Method: 1: if n = root then 2: n.type = closed ; 3: for each node t in the hash index such that 4: if s t s n then 5: if t.PDBSize = n.PDBSize then 6: t.type  X  termination and remove the sub-7: else 8: t.type  X  intermediate ; 9: else if s t s n then 10: if t.PDBSize = n.PDBSize then 11: n.type  X  termination and drop nodes un-12: else 13: n.type  X  intermediate ; 14: if n.type = termination then 15: insert n into the hash index; 16: for each child node t of n do 17: StateUpdate( t ); from the window. Since the sequence database of a sliding window is stored in an inverse order, ElemRemove can run without any node extension and thus is very efficient. An expensive operation of IST update is full projection con-struction since it needs to access all the sequences in the sliding window. According to Theorem 5, a t-node will never become a c-node or an i-node. Furthermore, after removal of the obsolete element, supports of tree nodes are never increased. Original frequent nodes may become infre-quent and be dropped, and original infrequent nodes never become frequent. Consequently, node extension and full projection computation are completely avoided.
 Theorem 5 ( Termination Node under Element Removal ) After the removal of e t c  X  w , a t-node may be deleted, but it never changes to a c-node or an i-node.

The pseudo-code of ElemRemove is shown in Algorithm 3. For each child node t of n , it computes s t -projected database in the removal database D  X  (line 2). At the same time, it updates attribute values of the node (line 3). If a node X  X  support is less that the min sup value, the subtree rooted at t is dropped (lines 4-5). Finally it recurses on nodes with non-empty sequences in its projected database (lines 6-7). If a node has only empty projected sequences, it is safe to stop the recursion on that node since nodes under it will not change their supports, IDSums and PDBSizes. 3.3.3 State Update After the extension and elimination of some nodes in the original IST, some nodes may have changed their types. StateUpdate (Algorithm 4) is used to make types of nodes in current IST up-to-date. The state update algorithm uti-lizes a hash index to facilitate the update process. The hash index uses IDSum as hash keys and keeps only pointers that point to nodes in the IST. At line 2, n  X  X  type is initially set to closed . Then, for each node t with the same IDSum and support, it checks whether s t is a proper subsequence of s If it is and s t  X  X  projected database is equal to s n  X  X , it means t is a t-node. Nodes under t should be dropped from the IST (line 6). If s t is a proper supersequence of s n , and s jected database and s n  X  X  are equal, n is a t-node (line 11). If their projected databases are not equal, n  X  X  type is set to in-termediate (line 13). If n is a t-node, it can be easily shown that it is not necessary to insert it to the hash index (lines 14-15). It is because there must be an i-node or a c-node t that has the same projected database as n and s t s n (Theorem 6). Finally, the algorithm recursively calls itself on the child nodes of n (lines 16-17).
 Theorem 6 ( Projected Database Equivalence of Termi-nation Node ) Given a t-node n in an IST for the inverse database D , there must exist an i-node or a c-node t in the IST such that the two nodes have the same projected databases in D and s t s n .
In this section, a thorough experimental study on both real and synthetic data sets is conducted to compare Se-qStream with PrefixSpan which mines the complete set of sequential patterns, and two closed pattern mining al-gorithms CloSpan and BIDE. PrefixSpan was provided as binaries and CloSpan was provided as source code. We implemented BIDE and SeqStream in C++ and compiled them using g++. All experiments were done on an HP Pro-Liant DL585 server with four AMD Opteron 865 processors clocked at 1.8 GHz. The server has 2GB physical memory and runs Linux operation system with 2.6.11 kernel.
The synthetic data sets were produced by using the well-known IBM dataset generator [1] which has been used in evaluation of almost all sequence mining algorithms [18, 23, 22, 21]. A data set D100kC20N10k denotes that there are 100K users, the average sequence length is 20 and the number of distinct items is 10K. Since data sets generated by the generator do not contain a time-stamp for each item, we use the following method to generate a data stream with an element size  X  from a data set D d C c N n . An older user set S O and a new user set S N are maintained in the process of data element generation. Initially, S O is empty and all sequences in the data set belong to S N . Once an item of a
Figure 6. Time breakdown and subspace tra-versed by SeqStream user in S N is selected in a data element, the user is moved to
S O . Since the size of an element is  X  , the number of total time intervals  X  is dc/ X  . On average, in each element, there are d/ X  items from new users and  X   X  d/ X  items from old users. Therefore, a new element is generated by randomly selecting min ( d/ X , |S N | ) items from the front of sequences in S N and min (  X   X  d/ X , |S O | ) items from S O .
Figure 4(a) shows the running time of the four algo-rithms on data set D100kC25N20k when the minimal sup-port is varied from 0 . 05 to 1 4 . The running time of each algorithm is reported as the average time of 10 consec-utive full sliding windows. The sliding window size is set to 0 . 5  X  and the element size is 500 . There are about 50K users with non-null sequences in the sliding window. The corresponding speedups achieved by the several algorithms over PrefixSpan are shown in Figure 4(b). We can see that SeqStream is significantly faster than the other algorithms. The lower the minimal support, the faster SeqStream com-
Figure 7. Varying the number of items and se-quence length pared with the other algorithms. Figure 5 shows the various kinds of nodes in ISTs compared with the set of all fre-quent sequences ( X  X ll Frequent X ). It can be observed that the lower the minimal support, the smaller the percent of closed patterns in all frequent patterns and thus the smaller subspace closed methods need to traverse. This explains why closed pattern mining methods outperform non-closed ones when support is low.
 In addition, SeqStream is more than 50 times faster than BIDE and CloSpan. For example, when the minimal sup-port is 0 . 05 , SeqStream completes in 1 . 53 s, while BIDE and CloSpan use 108 . 82 s and 104 . 44 s respectively. Fig-ure 6(a) shows the time breakdown of three phases of Se-qStream. Element insertion phase uses most of the time, since in ExtendIST, it needs to use the whole set of se-quences in current window to extend IST. Due to nice prop-erties of IST, no extension is needed for element removal. Thus, element removal phase runs very fast. The percent of search space IncUpdateIST and ExtendIST traverse is shown in Figure 6(b). It can be observed that the most part of IST nodes are skipped by pruning techniques of SeqStream. It further explains the high efficiency of Se-qStream.

Figure 7(a) shows the running time of the four algo-rithms when the number of distinct items is increased from 5K to 100K (D200kC25N[5k-100k]). The minimal sup-port, window size and element size are 0 . 2 ,0.5  X  and 400 respectively. It can be observed that SeqStream is not sensitive to the number of items. The results of vary-ing the number of items per sequence are shown in Figure
Figure 10. Varying the minimal support (kosarak)
Figure 11. Varying element and window size (kosarak) 7(b) (D100kC[10-80]N20k). The minimal support, window size and element size are 0 . 4 ,0.5  X  and 500 respectively. When the number of items per sequence is increased, the data set becomes denser. The running time of all algorithms increases. The speedup of SeqStream over other algorithms does not decrease with the length of sequences.

Figure 8(a) shows how element size affects the algo-rithms on data set D100kC25N20k. Element size is changed from 100 to 5000. The minimal support and window size are 0 . 5 and 0.5  X  respectively. The running time of SeqStream increases linearly with element size. But even when 5000 sequences are updated simultaneously, Se-qStream is still significantly faster than the other algorithms. The slight variation of the running time of the other algo-rithms is due to the randomness of the stream generation process, although the database size of the sliding window does not change with element size. With element size fixed at 400, the running time of the algorithms is shown in Fig-ure 8(b) when the size of the sliding window w is varied from 0.1  X  to 0.9  X  . We can see that the running time of SeqStream increases slowly with the size of the window. Compared with the other algorithms, SeqStream performs much better.

Figure 9(a) shows the scalability of the four algorithms when the number of customer is varied from 50,000 to 1,000,000 (D[50k-1000k]C25N30k). The window size, minimal support and element size are set to 0.3  X  , 0.02%, and 400 respectively. We find that all algorithms scale lin-early with the number of users. The memory usage of Se-qStream is shown in Figure 9(b). The memory used is di-vided into three parts: Data, Algorithm and IST which are the memory space used by sequences in current sliding win-dow, temporary space used by SeqStream algorithm and space occupied by ISTs. It can be observed that the mem-ory used by data and algorithms increases linearly with the number of users. Since the number of IST nodes does not change a lot with the minimal support fixed, the memory used by IST nodes shows little variation.
 The real data set used in our experiments is kosarak 5 . The dataset contains (anonymized) click-stream data of a hungarian on-line news portal. It has 990,002 sequences. Its average and maximal sequence length are 8.1 and 2498 respectively. Figure 10 shows the results of the four algo-rithms when the minimal support is varied from 0.05% to 0.1%. The window size and element size are set to 0.45  X  and 500 respectively. It can be found that SeqStream per-forms uniformly well on this data set. Figure 11(a) illus-trates the running time when element size is varied. The minimal support and window size w are 0.1% and 0.45  X  re-spectively. Figure 11(b) shows how window size affects the algorithms with the minimal support and element size fixed at 0.1% and 500 respectively. SeqStream is the clear winner on all these parameter settings.
In this paper, we examined the problem of mining closed sequential patterns over data stream sliding windows. A synopsis structure IST was used to keep inverse closed se-quential patterns in current sliding window. An efficient algorithm SeqStream was designed to mine closed patterns in sliding windows incrementally. Various novel strategies were adopted to prune search space aggressively. A thor-ough experimental study on both real and synthetic data sets has shown that SeqStream outperforms three other al-gorithms by a large margin. In the future, we will examine how to parallelize SeqStream.

Acknowledgements The authors would like to thank anonymous reviewers for their valuable comments and sug-gestions.

