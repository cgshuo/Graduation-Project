 Biological databases are becoming increasin gly important, and their sizes are growing gene sequences. For example, GenBank already contains 56,037,734,462 base pairs and 52,016,762 DNA sequences as at 2005. For protein sequences, currently Release 50.8 of Oct 3rd, 2006 of UniProtKB/Swiss-Prot contains 234,112 sequence entries, comprising 85,963,701 amino acids abstracted from 146,463 references. The increasing size of biological databases is a boon for researchers in bioinformatics, but this is only true if they can retrieve information from these databases effectively (reasonable speed and accuracy). Two approaches exist for querying sequences. 
The first is to perform database search based on sequence alignment [1]. Sequence alignment algorithms search for, in the database, all the sequences matching the query sequences. Since the time to perform sequence alignment increases proportionally to the size of the database, these algorithms become very slow for large sequence databases because databases size experienced exponential growth. The second approach is to use schemes si milar to the BLAST algorithm [2, 3] or PatternHunter algorithm [4]. BLAST finds regions of local similarity between sequences. It compares nucleotide or protein sequences to sequences in databases and calculates the statistical significance of matches. It can be used to infer functional and evolutionary relationships between sequences as well as help identify members of gene families. Though BLAST is fast, it does not guarantee to output all the matched sequences given the query sequences. At the same level of sensitivity as BLAST, PatternHunter is able to find homologies between sequences as large as human chromosomes, in mere hours on an entry-level PC. It can even approach the Smith-Waterman [1] exhaustive dynamic programming sensitivity at speed 3,000 times based on the first approach. 
Accordingly, we ask the question of how to cope with the biological sequences database so that the query is efficient, and it can output as many matched sequences as possible. In this paper, we propose a new approach for sequences similarity search. The basic idea is to map all biological sequences in the database onto a plane as 2-d points through the self-organizing map (SOM) [5], where they are spatially indexed thereafter with a spatial data structure such as the widely-used R-tree. Then, we perform similarity search using our multi-point range query (MPRQ) algorithm [6, 7] that can support multiple simultaneous queries efficiently. In this paper, we transform the problem of searching for similar sequences in sequences database to the problem of spatial search of query points in 2-d planes. Our approach, as mentioned before, has two major components: the self-organizing map (SOM) and the multi-point range query (MPRQ) algorithm. 2.1 SOM for Sequences Transformation The SOM algorithm can be applied on biological sequences to form a similarity  X  X ap X  via unsupervised training. The map is a grid of artificial nodes which are adapted to closer match sequences from an input database DB . Each node is a vector also updated to be more similar to S but at a smaller degree. As a result, when a SOM (sequences) are characterized by their sim ilarity. Because of this, SOM could indicate relationships between clusters. Therefore, it is very suitable for analysis of the similarities among sequences and is widely used [8]. 
Biological sequences can be transformed to statistical vectors via SOM. In fact, sufficient condition for them to be mapped into a SOM map is that some kind of implementation, we used the Euclidean (L 2 ) distance metric as similarity measure between any 2-d point representing sequences. 2.2 MPRQ for Query Using the MPRQ algorithm from our earlier work, we are able to quickly perform similarity search of biological sequences in the database. The MPRQ algorithm (spatially indexed) that is within a distance d from any of the query points. Formally, given a spatial database DB , a set of points P , and a distance d , MPRQ( P , d ) = { p i  X  including bulkloaded R-tree [9] which we use. 
The general idea behind MPRQ algorithm is to perform only one pass of the R-tree while simultaneously process multiple query points (in this case, transformed from O(log B n + k / B ) time where B is the disk page size. Due to space constraints, we refer the intelligent pruning rules embedded within MPRQ. 2.3 Similarity Query The use of SOM is to achieve a high correlation between the proximity of 2-d points on the SOM map and the similarity between mapped sequences. The use of MPRQ algorithm is to achieve the best possible efficiency in finding similar sequences. Together, both SOM and MPRQ, as tools for similarity queries, present an alternative approach to studying the similarity query of biological sequences. 
Both the query sequence(s) and sequences databases are transformed into statistical vectors, ready as input for SOM. Once the sequences in database are mapped to a 2-d plane with SOM, we transform the query sequence(s) into query point(s) in 2-d space and proceed to query. At this point, it is possible to use many sequences as the query, which translates to multiple points in 2-d space as the input for MPRQ. controls the radius of the search distance. The larger the value of d , the more similarity results will be returned. 
When the algorithm has terminated, the query results (2-d points, each representing a similar sequence) obtained from MPRQ are collected for analysis. For each point in original sequence. Fig. 1 illustrates the whole process. 
BLAST scores the sequences similarity based on a distance matrix. However, in our approach, we do not use a distance matrix; instead, the similarity measure of our approach is derived from the distance between 2-d points. To compute the number of matched sequences, we score and validate the candidates generated by MPRQ with the same distance matrix as BLAST (Fig. 2 (a)). By doing so, the results for our approach can be fairly compared with BLAST results. 3.1 Datasets and Experiment Settings The DNA sequences database are based on the GenBank database (Release 155.0, ftp://ftp.ncbi.nih.gov/blast/db) [10] and the protein datasets are based on the Uni-ProtKB/Swiss-Prot database [11]. The specifications of these datasets are in Table 1. 
Notice that for DNA sequences, every dataset has few sequences, but each DNA sequence is very long. On the other hand, for protein sequences the number of Thus, it is a challenge to intelligently prune the search space for sequences to maintain query efficiencies. Query sequences were randomly selected from their respective datasets. 
For comparison with other database search algorithms, we used NCBI BLASTn [4] for sequences search on DNA sequences, and NCBI BLASTx [12, 13] for sequences search on protein sequences. These two algorithms are widely used. For mapping the biological sequences onto points in planes , we used the SOM_PAK [14] package. We implemented our program in C++ and Perl. The experiments were performed on a Linux PC machine with 3.0GHz CPU and 1.0GB RAM. 
The accuracy of the sequences obtained is of great importance. For a result  X  i and the real sequence  X  of DNA sequences, the accuracy score was computed in the same way as BLASTn for DNA sequences, and BLASTx for protein sequences. We call this function BLAST_Score. The accuracy measures the portions of the real sequence that are in the results. Current algorithms generally use the number of  X  X atches X  as an indicator of the query results is defined as 
Since the BLASTn algorithm treats DNA sequences with scores above 10.0 as good results, we had also set the threshold value t of 10.0 and take these DNA the protein sequences with score above these are considered matches. Based on the number of match results, we define the match ratio R m . where  X  X B search results X  are the results given by database search with the combined SOM and MPRQ approach. 3.2 Results We first analyzed the process of mapping biological sequences onto 2-d plane. The aim is to test how well the distances between points on the planes reflect the similarities between sequences. Results show that the closer the two points on the plane, the more similar the sequences that they represent (details not shown here due similarity were grouped together by SOM, we believe that SOM is suitable for clustering analysis. Fig. 2(b) shows a sample of the SOM map that we trained from the E. Coli dataset. 
Next, we analyzed the performance of the spatial index used to index the points from the SOM so as to guarantee efficient querying. Extensive experiments have been time for MPRQ is very fast (&lt; 1 sec) even with a large number of query points. obtained from database search, as well as the number of matched results from database search. We observe that both the number of database search results and the number of matched results increase as the search distance d increases. This indicates a high correlation between the proximity of 2-d points on the SOM map and the similarity between the sequences. The number of matches do not increase greatly after d =10000 but the time increase significantly (details not shown here). Thus, in the following experiments, we had selected d =5000 and d =10000 for further analysis and comparison. From the same figure, we also infer that the match ratio R m is very high. This empirically proves the effectiveness of our algorithm. 
We also compared our method with other existing biological sequences search algorithms. For DNA sequences from GenBank database, we compared with (ii) search distance and (iii) total query time. We performed single input query ( m = 1) and multiple input query ( m = 10) using 10 sequences and we measured the total number of similar sequences. Table 2 depicts the results. 
We noticed that our algorithm does not produce as many results as BLASTn. For single query, we think this is because BLASTn is more accurate than our algorithm. support multiple inputs; so for m = 10, we perform 10 separate queries, and thus the sequences reported includes some (though not many) overlaps. 
The search distance parameter d influences the number of similarity results returned. We had selected d =5000 and d =10000 for experiments. As expected, a Also, we observed that our algorithm performs very fast, especially for multiple inputs. Compared with BLASTn, our algorithm is faster by 1 to 2 orders of magnitude. The reason behind this is that our approach has transformed the similarity query problem for sequences into range queries of 2-d points. We also performed experiments on real protein sequences from UniProtKB/Swiss-Prot database. We compared our algorithm with BLASTx. The results are shown in Table 3.

For single query, the number of matched protein sequences is about 20% to 75% of those by BLASTx on Yeast datasets; and are about 30% to 80% on Drosoph datasets. For batch query, large amount of matched protein sequences are also observed. This indicates that our algorithm also perform well on protein sequences queries. than that of BLASTx. This is very significant, especially for large query sizes. Comparing the query time on E. Coli , Yeast and Drosoph DNA sequences datasets, we observe that the process time did not increase greatly with the increase of dataset size. The experiments on Yeast and Drosoph protein sequences datasets also show the same phenomenon. Furthermore, the query time is affected only slightly by query size and database size. This is a very good characteristic for larger scale database queries, in which query size is large, and database size is also large. Though we did not perform experiments on larger genome datasets such as BLAST nr dataset, we believe that the query time on large dataset will not increase too much. 
We do, however, note that by using our algorithm, the original sequences database must be preprocessed before efficient queries can be performed. Most of the current sequences databases for queries are relatively stable (i.e. published databases are rarely changed radically) and most of the queries are performed on those stable sequences in the database. Therefore, preprocessing time can be seen as only a small one time overhead to the overall query ef ficiency. For example, the preprocessing time is about 1 minute for Yeast DNA dataset, and 3.5 hours for Yeast protein dataset. We also note that BLASTn and BLASTx also need preprocessing time. It takes about 1 minute and a few minutes for these algorithms to preprocess Yeast DNA and Yeast protein datasets respectively. datasets such as BLAST nr genome sequences, the preprocessing time will be a big overhead. However, as the number of queries performed increases, the total cost for each query actually decreases. As a result, if a sufficiently large number of queries are orders of magnitude faster. As the sizes of biological databases grow, we believe algorithms to effectively search biological sequences in the database will become the focus for many scientists. In this study, we proposed a new approach for indexing biological sequences in database so as to facilitate fast similarity queries. Essentially, this algorithm transforms sequences to vectors and then to 2-d points on SOM map, and use SOM and MPRQ for fast and accurate sequences query. Experiments show that our algorithm is not only efficient but also accurate in searching for similar sequences in database. areas in our current work that can be improved. For instance, the scale of our this approach further. Also, it is possible to research better data structures and algorithms as spatial indexes that take into consideration some characteristics of biological sequences rather than mere 2-d points. 
There are still many related problems waiting for further investigations. One of these interesting problems is how to extract biological information from such an indexing process. Since sequences similarity at different levels may indicate their functional relationships, we think research in such areas may be especially useful for the comprehensive comparison of sequences. 
