 SimRank is an attractive structural-context measure of sim-ilarity between two objects in a graph. It recursively follows the intuition that  X  X wo objects are similar if they are ref-erenced by similar objects X . The best known matrix-based method [1] for calculating SimRank, however, implies an assumption that the graph is non-singular , i.e., its adjacency matrix is invertible. In reality, non-singular graphs are very rare; such an assumption in [1] is too restrictive in practice. In this paper, we provide a treatment of [1], by supporting similarity assessment on non-invertible adjacency matrices. Assume that a singular graph G has n nodes, with r ( &lt; n ) being the rank of its adjacency matrix. (1) We show that SimRank matrix S on G has an elegant structure: S can be represented as a rank r matrix plus a scaled identity matrix. (2) By virtue of this, an efficient algorithm over singular graphs, Sig-SR , is proposed for calculating all-pairs SimRank in O ( r ( n 2 + Kr 2 )) time for K iterations. In contrast, the only known matrix-based algorithm that supports singular graphs [2] needs O ( r 4 n 2 ) time. The experimental results on real and synthetic datasets demonstrate the superiority of Sig-SR on singular graphs against its baselines.
 H.3.3 [ Information Search and Retrieval ]: Information Storage and Retrieval Link Analysis; Similarity Search; SimRank; Singular Graph
Modern means of similarity assessment between objects based on hyperlink structure have played a giant role in web information retrieval. One well-publicized link-based simi-larity measure is SimRank [3], invented by Jeh and Widom, due to its successful applications in e.g., similarity join [4], k -nearest neighbor search [1], and citation analysis [2, 5]. Analogous to the famous PageRank algorithm [6] assigning a relevance score to each object (node), SimRank assigns a similarity score to each pair of nodes in a graph. The central idea behind SimRank is that  X  X wo nodes are similar if they are referenced by similar nodes X , together with the base case that  X  X odes are maximally similar to themselves X , which can be formulated in the matrix notation [1,2] as follows: where C  X  (0 , 1) is a damping factor, W is an n  X  n column normalized adjacency matrix, (  X  ) T is the matrix transpose, S is the similarity matrix, whose entry [ S ] i,j is the SimRank score between nodes i and j , and I is the identity matrix. The recursive nature of SimRank not only allows its simi-larity scores to capture the global link structure of a graph, but also inspires research on efficient SimRank calculation since the naive way [3] of solving S needs O ( Kn 2 d 2 ) time on a graph of n nodes and d average in-degree for K iterations. With the massive size of the Internet, recent years have witnessed an increasing attention in SimRank optimization (see [1,2,5,7,8] and the references therein).
 Among those existing matrix-based SimRank algorithms, SimMat [1] is the state-of-the-art one, yielding O (  X n 2 for estimating SimRank, where  X  is the target rank of the adjacency matrix. However, the optimization method of SimMat is based on the following formula ( i.e., Eq.(3) in [1]): which is derived by left-multiplying both sides of Eq.(1) by ( W T )  X  1 . Unfortunately, this process rests on an under-lying assumption that ( W T )  X  1 must exist (or equivalently, the adjacency matrix must be invertible), but this does not always hold in reality. Indeed, when ( W T )  X  1 does not exist, SimMat fails to work properly, as depicted in Example 1.
Example 1. Consider two web graphs G 1 and G 2 in Fig.1, where nodes are web pages, and edges are hyperlinks. We want to calculate SimRank scores of all-pairs on G 1 and G respectively. However, we observe that SimMat [1] fails on both graphs as their adjacency matrices are not invertible: there does not exist ( W T )  X  1 for G 1 and G 2 such that Eq. (2) holds, not to mention using the subsequent Eq. (2) -based op-timization method in [1] for SimRank calculation.

Example 1 suggests that S imMat only works when ( W T )  X  1 exists. However, as demonstrated by our statistical exper-iments on SNAP 2 , there are over 95% real graphs whose adjacency matrices are non-invertible, i.e., rank( W ) &lt; n (known as singular graphs ). Thus, it is imperative to provide a treatment for SimMat , by devising an efficient algorithm that supports SimRank computations on singular graphs. To this end, we study the following problem in this paper: Problem ( SimRank over Singular Graphs ) Given a singular graph G , and a damping factor C  X  (0 , 1). Compute all-pairs of SimRank scores on G .

It is worth mentioning that there is a special subclass of singular graphs, in which there are many isolated nodes ( e.g., G 2 in Fig.1(b)). Singular graphs of this subclass are not the direct focus of our consideration, since they could be further simplified by removing trivial zero rows and columns (associated with isolated nodes) in the adjacency matrices. For example in G 2 , once isolated nodes d and e are removed, its adjacency matrix Adj ( G 2 ) can be reduced to Adj ( G Since Adj ( G  X  2 ) becomes invertible, SimMat is still applicable to the reduced G  X  2 (though not applicable to the original G Hence, in this scenario, we call G 2 a  X  X alse X  singular graph , a graph whose original non-invertible adjacency matrix can be converted to an invertible one if isolated nodes are removed. In this paper, our attention will be devoted to X  X rue X  X ingular graphs without isolated nodes ( e.g., G 1 in Fig.1(a)). Contributions. Our main contributions are listed below.
SimRank is arguably one of the most successful link-based similarity measures in recent years. It was initially proposed by Jeh and Widom [3], who adopted an iterative paradigm to compute SimRank scores of all-pairs in O ( Kn 2 d 2 ) time. Since then, there has been a surge of papers looking at vari-ous problems in efficient SimRank computing as the naive al-gorithm [3] has high time complexity. Recent results include matrix-based methods [1, 2], iterative optimization [7 X 9], random walk sampling [10, 11], incremental updating [12], parallel computing [13], and semantic improvement [14].
In comparison to the work on iterative optimization ( resp. random walk sampling) that will produce deterministic ( resp. probabilistic) errors, the work on matrix-based methods [1,2] may accurately calculate SimRank without loss of exactness. The pioneering work of Li et al. [2] proposed a very elegant closed-form for SimRank: where  X  is tensor product, and vec (  X  ) matrix vectorization. Based on Eq.(3), [2] utilized rank r ( resp. low-rank  X  ( &lt; r )) singular value decomposition to compute all-pairs SimRank In contrast, our work uses a trick to avoid directly applying matrix factorization to the high-dimensional tensor product, just entailing O ( rn 2 ) time for singular graphs.
Most recently, Fujiwara et al. [1] proposed SimMat to fur-ther speed up the computation of n -pairs of SimRank w.r.t. a given query node to O ( rn ) time, thus needing O ( rn 2 ) time for all-pairs SimRank. However, their optimization method is based on Eq.(2), implying an underlying assumption that ( W T )  X  1 must exist, which does not always hold in general. In comparison, our work provides a treatment for SimMat , aiming to support SimRank computation on singular graphs, whose ( W T )  X  1 does not exist. Note that the matrix inver-sion in Eq.(3), different to ( W T )  X  1 in Eq.(2), always exists as ( I  X  C ( W T  X  W T )) is a diagonally dominant matrix.
Unlike SimMat [1] that left-multiplies both sides of Eq.(1) by 1 C ( W T )  X  1 , we first provide the following lemma.
Lemma 1 ( [12]). Given any three n  X  n matrices A , B , C , X = P  X  i =0 A i C B i to the following matrix equation Main Idea. Based on Lemma 1, we show our main idea. Let A := C W T , B := W , C := (1  X  C ) I in Lemma 1. Then, the SimRank solution S to Eq.(1) takes the form: 5 As G is a rank r ( &lt; n ) singular graph, we now apply Gram X  Schmidt method [15, pp.316] to decompose W  X  R n  X  n as W = V r H r T , where V r and H r are both n  X  r matrices, and V r is a column orthonormal matrix, i.e., V r T V r = I Hence, W i can be efficiently computed as
It is important to note that the second equality in Eq.(6) plays a critical role in speeding up the computation of W The original method for computing W i requires O ( in 3 ) time, including multiplying i times two n  X  n matrices. In contrast, the right-hand side of Eq.(6) tells that, once W is decom-posed into two n  X  r matrices, the computation of W i can be improved to O ( r 2 n + ( i  X  1) r 3 + rn 2 ) time with r &lt; n , involving (i) O ( r 2 n ) time to compute H r T V r , whose result
X i s diagonally dominant if | x i,j |  X  P j 6 = i | x i,j  X  max ( X ) is the eigenvalue of the matrix X with the largest absolute value, i.e., the spectral radius of X .
One can readily verify that  X  max ( C W T )  X  max ( W ) &lt; 1, by using the matrix norm property  X  max (  X  )  X  k  X  k and the fact that W is column-normalized ( k W k 1 = k W T k  X   X  1).
I r is an r  X  r identity matrix, as opposed to I  X  R n  X  n . is an r  X  r m atrix, memoized as P r  X  R r  X  r , (ii) O (( i  X  1) r time to compute the power ( i  X  1) of P r , memoized as  X  and (iii) O ( rn 2 ) time to compute V r  X  P r H r T .
Then, to efficiently compute S , we plug Eq.(6) into Eq.(5): with S r := X  X 
Eq.(7) depicts an important feature of matrix ( 1 1  X  C S  X  I ) , based on the following theorem.

Theorem 1. For a singular graph G with the adjacency rank r ( &lt; n ) , its SimRank matrix S can be characterized as a rank r matrix plus a scaled identity matrix.

Proof. As S r in Eq.(8) is an r  X  r matrix, Eq.(7) says that the matrix ( 1 1  X  C S  X  I ) can be decomposed as the prod-uct of ( H r S r )  X  R n  X  r and ( H T r )  X  R r  X  n , meaning that ( 1  X  C S  X  I ) is a rank r matrix. Thus, S on rank r singular graph can be expressed as the rank r matrix ( H r S r H T plus the scaled identity matrix (1  X  C ) I .
C haracterizing the structure of S in Theorem 1 is intended to speed up the computation of SimRank on singular graphs.
Specifically, by virtue of Eq.(7), solving S  X  R n  X  n boils down to computing S r  X  R r  X  r from Eq.(8). Due to its small dimension, S r is relatively easier to solve and can thus sig-nificantly improve the complexity for computing SimRank. Moreover, we observe that Eq.(8) takes an Eq.(5)-like form. Applying Lemma 1 to Eq.(8), we have the following theorem.
Theorem 2. SimRank matrix S over a rank r singular graph can be represented as
Proof. The correctness of Theorem 2 follows immedi-ately from the combination of Eqs.(7) and (8) and Lemma 1.
One caveat is that the existence of S r in Eq.(9) is guar-anteed by the condition that C  X  max ( P r T )  X  max ( P r or equivalently,  X  max ( P r )  X  1. This is always true because W = V r H r T implies that This suggests that P r is a compression of W via orthogonal projection V r onto a small r  X  r subspace. Thus, by Cauchy interlacing theorem, it is follows that  X  max ( P r )  X   X  Combining this with the spectral property that  X  max ( W )  X  k W k 1  X  1 yields  X  max ( P r )  X  1.
 Theorem 2 provides an efficient way of computing Sim-R ank on rank r ( &lt; n ) singular graphs. As depicted in Fig.2, the conventional method computes S on an n  X  n dimensional space via Eq.(1), whereas our approach solves S by resorting to the computation of S r on a small r  X  r dimensional space via Eq.(9). Below is the complexity analysis of our solution.
Theorem 3. All-pairs SimRank on a rank r singular graph can be computed in O ( rn 2 + Kr 3 ) time for K iterations. Figure 2: Compute S in n  X  n s pace by resorting to solving S r in small r  X  r subspace Algorithm 1: S ig-SR ( G, C, K )
To prove Theorem 3, we next provide an algorithm, de-n oted as Sig-SR , for SimRank assessment on a singular graph. Algorithm. The algorithm Sig-SR works in three phases: 1) For the preprocessing (lines 1 X 3), it first applies Gram X  S chmidt method [15, pp.316] to factorize W as V r and H r such that the column vectors in V r form an orthonormal ba-sis of W (line 2). Then, utilizing V r and H r T , it calculates auxiliary P r  X  R r  X  r (line 3) for subsequent iterations. 2) In the computation of S r  X  R r  X  r (lines 4 X 6), it adopts a fixed point iteration in r  X  r dimension to get S r in Eq.(9). It is worth noting that, as P r is full-rank (invertible) matrix, other prior optimization methods for computing SimRank ( e.g., [1,7,13]) can be applied to computing S r as well. 3) For calculating S  X  R n  X  n (line 7), it uses V r a nd the resulting S ( K ) r , and returns S as the final result. Correctness &amp; Complexity. The correctness of S re-turned from Sig-SR can be readily verified by Theorem 2.
The total time of Sig-SR is bounded by O ( rn 2 + Kr 3 ), which consists of (i) O ( rn 2 + r 2 n ) time for the preprocessing (lines 1 X 3), including O ( rn 2 ) time to decompose W and O ( r 2 n ) time to compute P r , (ii) O ( Kr 3 ) time for computing S r for K iterations (lines 4 X 6), and (iii) O ( rn 2 ) time for computing S (line 7).
 Example 2 . Recall the singular graph G 1 in Fig.1(a). We illustrate how Sig-SR computes all-pairs SimRank in G 1 As previously used in [2,8], we set C = 0 . 8 and K = 10 .
Firstly, by applying the Gram X  X chmidt process, W  X  R 6  X  6 can be decomposed as W = V 3 H 3 T (line 2):
T hen, using V 3 and H 3 T , we obtain P 3  X  R 3  X  3 (line 3) and S 3 (10)  X  R 3  X  3 (lines 4 X 6) as follows: Finally, S  X  R 6  X  6 is derived from S 3 (10)  X  R 3  X  3 (line 7):
We present an empirical study on real and synthetic data, to show that our algorithm Sig-SR (1) provides an effective treatment for supporting SimMat [1] on singular graphs, and (2) is much faster than other competitors on singular graphs. Experimental Setting. We used three real datasets. (1) (ca)-HepTh , a citation graph from the e-print arXiv, where nodes are papers, and edges are citations. (2) (soc)-Slashdot , a Slashdot Zoo social network, which contains friend links between the users of Slashdot. (3) (email)-EuAll , an email dataset from a EU research institution, where an edge from an email address i to j is a message sent from i to j . We removed all the isolated nodes. The sizes of these datasets are summarized below.

We designed a generator to produce synthetic data with 2 parameters: the number of nodes, and the number of edges. We generated graphs following the densification power law.
We implemented the following algorithms in Visual C++. 1) Sig-SR . 2) SimMat [1], the best known matrix-based Sim-Rank algorithm. 3) Iter [7], the iterative algorithm comput-ing SimRank via fine-grained memoization. 4) NI Sim [2], the only known matrix-based SimRank that supports singu-lar graphs via SVD method. All the algorithms are run on Windows 7 with an Intel Core 3.1G CPU and 8G RAM.

As previously used in [2,8], we set damping factor C = 0 . 8, and total iteration number K = 10 as default values. Experimental Results. We next present our findings. (1) Effectiveness. Fig.3(a) shows the high time efficiency of Sig-SR on real and synthetic datasets. Note that, on real data, y -axis is in log scale; on synthetic data, n is varied from 20K to 100K as shown in x -axis. We see that 1) on singular graphs, Sig-SR works fairly well, whereas SimMat always fails due to the non-invertible adjacency matrices. This tells that Sig-SR , as a treatment for SimMat , enables SimRank assessment on singular graphs. 2) On each dataset, Sig-SR consistently outperforms all other algorithms, e.g., on real ca , Sig-SR (65s) runs 300x faster than NI Sim (19786s), and 6.7x faster than Iter (436s). When n &gt; 40K, NI Sim explodes due to huge costs for tensor products; in contrast, Sig-SR uses Theorem 1 that avoids tensor products. These verify that our method of computing S (in n  X  n ) by resorting to the computation of S r (in small r  X  r ) is effective. (2) Phase Duration. Fig.3(b) depicts the time percentage of Sig-SR for three phases ( i.e., (I) decompose W , (II) solve S (III) compute S ) on real datasets. We can see that Phase (II) is most time-consuming on ca (58%) and soc (47%), whereas on email , the time for Phase (II) is negligibly small (2%). The reason is that on email , r is 11.6x smaller than n , in contrast with ca and soc (1.25x) where r is only 1.08x and 1.25x smaller, respectively. Thus, when r  X  n , the time for Phase (II) is comparable to that for (I) and (III). This confirms our complexity analysis of Sig-SR in Section 3.2. (a) Efficiency of Sig-SR on Real and Synthetic Graphs (b) % Time in Each Phase (3) Singular Graph Statistics. To verify that singular graphs are commonly existent, Fig.3(c) statistically depicts the fre-quencies of r n occurring in certain ranges of ratios (as de-picted in x -axis) over 100 real datasets. We see that 1) there graphs are very rare in reality. Thus, Sig-SR is typically useful in many cases. 2) Almost 32% ( resp. 21%) real graphs The smaller r is, the faster Sig-SR runs. This explains why, in general, the better speedup of Sig-SR is guaranteed. We provide a treatment of SimMat [1], by supporting SimRank assessment on singular graphs. First, we show that SimRank matrix on rank r graph can be represented as a rank r matrix plus a scaled identity matrix. Then, in light of this, an efficient algorithm Sig-SR is proposed. Our empirical evaluations verify the effectiveness of Sig-SR against its competitors over real and synthetic datasets.
