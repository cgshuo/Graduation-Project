 We investigate the problem of how to evaluate, fast and efficiently, classes of optimal r oute queries on a massive graph in a unified framework. To evaluate a route query effectively, a large network is partitioned into a collection of fragments, and distances of some optimal r outes in the network are pre-computed. Under such a setting, we find a unified algorithm that can evaluate classes of optimal route queries. The classes that can be processed efficiently are called constraint preserving ( CP ) which include, among others, shor test path, forbidden edges, forbidden nodes,  X  -autonomy and some of hypothetical weight changes optimal route query classe s. We prove the correctness of the unified algorithm. We then turn our attention to the optimization of the proposed algorithm. Several pruning and optimization techniques are derived that minimize the search time and I/O accesses. We show empirically that these techniques are effective. The proposed optimal route query evaluation algorithm, with all these techniques incorpor ated, is compared with a main-memory and a disk-based brute-force CP algorithms. We show experimentally that the propos ed unified algorithm outperforms the brute-force algorithms, both in term of CPU time and I/O cost, by a wide margin. H.2.4 [Database Management]: Systems -Query processing. Algorithms, Performance, Experimentation.. Keywords: Optimal Route Queries, Distance Materialization, Route Query Evaluation. Consider a web-based road info rmation system, like Yahoo!Maps or a moving object database [13] , in which commuters issue queries to find optimal routes from current locations to their destinations. For such a system to be valuable, it is imperative that the route queries are answered fa st, preferably in real-time. Some of the most frequently asked route queries, such as shortest path queries, as well as Traveli ng Salesman and Hamiltonian Path queries, are examples of optimal route queries. Among all route queries, shortest path ( SP ) queries are the most fundamental, and have been studied extensively in the literature. There are many mature SP algorithms. However, when a graph is huge, and the main memory is not large enough to load the whole graph, these algorithms do not work properly. Even if the main memory is large enough to accommodate the graph, the running time could be long, and the system resources may not be utilized effectively. It is well-known that the SP problem can be solved in polynomial time, while some optimal route problems are NP -complete. Although many papers, such as [3] [6] [9] , deal with the optimal route problems, most of them only solve a specific case. Moreover, it is difficult to extend their solutions to a disk-based environment. In this paper, we focus on the pr oblem of how to evaluate classes of optimal route queries under a disk-based framework. In particular, we are interested in finding, with the help of distance materialization, a general and fast algorithm that can evaluate classes of optimal route queries. Such an algorithm is found, and is derived from an existing SP query evaluation algorithm [2] . We call the classes of optimal route queries that can be evaluated by the proposed algorithm constraint preserving ( CP ). CP optimal route queries include real-life queries such as  X  X ind a route from a to b with the minimal cost, X   X  X ind an optimal path from a to b that does not go through the center core of the city, X   X  X ind the best trip from a to b that does not pass a set of towns and cities, and avoid highways 9, 10 and 20, X   X  X ind an optimal route from a to b such that the distance of between successive nodes (which could denote intersections, hotels, gas stations) is not greater than c , X  and  X  X ind an optimal route from a to b , assuming that Highway 401 traveling time was increased by 15% while the traveling time on Highway 400 was decreased by 10%. X  In this work, we first prove that the generalized algorithm correctly evaluates a CP optimal route query. To minimize the search space, algorithms have been proposed in [2] to prune the network when evaluating an SP query. We show that these pruning algorithms can be generalized to CP optimal route queries. After that, we turn our attention to finding techniques for route query evaluation. Several techniques are found that could speed up the execution time or reduce the I/O cost. We show empirically that these techniques are effective, and the proposed algorithm outperforms significantly, both in term of the execution time and I/O cost, a main-memory and a disk-based brute-force CP query evaluation algorithms. In Section 2, we define some ba sic notation. In Section 3, we survey related work. In Section 4, we define the CP optimal route query classes, and show how they can be evaluated efficiently with a query evaluation algorithm. We also introduce techniques that can speed up the evaluation process. In Section 5, experimental results are presented. Finally, a summary is given in Section 6. A network such as a road system is denoted as a directed graph G function from the set of edges to a set of non-negative real numbers. Let p be a path in a graph G . Then l ( p ) is the sum of the lengths of edges in path p . Since we are interested only in paths without any loop , unless otherwise stated, a path is a simple path. If a path p starts from node s and ends at node t , then p is an s -t path. An optimal route query returns an SP in a graph G that satisfies certain constraint. Let  X  be a constraint imposed on paths in a The constraint  X  could be dependent on G , or could be a general condition on paths in G . Examples of general path constraints include the following: the number of nodes/edges in a path, or the length of a path must be less than certain constant c . Instances of constraints that are dependent on a graph G include: a path cannot pass through a set of specific edges/nodes in G , or a path must visit certain edges/nodes in G in a specific order.
 imposed on paths in G . The answer to an optimal route query Q ( G ,  X  , s , d ) is an SP from s to d in G . Unless confusion arises, we the answer to the query. The length of an optimal u -v route in G , optimal path exists, and  X  otherwise. An optimal route query d are distinct nodes in G }. The following are examples of optimal route query classes:  X  Shortest Path :  X  :  X  .  X  Forbidden Nodes/Edges :  X  : Nodes(Edges) in a path cannot  X   X  -autonomy :  X  : An edge in a path cannot have a length  X  k -stops :  X  : There are exactly k -1 edges in a path.  X  Traveling Salesman :  X  : A path passes each node in N  X  n -consecutive Nodes :  X  : Any n consecutive nodes in a path  X  Hypothetical Weight Changes :  X  is defined with respect to The  X  -autonomy and k -stops optimal route query classes are proposed and studied in [11] , while a generalization of Traveling Salesman which is called Trip Planning Query ( TPQ ) is discussed in [4] . A graph G is assumed to be too large to be main-memory resident. It is first partitioned into a collection of fragments before queries are posted to the database. A fragment is a connected sub-graph such that an edge connecting two nodes in a fragment precisely when the two nodes are connected by the same edge in the original graph G . A partition P ( G ) of a graph G = ( V , E , w ) is a collection of fragments { F 1 = ( V 1 , E 1 , w 1 ),..., F such that U i V i = V , U i E i = E , and  X  f  X  e  X  E resulting partition is stored in a disk-based structure, and is called a fragment database . Nodes in a fragment of a partition are divided into two disjoint sets: the boundary nodes and the interior nodes. A node is a boundary node if it belongs to more than one fragment, otherwise it is an interior node. An important property of an interior node in a fragment F is that it is adjacent only to nodes in F . If two distinct fragments F i and F i are sharing at least one boundary of boundary nodes shared by them is called a boundary set , denoted by BS [ F i , F j ]. Conceptually, once a graph is partitioned, one can apply a route query evaluation algorithm to it, by reading in fragments and their auxiliary data structures from the disk whenever they are needed, and swapping them out when thei r usefulness expi res. However, this brute-force method may not be effective, especially if the search space is huge, or if fragments are repeatedly accessed. For some classes of route queries, que ry evaluation can be speeded up by pre-computing some optimal distances. Given a route query matrix is created to record the distance of a local optimal path from one boundary node to the other. That is, for each pair of SD ( F ,  X  , v , u ) are recorded in a distance matrix. All these matrices collectively are called a distance (matrix) database for the query class Q ( G ,  X  ). The distance database for a query class Q ( G ,  X  ) of a graph partition P ( Q ) is denoted as DMDB ( P ( Q ), Q ( G ,  X  )), or DMDB ( Q ( G ,  X  )), if the partition is understood from the context. An important concept in this a pproach is called super graphs. boundary nodes and their pre-computed optimal distances in fragments give rise to a super graph for Q ( G ,  X  ). A super graph (V ,E s ,w s ) , of a graph partition P ( G ) = { F 1 = ( V ( V , E n , w n )} is a directed graph and has the following properties: V ={ v b |  X  F i , v b is a boundary node in F i }, E v  X  v j and they are boundary nodes in F k }, and  X  e ij w the context, from now on, a super graph for an optimal query class is denoted as SG ( Q ( G ,  X  )). Another useful concept is called sketch graphs. The connectivity of boundary sets in a partition can be captured with a sketch ={ F 1 , F 2 ,..., F n } is a directed graph and has the following properties: V k = { v q | v q corresponds to some boundary set BS [ F F ]}, E k = {&lt; v i , v j &gt; F p | v i and v boundary sets in some fragment F p , p  X  [1, n ]}, and w whenever is needed and is undefined otherwise. A framework is presented in [10] to address the issue of how to evaluate various types of spatial queries in the presence of a road network. The query classes investigated include k -NN , range, distance-join, and closest-pairs queries. To efficiently access nodes and edges in a network, the adjacency lists of the nodes closed in space are placed in the same disk page. To support queries that explore the spatial properties of a road network, an R-tree is constructed for the minimal bounding rectangles of the polylines in the network. With this framework, algorithms are proposed to answer the above-men tioned query classes. However, this work does not focus on route queries nor their evaluation. Given a large set of points, and assuming that the distance between a pair of points is their Euclidean distance, the authors in [11] formulate and solve the  X  -autonomy and k -stops shortest path queries in spatial databa ses. To solve these problems, algorithms with pruning are introduced which optimize the search space. However, it is not clear how their techniques can be extended effectively to network environment in which the distance is given as the path length. A class of optimal route queries known as Trip Planning Query ( TPQ ) is introduced and investigated in [4] . Given a set of points P , where each point belongs to a specific category, a source and a destination, TPQ retrieves the best trip that passes through at least one point from each category. This problem is known to be NP -hard. In this work, the authors propose several fast approximation algorithms for TPQ . A number of approximation algorithms with various approximation ratios are proposed and investigated. For different instances of the problem, one can choose the algorithms with the best approximation ratio. Since all these are approximation algorithms, an op timal trip is, however, not guaranteed. Work has been done on efficient evaluation of SP queries on massive graphs. Several methods have been proposed to solve the SP problem under the disk-based framework. See for instance [1] [2] [5] [7] [8] . To solve the scalability pr oblem, all of them use a graph partitioning technique, and consist of a pre-processing and a query evaluation phases. A distinct feature of all these approaches is to use data materialization to speed up the query evaluation process. During the pre-processing, a graph is first divided into a set of fragments which are stored on a disk. Each fragment is small enough to be load ed into the main memory, and is a unit of transfer from the disk to the main memory. Because a graph is massive, some pre-com putations are performed on these fragments, and the resulting information is materialized, commonly on some disk-based structures. Having pre-processed the network, the system is ready to evaluate SP queries. During the query evaluation phase, these methods make full use of the pre-computed data to reduce the execution time and I/O accesses. Since our proposed optimal route query evaluation algorithm is derived from an algorithm called DiskSP in [2] , we briefly outline the algorithm here. With the help of an R-Tree, an arbitrary large graph G can be partitioned into a set of fragments. Fragments are stored on disks, and each is accessed as a unit during query processing. During the pre-processing phase and after the fragment database is created, the distance database DMDB and the sketch graph for the query class Q ( G ,  X  ) are constructed. An SP query is evaluated by an algorithm called DiskSP [2] . We describe conceptually how an SP query is evaluated here. Given DMDB ( Q ( G ,  X  )), DiskSP evaluates a query in two steps: skeleton path finding and skeleton edge filling . In the skeleton path finding phase, a disk-based variant of Dijkstra X  X  algorithm is invoked to compute an SP p from s to d in Conceptually, an augmented super graph is obtained by merging the source fragment S and the destination fragment D into the physically constructed. Instead, the source and destination fragments are main-memory re sident, and the corresponding boundary nodes and their distance matrices are read into main memory, whenever a part of the augmented super graph is processed. The s -d path p found in the first step is called a skeleton path . A skeleton path may cont ain edges from the super graph, and they are called skeleton edges . Each skeleton edge in fact represents an SP in some fragment for the two boundary nodes. In the skeleton edge filling phase, for each skeleton edge of p , the actual SP in the corresponding fragm ent is computed, and then SP to query Q ( G ,  X  , s , d ). A contribution in [2] is the introduction of two sketch graph pruning algorithms; one is based on the boundary set distance matrix ( BSDM ) and the other is based on x -hop graphs ( XHOP ) which results in two SP evaluation algorithms DiskSP DiskSP XHOP . With these pruning techniques, a BSDM and x -hops graphs are pre-computed in the pre-processing phase. With the introduction of pruning, an SP query evaluation algorithm consists of three phases: sketch graph pruning , skeleton path finding , and skeleton edge filling . In DiskSP and DiskSP XHOP , the first phase is handled by a sketch graph pruning algorithm, while the last two phases are implemented by invoking DiskSP . In this work, we first show that DiskSP can be generalized to evaluate other optimal route queries. More specifically, we prove that some classes of optimal route queries, which we call constraint preserving ( CP ), can be evaluated very fast with a unified route query evaluation algorithm. CP optimal route queries include many real-life optimal route queries such as SP, fo rbidden edge/node and  X  -autonomy queries. The CP optimal route query classes will be defined in Section 4.2 . The generalized DiskSP , which we call DiskCP , will be discussed in Section 4.2 . In Section 4.3, we show that two sketch graph pruning algorithms [2] mentioned in Section 3.3 can be improved and extended to prune sketch gra phs for CP optimal route queries. In Section 4.4, we discuss se veral techniques that reduce the execution time and I/O cost for finding skeleton paths in DiskCP . The new algorithms, with improved sketch graph pruning and with all optimization techniques incorporated, are called DiskCP BSDM and DiskCP XHOP . It has been shown that SP query evaluation benefits significantly from distance materialization [2] . We now define a set of optimal route query classes that can be evaluated very fast with this method. To our best knowledge, the proposed algorithm is the first disk-based algorithm that can be used to evaluate classes of optimal route queries. Moreover, th is set of optimal route query classes is the largest that can be evaluated very fast with distance materialization by a unified algorithm. Consider the n -consecutive nodes query class. If a path p in G has fewer than n-1 edges, then p is not considered to be well-defined, and we said p is not in the domain of the constraints. A path p is satisfying wrt  X  if p is in domain of  X  and is evaluated to true wrt  X  .Given a graph G and a constraint  X  on paths in G ,  X  is said to be constraint preserving ( CP ) wrt G , if (i) given any satisfying path p wrt  X  in G , any sub-path q of p is also satisfying wrt  X  , and (ii) given any sequence of connected paths p 1 , p 2 ,..., p n &gt;0, such that each path p i satisfies  X  , then the path p = p also satisfies  X  , where  X  is the path concatenation operator. Two consecutive paths are said to be connected if the end point of first is the start point of the second. A sequence of paths are connected if each consecutive pair is. The definition of CP captures the essence of when a query class can be evaluated fast under our framework with distance ma terialization. It remains to be seen if a fast algorithm can be found for classes of non-CP queries. An optimal route query class Q ( G ,  X  ) is said to be constraint preserving ( CP ) if  X  is CP wrt G . Clearly, CP optimal route query classes are a subset of optimal route query classes. Not every optimal route query class is CP. For instance, k -stops [11] and trip-planning query classes [4] and n -consecutive nodes query classes, where k and n  X  3, are not CP, and thus cannot be evaluated with the proposed algorithm. On the other hand, SP query, forbidden edge/node query,  X  -autonomy query classes [11] are CP. The reason that CP route query classes can be evaluated effectively is due to the following property. Corollary 4.1 : Let Q ( G ,  X  ) be a CP optimal query class, and p be satisfying wrt [Proof] Follows from the definition of CP optimal route query classes.  X  Let G  X  be a graph obtained from G by removing all edges not P ( G ) be G 's partition. Let the partition obtained by removing all unsatisfying edges from P ( G ), denoted as P' ( G 1-1 correspondence between fragments in P ( G ) and P' ( G and F X  be a corresponding pair of fragments from P(G) and P' ( G  X  ), respectively. Then F X  is obtained from F by removing all unsatisfying edges. To simplify the discussion, we assume from now on, whenever we talk about G and its transformed G ', their partitions are P(G) and P' ( G  X  ), respectively. path in G , and G  X  be G 's transformed. The path p is satisfying wrt  X  in G iff p is a path in G  X  . [Proof] Follows from Corollary 4.1 and from the definition of G 's transformed.  X  By Corollary 4.2, finding an optimal route in a graph G is the same as finding an SP in the transformed graph G the problem of finding optimal routes for CP query classes can be reduced to the problem of finding shortest paths with distance materialization. query class, and G  X  be G's transformed. Then (i) DMDB ( Q ( G ,  X  )) SG ( Q ( G  X  ,  X  )) are the same. [Proof] : Follows from the definitions of transformed graphs and partitions, and from Corollary 4.2.  X  As in DiskSP , DiskCP accepts seven parameters: s , d , S , D , F , M , K . Nodes s and d are source and destination, respectively, and S and D are their corresponding fragments. F and M are the fragment database and distance database for the query class to guide or limit the search of a skeleton path in evaluating a query. K is produced in the sketch graph pruning phase. DiskCP is a generalization of DiskSP since M is more general in DiskCP . In DiskSP , M is a distance database for the query class Q ( G ,  X  ), while the input M to DiskCP is a distance database for a CP optimal route query class Q ( G ,  X  ). Given an SP query Q ( G ,  X  , s , d ), DiskSP can be considered as a be considered as a Dijkstra X  X  applied to an augmented super graph ASG ( Q ( G ,  X  , s , d )), where Q ( G ,  X  ) is a CP optimal route query class. However, there is one more change to DiskSP to obtain DiskCP : after a node in the source or de stination fragment is closed, DiskSP relaxes all adjacent open nodes. However, in DiskCP , after a node in the source or de stination fragment is closed, instead of relaxing all adjacent edges, only those satisfying adjacent edges (wrt  X  ) are relaxed. Adjacent edges considered include edges in the source and destination fragments, and super edges in the super graph. By construction, each super edge denotes an optimal path in some fragment, thus, each super edge is satisfying (wrt  X  ). DiskCP is a generalization of DiskSP , and is obtained with the above-mentioned modification from DiskSP . We are now ready to show that DiskCP correctly evaluates CP optimal route queries. Conceptua lly, given a CP optimal route query Q ( G ,  X  , s , d ), DiskCP computes a skeleton path by applying Dijkstra X  X  , starting from s , to an augmented super graph skeleton path of the answer Q ( G ,  X  , s , d ). Let G be a graph, and G X  it's transformed. Consider the augmented super graphs for queries Q ( G ,  X  , s , d ) and Q ( G By Corollary 4.3, the augmented super graphs ASG ( Q ( G and ASG ( Q ( G ,  X  , s , d )) differ only on the unsatisfying edges (wrt  X  ) in the source and destination fragmen ts. That is, if we remove all unsatisfying edges in the source and destination fragments from ASG ( Q ( G ,  X  , s , d )), the two augmented supe r graphs are identical. Consider now we apply DiskSP to ASG ( Q ( G  X  ,  X  , s , d )), and invoke DiskCP to ASG ( Q ( G ,  X  , s , d )). Recall that DiskCP is obtained from DiskSP by relaxing only satisfying edges. This implies that the set of edges in source and destinati on fragments that can be relaxed by both algorithms are identical. Therefore, p is a skeleton path skeleton path returned by DiskCP on ASG ( Q ( G ,  X  , s , d )). Corollary 4.4 : Let Q ( G ,  X  , s , d ) be a CP optimal route query. DiskCP correctly evaluates Q . [Proof] : Follows from the above argument, and from the correctness of DiskSP .  X  It is necessary to prune a graph in order to minimize the search space. Two techniques were proposed in [2] to prune a sketch graph before a skeleton path is found. These techniques can be extended naturally to CP optimal route queries. Both techniques require some distance materialization: Boundary Set Distance Matrix ( BSDM ) and x-hop sketch ( XHOP ) graphs , respectively. These data are computed in the pre-processing phase. Given a pair of boundary sets in a sketch graph, BSDM contains an upper and a lower bounds on the shortest distances between nodes in the pair. Likewise, an x -hop sketch graph can be used to derive an upper bound and a lower bound on the shortest distances between nodes in any pair of boundary sets. Given a CP query class, instead of finding SPs in the pre-computation, optimal routes are computed. With this modification, it can be proven that BSDM and x-hop sketch graphs pruning can be generalized to any CP query class. During the sketch graph pruning, algorithms in [2] prune boundary sets by searching the whole sketch graph. Instead of using an exhaustive search, we propose algorithms that based on the BFS which optimizes the pruning process. Example 4.1 : Figure 1 provides an example of the improved sketch graph pruning based on BSDM . Given a query Q and a boundary set BS , the table (which can be derived from the fragments and pre-computed data) gives the lower bounds from s to (any vertex in) BS and from (any vertex in) BS to d . An upper bound U ( Q ) from s to d is computed (from the fragments and pre-computed data), and assumed to be 13. First, check the adjacent boundary sets of s , BS [ F 0 F ] in source fragment F 0 , where L ( Q , BS [ F 0 F ])+ L ( BS [ F 0 , F 2 ], d )=17&gt; U ( Q )=13 and L ( Q , BS [ F F ]. Then, check the adjacent unvisited boundary set of BS [ F F ], which is BS [ F 1 , F 3 ], and L ( Q , BS [ F F ])+ L ( BS [ F 1 , F 3 ], d )=15&gt; U ( Q )=13. Thus, BS [ F available from s to other unvisited boundary sets. Consequently, we can prune them without co mputing any lower bounds. After pruning, BS [ F 0 , F 1 ]is the only boundary set in the sketch graph. With the pruning approach in DiskSP BSDM , we need to compute 7 L ( Q , Y )'s, whereas with the new BFS method, and in this example, only 3 lower bounds are calculated.  X  The above BFS idea can be extended, albeit a bit more complex, to sketch graph pruning based on the XHOP technique. The two versions of DiskCP , with the corresponding improved sketch graph pruning incorporated, will be referred to as DiskCP Under this framework, finding a skeleton path is a major cost in evaluating a route query. Another contribution of this work is several optimization techniques fo r a faster computation of a skeleton path Under this framework, sketch graph pruning is the first phase in finding an optimal path. During the pruning phase, an outgoing incoming (local) SPT d rooted at destination d in destination fragment D are first computed. Hence, the optimal distances from s to any vertex in S , and the optimal distances from any vertex in D to d have been calculated. These computed optimal distances could be used to facilitate the second phase, the skeleton path finding phase. graph for the query from the super graph. The differences between an augmented super graph and a query super graph lie in the source fragment and the destination fragment. The former includes all nodes and edges in S and D , while the latter contains only the outgoing super edges of s to all boundary nodes inside S , and the incoming super edges from all boundary nodes in D to d . Computing a skeleton path in a query super graph is faster than that in its corresponding augmented super graph. Dijkstra X  X  algorithm on the (pruned) super graph to compute a skeleton path from s to d . It iteratively selects a vertex u , with the minimum optimal distance from s , among all open vertices in the (pruned) super graph, adds it into a closed vertex set, then retrieves all adjacent edges of u and does relaxation on them. If u is a boundary vertex, then all adjacent super edges of u are which is selected and closed in some i th iteration. Obviously, all boundary vertices in fragments F 1 and F 2 (except u ) are u's adjacent vertices in super graph and are relaxed in the i Let a skeleton path p s be &lt;e 1 , e 2 , ... , e m &lt;v x , v y &gt; F k and e i = &lt;v y , v z &gt;F k X  edges, for some i  X  [2, m ]. The vertex sequence &lt;v sequence of boundary vertices. Then, the predecessor of boundary vertex v y in path p s is v x and the successor of v Likewise, the adjacent fragments F k and F k  X  are said to be predecessor fragment and the successor fragment of v respectively. It can be proven that, once v y is closed, it is unnecessary to relax the outgoing super edges of v predecessor fragment F k . property for any boundary vertices x, y, z in a fragment F : SD ( F, the fact that, given a CP query class, the existence of optimal Let u be a boundary vertex in a fragment F . Assume that p is a skeleton path from s to u . Let F be the predecessor fragment of u on a skeleton path p . With the triangle inequality property, we can prove that it is unnecessary to relax the outgoing super edges of u inside its predecessor fragment F . The way to prove this claim is to show that, even if those e dges were relaxed, the optimal distance of the head of a relaxed edge will not be improved. on the length of the answer to Q . Likewise, given a boundary set Y , L ( Y , d , Q ( G ,  X  )) is a lower bound on the distance from any vertex in Y to the destination d . Given a vertex x , we denote x.distance as the currently computed optimal distance from source s to x in a given graph G . We observe that when a boundary vertex v  X  Y is closed, where Y through v . Moreover, all currently non-closed vertices of Y can also be pruned. Since this technique reduces the number of boundary nodes that need to be closed, it has the advantages of reducing both the skeleton path computation time and DMDB accesses. On the other hand, the testing cost is negligible, because computed. We first describe the environmen t of the experiments in Section 5.1, and then present the experime ntal results in Sections 5.2 and 5.3. The PC for testing is a Pentium IV 1.6 GHz system with 1GB DDR, and the hard drive is an Ultra ATA/100 at 7,200 rpm. The operating system is Microsoft Windows Server 2000 with SP4. All algorithms are implemen ted with Java 1.4.1. The road system of Connecticut, denoted as CT , from Tiger/Line file [12] is chosen as our first test case. CT is small enough to be loaded into the main memory and yet large enough to test the proposed main-memory and disk-based algorithms. To test the scalability of the proposed disk-bas ed algorithms, the road system of eastern five states, which is denoted as East5 , is used as the second test case. East5 is com posed of the road systems of Connecticut, Massachusetts, New Jersey, New York, and Pennsylvania. It consists of more than three million edges and two and half million nodes. To make a homogeneous environment, we set the Java Virtual Machine (JVM), for CT and East5 test cases, to 512MB and 1GB, respectively. It has been shown that, for DiskSP , the optimal fragment size for CT and East5 are 1000 nodes and 2500 nodes, respectively [2] . On average, each such a CT fragment occupies 145KB while an East5 fragment is about 272KB. These fragment size da tabases are used in the experiments. The size of the fra gment databases for CT and for East5 are 20MB and 315MB, respectively, while the size of distance databases DMDB for CT and for East5 are 2 MB and 40 MB, respectively. Because the sketch graph pruning algorithms are designed for different circumstances, for CT, the algorithm DiskCP BSDM is called while for East5, DiskCP XHOP is invoked. For DiskCP , the most I/O intensive structure is DMDB and its cache size is set to 25%. Since at most two fragments are needed during query evaluation, the cache size of a fragment database is set so that at most two fragments, at any time, are main-memory resident. All other data struct ures consume a relatively small amount of memory, and their cache sizes are set to 100%. For each optimal route query class, and for each data set we are going to investigate, a set of tested queries is generated for each range: long , medium , and short . These queries represent optimal paths of different lengths. As explained in Section 4.2 , all CP query classes can be reduced to the SP query class. Thus, SP query class is used in all experiments in this subsection. The result obtained for SP query class should carry over to other CP route query classes. Each query set consists of 100 randomly generated queries. In Section 4.3 , a sketch graph pruning based on BFS is proposed. All CP route query classes s hould benefit from sketch graph pruning. Since a sketch graph is small enough to be main-memory resident, the execution time of a sketch graph pruning is proportional to the number of lo wer bound computations, and thus it is used in evaluating different pruning algorithms. The experimental result in Table 1 shows that, with our proposed BFS pruning algorithms, the number of lower bound computations are reduced drastically. The reduction varies from 30% for long-range queries to 80% for short-range queries. In Section 4.4 , we propose three techniques to improve the performance during the skeleton path finding phase, and they are:  X  We propose to conduct the skeleton path computation on a  X  Instead of relaxing all outgoing super edges of a closed  X  We introduce a dynamic pruning (DP) of boundary vertices. Since the proposed techniques are for improvement on the skeleton path finding , we concentrate on this particular step only in this part of the discussion. For execution time, the dominant costs are graph-related operations. For I/O cost, the most significant is the accesses to DMDB . The advantages of using a query super graph, instead of an augmented super graph, in computing a skeleton path are that there is no  X  X erging X  of source a nd destination fragments, and the size of the graph is likely smaller. As a result, the algorithm is less complex, and the computation time is shorter. Experimental results (not included here) show that the queue operations using a query super graph, relative to an augmented super graph, are reduced by from 15% to 22%. However, this technique has no influence on DMDB accesses. Table 2 illustrates that, in both CT and East5 data sets, the successor fragment relaxation tec hnique reduces the number of times boundary nodes are accessed (which is the same as the number of times adjacent edges are relaxed) by more than 40%. Consequently, the skeleton path computation time is reduced as well. Since the distance matrix for adjacent boundary nodes are likely in cache when a boundary node is closed, this technique does not improve much on the DMDB accesses. Dynamic boundary node pruning resu lts in a fewer number of boundary nodes need to be processed. Table 3 shows the reduction in the number of clos ed boundary nodes. It is worth noting that the number of nodes closed is to the number of iterations in the skeleton path finding algorithm. For both the CT and East5 data sets, the reduction is about 30%, and is independent of the query type. Fewer number of closed bounda ry nodes implies shorter computation time and fewer DMDB accesses. The improvement of the I/O calls to DMDB is illustrated in Table 4. It shows the reduction of distance matrix I/O calls for CT (East5) data set ranges from 11% (22%) for short queries to 17% (24%) for long queries. Thus, this technique reduces the I/O cost of skeleton path computation, and its benefit incr eases proportionally with the size of the graph and the length of a query. In this section, we shall show that DiskCP outperforms, by a wide margin, both the main memory and disk-based brute-force algorithms MMCP BF and DiskCP BF . This shows the desirability of DiskCP . This also demonstrates that distance materialization is essential in fast CP route query evaluation. Since East5 is too large to be main-memory resident, only DiskCP and DiskCP compared for this data set. MMCP BF is obtained from main-memory Dijkstra X  X  with a slight closed during an iteration, instead of relaxing all adjacent edges, MMCP BF only relaxes all satisfying adjacent edges wrt  X  . So in effect, MMCP BF is Dijkstra X  X  applies to G X  X  transformed G Corollary 4.2, MMCP BF correctly computes the answer to a CP query. Once a graph is partitioned into a collection of fragments, one can apply a Dijkstra -like algorithm onto fragments to compute a CP optimal route. In such an algorithm, no pre-computed data such as distance materialization is used to speed up the search process. In DiskCP BF , the search for a path starts from the source by reading in the source fragment and its auxiliary data structure. Nodes are extracted from the prio rity queue iteratively. In each satisfying edges with respect to  X  are relaxed. It takes a relatively long time for brute-force algorithms to execute a CP query. Since East5 is significantly larger than CT, the number of randomly selected queries for a query set for CT and for East5 are 30 and 15, respectively. Each testing result is the average of all queries in a query set; each query is executed once. Three optimal route query classes are chosen in our evaluation: SP , forbidden edges , and forbidden nodes queries. These three sets are chosen because of their importance and/or potential real-life applications. For forbidden edges queries, 1 % and 0.1 % of edges in CT and East5, respectively, are randomly selected to form the forbidden edges set. No optimal route can pass through any edges in the forbidden set. For forbidden nodes queries, five nodes or seeds are first selected; one in the center of the graph and the remaining four locate at the center of the four quadrants of the graph. Each of the five seeds selected is used to generate a cluster of forbidden nodes. Starting with a seed, a B FS is performed to locate all forbidden nodes in a cluster. The search is terminated when the number of nodes in a cluster reaches ( x  X  V )/5, where V is the number of nodes in the graph. The values of x are 0.2 % and 0.01 % for CT and East5, respec tively. For forbidden nodes queries, no optimal route is allowed to pass through a node in any of the five clusters. For DiskCP BF , we measure the amount of I/O performed on fragment databases and on the aux iliary data required during its execution. We observe that whenever a fragment is accessed, its auxiliary data are also retrieved. Consequently, for DiskCP cache sizes for fragment database and for auxiliary database are set to the same value. We experiment several cache sizes for CT and for East5 data sets, and we found the optimal cache sizes for DiskCP BF East5 are 50 % and 20 % , respectively. These cache sizes are used in the rest of the experiments. The cache sizes for disk-based structures in DiskCP are stated in Section 5.1. Due to the nature of these algorithms, the memory requirement by DiskCP significantly larger than that by DiskCP . Queues are an important part for all these algorithms. Thus, the number of queue operations perform ed is a good indication of the complexity of an algorithm. Consequently, in addition to execution time, the number of queue operations are also compared among these algorithms. Since the results in forbidden nodes/edges query classes have a similar trend as those in SP query class, we just summarize their experimental results without explicitly giving all data. Table 5 compares the I/O of the two disk-based CP algorithms: DiskCP (CP) and DiskCP BF (BF). The amount of I/O by DiskCP for CT (East5) data set, relative to DiskCP BF , are reduced by 91 % (95 % ) for short queries and 95 % (97 % ) for long queries. Thus, DiskCP requires only a small fraction of I/O accesses in evaluating an SP query when compared with DiskCP BF . Table 6 records the average number of queue operations by all three algorithms. Relative to MMCP BF (MM), the average numbers of queue operations of DiskCP on short, medium, and long queries on CT data set are reduced by 85 % , 89 % , and 88 % , respectively. With respect to DiskCP BF , the reduction of queue operations on short, medium and long queries on CT (East5) are 91 % (95 % ), 92 % (97 % ) and 92 % (96 % ), respectively. Table 7 shows the running time for all three algorithms. The execution time confirms the results obtained in Tables 5 and 6. Over all query sets, DiskCP BF has the worst running time while DiskCP performs the best. For CT data set, the query evaluation time of DiskCP , compared to that required by MMCP BF , is about 18 % for short and up to 25 % for long queries. Compared to DiskCP BF , DiskCP requires about 8 % of DiskCP BF execution time to evaluate a query, independent of the query sets. For East5 data set, the reduction of execution time is even more dramatic. For short, medium and long queries, DiskCP requires only 4 % , 1.5 % and 2 % , respectively, of time needed by DiskCP BF . Thus, with a relatively small am ount of distance materialization and with the proposed optimizati on, the CP query evaluation time and I/O can be reduced drastically. This result also demonstrates the scalability of DiskCP . Without showing the actual data, the amount of I/O by DiskCP for CT (East5) data set, relative to DiskCP BF , are reduced by 81 % (91 % ) for short queries and 86 % (93 % ) for long queries. Relative to MMCP BF , the average numbers of queue operations of DiskCP on short, medium, and long queries on CT data set are reduced by 85 % , 89 % , and 89 % , respectively. With respect to DiskCP reduction of queue operations on short, medium and long queries on CT (East5) are 90 % (96 % ), 93 % (97 % ) and 92 % (96 % ), respectively. Table 8 shows the running time fo r all three algorithms. For CT data set, the query evaluation time of DiskCP , compared to MMCP BF , is about 27 % for short and up to 31 % for long queries. Compared to DiskCP BF , DiskCP requires only 12 % for short and 8 % for medium and long queries of DiskCP BF execution time to evaluate a query. For East5 data set, the reduction of execution time is even more significant. For short, medium and long queries, DiskCP requires only 4 % , 2 % and 2 % , respectively, of time needed by DiskCP BF The reduction in the amount of I/O and queue operators by DiskCP, relative to the other two algorithms, are similar to the above two cases.
 Table 9 shows the running time. For CT data set, the query evaluation time of DiskCP , relative to MMCP BF , is about 21 % for short and up to 27 % for long queries. Compared to DiskCP DiskCP requires only 9 % for short and 8 % for long queries of DiskCP BF query evaluation time. For East5 data set, DiskCP requires only 2 % -4 % of time needed by DiskCP BF . We have studied the problem of how to evaluate fast and efficiently classes of optimal route queries by a unified algorithm on a massive graph. To evaluate th e queries effectively, a graph is partitioned and distance information of some paths are materialized. Under such a setti ng, we found an algorithm, which we called DiskCP , that can be used to evaluate classes of optimal route queries. To our best knowledge, DiskCP is the first disk-based algorithm that can evaluate classes of optimal route queries efficiently. The classes of queries that are evaluated by DiskCP are called constraint preserving ( CP ). CP optimal route queries contain, among others, SP, forbidden edges and nodes,  X  -autonomy, and some of the hypot hetical weight changes route query classes. They also represent the largest classes of optimal route queries that can be evaluated very fast with distance materialization on a massive graph. We then turn our attention to the optimization of the proposed algorithm. With this method, a query is evaluated in three steps: sketch graph pruning , skeleton path finding and skeleton edge filling . There is not much optimization can be done in the last phase, and techniques were found to speed up the evaluation process for the first two phases. For sketch graph pruning, we generalized existing pruning algorithms [2] to the CP optimal query classes. Moreover, we improved the running time by employing the BFS, instead of an exhaustive search. In finding a skeleton path, several optimizati on techniques were proposed to reduce the execution time and I/O accesses. Experiments were conducted and these techniques have been shown to be effective. To evaluate DiskCP , we implemented a main-memory ( MMCP and a disk-based ( DiskCP BF ) CP route query evaluation algorithms with no data materialization. Three optimal route query classes were chosen in the test, and they are SP, forbidden edges and forbidden nodes. To investigate the scalability of these disk-based algorithms, two data sets were chosen: a relatively small graph called CT and a larger graph named East5. We showed empirically that the proposed DiskCP algorithm outperforms, both in term of execution time and I/O accesses, the main-memory and the disk-based algorithms by a wide margin. When respect to CT data set, the execution time of DiskCP ranges from 18 % to 31 % that of required by MMCP BF . When compared with DiskCP BF , the running time (I/O accesses) ranges from 8 % (5 % ) to 12 % (19 % ) of that required by DiskCP BF . For East5 data set, the execution time (I/O accesses) of DiskCP is about 1.5 % (3 % ) to 4 % (10 % ) of that needed by DiskCP BF DiskCP is desirable and scalable in evaluating CP optimal route queries. This also implies that distance materialization is essential in fast CP route query evaluation, especially when the graph is large. The CP optimal query classes can be evaluated fast is due some pre-computation is done on a graph so that this information is used to speed up a route query evaluation. It is an open question to see if and how non-CP query classes can be evaluated in a similar fashion. Although non-CP op timal query classes cannot be evaluated directly with the proposed algorithm, some of these non-CP query classes, such as in stances of trip planning query classes, can be evaluated with th e help of the proposed algorithm. Throughout the discussion, a graph is assumed to be static. This work also requires the query class to be known in advance so that pre-processing can be performed on it. Currently, we are investigating on how to relax thes requirements in fast route query evaluation. The authors wish to thank the financial support of the Natural Sciences and Engineering Research Council of Canada. [1] Agrawal, R. and Jagadish, H. V., ``Algorithms for Searching [2] Chan, E.P.F. and Lim, H., Evaluation and Optimization of [3] Guo, L. and Matt, I, `Search Space Reduction in QoS [4] Li, F., Cheng, D., Hadjieleftheriou, M., Kollios, G. and [5] Hutchinson, D., Maheshwari, A. and Zeh Z., An External-[6] Korkmaz, T., and Krunz, M., Multi-Constrained Optimal [7] Jing, N., Huang Y.W. and Rundensteiner, E.A., Hierarchical [8] Jung, S. and Pramanik, S., An Efficient Path Computation [9] Juttner, A., Szviatovszki, B., Mecs, I., and Rajko, Z., [10] Papadias, D., Zhang, J., Mam oulis, N. and Tao, Y., Query [11] Terrovitis, M., Bakiras, S., Papa dias, D., and M ouratidis, K., [12] Tiger/Line Files, US Department of Commerce Economics [13] Vazirgiannis, M and Wolfson, O., A Spatial temporal Model 
