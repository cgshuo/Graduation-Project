 Software developer X  X  working process could benefit from the support of an active help system that is able to recommend applicable and useful integrated development environment (IDE) commands. While previous work focused on predic-tion methods that can identify what developers will eventu-ally discover autonomously, and without taking into account the characteristics of their working tasks, we want to build a system that recommends only commands that lead to bet-ter work performance. Since we cannot expect that devel-opers are willing to invest a significant effort to use our rec-ommender system (RS), we are developing a context-aware multi-criteria RS based on implicit feedback.

We already created and evaluated context and user mod-els. We also acquired a data set with more than 100,000 command executions. Currently, we are developing RS al-gorithm for predicting the scores of performance and effort expectancy and developer X  X  intention to use a specific com-mand. We are also developing a user interface, that has to be persuasive, effective, and efficient. To date, a user interface for IDE command RS has not been developed.
 integrated development environment; command; recommen-dation; context
Modern integrated development environments (IDEs) bring together multiple tools to create and manipulate software project artifacts. Professional software developers spend most of their time working in an IDE and to effectively use it, they have to know a large number of commands that could be relevant for the task at hand, such as Generate Getters and Setters, Open Resource, and Navigate to Type Definition, amongst others. Previous research shows that developers use IDEs sub-optimally [10], thus, their learning and working process could benefit from the support of an ac-tive help system that is able to recommend applicable and useful commands.

Recommender systems (RSs) are personalized informa-tion search and filtering tools that suggest useful items [12]. Murphy-Hill et al. [11] showed that it is feasible to auto-matically recommend novel and useful IDE commands, even when simple RS algorithms are used. Nevertheless, in our opinion, if the goal of a RS is to recommend an item with the largest utility for the developer, current scientific work in IDE command recommendations suffers from several de-ficiencies. First, state-of-the-art algorithms focus on accu-rately predicting the next command that the developer will autonomously discover, which is generating redundant and not only novel command recommendations, as the online evaluation in [11] indicates. Second, such an approach rec-ommends commands without considering their relevance to the developer X  X  work, which may lead to better IDE knowl-edge, but not necessarily to better work performance of the developer. And third, to the best of our knowledge, a stan-dalone IDE command RS has not yet been implemented: Zolaktaf and Murphy [16] performed only offline evaluations, while Murphy-Hill et al. [11], who performed an online eval-uation, presented the recommendations to the study partic-ipants in-person , instead of developing a user interface or its mock-up to decrease the effect of presenter X  X  persuasiveness on the perceived quality of the recommendations.

While previous work focused on prediction methods that can identify what developers will eventually discover au-tonomously, and without taking into account the charac-teristics of their working tasks, we aim at developing an IDE command RS that can improve developer X  X  use of an IDE, which, ultimately, has to result in a better work per-formance, since developers are not interested in becoming IDE experts, but only want to complete their tasks as quick and as good as possible. Consequently, we have to create an algorithm that is capable of identifying commands that the developer can and will use during the work and we have to devise a user interface through which the acceptance of useful recommendations can be attained. We seek to answer the following research questions:
RQ1: How to generate valuable work-related IDE command RQ2: How to present IDE command recommendations?
We already created context and user models that enable the detection of different situations in which certain (differ-ent) developers are using certain (different) commands. Now we are developing a RS algorithm based on implicit feedback and context that can predict the scores of performance and effort expectancy and developer X  X  intention to use a specific command; and we are developing a user interface that has to be persuasive , effective , and efficient .
Matejka et al. [9] apply collaborative filtering algorithms and domain knowledge to provide command recommenda-tions in AutoCAD. Murphy-Hill et al. [11] apply the same algorithms as [9] and four new algorithms to recommend commands in Eclipse, 1 namely,  X  X ost widely used X ,  X  X ollab-orative filtering with discovery X ,  X  X dvanced discovery X , and  X  X ost popular discovery X  algorithms. The first algorithm is a special version of the  X  X ost popular X  algorithm, while other three are based on sequential pattern mining, which is used to model the process of discovery of new commands. When the most successful algorithms were used in an online study, experts evaluated 26% of commands as novel, while novices evaluated 80% of commands as such, and experts evaluated 80% of commands as useful, while novices evaluated 100%.
Zolaktaf and Murphy [16] suggest a new algorithm for command recommendations that is based on the command discovery patterns and co-occurrence of command execu-tions in the session. The offline evaluations show that this algorithm outperforms other existing algorithms, according to the accuracy of predicting the next command that will be discovered by the developer.

We are developing a context-aware multi-criteria RS based on implicit feedback that aims at convincing software devel-opers to learn new IDE commands. By the RSs commu-nity, the command recommendation as such has not been addressed yet, however, there exists a large body of work in the domains that are related to our problem. Adomavi-cius et al. [2] define the context-aware RSs (CARSs): the overview of recent developments is provided by Adomavi-cius and Tuzhilin [3]. Adomavicius and Kwon [1] present the field of multi-criteria RSs. Hu et al. [7], in their sem-inal work, describe the properties of implicit feedback and propose some techniques for generating recommendations. Jameson et al. [8] describe everyday human decision mak-ing approaches that are relevant also in the context of RSs. Tintarev and Masthoff [13] discuss the role, the design, and the evaluation techniques for recommendation explanations.
In this section, we present more in detail the IDE com-mand recommendation approach that we have designed and plan to implement. We assume that the Unified Theory of Acceptance and Use of Technology [14] (UTAUT) can help us to understand the drivers of command acceptance. Ac-cording to Venkatesh et al. [14], three determinants directly affect the intention to use a new system X  X n our case, a new IDE command: http://www.eclipse.org
The first two aspects (performance and effort expectancy) of IDE command can be highly influenced by recommen-dation generation and presentation, while the third aspect (social influence) is less impacted by them [6]. We want to develop and implement an algorithm that will be able to assess the individual criteria (performance expectancy and effort expectancy) and properly integrate these evaluations into a prediction of the intention of a specific developer to use a specific command, if it was recommended.

Generally, the work performance of a software developer is improved if the process or the product under development are improved; however, it is hard to explicitly define how useful an IDE command is, since the perception of the qual-ity and the value of saving time varies between developers, teams, and organizations. For instance, even if it seems un-necessary and inefficient to use some refactoring commands in a certain moment, they may lead to better readability of the source code, which can decrease long-term maintenance costs, or to less bugs, which can increase customer satisfac-tion. Since we cannot assume that developers are willing to change their working process or to invest a significant effort to use our RS, we have to rely on implicit feedback X  the execution of a command X  X nd the observations of the context X   X  X ny information that can be used to characterize the situation of an entity X  [5], which is in our case the sit-uation of a developer using an IDE X  X hat do not require repetitive or substantial manual effort. We posit that the estimation of the performance can be based on models that are not only learned from the data and explicit input but are based on general principles, i.e., heuristics. We assume that the performance of a command can be defined implicitly: the command is more useful if the target developer finds herself more often in the situations in which the command is executed more often. These situations can be identified using the context model described in Section 4.

The effort required to use an IDE command consists of the learning effort and the command execution effort. Since the effort required to execute a command is negligible, 2 we con-jecture that the overall effort strongly correlates with the effort required to understand why and how the command should be used, which depends on the complexity of the command and developer X  X  knowledge. We assume that the complexity of a command is a characteristic of a command that is independent of developers and context. We plan to estimate the complexity of commands using their descrip-tion text complexity metrics. Nevertheless, developers with more experience, who are more familiar with IDE concepts and its interface, will likely need less effort to comprehend the meaning of the recommended command. Thus, we plan to personalize the recommendations by integrating a user model in the RS algorithm as well.

We assume that the perception of the scores (i.e., ratings) of the individual criteria is correlated to the true (i.e., expe-rienced) value of these criteria. However, it can be largely affected by the recommendation presentation as well. Thus, the goal of the user interface design should be to present the recommendations in a way that developers X  perception of criteria is as close as possible to the true value of it.
To execute a command in a high-functionality application, the user has to select a menu button or press a certain key sequence.
To increase the likelihood of recommendation acceptance, the system has to be persuasive . In our case, it means that the commands have to be presented in such a way that the performance expectancy is high and effort expectancy is low. At the same time, since we are aiming at the long term usage of a RS and we do not want to risk loosing trust by tricking the users, the gap between the expected and experienced values should be small; thus, the command presentation and the recommendation explanation have to be effective [13].
The third criterion we want to satisfy in designing the user interface is the efficiency . Unless the developer is explicitly learning how to use an IDE, we cannot expect that she will be willing to invest a lot of time and effort in the interaction with a RS or simply into reading the explanations of recom-mendations. Moreover, efficient recommendations decrease the required effort, which directly improves the persuasive-ness of the RS as well.

To accurately predict the performance expectancy , effort expectancy , and intention to use an IDE command related to a specific developer, and to satisfy the criteria related to the user interface X  persuasiveness , effectiveness , and ef-ficiency  X  X e need information about the context and the user. For instance, recommending a version control com-mand for resolving merging conflicts to a developer who does not know or use version control will lead to low perfor-mance and high effort expectancy , which will result in a low intention to use , thus, such a command should not be rec-ommended. On the other hand, recommending an editing command to an experienced developer will require low effort from her and can significantly improve the performance, but the presentation and the explanation will have to be convinc-ing to persuade her to change the old development style. We present our context and user models in the next section.
In our previous work, we devised a context model for char-acterizing the situations of a developer using an IDE and a user model for characterizing the developers. They can be used to improve the accuracy of recommendations and to provide the information about the context of command us-age, which can be used as a rationale for the recommenda-tions. In this section, we briefly describe the models, which we plan to incorporate in our IDE command RS.

To date, in software development applications, contextual factors X  X ariables with precise domains of possible values that are used to identify the context X  X ave typically been limited to project artifacts, such as source code [6]. We pro-pose a new context model that consists of eleven contextual factors, which we grouped into three categories:
We also propose a user model that consists of three factors:
The inclusion of factors is based on the previous litera-ture and our own experience. To evaluate the relevance of the factors for describing the IDE usage, we examined the correlations between different situations X  X s described by the proposed factors X  X nd IDE command usage. We gath-ered data about which commands in an IDE were used by eight Eclipse users working in either academia or a medium-sized company for ten weeks; together they executed more than 100,000 commands. The factors included in the model statistically correlate with the usage of at least some com-mands; in particular, when the values of the factors change, different developers X  X s individuals and as a group X  X se com-mands differently, according to Pearson X  X   X  2 and Fisher X  Freeman X  X alton tests. Table 1 displays the results of the tests.
 Table 1: The results of the statistical tests. The values are the numbers of used commands that cor-relate with the factors.
 Developer A B C D E F G H All Num. of used commands 60 93 85 66 81 70 60 15 193 Current activity 41 77 62 39 53 47 37 4 130 Previous activity 30 48 40 36 45 40 19 2 101 Artifact type 22 61 37 33 48 26 26 4 103 Artifact length / / 31 20 34 20 5 / 83 Artifact complexity / / 35 24 38 26 5 / 86 Time of the day 20 32 11 22 14 12 10 0 72 Day of the week 29 40 24 24 43 25 20 5 84 IDE instance / / / / / 20 23 / 136 Active perspective 24 41 10 19 / 18 0 5 122 Opened UI elements 20 66 36 39 43 36 18 4 130 UI element with focus 35 65 50 45 48 44 24 0 126 Developer ID / / / / / / / / 137 Developer general exp. / / / / / / / / 118
Developer IDE exp. / / / / / / / / 10 /  X  the detection failed or the values did not change
By observing the entire sample, we can see that the con-textual factor for which the usage of the most commands changes is developer unique identifier ; this indicates that the systems supporting users in their interaction with an IDE should be personalized, because users behave differently, even if we observe only a small set of users working in a simi-lar environment. Almost the same result is achieved by IDE instance ; probably because only three participants changed it during the case study and consequently it strongly re-flects developer unique identifier . On the third place, we find current activity and opened views and editors . The first could be expected since commands are strictly connected to the current activity : a developer who executed Delete Line command is currently editing and the one who executed Re-sume Debug is debugging, for example. The second is rather unexpected; we assume that opened views and editors indi-cates the change in usage of so many commands because the domain of the factor is so large: it contains 372 different values, which is more than all other factors combined; con-sequently, we conclude that more fine-grained observations lead to higher accuracy, however, the generalizability of the situations may suffer. The only factor that performs very poorly on our data set is developer IDE experience . This is probably due to the size of the set of participants and their characteristics, since we only classified participant H as a  X  X ovice X  and he only executed 15 different commands.
The set of executable commands and the visualization of menu bars in Eclipse depends mainly on the user interface element with focus and type of the artifact under develop-ment . These two factors are outperformed by several other factors that are not taken into account by the IDE. If we knew more about the situations in which commands are use-ful, we could compare them with the situations in which spe-cific developers often find themselves. Hence, an IDE com-mand RS would be able to identify the recommendations that are more suited to developer X  X  work. Such knowledge may be used also for generating explanations of recommen-dations. We discuss the directions of this research next.
We are currently designing a RS algorithm that will in-corporate contextual information according to the contextual modeling paradigm [2]. 3 We are testing our ideas offline, us-ing the data set we acquired during the context model eval-uation. We are also designing the RS user interface. We as-sume that visualizing the command name or key sequence of the shortcut, if it exists, is not sufficient to reach developer X  X  understanding of what the RS is recommending nor to con-vince her to accept the recommendation. We are currently designing different user interfaces, focusing on maximizing their persuasiveness , effectiveness , and efficiency . We are also exploring the possibilities for generating context rec-ommendations 4 for a specific command, which can then be included in the explanations: when the command should be executed; or can be used for calculating the best timing for different recommendations: when should RS suggest devel-opers to learn and start using a new IDE command.

In the future, we plan to perform the evaluations of user interface mock-ups with a survey and in a laboratory setting. Then we will integrate the best performing user interface in our IDE command RS. And at the end, we plan to conduct a case study to evaluate and compare our RS algorithm with the state-of-the-art IDE command RSs and algorithms gen-erally used in CARSs.
Contextual modeling or contextualization of recommenda-tion function refers to a direct usage of the context in the modeling technique as part of the rating estimation. [2]
Baltrunas et al. [4] introduce the best context concept for defining the conditions most suited for a particular item X  X n their case, it is a music track. Zheng [15] presents the latest achievements in this field. We are trying to identify the best context for IDE command. [1] G. Adomavicius and Y. Kwon. Multi-criteria [2] G. Adomavicius, B. Mobasher, F. Ricci, and [3] G. Adomavicius and A. Tuzhilin. Context-aware [4] L. Baltrunas, L. Rokach, M. Kaminskas, B. Shapira, [5] A. K. Dey. Understanding and using context. Personal [6] M. Gasparic and A. Janes. What recommendation [7] Y. Hu, Y. Koren, and C. Volinsky. Collaborative [8] A. Jameson, M. C. Willemsen, A. Felfernig, [9] J. Matejka, W. Li, T. Grossman, and G. Fitzmaurice. [10] E. Murphy-Hill. Continuous social screencasting to [11] E. Murphy-Hill, R. Jiresal, and G. C. Murphy. [12] F. Ricci. Recommender systems: Models and [13] N. Tintarev and J. Masthoff. Explaining [14] V. Venkatesh, M. G. Morris, G. B. Davis, and F. D. [15] Y. Zheng. Context suggestion: Solutions and [16] S. Zolaktaf and G. C. Murphy. What to learn next:
