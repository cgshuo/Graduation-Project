 Mobile devices have become indispensable in daily life, and hence how to take advantage of these portable and powerful facilities to share resources and information begins to emerge as an interesting problem. In this paper, we investigate the problem of information retrieval in a mobile peer-to-peer network. The prevailing approach to information retrieval is to apply flooding methods because of its quick response and easy maintenance. Obviously, this kind of approach wastes a huge amount of communication bandwidth which greatly affects the availability of the network, and the battery power which significantly shortens the serving time of mobile de-vices in the network. To tackle this problem, we propose a novel approach by mimicking different human behaviors of social networks, which takes advantages of Intelligence Ac-curacy (IA) mechanism that evaluates the distance from a node to certain resources in the network. Extensive exper-imental results show the efficiency and effectiveness of our approach as well as its scalability in a volatile environment. H.3.3 [ Information Systems ]: [INFORMATION STOR-AGE AND RETRIEVAL], [Information Search and Retrieval], Search process Algorithms, Performance Information Retrieval, Mobile Networks, Peer-to-Peer
Recently, with the advance in mobile wireless communica-tion technology and the increasing number of mobile users, mobile devices, such as cell phones, PDAs and pocket PCs, have become more and more popular in daily life. These mobile devices generally have gigabytes of storage capacity and can connect to each other using short-range commu-nication access, such as Bluetooth [1] and IEEE802.11 [2]. With such portable devices in hand, we can bring hundreds of documents and multimedia files (i.e., mp3 songs or short movies) wherever we go. Given these facilities, we can imag-ine a scenario where different people are interconnected in a confined area. For example, in a business district with adjacent buildings, people can use their mobile devices to search and share information and resources (e.g., mp3 mu-sic files, e-books, working documents and advertisements), or to find a person providing a particular service. This kind of environment is very popular in real life, such as in schools, business centers, shopping malls, and airports, etc., where mobile nodes can interconnect with each other in a peer-to-peer (P2P) way to form a mobile P2P network.

In such a mobile network, all nodes are generally gathered together to form a P2P network and free to move, join or leave. Since the nodes in the network are highly dynamic or periodically participate, it is very expensive to maintain a structured network overlay. Therefore, a reasonable and practical solution is to construct the nodes in an arbitrary unstructured way [7, 9]. In this manner, nodes just dynam-ically maintain neighbors in their reachable ranges like real neighborhood in social networks, and no special overlay is needed. Specifically, mobile P2P environment differs from the traditional P2P systems based on static nodes. First, nodes in P2P networks are PCs connected through inter-net. They have powerful computing capacity, large stor-age and stable interconnection. The situation is totally dif-ferent in mobile P2P environment, as mobile devices have limited resources (computing capacity, storage, bandwidth, battery power), which means high resource consuming al-gorithms used in P2P networks are not suitable for mobile P2P. Second, nodes in mobile P2P networks are connected via short-range communication access (e.g. IEEE802.11). Thus neighbors are adjacent in physical network and data is transferred in multi-hop manner between non-neighbor nodes. However, two P2P nodes can directly communicate via IP address. Third, mobile nodes move from time to time, which makes the network topology and neighbor rela-tionship vary rapidly. Thus, information frequently used to process queries in P2P literature, e.g. profile of neighbors and query historical records, can not be directly applied. In a word, query forwarding in mobile P2P environment suffers from more limitation, uncertainty and complexness.
Most previous works in mobile P2P networks [4, 8, 13, 23, 17, 24] focus on data dissemination and resource discovery problems, and mainly study how to push the information to end users in the network. In that case, users are pas-sive receivers of information. However, most of the users are likely active searchers of information in real-life applications, where the users can seek resources they want, search specific information for certain purposes, find discount advertise-ments, or download music or files from the network. In this paper, we aim at providing active search for end users. Thus, we tackle the problem of keyword-based query forwarding in file-sharing unstructured mobile P2P networks. Query for-warding differs from message routing in mobile P2P environ-ment. In message routing, the destination of a message is known. Nodes have a prior knowledge of the routing paths. However, in query forwarding, there is no prior knowledge of where to send the messages. This unknown destination implies more uncertainty and less control in message relay-ing. Therefore, the algorithms of distance-aware routing are not appropriate for query forwarding problem.

There exist some challenges for efficient search in such mo-bile P2P networks. First, the q uery routing strategy must be efficient although the global index is not available. Second, due to the constraint of computation capacity, battery en-ergy and communication bandwidth, the query forwarding algorithm must be light-weight and energy-efficient. Third, since the network is highly vulnerable, the solution must be able to adapt to frequent data updates and high network fluctuation.

To deal with the above challenges, we adopt the human strategies in social networking for mobile P2P information retrieval problem. Differing from previous works [18, 12] in social networks which utilize social-links, interesting-similarity or behaviors-alike properties, we exploit the human natural behaviors of finding answers through acquaintances, learn-ing from experiences and gossiping words. Intuitively, once a person has a question, he would ask an acquaintance who has that knowledge, or who has a wide knowledge that can potentially answer his question. In our proposed solution for mobile P2P networks, we use intelligence information about neighbor peers instead of knowledge of acquaintance. The intelligence information is a piece of message about where to find a specific data (file). We use Intelligence Accuracy (IA) to evaluate the precise of all these intelligence information provided by its neighbors, which helps peers to find a better node to further pass the query to its neighbors. In our im-plementation, the Intelligence Accuracy is a convenient yet efficient method to evaluate the distance from a query node to the resource provider, with which the shortest way can be determined for the whole search operation in a volatile envi-ronment without a global view. The intelligence information is exchanged with neighbor peers as the way social peers gos-sip words, and spread in neighborhood. It helps peers collect more information from their neighbors. What X  X  more, the peers learn from their query experience, both in success and failure. After that, they re-adjust the Intelligence Accuracy (IA) value of the intelligence they used, and make it more precise and up-to-date. With above mimicking mechanisms from social networks, we propose an intelligence-based ap-proach for information retrieval and demonstrate that it can well tackle the challenges and provide efficient and effective information retrieval in mobile P2P networks. We further discuss our proposed approaches under the circumstances of network fluctuation and data updates to show its scalability and maintainability.

In summary, our approach is such a keyword-based in-formation retrieval algorithm that is light-weight, energy-saving, search-efficient and self-adapted, which is well-fit for the mobile P2P environment. Our contribution includes:
The rest of the paper is organized as follows. In the next section, we review the related work. We present the details of our intelligence-based information retrieval approach in Section 3. Section 4 describes a performance study and gives a detailed analysis of results. We finally conclude the paper in Section 5.
In mobile P2P networks or wireless ad hoc networks, a number of research studies have been conducted on data dissemination and discovery [6, 14]. Siddhartha et al. [20] proposed a P2P data dissemination protocol over an ad hoc network. It focuses on data transmission, in which a file is divided into segments according to a particular mobility model, while it ignores the issue of data search. Papadopouli et al. [17] introduced a peer-to-peer architecture called 7DS, which enables data sharing in a self-organizing fashion with either mobile or stationary nodes by simply using random forward method. Das et al. [8] studied a cooperative down-loading strategy for content delivery and sharing in wire-less vehicular-to-vehicular (V2V) networks, called SPAWN. It leverages the inherent broadcast nature of the wireless medium for neighbor discovery and uses a proximity-based piece-selection strategy to exchange data pieces. Klemm et al. [11] presented a special-purpose system for search and file transfer tailored to both the characteristics of MANET and the requirements of peer-to-peer file sharing. Motani et al. [15] proposed a wireless virtual network called PeopleNet, which mimics the way people seek information via social networking. It divides nodes into groups and propagates queries to a particular group based on given types. Wolfson et al. [22] proposed a rank-based dissemination (RANDI) al-gorithm which considers three constraints of mobile devices, including energy, communication bandwidth and storage. Tchakarov et al. [21] proposed a Geography-based Content Location Protocol (GCLP) to make use of physical location information for efficient content location in ad hoc networks. Lupu et al. [14] introduced a fast data dissemination method for structured P2P networks with mobile devices. It quickly constructs a CAN-like [19] structured P2P network for peo-ple who stay together with a short period of time. Most of above algorithms investigate how to disseminate the data in a peer-to-peer environment, which differ from our work that they push the data to the end users while we focus on processing the user-issued queries.

More recently, Fiore et al. [10] proposed an algorithm called Eureka to retrieve user contents in MANET. To the best of our knowledge, Eureka is the most related work to our research. It focuses on the query propagation and ap-plies a pure peer-to-peer approach to conduct data retrieval. Mobile nodes with Eureka estimate the information density in their proximity and use it to direct queries toward ar-eas where the requested data is denser. However, it suffers from high maintenance cost of indexing information density estimation of all data items in every node. It also suffers from high communication overhead caused by information updating because a single change of information density es-timation can incur the updates of all relevant nodes in the network. Our proposed IA approach assumes a more general environment with users in different mobilities, and it is well adapted to the highly dynamic environment with frequent data/peer update.
In this section, we introduce our intelligence-based ap-proach for information retrieval in mobile P2P networks, which mimics social human behaviors to facilitate efficient information retrieval. It re-adjusts IA values after query processes just like people learning from their experiences; it updates and exchanges the intelligence information as the way people gossip; its strategies to forward queries like peo-ple finding answers from acquaintances.

As shown in Figure 1, a query routing process can be divided into several forwarding steps. At each step, the par-ticipant forwards the query to one of its neighbors within its reachable range, by checking the intelligence information provided by them. Here, we define a node X  X  reachable range as the range in which the node can reach all other nodes in one-hop connection. We use query time-to-live (TTL) to control the hops of query propagation. If the query rout-ing path X  X  length is equal to TTL and the result is still not found, the query fails in finding its results. Otherwise, the resource provider node (denoted as R-provider ) will send the result back along the query routing path to the query issuer node (denoted as Q-issuer ). As discussed in [25, 16], an appropriate value of TTL is needed to tradeoff the suc-cess probability of queries and the overall query load in the network. However, this value is highly dependent on the workload and the network scenario.
Before discussing the query forwarding strategy, we in-troduce the notion of intelligence and our method to mea-sure the accuracy of intelligence information. In this paper, the intelligence of a query item in a node is the informa-tion about the distance from the node to the result item. This kind of intelligence is collected from neighbors X  gossip-like intelligence exchanging and query forwarding experi-ences. They are stored in the index tables of each node, as shown in Figure 2. The index table at left side, named self-contained items (SCI) table, stores the intelligence of data items which are provided by the node itself, obtained from previous queries or evaluated from neighbors X  items (NI) ta-ble. This information is the node X  X  own intelligence which will be sent to its neighbors for exchanging. The NI table at right side maintains all selected intelligence collected from neighbors which can help to decide where to forward a query.
The Intelligence Accuracy (IA) is a criterion representing the evaluating distance from the nearest copy of the resource data. We denote data item j  X  X  Intelligence Accuracy value as I j . Additionally, since the mobile P2P network is a highly dynamic environment, we bring in a time parameter t j to indicate the timeliness of intelligence. We measure IA in following ways:
In case that L is odd number, the two circles in the middle actually represents the single trough point of the curve as
L/ 2 = ( L  X  1) / 2 .
In our implementation, to expedite the data dissemination in mobile environments, we store the result in the query is-suer node for a certain period of time. During this period, the query issuer node can serve this resource to the others. If the data storage in the query issuer node exceeds a limita-tion, it forces the oldest cache to be deleted. This duration for cache can be a system tuning factor and may vary for dif-ferent applications. The duration of cache is generally short and during this period we consider the cache of resource to be valid using a version number to distinguish it from new update versions (refer to Section 3.3). We don X  X  cache re-sults in intermediate peers because it is a tradeoff between data dissemination and device storage consumption.
We can see that, Intelligence Accuracy is a value reflecting the distance from a node to the demanded resource. For an item j , a node whose IA value is nearer to I 0 j is closer to one of item j  X  X  providers in the network. Therefore, the node for-wards the query to one of its neighbors who has the highest value of I j . However, if we take the time factor into consid-eration, the IA value updated more recently is expected to be more precise. Integrating the above considerations, we design our query forwarding strategy as follows:
Intuitively, in order to satisfy the forwarding strategy, a node must store the indexes of every item from every neigh-bor, which is infeasible in reality. Therefore, in our imple-mentation, we simplify the indexes by exploiting the strat-egy on NI table X  X  updating phase. As shown in Figure 2, we manage the indexes in NI table based on items. For one item j , we store one entry which has the highest forward-ing weight F j (Formula (2) and (3)). When a new updated value from a neighbor comes, we compare it with the stored value. If the new F is higher, we update the entry. Oth-erwise, we drop the update message. Nevertheless, we still have to keep the indexes of all items in our index tables. However, we discover that if an IA value is so small as that its evaluating distance from the resource is longer than the TTL, this IA value becomes useless. Thus, we can remove it from our index tables. For the sake of index optimum, we set a threshold  X  : The IA values in both SCI and NI tables which are smaller than  X  can be safely removed.

One problem of the approach we presented above is that the query forwarding may get locked into a cycle. For in-stance, node i forwards the query to node j , j then forwards it to node k . And the IA value in node k  X  X  NI table points to node i ,so k forwards it to i . This cycle will recur until the TTL is reached. The query forwarding fails to explore other parts of the network where the results may reside. To solve this problem, we enhance the strategy with an addi-tional rule that a new IA value is recorded in a node X  X  NI table only if this new value is larger than the node X  X  own IA value in SCI table. With this rule, we guarantee that a node always forwards a query to a neighbor with a larger IA value. In case that such a neighbor does not exist, it ran-domly selects a neighbor to forward. Furthermore, in order to improve the robustness of our algorithm, we can store en-tries with top-k F of one item in our NI table by any chance the best candidate neighbor is disconnected at the moment we need it.
The mobile P2P network is such a dynamic network that mobile devices can join or leave freely. Nodes in this network can move from one place to another, and can add, delete or modify data arbitrarily. As we know, communication cost and maintenance cost can be extremely high in this kind of volatile environment. We show that our IA approach does not need any additional accesses to deal with the volatil-ity. We introduce how our IA approach tackles the network dynamic and data update as follows:
It is clear that no additional process is needed to deal with the network volatility and data update, besides NI updates. In other words, our model is a self-adaptive model who can be well fitted to highly dynamic networks.
We define the communication cost C as the amount of messages which have been sent, including query request mes-sages, result messages and update informing messages. For clarity of presentation, we simply denote the size of a single message as m . Note that, we can set different sizes for dif-ferent types of messages. We now investigate the process of query routing and IA value updating to analyze the cost of communication.

As mentioned before, the length of query path is l if the result is found. Otherwise the number of routing hops is equal to TTL. During the query routing, each node chooses one of its neighbors by checking its own index, then forwards the query request to that neighbor, which sends only one message. So does the result re turning process. Therefore, the communication cost C is
The IA value updating process is one of the key pro-cesses in our model, because many processes are essentially IA value updating processes, such as node joining/leaving process, data adding/deleting process and data modifying process. For a node i , we assume that it has n i neighbors. In the updating process, node i sends only one message m i to each of n i neighbors. After receiving the message, those n i neighbors just update their own NI table and nothing more need to be done. The communication cost of node i  X  X  IA value renewing is
We consider the energy consumption of battery while nodes are forwarding the queries or updating IA values. Suppose e is the energy cost of node i for one-hop connection. As we know a mobile device can be configured with several power levels at which it can send packets. Different power levels lead to different reachable ranges. To simplify our model, we let p to be a standard power level in our network. Each node sends messages at power level p and consequently has the same reachable range. In general, the energy cost e i sending a data unit by node i is where  X  i is a battery state parameter. Here  X  i reflects node i  X  X  internal states such as remaining electric energy of the battery and the valuation of each unit of power.

We distinguish two cases in explaining the energy cost during query routing:
On the other hand, the receiving energy cost of a node i for a data unit is a fixed value r i . We now consider energy cost of different roles in the network. For an arbitrary intermediate node E itm , it receives and forwards the message twice in both query propagation process and result delivery process. Therefore, the energy cost is
For an issuer node E isr or a resource provider node E rsp it only receives and forwards the message once. Thus, the energy cost is For a node who updates its IA value to its n i neighbors. The energy cost E upd is
In this subsection, we introduce the overall query process-ing algorithm of our IA approach as shown in Algorithm 1. When a node i receives a message M from one of its neigh-bors(line2),itfirstchecksthetypeofthismessage. Ifit is a query request message (line 3), it checks whether the query has been processed. If so, it drops the message (lines 5-6). If query TTL is equal to zero, the query fails. A failed message is returned (lines 8-9). Otherwise, it searches its own data for the query (line 11). If the result data is found, node i calculates the length of query path l , and then sends the result data, l and its position k back to the previous hop neighbor (lines 12-14). On the contrary, if the result is not found, it calculates its own position k in the query path and adds the query into its query list in order to record which one it has already processed and where it is from. After that, it checks for next hop (lines 16-19). If an appropriate neighbor is found, node i forwards the query to it, or else forwards the query to the neighbor who has maximum forwarding weight V max (lines 20-23). If node i receives a result data message (line 28), it first checks whether this query was issued by itself. If so and the query is successful, it stores the data and updates the corresponding IA value. If the query fails, it re-issues the query with a p re-defined number of attempts (lines 30-35). Otherwise, it searches the query list to find the record of that query (line 37). If no record is found, the query has been sent to the wrong place, node i drops it (line 44). If a record is found, node i updates the corresponding IA value and then sends it to the next hop. Otherwise, it directly forwards to the next hop (lines 38-42).
 Algorithm 1 The Query Processing Algorithm 1: k =0; l =0; 2: while recvMsg ( M ) do 3: if M.type == QUERY then 4: Q = M.query ; 5: if hasP rocessed ( M.qID ) then 6: Drop ( M ); 7: end if 8: if Q.ttl == 0 then 9: return ( Data = Failed ); 10: else 11: Data = checkData ( Q.dataID ); 12: if Data != NULL then 13: l = TTL  X  Q.ttl +1; 14: return ( Data, l, l  X  1); 15: else 16: k = TTL  X  Q.ttl ; 17: addQuery ( Q, k, fromID ); 18: Q.ttl = Q.ttl  X  1; 19: nextHop = searchN I ( Q.dataID ); 20: if nextHop != NULL then 21: sendT o ( nextHop, Q ); 22: else 23: sendT o ( V max Nb,Q ); 24: end if 25: end if 26: end if 27: end if 28: if M.type == RESULT then 29: Q = M.query ; 30: if Q.issuer == my.ID then 31: if M.Data != Failed then 32: addData ( M.Data ); 33: updateIA ( M.dataID ); 34: end if 35: Re  X  issueQuery ( Q, try  X  1); 36: else 37: Q = searchQueryList ( M.qID ); 38: if Q != NULL then 39: if M.Data != Failed then 40: updateIA ( M.dataID ); 41: end if 42: sendT o ( Q.nextHop, M.Data ); 43: else 44: Drop ( M ); 45: end if 46: end if 47: end if 48: end while
Example 1. Figure 4 shows a detailed example of how query processing uses intelligence-based forwarding strategy in the mobile P2P network. Node 0 is a query issuer. It issues a query Q . It then lookups its NI index table to find a neighbor to forward that query. It decides to send the query to node 1 according to the intelligence-based forward-ing strategy. Node 1 receives the query message from node 0 . It finds out that it has no data for that query. Then it calculates its own position k in the query path and forwards the query to node 2 after searching its NI table. Node 2 con-ducts the same job as node 1 does and forwards the query to node 3 .Node 3 checks its data and finds out it has the result data. It then calculates the length l of the whole query path and then sends the result back with the value of l .Node 2 and node 1 receive the result data, update their correspond-ing IA value and send back to the next hop retrieved from the query record. Finally, node 0 receives the result, and updates the IA value.
In this section, we evaluate our approach as well as two comparative approaches, Naive approach and Eureka [10], in the network simulator ns-2 [3]. The naive approach simply disseminates the queries in a flooding way. We use it as a baseline approach because it is simplest in maintenance yet proved to be efficient in search though with obvious draw-backs. We also compare our algorithm with Eureka because the Eureka approach is the most recently proposed approach related to our work and has been proved to be more effective than several previous works. In the Eureka approach, each node maintains information density evaluation of resources in the surrounding range, within which it can reach other nodes in multi-hops. This range is called a region. Queries are propagated to a region that is evaluated to have higher information density.
In the simulation, we set the scenario of a 1000 m  X  1000 m area. Within this area, the mobile nodes move according to the Random Waypoint Mobility Model [5]. In particular, at the beginning of the simulation N s percentage of all N mobile nodes are randomly placed in this area. Each node has a destination which is another random point within the space. The node moves to its destination at a constant speed s along the straight line. After it arrives, it pauses at the destination for a period t s , then randomly chooses another destination, and repeats this procedure. N d ( N s + N d =1) percentage of nodes are randomly placed outside the area. Each of them moves toward a random destination within the area at speed s and pauses at the destination for t d After that, it moves toward outside of the area and is re-moved from the simulation. The pause time t s is uniformly distributed between 120 and 240 seconds for stable nodes. t is uniformly distributed between 30 and 60 seconds for highly dynamic nodes. The motion speed s is randomly selected from the interval [0 . 5 , 1 . 5] miles/hour for model-ing the pedestrian scenario. This mobility model simulates, for example, the motion of workers and visitors at business district. Within the area, there are D identical data re-sources and each of them has two replicas randomly dis-tributed among nodes. Every node selects a random data for issuing a query. The query rate is  X  . All mobile nodes use IEEE 802.11 for connection. The bandwidth is 10 Mbps and the transmission range is 100 meters. The parameters used are listed in Table 1.
We exploit the following performance metrics:
We study the network traffic incurred by query propaga-tion. We set the query rate  X  =0 . 2andcachedroprate  X  =0 . 035. We randomly set the issuing time of the first query for each node in the range of [0 , 60 s ]. We vary the data cardinality D from 50 to 250 and the network size N from 100 to 1000. The value of D affects the speed of IA value dissemination because a large D value provides more choices when a node issues a query, which introduces fewer cached data replicas of certain resources in the network. It sequentially slows down the dissemination of IA values, and indirectly lengthens the forwarding paths of queries. There-fore, in Figure 5, the query traffic of our IA approach in-creases. However, our approach outperforms the other two approaches in all cases. The flooding approach suffers more than one order of magnitude query traffic compared with the IA approach because IA only chooses the most promis-ing neighbor to forward the query instead of flooding the query. Eureka also incurs much higher query traffic than the IA approach, because it blindly floods the query to its neighbors. Those neighbors then evaluate whether their in-formation densities are larger than the former ones, and one or some of these neighbors take the forwarding process and flood the query to all its neighbors continuously, until the result is found. Although Eureka is much better than pure flooding, its blind flooding to the neighbors results in higher query traffic.
Figure 6 shows the results of communication cost which includes query traffic, result data traffic, index dissemination traffic and traffic incurred by incentive mechanism. The pro-posed IA approach significantly outperforms the other two competitors. Both Eureka and IA approach use indexes to maintain some useful information. However, Eureka incurs much more communication traffic than IA does, because of its inefficient index dissemination. It delivers updated index values to all neighbors whenever an update happens. When a neighbor receives this message, it updates its correspond-ing index value and recursively delivers the new updated value to its neighbors. Thus, every update in Eureka may involve all the nodes in the network. This is the main reason why Eureka incurs as much as or even higher communica-tion traffic than the pure flooding approach does. In the IA approach, the indexes can be renewed during query process. A node sends the updated indexes to its neighbors in a fixed time interval, which does not incur recursive effort.
In this set of experiments, we evaluate the query response time for successful queries. Adopting the typical policy in many mobile networks, we set a time threshold for queries, and assume a query fails if its issuer does not get any reply within the threshold. In Figure 7, we show the average query response time of all successful queries in the network by varying the network size and data cardinality. The flooding approach has the shortest response time owing to its fully distributed nature. Our IA approach is faster than Eureka, which means IA has shorter query paths than Eureka on average. As we can see, Eureka is a constrained distributed approach which propagates queries in a selective and parallel way. IA has only one but probably most optimal query path, thus it outperforms Eureka. This is owing to the advantages of its Intelligence Accuracy evaluation technique as well as the cooperation of each node. Meanwhile, the gaps among IA, Eureka and flooding are getting smaller when network size becomes larger, because the query paths of all three approaches get closer to TTL for larger networks.
Figure 8 shows the average query success rate for different methods. Clearly, the flooding approach performs best, as it always floods the query to all the neighbors, thus it will not miss any results stored in these neighbors. Compared with IA and Eureka, we find that IA is a little worse than Eureka in 100-node network, while it outperforms Eureka when the network size becomes larger. Although the proposed IA ap-proach selects one path to forward the query, the IA value can effectively capture the information of data resources in the network, and forward the query to the most promising neighbor. In such a highly dynamic environment, data and peers are frequently updated. The higher query success rate indicates higher scalability of our approach over Eureka.
Figure 9 shows the average battery energy consumption of each node in the network. We use the average energy consumption of the flooding approach as the baseline. The IA approach is much more efficient in energy saving than the other two approaches. Energy consumption is highly re-lated to the total number of communication messages shown in Figure 6. More message transfer in the network consumes more energies. Eureka incurs more energy consumption than the flooding approach, because of its index dissemination and query propagation. In every single query step of Eu-reka, it floods the query to all neighbors. Although only one or a few neighbors with higher index values will further flood the query, many neighbors just do nothing but drop the messages, and hence the energies are wasted on these nodes. Additionally, the index update in Eureka involves the majority of nodes in the network, which introduces high energy cost.
In this paper, we have addressed the keyword based in-formation retrieval problem in a popular and realistic file-sharing mobile peer-to-peer network. The proposed solu-tion takes the advantage of the powerful mobile facilities to share resources and information which are of great bene-fit to people X  X  daily life and various business applications. An intelligence-based information retrieval algorithm is pro-posed to help nodes decide where to forward the query, by mimicking different human behaviors in social networking. It is a light-weight and energy efficient approach using an Intelligence Accuracy (IA) mechanism to evaluate the dis-tance from the node to the resource. We conduct extensive experiments to evaluate the performance of our proposed ap-proach. The results show that our approach is well adaptive in highly dynamic mobile P2P network, and yields superior efficiency and effectiveness.
This research was supported by the National Natural Sci-ence foundati on of China under Grant No .60603045, the Na-tional High-tech R&amp;D Progr am (863) of Chin a under Grant No. 2007AA01Z153.
