 Traditional desktop search engines only support keyword based search that needs exact keyword matching to find re-sources. However, users generally have a vague picture of what is stored but forget the exact location and keywords of the resource. According to observations of human asso-ciative memory, people tend to remember things from some memory fragments in their brains and these memory frag-ments are connected by memory cues of user activity con-text. We developed iMecho (My Memory Echo), an associa-tive memory based desktop search system, which exploits such associations and contexts to enhance traditional desk-top search. Desktop resources are connected with semantic links mined from explicit and implicit user activities accord-ing to specific access patterns. Using these semantic links, associations among memory fragments can be built or re-built in a user X  X  brain during a search. Moreover, our per-sonalized ranking scheme uses these links together with a user X  X  personal preferences to rank results by both relevance and importance to the user. In addition, the system provides a faceted search feature and association graph navigation to help users refine and associate search results generated by full-text keyword search. Our experiments investigating pre-cision and recall quality of iMecho prototype show that the association-based search system is superior to the traditional keyword search in personal search engines since it is closer to the way that human associative memory works.
 H.3.3 [ Information Search and Retrieval ]: Search process Algorithms, Design associative search, desktop search, personalized ranking
As most of the digital universe are created by individu-als, personal information management (PIM) has become a hot topic. Searching desktop resources, including local files, emails, instant messages, cached web pages, etc., has become an important but time-consuming task [6, 7, 8]. Per-sonal search is different from web search. People generally have a vague picture of what is stored in their computers but they always forget the exact location and keyword of the resource content. Existing desktop search systems such as Google Desktop, Microsoft Windows Desktop Search, and Spotlight for Apple X  X  OS only support keyword search that needs exact keyword matching to find resources.

Considering human memory recall, people appear to re-member something through some associative memory frag-ments left in their brains as well as memory cues relating to the context of information capture or subsequent access. For example, a user wants to find a web page he had read while writing an important report, but he cannot remember the keywords about the web page. Interestingly, he does remem-ber the connection and therefore finds the web page through the report. Psychology research has shown that people often remember things through chains of associations [18]. Our idea is to exploit such associations and contexts to simulate human associative memory to enhance desktop search.
Current desktop file systems do not provide a means to link semantically related files. However, user activities in the desktop, to some extent, reflect his associative mem-ory when he searches resources later. We developed the iMecho (My Memory Echo), an associative memory based desktop search system. Desktop resources are connected in iMecho with semantic links by analyzing user activities and the contexts in which the user works. Using these semantic links, associations among memory fragments can be built or rebuilt in a user X  X  brain during a search. The person-alized ranking scheme uses these links together with user X  X  personal preferences to rank results by both relevance and importance. iMecho provides a two-step search paradigm. The user first uses faceted search filters to quickly locate an easy-to-remember intermediate resource from the full-text keyword search results. Then the user can find the target resource by multiple navigation in the association graphs in iMecho.
 In some recent PIM systems, e.g. Stuff I X  X e Seen [8], MyLifeBits [10], Haystack [13], Semex [9], Beagle++ [7] and Feldspar [6], contextual cues such as time, author and association information are exploited to search and present personal information. However, the above systems only sup-port a few kinds of simple predefined associations. iMe-cho enhances desktop search by building associative links of resources from implicit access patterns of user activity se-quences. In iMecho, there are three types of associations: Content-based Associations (CA), Explicit Activity-based Associations (EAA) and Implicit Activity-based Associa-tions (IAA). CAs refer to associations that can be extracted from the content and attributes of resources. EAAs are ex-plicit associations in the sense that they are bound with certain user activities such as jumping to another webpage. IAAs denote some implicit associations between resources, which can be discovered through user access pattern analysis and resource provenance analysis. These semantic associa-tions are designed in accordance with a common mode of thinking in human minds so that the associative memory can be exploited to help find the target resource. Our ex-periments investigating precision and recall quality of iMe-cho show encouraging improvements over traditional key-word desktop search.

In summary, iMecho has the following contributions:
The remainder of the paper is organized as follows: In Sec-tion 2 we present the architectural overview of the iMecho system. Section 3 describes the key implementation tech-nologies. Section 4 evaluates its performance. Section 5 discusses the state of the art. Finally, Section 6 concludes this paper.
There are different kinds of physical resources available on the PC desktop. Currently, iMecho mainly deals with gen-eral files and file hierarchies in the file system, email mes-sages and attachments in the email store and offline web pages in the web cache. The architecture of iMecho is given in Figure 1. Like a traditional full-text search engine, the system need crawlers and extractors to parse the full-text content from different data sources. iMecho can extract con-tent from PDF, Word, Excel, Powerpoint, RTF, TXT, Java, CHM as well as ZIP, RAR, and many other archives. The indexer module is used to build up indexes for these data sources and to store them in the Lucene full-text index. Files inside ZIP, RAR, CHM and other archives are extracted dur-ing indexing and can be preserved for searches. When user inputs keywords in the user interface, the searcher and query processor will find the results through the Lucene full-text index. In addition, a relevance score is computed for each desktop item by ranking module, supporting an enhanced ordering of results based on term frequency.

Besides the traditional desktop search components (left rectangle), iMecho has several additional components (right rectangle) for tracking user activities and generating seman-tic links. iMecho uses the activity event monitor to record desktop events and association analyzer to create semantic links from the recorded events. Then the resource associ-ations and attributes are represented as RDF triples and stored in an RDF repository. The searcher and query pro-cessor module delegates keyword searches and RDF queries to the full-text index and RDF repository respectively. RDF queries are used to retrieve the semantic links of a given re-source. iMecho provides two different ways to help users find resources. Faceted search filters are used to refine the full-text search results through multi-dimensional classifica-tion. On the other hand, the association graph navigation is used to extend the searching results to associative resources via semantic links. The user interface (showed in Figure 2) visualizes search results and associative context in these two ways as well.
In order to construct semantic associations, iMecho needs to monitor user activities on their desktops. Currently, the event monitor can track both system-level and application-level activities. System-level activities include all file system operations and Window related activities such as Window creation, activation and closing. Application-level activities are restricted to specific applications. The monitor provides  X  X lugins X  for each of the applications to track user activities on MS-Office documents, Emails (Outlook), Adobe pdf files and cached webpages (Firefox). The plugins also extract application-specific metadata and associations between re-sources. When an email is received, for example, the Out-look plugin automatically extracts email metadata, e.g.  X  X o X ,  X  X rom X  and  X  X ubject X  from corresponding email fields, and connects the attached documents with the email. iMecho enhances desktop search by building associative links of resources from user activity context. Through con-tent analysis, user access pattern analysis and lineage anal-ysis, we get the following three types of links.

CA CAs represent the content-based associations created by analyzing the content and attributes of desktop resources. For example, in Figure 3, the similar to link connects two resources that are similar in terms of contents, file names and locations (e.g. same directory). A similarity function regarding these three factors are used to compute the dis-tance between two resources. By analyzing the attributes of email messages and files, we can get has attachment , re-ply to , received from , owned by and contained in CA links.
EAA EAAs are explicit and deterministic activity based associations. EAA links are set when specific user events are observed. We create three types of EAAs in iMecho: jump to , copy from and save as . Each of them is bound with a type of user activity tracked by the event monitor. For instance when the user goes from one webpage to another, the two pages are connected by a jump to link. When the attachment of an email (or a webpage) is saved as a local file, a save as link will be created connecting the attachment (or webpage) and the file. Similarly the copy from link is created based on  X  X ile copy X  events.

IAA IAAs denote some implicit and nondeterministic as-sociations between resources, which can be discovered by user access pattern analysis (e.g. the same task link) and resource lineage analysis (e.g. the provenance of link). We find that users tend to access and manipulate different re-sources to complete a task. We define the same task link to cluster resources by their related tasks. The same task is usually very helpful for the user because we organize our memory in a similar way. The provenance of link can rep-resent the origin of a resource. Users always create multiple versions of a document through several  X  X ile copy X  and  X  X ave as X  operations. By analyzing the lineage sequence of save as and copy from activities, we can create the provenance of link between a document and its original copy. Actually, an IAA link is responding to a pattern of user activity sequence.
Existing desktop search engines only employ the content-based algorithms such as cosine similarity to rank personal desktop resources. However, the content-based ranking could not reflect the user X  X  personal preference. For desktop search, a top ranked document should be not only relevant to the query but also relatively important to the user. The link-based ranking algorithms, such as PageRank, are good ways to find authoritative results. With the established links from user activity, iMecho can combine the two ranking schemes to generate personalized ranking results for every user. The final score of a document is the product of the relevance score and the global authority score. Similar to the Ob-jectRank [5] algorithm, different weights are manually as-signed to different types of links since different links may have different impacts on the global authority score. There-fore more important links, such as same task , are given rel-atively higher weights. By this means, desktop resources are connected by weighted links. Then we can employ a link-based ranking algorithm to find important results.
Our ranking algorithm is personalized because the user can manually adjust the weights of different types of as-sociations, which explicitly show the user preferences. In addition, user activities can implicitly influence the rank-ing computation since some semantic links are created by analyzing user access patterns and some parameters in the algorithm are decided by the user access frequency as well.
Faceted Search enables users to navigate in a multi-di-mensional information space by combining text search with a progressive narrowing of choices in each dimension. In iMecho, we apply faceted search to desktop search to re-fine results from keyword search. It combines the effective-ness and flexibility of full-text search with the ease-of-use of faceted navigation: the ability to find information based on attributes such as its location, file type, modification dates, file size, author, etc. Unlike web facets, desktop facets in iMecho are well organized into a facet tree, which further classifies facets of the same taxonomy. In addition, users can select multiple facet terms from different taxonomies at the same time to quickly filter the result set. In iMecho, there are two kinds of desktop facets, predefined desktop facets (e.g. file size, modified date, file type) and dynami-cally generated facets, such as the senders of email messages, in the sense that their values vary according to the result set.
In desktop search, users tend to associate resources in their minds and try to follow these associations when look-ing for specific resources. There are some examples here.  X  X  remember that I have browsed several webpages weeks ago, but I forgot either its URL or its content. On the other hand, I remember that when I browsed the page, I was writing a technical report, and I remember some keywords of that document X ,  X  X everal images were downloaded from attach-ments of an email several months ago. Now I want to find a paper with the same folder as these images. But I could not remember either its name or its directory. I only know that Peter sent the email and talked about desktop search topic X . iMecho manages to process such searches. The asso-ciation graph shows all directly related resources to a spe-cific resource (showed in Figure 2). A user can first locate an intermediate resource by keywords and faceted search, and then switch to the association graph to get its related resource. When the user selects one of the associative re-sources, say resource  X  , the graph will be updated and all related resources of  X  will be displayed. By this means, the user can navigate in the association graph, which simulates the associative memory in the mind of the user.
Desktop search could potentially profit from a lot of im-plicit and explicit semantic information available in emails, folder hierarchies, browser cache contexts and others (con-textual metadata, provenience of information as well as so-phisticated classification hierarchies). Figure 3 shows the desktop ontology in iMecho, which represents desktop re-source attributes and semantic associations among emails, folder and file hierarchies, cached web pages, etc.
As mentioned above, associations among desktop resources include CAs, EAs and IAs. Here, we mainly focus on asso-ciations related to user activities (i.e. EAAs and IAAs), in particular, the IAA links. IAAs can be mined by recogniz-ing specific patterns in the user log. In this section, we will describe the task mining algorithm and its optimization in generating the same task IAA link in details. To the best of our knowledge, this work remains unexplored up until now.
Users tend to access and manipulate different resources to complete a task. For instance, when writing a paper, a user may look for related presentations, references, web pages and emails from colleagues. These resources are all somehow re-lated to this task. This type of links is defined as same task , which corresponds to a special pattern of user activity se-quences. A task can be taken as a series of user activities with a specific goal. Two document resources are associ-ated via same task if they are involved in a same working task. To generate the same task links, we propose a clus-tering based algorithm for initial task mining and a Hidden Markov Model based method for further optimization. A Clustering based Algorithm for Initial Tasks
A user always switches between different tasks in a given period of time. For instance, a researcher starts to read a paper in the Monday morning. Then he gets a email regard-ing an upcoming presentation. After finishing the slides he gets some good ideas and turns to write a working draft. In the end he goes to the paper he read in the first place. This example shows how difficult it is to decide which resources are related to the same task.

We try to ease the problem by introducing the notion of  X  key resources  X . A key resource is the goal of a task. All other resources related to this task work as references or ap-pendixes to the key resource . It can be a report, a read-only paper, an Email message and so on.

Definition 1. A task T is defined as a set of resources. If resource  X  is accessed by the user when he is accomplishing task T, we denote  X   X   X  .

Resource  X  may belong to several tasks, which means  X  is used several times for different purposes.

Definition 2. The lifecycle of a resource  X  (denoted as  X   X  (  X  ),  X  is the occurrence index of  X  in the log) is the gap between opening time (  X   X  (  X  )) and closing time (  X   X  (  X  )) of length of  X   X  (  X  ). The index  X  can be omitted if no misun-derstanding occurs.

If  X  (  X  ) is completely covered by  X  (  X  ), then  X  (  X  )  X   X  (  X  ) or  X  (  X  )  X   X  (  X  ). If  X  (  X  ) and  X  (  X  ) are overlapped, which means that the user opens  X  before closing  X  or vice versus,  X  (  X  )  X 
A resource may have several lifecycles in a given period of time with different  X  .
 We make several assumptions about key resources.

Assumption 1. There is only one key resource in a given task. The key resource of task  X  is denoted as  X  (  X  ).
According to the definition, the key resource serves as the goal of the task. We assume that a user has one task at one time. Therefore there is only one key resource in a task.
Assumption 2. A key resource has the longest lifecy-cle among all the resources in the corresponding task, i.e.,  X   X   X   X ,  X   X  (  X  (  X  ))  X  X  X  X   X  (  X  )  X  .

In most cases the user opens the key resource and keep editing it until it is finished.

Assumption 3. Task  X  starts when its key resource  X  (  X  ) is opened and  X  stops when  X  (  X  ) is closed. All the overlapping resources of  X  (  X  ) go to task  X  , i.e.,  X   X  , if  X  (  X  )  X   X  (  X  ) then  X   X   X  .

This assumption comes from the observation that the user usually opens resources that are related to the key resource he is working on. When the key resource is closed, the cur-rent task is accomplished. Of course the user may open the key resource in future but that is treated as another task.
Because usually when a user is working on a task, he opens all resources involved. Therefore what we should do is to de-cide the boundary of each task and get the corresponding resources inside the boundary. A initial algorithm is used to discover tasks and create the same task links. We cluster resources by their lifecycles. If the lifecycle of resource  X  is completely covered by that of resource  X  , then  X  and  X  go to one cluster. The resource that has the longest lifecycle is the key of the cluster. If the lifecycles of two keys are overlapped, we use some rules to decide whether the two clusters should be merged or not. When no clusters can be merged, each cluster is output as one task. All resources in the cluster are connected by the same task link. Since the boundary of a task is determined by its key resource accord-ing to assumption 3, we should get all the key resources first. To make sure that these key resources satisfies assumption 2, they should be ranked by their lifecycles in the first place. The initial task mining algorithm is showed in Algorithm 1. Algorithm 1. TaskMining Input : Resource list  X  , Lifecycle map  X  . Suppose  X   X  X  X  ,  X  (  X  ) stands for the lifecyle of  X  .

Output : Task list  X   X  =  X  WHILE (TRUE) END WHILE
Sometimes the lifecycles of resources are too short that few of them are overlapped. It usually happens when the al-gorithm is coming to an end because lifecycles are sorted in descending order. A simple solution is to set a threshold for the minimal size of a task. The default value of this thresh-old is 2, which means all tasks with less than two resources will be removed from the output.
 An HMM-based Optimization for Task Mining
After getting initial tasks results, we optimize the tasks using a well-studied mathematical model, Hidden Markov Model (HMM), which is proved to yield task mining results that are closer in line with the user logs.

HMM is a widely-used stochastic model in which the set and sequence of states in a system can be estimated by studying the observed behaviors of the system. In desktop systems, states can be represented as tasks and the observed behaviors are user activity logs on desktop resources. Users tend to access different resources to complete a task and usually keep switching between different tasks.
 Figure 4: The Optimization Process of Task Mining
The output of the initial task mining can be represented as a triple (  X ,  X ,  X  ).  X  stands for the set of mined tasks.  X  is the set of resources related to  X  .  X  is the weight matrix.  X   X  X  X  is the weight that resource  X   X  is in task  X   X  . The weight  X   X  X  X  is calculated as following:
Here  X   X  (  X  ) is the number of resources in task  X   X  . If  X  0, resource  X   X  is related to task  X   X  . The HMM model can be represented as  X  = (  X ,  X ,  X ,  X  ) , in which  X  ,  X  and  X  are the inputs of the initial task mining step.  X  is the transfer matrix.  X   X  X  X  denotes for the possibility that the user switches from task  X   X  to task  X   X  . The user log  X  is a sequence of the elements of  X  .  X   X   X  stands for the length of the log. The optimized task mining process is shown in Figure 4. The initial task mining results are generated in the first place. Then an HMM is built on the results. After opti-mizing the model with user log  X  , the weight matrix  X  and transfer matrix  X  are updated to  X   X  and  X   X  respectively. is output. The task set  X  and the resource set  X  is not changed during the optimization process. But the weight matrix  X  is updated as  X   X  , which is the key of the task mining result. The last step of task mining is to cluster all resources according to  X   X  . For task  X   X  , resource  X   X   X   X   X  X  X   X   X   X  (  X  ).  X   X  (  X  ) is the number of resources of  X  optimizing.

The goal of the optimization is to make the model more precise. The Baum-Welch algorithm [8] is used to optimize the parameters of HMM to make it  X  X loser X  to the log. It is proved that  X  (  X   X   X   X  )  X   X  (  X   X   X  ). In other words, the op-timized model is more likely to generate the observed user log than the initial model. In addition, the transfer matrix  X  is less important in the optimization process. Uniform initial estimate of the matrix  X  is adequate for giving useful optimization of these parameters in almost all cases.
The ranking algorithm is one of the key technologies to search engines. Current desktop search products, such as Google Desktop and Windows Desktop Search, are now com-parable to first generation web search engines, which pro-vided full-text indexing, but only relied on textual infor-mation retrieval to rank their results, e.g. content-based ranking algorithms. These algorithms use heuristic distance functions to compare how X  X lose X  X he query and indexed doc-uments are. The most frequently-used distance function is called cosine similarity , which uses the cosine of the angle between the two term vectors as the distance. Content-based ranking algorithms, no matter which distance function they employ, only rank documents by their  X  X elevance X  to the given query. It is widely accepted that users are also inter-ested in the  X  X mportance X  of the pages. The more important the page is, the higher rank in the result set it should have. PageRank [17] is one of the most famous algorithm which ranks pages by their importance. It calculates the probabil-ity that each node is visited by the  X  X andom Surfer X  model, which is used as the score of importance. The  X  X andom Surfer X  model can simulate the behavior of a web user such that the ranking score of a page is approximately the prob-ability that it is visited by the user in his tour on the Web. The  X  X andom Surfer X  model assumes that the surfer follows three rules when navigating on the Web. 1. He starts with a random page. 2. He may click one of the links in the existing page with 3. He is not interested in the current page and its links
However, current desktop search engines can not benefit from this ranking scheme because there are no established links among those isolated desktop resources (files, emails, etc. ). iMecho overcomes this problem by building seman-tically associative links among desktop resources from the analysis of user activity context. Then a new personalized link-based ranking algorithm -iRank is formed based on such link structures together with the user preferences. Dif-ferent from the the random surfer model in PageRank, iRank employs the following user model: 1. He starts with a random resource. 2. He may either access one of the resources that are re-3. Or he goes to a resource with a probability that is
In iMecho, a top ranked document should be not only relevant to the query but also relatively important to the user in the result set. Specifically, iRank uses a combination of the TF*IDF score returned by Lucene and an extension of PageRank. Given query  X  , the ranking score of a resource  X  is denoted as  X   X  (  X  ). Suppose  X   X  (  X  ) is the relevance score between  X  and  X  ,  X  (  X  ) is the importance score of  X  , then  X   X  (  X  ) is given by Lucene at the query time. And  X  (  X  ) is calculated by the link-based algorithm, which will be in-troduced later. As PageRank, iRank is an offline algorithm which runs periodically on the dataset.

For ranking personal desktop information, iRank has two advantages over PageRank.
Weighted Links There are different types of links in iMecho. iMecho extends the desktop ontology of Figure 3 by adding weights and edges in order to express how impor-tance propagates among the entities and resources inside the desktop ontology. For example, authority of an email is split among the sender of the email, its attachment, and the email to which it was replied. So, if an email is important, the sender might be an important person, the attachment be an important one. And the previous email in the thread hi-erarchy also become important. In iMecho, different weights are manually assigned to different types of links. Every edge from the ontology graph is split into two edges, one for each direction. This is motivated by the observation that author-ity potentially flows in both directions and not only in the direction that appears in the original desktop ontology (if we know that a particular person is important, we also want to have all emails we receive from this person ranked higher).
Figure 5 shows the links between different types of re-sources in Imecho and weights of these links as well. The user is more likely to follow the links with higher weight according to our model. Therefore nodes pointed by these links are more likely to be visited by the user.

There are a couple of issues should be noted in Figure 5.
Personalization Different authority transfer weights ex-press different preferences of the user, translating into per-sonalized ranking. As mentioned before, the user activities that influence the ranking computation have also to be taken into account, which translates to assign different weights to different contexts. The weights explicitly show the user preferences. In addition, the ranking is implicitly person-alized by analyzing the user activity logs. Before running iRank, we study the activity logs and calculate the access frequency of each resource. According to our user model, the user prefers to the most frequently visited resource when he decides not to follow the existing links. Then we use this ac-cess frequency information to adjust our ranking algorithm so these user-preferred resources will get higher ranks.
Computation Algorithms The computation of rank-ings in iRank is based on the link structure of the resources as specified by the defined ontologies and the correspond-ing metadata.  X  is the directed graph of connected desktop resources. Suppose  X  is the number of nodes in the graph  X  ,  X  X  X   X  (  X  + 1) denotes the access probability vector, i.e. the importance score vector, after  X  rounds, there is
Here  X  is the dumping factor and it is set to 0.85 in general cases. Matrix  X  also known as the Transition Matrix , which denotes the weighted graph of indexed files. After some algebra, equation 3 turns to:  X   X  is the unit matrix, a Personalization Vector and  X   X  =  X  / the user log). The random jump to an arbitrary resource in the resource graph is modeled by  X   X  in the Random Surfer model, which shows the probabilities that pages are visited by the surfer when he is not following the links of the current page. This usually happens when the user gets bored with the page he is reading and then goes to a familiar site. In web search, users go to different pages with equal probabilities so  X   X  is a uniform vector in PageRank. The result is that every user will get exactly the same ranking list given the same query. While for desktop search, with the help of user logs, we can easily get the preference of the user and set the value of  X   X  according to the user access frequency. In iRank, by appropriately modifying  X   X  with different weights assigned to different data sources according to their access frequency, it can model user X  X  preference and personalization.
The iRank algorithm consists of two parts. The first is the initialization phase, which initializes the transition ma-trix  X  . The second is the iteration phase, which iteratively calculates ranking scores of every node.
In the iRank algorithms, we note that the initial value of  X  X  X  , i.e.  X  X  X  0 in Equation 2, does not affect the final ranking score. But it does affect the rate of convergence. In addition, the personalization vector MUST NOT have any zero elements, otherwise iRank might NOT converge. Therefore, if resource  X  is not accessed according to the user log, i.e.  X   X  = 0, we set  X   X  = 1 /
We did an initial evaluation of our system by conducting a small scale user study. Five of students in Fudan Uni-versity provided a set of their locally indexed documents, some of which they received as attachments to emails. The average data set contains 9431 desktop files in 1019 directo-ries. The average directory depth is 9 with the longest being 15. On average, directories contain 10.3 sub-directories and files, with the largest containing 241 ones. 75% of the files are smaller than 16KB, and 95% of the files are smaller than 40 KB. The largest file is of size 21.5MB. The user log produced by the event monitor records totally 1601 desk-top events. Then, each user issues search queries, related to their activities, over the indexed dataset. In total, 10 queries were issued ( X  X eagle indexing X ,  X  X eagle ranking X ,  X  X ageR-ank model X ,  X  X andom walk X ,  X  X esktop search application X  are some sample queries). The average query length was 1.9 keywords, which is slightly more than the average of 1.7 keywords reported in other larger scale studies (e.g. in [8]). For comparison purposes, we sent each of these queries to Windows Desktop, Google Desktop and the Lucene-based desktop search systems (content-based ranking), and the iMecho system (containing semantic links from user activity context and personalized ranking) respectively. For every query, each user rated the top 5 output results for each sys-tem using grades from 0 to 1 where 0 for an irrelevant result, 0.5 for a relevant one, and 1 for a highly relevant one.
Even when semantic links are integrated as part of a search system, the traditional measures from information retrieval theory can and should still be applied when evaluating sys-tem performance. We therefore used the ratings of our users to compute average precision and relative recall values at each output rank. Both measures can be calculated at any rank  X  , i.e., considering only the top  X  results output by the application. Restricting the calculation of precision and recall to various ranks is useful in order to investigate the quality of the system at different levels. It is a common prac-tise to focus only on the top-k results. In the experiment we follow the practise to use the top-5 results only. An-other important aspect is when calculating the recall mea-sure, we need to know the total number of relevant results, which is extremely difficult to know. We use the total num-ber of unique relevant results returned by the four ranking schemes. For every query, each returns 5 results. So the Figure 6: Comparisons of average precision and rel-ative recall overall relevant number is 20 at most. That is the base of relative recall [7].

We averaged the precision values at each rank from one to five for all 10 queries submitted by our users. The re-sults are depicted in Figure 6(a). We first notice that the Desktop Search with Lucene, Google and Windows Desk-top are poor, containing more qualitative results towards rank 4 to 5, rather than at the top of the result list. This is, in fact, explainable since Lucene, Google and Windows Desktop only uses TF*IDF to rank its results, thus missing any kind of global importance measure for the desktop re-sources. On the contrary, our iMecho system enhanced with semantic metadata and links, performs much better. An im-portant reason for this high improvement is that metadata are mostly generated for those resources with high impor-tance to the user, whereas the other automatically installed files (e.g., help files) are not associated with metadata, and thus ranked lower. When we have metadata describing a desktop item, more text is inherently available to search for, and thus this item is also easier to find. In addition, person-alized ranking pushes our resources of interest more towards the top of the list, yielding higher desktop search output quality. We drew similar conclusions with respect to the av-erage recall values (depicted in Figure 6(b)). The recalls of the Lucene and Google desktop search system are very low, whereas that of iMecho system is almost twice better (owing to the additional semantic links mined from user ac-tivity context). We thus conclude that iMecho significantly increases recall (as semantic links and other metadata usu-ally represent additional, highly relevant text associated to each desktop file), whereas adding desktop ranking further contributes with a visible improvement in terms of precision. iMecho employs a task mining algorithm to generate the same task associations between resources. To give the reader a feeling of the tasks detected by the algorithm, Table 1 shows the tasks mined from one of the users X  (user A ) ac-tivity log. To save space, only relative path of the resource is used. The descriptions of the tasks are added after an interview with user A about the semantics of these tasks, who was recently engaged in a project on desktop search en-gines. Specifically, in  X  1, Lucene is a full-text search engine, Task Resources involved Brief description T1 T2 T3 T4 T5 and Sesame is a well known RDF repository incorporating efficient RDF storage and query processing functionalities. LuceneSail is simply a combination of these two technolo-gies. These resources are all related to that task. Other discovered tasks also make sense.  X  2 is the writing of a survey of popular ranking schemes widely used by current web search engines;  X  3 and  X  5 are the writing of two re-ports about Beagle , which is a desktop search engine on the Linux platform. They focus on Beagle X  X  indexing and rank-ing methods respectively. Finally,  X  4 is an investigation of different desktop search tools. Tasks mined from other user X  X  logs also give positive results and we omit the details here due to space limitation.
The difficulty of accessing information on our comput-ers has prompted several first releases of desktop search ap-plications recently. The most prominent examples include Google desktop search [3] and Microsoft Windows Desktop Search [4] (proprietary, for Windows) and the Beagle open source project for Linux [2]. Yet they include no metadata and associations whatsoever in their system, but just a reg-ular text-based index. Apple Inc. integrated an advanced desktop search application (named Spotlight Search [1]) into their operating system, Mac OS Tiger. Even though they also added semantics into their tool, only explicit informa-tion is used, such as file size, creator, or metadata embedded into specific files. While this is indeed an improvement over regular search, it still misses contextual information often resulting or inferable from explicit and implicit user actions.
Some PIM systems have been constructed in order to fa-cilitate re-finding of various stored resources on the desktop. Stuff I X  X e Seen [8] for example provides a unified index of the data that a person has seen on her computer, regardless of its type. Based on the fact that the user has already seen the information, contextual cues such as time, author, thumb-nails and previews can be used to search for and present information. Similarly, MyLifeBits [10] targets storing lo-cally all digital media of each person, including documents, images, sounds and videos. They organize these data into collections and, like us, connect related resources with links. Haystack [13] emphasizes the relationship between a particu-lar individual and her corpus. It is similar to our approach in the sense that it automatically creates connections between documents with similar content and it exploits usage anal-ysis to extend the desktop search results set. Feldspar [6] is one kind of link-based desktop search prototype with new interface. Users can propose associative queries via a well-designed interface rather than simple keywords. Because user activities are not tracked in Feldspar, only CAs are sup-ported. Semex [9] is also link-based person information sys-tem. It employs a fancy reference reconciliation algorithm to integrate data from different sources and construct content-based associations by extracting metadata. As Feldspar, it only supports CAs and has not activity-based associations mining from user access patterns. Beagle++ [7] is another kind of link-based desktop search prototype, which is closer to our work. It proposed various activity specific heuristics to generate links between resources that associates desktop resources (i.e. local files, emails and cached web pages) via CAs and EAAs. Beagle++ also logs user activities such as attachment saving, file downloading to generate EAAs, but it only focuses on associations from predefined user actions between web pages, email messages and files, not mining from a sequence of user access activities. Their approach was limited to specific desktop contexts (e.g., publications, or web pages), whereas in our methods we explore much more general sources of linkage information such as file ac-cess patterns, which are applicable to any desktop resource.
All of the above systems only support a few kinds of sim-ple predefined associations, not semantic associations mining from special patterns of user activity sequences. In iMecho, by exploiting file access patterns and user implicit tasks, many more associations are constructed to better simulate human associative memory in the search. In addition, iMe-cho combines association navigation with faceted search to incrementally filter search results.

Personalization techniques have been developed in diversi-fied ways for web search. In a nutshell, the techniques can be classified into three categories, namely, content based per-sonalization, link-based personalization, and function-based personalization [14]. Content-based personalization deals with the  X  X elevance X  measure of Web pages and the user X  X  queries. In order to manage user interests, a content-based personalization technique is used to construct user profiles, which store user interests derived from each user X  X  search history [15]. Link-based personalization performs personal-ization based on link analysis techniques. They redefine the importance of Web pages according to different users X  pref-erences such as bookmarks as a set of preferred pages [11]. The function-based personalization first discovers user pref-erences on the search results from clickthrough data and then the ranking function is optimized according to the dis-covered preferences [12, 16]. However, these personalized techniques still miss contextual information often resulting or inferable from explicit and implicit user activities. For personalization in desktop search, the desktop environment is comparably  X  X imited X  in the sense that we will be able to describe most relevant contexts more easily. It is possible to obtain the complete trace of user activity on his desktop, and therefore his accurate interests, goals, and preferences can be discovered during a search.
We developed an associative memory based desktop search system, iMecho, which enhances the conventional full-text keyword search with semantic associations discovered from user activity contexts. In addition, the system provides the faceted search and association graph navigation to help users refine and associate search results generated by the keyword search. iMecho is superior to the traditional keyword based search engines because it is closer to the way that human associative memory works.
 This work was supported by the EMC Research China and Fudan University Collaboration Project and by the grants from the Natural Science Foundation of China with grant number 606731330. [1] Apple spotlight search. [2] Gnome beagle desktop search. [3] Google desktop search. http://desktop.google.com/ [4] Windows desktop Search. [5] A. Balmin, V. Hristidis, and Y. Papakonstantinou. [6] D. H. Chau, B. Myers and Faulring, A. What to Do [7] P. A. Chirita, S. Ghita, W. Nejdl, and R. Paiu. [8] S. Dumais, E. Cutrell, J. Cadiz, G. Jancke, R. Sarin, [9] X. Dong and A. Halevy. A Platform for Personal [10] J. Gemmell, G. Bell, R. Lueder, S. Drucker, and C. [11] T. Haveliwala. Topic-sensitive pagerank. In WWW [12] T. Joachims. Optimizing search engines using [13] D. R. Karger. Haystack: A Customizable [14] Y. Ke, L. Deng, W. Ng, D. L. Lee. Web dynamics and [15] F. LIU, C. YU, and W. MENG. Personalized web [16] W. NG, L. DENG, and D. L. LEE. Mining user [17] Larry Page, et al. The PageRank Citation Ranking: [18] E. Tulving and D. Thomson. Encoding specificity and [19] L. Welch. Hidden Markov Models and the
