 With the rapid advances of wireless comm unications and electronic technologies, Location Based Services (LBS), which t rack the location of mobile users and provide useful information associated with locations, is becoming a new and important application area. Efficient query processing for moving objects can substantially improve the quality of the services and there arises the great need of new query processing technologies in mobile environments.
 required to support many of the services, such as intelligent transportation sys-tems and sensor-based monitoring. With various applications, a large number of continuous range queries are repeate dly evaluated in a concurrent execution environment. One challenge is the real-time response to query answers, which is critical for actual applications. Any delay of the query response results in an obsolete answer. Examples are traffic monitoring and enhanced 911 services. Another challenge is the concurrent execution. With a large quantity of queries, many query regions intera ct and lead to overlapping. Movement of a single ob-ject can affect the answers of multiple qu eries, which increases the complexity of evaluation and workload of the server.
 tant approaches for continuous range queries [7,8]. To the best of our knowledge, the SINA [7] is the only algorithm that exploits both of these two paradigms. The existing incremental approaches are limited in three aspects: (1)Redundant processing. (2)Query overlapping. (3)Frequent query set operations. In dex ) for efficient processing of concurrent continuous range queries over mov-ing objects. cGridex is designed with two distinguishing features: (1) Enhanced incremental evaluation. (2) Enabling moving objects query-aware. Enhanced in-cremental evaluation entails that only queries whose answers are changed and only objects that change query answers are wholly processed while others are excluded from answers at an early time. cGridex eliminates redundant process-ing of both objects and queries in order to minimize computational costs. The query-aware ability is that an object can directly obtain incremental query an-swers without additional overhead when it moves to a new position. current queries, and introduces the concep t of coloring on a high level. It colors up the grid space and utilizes the space characteristic of grid-based index by dividing a range query into normalized parts and fragmented parts to optimize disk I/O and CPU time respectively. Wi th colored grids, i t forms a direct map-ping between moving objects and continuous queries, and can process both of them in a unified way, without redundant evaluation. By precomputing and ma-terializing the color transferring relations, it avoids frequent operations between query sets and spatial join between obj ects and queries at each time interval, thus saving both I/O and computational costs.
 model and reviews some related work. S ection 3 presents ou r approach cGridex, including its basic idea, data structures, and query algorithms. Section 4 con-ducts the experimental evaluation and we conclude the paper in Section 5. 2.1 System Model In this subsection, we present the system model and identify the major problems. In concurrent continuous query execution environments, we divide time interval into two kinds: one for query evaluation (  X  X  q ), which is equal to the minimum time unit, and the other for location update of moving objects (  X  X  u ).  X  X  u is larger than or equal to  X  X  q , which indicates that cycles of location update and query evaluation are not necessarily synchronized. At each  X  X  u , location updates with no client overhead are issued by positioning systems such as GPS or sensor networks. We do not make any assumption about moving objects X  X  storage or computational capabilities. Therefore, only minimal possible information, includ-the process from two aspects. In a time interval, in the view of a moving object ( o 2) o reports the new position to the server, and new pos is equal to old pos. ( o 3) o reports the new position to the server, but new pos is different from unchanged. ( q 2) q  X  X  result is changed. The relation between these two categories is illustrated in Figure 1(a). All the three cases in the object category can lead to case q 1 while q 2 only comes from o 3.
 the concurrent execution, there arise the following limited aspects in existing incremental approaches: (1) Redundant processing. In general incremental evaluation, we have to carry (2) Query overlapping. Since different queries may be applied for different ap-(3) Frequent query set operations. For incremental evaluation, we have to 1) 2.2 Related Work Unlike traditional snapshot queries, continuous range queries have the following characteristics, which have been described in previous work [7,8]: (1) Incremental evaluation is more efficient than non-incremental approaches. It is important to maintain query answers continuously rather than to rebuild the whole answers each time. Reevaluating all the queries is costly and unnecessary. With incre-mental approaches, only the change of query answers needs to be computed, which leads to fast evaluation as well as smaller answer sizes. (2) Query index performs better than the index built on moving objects, since building an index on queries avoids the high cost of keeping an object index updated. tigated recently. One way is to directly ev aluate the queries on an object index [6,9] at each time, where frequent updates of the object index is a major prob-lem. [7] proposes the SINA, an incremental hash-based algorithm for continuous spatio-temporal queries. It exploits t wo main paradigms: shared execution and incremental evaluation. SINA distinguish two kinds of query updates: positive updates and negative updates . Positive/Negative updates indicate that a certain Q-index is presented, which is to build an R-tree-like index structure on queries each moving objects is defined. [5] inves tigates the main memory evaluation of continuous range queries. It shows that a grid-based query index performs bet-ter than an R-tree based query index. [3] proposes a motion adaptive indexing schema for moving continual queries. It indexes less frequently changing objects, which helps decrease the number of updates to the index. Different from the system model in this paper, some previous work [1,2] assumes that moving ob-jects have computational and storage capabilities to share the workload of query processing with the server, which may be not always realistic i n actual scenarios. such as continuous k NN queries [12], and spatial semijoin queries [4]. 3.1 Motivation The main idea behind cGridex is to abst ract the dynamic relations between movements of objects and query answers by coloring up the grid space. In the of queries, as is shown in Figure 2(a). to-one mapping between objects and queries, as is shown in Figure 2(b), which is in a unified way and essentially different from that in Figure 1(a). We reconsider the case in Figure 1(b). Different query regions, including overlapping regions, take on different colors, as is shown in Figure 2(c). Then we can easily identify whether an object incurs any change of que ry answers by its color. Further, if we materialize the relations b etween colors and queries, i n continuous execution, we can directly obtain query answers without extra computational costs. With such a basic idea, we could have the following algorithm sketch of query evaluation: Algorithm Sketch 1. identify an object X  X  current color. 2. obtain the incremental answers directly from the materialized relations by 3. update the object information. 3.2 Data Structure The space is equally divided into N  X  N small grids. A grid, query, and color are respectively identified by GID , QID ,and CID . Specifically, CID is 1-based and 0 is reserved for no color.
 three steps: 1. Query Normalization. A query q is projected on the grid space and is divided 2. Coloring of query regions. First we project the normali zed query regions on 3. Color selection for grids. Each grid takes on two kinds of colors: full color Definition 1. ( Relation contains )Aquery q contains a color c if some part of q  X  X  region takes on color c.
 structures:  X  Colored Grid Based Index ( CGI ). CGI is an in-memory sequential struc- X  Color-Query Table ( CQT ). CQT is a disk-based sequential table indexed  X  Hash Table for Color Pairs ( HT ). HT is an in-memory hash table, with  X  Object Table ( OT ). OT is a disk-based table for storing object information.  X  Query Table ( QT ). QT stores the query information, including QID and 3.3 Materialized Relation In this subsection, we describe how to construct and materialize the color trans-ferring relations, which could speed up query processing in real-time environ-ments. First we introduce two definitions.
 Definition 2. ( Query Overlapping Relation, QOR )Query q i and q j sat-isfy QOR if and only if R ( q i )overlapswith R ( q j ) .
 Definition 3. ( Color Transferring Relation, CTR ) Color c i and c j satisfy CQT[ c i ] .QList ,  X  q j  X  CQT[ c j ] .QList ,satisfy q i = q j .
 query set operations are needed in order t o get incremental answers. Algorithm 1 describes how to generate the CTR for all the colors. We maintain a temporary array to record all the colors that a query contains . It should be noted that step 1  X  3 in the algorithm can be simultaneously done in the preprocessing step 2 in Subsection 3.2.
 Algorithm 1. Generate CTR 1. if a new color c is generated 2. for each query k that contains c 3. add c to array[ k ]. 4. for each query k 5. for each c i , c j  X  array[ k ], and c i &lt;c j 6. if pair( c i , c j ) has not been added to HT 7. add (pair( c i , c j ), ptrResult( c i , c j )) to HT. on disk. The result has the form ( L i , L j ), where L i =CQT[ c i ] .QList  X  CQT [ c ] .QList ,and L j =CQT[ c j ] .QList  X  CQT[ c i ] .QList . With the materialized CTR , positive answers (PA) and negative answers (NA) can be obtained di-rectly. Since dynamic transferring relations have been precomputed, there is no time environments.
 Algorithm 2. GetIncrementalAnswers(color i , color j ) 1. p =HT( i , j ). 2. if p != NULL 3. obtain the materialized result ( L i , L j )ondiskby p . 4. positive = L j . 5. negative = L i . 6. else 7. positive = CQT[ j ]. QList . 8. negative = CQT[ i ]. QList . 9. return (positive, negative).
 alized CTR , which is identical for both full colors and partial colors. Without rithm, if color i and j satisfy the CTR , we can get the materialized incremental answers from HT. Otherwise the answers can be got from the corresponding QList . With the implementation of dynamic arrays for the QList , the algorithm complexity is O (1). An example is shown in Figure 3. CQT[ c 1] .QList = { q 1, is { q 1, q 2 } .If o moves to p 2, PA = CQT[ c 3] .QList and NA = CQT[ c 1] .QList , since color c 1and c 3donotsatisfytherelation CTR . 3.4 Query Algorithm According to the coloring rule in Subsection 3.2, a region takes on two kinds of denote the corresponding full color and partial color an object takes on in the old and new position. An object identifies its full color and partial color at each query time. We introduce two lemmas bel ow, which guarantee the correctness of the query evaluation. Details of proof can be found in [11].
 Lemma 1. Given a position p takesonthecolorpair( fc , pc ), there does not ex-Lemma 2. Givenanobject X  X oldcolor( fc 1, pc 1) and new color ( fc 2, pc 2), there is no duplicate in the increm ental answers that result from fc 1  X  fc 2and pc 1  X  pc 2 respectively .
 uation and there is not duplicate in both of the answers according to Lemma 2, there are some cross influences on each other, which are verified in Algo-rithm 3. The cross validation phase is to remove the unnecessary incremental answers.
 CGI. For the partial color, we get the PCList on disk and checking whether the new position lies in the corresponding partial query region. Algorithm 3. CrossValidation( fc 1, pc 1, fc 2, pc 2) 1. if fc 1!= fc 2 2. if pc 1= fc 2 3. remove the positive answer of fc 1  X  X  X  fc 2. 4. if fc 1= pc 2 5. remove the negative answer of fc 1  X  X  X  fc 2. 6. if pc 1!= pc 2 7. if fc 1= pc 2 8. remove the positive answer of pc 1  X  X  X  pc 2. 9. if pc 1= fc 2 10. remove the negative answer of pc 1  X  X  X  pc 2.
 Algorithm 4. IdentifyColor( pos ) 1. i = pos .x / xunit, j = pos .y / yunit. 2. k = j  X  N + i . 3. fc 2=CGI[ k ]. FC . 4. pc 2=0. 5. for each ( PC , QR )  X  CGI[ k ]. PCList 6. if pos is within QR 7. pc 2= PC . 8. break . 9. return ( fc 2, pc 2).
 Algorithm 5. GetAnswers( fc 1, pc 1, fc 2, pc 2) 1. set FPos , FNeg , PPos , PNeg to NULL. 2. if fc 1! = fc 2 3. ( FPos , FNeg )= GetIncrementalAnswers ( fc 1, fc 2). 4. if pc 1! = pc 2 5. ( PPos , PNeg )= GetIncrementalAnswers ( pc 1, pc 2). 6. CrossValidation ( fc 1, pc 1, fc 2, pc 2). 7. return ( FPos  X  PPos , FNeg  X  PNeg ).
 query regions can not be represented b y a rectangle. We use an ordering tech-nique to solve this problem. We make such a query stored behind the queries that are fully covered by it in the PCList . The results consist of two parts, positive answers and negative answers. The algorithm proceeds by the full color and pa rtial color respectiv ely, and combines the two kinds of answers after the cross validation phrase. Now we extend the algorithm sketch in Subsection 3.1 to Algorithm 6, which describes the query evaluation in cGridex.
 Algorithm 6. QueryEvaluation( obj , pos ) 1. obtain old color ( fc 1, pc 1) from OT[ obj ]. 2. obtain new color ( fc 2, pc 2) by IdentifyColor ( pos ). 3. obtain positive and negative answers by GetAnswers ( fc 1, pc 1, fc 2, pc 2). 4. if ( fc 1, pc 1) != ( fc 2, pc 2) 5. update OT with ( fc 2, pc 2). 6. return answers.
 I/O and CPU cost, as well as memory requirement, can be found in [11]. 4.1 Experimental Setup In the experiments, we compare the performance of the following three ap-proaches: cGridex, SINA and Q-Index. We implement the algorithms using C++. All the experiments are conducted on Pentium IV 2.2GHz with 512 MB RAM running Windows Se rver 2003. The size of disk page is set to 4KB. We use syn-thetic datasets generated by the  X  X eneral Spatio Temporal Data X  (GSTD) [10]. All the objects are uniformly distributed in a square unit and can move arbi-trarily with a maximum moving distance of 0.2. The default number of objects is 100K and the default number of queries is 10K. The average query size is 0.05. The performance metric is the numbe r of disk access and CPU time, which is considered as the time used to p erform computation in memory.
 seconds, that is, all the queries are evaluated every 10 seconds and each moving objects reports its new location inform ation every 60 seconds. The percentage of moving objects that report a change of location information within  X  X  q is 30%. In cGridex, k is set to 100, which determines the number of grids in the space. 4.2 Results and Discussion We investigate the effects of the number of moving objects and continuous queries respectively in the experiments.
 jects from 10K to 100K on I/O cost and CPU time. In Figure 4(a), both SINA and cGridex shows its scalability. With the increase in the number of moving objects, the performance of SINA and c Gridex keeps stable. Both of them are the incremental evaluation, and only the change of query answers needs to be computed, avoiding the repeated reeval uation of queries. However, the perfor-mance of Q-Index degraded, because it reevaluates all the objects and rebuilds the query answers at each query evaluation time. It should be noted that both SINA and cGridex employ the indexing of objects (the Object Index in SINA and the Object Table in cGridex), which provides the support for the incremental evaluation, while objects are not indexed in Q-Index. We also see that cGridex performs slightly better than SINA, beca use with the enhanced incremental eval-uation only objects that change query answers proceed to be wholly processed while others are excluded from answers at an early time, which eliminates the redundant processing. In Figure 4(b), cGridex has the lowest CPU time. The reason is that the dynamic transferring relation between queries and moving objects has been precomput ed and materialized, and th erefore the incremental answers can be obtained directly without additional computational overhead. As is shown in the figure, SINA computes the answers dynamically each time, and the cost slightly increases with the increase of the number of objects. queries, which increases from 10K to 50K. In Figure 5(a), we see that Q-Index has the high I/O cost since it is based on the R-tree structure indexed on queries and non-indexed objects worsen the performance. Both of SINA and cGridex increase its I/O cost slightly, because with the more queries to be evaluated, the structures maintained for queries, the Grid Index in SINA and the Color-Query Table in cGridex, need more disk space, which lower the performance of one disk access. In Figure 5(b), when the number of queries becomes larger, SINA increases its CPU cost since it repeated ly executes the set operations such as difference and intersection between old and new query lists, whose length have increasingly become lo nger. With the materialized coloring transferring relations, cGridex is not much affected by the increase of queries. Efficient evaluation of continuous range queries has increasingly been impor-tant in a wide range of application areas. In this paper, we propose a novel approach, namely cGridex, for efficient processing of continuous range queries over moving objects. cGridex abstracts the dynamic relations between moving objects and concurrent queries, which aims at avoiding redundant evaluation. It precomputes and materializes the color transferring relations, without dynamic frequent computation. In the future work, we will further extend the basic idea to other types of continuous queries over moving objects.

