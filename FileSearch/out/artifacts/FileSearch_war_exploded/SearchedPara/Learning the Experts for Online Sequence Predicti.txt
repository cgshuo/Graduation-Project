 Elad Eban elade@cs.huji.ac.il Aharon Birnbaum aharob01@cs.huji.ac.il Shai Shalev-Shwartz shais@cs.huji.ac.il Amir Globerson gamir@cs.huji.ac.il Sequence prediction is a key task in machine learn-ing and statistics. It involves predicting the next ele-ment in a sequence given the previous elements. Typ-ical applications include stock market prediction, click prediction in web browsing and consumption predic-tion in smart grids. Although the sequence prediction problem has been well studied, current solutions either work for long sequences or require strong prior knowl-edge. In this work we provide a method that uses training data to learn how to predict a novel sequence. As we shall show, we use the training sequences to ob-tain the prior knowledge needed for predicting novel sequences.
 Sequence prediction is most naturally cast as an online prediction problem ( Cesa-Bianchi and Lugosi , 2006 ), where at every step we predict the next element, and then receive the true value of the element while suf-fering a loss if we made a prediction error. We are then allowed to improve the model, and predict the next step. The online formulation is natural in most applications since the new element X  X  true value unfolds in real time and we are interested in minimizing the prediction loss of this process.
 One classical approach to the problem is the so called universal sequence prediction class of methods ( Feder et al. , 1992 ; Hutter , 2006 ). Such methods guarantee that asymptotically (with sequence size) the model will achieve optimal prediction error. However, the price we pay for universality is that good performance will be reached only after seeing long sequences. Intu-itively, the reason for this is that no prior knowledge about the sequence is used, so it may take a while until we have a good model of it.
 An alternative approach which does introduce prior knowledge is predicting with expert advice ( Littlestone and Warmuth , 1994 ; Vovk , 1990 ). Here one has a set of r experts, where each expert is a sequence pre-dictor. The Weighted-Majority algorithm ( Littlestone and Warmuth , 1994 ) uses such experts to do online prediction, and is guaranteed to perform almost as well as the best expert. More formally, for any sequence of length T , the average number of prediction mistakes of Weighted-Majority ( WM ) is bounded above by the av-erage number of prediction mistakes made by the best expert plus perform well when for every sequence there exists an expert that performs well on it and when the sequence is long enough.
 Given the above, it X  X  clear that learning from experts will work when the experts t the sequences we want to predict. Thus a key question, which we address here, is how to choose a good set of experts. We propose to learn these experts from a set of training sequences. In the spirit of empirical risk minimization we shall seek a set of experts that perform well on our training set. This is a highly non-trivial task in our case due to several reasons. First, the performance of a pool of experts is measured by the performance of an online algorithm whose parameters are the experts, and it X  X  not clear how to optimize this function. We shall see that the hindsight loss is a simpler function to optimize and results in comparable theoretical guarantees. Sec-ond, we would like our experts to use arbitrarily long histories in making predictions, but do so without over fitting. We shall show that this can be done by using a variant of context trees (a.k.a. prediction suffix trees). Finally, it X  X  not clear what generalization guarantees, if any, can be expected from such a scheme. We per-form a detailed generalization analysis, providing the-oretical bounds on the sample complexity of learning a good set of experts.
 Our learning task is thus as follows: given a training set of sequences, learn a set of experts that will work well for online sequence prediction. In a sense, this can be viewed as a collaborative version of sequence prediction. We provide an objective that corresponds to this discriminative setting and analyze the general-ization error of its minimizer. Our theoretical analysis provides generalization bounds that show no over fit-ting for longer histories, and quantify the advantage of learning in the collaborative setting.
 We apply our model to synthetic and real-world prob-lems and show that it outperforms methods which do not use temporal and collaborative approaches. Let  X  be a finite alphabet. A sequence of symbols is a member of  X   X  and is denoted by x = ( x 1 ,...,x T ). Online sequence prediction takes place in consecutive rounds. On round t , the forecaster observes the prefix x next symbol, x t , is revealed and the forecaster pays 1 An  X  X xpert X  for sequence prediction is a function f :  X   X   X   X . Such an expert can be used for predicting the t  X  X h symbol by setting  X  x t = f ( x 1: t  X  1 ). Given a set of r such experts, the Weighted-Majority (WM) algorithm ( Littlestone and Warmuth , 1994 ) (see pseudocode below), can be used for predicting almost as well as the best expert.
 A performance guarantee for WM is provided in the following theorem ( Littlestone and Warmuth , 1994 ). Theorem 1 The Weighted Majority algorithm (with  X  = 1 T  X  It follows that we can predict the sequence reasonably well if two conditions hold: 1. log( r ) is sufficiently small compared to T . 2. At least one of the experts makes a small number Therefore, when choosing a set of experts we face the classical bias-complexity tradeoff: On one hand we want r to be small enough so that the regret term  X  log( r ) /T will be small. On the other hand, differ-ent experts will work well on different sequences, and since we do not know the type of sequence we are go-ing to get, we would like to increase r so that the set of experts will be rich enough to explain many types of sequences.
 In this paper we propose to learn a good set of experts based on a sample of sequences. Formally, let H be a hypothesis class of experts. It is convenient to allow experts to output predictions from a set Y , where we have some way to convert an element from Y into a prediction in  X . For example, we can use Y = R |  X  | , where we interpret the prediction y  X  Y as a score for each of the symbols in  X . The mapping from a score vector in Y to an actual prediction in  X  is via arg max  X   X   X  y  X  . Therefore, each f  X  H is a function from  X   X  to Y . The loss of a prediction f ( x 1: t  X  1 ) is measured by a loss function  X  : Y  X   X   X  R . The loss function can be the 0-1 loss 1 [ x other loss measures that are convex surrogates of the zero-one loss.
 The problem that we consider in this paper can be for-malized as follows: We are given a sample of sequences, S = ( x (1) ,..., x ( m ) ), where each x ( i ) is assumed to be sampled i.i.d. from an unknown distribution D over  X  . Our goal is to use S for learning a set of experts, F  X  H , of size | F |  X  r , where r is a parameter of the learning problem (which should depend on the typical size of T ). We wish to learn F such that when running WM on a new sequence with the set F it will have a small number of mistakes.
 Given an expert f and a sequence x , we denote by L ( f, x ) the average loss of f on x , specifically: Given a set of experts, F  X  X  , we denote by WM( F, x ) the averaged loss of applying the WM algorithm on the sequence x with the set of experts F . Therefore, our ultimate goal is to learn a set of experts F which (approximately) minimizes Before we describe how we learn F , let us first consider two extreme situations. First, for r = 1, i.e. F = { f } , then WM( F, x ) = L ( f, x ). That is, at prediction time, we simply follow the predictions of the single expert f . This is exactly the standard traditional setting of sta-tistical batch learning, where we would like to learn a model f from a hypothesis class H whose expected loss over a randomly chosen example (in our case x  X  X  ) is as small as possible. The problem with this approach is that it might be the case that the sequences are of different types, where no single expert from H is able to accurately predict all of the sequences. On the other extreme, if we set r =  X  , i.e. F = H , then we revert to the problem of online learning with a hypothesis class H . The problem with this approach is that if H is  X  X omplex X , 1 then the sequence length required in order to guarantee good performance of the online learning might be very large. A straightforward approach for learning F when r &gt; 1 is to follow the empirical risk minimization (ERM) principle, namely, to solve the optimization problem This problem might be difficult to optimize since the objective function involves the activation of an algo-rithm and does not have a simple mathematical for-mulation. To overcome this difficulty, we show how a simpler objective may be used. In light of Theorem 1 (generalized to convex surrogate losses) we know that for any sequence x , Let us slightly overload notation and denote Thus L ( F, x ) is the hindsight loss when learning the sequence x with experts F . Taking expectation of both sides of Eq. 1 we obtain that
E The second summand only depends on F via its size. Therefore, for a fixed size of F , we can follow a stan-dard bound minimization approach and aim at mini-mizing E x  X  X  [ L ( F, x )] instead of E x  X  X  [WM( F, x )]. In other words, we minimize the hindsight loss instead of the online loss. An ERM approach to this minimiza-tion yields the following minimization problem on the training set of sequences: By definition of L ( F, x ), this can be written equiva-lently as where  X  r = { w  X  R r : w  X  0 ,  X  w  X  1 = 1 } . Assuming that H can be encoded as a convex set and L ( f, x ) is a convex function, 2 we obtain that the objec-tive of Eq. 4 is convex in f 1 ,...,f r and w (1) ,..., w individually but not jointly. This suggests an alternat-ing optimization scheme where one alternates between optimizing over w  X  X  and over f  X  X . This scheme is es-pecially attractive since minimizing over w for fixed F is straightforward: for each sequence x ( i ) find the best expert and set w ( i ) to 1 for that expert and 0 otherwise. Optimizing f i for fixed w can be done via gradient descent when using a smooth loss as we do here (see Sections 3.1 and 3.2 ). 3.1. The class of bounded norm context trees Thus far we have given a general scheme and have not described the particular set of experts we will use. In what follows we specify those. Any function f :  X   X   X   X  can be described using a multiclass context tree . For our experts, we will be using a generalization of multiclass context trees following Dekel et al. ( 2010 ), described below.
 To simplify notation, denote  X  = [ k ] = { 1 ,...,k } . A multiclass context-tree is a k -ary rooted tree, where each node of the tree is associated with a vector z  X  R k . The prediction of the tree on a sequence x 1: t  X  1 is determined as follows. We initially start with the vector z = 0  X  R k , and set the current node to be the root of the tree. We then add to z the vector associated with the current node and traverse to its x  X  1 child, which becomes the current node. We add again the vector associated with the current node and traverse to its x t  X  2 child. This process is repeated until we arrive either to x 1 or to a leaf of the tree. The final value of z gives a score value to each of the elements in  X , and the actual prediction is arg max i z i . It is convenient to represent a context tree as a matrix with k rows as follows. Let us order the nodes of a full k -ary tree in a breadth first manner. For simplicity, we restrict ourselves to trees of bounded depth (which can be very large, so this is not a serious limitation). To represent a context tree as a matrix, we set column i of the matrix to be the vector associated with the i  X  X h node of the tree (where if the node does not exist in the tree we simply set the column to be the all zeros vector). Similarly, we can map a sequence x 1: t  X  1 to a we traverse from the root of a full k -ary tree accord-ing to the symbols x t  X  1 ,x t  X  2 ,...,x 1 , as we described before. Then, we set all the coordinates of  X  ( x 1: t  X  1 corresponding to nodes we visited in this path to be 1, and set all the rest of the coordinates to be zero. It is easy to verify that the vector z constructed by a context tree for the history x 1: t  X  1 is U  X  ( x 1: t where U is the matrix describing the context tree (the size of U is thus |  X  | X |  X   X  | and the columns correspond to the vectors z at each node).
 As mentioned before, any function f :  X   X   X   X  can be described by a context tree (as long as we allow its depth to be large enough). Therefore, without ad-ditional constraints, learning the class of all context trees from a finite sample will lead to over-fitting. To overcome this, one can constrain the depth of the tree. Alternatively, we can allow any depth but carefully discount long histories as described next.
 Following ( Dekel et al. , 2010 ), we aim to balance be-tween long histories (can be very informative but are rare in the data hence are hard to learn) and short his-tories (less informative but easier to learn). This can be done by defining a norm over matrices correspond-ing to context trees, where longer histories are penal-ized more. Formally, for each column i of a context tree matrix U , let d ( i ) be the depth of its correspond-ing node in the tree. Let a 1  X  a 2  X  ... be a sequence such that vectors to be such that and a norm over matrices to be  X  U  X  2 = where U j is the j  X  X h row of U . Put another way, the squared norm of U is a weighted sum of the squared Euclidean norms of columns of U , where the weight of column i is a d ( i ) . Thus, we assign a higher penalty to columns corresponding to deep nodes of the trees. Consequently, we define the hypothesis class of bounded norm context trees to be Finally, we also need to define scale sensitive loss func-tions. A common choice is the multiclass log-loss: This loss function has the advantages of being a convex surrogate loss for the zero-one loss. 3.2. The LEX algorithm We are now ready to describe our algorithm, which we call LEX (for Learning Experts). Our goal is to minimize the loss in Eq. 4 with respect to the vectors w i and the parameters of the experts. As described in Section 3.1 , we parameterize each expert by a con-text tree matrix U  X  R k  X |  X   X  | . As mentioned earlier, we can minimize Eq. 4 via alternating optimization where minimizing over w can be done in closed form and minimizing over U can be done with gradient de-scent. Calculating the gradient w.r.t. U is easy for the log loss. In our implementation we use stochastic gradient descent, where an update is performed after each training sequence is processed. Define the generalization loss for the set of experts F : In light of Eq. 2 , in order to bound E x [WM( F, x )] it suffices to bound L D ( F ). In this section we derive bounds on L D ( F ). Our bounds depend on the follow-ing measures: the number of experts | F | , a complex-ity measure of the hypothesis class H , the number of training examples, and the training loss: We first define a complexity measure for a hypothesis class H with respect to a loss function  X  .
 De nition 1 Let H be a class of functions from Z to Q , let Y be a target set, and let  X  : Q  X  Y  X  R be a loss function. We say that the complexity of H is C ( H ) if for any sequence ( z 1 ,y 1 ) ,..., ( z q ,y q )  X  ( Z  X  Q ) for any  X  &gt; 0 , there exists H  X   X  H of size |H  X  |  X  that satis es The reader familiar with covering number bounds can easily recognize C ( H ) as determining the size of a cover of H . It is also easy to verify that if H is a class of binary classifiers then C ( H ) is upper bounded by the VC dimension of H (this follows directly from Sauer X  X  lemma). We will later show that the class of bounded norm context trees has a bounded C ( H ) as well. Theorem 2 Let D be a probability over  X   X  such that there exists some constant T with P [len( x )  X  T ] = 1 . Assume also that for all x and F  X  H we have L ( F, x )  X  [0 , least 1  X   X  over S  X  X  m , for all F  X  X  , with | F | = r , we have The above theorem tells us that if H is of bounded complexity, then the number of samples required to have L D ( F )  X  L S ( F ) +  X  is order of rC ( H ) / X  2 . In particular, the sample complexity of learning a set of r experts is r times larger than the sample complexity of learning a single expert.
 The proof of the theorem is given in the long version of this article. The main ideas of the proof are as follows. First, we construct a cover for the loss class { x 7 X  L ( F, x ) : F  X  X  , | F | = r } . Then, we bound the Rademacher complexity of this class using a general-ization of Dudley X  X  chaining technique, which is sim-ilar to a technique recently proposed in Srebro et al. ( 2010 ).
 Next, we turn our attention to the specific class of con-text trees with bounded norm. The following lemma bounds its complexity.
 Lemma 1 Let H B be the class of multiclass context trees which maps  X   X  into R |  X  | as de ned in Section 3.1 . Let  X  : R |  X  |  X   X   X  R be a loss function such that  X  l  X   X  , u,v  X  R |  X  | , |  X  ( u,l )  X   X  ( v,l ) | X  X  X  u  X  v Then: C ( H B )  X  O ( B 2 log( k )) .
 The proof of the lemma is given in the long version of this article. The main idea is a nice trick show-ing how to bound the cover of a linear class based on known bounds on the convergence rate of sub-gradient mirror descent algorithms (e.g., see Nemirovski and Yudin , 1978 ). This is similar to a method due to Zhang ( 2002 ), although our bound is slightly better. The multiclass log-loss function satisfies the conditions of the above lemma, hence: Corollary 1 Let H B be the class of multiclass context trees and let  X  be the multiclass log-loss. Let D be a probability over  X   X  such that there exists some constant T with P [len( x )  X  T ] = 1 . Then, with probability of at least 1  X   X  over S  X  X  m , for all F  X  X  B , with | F | = r , we have In summary, if we manage to find a set F  X  X  B of size r that achieves a small hindsight training loss, then it will also achieve a small hindsight generalization loss. Combining this with Eq. 2 yields E [WM( F, x )]  X  L S ( F )+  X  O Therefore, the performance of the Weighted-Majority algorithm is upper bounded by three terms: The train-ing loss of F (which can decrease when increasing r ), the estimation error term (which increases with r ), and the online regret term (which also increases with r ). The problem of sequence prediction has a fairly long history and has received much attention from game theorists ( Robbins , 1951 ; Blackwell , 1956 ; Hannan , 1957 ), information theorists ( Cover and Hart , 1967 ; Cover and Shenhar , 1977 ; Feder et al. , 1992 ; Willems et al. , 1995 ), and machine learning researchers ( Helm-bold and Schapire , 1997 ; Pereira and Singer , 1999 ; Cesa-Bianchi and Lugosi , 2006 ; Dekel et al. , 2010 ). One of the most useful tools is context trees, which store informative histories and the probability of the next symbol given these. However, all of these works consider predicting a sequence from a single source. Indeed, our work extends these single sequence predic-tions to the collaborative setting where we model dif-ferent sequences, but constrain the predictors to share some common structure (i.e., the experts used in pre-diction).
 Another related line of work is multitask prediction (e.g., see Ando and Zhang , 2005 ; Abernethy et al. , 2007 ), in which one considers several different multi-class prediction problems and seeks a common feature space for those. This setting is different from ours in several ways. First, in the multitask setting one re-ceives a set of training instances from each task, where it is known which sample belongs to each class. In our case, we receive only a set of individual sequences. Fur-thermore, in the multitask setting, the test data comes from one of the known tasks, whereas we again receive a novel sequence from an unknown source.
 A more recent approach to sequence modeling is the  X  X equence memoizer X , which is based on nonparamet-ric Bayesian models ( Wood et al. , 2009 ). So far these have been applied to a single type model (e.g., lan-guage modeling), and not for multiple distinct mod-els as we have here. It is conceivable that a fully Bayesian model for collaborative sequence prediction can be built using these models, and it would be in-teresting to contrast it with our approach.
 Another possible approach to the problem is to use probabilistic latent variable models ( Hofmann , 1999 ) or their discriminative counterparts ( Felzenszwalb et al. , 2008 ; Yu and Joachims , 2009 ). Here each se-quence will be mapped to a latent variable correspond-ing to the best expert. Next, given the class and the previous history, a probabilistic suffix tree will be used to generate the next action. However, such a model will not handle long histories appropriately and is likely to result in overfitting (as our empirical results also show). While it may be possible to add history discounting to such a model, it will be considerably more complex than what we suggest here.
 In our formulation, the state space  X  is unstructured. There are cases of interest, where  X  has structure. For example, it may correspond to the items in an online shopping basket. Prediction in such a setting was re-cently addressed in Rendle et al. ( 2010 ). Unlike in our case, they have access to multiple training sequences from particular users, and prediction is done on these users. Furthermore, the temporal model itself is only first order and thus very different from ours. Note that we can easily extend our approach to structured state spaces by using structured prediction instead of multiclass as we do here. In what follows, we evaluate the performance of the LEX algorithm (see Section 3.2 ) on two datasets: syn-thetic and real-world. We compare it to the baselines described below. 6.1. Baselines Models We consider three different baselines models. The first is our LEX algorithm with r = 1 (we denote this base-line by 1-LEX ), which is in fact a batch trained PST (where training uses the log loss). In this approach all training sequences are modeled via a single PST corresponding to one expert. It thus does not directly model multiple temporal behaviors of the sequences in the data.
 Our second baseline is an online PST model which is evaluated on each test sequence individually. Training is done using the algorithm in ( Dekel et al. , 2010 ). Be-ing an online algorithm, it does not use the training data. However, given long enough sequences it will be able to model any deterministic temporal behavior op-timally. In other words, this algorithm has the benefit of adaptation but its performance crucially depends on the length of the sequence. We denote this baseline by Online PST .
 Finally, we consider a generative latent variable model (denoted by LMM ) which is a mixture of Markov chains. An order d Markov chain is a basic yet power-ful tool for modeling sequences. In LMM we general-ize Markov chains by allowing each sequence to be gen-erated by one of r regular Markov models. We think of these r models as different chain types similarly to the r experts of LEX . Specifically, for a sequence x ,...x t  X  1 the r -LMM model of order d is defined by: Where z is the latent (unobserved) variable which  X  X s-signs X  a chain type to a sequence. Note that the stan-dard Markov chain is simply a 1-LMM . We learn the parameters of a LMM from training data using EM . The (online) prediction using this model is done by the maximum a-posteriori assignment at each point in time. Since LMM does not discount long histories, it is not expected to perform well when d is large and not enough training data is available. Parameters for all algorithms (i.e., r and d ) were tuned using cross validation. 6.2. Synthetic Data We begin by considering sequences that follow one of two temporal patterns. The sequences are generated as follows: First randomly select j  X  X  1 , 2 } then draw T samples according to the (independent) distribution: Pr( x t = x ) = |
 X  | = 200 and generated a set of m = 1000 sequences, each of length T = 250 (these parameters where se-lected to resemble the browsing data characteristics). We note that by construction, the maximal possible generalization accuracy on this data is 0.5. We eval-uate the accuracy of online prediction on 400 test se-quences. In Fig. 1 we show the accuracy (on test data) of LEX and the three baselines. We notice that LEX approaches 0.5 accuracy using about 50 sequences, 1-LEX and LMM require substantially more samples in order to approach this performance (over 500 se-quences for 0 . 45 accuracy). In other words, in agree-ment with our theoretical analysis, the sample com-plexity of LEX is smaller than both 1-LEX and LMM . The accuracy of online PST is much lower due to the conservative training of this algorithm. 6.3. Click Prediction Data Here we consider a challenging task of predicting the browsing pattern of web users. Specifically, we use browsing logs for users in an intra-net site. For each session the sequence of url s visited by every user was recorded by the web server. The dataset contains 2000 such sequences of length 70-150. The domain of the prediction problem, is of distinct url s and its mag-nitude is |  X  | = 189. The data was split into train, validation and test sets, the sizes of the training sets vary, while the validation and test set sizes were fixed at 200 and 800 sequences respectively. We applied the three baseline models, and compared their per-formance to LEX . In this experiment the r experts learned by LEX were combined with an additional expert obtained from training a 1-LEX algorithm, re-sulting in a pool of r +1 learned experts. This addition smoothes performance on short sequences where the WM algorithm might not have enough time to decide which of the r experts to follow.
 Results are shown in Fig. 2 . It can be seen that LEX outperforms the other methods. When considering the difference in accuracy between LEX and 1-LEX we notice that the added accuracy from multiple experts shrinks as training size increases. This trend agrees with theory, since as more data is available to 1-LEX , it can use longer histories and eventually will be able to model any temporal behavior. However, as we show in the synthetic experiments, the gap for small data sizes can be considerable.
 We have described and analyzed a method for learning the experts for online sequence prediction. In partic-ular, we specified it to the class of prediction suffix trees. Thus, our experts can capture dependencies on arbitrarily long histories. This is achieved by map-ping context trees into a vector space and designing a norm on this space which discounts long histories. As our generalization results show, the complexity of the model is not penalized by the maximal possible length of histories (dimensionality of the matrix U ) but rather by the effective needed context based his-tory (captured by the norm of U ). Our empirical re-sults show that temporal user specific structure can indeed be used to improve prediction accuracy. The proposed approach can be extended in several ways. First, we can consider different prediction goals: instead of predicting the next symbol in the sequence, corresponding to the next URL, we can have a binary classifier that returns one if a user is likely to take a given action and zero otherwise. Alternatively, we can consider a ranking task where we want to sort actions according to their interest to the user. To use such objectives we will just need to replace our multiclass log loss with the corresponding loss.
 Finally, we note that our model can be applied to a wide array of practical problems. Some examples are ad placements, course enrollment systems, and en-hanced user interface automation.
 Acknowledgements: This research is supported by
