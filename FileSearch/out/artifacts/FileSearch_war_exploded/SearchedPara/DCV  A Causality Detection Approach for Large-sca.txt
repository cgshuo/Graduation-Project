 Recent studies have indicated the significance of supporting real-time group editing in  X  X iki X  applications, whose col-laboration environments have their dynamic and large-scale nature. Correct capture of causal relationships between op-erations from different users is crucial in order to preserve consistency of object copies. This challenge was resolved by employing vector logical clock. But since its size is equal to the number of cooperating sites, it has low efficiency when dealing with a collaborative environment involving a large number of participants. In this paper, we propose a direct causal vector (DCV) approach for solving causality detec-tion issues in real-time group editors. DCV timestamp does not record the causality information that can be deduced from the transitivity of causal relation. As a result, it can automatically reduce its own size when people leave the col-laboration session and always keep small. We prove that DCV approach is well fit for capturing causality in wiki like large-scale dynamic collaboration environments.
 C.2.4 [ Computer-Communication Networks ]: Distrib-uted applications; K.4.3 [ Computers and Society ]: Com-puter supported collaborative work Algorithms, Design CSCW, Concurrency Control, Groupware, Group Editors, Logical Clock, Direct Causal Vector  X 
The work is supported by National Natural Science Foun-dation of China (NSFC) unde r Grant No.90612008, National Grand Fundamental Research 973 Program of China under Grant No.2005CB321905 and Shanghai Science and Tech-nology Committee Key Fundamental Research Project un-der Grant No.05JC14006.

Real-time group editors enable a group of users to view and edit the same document (e.g., text, graphic and mul-timedia document) simultaneously from geographically dis-persed sites connected by communication networks such as the Internet[2, 7]. This category of groupwares have some unique characteristics which make them distinct from other kinds of collaborative work[2, 4, 7, 8, 22]: 1. real-time: the response to local user actions must be quick and the latency for reflecting remote user actions must be low; 2. uncon-strained: cooperating users are able to freely edit any part of the document at any time, synchronously or not. 3. dis-tributed: cooperating users may operate different machines connected by different communication networks with non-deterministic latency.

A replicated approach has been proposed to meet the re-quirements for good responsiveness and unconstrained col-laboration. Documents are replicated at each cooperating site, and user operations are first executed on their local replicas immediately, and then propagated to all other co-operating sites for group awareness. To ensure that the doc-ument replicas at each cooperating sites can always exactly reflect the initial intentions of each cooperating users, and can eventually arrive at the same consistent status at the end of collaborative session, whenever to synchronize a remote operation, it must take into account the impact of all the concurrent operations executed previously. Thus, precise capture of causality is crucial in real-time group editors[2, 7, 8].

Vector logical clock is currently the most widely used causality detection technique[2, 7, 9, 17, 18, 19]. However, it has only been proved to work well in small collaboration environment (less than ten participants). Our recent studies have indicated the significance of supporting real-time group editing in  X  X iki X  applications, whose collaboration environ-ments have their dynamic and large-scale nature. Vector logical clock is not fit for such collaboration environments. Is there any other causality detection solution? This is the focus of this paper.
The Internet has fostered an unconventional and powerful style of collaboration:  X  X iki X  web sites. A wiki is such a web-site  X  every visitor is allowed and able to add new pages to it, remove existing pages, or otherwise edit and change the content of existing pages, using just web browsers[25]. By working on the same wiki website, geographically dispersed users can easily collaborate and share knowledge with each other. Wiki web sites, as a novel and convenient collabo-ration medium, is becoming more and more popular, which could be evidenced by an increasing number of wiki applica-tions, such as Wikipedia[26], WikiNews[24], WikiTravel[28] and StrategyWiki[23].
 Existing wikis only support asynchronous collaboration. People collaborate with each other in a Copy-Modify-Merge manner: each wikipedian checks out a separate working copy of wiki pages from the the wiki server; then modi-fies her/his working copy independently; and finally merges her/his working copy with those from other wikipedians[23, 24, 26, 28]. Our recent study means to, by adapting existing single-user wiki page editors to full-featured real-time group editors, support wiki users synchronous collaboration.
Supporting both synchronous and asynchronous collabo-ration allows more flexible collaboration among users. Wiki users can collaborate with each other more closely and more effectively. Consider the following scenario: a wiki user, named Bob, poor at language expression, just drafts his ideas on the wiki page; at the same time another wiki user help to revise his expression; if there is misunderstanding, Bob will immediately notice and correct it. It could save Bob a lot of time without carefully choosing and organizing his words.

Another notable benefit is that it could help to eliminate editing conflicts. In existing wikis, we have more than once experienced that we made a large number of changes to a paragraph of text, only to have them all silently discarded when someone else, editing the same paragraph at the same time, saved their modifications after me. Although this does not happen very often, they are really frustrating. As has been mentioned before, wiki systems are gaining more and more populations. As the wiki systems grow, so do the op-portunities for conflict. How to help reducing the coordi-nation costs? It has become a problem faced by many wiki designers and researchers[1]. An unique feature of real-time group editors is real-time workspace awareness. It could help people detect editing conflicts as early as possible. Histor-ical studies have indicated that when concurrently working on the same object, if people are able to see others in real time, it is less likely that their actions seriously conflict with each other[3].

The collaborative environments in wikis are typically large-scale and dynamic collaboration environments. In wiki ap-plications, each wiki page represents a collaboration session. People viewing or editing one wiki page all are participants of corresponding wiki collaboration session. The number of participants of a wiki collaboration session could be very large (i.e. hundreds, thousands or more). Take Wikipedia as an example. Many of its wiki pages have over thousands of hundreds of visitors a day[27]. Another feature of wiki collaboration environments is dynamic. In wiki applications like Wikipedia, every minute there are hundreds of users join and leave[27]. People usually leave a wiki collaboration session (wiki page) by simply closing the web browser or navigating to another web page. There is not any notifica-tion.
Most existing real-time group editors employ vector log-ical clock to help detect causality[2, 7, 9, 17, 18, 19]. In these implementations, a fixed sized state vector is attached to each operation o , named vector logical clock timestamp, in which each item corresponds to a collaboration partic-ipant, and records the number of operations generated by that participant that are causally preceding o .Bycompar-ing their vector logical clock timestamps, causal relationship between any two operations can be easily determined.
This approach works well when the collaboration group is small. However, the size of vector logical clock linearly de-pends on the number of participants. If there are hundreds, thousands or even more participants, problem occurs. The timestamp attached to each operation will become huge in size, even much larger than the operation itself, which could add an intolerable cost to network transmission, local stor-age as well as causality detection complexity, and as a result, seriously affect the performan ce of the groupware system. Moreover, many large-scale collaboration environments (i.e. Wikipedia) are open. They tend to have a nondeterministic number of participants. In such collaboration environments, it is not practical to timestamp operations with a fixed size state vectors.

Some previous work tries to solve this problem by[11]: 1. redesigning the vector logical clock, using associative vec-tors indexed by participant identifier, thus allowing the sys-tem to dynamically add new timestamp items or discard old timestamp items during the collaboration session; and 2. allocating timestamp items dynamically at run-time, cre-ating vector items just for those participants who have writ-ten, instead of pre-allocating a timestamp item for all the potential participants; and 3. if some participants midway leave the collaboration session, watching their corresponding timestamp items and removing them once they have become insignificant.

In these above approaches, since timestamp items are not pre-allocated at the beginning of the collaboration session, opening large-scale collaboration environments should no longer be a problem. Furthermore, if the collaboration envi-ronment is not active, most participants just read instead of writing, the vector logical clock timestamp of each operation will never grow too large. It seems that these approaches can help to significantly ease the problems about vector logical clock in large-scale collaboration environments. Neverthe-less, the trouble is that, firstly, it is difficult to determine whether a participant has really left the collaboration ses-sion or not in a large-scale collaboration environment. We still take wiki as an example. As mentioned before, people in wiki collaboration sessions often leave by simply closing the browser window or navigating to another page, with-out sending any notification to wiki server. Thus, we can by not direct means determine whether a participant has left the collaboration session or not. It is also not safe to assume that any participants who are not active for a pre-determined time has already left the collaboration session. People collaborate with each other over Internet. The net-work is unstable. Sometimes we do not receive any message from a participant for a long time, just because the network connection between he/she and other participants is tem-porary failed. Even if we can make sure that a particular participant has left the collaboration session already, it is not always safe to remove her/his corresponding timestamp item. A timestamp item could be safely reclaimed only af-ter the operations that were generated by the corresponding participant have all been synchronized at all the cooperat-ing sites. In an unreliable and highly dynamic collaboration environment like wiki, it is usually difficult to determine the exact list of participants that are currently present in the collaboration session and thus is also difficult to determine whether a timestamp item has become insignificant or not.
In the past decade, there have been several different tech-niques about vector logical clock compression[6, 11, 14, 16, 20, 21]. But as to our knowledge, none of them can really solve all its efficiency issues in large-scale collaboration en-vironments, without imposing any assumption on network reliability and negatively affecting the users X  normal collab-oration work.

Noticing the limitation of vector logical clock, some exist-ing real-time group editing systems design their own causal-ity detection solutions[10, 13, 19]. Their main ideas are quite similar. In these systems, before propagating an local oper-ation, cooperating sites pre-transform it against some con-current operations generated from other cooperating sites to make them appear as sequential operations. By carefully designing the transforming and propagating rules, causality detecting issues in these systems are greatly simplified, and thus bring the possibility for much simpler causality detec-tion solutions. The common drawback of such approaches is that, during the pre-transforming, intention conflict among different participants may be improperly hidden, which may incurs much intolerable confusion. Furthermore, as to our knowledge, existing systems of this category either suffer from single-point failure, or require extremely reliable and stable collaboration network. None of them is well fit for wiki like wide-area collaboration environments.
In this paper, we develop a new causality detecting ap-proach, named Direct Causal Vector (DCV). This is a well scalable approach, which works well in many large-scale dy-namic collaboration environments, including most existing wiki environments.

The rest of this paper is organized as follows: Section 2 introduces some background concepts and makes clear the causality detection issues needed to be solved in realtime group editor systems. Section 3 introduces the concept of direct causal vector, which is our new timestamp design. Section 4 proposes a solution to all the issues proposed in section 2, based on our new timestamp design. Section 5 makes some discussion on our new approach and section 6 compares it with related works. Section 7 summarizes the contributions of this paper.
In this section, we will introduce some background con-cepts and articulate the causality detection issues needed to be solved in realtime group editor systems.
Following Lamport[15], in this paper, we define a causal ordering relation on operations in terms of their generation and execution sequences.

Definition 1. [ Causal relation  X   X   X  ]Giventwoopera-tions o a and o b , generated at site i and j, then o a  X  iff: (1) i = j and the generation of o a happened before the generation of o b ,or(2) i = j and the execution of o a at site j happened before the generation of o b ,or(3)thereexists an operation o x , such that o a  X  o x and o x  X  o b .
The operation o a is said to causally precede o b iff o a o . Operations that are not cau sally related are said to be concurrent, denoted as o a o b . More accurately o a and o are concurrent iff neither o a  X  o b nor o b  X  o a . Figure 1: A scenario of a real-time cooperative edit-ing session.

As illustrated in Figure 1. o 11 , o 21 and o 31 are concur-rent with each other. o 12 is causally dependent on three operations o 11 , o 21 and o 31 . o 22 is causally dependent on four operations o 11 , o 21 , o 31 and o 12 . o 32 is only causally dependent on o 31
To achieve high responsiveness and high concurrency, a replicated architecture has been introduced and widely ap-plied in current realtime grou p editor systems. In this ar-chitecture, a document replica is maintained at each coop-erating site. Collaborators are allow to modify their own document replicas at any time. After their local executions, operations are broadcasted to all the collaborators for syn-chronization. For high usability, it is required that a real-time group editor with replicated architecture always satisfy the following properties[2, 5, 7]: 1. Convergence: When the same set of operations have 2. Causality preservation: For any pair of operations o a 3. Intention preservation: For any operation o , the effects Thus, the following causality detection issues surface.
Problem 1. Given an unexecuted remote operation, how to determine whether all the operations causally preceding it have already been executed?
To achieve causality preservation, we must ensure that an operation is not executed on a remote site until all the operations on which it causally depends have already been executed. However, due to the nondeterministic communi-cation latency, remote operations may arrive out of their natural causal order. Thus, we must check its causality con-dition every time before executing a remote operation.
Problem 2. Given an unexecuted remote operation that is causally ready, how to separate all the history operations that are concurrent to it from the operation history?
An operation history is a set of history operations that satisfies (1) it contains all the history operations that have the possibility of being concurrent with the future incoming remote operations and (2) if it contains an operation, all the history operations causally depend on this operation are also included. In real-time group editor systems, an operation history could be found maintained at each cooperating site [2, 7, 9, 17, 18, 19].

To achieve intention preservation, whenever executing a remote operation, the impact of concurrent operations in the operation history must all be taken into account.
Problem 3. How to determine the causal relationship be-tween two arbitrary operatio ns in the operation history?
It is not a trivial matter to find the real intention of a remote operation. It is also required by some concurrent control algorithms that causal relationship between two his-tory operations be determined correctly and efficiently[2, 8, 18].
Causal relation is transitive, that is, if o a  X  o b and o o ,then o a  X  o c . Some causal relationships can be de-duced from other causal relationships by transitivity, while others can not. By differentiating these two kinds of causal relationships, we come up with the concept of direct causal relation . Direct causal relation represents those causal re-lationships that can not be deduced from other causal rela-tionships by transitivity.

Definition 2. [ Direct causal relation  X   X   X  ]Giventwo operations o a and o b , o a causally precede o b directly, denoted as o a  X  o b ,iff: (1) o a  X  o b , and (2) there exists no operation o x satisfying o a  X  o x and o x  X  o b .

The concept of direct causal relation just excludes those causal relationships that could be deduced from other causal relationships by transitivity, thus there exists the following theorem.

Definition 3. [ Uninterrupted Operation Set ]Inthis paper, we refer to an operation set as uninterrupted iff: given two causally related operations o a and o b in the operation set (suppose o a  X  o b ), there exists no operation o such that o a  X  o and o  X  o b but o is not contained in the operation set.

Theorem 1. Given an uninterrupted operation set S and two operations o a , o b in it, then o a  X  o b ,iff(1) o a (2) there exists a operation sequence o 1 , o 2 , ..., o n that ( o a  X  o 1 )  X  ( o 1  X  o 2 )  X  ...  X  ( o n  X  1  X  o n
Definition 4. [ Direct causal vector(DCV) ]Givenan operation o , suppose there exist only k operations that are causally preceding it directly, enumerated as o 1 ,o 2 , ..., o Here, o 1 is the n 1 th operation generated at cooperating site s ; o 2 is the n 2 th operation generated at cooperating site s ...; o k is the n k th operation generated at cooperating site s The direct causal vector of o , denoted as DCV ( o ), is defined as DCV ( o )=[( s 1 ,n 1 ) , ..., ( s k ,n k )].

Notice that each item in the direct causal vector DCV ( o ) represents an operation that is causally preceding o directly. Each operation that is causally preceding o directly must have a corresponding item in the direct causal vector DCV ( o ). It must hold that o x  X  o iff o x  X  DCV ( o ). Thus, to de-termine the direct causal relationship between o 1 and o 2 we just need to check whether o 1 exists in DCV ( o 2 )and whether o 2 exists in DCV ( o 1 ).

To illustrate the concepts of direct causal relation and di-rect causal vector , refer to the scenario in Figure 1 again, o 11 , o 21 and o 31 have no operation causally preceding them directly; o 12 causally depends on o 11 , o 21 and o 31 directly; o 22 causally depends on o 12 directly. o 32 causally depends on o 31 directly. The direct causal vector of o 11 , o 21 o [(1 , 3)] respectively.

Following are some interesting properties of direct causal relationship, related with causality detection in real-time group editor systems.

Property 1. Given a remote operation o , suppose all the operations executed before respect their causal order. o is causal ly ready iff al l the operations causal ly precede o directly have already been executed.

To prove this property, consider an arbitrary operation o that is causally preceding o but not directly. According to theorem 1, there must exist another operation o x satisfying ( o t  X  o x )  X  ( o x  X  o ). Accordingtotheassumption, o x has already been executed, and it was executed after it had become causally ready. Thus o t must have been executed too.

This property indicates that to decide whether an unex-ecuted remote operation is causally ready, we just need to check the operations causally preceding it directly.
Property 2. Assume o is an unexecuted remote operation that is causally ready already. HB is the operation history. The causal relationship between o and an arbitrary history operation o in HB can be determined correctly just by trac-ing the direct causal relationships over HB  X  o .Soisthe causal relationship between two arbitrary causal operations in HB .

Notice that HB  X  o is an uninterrupted operation set, so this property can be deduced directly from the theorem 1.
These two properties indicate that, it is possible to solve the three causality detection issues in real-time group edi-tors just through the direct causal vector timestamp of each operations.
In this section, we will look into the causal detection is-sues mentioned in section 2 and give a direct causal vector timestamp based solution for each of these issues.
As has been pointed out in the previous section, to solve the first causality detection issue, that is, to decide whether an unexecuted remote operation is causally ready, we only need to check whether all the operations causally preceding it directly have already been executed.
 As is done in many previous works, we use state vector. Each site s maintains a state vector SV s .Foreachsite t in the collaboration session, there is a corresponding compo-nent in SV s , denoted as SV s [ t ], which holds a value corre-sponding to the number of operations that were generated at site t and have already been synchronized on site s .Are-mote operation o r received on site s is thought to be causally ready, if and only if it holds for each item ( s i ,n i )in DCV ( o that SV s [ s i ]  X  n i .

For illustration, refer to the scenario in Figure 1 again. At the time when o 12 , whose direct causal vector timestamp is named o 21 and o 31 , have been executed at site 2, that is, the statevectorofsite2is { SV 2 [1] = 0; SV 2 [2] = 1; SV 2 [3] = 1 It is not satisfied that SV 2 [1]  X  1, so o 12 is not causally ready and its synchronization must be delayed. The synchroniza-tion of o 12 is delayed until o 11 has been received and synchro-nized at site 2. At that time, the state vector at site 2 has changed to { SV 2 [1] = 1; SV 2 [2] = 1; SV 2 [3] = 1 } .Itsatisfies that for each item ( s i ,n i )in DCV ( o 12 ), SV 2 [ s i we could make sure that o 12 has become causally ready for synchronization.
In this subsection, we will focus on the second causality detection issue, that is, given an unexecuted remote opera-tion o r that is causally ready, separating from the operation history all the operations that are concurrent with it.
Our basic idea is to check the history operations (the op-erations in operation history) in the reverse order of their causal order. And we do not check a history operation until all the history operations that are causally dependent on it have been proved to be concurrent with o r .

Not all the history operations will be checked during the process. But if a history operation is ignored, there must exist at least one of its direct causal successor in the opera-tion history that could be proved to be causally preceding o Such operation can not be concurrent with r o , thus ensuring the correctness of our approach.

Concerning a history operation o h , whose direct causal successors have all been proved to be concurrent with o r Due to Theorem 1, it must hold that o h is either concurrent with o r or directly causally preceding o r . Thus, to decide whether o h and o r are concurrent with each other, we just need to check their direct causal relationship. As has been pointed out in the previous section, the direct causal rela-tionship between o h and o r can be determined directly by checking the direct causal vector timestamp of o r ,thusen-suring the efficiency of our approach.

We propose two data structures to facilitate the concur-rent separating process: direct causal history and direct causal graph.

Direct causal history (DCH) is a subset of operation his-tory. It contains those operations that have no causal suc-cessor in the operation history.
 Direct causal graph (DCG) is a graph of history operation. For each operation in the operation history, there is a corre-sponding node in the direct causal graph. Given two history operations o a and o b , there is a link from o a to o b in the di-rect causal graph iff o b  X  o a . In the following discussion, LT ( o ) will be used to denote the set of history operations that an operation o links to in the direct causal graph, and LF ( o ) will be used to denote the number of history opera-tions that have a link to an operation o in the direct causal graph.
 Figure 2: Illustration of the new concurrent separa-tion method.

To illustrate, consider the scenario in Figure 1. At site 3, after the execution of o 22 , there should be six operations in its operation history: o 11 , o 21 , o 31 , o 12 , o 22 and o responding status of DCH and DCG is displayed in Figure 2.

None of the operations o 11 , o 21 , o 31 , o 12 and o 22 dependent on o 32 .Thus, o 32  X  DCH . Similarly, o 22  X  DCH . Other history operations all have at least one causal successor in the operation history, o 11 as an example, the operation o 12 contained in the operation history is one of its causal successors, so none of them belongs to DCH.
In DCG, there are six operation nodes, corresponding to the six operations in the operation history. There are five directed edges in the graph, each corresponding to a direct causal relationship over the six history operations, i.e. there is a link from o 32 to o 31 in the graph because o 31  X  o is a link from o 22 to o 12 in the graph because o 12  X  o Furthermore, according to the graph, we have LF ( o 32 )= LF ( o 22 )=0, LF ( o 12 )= LF ( o 11 )= LF ( o 21 )=1and LF ( o 31 )=2.
 Following is the detail algorithm.

The Concurrent Separation procedure 1 takes a causally ready unexecuted operation o r as input and returns an oper-ation set set c o r that contains all the history operations that are concurrent with o r .

The operation set candidates is used to, during the proce-dure, temporarily keep the newly found history operations that are proved to have no direct causal successors in the op-eration history causally preceding o r . It is initialized with DCH (line 2), because (1) none of the operations in DCH have causal successors in the operation history, let alone hav-ing any causal successors in the operation history causally preceding o r , and (2) the operations in DCH are the only history operations that could be proved to have no direct causal successors in the operation history causally preceding o , at the beginning of the procedure. Based on the above analysis, to select out all the history operations concurrent with o r , we begin by checking these operations. The map structure map is used to record the number of history op-erations causally dependent on it directly which have been proved to be concurrent with o r for each history operation. Algorithm 1 Concurrent Separation( o r ): set c o r 1: set c o r  X   X  2: candidates  X  DCH 3: map  X   X  4: add a node to DCG, representing operation o r 5: add o r to DCH 6: repeat 7: examinee  X  candidates 8: candidates  X   X  9: for all o h in examinee do 10: if o h  X  o r then 11: if o h  X  DCH then 12: remove o h from DCH 13: end if 14: add to DCG a link from o r to o h 15: else 16: add o h to set c o r 17: for all o in LT ( o h ) do 18: if map [ o ] is undef ined then 19: map [ o ]  X  1 20: else 21: map [ o ]  X  map [ o ]+1 22: end if 23: if map [ o ]= LF ( o ) then 24: add o to candidates 25: end if 26: end for 27: end if 28: end for 29: until candidates is empty 30: return set c o r
The Concurrent Separation procedure simply repeats the checking process from line 7 to line 28 until all the concurrent history operations have been found.

In each round of checking, the Concurrent Separation pro-cedure check whether it is causally dependent on o r directly for each history operation in candidates . If not, according to the above analysis, the history operation currently checked must be concurrent with o r , so we add it into set c o r 16), and update map for each of the history operations it causally depends on directly (line 17-26). At the same time, we check whether some more operations could be proved to have no direct causal successors in the operation history causally preceding o r . If so, we will add such operations into candidates and prepare them for a next round of checking (line 23-25). According to the definition of map ,itiseasyto see that if map [ o ]= LF ( o ), it must hold that all the history operations which causally depends on o directly have been proved to be concurrent with o .

During the execution, the procedure also finish the ad-justment of data structures DCH and DCG. Initially, a new node is created in DCG and DCH for o r (line 4-5). For each operation causally preceding o r directly, the procedure en-sures its removement from DCH and adding to DCG a link from o r to it (line 11-14). Notice that if a history operation is causally preceding the causally ready unexecuted o r directly, it must have no direct causal successor in the operation his-tory causally preceding o r . All such operations are checked and handled during the execution of Concurrent Separation , and thus ensures the integrity of such adjustment.
To illustrate the Concurrent Separation procedure, still consider the scenario in Figure 1. Suppose a new remote operation o 41 , whose direct causal vector is [(1, 1), (3, 2)], is received at site 3 shortly after the execution of o 22 on that site. Obviously, o 41 is causally ready.

At the beginning of Concurrent Separation ( o 41 ), the op-eration set candidates is initialized with the two history op-erations in DCH o 32 and o 22 .

In the first round of checking. o 22 is proved to be concur-rent with o 41 . It is put into set c o 22 . At the same time, the value of map [ o 12 ] is adjusted to 1. Noticing that the value of map [ o 12 ] becomes equal to LF ( o 12 ), so o 12 is pushed into the operation set candidates . o 32 is proved to be causally preceding o 41 . It is removed from DCH and a link is added into DCG from o 41 to o 32 . During the first round of check-ing, only one more history operations o 12 is proved to have no direct causal successor in the operation history causally preceding o 41 , so at the end of this round of checking, the status of candidates becomes { o 12 } .

In the second round of checking, o 12 is proved to be con-current with o 41 . The status of variable map is updated to { map [ o 12 ]=1; map [ o 31 ]=1; map [ o 11 ]=1; map [ o 21 LF ( o 11 )=1and LF ( o 21 ) = 1. Two more operations o 11 and o 21 are proved to have no direct causal successor in the operation history causally preceding o 41 . They are added into the operation set candidates . At the end of the second round of checking, the status of candidates is { o 11 ,o 21
In the third round, o 11 is proved to be causally preceding o 41 directly, and o 21 is proved to be concurrent with o 41 link from o 41 to o 11 is added into DCG. No more history op-eration is found that could be added into candidates .Thus the status of candidate becomes empty at the end of the third round of checking.

The execution of Concurrent Separation ( o 41 ) is completed. effect of Concurrent Separation ( o 41 ), the status of DCH and DCG is adjusted as illustrated in Figure 3.

By and large, we have described our concurrent separation algorithm in full detail. Notice that whenever a new local op-eration is generated, the oper ations in DCH exactly contains the operations it causally depends on directly. Thus, we can build direct casual vector based timestamp for a newly gen-erated local operation directly from the content of DCH. Furthermore, after each execution of a local operation o l the data structures DCH and DCG must be immediately adjusted. A new node should be added into DCG corre-sponding to operation o l . A link from o l to each operations currently in DCH operation set should be added into DCG. And finally the status of DCH operation set should be ad-justed to { o l } .
In this subsection, we will focus on the third causality detection issue: determining the causal relationship between two arbitrary operations in the operation history. Figure 3: Illustration of the new concurrent separa-tion method  X  after the execution of o 41 .
 An operation history is an uninterrupted operation set. According to Theorem 1, the causal relationship between two arbitrary operations in the operation history can be de-termined exactly by tracing its direct causal relationships. However, it has low efficiency. In worst case, it should tra-verse all the history operations in operation history. Our solution is based on the following observations.
Every time before executing a remote operation o r ,allthe earlier executed operations t hat are concurrent with it are separated out in set c o r in advance (refer to chapter 4.2). If this result is cached, things will become much easier: given two operations o a and o b in the operation history, suppose o was executed earlier than o b , to determine their causal rela-tionship, we just need to check whether o a belongs to set o a is concurrent with o b if it belongs to set c o b .Otherwise,it must be causally preceding o b .

The number of operations that an operation is concurrent with could be very large. Accordingly, the size of set c could also be very large. Fortunately, we do not need to keep in cache for each history operation a full version of set c .Given an arbitrary history operation o , suppose o a and o b are two operations in set c o , and suppose o a and o b are generated at the same site, o a is generated earlier than o b . Consider what happens if we remove o b from set c before putting it in cache. When determining the causal relationship between o b and o , we can first confirm that either o b o or o b  X  o ,for o b synchronized earlier than o ; noticing that o a is contained in cached set c o , we can further conclude o a o ;nowconsider o and o b are coming from the same cooperating site, o a  X  o it should not be difficult to find that o b o . To sum up, the causal relationship between o b and o can still be efficiently and exactly determined. In general, if there are several op-erations in set c o that come from the same cooperating site, we can safely remove all but the earliest generated one of them before caching it.
 Following is a formal description of our solution. Here, SITE(o) represents the identifier of the site at which oper-ation o was generated. GEN SEQ(o) represents the gener-ation sequence number of o at SITE ( o ). E SEQ(o) repre-sents the execution sequence number of o at current coop-erating site.
 Algorithm 2 Build Cache( set c o r ): cache c o r 1: cache c o r  X   X  2: for all o h in set c o r do 3: if cache c o r [ SITE ( o h )] is undef ined then 4: cache c o r [ SITE ( o h )]  X  GEN SEQ ( o h ) 5: end if 6: if cache c o r [ SITE ( o h )] &gt;GEN SEQ ( o h ) then 7: cache c o r [ SITE ( o h )]  X  GEN SEQ ( o h ) 8: end if 9: end for 10: return cache c o r
After procedure Concurrent Separation has been success-fully executed, its result set c will be passed along to proce-dure Build Cache . The procedure Build Cache will remove redundancy from set c and return a condensed version of it cache c for cache use. cache c is an associative vector indexed by cooperating site identifier. Build Cache will create an item in cache c for a cooperating site s (an item with site s  X  X  identifier as the key) when it find in set c an operation that was generated at s (line 3-5). Given a cooperating site s , cache c [ s ] records the generation sequence number of the earliest generated one of the operations in set c that are gen-erated at s (line 6-8).
 Algorithm 3 Detect Causality( o x ,o y ) 1: if E SEQ ( o x ) &lt;E SEQ ( o y ) then 2: if o y is local operation then 3: return o x  X  o y 4: else 5: if cache c o y [ SITE ( o x )] is undef ined or 6: return o x  X  o y 7: else 8: return o x o y 9: end if 10: end if 11: else 12: if o x is local operation then 13: return o y  X  o x 14: else 15: if cache c o x [ SITE ( o y )] is undef ined or 16: return o y  X  o x 17: else 18: return o y o x 19: end if 20: end if 21: end if
To determine the causal relationship between two history operations o x and o y , in procedure Detect Causality ,wefirst determine the synchronization order of these two operations (line 1). If o x is synchronized before o y ,asanexample, there must be o x o y or o x  X  o y .If o y is a local operation, it is out of question that o x must be causally preceding o (line 2-3). Otherwise, we check o y  X  X  related causality cache data cache c o y to see whether there is some operation that is generated at the same site of o x earlier than o x and is concurrent with o y (line 5). If there is, it must hold that o x o y (line 8), otherwise, o x  X  o y (line 6).
As an illustration, still consider the scenario in Figure 1. Continue with previous analysis: suppose a new remote received at site 3 shortly after the execution of o 22 on that site.

Before o 41  X  X  execution, procedure Concurrent Separation is first invoked to select all the history operations that are concurrent with o 41 from operation history. In the previ-ous subsection, we have analyzed the execution process of Concurrent Separation( o 41 ) and concluded that three oper-ations o 22 , o 12 and o 21 will be returned as the result. Later, the result operation set is passed to procedure Build Cache . Build Cache scans the three operations o 22 , o 12 and o 21 order. The variable cache c o 41 is first initialized with empty set. After o 22 has been scanned, according to line 4 in the procedure, this variable cache c o 41 is updated to { cache 2 } .Then o 12 is scanned and for the same reason, cache c o 41 updated to { cache c o 41 [ s 2 ]=2; cache c o 41 [ s 1 ]=1 o 21 is scanned. Because the current value of cache c o 41 [ s 7 in the procedure, the value of cache c o 41 [ s 2 ] should be up-dated to 1. The final status of cache c o 41 is { cache c 1; cache c o 41 [ s 1 ]=1 } . It is returned as a condensed version of o 41  X  X  concurrent preceding operation list for cache use. cache c o 41 is put into the causality cache after it is com-puted. Later if it is needed at site 3 to compute the causal relationship between o 41 and one of the operations o 11 , o o 21 , o 22 , o 31 and o 32 , which are all operations executed prior to o 41 at site 3, the cached value cache c o 41 can be used. Con-sider the causality detection between o 41 and o 31 .Because cache c o 41 [ s 3 ] = 0, according to the previous analysis, we can ascertain that o 31  X  o 41 . Again consider the causality detec-tion between o 41 and o 22 . Because the value of cache c is 1, which is smaller than the generation sequence number of o 22 at site 2, we can safely deduce that o 22 || o 41 easy to see that, with causality cache, the causal relation-ship between two arbitrary hist ory operations in operation history can always be determined within a constant time.
In this section, we will analyze some important features of our approach. We will prove that our approach can be well adapted to wiki like large-scale dynamic collaboration environments.

We first consider the timestamp size. Direct causal vector timestamp is a kind of dynamically sized timestamp. It is not pre-allocated for each potential participants an item in the direct causal vector timestamp, so collaboration partic-ipants will not contribute to the size of direct causal vector timestamps until she/he begins editing the shared object. Thus, in our approach, it should work well in large-scale open collaboration environments.

A most critical feature of our approach is that, after a participant stops editing the shared object, she/he will also automatically and gradually stop contributing to the size of direct causal vector timestamps. Refer to Figure 4 as an illustration. There are totally three cooperating site 1, 2 and 3. After site 1 begins to edit the shared object, it begins to affect the cost of direct causal vector timestamp in the real-time group editor system. o 22 is an operation that is generated after site 1 has begun editing the shared object. Its direct causal vector timestamp is [(1 , 1) , (2 , 1)]. There is a timestamp item (1 , 1) corresponding to site 1. After site Figure 4: Direct causal vector approach and dy-namic collaboration environment. 1 has stopped editing for an enough long time, at T 2, when the operation o 22 , which is causally dependent on o 11 ,has been propagated to and synchronized on all the cooperating sites, it can be proved that none of the operations generated afterwards have a timestamp item corresponding to site 1 in their direct causal vector timestamp. This will hold until site 1 is again active editing the shared object. It could be seen in Figure 4 that, in the direct causal vector timestamps of o 23 and o 32 , which are operations generated at site 2 and site 3 respectively after time T 2, there is no timestamp item related with site 1.

It is not difficult to conclude that the size of the direct causal vector timestamp of an operation o approximates the number of participants active at editing the shared object recently before the generation of operation o .

Now we turn to the complexity of our algorithms. As-sume that the number of participants concurrently editing the shared object never exceed L .

Our approach requires that four special data structures be kept at each cooperating site: DCH, DCG, LF mapping and causality cache. The size of DCH is never larger than L ;the storage complex of DCG is O ( nL ); the storage complexity of LF mapping is O ( n ); the storage complexity of causality cache is O ( nL ), where n represents the size of the operation history. To sum up, the average storage cost of our approach (total storage cost/size of HB) is O ( h ).

Our algorithms can detect for a remote operation whether it has become causally ready in O ( L ) time. The time com-plexity of algorithm Concurrent Separation is O ( h + L 2 where h is the number of history operations concurrent with the input remote operation. With the help of causality cache, algorithm Detect Causality can detect the causal re-lationship between two arbit rary history operation in O (1) time.

It is obvious that the complexity of our approach is not correlative with the total number of collaboration partici-pants. Our approach can work well in collaboration envi-ronments of any scale, as long as the concurrency degree is not too high, which means that it never happens that a huge number of people edit the shared object concurrently at a same time. As to our experience, in existing wikis, it rarely happens that more than ten people concurrently edit the same wiki page. Take Wikipedia as an example. Accord-ing to the statistics from wikipedia web site [27], it seldom happens that a normal wikipedia page is edited more than ten times within less than an hour. Thus, our approach should be able to work efficiently in wiki collaboration envi-ronments.

We have notice that by carefully controlling the synchro-nize order of remote operations at each collaborating sites, the size of direct causal vector timestamp can be kept small even in a highly concurrent environment. This indicates the possibility of adapting our current direct causal vector approach to collaboration environments with much higher concurrency. Due to space limitation, we will not discuss it further. It should be part of our future work.

Notice that, unlike other solutions, as are discussed in the next section, our approach does not place any constraint on the network reliability, the network performance, the net-work topology or the mode in which people collaborating with each other.
Various methods have been proposed to compress the size of vector clocks. On one extreme, methods have been pro-posed in [14, 20] to reduce the timestamp data to a single integer, but this comes at the cost of an increased compu-tational overhead for the calculation of the vector clocks assigned to events, which is so large that it will slow down the distributed computation in an unacceptable way. There-fore, these methods are mainly applicable for a trace-based off-line analysis of the causality relation.

Other methods have been proposed to dynamically com-press the size of vector clock[11, 16]. These method are all based on the following observation: even though the num-berofprocessesislarge,onlyafewofthemwillinteract with each other frequently by passing messages. In Singhal-Kshemkalyani X  X  technique[16], vector clock compression is achieved by carrying in each message only those entries of the vector clock that have been updated after the previ-ous communication between any pair of process. Ratner et al.[11] employs another method: for each entry of the vector clock, it tries to achieve consensus on a value to be sub-tracted and an entry will be removed once it is subtracted to 0. The main problem with these methods is that the size of the message timestamps is still linear in N (the number of communicating processes) in the worst case, as long as the collaboration is active enough. Furthermore, the Singhal-Kshemkalyani technique requires that communication chan-nels be FIFO, while Ratner et al. X  X  method is only adapted to a well connected network.

The method proposed in [21] requires that the communi-cation links between processes be static and known ahead of time. It is impossible in a large-scale collaborative environ-ment.

Sun and Cai proposed an OT based method[6]. It is en-forced that every operation generated at a certain cooper-ating site should be sent to the central site, transformed there against all the previously arrived concurrent opera-tions, even if there exist some conflicts, and propagated to other cooperating sites in its transformed form, rather than original form. Thus, the method that can be applied to han-dle conflict operations is constrained. The MVSD method proposed in [12] no longer applies. This method also suffers from single-point failure. Cooperating sites can not cooper-ate with each other if the central site is not accessible even if they themselves are well connected. Moreover, with this method, it is difficult to provide good performance for all the cooperating sites.

There also exist some OT algorithms that do not use the vector clock[10, 13, 19]. In NICE[13], a central site is em-ployed to ensure that every operation propagated to a co-operating site i has been transformed against all the con-current operations i received before. It suffers from similar deficiencies as the method proposed by Sun and Cai[6]. Both SOCK4[19] and TIBOT[10] use a scalar clock. In SOCK4, every operation is assigned a continuous serial num-ber that is obtained from a global sequencer. It is required that a local operation should not be broadcast until all the operations with lower serial number have been transformed against it. In TIBOT, every site maintains a linear logi-cal clock. All clocks are initialized to a common value and take the same sequence of values. The period between two consecutive clock ticks is defined as a time interval. It is required that a local operation should not be broadcast un-til all the operations generated in earlier time intervals have been transformed against it. Due to these constrains, in both SOCK4 and TIBOT, collaboration will be suspended even if only one of the clients is disconnected. Thus, neither of them can be used in large-scale collaborative environments based on Internet like unreliable network like wiki. The collabora-tion mode is also constrained. The collaboration provided by SOCK4 and TIBOT cannot be partial, that is either all sites collaborate or each one works separately.
In this paper we propose a new approach for capturing causality in real-time group editors. Our approach is based on a new kind of logical clock called DCV. Compared with other approach, it is easier to adapt to wiki like large-scale, highly dynamic, and unreliable collaboration environments.
Our approach enables the support of real-time group edit-ing in wiki like applications, which should be beneficial for such category of applications to better support users X  collab-oration activities. Supporting large-scale collaborations over a wide-area network can help to gain more usage and visi-bility for Computer-supported Cooperative Work (CSCW).
Our approach currently do not support collaboration en-vironments with high concurrency. We have seen the possi-bility of adapting it to support such collaboration environ-ments. It should be one of our future work to delve into it in more detail. There exist a lot of real-time group editor related technologies that could help people better collabo-rate with each other, such as telepointer, radar view and etc. How to apply these technologies to wiki like applica-tions? What are the effects? These should also be part of our future work. [1] A. Kittur, B. Suh, B. A. Pendleton, and E. H. Chi. [2] C. A. Ellis and S. J. Gibbs. Concurrency control in [3] C. Gutwin and S. Greenberg. The importance of [4] C.M.HymesandG.M.Olson.Unblocking [5] C. Sun and C. Ellis. Operational transformation in [6] C. Sun and W. Cai. Capturing causality by [7] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen. [8] D.LiandR.Li.Preservin g operation effects relation [9] D. Li and R. Li. A landmarkbased transformation [10] D. Li, R. Li, and C. Sun. A time interval based [11] D. Ratner, P. Reiher, and G. Popek. Dynamic [12] D. Sun, S. Xia, C. Sun, and D. Chen. Operational [13] H. Shen and C. Sun. Flexible notification for [14] J. Fowler and W. Zwaenepoel. Causal distributed [15] L. Lamport. Time, clocks, and the ordering of [16] M. Singhal and A. Kshemkalyani. An efficient [17] M. Suleiman, M. Cart, and J. Ferrie. Serialization of [18] N. Gu, J. Yang, and Q. Zhang. Consistency [19] N. Vidot, M. Cart, J. Ferrie, and M. Suleiman. [20] R. Schwarz and F. Mattern. Detecting causal [21] S. Meldal, S. Sankar, and J. Vera. Exploring locality [22] T. Prante and C.Magerkurth. Developping cscw tools [23] StrategyWiki. [24] WikiNews. http://en.wikinews.org/. [25] Wikipedia. What Is Wiki? [26] Wikipedia. http://en.wikipedia.org/. [27] wikistat. [28] WikiTravel. http://wikitravel.org/en/Main Page.
