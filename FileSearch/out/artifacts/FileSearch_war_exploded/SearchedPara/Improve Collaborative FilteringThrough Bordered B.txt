 Collaborative Filtering-based recommendation algorithms have achieved widespread success on the Web, but little work has been performed to investigate appropriate user-item rela-tionship structures of rating matrices. This paper presents anovelandgeneralcollaborativefilteringframeworkbased on (Approximate) Bordered Block Diagonal Form structure of user-item rating matrices. We show formally that matri-ces in (A)BBDF structures correspond to community detec-tion on the corresponding bipartite graphs, and they reveal relationships among users and items intuitionally in recom-mendation tasks. By this framework, general and special interests of a user are distinguished, which helps to improve prediction accuracy in collaborative filtering tasks. Exper-imental results on four real-world datasets, including the Yahoo! Music dataset, which is currently the largest, show that the proposed framework helps many traditional collab-orative filtering algorithms, such as User-based, Item-based, SVD and NMF approaches, to make more accurate rating predictions. Moreover, by leveraging smaller and denser sub-matrices to make predictions, this framework contributes to the scalability of recommender systems.
 H.3.3 [ Information Storage and Retrieval ]: Information Filtering; H.3.5 [ Online Information Services ]: Web-based services Collaborative Filtering; Community Detection; Block Diag-onal Form; Graph Partitioning
Recommender Systems play an important role on the Web which is becoming more and more personalized. With their ability to discover various items of potential interest to users, recommender systems benefit users by saving time when the users are looking for what they want, and they benefit online shops that seek to expand their marketing e ff orts.
Collaborative Filtering (CF) [22] recommendation algo-rithms based on user-item rating matrices have achieved great success in recommender systems. Typically, they take aratingmatrix(Figure1(a))asinputtomakeratingpredic-tions, where each row/column/cross represents a user/item/ rating. An important advantage of CF-based algorithms is their ability to make recommendations without clear con-tent descriptions of the items, which is the reason why they are widely applied in recommender systems thus far [22].
However, CF-based recommendation algorithms also suf-fer from several drawbacks. First is the data sparsity prob-lem, which usually decreases the accuracy of the rating pre-dictions. Second is the problem of scalability, which is usu-ally caused by the presence of computationally expensive training components. Finally, the lack of distinguishing users and items from di ff erent communities, which makes them incapable of detecting users X  special interests and de-creases their abilities to make long tail recommendations.
Some previous research has been performed attempting to address these problems, which mainly focus on various matrix-clustering [11, 26, 27, 39, 34] or community detection [6, 36, 23] techniques. Clustering-based approaches cluster users and/or items for CF. However, in real-world applica-tions, clusters are usually di ffi cult to interpret. Moreover, they usually assume that a user or an item should fall into one particular cluster, which might not be a reasonable as-sumption in reality. Community detection approaches based on user-item bipartite graphs attempt to improve accuracy and diversity by detecting user-item communities. Distin-guishing the general and special interests of a given user helps to make better recommendations, but it is di ffi cult for them to take advantage of various successful CF techniques on rating matrices in real-world recommender systems.
In fact, rating matrices and bipartite graphs can be equiv-alently transformed into each other. Before problem for-malization, we would like to use an intuitional example to introduce the matrix structures that are leveraged in this framework. Figure 1(a) shows a rating matrix, and its corre-sponding bipartite graph is shown in Figure 1(d), where each row/column/non-zero of the matrix is represented as an R-node/C-node/Edge in the graph. Figure 1(b) is a Bordered Block Diagonal Form (BBDF) structure of the original ma-trix, where Row4, Row9 and Column7 are permuted to  X  X or-ders X , and the remaining parts are thus permuted into two  X  X iagonal blocks X . The permuting procedure is conducted recursively on the first diagonal block. The Approximate Bordered Block Diagonal Form (ABBDF) structure is a gen-eralization of BBDF where scattered non-zeros are allowed in o ff -diagonal blank areas, as shown in Figure 1(c).
It is important to note that the ABBDF structure of rat-ing matrices is capable of representing community detection results on the corresponding bipartite graphs. In Figure 1(f), for example, each community in the graph corresponds to a diagonal block in Figure 1(c); nodes out of communi-ties constitute borders, and dotted inter-community edges correspond to the non-zeros in o ff -diagonal blank areas. In this sense, BBDF structure is a special case of ABBDF when the community detection result contains no inter-community edge, as shown by the example in Figure 1(e) and 1(b).
The CF framework based on (A)BBDF structures of rat-ing matrices proposed in this paper is capable of combining the advantages of community detection and matrix cluster-ing techniques as well as making use of various CF algo-rithms. An important advantage of this framework is that it does not rely on a specific CF algorithm. Any CF algo-rithm that is based on rating matrices can be integrated into this framework, such as User-based, Item-based, SVD and NMF. Experimental results show that this framework helps these CF algorithms to improve the prediction accuracy and, at the same time, benefits system scalability.

In summary, the contributions of the paper are four-fold:
In the remaining part of this paper, section 2 reviews some related work, and section 3 introduces some definitions and theorems. Section 4 presents the proposed algorithms and framework. Experimental settings and results are shown in section 5. In section 6, we present a discussion, and section 7 concludes the work and provides future directions.
Collaborative Filtering (CF) [22, 2] algorithms based on user-item rating matrices focus on the core task of making rating predictions. They attempt to discover and leverage the knowledge of users X  preferences when making recommen-dations. Unlike Content-Based Filtering (CBF) [28], which makes recommendations by analyzing the item features of a user X  X  historical items, CF algorithms take advantage of the wisdom of crowds, and they usually have no special require-ments on items or domains.

One of the most widely used forms of CF is the nearest neighbor approach [22]. User-based [29] and Item-based [31] CF algorithms are two best-known methods that fall into this category. Nearest neighbors can be determined by var-ious similarity measures, such as Pearson correlation and cosine similarity. User-based CF attempts to find the neigh-borhood of like-minded users for each user and predicts a user X  X  ratings according to the ratings given by the user X  X  neighbors. Similarly, Item-based CF takes advantage of the similar items of each item, and predictions for a user are de-termined by the user X  X  historical ratings. Nearest neighbor approaches are usually unable to detect item synonymies and are also computationally expensive in real-world recom-mender systems.

The Matrix Factorization (MF) [16] approaches attempt to factorize a rating matrix into products of real-valued com-ponent matrices. A reconstruction error objective function is usually defined, and gradient descent optimization proce-dures are usually conducted [25]. SVD [33, 37] and NMF [17, 40, 19] methods are typical algorithms that are investigated. However, computationally intensive training components of these techniques make them not scalable enough and imprac-tical to conduct frequent model re-training. Incremental and distributed versions of SVD and NMF algorithms [4, 37, 32, 21, 10] partially alleviate this problem, but they are still not e ffi cient enough because the e ff ects of small updates to the rating matrix are not localized.

Various matrix clustering techniques have been investi-gated in an attempt to address the problems of e ffi ciency, scalability and sparsity. User clustering and item clustering methods [26] cluster user or item vectors first, and nearest neighbors of a user or item are restricted to its cluster. Some other matrix clustering techniques, such as co-clustering [7, 18, 11], ping-pang algorithm [27] and clustered low-rank ap-proximation [35], cluster users and items at the same time, and the procedure of rating prediction takes advantage of these user-item clusters. By utilizing clusters, the scalabil-ity of recommender systems is usually improved, but clus-ters are usually di ffi cult to interpret. In addition, these approaches usually force a user or item to fall into a sin-gle cluster, which might not be a reasonable assumption in real-world applications.

Recently, community detection techniques based on graphs have been investigated extensively with the rapid growth of social networks [20, 24, 23, 6], which helps to improve both the accuracy and diversity of the recommender systems by extracting user or item communities.

In fact, user-item rating matrices can be equivalently trans-formed into bipartite graphs [1, 3], and community detec-tion results on the bipartite graphs can be represented as (A)BBDF structures on the corresponding rating matrices. Any CF method can still be applied to the permuted ma-trix without any modification, but by leveraging user-item community information therein, more accurate and specific recommendations can be made.
Several definitions and theorems are presented in this sec-tion, which will be the basis of the (A)BBDF permutation algorithms and the collaborative filtering framework to be proposed in Section 4.
 Definition 1. Bordered Block Diagonal Form (BBDF). Matrix A is in Bordered Block Diagonal Form if:
Namely, A ij = 0 ( i ! = j, 1  X  i, j  X  k ) .Each D i (1  X  i  X  k ) is a  X  X iagonal block X ; R =[ R 1  X  X  X  R k B ] and C = [ C 1  X  X  X  C T k B T ] T are  X  X orders X . Recursively, each of the diag-onal blocks D i can also be in the BBDF structure. !
BBDF structure is a generalization of Block Diagonal Form (BDF) matrices, for example, A =diag( D 1 D 2  X  X  X  D k ), where the latter has no border.

Definition 2. Approximate Bordered Block Diag-onal Form (ABBDF). Matrix A is in Approximate Bor-dered Block Diagonal Form if: (a) Communities (b) Middle result (c) ABBDF Figure 2: Community detection and ABBDF, k = 2
Namely, A ij ( i ! = j, 1  X  i, j  X  k ) can also contain scattered non-zeros compared with the BBDF structure. D 1 D 2  X  X  X  D might also be in the ABBDF structure. !
ABBDF is a generalization of BBDF in that scattered non-zeros are allowed in o ff -diagonal blank areas. We also refer to BBDF as Accurate BBDF to distinguish it from Approximate BBDF.
 Definition 3. Community Detection. Given a graph G =( V , E ) ,acommunityin G is a set of vertices C i  X  V , and a community detection with k ( k  X  1) communities is C = {C 1 C 2  X  X  X C k } ,witchsatisfiesthefollowing: ii. C i  X 
The second requirement means that each community con-tains at least one monopolized node. It X  X  important to clarify that no definition of community detection is universally ac-cepted until now because definitions often depend on a spe-cific application and algorithm [9]. This definition is solely for introducing the relationships between the (A)BBDF struc-ture and community detection in this paper. Even so, Def-inition 3 is general enough to describe the output of many frequently used community detection algorithms, including both independent and overlapping communities, depending on C i  X 
Theorem 1. Any community detection result with k com-munities C = {C 1 C 2  X  X  X C k } on a bipartite graph G =( V , E ) can be represented as an ABBDF structure with k diagonal blocks on its corresponding rating matrix A .

Proof. Without loss of generality, we assume that V ,inotherwords,thateachnodebelongstoatleastone community. Otherwise, we permute the nodes in V  X  to the borders first. We will make a proof by induction.
If k =1,thenthepropertyholdsnaturally,andthematrix is viewed as a single diagonal block.

If k =2,thenpermutethenodesin S = C 1  X  C 2 to borders, followed by permuting the nodes in C " 1 = C 1  X  S and C " C  X  S to construct two diagonal blocks, shown in Figure 2.
Suppose that the property holds for k = n  X  1. When k = n ,asshowninFigure3,let S 1 = C 1  X  C = C i  X  S 1 (1  X  i  X  n ). Note that C " i ! =  X  (1  X  i  X  n ), Figure 3: Community detection and ABBDF, k = n according to Definition 3. Permute the vertices in S 1 to the borders, permute C " 1 to the upper-left corner and permute " tive assumption, structure with n  X  1diagonalblocksinthesamemanner. As a result, the final matrix is an ABBDF structure with n diagonal blocks, and the final border is S =
It is helpful to look at the case of k =3,asshowninFigure 4. First, let S 1 = C 1  X  ( C 2  X  C 3 )and C " i = C i  X  S Permute S 1 to the borders, and there will be two diagonal blocks in the matrix, corresponding to vertex sets C " 1 and C  X  C " 3 .Moreover,let S 2 = C " 2  X  C " 3 and C "" i = C " 2 , 3). By recursively permuting S 2 to the borders, one of the diagonal blocks is again permuted into an ABBDF structure, which gives us two new diagonal blocks that correspond to C 2 and C "" 3 .Thefinalnumberofdiagonalblocksis3,and the border is S = S 1  X  S 2 .

Corollary 1. Given a community detection result C = {C 1 C 2  X  X  X C k } on a bipartite graph, let S i = C i  X  and C " i = C i  X  S i for each 1  X  i  X  k .Then, C corresponds to an Accurate BBDF structure if and only if there is no edge from C " i to C " j when i ! = j .

Proof. The result follows from the fact that a non-zero in the o ff -diagonal blank areas in an ABBDF structure cor-responds to an edge that connects two nodes, u and v ,from two communities, C ( u )and C ( v ), where u and v are monop-olized by C ( u )and C ( v ), correspondingly.

Intuitionally, a diagonal block in an (A)BBDF matrix is a  X  X ser-item community X , with its users and items being its  X  X ominant X  users and items. The borders can be viewed as  X  X uper X  users and items among communities. Super users are users whose tastes are relatively broad and fall into di ff erent communities. Super items are items favored by users from di ff erent communities. Users might indeed focus their main attentions on certain fields, but they do step into other fields occasionally, which is important when detecting the poten-tial interests of a user. In this sense, an Approximate BBDF structure is more natural than an Accurate BBDF structure.
The following definitions and theorems concern how to permute a sparse rating matrix into accurate and approxi-mate BBDF structures.

Definition 4. Graph Partitioning by Vertex Sepa-rator (GPVS)-based Community Detection.

Consider an undirected graph G =( V , E ) . Adj ( v ) denotes the set of vertices adjacent to v .Foravertexsubset V "  X  V , Adj ( V " )= { v j  X  V  X  V " :  X  v i  X  V " s.t. v j  X  Adj ( v V S  X  V is a vertex separator if the subgraph induced by V  X  V S has k  X  2 connected components. Formally, GPVS is defined as  X  v = {V 1 V 2  X  X  X V k ; V S } ,where V i ! =  X  , V Figure 4: Community detection and ABBDF, k = 3 Adj ( V i )  X  V S for 1  X  i  X  k , V i  X  V j =  X  for 1  X  i&lt;j  X  k , and ( C = {C 1 C 2  X  X  X C k } is the community detection result, where C = V i  X  V S (1  X  i  X  k ) . !
Intuitively in GPVS, the removal of a vertex separator splits the graph into k connected components. GPVS is a type of community detection algorithm that corresponds to accurate BBDF structures. This conclusion can be derived directly from Corollary 1 and Definition 4 because S i = C $ " k when i ! = j .

The reader can refer to Figure 1(b) and 1(e) for an ex-ample. By first removing nodes R 4 R 9 and C 7 which are represented by shaded borders, the remaining nodes are par-titioned into two parts, corresponding to the two main diag-onal blocks in the rating matrix. Furthermore, by removing nodes R 3 C 2 and C 9 ,oneofthediagonalblocksisagainper-muted into the BBDF structure with two diagonal blocks.
Definition 5. Graph Partitioning by Edge Separa-tor (GPES)-based Community Detection.
 Consider the undirected graph G =( V , E ) .

E S  X  E is an edge separator if the removal of E S  X  e = {V 1 V 2  X  X  X V k } ( k  X  2) ,where V i ! =  X  for 1  X  i  X  k , V  X  V j =  X  for 1  X  i&lt;j  X  k , subgraphs induced by V i and V j are disconnected for i ! = j . C = {C 1 C 2  X  X  X C k } is the community detection result, where C = V i (1  X  i  X  k ) . !
GPES-based community detection corresponds to an ABBDF structure with no border because S i = C i  X   X  .ThisstructurecanbeusedtofurtherconstructanABBDF structure with borders when necessary, which will be pre-sented by the algorithms in the following sections.
Definition 6. Density. Let A be an m  X  n ( m, n  X  1) matrix, let n( A ) be the number of non-zeros in A ,andlet area( A )= m  X  n be the area of A .

The density of A is  X  ( A )= n( A ) area( A ) ,andtheaverageden-sity of k matrices A 1  X  X  X  A k is  X   X  ( A 1  X  X  X  A k )= Let G denote the bipartite graph of A ;then,  X  ( G )=  X  ( A ) ,  X   X  ( G 1  X  X  X G k )=  X   X  ( A 1  X  X  X  A k ) .
 Aroworacolumnofmatrix A is referred to as a  X  X ine X . The density of line l restricted to a block B is  X  ( l ( B )) ,where l ( B ) denotes the sub-vector on line l that is restricted to block B, shown as the red dashed rectangles in Figure 5(b) . !
The density of graphs or matrices has been widely used in various community detection algorithms and tasks [9]. Taking Figure 5 as an example, the density of the shaded block is 9 25 in Figure 5(a). In Figure 5(b), the density of column 5 is 5 9 ,andthedensityofrow8restrictedtothe shaded block is 2 5 .
In accurate BBDF permutation, a basic procedure is per-formed recursively, which is to permute some lines to borders and to permute the remaining part to construct several diag-onal blocks. This recursive framework is known as George X  X  nested dissection approach [3, 14], which has been widely used in fill-reducing ordering of sparse matrices. This basic procedure is investigated in this subsection, and the accu-rate BBDF permutation algorithm in the following subsec-tion leverages this procedure.

The basic step is equivalent to GPVS [1] on the corre-sponding user-item bipartite graph, which has been shown in preliminaries. It is typical that a graph has more than one vertex separator, and a proper GPVS algorithm attempts to find the one with the least number of vertices, namely, the minimum vertex separator .Unfortunately,theminimum vertex cut problem is known to be NP-hard [5], but this problem has been investigated extensively, and many e ffi -cient and high-quality heuristic-based methods have been proposed [15], such as the multilevel approach, spectral par-titioning and kernel-based methods. It has been verified both theoretically and experimentally that multilevel ap-proaches usually provides both fast execution time and very high quality partitions [15, 30, 1, 3]. Perhaps the most widely known and used package for graph partitioning is Metis by Karypis [13], which is based on a multilevel ap-proach, and we chose the core multilevel graph partitioning routine implemented in Metis as the basic GPVS algorithm.
In this study, we utilize the density of user-item communi-ties to control the procedure of BBDF permutation because dense subgraphs are usually interpreted as actual commu-nities. This approach has been widely used in community detection tasks [9]. Algorithm 1 shows the basic procedure. Algorithm 1 Basic-BBDF-Permutation( A, G ) Require: Ensure: 1:  X  v  X  {V 1 V 2  X  X  X V k ; V S }  X  GPVS( G ) 2: Permute rows of A in order of R 1 R 2  X  X  X R k R S 3: Permute columns of A in order of C 1 C 2  X  X  X C k C S 4: return  X   X  ( D 1 D 2  X  X  X  D k ) ! D i denotes the i -th diagonal
We expect the average density of diagonal blocks to be improved compared with the density of the original matrix A after permutation; we discuss the relevant issues here.
Taking the notations in Definition 6, we have:
Let n =n( A ) ,n 1 = s =  X  A =  X  ( A )= n where  X  2 represents the average density of o ff -diagonal  X  &gt;  X  A ;then,wehave:
This statement means that the average density of the re-sulting diagonal blocks will increase if and only if it is greater than the average density of the remaining parts. This rela-tionship is usually satisfied because the GPVS algorithm attempts to find a separator with the minimum number of vertices. Furthermore, the total area of o ff -diagonal blocks plus borders tends to be much larger than the area of the diagonal blocks [1]. For this reason, we choose the average density to be an important controller in the algorithm.
The density-based BBDF permutation algorithm requires aparameter  X  as an input, which is a pre-defined require-ment on the minimum average density of diagonal blocks. It conducts Basic-BBDF-Permutation on a matrix and re-curses on each of the resulting diagonal blocks until the den-sity of a diagonal block has reached the density requirement  X  or the Basic-BBDF-Permutation cannot improve the av-erage density any more. Algorithm 2 shows the procedure. Algorithm 2 BBDF-Permutation( A, G ,  X  ) Require: Ensure: 1:  X  A  X   X  ( A ) 2: if  X  A &lt;  X  then ! else do nothing 3:  X   X   X  Basic-BBDF-Permutation( A, G ) 4: if  X   X  &gt;  X  A then ! else do nothing 5: for each diagonal block D i in A do 6: BBDF-Permutation( D i , G V i ,  X  ) ! V i denotes 7: end for 8: end if 9: end if
Note that, in the 4-th line, we do nothing if the aver-age density of the resulting diagonal blocks is not improved compared with the original matrix, although some diagonals might not have reached the density requirement  X  .Sucha diagonal D is viewed as a sparse user-item community, and such a case occurs when the density requirement  X  is set too high. An important reason for using the average density to prevent such diagonals from recursion is that they would result in many small scattered communities with only a few users and items. Proper density requirements give better BBDF structures, and this issue will be discussed with the experimentation below.
Approximate BBDF can be achieved by GPES, and we also make use of the multilevel graph partitioning approach that is implemented in Metis. The ABBDF permutation algorithm also has a density requirement of  X  ,asinput. It computes a GPES on the bipartite graph of a rating matrix A ,andbyignoringthenon-zeroscorrespondingtotheedge separator, matrix A is permuted to several diagonal blocks.
Unlike an accurate BBDF permutation, which accomplishes nothing if the average density is not improved after the per-mutation, the approximate BBDF permutation algorithm moves lines from diagonal blocks to borders to further im-prove their average density, unless the average density is greater than the original matrix. Note that this goal can al-ways be reached because the density of a single non-zero is one. This procedure is performed recursively in each diago-nal block until the density requirement is reached, as shown in Algorithm 3.
 Algorithm 3 ABBDF-Permutation( A, G ,  X  ) Require: Ensure: 1: if  X  ( A )  X   X  then 2: return 3: else 4:  X  e  X  {V 1 V 2  X  X  X V k }  X  GPES( G ) 5: Permute rows of A in order of R 1 R 2  X  X  X R k 6: Permute columns of A in order of C 1 C 2  X  X  X C k 7: {V " 1 V " 2  X  X  X V " k ; V " S }  X  Improve-Density( A, G ,  X  8: for each diagonal block D i in A do 9: ABBDF-Permutation( D i , G V ! 10: end for 11: end if
The sub-procedure Improve-Density selects the specific line whose removal improves the average density the most from the diagonal blocks at each time and inserts it into the borders. This process is shown in Algorithm 4.
 Algorithm 4 Improve-Density( A, G ,  X  e ) Require: Ensure: 1: {V " 1 V " 2  X  X  X V " k ; V " S }  X  {V 1 V 2  X  X  X V k ;  X  } 2: while  X   X  ( D 1 D 2  X  X  X  D k ) &lt;  X  ( A ) do 3: l " ,i "  X  0 ,  X   X  "  X  0 4: for each diagonal block D i do 5: for each line l in D i do 6:  X   X   X  7: if  X   X  &gt;  X   X  " then 8: l "  X  l, i "  X  i,  X   X  "  X   X   X  9: end if 10: end for 11: end for 12: Permute line l " to borders 14: V " S  X  V " S  X  { node( l " ) } ! node( l " )denotesthenodein 15: end while 16: return {V " 1 V " 2  X  X  X V " k ; V " S }
Note that, when looking for the line that improves the average density the most, there is no need to check all of the lines in each diagonal block in a real implementation. In each diagonal block, we only need to check the line with the minimum density restricted to it, namely the line that contains the fewest non-zeros in it.
AgreatadvantageoftheCFframeworkbasedontheac-curate or approximate BBDF structure is that any CF al-gorithm can be used on a submatrix that is made up of diagonal blocks and borders. In this paper, we do not pro-pose new CF algorithms on (A)BBDF structures but instead propose a general CF framework, which makes use of user-item communities. By utilizing the community information, the prediction accuracy tends to be improved. Furthermore, conducting collaborative filtering on smaller and denser sub-matrices contributes to the scalability of CF algorithms.
The intuitive example shown in Figure 6 will be used to introduce the framework. For each diagonal block, we re-construct its corresponding community by combining it with borders from di ff erent levels. Specifically, we use dominant users and items together with the corresponding super users and items to make predictions. In Figure 6, three submatri-ces are constructed, which correspond to the diagonal blocks A , B and C .Notethat,intheABBDFstructure,scattered non-zeros in o ff -diagonal areas are ignored because they are viewed as special interests or unprofessional ratings of users.
On each submatrix, any CF algorithm can be conducted to make rating predictions. There could be more than one prediction for user-item pairs from border crosses because they are shared by di ff erent submatrices. These predictions are averaged as the final prediction. It is a natural idea that the predictions can be averaged with di ff erent weights, but in this paper, we take only the average value. The averaging strategy could be investigated in future work. Figure 6: A toy example for extracting communities
We conducted a series of experiments on four real-world datasets: MovieLens-100K, MovieLens-1M, Dianping and Yahoo! Music to validate the e ff ectiveness of the proposed framework. Among these datasets, MovieLens-100K and MovieLens-1M are from the well-known MovieLens dataset. Besides, we also collected a year X  X  data from a famous restau-rant rating web site Dianping.com (http://www.dianping.com) in China, and selected those users who made 20 or more rat-ings. The ratings also range from 1 to 5 like the MovieLens dataset. The Yahoo Music dataset [8] is from KDD Cup 2011, and its ratings range from 1 to 100. Statistics on these four datasets are presented in Table 1.

These datasets are chosen because they have di ff erent sizes and densities. Additionally, two of them have more users than items, and the other two are the opposite. We expect to verify whether the framework works regardless of the size or density of the matrix. A significant di ff erence between Dianping and other frequently used datasets is that Dian-ping is a location-based service in which the longitude and latitude of each restaurant is recorded. By analyzing the locations of user-item communities discovered by (A)BBDF algorithms, we expect to obtain an intuitional observation of their e ff ects.
Four popular CF algorithms were experimented on using the framework. The User-based and Item-based CF algo-rithms are famous memory based approaches, while SVD and NMF are known to be famous matrix factorization ap-proaches.

User-based :ThePearsoncorrelationwasusedforuser similarities, as suggested in [29]. The neighborhood size is k =100.

Item-based :Adjustedcosinesimilaritywasusedbecause it is reported to give the best performance in [31], and k = 100 is also used for neighborhood size.

SVD :WeusethepopularSVDpredictionstrategypre-sented in [16]. Here, the number of factors k is 100, and the regularization coe ffi cient  X  is 0 . 015.

NMF :Themostcommonlyusednon-negativematrixfac-torization algorithm in [17] was used to make predictions, and we also used k =100and  X  =0 . 015.
 To make a comparison with the literature, we used the Root Mean Square Error (RMSE) to measure the predic-tion accuracy in this work. Five-fold cross validation was conducted on the MovieLens and Dianping datasets, and the average RMSE was calculated. For the Yahoo! Mu-sic dataset, we used its training set and validation set for training and evaluation, respectively.
Figure 8: #communities v.s. density requirement
The most important parameter in the density-based BBDF and ABBDF permutation algorithms is the density require-ment  X  .Lowdensityrequirementsleadtofewerandlarger user-item communities, and high density requirements re-sult in more and smaller communities, as shown in Figure 7, where  X  =0 . 005 and  X  =0 . 01 are applied to the accurate and approximate BBDF algorithms on the Dianping dataset. Note that the matrix is not as dense as it appears to be in these figures; The appearance of density arises because more than half a million points are restricted to a small canvas.
An appropriate density requirement is important. If the density requirement is too low, then the user-item communi-ties hidden in the original rating matrix cannot be extracted properly and completely. However, if the density require-ment is too high, then it will result in many small scattered communities, which could lead to over-fitting problems.
An appropriate density requirement gives reasonable and meaningful communities. See the ABBDF structure in Fig-ure 7(d), for example. Nine communities are extracted, numbered 1 through 9, from the upper-left to bottom-right corner. It is interesting to note that they represent nine main cities in China. Table 2 presents these cities and shows how high a percentage of restaurants in each community truly belong to that corresponding city.

One can find that communities 5, 6, 7 and 9 are highly re-lated to each other by the dense pseudo-blank areas marked by circles. By viewing the dense areas horizontally, we know (c) acc.BBDF Dianping (g) app.BBDF Dianping that users in one city can usually go to restaurants in an-other city, and vertically we know that restaurants in the other city can be frequently visited by users from the first city. These observations are reasonable in reality because these four cities are geographically very close to each other, as shown in Figure 10. Tra ffi c among these cities is devel-oped, and their business relationships are close. In fact, this area is exactly the famous Yangtze River Delta of China.
Figure 8 shows the relationship between the number of extracted communities and the density requirement on the four datasets, respectively. For accurate BBDF, the num-ber of communities rises first, and then tends to be stable after a certain density requirement is met because a diag-onal block will not be permuted recursively if its average density does not increase after graph partitioning. How-ever, for approximate BBDF, the number of communities increases consistently because it moves lines to borders to increase the average density in such cases. This strategy makes the algorithm more flexible but could also lead to too many small scattered communities if the density require-ment is too high. The impact of the density requirement on the prediction accuracy will be analyzed next.
Experimental results on four datasets show that the pro-posed CF framework helps existing CF algorithms to im-prove their accuracy in a large range of density requirements.
The experimental results on the RMSE versus the density requirement is shown in Figure 9. Each sub-figure presents Figure 10: Location of the four highly related cities. the performance of all of the four CF algorithms on the cor-responding dataset. Note that the beginning point of each curve represents the base performance of the CF method on the dataset, and the density requirement of this point is set to the density of the whole rating matrix. As a result, points on a curve below its beginning point mean an improvement on the prediction accuracy, and vice versa.

We must note the fact that the very large number of users and items in the Yahoo! Music dataset makes it unrealistic for current hardware to conduct memory-based CF algo-rithms. To the best of our knowledge, there is no report of direct user-based or item-based collaborative filtering on this dataset. Strategies such as KNN with SVD features [12] or parallelization [38] were attempted in KDD cup, but these strategies would make the results incomparable with other datasets. As a result, we did not perform KNN on the whole dataset. However, we found that our CF framework makes it possible to run KNN predictions on a standalone machine when the number of communities is more than 27, and experiments were performed in such cases.

Experimental results show that the proposed CF frame-work on accurate BBDF benefits user-based, SVD, and NMF algorithms consistently on all of the four datasets. However, mixed results were obtained on the item-based CF method. On MovieLens-1M, Dianping and Yahoo! Music datasets, its performance is slightly improved, but on the MovieLens-100K dataset, its accuracy rises at first and begins to drop while the density requirement continues to rise. Further-more, a negative e ff ect can even be introduced if the density requirement is too high.

This e ff ect could be the reason that the item-based algo-rithm utilizes historical ratings of a user, which is di ff erent from other CF algorithms that take advantage of neighbor-hood relationships. A user X  X  historical ratings are reduced in the BBDF framework, especially on small datasets, which introduces bad predictions. However, it still benefits from BBDF structure given reasonable density requirements.
For approximate BBDF structure, prediction accuracy im-proves at first but tends to drop when the density require-ment is too high, in almost all of the cases. The reason for the performance improvement could be that approximate BBDF plays a role in data denoising, and user-item commu-nities help to extract professional ratings. However, small scattered communities could give bad predictions because of over-fitting problems, which leads to a decrease in the performance when high density requirements are used.
Table 3 presents the best performance of each CF method on each dataset for accurate and approximate BBDF frame-works. A bold number indicates an obvious improvement, where the RMSE is reduced more than 0.02 on MovieLens and Dianping or more than 0.4 on Yahoo! Music.

When calculating the average RMSE on each dataset, five-fold cross-validation was conducted on MovieLens and Di-anPing, and experiments were conducted five times on Ya-hoo!Music. Standard deviations were  X  0 . 006 on MovieLens and DianPing and were  X  0 . 05 on Yahoo! Music.

We see that both accurate and approximate BBDF bene-fits CF algorithms in the best cases, and approximate BBDF tends to achieve better performance.
Experiments were conducted on a linux server with 8 core 3.1GHz CPU and 64GB RAM. For both accurate and ap-proximate BBDF algorithms on each dataset, we averaged the computational time consumed under di ff erent density requirements, as shown in Table 4.
 Table 4: Computational time of the BBDF and ABBDF algorithms on the four datasets.
 Experiments show that the computational time of the BBDF algorithms increases along with the scale of rating matrices, but the time used for BBDF permutation is small compared with the CF prediction algorithms. Moreover, once BBDF structures have been constructed, they help to decrease the total prediction time by conducting collabo-rative filtering on smaller submatrices, especially for user-based and item-based methods. We calculated the average speedups for each CF algorithm on each dataset, as shown in Table 5, where speedup is defined as:
T CF is the time used by a CF prediction algorithm on the whole matrix, T BBDF is the time of accurate or approximate BBDF permutation algorithms, and T BBDF CF is the time of CF prediction algorithms on (A)BBDF structures.
The experimental results show that in almost all of the cases, (A)BBDF structures speed up rating prediction; the speedup is obvious especially for nearest neighbor CF meth-ods and large datasets.
 Table 5: Speedups of conducting collaborative filter-ing based on (A)BBDF structures on four datasets.
In practical real-world recommender systems, rating ma-trices are usually changing continuously as new ratings are made by users. However, (A)BBDF structures make it pos-sible to re-predict the submatrices that are truly in need of re-prediction, for example, those whose RMSE have reached acriterion,ratherthantore-predictthewholematrix,which might further contribute to the scalability in real-world rec-ommender systems.

The cold-start problem has long been an important is-sue in the research of collaborative filtering. By inserting a new user or item into a proper community and making rec-ommendations there, the framework could benefit the cold-start recommendation. Additionally, ABBDF structure dis-tinguishes a user X  X  special interests from the general inter-ests of his or her community, which could contribute to the serendipity of the recommendations, and these issues will be investigated in future work.

Although the (A)BBDF permutation algorithms have only one tunable parameter density requirement  X  ,itcouldbedif-ficult to determine a proper  X  given a new dataset in real applications because too low or too high density require-ments might both not give the best performance, which is currently a shortcoming of the algorithms. Further work will be performed to investigate the possibility of learning proper density requirements automatically.
In this paper, we investigated the relationship between (A)BBDF structures and community detection on user-item bipartite graphs, and we proposed algorithms that, in fact, need only one intuitional parameter density requirement to permute a matrix into (A)BBDF structures. We further proposed a general collaborative filtering framework that is based on (A)BBDF structures to make rating predictions.
Experimental results show that, by utilizing user-item com-munities contained in these structures, the proposed frame-work benefits many CF algorithms improving their predic-tion accuracies, and at the same time contributes to system scalability, which means that (A)BBDF structures tend to be a general and promising framework to improve the per-formance of existing CF algorithms.
The authors thank the anonymous reviewers for their con-structive reviews and suggestions. This work was supported by Natural Science Foundation (60903107,61073071) and Na-tional High Technology Research and Development (863) Program (2011AA01A205) of China. [1] C. Aykanat, A. Pinar, and U. V. Catalyurek.
 [2] R. M. Bell and Y. Koren. Scalable Collaborative [3] E. Boman and M. Wolf. A Nested Dissection approach [4] M. Brand. Fast online SVD revisions for lightweight [5] T. N. Bui and C. Jones. Finding Good Approximate [6] J. Chen and Y. Saad. Dense Subgraph Extraction with [7] I. S. Dhillon, S. Mallela, and D. S. Modha.
 [8] G. Dror, N. Koenigstein, Y. Koren, and M. Weimer. [9] S. Fortunato. Community Detection in Graphs. [10] R. Gemulla, E. Nijkamp, P. J. Haas, and Y. Sismanis. [11] T. George and S. Merugu. A Scalable Collaborative [12] M. Jahrer and A. Toscher. Collaborative Filtering [13] G. Karypis. Metis-A Software Package for Partitioning [14] G. Karypis and V. Kumar. A Fast and High Quality [15] J. Kim, I. Hwang, Y. H. Kim, and B. R. Moon. [16] Y. Koren, R. Bell, and C. Volinsky. Matrix [17] D. D. Lee and H. S. Seung. Algorithms for [18] K. W. Leung, D. L. Lee, and W. Lee. CLR: A [19] T. Li, C. Gao, and J. Du. A NMF-based [20] W. Lin, X. Kong, P. S. Yu, Q. Wu, Y. Jia, and C. Li. [21] C. Liu, H. Yang, J. Fan, L. He, and Y. Wang. [22] J. Liu, M. Z. Q. Chen, J. Chen, F. Deng, H. Zhang, [23] F. Luo, J. Z. Wang, and E. Promislow. Exploring [24] T. Nakahara and H. Morita. Recommender System for [25] J. Noel, S. Sanner, K. Tran, P. Christen, and L. Xie. [26] M. O X  X onnor and J. Herlocker. Clustering Items for [27] S. Oyanagi, K. Kubota, and A. Nakase. Application of [28] M. J. Pazzani and D. Billsus. Content-Based [29] P. Resnick, N. Iacovou, M. Suchak, P. Bergstrom, and [30] P. Sanders and C. Schulz. Engineering Multilevel [31] B. Sarwar, G. Karypis, J. Konstan, and J. Riedl. [32] B. Sarwar, G. Karypis, J. Konstan, and J. Riedl. [33] B. M. Sarwar, G. Karypis, J. A. Konstan, and J. T. [34] B. Savas and I. S. Dhillon. Clustered Low Rank [35] B. Savas and I. S. Dhillon. Clustered Low Rank [36] F. Wang, T. Li, X. Wang, S. Zhu, and C. Ding. [37] Q. Wang, J. Xu, H. Li, and N. Craswell. Regularized [38] Y. Wu, Q. Yan, D. Bickson, et al. E ffi cient Multicore [39] B. Xu, J. Bu, and C. Chen. An Exploration of [40] S. Zhang, W. Wang, J. Ford, and F. Makedon.
