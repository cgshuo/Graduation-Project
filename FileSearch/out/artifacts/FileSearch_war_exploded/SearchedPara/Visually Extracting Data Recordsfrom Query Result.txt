 Web sites that rely on structured databases for their content are now ubiquitous. Users retrieve information from these databases by submitting HTML query forms. Query results are displayed on a web page, but in a proprietary presentation format, dictated by the web site designer. We call these pages, query result pages . Figure 1 shows a typical query result page from HMV.com. O n this page each DVD is presented as a data record. In turn, each data record contains a collection of data items; including the title, description, release date, availability, price and customer rating, etc. as well as an image of the product. Any item on the page that does not belong to a data record is called a noise item , for example, a menu button or an advert. A query result page is designed for a human to read rather than a computer to process, thus there is no standard way to automatically extract structured data from the page.

Automatic data extraction is the process of extracting automatically a set of data records and the data items that they contain from a query result page. Such structured data can then be integrated with data from other data sources and presented to the user in a single cohesive view in response to their query. For instance, there is great commercial demand for comparison shopping search engines. A user may wish to buy a DVD; a comparison shopping search engine can extract data from many different online stores, integrate the data and display it to the user. Other practical applications include flight and hotel booking sites, financial product comparisons, property sales and rentals.
In this paper, we focus on the problem of data record extraction, that is, to identify the groups of data items that make up each data record on a query result page.
Data records on a query result page display regularity in their content, structure and appearance. They exhibit structural and visual similarities: that is, they form visual pat-terns which are repeated on the page. This is because data records on the same site are often presented using the same template. The displayed data is in an underlying database, and as the data items for each reco rd are retrieved from the database (in re-sponse to the user X  X  query), the same template is used each time to present the record. Much of the existing work that deals with the e xtraction of data records is based on the theme of identifying repeated patterns. The common premise is to find and use the re-peated patterns of data records. The main dif ferences between the existing approaches are where they look for these patterns and how they use them in data extraction.
Early approaches [1,4] identify repeated patterns in the HTML source code of multi-ple training pages from a data source in order to infer a common structure or template, and use it to extract structured data from new pages from the same source. Other ap-proaches [3,15] identify repeated patterns in the source code of a query result page in order to directly extract data records and align data items in them. However, these approaches are all limited by the rapidly increasing complexity of source code. For in-stance, the widespread use of Javascript lib raries, such as jQuery, can make source code structurally much more complex; t hus these approaches start to fail.

Later approaches [9,16,18,19] use the tag tree representation of a web page to iden-tify repeated patterns in the subtrees of the t ag tree. This representation is useful be-cause it provides a hierarchal representation of the source code. However, the tag tree was designed for the browser to use when displaying the page, and unfortunately does not accurately resemble the structure of the d ata records on the displayed page. The use of scripts and other runtime features contribute further to the differences between the structure of the tag tree and the dynamically displayed web page.
The state-of-the-art approaches [11,14,17] identify visually-repeated patterns using additional information displayed on a rendered page. However, they all succumb to the same limitation: they still rely on direct access to either the source code or the tag tree.
The approach in [10] is the first that uses pri marily visual features for data record ex-traction. However, this approach has several other limitations caused by the granularity of its input data and how it deals with noise items on a web page.

In addition, many of the current approaches [10,14,16,17] start by identifying a sec-tion of the page, referred to as the data-rich section , which contains all of the data records. However, correctly identifying the d ata-rich section can be problematic. There is a risk that some data items may be omitted from, or unwanted noise items incorrectly included in, the data-rich section. Furthermore, it is possible to identify the wrong sub-section of the page entirely.

In this paper, we propose a novel visual approach to data record extraction, which shows a strong correlation with human intuition. Our approach is guided by how most humans expect query result pages to be visually presented. This also influences web site designers, who often present pages to meet human expectations.

A common convention is to place noise items, such as menus or adverts, around the periphery of the page, reserving the centre of the page for the data records. Further-more, data items in each data record are displ ayed together, forming what is known as a locality constraint. As shown in Figure 1, query result pages follow these conventions.
To make it easy for a human reader to perceive data items in each data record as a group, designers display the data items repeatedly in the same relative position in each data record. Furthermore, designers also reserve the same horizontal space (or width) for each data record. Originally they did s o because human readers disliked pages that required horizontal scrolling [7], therefore, the data records on the page must have a uniform width so they would not cause the pag e to exceed the screen width. Indeed this accepted design constraint contributes grea tly to the regular visual appearance of data records. Technical constraints also have a part to play. Each data record on the page is displayed using the same template code, which, when rendered, reinforces a repeated visual appearance and therefore a similar composition for each data record.
A human reader uses the regularity of the vis ual-repeated pattern and structure that appears when the data records are displayed on the page to infer semantic relationships between data items and can therefore group the data items into data records.
In summary, our main contributions in this paper are as follows: First, we remove the requirement to identify the data-rich section of a query result page. We propose a novel visual approach which identifies, as a seed block, a single data item, which is a basic content block in a data record. We then implement our observations on visual and structural regularity to group together only the data items in each record. Second, our visual approach directly accesses a rendering engine to retrieve positional information and visual features of each item on the page, avo iding the need to interpret increasingly complex HTML source code and tag trees.

The rest of the paper is organised as follows. The fundamentals behind our proposed approach are presented in Section 2. Solu tions for identifying a record block for each data record on the query result page are des cribed in Section 3 and Section 4. Experi-mental results are reported in Section 5 a nd finally, Section 6 concludes the paper. In this section, we first introduce the visual block model (VBM) to represent a rendered web page, which allows us to access the positional information and visual properties of each item on the page. Next, we present our method to measure the visual similarity between the visual blocks in the model, followed by our definitions of the spatial rela-tionships between these visual blocks. Finally, we present an overview of our approach. 2.1 Visual Block Model The visual block model of a query result page is a product of the tag tree and the Cas-cading Style Sheet (CSS) of the page. A layout engine generates visual blocks for each node in the tag tree, according to the instruc tions contained in the CSS. This process, called rendering, draws a rectangular box around the minimum boundary of each visi-ble node on the page. We refer to each rectangular box as a visual block . The position of each visual block is represented by its four borders in the four directions on the two-dimensional plane. The plane has its origin at the top-left of the page, with the x-axis running from left to right and y-axis running from top to bottom.

Some of the visual blocks in the VBM, such as those outlined in blue in Figure 1, represent the structural components of the query result page. These blocks, which we call container blocks , can be thought of as the scaffolding that holds the structure of the page together. Each of these visual blocks contains at least one other visual block, each of which we call a child block . The larger visual blocks shown in Figure 1, such as those that appear to surround each data reco rd, contain many other visual blocks.
The remaining visual blocks in the VBM, such as those shown in green in Figure 1, which we call basic blocks , represent the individual labels and data items displayed on the query result page. These blocks do not c ontain any other visual blocks. A container block for a data record typically contains a number of these basic blocks.

For each visual block, we obtain 23 visual p roperties that can be used to define the visual appearance of the visual block. We choose the properties that have historically enjoyed good cross-browser representation and are the most widely used by web site designers to define the visual appearan ce of query result pages, for example, fontWeight . Our approach uses these properties to deter mine the visual appearance of each block and is flexible; additional visual properties from the CSS specification can be incorporated very easily. We use the WebKit layout engine [8] to render query result pages, however, our approach is independent of any specific engine.

In contrast to the VIPS Algorithm [2], used in other visual approaches, our VBM makes no prior assumptions regarding the or ganisational hierarchy of a query result page, it simply provides the visual properties for each displayed item. Furthermore, our VBM has finer granularity of visual blocks than the VIPS algorithm. For instance, it can represent two consecutive visual blocks containing two visually distinct texts whereas the VIPS cannot segment the two texts into two visual blocks.
 VBM vs. Tag Tree. While the VBM and the tag tree are related, they are not equiva-lent. The tag tree is a complex represent ation of the HTML code of the page, created for the browser to interpret and is only part of the information required to render the page as the designer intended. We choose to use the VBM in preference to the tag tree for data record extraction for a number of reasons. First, nodes that are close together on the tag tree may be spatially far apart on the displayed page and vice-versa. By con-sidering only the visual blocks in the VBM, our approach can  X  X ee X  the result page in the same way that a human can. Crucially, t his is how the page was designed: inferred relationships, such as a group of data items that form a data record, are much easier to identify in a visual context. Second, our approach is insulated from developments in coding practices and standards. Our appro ach relies on the rendering engine, accord-ingly we are at liberty to make use of the best engine without the need to adapt our VBM. 2.2 Similarity between Visual Blocks Our approach decides if two visual blocks have visual, width or content similarity. Definition 1. Visual Similarity: Two visual blocks, A and B , are visually similar if all of the visual properties of both blocks are the same. Let P A = { P a 1 ,P a 2 , ..., P an } be a of B . The visual similarity between A and B, Sim ( A, B ) ,isdefinedasfollows: For example, as shown in green in Figure 1, the visual blocks that contain the DVD title in both records on the query result page have the same visual proprieties and are, therefore, visually similar.
 Definition 2. Width Similarity: Two visual blocks have similar widths if the width properties for both blocks are within a threshold of 5 pixels of each other. For example, as shown in blue in Figure 1, the visual block that contains all of the data items of the first record, is the same width as the visual block that contains all of the data items of the second record. We say these blocks have similar widths.

Our approach also needs to decide if two blo cks have block content similarity, that is, they have similar sets of child blocks. Our observation is that two record blocks have a high degree of block content simila rity. This is because both record blocks are created from the same template, repeated fo r each record on the page. For example, the two record blocks, as shown in Figure 1, contain a large number of visually similar blocks. In contrast, our observation is that there is little block content similarity between a record block and a noise block. For example, the container block for the  X  X ort by X  options, which is the same width as, and directly above, the record blocks in Figure 1, does not share any visually similar child blocks with the record blocks.

We use a variant of the Jaccard index [13] to measure block content similarity be-tween two visual container blocks. The index ranges between 0 and 1, where 1 means that the two blocks are identical, and 0 means they have nothing in common. In our approach, we consider that each container b lock contains a set of child blocks. We can then measure block content similarity between two container blocks by a similarity index between two corresponding sets of visual child blocks.
 Definition 3. Block Content Similarity: Two visual container blocks have similar block contents if they have a similarity index above a preset threshold.
 For example, as shown in blue in Figure 1, the visual block that contains all of the data items of the first record has a large number of child blocks that have the same visual appearance as those child blocks in the visual block that contains all of the data items of the second record. We say these blocks have block content similarity. In Section 4.2, we formalise our usage of the similarity index. 2.3 Spatial Relationships between Visual Blocks We now define a number of spatial relationships between visual blocks. The structural regularity of data records on a query result page can be recognised by identifying these spatial relationships between data items in data records.
 Definition 4. Contains: A visual block contains another if all of the borders of the later are inside those of the former.
 For example, as shown in Figure 2, block F contains blocks A, B, C, D and E. 2.4 Data Record Extraction Each data record on the page is represented by a visual block, which contains all of the contents of the data record and nothing else. We have completed a survey of 600 query result pages and found that in over 98% of cases there is a single visual block that exactly contains each data record. The goal of our approach is to identify this block for each data record on a query result page. We call such visual blocks, record blocks .
Our approach starts by identifying a single basic visual block that is very likely to be one of the basic blocks of a data record, we call this the seed block . The seed block is contained in a set of larger blocks, which we call the candidate record blocks ,as only one of them is the record block for the data record that the seed block is in. Our approach must select the correct candidate record block as the record block. The goal of seed block selection is to identify a single basic visual block from the VBM which is part of a single data record. Let us look at the organisation of a query result page. Since the Western reading order is from top to bottom, and from left to right, it follows that the data records should start in the top left of the page. However, most web pages have common navigation menu and header structures that appear around the edges of the page. Thus, the starting point of the data records can be shifted down and to the right. As human readers expect this convention, they start looking for data records in this area of the page. A study on web usability by eye tracking [12] confirms that the highest priority area for content is betw een the centre and the top left of the page.
Our approach starts at the centre of the page, furthest from the noise blocks at the edges and closest to the highest priority area for data records. We trace a clockwise Ulam Spiral [5], as shown in Figure 3, which naturally grows from the centre towards the top left of the page. This is the area of the page most likely to contain data records.
The Ulam Spiral was specially selected as it covers the largest possible proportion of the highest priority area, before it reaches the edges of the page. A simple plane between the centre of the page and the top left corner of the page has, on the other hand, the potential to miss the basic blocks belonging to sparsely populated data records. Instead it could quickly reach the edge of the page a nd select as the seed a basic block belonging to a noisy feature such as a left menu.

The exponential growth of the spiral combined with its direction of travel (clockwise) ensures that it shows bias to the area between the centre and the top left of the page thereby covering more of the highest priority area than is possible for a simple plane cover. As shown in Figure 3, the spiral terminates when it first encounters a basic block. This block is taken as the seed block. The goal of data record selection is to identify a set of container blocks from the VBM, one block for each of the data records on the query result page.

The seed block is contained inside a numbe r of container blocks, each of which pro-vides a structure on the page. Examples of these container blocks are shown in Figure 1, highlighted in blue. By isolating only the container blocks in which the seed block is actually contained, our approach identifies the set of candidate record blocks, as shown in Figure 1, highlighted in red. We observe that one of these candidate record blocks is the record block for the data record and furthermore, this visual block has the similar width to the record block for each of the r ecords on the same query result page. 4.1 Getting Candidate Record Blocks and Clustering Container Blocks The seed block is a basic block, which is contained inside one or more of the container blocks. As shown in Figure 1, the seed block, which was selected in the previous step, is contained inside four container blocks, highlighted in red. As one of these blocks is the record block, all four are taken as the candidate record blocks. Next, our approach filters the set of all container blocks on the page, discarding any block that is not the same width as one of the candidate record blocks. Our approach uses a one-pass algorithm to cluster the filtered container blocks into a strict partition based on block width. This step creates a number of clusters, one of which contains the record blocks. In our example, the algorithm would create four clusters, one for each of the candidate record blocks. 4.2 Measuring Block Content Similarity Our approach uses a similarity measure to det ermine if two container blocks have sim-ilar block contents. Assume that block A contains a set of child blocks { a 1 ,a 2 , ..., a m } and block B contains a set of child blocks { b 1 ,b 2 , ..., b n } .

It is reasonable to expect that a container block may contain more than one child block with the same visual properties. For example, a data record on a car sales web site may contain an individual child block f or each feature of the car, such as the engine size, number of doors and fuel type. These child blocks could share the same visual properties. Accordingly, our approach uses a multi-set representation for each container block. This generalisation of the notion of a set, in which members may appear more than once, allows our approach to represent the child blocks of a container block.
Our approach uses a one-pass algorithm to c luster each of the child blocks contained in a set into a strict partition based on their visual similarity. The function Sim ,defined in Definition 1, is used for this purpose. Two child blocks, a and a , are clustered to-gether if Sim ( a, a )=1 . So a set of child blocks, A , is clustered into a strict partition A
For instance, assume that container block A contains four child blocks, a 1 , a 2 , a 3 and a 4 . Two child blocks, a 1 and a 2 , are visually similar, while a 3 and a 4 are visually distinct. The corresponding multi-set, A , is clustered into a set of subsets, A c ,where each subset in A c represents a single cluster: Select one child block from each cluster in A c as its representative, so we have a set of representative child blocks, A x ,for A c : Given two sets of visual blocks, A and B , we use our similarity measure to find the block content similarity between A and B , defined as follows: We define an indicator function for A x as follows: Assume that B is clustered into B c and B y = { y 1 ,y 2 , ..., y n } is a set of representative child blocks for B c . We define an indicator function for B y as follows: We t h e n h av e : |
A  X  B | = where and If SimBlockContent ( A, B ) is above a preset threshold, A and B are considered to have similar block contents. 4.3 Selecting Record Blocks Only one of the candidate record blocks represents the container blocks that provide the structure for each data record on the page. Th e other candidate record blocks represent container blocks that are used to provide structure to other areas of the page. By select-ing the candidate record block, which has content similarity to the maximum number of container blocks, our approach iden tifies the blocks for each data record.
However, our example demonstrates a scenario where two candidate record blocks both correspond to the maximum number of container blocks. In this case the candidate record blocks C and D in Figure 1 both have similar contents to the same number of container blocks, as both blocks are pres ent for each displayed record. In the event of a tie for maximum blocks, our approach selects the candidate record block which represents the widest container block, as these container blocks provide the structure to the whole data record (for example, container block labelled D), rather than the internal structure provided by the smaller blocks (for example, container block labelled C). We have implemented our algorithms for data record extraction in a software prototype called rExtractor . In this section we first describe the two datasets that we use to eval-uate the accuracy of our algorithms, and then discuss the performance metrics used to interpret the results of these experiments. We compare the performance of our proto-type, rExtractor , with that of ViNTs [17], a state of the art extraction system available on the web (our experimental analysis makes use of the online prototype), which is based on both visual content features and HTML tag structures.
 5.1 Datasets In our experiments we use two datasets, DS1 and DS2 . DS1 is used to compare our method with ViNTs [17]. As these is no standard dataset for experimental analysis of data record extraction techniques, DS1 comprises of web sites taken from the third party list of web sites contained in Dataset 3 presented in [17]. The web pages contained in Dataset 3 were downloaded from the Internet in 2004, as a result they are  X  X tale X , that is, they are not representative of the layout and appearance of modern web pages. From a visual standpoint, modern pages are more vi vid than older pages: they contain more images and much more noise in the form of adverts and menus for example. Therefore, for each web site from Dataset 3 we visited the same web site and downloaded five modern equivalent query result web pages. DS1 comprises 50 web pages from 50 web sites, one web page per web site. In total DS1, contains 752 data records.

DS2 contains a total of 500 web pages from 100 web sites, five per site. It is based on Dataset 1 and Dataset 2 in [17], as well as the list of web sites in [6]. As with the previous dataset, the source web pages used to compile DS2 are stale. Accordingly, for each web site included in DS2 from Dataset 1 and Dataset 2, we visited the same web site and downloaded a modern equivalent query result page. The web sites in [6] are listed by their query interface, for each web site included in DS2, we used the query interface to generate five modern query result pages. The web sites in our datasets are drawn from a number of domains, including Books, Music, Movies, Shopping, Proper-ties, Jobs, Automobiles and Hotels. In total, DS2 contains 11,458 data records. 5.2 Performance Metrics We use a number of performance metrics for our experiments.
 Ground Truth. The set of data records from all of the web pages collected per web site.
 True Positives. These are data records extracted co rrectly from all of the web pages per web site. Ideally, the true positives are the same as the ground truth for each web site. False Positives. These are data records extracted in correctly from all of the web pages per web site. Ideally, the number of the false positives should be zero.
 Precision. This is the number of true positives divided by the number of both true and false positives per web site. The average precision across web sites is calculated by averaging the precisions of individual web sites.
 Recall. This is the number of true positives divided by the number of data records in the ground truth per web site. The average r ecall is calculated by averaging the recalls of individual web sites. 5.3 Experimental Analysis To undertake the experimental evaluation and comparison of rExtractor and ViNTs, we first extract manually the data records on each web page in DS1. Second, we run both rExtractor and ViNTs on all of the pages in DS1 and record the correctly extracted (true positives) and incorrectly extracted (false positives) data records on each web page. Finally, we calculate the average precision and recall for all of the web sites in DS1 for both ViNTs and rExtractor . Next, we undertake the same procedure for DS2 and rExtractor , to determine how rExtractor preforms on a larger dataset. The results for both DS1 and DS2 are presented in Table 1. 5.4 Experimental Analysis As we can see from Table 1, the performance of rExtractor is considerably better than that of ViNTs. Our analysis of the results for ViNTs on DS1 found that ViNTs identified a large number of false positive data records (427 in total). This contributed greatly to their low precision score. By inspecting these false positives, we discovered that ViNTs frequently selected the wrong sub-section o f the page as the data-rich section section (DRS). For example, their approach often s elected a centrally lo cated, or near centrally located, page navigation men u (for instance, a large footer menu) and then extracted each menu item as a false positive record. In the se cases, it was then impossible for their technique to extract the correct data records. Consequently, the number of true positive data records they identified was also small, which contributed to their low recall score. This is not a criticism of ViNTs. Their technique worked very well on the web pages that were available when ViNTs was developed; rather it serves to highlight that modern web pages are vastly differ ent from older web pages.

Conversely, the seed block technique implemented by rExtractor selected correctly a child block belonging to a data record in all of the test cases. This demonstrates that our technique has no need to explicitly identify a DRS. Furthermore, as we can see from Tables 1 and 2, rExtractor preforms extremely well on both DS1 and DS2 (more than 12,000 data records in total). The experimental results show that the techniques imple-mented in rExtractor to identify candidate record blocks, measure block similarity and select record blocks are all robust and highl y effective. Therefore, it is more worthwhile to investigate the cases where rExtractor failed to correctly extract data records.
First, a small number of data records (1.3% in total) were not displayed in record con-tainer blocks. rExtractor relies on these blocks to define the record boundaries. Close inspection of web pages containing these d ata records reveals they use out-dated page design conventions and are very much the exception rather than the norm.

Second, our content similarity technique prevented the extraction of a small number of data records. These records were determined to have not enough in common with other records on the same page. For instance, designers use a different structural layout and visual appearance to distinguish between a normal record and a  X  X eatured X  record. In the cases where rExtactor failed, it was often because a featured record was excluded. We see this as an opportunity to develop further our content similarity technique. This paper presents a novel approach to the automatic extraction of data records from query result pages. Our approach first identifies a single visual seed block in a data record, and then discovers the candidate record blocks that contain the seed. Next the container blocks on the page are clustered an d a similarity measure is used to identify which of these blocks have similar contents to each candidate record block. Finally, our approach selects the cluster of visual blocks that correspond to the data records. We plan to extend our approach so that the similarity threshold, used to determine if two blocks have similar contents, is set automatically by a machine learning technique.
