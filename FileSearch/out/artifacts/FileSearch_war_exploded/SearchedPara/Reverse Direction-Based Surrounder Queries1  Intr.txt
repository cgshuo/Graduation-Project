
Xi Guo 1 , 2 , Yoshiharu Ishikawa 3 , Aziguli Wulamu 1 , 2 , and Yonghong Xie 1 , 2 In spatial databases, given the location of user o , a traditional nearest neigh-bor query retrieves the top-k nearest points of interests (POIs) to the user. The spatial closeness between the user and the POIs is typically used for the query. However, in real applications, directional closeness is also important. Re-cently, some studies [8][9][14][15] have focused on spatial queries considering both distance and direction. These direction-based spatial queries can provide infor-mation about the area around the user. Given a set of POIs, P , and user o in two-dimensional Euclidean space, two POIs, p and p ,are directionally close if their included angle,  X  pop , with respect to user o is smaller than an angular threshold,  X  .POI p dominates p if the distance from p to o is shorter than the distance from p to o . A DBS is a point that cannot be dominated by any other POIs. A DBS query is used to retrieve all the DBSs from the database [8][9]. Example 1. Fig. 1 shows an example of the DBS query. The circles represent users labeled a to g . The squares represent POIs, such as the restaurants, labeled A to H . Assuming that user a wants to find nearby restaurants, a issues a DBS query with  X  =45  X  .POIs E and D are directionally close to user a . Because they are directionally close and E is closer to a than D , E dominates D .Inthe same way, E dominates C and G ,and A dominates B .POIs { A, E, F, H } cannot be dominated by any other POIs and they are the DBSs of user a (solid circles). Problem 1. The RDBS query finds all users that see a query POI as one of their DBSs.
 Example 2. Fig 2 shows an example of an RDBS query. POI A (solid square) wants to find the users that see it as a DBS, given  X  =45  X  . According to Example 1, user a sees A as a DBS; therefore, user a is an RDBS of A . However, another user, g ,doesnotsee A as a DBS because E can dominate A with respect to g (  X 
EgA =33  X  and E is closer to g than A ). In the same way, we also find that users c , d ,and e do not see A as a DBS 1 .Insummary,theRDBSsof A are { a, b, f } (solid circles).
 The query point in an RDBS query is usually a POI, whereas the query targets are the users. When the query point and the query targets are two different kinds of objects, the query is called bichromatic . When the query point and the query targets are the same kind of object, the RDBS query is called monochromatic . In this paper, we focus on bichromatic RDBS queries, although the proposed techniques can answer monochromatic queries with a few changes.
 Motivation. RDBS queries are suitable for loc ation-based services. A typical scenario is a restaurant, q , that issues an RDBS query to retrieve every cus-tomer who may visit q . Every customer retrieved should see q as their nearest restaurant in all different directions. In Fig. 2, it is assumed that the direction preference of the customers is unknown. Customers { a, b, f } may visit A because it is the nearest restaurant in a specific direction. In other words, they are pos-sible customers of A and A should do something to attract them, such as reach them with an advertisement.

We propose an extended query based on the RDBS query, called the competi-tor RDBS query .
 Problem 2. A competitor RDBS query (hereafter referred to as the competi-tor query) retrieves the competitors of query point q and sorts the competitors by their competition scores for q . Example 3. In Example 2, we know that the query point A has three RDBSs, { a, b, f } . In this example, we consider another query point, E . As Fig. 3 shows, E has two RDBSs, { a, g } .Queries A and E share the same RDBS, a (solid triangle). Consider the restauran t scenario. Restaurant E is a competitor of restaurant A . A competitor query is an extension of an RDBS query. Two points may share the same RDBSs. For the two restaurants, q and q , the customer a can visit q or q . We evaluate the amount of competition between q and q by competition scores . The competition score that q has for q is the number of the same RDBSs divided by the number of RDBSs of q , whereas the competition score that q has for q is the number of the same RDBSs divided by the number of the RDBSs of q . We retrieve the competitors for query point q and rank them by sorting their competition scores.
 Technical Overview. To answer a bichromatic RDBS query, a straightforward approach is to check every user o  X  X  and determine whether they are an RDBS of q . Observing that the users close to q are likely to be RDBSs, we propose an RDBS candidate polygon , in which the points are possible RDBSs. Using the candidate polygon, we can avoid performing checks for the users that cannot be RDBSs. To answer a competitor query, a straightforward approach is to check every POI in P X  q and to determine whethe r it is a competitor of q . Intuitively, two POIs share the same RDBSs only if their RDBS candidate polygons inter-sect. We calculate the polygons of all POIs beforehand and organize them by a spatial index. Because R  X  -tree cannot index polygons directly, we approximate the polygons by bounding boxes.
 Experimental Results. We conduct experiments to evaluate the RDBS queries and the competitor queries. In the RDB S query experiments, the results show that the users enclosed by the RDBS candidate polygon are a small portion of the whole user set. Because the polygon helps us prune many non-candidate users, our approach can answer RDBS queries very quickly. The average speed is about 100 times faster than the straightforward approach. In the competitor query experiments, the results show that when we use bounding boxes to approximate the polygons, we can filter out many POIs that cannot be competitors. Filtering out many irrelevant competitor s decreases the retrieval time.
 Contributions. The contributions of the paper are summarized below.  X  We propose a new problem called an RDBS query and design algorithms to  X  We propose an extension problem, calle d the competitor query problem, and  X  We conduct experiments to test the performance of the proposed algorithms. Reverse Nearest Neighbor Queries. Given a query point, q , a reverse nearest neighbor (RNN) query ([10],etc.) finds the points that see q as their nearest neighbors. RDBS queries retrieve point s considering distances and directions, whereas RNN queries only consider the distances.
 Direction-Based Spatial Queries. In spatial databases, the study of queries that emphasize direction is limited. T he RDBS query is different from the DBS queries in previous work [8][9] because i t retrieves the POIs that see the query point as a DBS rather than retrieving the POIs that are the DBSs of the query point. In Refs. [6], [14], and [15] the problem definitions and retrieval algorithms of the DBS queries are improved. The DBRNN problem has been studied previ-ously [11][12]. The DBRNN query first retrieves the users that are RNN of q and then filters out the users that are not moving towards q and the customers that are too far away from q . It is totally different from the RDBS query. In Refs. [3][13] spatial points are retrieved considering keywords as well as distances and directions.
 ReverseSkylineQueries. Skyline queries also retrieve points to optimize two or more objectives [2]. Reverse skyline queries [4] retrieve the points that see q as a relative skyline point [5]. RDBS queries are different from reverse skyline queries because whether two poi nts are directionally close depends on the positions of two points and q . In reverse a skyline query, an attribute value of a point depends on itself and q . We define RDBS queries in two-dimension al Euclidean space. In the space, there are a set of POIs, P , and a set of users, O . According to user o  X  X  and angular threshold  X  ,POI p 1  X  X  has a dominance relationship with POI p 2  X  X  . Definition 1. Given a user, o , and a threshold,  X  ,twoPOIs, p 1 and p 2 ,are directionally close if the included angle of the vector, op 1 , and the vector, op 2 , are smaller than  X  , that is  X  p 1 op 2 &lt; X  .
 Definition 2. Given a user, o , and a threshold,  X  ,POI p 1 dominates POI p 2 if they are directionally close and p 1 is nearer than p 2 .
 Definition 3. Given a user, o , and a threshold,  X  ,aPOI, p ,isa DBS of o if it cannot be dominated by any other POIs in P .
 Definition 4. Given a query POI q , and a threshold,  X  ,user o  X  X  is an RDBS of q if o sees q as a DBS.
 An RDBS query retrieves the RDBSs of query POI q as Problem 1 defines. Na  X   X ve Approach. Ana  X   X ve approach to retrieving the RDBSs of a query POI q , is to check every user, o  X  X  , and to determine whether it is an RDBS. User o is an RDBS if o sees q as a DBS. If q is a DBS, it should not be dominated by any other points in P . According to the location of o ,point p can dominate q only if p and q are directionally close and p is closer than q 2 . However, the na  X   X ve approach is not efficient enough. Intuitively, the users close to q are likely to be RDBSs, as Fig. 2 indicates. User o far from q may see that q is dominated by other POIs. A POI that can dominate q should be directionally close to q and be closer than q . It is easy to find such a POI near o . Based on this observation, next we analyze the area where user o must not be an RDBS of q .Inother words, we try to find the area where user o could be an RDBS.
 Negative Area. Consider where user o is if they do not see q as their DBS. Assuming p can dominate q with respect to o , two conditions must be satisfied according to Definition 2. One condition is that p should be nearer than q . Another condition is p and q should be directionally close. To find o that makes p and q satisfy these two conditions, we use two geometries as shown in Fig. 4.  X  Mid-Perpendicular Line. The mid-perpendicular line, l ( p, q ), of segment Using the mid-perpendicular line and the  X  -circles, we separate the space into three areas can make p and q satisfy different conditions. Because area ( c 1 ,c 2 ) intersects with area ( l,p )and area ( l,q ), the space is divided into four non-overlapping areas. We show the four areas and the corresponding satisfied con-ditions below. 1. area ( l,p )  X  X  area ( c 1 ,c 2 ): | op | &lt; | oq | and  X  poq &lt;  X  ; 2. area ( l,p )  X  area ( c 1 ,c 2 ): | op | &lt; | oq | and  X  poq &gt;  X  ; 3. area ( l,q )  X  area ( c 1 ,c 2 ): | op | &gt; | oq | and  X  poq &gt;  X  ; 4. area ( l,q )  X  X  area ( c 1 ,c 2 ): | op | &gt; | oq | and  X  poq &lt;  X  . We call area 1 the negative area (according to p ), denoted as area neg ( p ), because the users in this area are guaranteed not to be RDBSs of q because they see p as a dominator of q . To find RDBSs efficiently, we should prune such negative areas beforehand. However, negative areas are not regular shapes. To make the negative area easily pruned, we simplify the area as a half-plane that is separated The gray area in Fig. 4 shows the simplified negative area separated by l neg ( p ). Given a query POI q ,andaPOI, p  X  X  ,user o cannotbeanRDBSof q if it is in area neg ( p ), the negative area according to p .
 RDBS Candidate Polygon. We introduce the concept of an RDBS candidate polygon .InFig.5,whereagroupofPOIs, P  X  = { a, b, c, d } , correspond to neg-area in Fig. 5. If a user is in the polygon, like the hollow circles, they can be an RDBS. We call such an area an RDBS candidate polygon .
 Definition 5. Given a query POI, q ,andagroupofPOIs, P  X  ,the RDBS candidate polygon of q according to P  X  is the area enclosed by the negative lines corresponding to the POIs in P  X  .
 Theorem 1. Given a candidate RDBS polygon of query POI q ,ifauserisin the polygon, it could be an RDBS, otherwise, it is not an RDBS.
 We can arbitrarily select a group of POIs, P  X  , to construct an RDBS candidate polygon of the query POI q . However, a better way to construct the polygon is to use the k -nearest POIs of q because a POI closer to q corresponds to a negative line that is also closer to q . The line closer to q can prune larger negative areas and can form a smaller RDBS candidate polygon. For example, in Fig. 5, we construct the polygon by using the nearest POIs, { a, b, c, d } ,where a is the first nearest neighbor of q , b is the second nearest neighbor of q ,and so on. This construction order has an additional benefit. We can terminate the construction of the candidate polygon when the enclosed area does not shrink. Next, we introduce details of the termination condition.
 Termination Condition. APOI p contributes a useful negative line , l neg ( p ), if the line intersects with the current polygon. If l neg ( p ) does not intersect with the polygon, it is useless because it cannot change the boundary of the current poly-gon and cannot make the polygon enclose a smaller area. To obtain fewer RDBS candidate users, the area enclosed by the polygon should be minimized. For ex-ample, in Fig. 5, after constructing the polygon ABCD by using the nearest POIs { a, b, c, d } we update the polygon by using the fifth-nearest POI. The neg-ative line contributed by the fifth-nearest POI may intersect with the polygon. Consider the scenario when the i ntersection happens. Line l neg ( p 1 ) contributed by p 1 4 intersects with ABCD and a new polygon, ABCEF , is obtained from the two intersections, E and F . New polygon ABCEF encloses a smaller area than ABCD ;thus, l neg ( p 1 ) is useful. Consider another scenario when the inter-section does not happen. Line l neg ( p 2 ) contributed by p 2 does not intersect with ABCD , ABCD does not change, and thus Line l neg ( p 2 ) is useless. When a POI is far away from q , it cannot contribute a useful negative line. When the polygon stops shrinking, it is meaningless to retrieve more nearest neighbors to update the polygon. We consider how far the nearest neighbor is when the retrieval should terminate. Before introducing the termination condi-tion, we define angular adjacent first. Assuming that there is an auxiliary polar coordinate with the origin as POI q and the axis as vector qq ,where q is ( q x +1 ,q y )tomake qq parallel to the x-axis. In the polar coordinate, each POI p has a polar angle,  X  ( p ), and a polar radius,  X  ( p ).
 Definition 6. Given two POIs, p  X  and p + (  X  ( p  X  )  X   X  ( p + ) ), the two POIs are angular adjacent if  X  ( p  X  )  X   X  ( p )  X   X  ( p + ) ,where p  X  X   X   X  p  X   X  p + . In the definition, P  X  denotes the nearest neighbors that have been checked al-ready. For example, in Fig. 5, nearest neighbors a and b are angular adjacent in the list sorted by the increasing order of their polar angles. When there is no ambiguity, we use p  X  and p + to denote two angular adjacent points. We define the angular interval below.
 Definition 7. An angular interval is the range defined by the polar angles of two adjacent POIs, p  X  and p + , that is [  X  ( p  X  ) , X  ( p + )] .
 The intersection of their negative lines, l neg ( p  X  )and l neg ( p + ), is denoted as cp ( p  X  ,p + ). For example, in Fig. 5, the intersection of l neg ( a )and l neg ( b )is cp ( a, b ). The theorem below indicates when a nearest neighbor cannot contribute a useful negative line.
 Theorem 2. If the polar angle of p is between the polar angles of two angular to p is POI p cannot contribute to a useful negative line. For simplicity, we call the right side of Eq. 2 the distance threshold of the interval According to Theorem 2, we can define the closed interval .
 Definition 8. Angular interval [  X  ( p  X  ) , X  ( p + )] is closed if there is a nearest When an angular interval is closed, it is meaningless to retrieve the next nearest POIs, which have polar angles in the interval. Assuming we are checking near-larger than or equal to dt ( q,p  X  ,p + ), p cannot contribute a useful negative line. According to Eq. 2, in the interval, all the POIs further away than p cannot contribute useful negative lines. Thus, we should terminate retrieving nearest POIs in the interval. In other words, the interval is closed. On the other hand, if | q,p | is smaller than dt ( q,p  X  ,p + ), p can contribute a negative line. Thus, we compute l neg ( p ) and update the boundary of the polygon. After updating the and [  X  ( p ) , X  ( p + )]. Theorem 3 summarizes th e termination condition. Theorem 3. After retrieving nearest POIs { p 1 ,p 2 ,...,p m } to construct the are all closed, the area enclosed by the polygon will not be smaller and retrieval can be terminated.

To answer the RDBS queries more efficiently than the na  X   X ve approach, first we use the RDBS candidate polygon of q to obtain the users that could be RDBSs. The polygon is constructed incrementally by retrieving the nearest POIs of q .To retrieve the nearest POIs efficiently, we organize POIs P by a spatial index such as R  X  -tree [1]. After the polygon is determined, we check whether the candidate users in the polygon are real RDBSs by using the na  X   X ve approach. To retrieve the candidate users efficiently, we use another R  X  -tree to index the users O 5 . Based on the definition of an RDBS query, we define a competitor query. The competitors are POIs of query point q .
 Definition 9. Given a set of POIs, P , a set of users, O , and a threshold,  X  ,a competitor of query POI q are POIs p  X  X  that share the same RDBSs with q , that is RDBS ( q )  X  RDBS ( p ) =  X  .
 RDBS (  X  ) denotes the RDBS set of a POI. The same RDBSs shared by two POIs are denoted by share (  X  ,  X  ). Each competitor of query POI q has a competition score with q . Definition 10. Given query POI q and its competitor p ,the competition score that p has for q is given as where | X | denotes the number of members in a set. The competition score can describe the effect of the competition strength that p exerts on q . According to Definitions 9 and 10, we formulate the competitor query problem in Problem 2. The competitor query problem is finding the competitors of query POI q and sorting the competitors by their competition scores.
 Na  X   X ve Approach. To answer competitor queries, a na  X   X ve approach is to find RDBS ( q )and RDBS ( p i )( p i  X  X  ) for identifying the competitors from P that share same RDBSs with q , and then to sort the competitor by their competition scores. The RDBS set of q and p i  X  X  can be found by using the algorithm proposed in Section 3. The competition score of a com petitor can be calculated according to Eq. 3. However, the na  X   X ve algorithm is not efficient enough. One reason is that we have to calculate the RDBSs of every POI in P , even though most POIs do not share any RDBSs with q . Another reason is that we have to calculate the RDBSs of POIs repeatedly for different queries q , although the RDBSs of a POI are independent of the queries and never change for different query POIs. To improve the na  X   X ve algorithm in terms of two aspects, we propose an index-based approach.
 Bounding Boxes. Intuitively, if the RDBS candidate polygons of two POIs intersect, the two POIs are likely to share RDBSs. In other words, if the poly-gons of two POIs do not intersect, they d o not share any RDBSs. Therefore, we calculate polygons p poly of all POIs p  X  X  beforehand. When query q is issued, we find polygons that intersect with q poly . The corresponding POIs of these in-tersecting polygons may be the competitors of q . Finally, we identify the real competitors from these candi date competitors. To retrieve the polygons inter-secting with q poly efficiently, we use an R  X  -tree to index the polygons of the POIs in
P .R  X  -tree is designed to index points or boxes, but it cannot index polygons directly. We approximate the polygons as boxes by a bounding approach. The bounding approach can calculate the smallest bounding box of a polygon. We use R -tree from the Boost C++ Libraries 6 . In the library, the bounding approach has already been implemented. Datasets. We use synthetic datasets to evaluate the RDBS queries (Section 3) and the competitor queries (Section 4). The POIs and users in the datasets are two-dimensional and are generated rando mly. We create six datasets containing and P 5 ( O 5 ), which contain 100, 2000, 4000, 6000, 8000, and 10,000 points, respectively. For simplicity, the POI dataset, P i , and the user dataset, O i ,are thesamesetofpoints.Werandomlys elect 20 POIs from the experimental dataset as the query points. The results are the average results of 20 queries. Environments. All the experiments are conducted on a machine with an Intel Core i5-2415M CPU with 4 GB of memory running Windows 7 (32 bit). All the algorithms proposed are implemented i n C++. The development environment is Visual Studio 2013. The R  X  -tree used in the experiments is from the Boost C++ Libraries of release version 1.57.0.
 RDBS Query Experiments. First, we conduct experiments to evaluate the performance of the proposed algorithms with respect to different amounts of old  X  is 30  X  . Fig. 6 and 7 show the experimental results. The label  X 2 X  on the x-axis corresponds to dataset P 1 ( O 1 ), which contains 2000 points. We label the other x-coordinates in the same way. In Fig. 6, the y-axis represents the num-bers of RDBSs and users that have been checked. In Fig. 7, the y-axis shows the elapsed time (milliseconds) for retrieving the RDBSs on a log scale. In Fig. 6, the number of users checked is not much more than the number of RDBSs, which indicates that the filtering function of the candidate polygons works well. In Fig. 7,  X  naive  X  denotes the na  X   X ve approach, whereas  X  opt  X  denotes our approach. The experimental results show that opt runs about 100 times faster than naive because checking whether a user is an RDBS is time consuming and opt can filter out large numbers of users who cannot be RDBSs. Fig. 7 also indicates that when the dataset size increases, the time advantage of opt becomes more obvious.
Second, we conduct experiments to evaluate the algorithms when  X  varies. We x-axis represents different  X  values. In Fig. 8, the y-axis represents the number of RDBSs and the number of users checked. In Fig. 9, the y-axis represents the time (milliseconds) taken to retrieve RDBSs. In Fig. 8, the number of RDBSs decreases when  X  increases because q is more likely to be dominated when  X  is larger. The number of users c hecked also decreases when  X  increases because the candidate polygon for q decreases as  X  increases. In Fig. 9, the time cost decreases when  X  increases for naive and opt ;as  X  increases, q is more easily dominated.
 Competitor Query Experiments. First, we evaluate the performance for retrieving the competitors of a query POI for different dataset sizes. We use  X  bb  X  approximates the candidate polygons by bounding boxes.  X  ab1  X  X nd X  ab2  X  approximate the polygons by angular boxes, which are proposed in Ref. [7]. For brevity, we do not introduce the techniques ab1 and ab2 . The average results are shown in Fig. 10. The x-axis represent s the dataset sizes. Second, we evaluate the performance of retrievi ng competitors for different  X  values. We use dataset P or 75  X  . In Fig. 11 the x-axis represents different  X  values. The y-axis represents the time (seconds) taken to process the co mpetitors. The time cost decreases as  X  increases because a query POI has fewer competitors when  X  is larger. In this paper, we proposed an RDBS quer y that retrieves the users seeing the query POI q as one of their DBSs. We also proposed a competitor query that retrieves the POIs that share the same RDBSs with q . We designed algorithms to answer the queries and experiments sh owed that the algorithms are efficient. In future studies, we intend to consider the direction preference of query q and to consider moving target points O .
 Acknowledgement. This work is supported by National Key Technology R&amp;D Program in 12th Five-year Plan of China (No. 2013BAI13B06). This work is also supported by Fundamental Research Funds for the Central Universities (No. FRF-TP-14-025A1). This research was partly supported by KAKENHI (25280039).

