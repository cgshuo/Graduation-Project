 Caching the results of frequent query patterns can improve the performance of query evaluation. This paper describes a 2-pass mining algorithm called 2 PXMiner to discover fre-quent XML query patterns. We design 3 data structures to expedite the mining process. Experiments results indicate that 2 PXMiner is both efficient and scalable.
 Categories &amp; Subject Descriptors: H.2.8 [Database Man-agement]: Database Applications -Data Mining General Terms: Algorithms, Performance Keywords: XML Query Pattern, Tree Mining
The efficient management and delivery of XML data has become a prominent focus of recent research. Tree pattern is a distinguishing characteristic in XML query languages. Matching tree patterns against XML data is a core operation in XML query processing. This operation can be expensive since it involves navigation through the hierarchical struc-ture of XML documents, which can be deeply nested. One approach to improve the performance of XML management systems is to discover frequent queries and to cache the re-sults of these queries [3, 5].

By modelling XML queries as query pattern trees, we ob-tain a database of query pattern trees. Each query pattern tree is a transaction that is associated with a transaction ID . Mining frequent query patterns is equivalent to find-ing the rooted subtrees that occur frequently over the set of pattern trees. This mining process involves tree match-ing, which is expensive and is complicated by the presence of wildcards  X * X  and relative paths  X // X  in the XML query pattern trees. Given that the rooted subtrees are candidate patterns, the search space is exponential to the size of a pat-tern tree. Hence, an efficient mining algorithm will typically aim to minimize the number of tree matchings needed. [5] recently develop an algorithm called F astXM iner to discover frequent XML query patterns. While F astXM iner Copyright 2004 ACM 1-58113-888-1/04/0008 ... $ 5.00. is able to reduce the number of tree matchings required, there is no guarantee on the number of database scans re-quired. Further, the proposed method is applicable to XML queries on a class of XML documents that do not contain sibling repetitions. However, it is important to consider XML queries that involve sibling repetitions because they are widespread in many XML applications including authors in a publication database, and actors in a movie database.
This paper describes a novel algorithm called 2PXMiner to discover frequent XML query patterns involving repeated sibling nodes. This method requires only two scans of the query pattern tree database. This is achieved by utilizing the following data structures: 1. Transaction summary structure called T-GQPT. This 2. Equivalence Class Tree (ECTree). This is essentially a 3. Index structure called RETrie. This provides for the
Based on the above data structures, we develop three op-timization techniques in 2 PXMiner : 1. Computing Upper Bound of Potential Frequent Pat-2. Early Pruning : We prove that by exploiting the T-3. Tracing Repeated Candidates : The index tree RET rie
Experiment results indicate that the proposed 2 PXMiner is very efficient and has good scalability.
Fig. 1(a) shows the query pattern tree of a query to re-trieve the title , author and price of books where  X  books/ section//title  X  has value  X  X ML Schema X . A query pattern Figure 1: A query pattern tree and a rooted subtree. tree may consist of not only element tag names but also wildcard  X * X  and relative path  X // X . The relative path  X // X  indicates zero or more labels (descendant-or-self). A descen-dant edge is denoted by a double-line.

A subtree that has the same root as a query pattern tree is called a rooted subtree . An rooted subtree with k edges is called a k-edge rooted subtree, denoted as RST k .Fig.1(b) shows a 2-edge rooted subtree. A single-branch rooted subtree has a single leaf node. [4] investigated the containment problem of query pattern trees, and proved that the containment problem of pattern trees is co-NP complete. They described a containment al-gorithm based on alternating tree automata which runs in exponential time. However, the algorithm is able to run in polynomial time in some special cases such as when the num-ber of  X // X  X  is bounded by a constant, and when the pattern tree is a single-branch path. We implemented this tree in-clusion test as a procedure called Contains ( QP T, RST )to determine whether a rooted subtree RST is included in a query pattern tree QP T . Two basic concepts are used in the containment test: subtree embedding/homomorphism and query containment.

Homomorphism h : NODES ( p )  X  NODES ( p ) between two patterns p and p ,where h is root-preserving, respect node labels, and obey edge constraints. That is, 1. h (ROOT( p )) = ROOT( p ); 2. for each x  X  NODES ( p ), LABEL( x )=*orLABEL( x )= 3. for each x, y  X  NODES ( p ), if ( x , y ) is a child edge in
The concept of embedding is a mapping from a query pat-tern tree to an instance tree. If there exists a homomorphism h which maps a rooted subtree RST to a query pattern tree QOT ,then RST is structurally included in QP T ,denoted as RST  X  QP T . From the perspective of query answering, this h indicates answer ( QP T )  X  answer ( RST ) since if there is an embedding e from QP T to a tree t ,then e  X  h is also an embedding from RST to t . Given a set of query pattern trees QDB = { QP T 1 , ..., QP T N } , mining the frequent query pattern implies discov-ering the frequent rooted subtrees ( RST s) in the query pat-tern trees. If a rooted subtree RST iscontainedinaquery QPT 1 author book title Figure 2: Example of a frequent query pattern tree pattern tree qpt of QDB ,wedenoteitas occ qpt ( RST )=1, otherwise occ qpt ( RST )=0. The total occurrence of an RST in QDB is denoted by freq( RST )= qpt  X  QDB occ qpt ( RST ). Let | QDB | denote the number of QP T s in database QDB , the support level is defined as supp ( RST )= freq ( RST )/ We say that RST is  X  -frequent in QDB if supp ( RST ) ex-ceeds the minimum support  X  where 0 &lt; X   X  1. For conve-nience, we define minSupp =  X  * | QDB | .

Consider Fig. 2. The rooted subtree RST occurs in QP T 1 and QP T 2 with a frequency and support of freq ( RST )=2 and supp ( RST )=2/4 respectively.
In this section, we describe three structures that are im-portant in the design of the two-pass mining algorithm.
Mining tree patterns requires the enumeration of all the rooted subtrees in the XML query pattern tree database. Each query pattern tree is associated with a transaction ID or TID . For example, the query pattern trees QP T 1 , QP T QP T 3 and QP T 4 in Fig. 2 are associated with the TID s1, 2, 3 and 4 respectively. We can merge all the query patterns to build a global query pattern tree called transaction global query pattern tree, or T-GQPT . This structure guides the enumeration of valid candidate rooted subtrees.

Fig. 3(a) shows the T-GQPT obtained from the query pat-terntreesinFig.2. Thechildnodesofeachinternalnode in the T-GQPT are stored in a lexicographically ascending order. The cost to insert a newly created node at the proper position is negligible while the cost to merge a QP T of size k is O ( k ). The nodes in a T-GQPT are numbered using a pre-order traversal. Since each RST is a rooted subtree of T-GQPT , each node in RST has the same number as the corresponding node in T-GQPT (see Fig. 3). The map-ping between RST 3 1 and T-GQPT is given by a physical address-pointer, as indicated by the dashed lines between the T-GQPT and RST 3 1 . RST 3 1 can be represented com-pactly as  X 1, 2, -1, 5, -1, 9, -1 X  where -1 indicates an end tag. This numbering scheme reduces the amount of memory usage during mining and tree operations are transformed to string operations.
Next, we utilize the concept of equivalence class [7, 5] to further optimize the candidate enumeration scheme. Any two tree encoding s Se 1 and Se 2 corresponding to RST k 1 and RST k 2 can be transformed into the strings S and S 2 respectively by removing all the -1 from Se 1 and Se The order ofthetreeencodings Se 1 and Se 2 is given by the order between S 1 and S 2 ,thatis, Se 1  X  Se 2 iff S 1  X  S example,  X 1,2,-1,6,7,-1,-1 X  &lt;  X 1,2,-1,6,-1,9,-1 X . We also use Figure 3: Numbering scheme for T-GQPT and RST RST k 1  X  RST k 2 for Se 1  X  Se 2 .

The prefix of a rooted subtree X  X  string encoding s with length i is defined as the prefix of s with i positive numbers, denoted as prefix ( s, i ), or prefix ( RST , i). By removing the prefix from s ,the suffix of a RST is obtained.

Given two k -edge RST s RST k 1 and RST k 2 , which share the same prefix and RST k 1 &lt;RST k 2 , the join result of RST and RST k 2 is denoted as RST k +1 12 = RST k 1 R S T k RST k +1 12 is a k +1-edge RST candidate. The join can be car-ried out using string operations. The first differing position, e.g., element n in RST k 1 , is obtained, and { n ,-1 } is inserted into the corresponding position in RST k 2 , yielding RST
Given two k -edge rooted subtrees RST k 1 and RST k 2 ,let s 1 and s 2 denote their respective tree encodings. RST k 1 equivalent to (denoted as = prefix ) RST k 2 if pref ix ( s pref ix ( s 2 , k )holds. Let P k denote a k -length prefix. Then a P k induced equivalence class is denoted as [ P k ]. A k -edge candidate set C k can be partitioned into equivalence classes according to = prefix . The findings from [5] is used to produce C k +1 from C k :
Theorem 1. Given a k-edge RST k i  X  [ P k ]= { RST k 1 , RST ..., RST k N } sorted in ascending order, let G rmlne ( RST = { RST k +1 ir | RST k +1 ir be the rightmost leaf node expan-sion of RST k i } ,and G join ( RST k i )= { RST k +1 ij | RST k i R S T k j , j=i+1, ..., N } . Then [prefix( RST k
The search space is organized into an ECTree .Eachnode in the tree corresponds to an equivalence class, organized as a linked list of rooted subtrees in ascending order. All the nodes at the k th level of the search tree form the k -edge candidate set C k .
The number of rooted subtrees in the search space is exponential to the size of the T-GQPT .Weobservethat many candidate rooted subtrees will be repeatedly gener-ated when there are sibling repetitions in the query pattern trees. This will lead to many redundant tests against the query pattern trees. The repeated rooted subtrees cannot be simply pruned because they may participate to form new rooted subtrees. For example, two rooted subtrees with the encoding X  X ,b,-1,b,-1 X  can be joined to form a new candidate rooted subtree with the encoding  X  X ,b,-1,b,-1,b,-1 X .
We devise a trie structure to store and trace all the enu-merated rooted subtrees that contain at least one repeated sibling node. We call this trie a Repetition Elimination Trie , or RET rie in short. Fig. 4 shows an example RET rie .The nodes that are double-circled are called punctuator .The strings obtained from the root to these punctuators are the tree encodings of the corresponding rooted subtrees. Each punctuator keeps the information of the first rooted subtree
Figure 4: An index trie for tracing repeated RST s that forms this node, including the frequency count of the rooted subtree. When a new rooted subtree with repeated sibling(s) is generated, the RET rie is looked up to check whether this rooted subtree has already been evaluated. If yes, then the pointer in the new rooted subtree is kept and the frequency count from the previous rooted subtree is ob-tained.

Rooted subtree repetitions are due to the many isomor-phic representations of a tree. We use the canonical repre-sentation to obtain a unique representation of a tree. The lexicographically maximum representation is selected among all the depth-first-search representations of a tree.
Lemma 1 (Canonized Subtree). Let T be a canoni-cal tree and n be one of its node, and S denote the subtree rooted at n .Then S is also in canonical form.
 Lemma 2 (Canonizing RST). Given a canonical tree T , and two rooted subtrees S 1 and S 2 of T .If S 1 contains no sibling repetitions but S 2 does, then S 1 is also in canonical form, and S 2 can be transformed into a canonical form by only comparing the order of the repeated siblings.
Note that the child nodes of each node have been sorted in a lexicographically ascending order during the construction of the T-GQPT . Thus, canonizing T-GQPT involves only sorting the repeated siblings.
This section describes a two pass technique to discover the frequent query patterns from a set of XML queries. The following issues need to be handled, namely frequency count and early pruning of rooted subtrees. We design a new fre-quency counting technique by taking advantage of the T-GQPT and the ECTree .
The mining algorithm requires the TIDSet for each single-branch rooted subtree. The TIDSet in T-GQPT contains only the TID s of those query pattern trees that have been merged. It is not necessary to match all the possible paths in the T-GQPT against the query pattern trees. Each valid path in the T-GQPT can be matched against the other pathsinthe T-GQPT to obtain the TIDSet s of single-branch rooted subtrees.
 Let p i denote a path from root to leaf in T-GQPT ,and P = { p 1 ,..., p N } denote the set of all such paths. The length of p i isthenumberofnodesin p i , denoted by | p i | .Let p denote the path of the first m nodes of p i ,and p i [ m ] .T IDSet denote the TIDSet of p i [ m ]. Given two paths p and q ,if p [ m ]( m =1 , .., | p | ) is embedded in q , then find the mapping position k in q . Once the position is obtained, p [ m ] .T IDSet Algorithm SBTIDSet ( T-GQPT ) Input: T-GQPT ; Output : modified T-GQPT ; P is the whole path set of T -GQPT ; ancestor-descendent edge, or repeated sibling}; for p  X  P do k= findEmbeding( p [ m ], q ); Figure 5: Computing TIDSet s of single-branch RST s is given by the union of p [ m ] .T IDSet and q [ k ] .T IDSet .This union operation will propagate to the ancestor node of p [ m ].
Consider the T-GQPT in Fig. 3. Let p = X  X ook,section,title,-1,-1 X  and q = X  X ook,section,//,title,-1,-1,-1 X . Then p [3] is embedded in position 4 of q ,and p [3] .T IDSet is { 3,4 } taking the union of q [4] .T IDSet . p [1] and p [2] will also union the new TIDSet .

The following rule optimizes the above computation: If p [ k ] isnotincludedin q ,then p [ m ]( m = k +1 ,, | p | be included in q .

Fig. 5 gives the details of the algorithm SBT IDset to compute all the TIDSet sofa T-GQPT . The function find -Embeding ( p [ m ] ,q ) determines the position of p [ m ]in q ,which canbecomputedinPTIME[4].
 Theorem 2. After executing SBT IDset on T-GQPT, the TIDSet of every single-branch RST in T-GQPT is the same as the TIDSet of this RST matching against all the query pattern trees.
TIDs are often used to expedite the mining process [2]. We have the following upper bound properties for query pattern trees with sibling repetitions and wildcards.

Lemma 3. Let rst k be the RST by expanding an edge of rst k  X  1 .Then rst k . TIDSet  X  rst k  X  1 . TIDSet .
Theorem 3 (Upper Bound). Let RST k +1 ij be a join of RST k i and RST k j .Let n 1 , n 2 ,..., n m be the leaf nodes of RST k +1 ij , and let n i .T IDSet denote the TIDSet of the single-branch RST p n i (a path from root to the node n i T-GQPT. Then n 1 .T IDSet  X  n 2 .T IDSet  X  ...  X  n m .T IDSet is an upper bound of RST k +1 ij .T IDSet .

Since we use pointers to represent the nodes in the RST , the TIDSet of a single-branch RST can directly be obtained by accessing the node in T-GQPT corresponding to the leaf node of the RST without traversing the T-GQPT .Hence,we can compute the TIDSet for each RST on the fly without the need to materialize the TIDSet .

When generating a new candidate RST , we count its up-per bound frequency immediately. If it is infrequent, then it will be pruned away. Lemma 3 ensures the Apriori prop-erty [2]: if a k +1-edge RST is frequent, then all its k -edge subtree RST s must be frequent. Together with Theorem 3, we have the following corollary for early pruning: Algorithm : 2PXMiner ( QDB , minSupp ) 
Input : QDB  X  X uery pattern tree database minSupp  X  X he minimum support 
Output : Sets of frequent RSTs in ECTree. /*Pass 1: Filtering */ 1. Scan the QDB , build T-GQP T; 2. Compute TIDSet for T-GQPT : SBTIDSet ( T-GQPT ); 3. Perform early pruning on T-GQPT ; 4. Enumerate candidate RSTs and compute the upper bound /*Pass 2: Refining-Exactly counting the RST frequency */ 5. Scan the QDB , get the exact frequency count for RSTs : ExactCount ( QPTBuffer , ECTree ), where QPTBuffer stores the QPTs . 
Corollary 1 (Early Pruning). Cutting off all those subtrees subtree(n) in T-GQPT, where | n.T IDSet | &lt;minSupp , will not affect the result of frequent pattern trees. After computing the TIDSet sofsingle-branch RST sin T-GQPT , the early pruning strategy can be applied to T-GQPT to avoid enumerating a large number of RST s. Theorem 3 gives a upper bound of the frequency count. The exact frequency count of all rooted subtrees can be ob-tained by carrying out a database scan to match potentially frequent rooted subtrees against the query pattern trees in the database. However, it is not necessary to check all the currently frequent rooted subtrees. We observe that the TIDSet of a rooted subtree consists of two parts: (1) Original TID s( oT IDSet ) indicates the QP T sthat (2) Gained TID s( gT IDSet ) indicates the QP T s that in-Thereisnoneedtomatchtherootedsubtreeagainstthe query pattern trees in oT IDSet . Instead, the rooted sub-tree needs to be matched against the query pattern trees in gT IDSet . Thus, we can partition the TID sinthe TIDSet of single-branch rooted subtrees during the computation of SBTIDSet . The following corollary computes the TID list for a rooted subtree:
Corollary 2 (Compute New TIDs). Let n 1 , n 2 , ..., n m be the leaf nodes of a RST .Let n i .T IDSet , n i .oT IDSet and n i .gT IDSet denote the all, original and new TID sof the single-branch RST p n i in T-GQPT. (a) RST.T IDSet = n 1 .T IDSet  X  n 2 .T IDSet  X  ...  X  (b) RST .oT IDSet = n 1 .oT IDSet  X  n 2 .oT IDSet  X  ...  X  (c) RST.gT IDSet = RST.T IDSet  X  RST .oT IDSet .
Fig. 6 shows the framework of 2 PXMiner . It consists of two passes.
The algorithm 2 PXMiner first carries out a database scan to build the T-GQPT by merging the query pattern trees, and storing the TID information. Next, 2 PXMiner Algorithm : UBCount ( T-GQPT , F k ) Input : T-GQPT  X  GQPT with trans. info. F k  X  X he frequent k -edge RSTs ; 
Output : Sets of potentially frequent RSTs 2. for each equivalence class ec  X  F k do/* 2~13 compute F 3. for i =0 to | ec | do 4. rst i k = ec [ i ]; 5. G rmlne = rmlne ( rst i k ); 6. for j = i +1 to | ec | do 7. rst j k = ec [ j ]; 8. rst ij k+1 = rst i k rst j k ;/*join two RSTs */ 9. compute rst ij k+1 . TIDSet ; 10. if(| rst ij k+1 . TIDSet |  X  minSupp ) 11. G join  X  rst ij k+1 ; 13. F k +1  X  ec' ; 14. if ( F k +1  X  X  X  ) 15. UBCount ( T-GQPT , F k +1 ); calls SBT IDset to compute the TIDSet for all the single-branch rooted subtrees. An early pruning on T-GQPT is also performed by removing infrequent subtrees. 2 PXMiner uses the T-GQPT to enumerate the candi-date rooted subtrees, count their frequencies and prune away the infrequent ones (see procedure UBCount in Fig.7). A special root node F 0 is introduced in the ECTree to store the 0-edge rooted subtrees.

The procedure UBCount adopts the breadth first ap-proach. The RET rie is searched for rooted subtrees that involve repeated sibling(s). If they exist, then we use the pointer to get the frequency count instead of re-computing the TIDSet . Otherwise, we insert them into the index and store their pointers there.

The notation F k in the UBCount procedure denotes the set of frequent k -edge RST s. We assume that F k is a list of equivalence classes ec s, and that each ec is an array(sequence) of RST s in ascending order of their tree encodings. | ec notes the number RST sin ec and ec [ i ]denotesthe ith element( RST )of ec .

UBCount works as follows: Lines 2-13 compute F k +1 from F k .Foreach ec in F k , lines 3-12 generate k +1-edge ec  X  X . For each rst k i in ec , line 5 performs the right most leaf node expansions by calling the procedure rmlne .In-frequent RST s are pruned. G rmlne stores the rmlne result. Lines 6-11 perform the join operation and obtain the join result G join after pruning. A new equivalence class ec  X  X s formed and is added to F k +1 . The above procedure pro-ceeds recursively(lines 14-15).
Algorithm 2 PXMiner scans the database a second time to eliminate the frequency overestimation of some rooted subtrees. We only need to match a rooted subtree against those query pattern trees indicated by RST . gT IDSet .A  X  X lock X , or a batch of query pattern trees is read to the buffer each time, and the matching of the rooted subtree is performed against the query pattern trees in the buffer. We also include an attribute isEmpty for each rooted subtree in the ECTree to indicate if the gT IDSet of the rooted subtree Algorithm : ExactCount ( QPTBuffer , ECTree ) Input : QPTBuffer  X  X uffered QPTs , with TIDSet for TID range ECTree  X  X he tree of RST search space; 
Output : Sets of frequent RSTs with exact frequency 1. P ={sequence of RSTs by post-order traversal of ECTree }; 2. for i =0 to sizeof ( P ) do 3. Let rst=P [ i ], compute rst . gTIDSet ; 4. rst . parent . mTIDSet  X  rst . parent . mTIDSet  X  5. for each tid  X  rst . gTIDSet  X  QPTBuffer . TIDSet and tid  X  rst . mTIDSet do 6. if ( Contains ( rst , QPTBuffer [ tid ]))/*check*/; 7. rst . parent . mTIDSet  X  rst . parent . mTIDSet 8. else 9. rst . count --;/*decrease the count*/ 10. prune rst if rst . count &lt; minSupp ; /*11. release the space of rst . gTIDSet , rst . mTIDSet ; */ is empty, thus avoiding the computation of the gT IDSet for such rooted subtrees.

If a rooted subtree RST is included in a query pattern tree QP T ,thenalltheprefixof RST will also be included in this QP T . We associate an attribute mT IDSet with each rooted subtree in the ECTree to keep the TID s of the query pattern trees in the current buffer that are exempted from matching. This well known  X  anti-monotone property  X  X elps to avoid unnecessary tree inclusion tests.

Since the portion of rooted subtrees with true overestima-tion is small, the procedure ExactCount in Fig. 8 utilizes a bottom-up matching strategy. A post-order traversal of the ECTree is carried out. A list P is used to denote the post-order sequence of the rooted subtrees in the ECTree . P [ i ]isthe ith element. Line 3 computes the gT IDSet of a rst dynamically. Line 4 uses the anti-monotone property to propagate the TID s up from child node rst to parent. Lines 5-10 perform the verification of the potential over-estimation of the rst . ExactCount only checks the TID s related to current QP T sinbufferandavoidsthose TID sin rst.mT IDSet .Ifthis rst is included in some QP T then lines 6-7 add the TID into the parent RST  X  X  mT IDSet .Oth-erwise, lines 9-10 decrease the frequency count of the rst and prune this rst if it becomes infrequent. The procedure Contain carries out the tree inclusion test.

Note that in ExactCount , for RST swithrepeatedsib-ling(s), we first check if the computed count already exists. If it does, then we obtain its count without performing the inclusion test. ExactCount releases gT IDSet after visiting a rst .Asfor mT IDSet , it only occupies a small amount of space since there are at most the number of rst s equal to the maximum height. It will also be released after a rst node has been visited.
We evaluate the performance of 2 PXMiner ,andcompare it with XQPMiner [6] and F astXM iner [5]. XQPMiner utilizes the rightmost branch expansion method [1] to gen-erate rooted subtrees and test them against the query pat-tern trees. F astXM iner employs TID sofrootedsubtrees to improve its efficiency. However, F astXM iner only con-siders query pattern trees without sibling repetitions. The algorithms are implemented in C++, and the experiments are carried out on a 2.4 GHz PC with 1 GB RAM running Windows XP.
We develop a synthetic query pattern generator program that is based on an input schema tree by considering some probabilities to introduce the ancestor-descendant X // X  and  X * X  edge, or to walk down or back the schema tree.
Twosetsofqueriesareusedintheexperiments. Thefirst set is generated based on the DBLP schema, while the sec-ond set is generated based on the Shakespears X  Play schema, or SSPlay for short. We expand the DBLP and SSPlay schemas into trees such that the former has 98 nodes and the latter has 67 nodes. Table 1 summarizes the properties of the datasets used. The number of nodes in T-GQPT ,the maximum depth and fanout of QP T s give an indication of the complexity of the dataset.
 Data sets T-GQPT size maxHeight maxFanout DBLP 302 6 6
SSPlay 414 5 5
Fig.9(a) and (b) show the response times for the three algorithms under varying support from 2% to 10%. Since F astXM iner accepts only query pattern trees without sib-ling repetitions, the datasets are generated with this re-striction. We observe that 2 PXMiner is about 362 times faster than XQPMiner for the DBLP dataset at 2%, and 89 times faster at 10%. 2 PXMiner is about 1.2  X  2.6 times faster than F astXM iner . Similar results are obtained for the SSPlay dataset: 2 PXMiner is about 71  X  196 times faster than XQPMiner , and about 1.5  X  4 times faster than F astXM iner .

Recall that, in 2 PXMiner , SBTIDSet obtains the TIDSet s of all single-branch rooted subtrees without scanning the database. The early pruning strategy also enables 2 PXMiner to prune a large number of rooted subtrees. Distinguish-ing between oT IDSet and gT IDSet further ensures that 2 PXMiner is superior over F astXM iner in handling query patterns with no repeated siblings. The results in Fig.9(c) and (d) for the 1 million query pattern trees confirms this. 2 PXMiner is about 4  X  9 times faster than F astXM iner for both DBLP and SSPlay datasets.
Finally, we investigate the impact of the number of query pattern trees on the response time by fixing the minimum support at 4%. Fig. 10 shows that 2 PXMiner scales lin-early for both DBLP and SSPlay datasets. 2 PXMiner is about 80 times faster than XQPMiner for DBLP and about 61 times faster for SSPlay.
We have developed a two pass algorithm called 2 PXMiner to find frequent XML query patterns. Since the search space is exponential to the size of the query pattern trees, it is im-portant to reduce the number of costly tree inclusion tests. We achieve this by developing structures and optimizations Figure 9: Comparison of XQPMiner , F astXM iner and 2 PXMiner techniques such as the transaction summary structure ( T-GQPT ), early pruning, RET rie for repeated RST tracing, and filtering and refining RST s. Experiments show that 2 PXMiner is both efficient and scalable. [1] T. Asai, K. Abe, S. Kawasoe, H. Arimura, H.
 [2] R. Agrawal and R. Srikant. Fast algorithms for mining [3] L. Chen, E. A. Rundensteiner, S. Wang. XCache-A [4] G. Miklau, D. Suciu. Containment and Equivalence of [5] L.H. Yang, M.L. Lee, W. Hsu. Efficient Mining of XML [6] L.H. Yang, M.L. Lee, W. Hsu, S. Acharya. Mining [7] M. Zaki. Efficiently Mining Frequent Trees in a Forest.
