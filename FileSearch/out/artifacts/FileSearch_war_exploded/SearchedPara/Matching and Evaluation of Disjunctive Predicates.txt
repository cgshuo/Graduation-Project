 New optimization techniques, e. g., in data stream management systems (DSMSs), make the treatment of disjunctive predicates a necessity. In this paper, we introduce and compare methods for matching and evaluating disjunctive predicates.
 Categories and Subject Descriptors: H.3 [ Information Systems ]: Information Storage and Retrieval; H.3.3 [ Information Storage and Retrieval ]: Information Search and Retrieval X  Information filtering General Terms: Algorithms, Performance Keywords: Disjunctive predicates, predicate matching, predicate evaluation, data stream sharing
Except for a few publications which have dealt with the issue in the database field, disjunctive predicates, which are known to be complex to handle, have largely been neglected in the context of query optimization for traditional database management systems (DBMSs). Instead, query optimization generally limits itself to considering conjunctive query predicates since well-known ways for efficiently managing such predicates exist. The main argument for justifying the neglect of disjunctive predicates has been that such predicates do not occur often in practice. While this argu-ment might be true for traditional database systems and applica-tions, it is not correct for new and evolving applications and opti-mization techniques, e. g., in the domains of semantic caching and data stream management systems (DSMSs). One such optimiza-tion technique is data stream sharing [1] which reuses data streams in a distributed DSMS for satis fying multiple si milar continuous queries, thus reducing network traffic and computational load.
In this paper, we introduce and compare methods for matching and evaluating disjunctive predicates. Predicates in our context are disjunctions of conjunctive predicates. Each conjunctive predicate is a conjunction of atomic predicates. Atomic predicates are of the form v  X  c ,where v is a variable, c is a constant, and { = , = ,&lt;,  X  ,&gt;,  X } .
Predicate matching is the problem of deciding whether a predi-cate implies another and, if this is not the case, how the other pred-icate can be altered in order for the implication to be valid. More formally, given two predicates p and p , matching p with p returns ( true , p ) ,if p  X  p ,and ( false ,  X  p ) ,where  X  p is a relaxed version of p such that p  X   X  p (and of course also p  X   X  p ), otherwise.  X 
A graphical representation of two example predicates p 1 : 3 )  X  ( a  X  12 )  X  ( b  X  0 )  X  ( b  X  5 ))  X  (( a  X  9 )  X  ( a 2 )  X  ( b  X  8 ))  X  (( a  X  0 )  X  ( a  X  5 )  X  ( b  X  1 )  X  ( b and p 2 : (( a  X  1 )  X  ( a  X  8 )  X  ( b  X  2 )  X  ( b  X  4 )) shown in Figure 1.
Before the actual predicate matching algorithms, we first intro-duce a simple quick check (QC) algorithm that can be combined with each of the matching algorithms. It tests for a conjunctive subpredicate c , whether it implies at least one of the conjunctive subpredicates c of a given predicate p . The implication check for conjunctive predicates can easily be done by checking the bounds of c for containment in the intervals defined by the atomic predi-cates in c for all dimensions. If the quick check returns true, nothing more remains to be done for the tested subpredicate c because it is clear that it already matches predicate p as is.

Concerning our example, comparing the only conjunctive sub-predicate of p 2 to each conjunctive subpredicate of p 1 obviously yields no match, i. e., the quick check returns false. This is due to the fact that none of the tested implications is valid which can eas-ily be seen from Figure 1. The dashed box of p 2 is not completely contained in any one of the three solid boxes of p 1 .
The easiest way to perform predicate matching is to completely skip the predicate implication checking and go directly to the relax-ation part. This is the idea of the heuristics with simple relaxation (HSR). When matching a predicate p with a predicate p , all con-junctive subpredicates of p are disjunctively added to p . Since this solution does not perform any implication checking at all, it will miss matches already present in the original predicates and perform unnecessary relaxations in general.

The situation can be improved by combining the approach with the quick check algorithm of Section 2.1. The matching problem for disjunctive predicates is thereby basically reduced to the im-plication problem for conjunctive predicates. In this solution, two nested loops compare each conjunctive subpredicate of p to each conjunctive subpredicate of p , checking for implication. If, for each subpredicate of p , a matching subpredicate in p is found, the matching succeeds, else it fails. Obviously, this approach might fail even though p and p do match. In the running example, the only subpredicate of predicate p 2 does not match any of the three sub-predicates of predicate p 1 directly. However, it matches the whole predicate p 1 , as can be seen from Figure 1, which this algorithm would not realize. Therefore, a mismatch would be reported al-though the predicates actually do match. Predicate relaxation in the case of a mismatch is simply done by adding the concerned subpredicate of p to p using a disjunction.

The advantages of the HSR algorithm are that it is fast and easy to implement. The disadvantages of the approach obviously are that it generally misses matches X  X ctually all matches if it is used without the quick check X  X nd that it can therefore cause unneces-sary predicate relaxations which affects the performance of future predicate matching and evaluation processes.
The heuristics with complex relaxation (HCR) avoids the in-crease in the number of subpredicates in p induced by HSR at the expense of potentially producing only approximate results. For each conjunctive subpredicate in p , HCR relaxes one of the con-junctive subpredicates in p in order for it to match the subpredicate of p if no direct match between subpredicates has been found. In the DSMS scenario, relaxing a subpredicate means employing a less restrictive filter on the corresponding data stream, therefore in-creasing network traffic. Thus, the subpredicate of p which needs the least amount of relaxation in order to match p should be re-laxed. The situation is illustrated in Figure 1 for our running exam-ple. The dotted line marks the relaxation of a subpredicate of p In general, this kind of relaxation causes the data stream to contain unnecessary data. However, in the example, parts of this data are already covered by another conjunctive subpredicate of p 1 be seen from Figure 1. Therefore, additional unnecessary network traffic is only caused by the inclusion of the hatched area in Fig-ure 1 in this specific case. HCR, like HSR, can be combined with the quick check algorithm of Section 2.1 to detect obvious matches before starting the more complex relaxation algorithm.
 Similar to HSR, HCR is relatively fast and easy to implement. Furthermore, it does not introduc e any additional disjunctions in the stream predicate. The disadvantages are that the approach still misses matches and therefore performs unnecessary predicate re-laxations in general. Additionally, HCR, in contrast to HSR, can lead to the inclusion of unneeded parts of the data space in the relaxed predicate and therefore cause unnecessary network traffic through false drops. This necessita tes additional filtering to obtain the exact result if approximate results are not acceptable.
The exact matching (EM) algorithm is a split algorithm that al-ways correctly detects a match of p with p . It does not miss matches like the heuristics above nor does it report false matches. Predicate p is split along its dimensions according to the bound-aries of the overlapping intervals of p . Only if, at the end of the matching process, all parts of p have been successfully matched, a match is reported. Otherwise, p is relaxed. The example of Fig-ure 1 illustrates the case of a complete match between predicates. In case of a mismatch, we relax p by disjunctively adding the un-matched subpredicates of p . Note that the HSR and EM algo-rithms, as opposed to the HCR algorithm, never add unnecessary parts of the data space to p during relaxation. Again, the quick check presented in Section 2.1 can be executed in combination with the EM approach to check for matching subpredicates in advance before starting the more complex relaxation algorithm.

The exact solution has the advantage of determining matches be-tween predicates in an exact way, i e., producing no false matches and X  X s opposed to the heuristics X  X inding all existing matches. Therefore, the approach does not cause any unnecessary predicate relaxations. Also, it can exactly identify the non-matching parts of p . The major disadvantage of the exact solution is its high al-gorithmic complexity, which is exponential in the number of sub-predicates in the predicates to be matched. This might slow down the optimization process considerably for predicates with many dis-junctions and makes the algorithm inapplicable for larger problem sizes. In such cases, the heuristics have to be used.
Apart from predicate matching, efficient predicate evaluation is of major importance in a DSMS. Predicate evaluation is the prob-lem of deciding whether a data item satisfies a predicate or not. More formally, given a predicate p and a data item i , evaluating p against i returns true, if, for all dimensions referenced in p ,the value of i in the corresponding dimension lies within the interval defined for that dimension in p . The goal is to evaluate a given predicate against as many data items per time unit as possible, i. e., achieve a high throughput. In the following, two approaches for predicate evaluation are presented.
We use the term standard evaluation (SE) to denote a simple se-quential scan. It evaluates a given predicate p against a given data item i by iterating over the conjunctive subpredicates c of p and testing for each dimension, whether the value of i in that dimension lies within the interval defined for the same dimension in c .As soon as a subpredicate containing the values of i in each dimension is found, the algorithm terminates and returns true. Only if, af-ter inspecting all conjunctive subpredicates c of p , no subpredicate containing i could be found, it returns false.
Considering the facts that the exact matching algorithm is only applicable for small problem sizes and the approximate results of the HCR algorithm are often not desirable, a switch to the HSR algorithm for larger problem sizes, i. e., larger numbers of dimen-sions and subpredicates, seems necessary in many cases. Since this algorithm X  X ith as well as without quick check X  X an introduce a considerable number of additional disjunctions in predicates, the standard evaluation algorithm above will quickly become ineffi-cient. Therefore, an optimized predicate evaluation strategy that better handles large numbers of subpredicates is needed.

We can optimize predicate evaluation using multi-dimensional indexing. We use the term index-based evaluation (IE) to denote the evaluation algorithm with index support. It differs from stan-dard evaluation in that it uses a multi-dimensional index structure to represent the predicate. To evaluate the predicate against a data item, the algorithm simply executes the containment method of the index with the data item as its only parameter. The evaluation is then performed completely by the index, returning true if the pred-icate covers the data item and false otherwise. Note that the match-ing efficiency of the QC and EM algorithms of Section 2 can also benefit from multi-dimensional indexing.
In this paper, we have presented various methods for matching and evaluating interval-based disjunctive predicates. Matching in-volves deciding whether a predicate implies another and, if this is not the case, how the other predicate can be altered in order for the implication to be valid. More details and an extensive performance evaluation can be found in the full paper [2].

An interesting issue for future work is to design a specialized in-dex structure that specifically fits the needs of indexing disjunctive predicates. In this course, the functionality of predicate matching could be fully or partially incorporated into the index itself.
