 With the expansion of technologies that generate graph data in form of stream like Internet, social network, sensor network etc. into our everyday life, graph stream classification is gaining significant research interest in data mining and machine learning community. Graph stream classification is a two step process, where in the learning step, features are extracted from each training graph and a classification model is built, and in the classification step, class labels of each test graphs are predicted using that classification model.
Graph is a very popular data structure, suitable for representing schema-less data like representing various activities among nodes in a network. In many graph streams, various side attributes are associated with each graph which may contain semantically relevant information to the graph linkage structure. These informations may contribute to build a more discriminative classification model. Letuslookatsomeexamples. First , each article residing in scientific reposi-tories(e.g. Google Scholar [1], DBLP [2]) can be represented using a bidirected authorship graph where authors are nodes and their co-author relationships con-stitute bidirectional edges among the nodes. Along with each graph, various types of side attributes like terms and key words of the paper can be associated. Second , communication via message passing among users in a social network in a small time window can form a directed graph where users are nodes and messages sent and received among users m ake directed edges among the corre-sponding nodes of users of those messages. Different types of side attributes like user locations, user profile informations, message types (e.g. personal message, group chat) and platforms (e.g. PC, mobile) can be associated with each graph in the stream. Hence, side information should be incorporated along with graph linkage structure in the graph classification process to improve classification ac-curacy.

Features that only occur with high fre quency in objects with one particular class label, used to discriminate among objects with two or more different class labels, are known as discriminative features. The aim of any classification algo-rithm is to build a classification model using discriminative features, which help to make finer distinctions among objects with different class labels, thus improv-ing classification accuracy. By considering side information along with the graph linkage structure, dimension of the feature representation of a graph object can be increased. This increased dimension ality with features related to the graph structure, can be of great use to find more discriminative features from graph objects, hence increasing classification accuracy.

One of the inherent challenges in graph stream classification is storing the received objects from the st ream and extracting featu res from the enormous vol-ume of data. For example, there are 4 . 2  X  10 9 IPv4 addresses. So there can be 4 . 2  X  10 9 distinct nodes and 9 . 2  X  10 18 distinct edges in the web graph stream. Storing this huge amount of data is intractable. Traditional graph classification algorithms require multiple scans over the whole data, which is not possible in stream scenario. So a summary of the graph stream is saved for future mining. As information loss is occurring while saving a summary of the graph stream, the results will be approximate rather than exact.

Various graph mining approaches have been defined in recent times to solve different tasks like classification [3], correlation mining [4], recommendation on social networks [5] etc. Though there are some approaches for graph stream clas-sification [3][6][7][8], to the best of our knowledge none of them considers side information in the mining process. Aggar wal et al. [3] proposed a probabilistic discriminative subgraph mining approach, where the received graphs are at first compressed and saved into a summary table using two random hashing schemes and then frequent and discriminative subgraphs are mined from that table to build a rule-based classifier. A clique based approach was proposed by Chi et al. [6] where the graphs are at first compressed into a fixed size node space and then discriminative clique patterns are extracted from each compressed graph to build a rule-based classifier. Discriminative hash kernel approach was proposed by Li et al. [7] to classify graph streams. Guo et al. [8] proposed an approach for graph stream classification which uses a combination of hashing and factorization of graphs. Yu et al. [9] considered side information in the graph stream clustering process and their experim ental results showed the benefit of considering side information in the clustering process. One major drawback of the existing graph stream classification techniques is that, they do not consider side information in the classification process and the side inf ormation can help to improve classifi-cation accuracy.

Inspired by this drawback of the current graph stream classification tech-niques, in this paper we are proposing an approach GSCS for graph stream classification which considers side information. In GSCS ,wehavemostlyfol-lowed the discriminative clique based approach proposed by Chi et al. [6] for graph structure mining. The volume of side information in the stream scenario can also be potentially infinite. So a hash based technique is used to tackle this storage problem and extract discriminative features from side information. Finally a majority voting classifier, inspired from Chi et al. [6] approach, is de-signed for classifying the future stream.

The rest of the paper is organized as fo llows: Section 2 explains our proposed approach in detail with necessary exampl es and algorithms. Section 3 focuses on the performance analysis of our proposed technique and shows the benefit of considering side information in the classification process. Finally we bring the paper to a close in Section 4. First, we introduce the problem formulation. Assume we have a stream of graphs GS denoted as { G 1 ,G 2 ,...,G n ,... } . E represents the set of all distinct edges, { edge between the two nodes X i and Y i .Eachgraph G i is drawn on the sub-set of massive node set V and contains a subset of edges from set E . GS also has d different types of side information associated with it, denoted by  X  = { T 1 ,T 2 ,...,T d } . Each type of side information T l ,where l =1 , 2 ,...,d has multiple values S l = { S l 1 ,S l 2 ,...,S ln ,... } . Our aim is to incorporate side information in the graph stream classification process in order to improve the classification accuracy over the existing graph stream classification algorithms.
Now, we give an overview of our GSCS approach. GSCS is composed of four modules, showed in Figure 1. Each graph object consisting of graph structure and side information, is received from t he stream and processed according to GSCS approach. The first module hashes a graph X  X  edges into a fixed-size edge set and then maximal cliques are mined from the compressed graph. In this module, we have modified the approach in DICH [6] by using a more efficient algorithm, for maximal clique detection for better performance. Second module is followed from the approach stated in DICH [6], for managing the the ex-ponential number of cliques into a fixed-size feature space. The third module is used for side information mining and its design is inspired from DICH [6]. Finally, we have designed the fourth module to incorporate side information in the classification process.

As in stream scenario, due to the high incoming rate of enormous amount of data, a summary of stream needs to be saved for future mining. An in-memory data structure, enabling high speed acce ss-update operations, is used for stor-ing the summary. DICH [6] used one in-memory table, where GSCS will be using ( d + 1) in-memory tables. One table for the summary of the graph linkage structure, the other d tables for the summary of the d types of side information. These modules are briefly des cribed in Section 2.1-2.4. 2.1 Clique Detection In this module, the original e dge set of each received graph G i is hashed into a compressed edge set, and maximal cliques are mined from the compressed edge set to be used as feature representation of the linkage structure of graph. In graph stream mining, massive universe of nodes and continuous arrival of data make storing the original stream intractable. So a summary of the stream needs to be saved for mining purpose. Hence, we hash the original edge set of graph G i to a compressed edge set. Edge compression involves hashing the two node labels of an edge into a fixed-size node space { 1 ,...,N } , and then considering the two hashed node label values as a compressed edge. Each time an edge is mapped into a compressed edge, the weight of the compressed edge is increased by 1. If multiple edges of G i are mapped into the same index due to hash collision, the weight of that compressed edge is set to the number of edges that result into the same index after applying hash function.

Compressed representation of the original graph is significantly smaller and it is now feasible to run clique detection al gorithm. Different weights of compressed edges are taken into account and maximal cliques are mined at different edge weight threshold. Graphlet basis estimation algorithm [10] is adapted for this purpose. Though DICH [6] used the naive BronKerbosch algorithm [11], for improved performance, GSCS uses BronKerbosch with pivoting technique [12].
Let G i be the compressed graph of G i . G ( t ) i denotes the compressed graph which consists of only compressed edges with weight  X  t .Let max ( G i ) denotes the largest and min ( G i ) denotes the smallest edge weights in G i , respectively. For maximal clique detection, at first we apply threshold to the compressed G i at different weight level t to get G BronKerbosch with pivoting algorithm [12] is used at every G ( t ) i to identify all the maximal cliques. All the cliques found in G ( t ) i at different weight levels, { procedure is shown in Figure 2 and detailed in Algorithm 1. Algorithm 1. Clique Detection in Compressed Graph 2.2 Clique Hashing Each graph received from the stream is co mpressed and decomposed into maxi-mal cliques and then frequent and discriminative cliques are identified to build a rule based classifier. As there can be 3 n/ 3 maximal cliques [13] from a graph of n vertices, so there can be exponenti al number of cliques generated from the compressed node space. It makes the task of quantifying clique patterns for discriminative feature mining infeasible. To tackle this problem, each clique is hashed into a fixed-size feature space and the regarding information is updated in an in-memory pattern class table.
 An in-memory pattern class table  X  0 , consisting of P rows and M columns, Algorithm 2. Clique Hashing where P isthesizeofthefeaturespaceand M is the number of distinct class labels in stream, is maintained for storing the graph structure summary. For each clique C i,j in clique set C i of graph G i , a hash value H i,j  X  X  1 ,...,P } is generated. When a clique with class label L i generates hash value H i,j ,theentry at  X  0 [ H i,j ,L i ] is incremented by 1, so that the clique pattern C i,j contributes to the class label L i . This in-memory clique pattern class table  X  0 is continu-ously updated by cliques as with the progression of the stream. The steps of this procedure is given in Algorithm 2. 2.3 Side Information Hashing As the total number of aggregated side attributes associated with each received graph from the stream can be potentially infinite and it is not feasible to store them directly, so hashing is applied to save a summary of the side information. There are d pattern class tables for storing the summary of the d different types of side information. Each table consists of P rows and M columns where P is predefined size of the feature space and M is the number of distinct class labels in the stream. All types of side information values are hashed into the same fixed-size feature space { 1 ,...,P } using the same hash function. Each side information value S lj ,where j =1 , 2 ,...,q and q is a finite number, of type T ,where l =1 , 2 ,...,d , associated with each graph G i of the graph stream is hashed to generate a hash index H i,lj  X  X  1 ,...,P } . The i X  X h graph has class label L i . Then the entry  X  l [ H i,lj ,L i ], in the side information pattern-class table  X  l is incremented by 1. These st eps are shown in Algorithm 3.
 Algorithm 3. Side Information Hashing 2.4 Discriminative Feature Extraction and Classifier Construction GSCS uses ( d + 1) in-memory pattern class tables where  X  0 is for saving graph linkage structure summary and  X  1 ,..., X  d are for storing a sketch of each types of side information in their corresponding table.  X  and  X  , two parameters are used for discriminative feature extraction from these tables.  X  is the frequent pattern threshold used for selecting frequent features and  X  is the discriminative pattern threshold used for selecting frequent yet discriminative patterns [6].
At first, for identifying frequent features, the values in each row of a table are summed up and divided by the maximum row sum in that table. The resulting values indicate the occurrence frequency of a set of cliques in the graph stream. Frequent threshold parameter  X  is then used to filter out the infrequent patterns whose occurrence frequency are less than  X  . The remaining patterns are candi-date for the discriminative feature selection.
 ratios of the features in M classes. For a candidate feature, its occurrence ratio in column i ,where i =1 , 2 ,...,M , indicates the probability that the feature belongs to class label i . Higher occurrence ratio of a feature on a certain class indicates a better discriminative capability. Discriminative threshold parameter  X  is used to select features whose maximum ratios  X   X  . The process of finding discriminating features from pattern class table using the threshold pair (  X ,  X  ) is shown in Figure 3.

Then, a majority voting rule-based cl assifier is constructed, which has ( d +1) sets of discriminative features, 1 set corresponds to the discriminative clique patterns and another d sets correspond to the sets of discriminative features extracted from the d side information pattern class tables. Given, a test graph G test , the clique set C of G test is extracted using Algorithm 1. All distinct types of side information are directly hashed and stored into the array of sets SI ac-cording to their side information type. Then, all the extracted features from graph G test are given to the majority voting based classifier and for each hashed feature that has a corresponding discriminative pattern of its own type, the class label of that discriminative pattern is taken a vote for the class label of the graph G test . Finally the label of the test graph G test is determined from the majority of the class label votes from the classifier. This is detailed in Algorithm 4. Algorithm 4. Graph Stream Classification with Side Information In this section we will present the experime ntal results and techniques. We tested our proposed approach, GSCS for effectiv eness and efficiency and compared the results with existing DICH [6] approach. We used two real word data sets, CORA [14] and IMDB [15].
 CORA Data Set. The CORA data set contains scientific articles on computer science. To create a graph stream from the articles we considered the co-author relationship as edges of the graph. Research topics were used as class labels. Terms and citations were used as side information.
 IMDB Data Set. The Internet Movie Database, IMDB, is a website which contains detailed information about movies and TV shows. We scraped a sample of movies from IMDB which contains 3535 movies released in United States during 2000-2015. We created graph object from each movies using actor-pair as edges. The genre of the movies were u sed as class labels. We extracted two types of side information: (a) plot keywords and (b) directors.

We used 90% of each data set as training data and used the other 10% as testing data. There are 4 parameters to consider while using GSCS and DICH, frequent pattern threshold  X  , dicriminative pattern threshold  X  , the node space size N, the hash space size P. We vary the parameters and show how GSCS performs in comparison to DICH. The default values for parameters are:  X  = .05,  X  = .3, N = 500, P = 10000. All tests were run on an Asus K550JK running Windows 8.1 x64 with a 2.8 GHz Intel Core i5-4200H CPU and 8 GB of main memory. Both approaches were implemented with C++ and were compiled with tdm-gcc 4.9.2.
 Figure 4, 5, 6 and 7 shows different eff ectiveness measures for GSCS and DICH in both data sets. We measured pr ecision, recall, balanced accuracy and F1 score for multi-class classification [16]. From the graph it is apparent that GSCS performs better than DICH in terms of classification effectiveness. The extra dimensionality provided by the side information helps GSCS to be more effective.

Figure 8 shows that GSCS takes a little bit extra time than DICH. This is the overhead of processing the side information along with the graph structure. GSCS spends most of its time in feature extraction from the graph and side information. GSCS can process on an average 600 graphs per second in both data sets which is quite good for the stream scenario.
Since GSCS does not store any data other than in-memory tables for graph and side information, the memory usage is almost constant. In our experiments with both data sets the maximum memory used by GSCS was 100MB. This makes GSCS ideal for the stream scenario.

From the above experimentation, we can conclude that, GSCS is effective in classification of graphs with side information and efficient in the graph stream scenario. Also GSCS outperforms the state of the art graph stream classification approach DICH by providing better performance. In this paper we proposed the first approach which incorporates side information in the classification process of graph stre ams. The existing graph stream clas-sification algorithms only consider the graph structure and do not utilize side information in the classification process. Many real life applications generate graph streams where side information is associated with each graph, which con-tains semantically meaningful information relevant to the graph structure, thus can help to build a more accurate classific ation model. Mining graph streams is a challenging problem because of the high computational cost for graph struc-ture mining and storage difficulty in stream scenario. In our proposed approach GSCS , a graph is first compressed and decomposed into maximal cliques. Then both clique patterns and side information are hashed and stored into correspond-ing in-memory summary tables for discriminative feature extraction to build a majority voting classifier. The experim ental results show that our proposed ap-proach significantly outperforms state-of-the-art method [6] which only considers graph structure and thus depicts the potential of side information in the graph classification process. Experimental results also infer that our approach is effi-cient and scalable enough to be applied in real life graph stream scenario.
