 REGULAR PAPER Kedian Mu  X  Zhi Jin  X  Ruqian Lu  X  Ya n Pe n g Abstract Eliciting requirements for a proposed system inevitably involves the problem of handling undesirable information about customer X  X  needs, including inconsistency, vagueness, redundancy, or incompleteness. We term the require-ments statements involved in the undesirable information non-canonical software requirements. In this paper, we propose an approach to handling non-canonical software requirements based on Annotated Predicate Calculus (APC). Informally, by defining a special belief lattice appropriate for representing the stakeholder X  X  belief in requirements statements, we construct a new form of APC to formalize requirements specifications. We then show how the APC can be employed to char-acterize non-canonical requirements. Finally, we show how the approach can be used to handle non-canonical requirements through a case study.
 Keywords Software requirements  X  Inconsistency  X  Redundancy  X  Incompleteness  X  Vagueness  X  Paraconsistent logic 1 Introduction It seems to be inevitable to confront problematical information about customer X  X  responsibilities, and perspectives. Different stakeholders often focus on different aspects of a problem, use different terminologies to express their descriptions, and have conflicting goals. It is not surprising that inconsistency is a pervasive prob-lem throughout the requirements stage. Viewpoints-based approaches have been proposed as a way to manage inconsistent information gathered from multiple sources [ 9 ].
 result from an incorrect modeling or merging of several sources. For several rea-sons, the problem of redundancy of a requirements specification is worth noting. At first, removing redundant requirements information leads to a simplification source limitations. Every redundancy will consume the resources. When project timelines are short, and resources are limited, developers want to make sure the requirements that incur a high cost but provide relatively low value are avoided. Moreover, simplifying a requirements specification leads to a new specification process of removing redundancy can improve the development team X  X  shared un-derstanding. Thirdly, the simplification of requirements specification may improve the quality of system-to-be, as a large amount of redundancy may affect the run-ning efficiency of system-to-be.
 about some situation. However, it is also common to have  X  X oo little X  informa-tion about some other situations in practice. This is the third situation. The initial requirements statements for the proposed system is often incomplete and possi-bly vague [ 25 ]. As the first stage of software development, requirements elicita-tion just starts with some disorganized observations of related domains and frag-mented descriptions of customer X  X  demand in many cases. Most customers do not accustom themselves to the way of communication with software developers. For instance, customers always neglect providing common-sense requirements. Thus, developers often obtain a  X  X ough sketch X  [ 12 ] of the customer X  X  demand. More-over, the lack of available information inevitably makes clarification of some re-quirements information be a difficult task. To make matters worse, vagueness and incompleteness may result in difficulties in the following stages of software de-velopment. For example, vague descriptions may lead to uncertainty in decision during the design stage.
 any software requirements statements involved in the following four distinct unde-sirable characteristics of a requirements specification: inconsistency, redundancy, non-canonical software requirements is one of the important activities during the requirements verification stage that can improve the communication between the analysts and the customer and hence assist with mining the customer X  X  real needs. sistency handling strategies, including resolving the inconsistency immediately, ignoring it completely, or tolerating it for a while. To support this, several logics that allow continue reasoning in the presence of inconsistency have been proposed incompleteness of requirements specifications, and the related techniques for checking redundancy of requirements specifications, are underdeveloped. Some approaches touch on the topic. For example, in goal-oriented RE such as I  X  [ 21 ] and AGORA [ 13 ], incompleteness of specifications is detected by refining and elaborating goals in the form of AND/OR graph. However, completeness is always associated with consistency and correctness of requirements. Zowghi et al. [ 25 ] argue that there is an important causal relationship between consistency, completeness, and correctness of requirements.
 ments. As usual in vague information processing, the stakeholder X  X  belief in vague requirements statements plays an important role in handling vague requirements. practice. Hence, a complete representation of the vague requirements statement should focus on both the statement and the stakeholder X  X  belief in that. None of these techniques are appropriate for representing vague requirements information. Moreover, the redundancy in specification has not yet attracted much attention. We argue that vague requirements statements should be paid much more atten-tion, and even for clear requirements statements, it is difficult to distinguish which statements are involved in inconsistency or are redundancy and which statements are missing. It may be desirable to provide an uniform tool to handle inconsis-tency, incompleteness, and the related problem of redundancy of requirements specifications including vague requirements statements as well as clear require-ments statements.
 ware requirements based on Annotated Predicate Calculus (APC) in this paper. APC [ 14 ] is a form of paraconsistent logic. In APC , classical atomic formulae formally, an annotation r , may be viewed as strength of reasoner X  X  belief in l , thus it provides a promising tool to represent requirements statements with different levels of belief.
 specification that contains vague requirements statements. We then characterize inconsistency, redundancy, and incompleteness of the requirements specification based on APC, respectively. Furthermore, we propose a strategy for handling non-canonical requirements based on reasoning with specifications.
 APC. Section 3 applies this calculus to representing requirements specifications and to characterizing non-canonical requirements. Section 4 presents a framework for handling non-canonical requirements based on APC. In Sect. 5, we illustrate the strategy with an example. Section 6 compares our work with the related works. Finally, we conclude this paper in Sect. 7. 2 Preliminaries: Annotated Predicate Calculus APC [ 14 ] is a form of paraconsistent logic. The syntax and the semantics of APC is based on classical logic, except that the classical atomic formulae are annotated with values drawn from a belief semilattice (BSL) X  X n upper semilattice with the following properties [ 14 ]: (2) For every s  X  BSL ,  X  X  X  s  X  (  X  is the semilattice ordering); (3) lub ( t , f ) = ,where lub denotes the least upper bound.
 iff a = lub ( a , b ) and a &gt; b iff a  X  b and a is different from b . Two typical examples of BSL , four-valued BSL [ 1 ]and BSL with defaults [ 10 ], are shown in Fig. 1 . In both of them, the lattice elements are ordered upwards. The special BSL appropriate for our problem is defined later in Fig. 2 .
 predicates, function symbols, constants, variables, quantifiers, and logical connec-tives. The only syntactic difference is that atomic formulae in APC are constructed from those of predicate calculus (e.g. l ) by appending to them annotations that are drawn from BSL (e.g. l : r ). Informally, an annotation r represents strength of reasoner X  X  belief in the truth of the statements annotated with r . Another particu-predicate formulae appended by annotations to contrast with the  X  in annotated predicate formulae in APC .Andin APC the implication  X   X   X  is defined as  X   X   X   X  .
 is a triplet D , I F , I P .Here D is the domain of I ; I F associates to each k -ary function symbol f of L a mapping I F ( f ) : D k  X  X  X  D ;and I P associates to each m -ary predicate symbol p a function I P ( p ) : D m  X  X  X  BSL .
 extended to terms as usual in the first-order logic by combining v and I F : v( f (. . . , s ,...))) = I F ( f )(...,v( s ), . . .) . So, for a term t , v( t )  X  D . follows the standard definitions of predicate calculus: I | v  X   X   X  iff I | v  X  or I | v  X  ; I | v  X   X   X  iff I | v  X  and I | v  X  ; I | v  X   X  iff not I | v  X  ; I | v (  X  X )  X  iff I | u  X  ,forevery u that may differ from v only in its X -value; I | v (  X  X )  X  iff I | u  X  ,forsome u that may differ from v only in its X -value. every valuation v . Correspondingly, a semantic structure I is a model of a set of formulae S if and only if every formula  X  in S is satisfied by I . A set of formulae a model of  X  .
 and natural class of belief semilattice , APC has a sound and complete resolution-based proof theory.
 by epistemic embedding. That is, for consistent systems, APC yields the same consequences as the standard predicate calculus. In detail, the epistemic embed-ding views formulae of classical logic as beliefs and interprets negation,  X  p ,in ample, under epistemic embedding, S ={  X ,  X   X ,  X  } is embedded in APC as S e ={  X  : t , X  : f , X  : t } . Furthermore, APC is able to isolate that information causes inconsistency from the information that intuitively has nothing to do with inconsistency, thereby preserving the original meaning of the  X  X nspoiled X  data in classically inconsistent set of formulae.
 Example 2.1 Let the belief semilattice be BSL with defaults [ 10 ]. Consider the following set of clauses: (i) p : t  X  X  q : t , (ii) q : t , (iii)  X  p : t  X   X  : t , (iv)  X  : dt  X  X   X  : dt , (v)  X  : df , (vi)  X  : t , (vii)  X  : t  X  X   X  : t .
 We can get the following conclusion: (viii) p : t ( resolvent of (i) and (ii) ) , (ix)  X  : t ( resolvent of (viii) and (iii) ) , (x)  X  : dt ( resolvent of (ix) and (iv) ) , (xi)  X  : d ( resolvent of (x) and (v) ) , (xii)  X  : t ( resolvent of (vi) and (vii) ) . 3 What are non-canonical software requirements? 3.1 Formalizing requirements specification In practice, the level of stakeholder X  X  belief in a requirements statement could be viewed as an abstract measurement of vagueness of that. The lower levels of be-lief in vague requirements statements distinguish the vague information from clear requirements statements. In this sense, a complete representation of the require-ments should focus on both the statement and the level of stakeholder X  X  belief in that.
 quirements statements. As mentioned earlier, epistemic embedding has been It means that we can embed clear requirements statements into APC .Wemay also define some special BSL appropriate to vague requirements statements. For soning. It may provide a technical basis for potential modification of requirements specification.
 representing vague information. As mentioned earlier, the truth value appropri-ate for vague information should be viewed as a relative measure of degree of its vagueness. In fact, it is difficult to measure the degree of vagueness based on nu-merical values in many cases. We may just differentiate vague information based on several qualitative levels of vagueness, such as  X  X ossible, X   X  X ery possible, X  and  X  X ertain. X  in practice. For example, we may define 7-valued belief semilattice L p and 10-valued belief semilattice L p v .TheyareshowninFig. 2 . As usual, the meanings of values are explained later.
 the value  X  is explained as To Be Determined ( TBD ). Informally, the value t p be false .Thevalue t v signifies that it is very possible to be true .Thevalue f v possible to be inconsistent , and the values v signifies that it is very possible to be inconsistent .
 cific BSL used in this paper. It is the simplest BSL appropriate for representing vague information. As mentioned in Sect. 2, resolution, factorization, elimination, and reduction are sound derivation rules in APC ,and APC with regard to L p has a sound and complete resolution-based proof theory.
 Example 3.1 Consider the following set of clauses: (i) p : p  X  q : f p , (ii) p : t  X  X  q : f p , (iii)  X  p : p , (iv) p : f , (v)  X  p : .
 The following refutation illustrated the proof procedure: (vi) p : p  X  p : t ( resolvent of (i) and (ii) ) , (vii) p : t ( resolvent of (vi) and (iii) ) , (viii) p : ( reduction of (vii) and (iv) ) , (ix) empty clause ( resolvent of (viii) and (v) ) .
 APC and to characterize non-canonical requirements based on reasoning with specifications.
 Clear requirements statements Clear requirements statements may be translated into classical logic [ 11 ]. More-over, classical formulae could be embedded in APC by epistemic embedding .That is, given a classical clause, its positive literals are embedded using the truth value t , and its negative literals are embedded using the truth value f . Example 3.2 Consider {  X   X   X ,  X   X   X  X   X  } . It could be embedded in APC by epis-temic embedding as follows: Vague requirements statements Vague requirements statements could be translated into formulae with annotations drawn from L p . A particular thing is that there is at least an annotation drawn from { t p , f p } in each formula. We also use formulae with the annotation  X  to rep-resent the TBD requirements. We give an example to illustrate the representation of requirements statements.
 Example 3.3 Consider the following statements about customer X  X  needs.  X  stakeholder A : If a user X  X  application for borrowing a book is judged to be  X  stakeholder B : In many cases, if a book is reserved for a user, then the user  X  stakeholder C : At present, there is no consensus that a user with an overdue Obviously, we may use the following formula to represent the information pro-vided by A .
 The information provided by B and C is vague. But it is not difficult to get the following representation of the information provided by B .
 The information provided by C maybeviewedas TBD . It may be represented as follows: of the form  X   X   X  .  X  and  X  are called antecedent and consequent of the re-quirements statement, respectively. We use C and V to stand for a set of clear requirements statements and a set of vague requirements statements, respectively. Finally, we use  X  to denote a set of TBD requirements. In the rest of the paper, we use to denote C  X  V if no confusion arises. 3.2 Characterizing non-canonical software requirements We have argued that APC may be considered as an uniform tool for represent-ing vague requirements statements as well as clear requirements statements. We then characterize inconsistency, redundancy, and incompleteness of a require-ments specification based on APC, respectively.
 cus on classically inconsistent requirements specifications. In contrast, the incon-sistencies arising in requirements specifications may be more complex. certain scenarios with regard to the requirements specification, we must add fur-ther relevant facts to model each scenario. Let I be a set of relevant facts to model a scenario. Let E be a set of expected responses of system-to-be in the scenario. Just for convenience, we assume each formula in E is atomic. Infor-mally, we use I , E to denote a scenario. Let | be the logical entailment relation in APC .
 Definition 3.1 Inconsistency. Let I , E be a scenario. Let be the related requirements specification. If  X  I |  X  : r , r  X  X  , p } ,then is inconsistent relative to the scenario; otherwise, is consistent relative to the scenario.  X  : and  X  : sistency, which will be resulted from the transformation of vague requirements into clear requirements. For example, if  X  : t  X  and  X  : f p  X  , then we could get final conclusion  X  : t ,since f p &lt; t in L p . But if we transform the vague requirements statement into clear requirements statement  X  : f , then inconsistency  X  : appears in . However, the identification of potential inconsistency could be viewed as a prediction of the results to clarify vague information. Definition 3.2 Potential inconsistency. Let I , E be a scenario. Let be the related requirements specification. Assume that  X  I is consistent. If  X  I |  X  : t (resp.  X  is potentially inconsistent relative to the scenario.
 Definition 3.3 Redundancy. Let I , E be a scenario. Let be the related requirements specification. If  X   X  s.t.  X  I | E and are consistent relative to the scenario, then is redundant relative to the scenario. Further, is viewed as a simplification of relative to the scenario.
 Definition 3.4 Incompleteness. Let I , E be a scenario. Let be the related requirements specification. If  X   X   X  E s.t.  X  I |  X  ,then is incomplete relative to the scenario. 4 Handling non-canonical software requirements To detect and fix the non-canonical requirements during the requirements stage, we provide a framework shown in Fig. 3 . Central to this framework is reasoning with requirements. Expected response of a scenario also plays an important role in the framework. Given a scenario and the related requirements specification, we may simulate the behavior of system-to-be in the scenario by reasoning about the union of the specification and the input of scenario. The expected response is used to determine if the simulation is desirable. When non-canonical requirements are detected, some strategy is performed to modify the requirements specifications and the scenario. Whatever modification is performed, the union of the refined specification and scenario needs to be checked for non-canonical requirements. for clarifying vague requirements statements has been discussed in our previous paper [ 20 ]. Informally speaking, we heighten the level of belief in the vague re-quirements statements that are free from both inconsistency and potential inconsis-tency. We also lower the levels of belief in the requirements statements involved in undesirable inferences. Just for completeness of the framework proposed earlier, we give an overview of inconsistency-based strategy for clarifying vague require-ments specification firstly. Then we focus on redundancy and incompleteness. Clarifying vague requirements The gist of our approach to clarifying vague information is to heighten the level stakeholder X  X  belief in  X  X roblematical X  requirements. We then need to distinguish  X  X ood X  requirements from  X  X roblematical X  requirements. We start clarification of vague requirements with the following definitions.
 Definition 4.1 Let be a set of annotated formulae. Then inconsistent subsets of . MC () is the set of maximally consistent subsets of ; MI () is the set of minimally inconsistent subsets of . Furthermore, we can con-sider a maximally consistent subset of a specification as capturing a  X  X lausible X  or  X  X oherent X  view on the specification. Notice that we focus on p as well as in the definition of inconsistent subset. This means that both clear inconsistency and vague inconsistency are paid attention.
 which will result from the transformation of vague requirements into clear require-ments. However, the identification of potential inconsistency could be viewed as a prediction of the results to clarify vague information.
 Definition 4.2 Let be a set of annotated formulae. Then potential inconsistencies. We call it the set of potential inconsistent subsets of . Definition 4.3 Let be a set of annotated formulae. Then PFREE () is the subset of that is free from both inconsistency and potential inconsistency. However, PFREE () could be viewed as the reflection of all the  X  X eally uncontroversial X  information in . In contrast, the set  X  MI ()  X  MPI () can be viewed as the collection of  X  X roblematical X  information in .
 ments involved in the problematical inferences. First, we define two kinds of ac-tion appropriate for this purpose.
 Definition 4.4 Confirming. Let be a set of requirements statements. For every  X   X  , its confirmation is defined as  X  c ,where  X  c is constructed by  X  replacing each annotation t p in  X  by t ;  X  replacing each annotation f p in  X  by f .
 Definition 4.5 Degrading. Let be a set of requirements statements. For every requirements statement  X   X   X   X  , its degradation is defined as  X   X   X  d , where  X  d is constructed by replacing each annotation in  X  by  X  . In particular,  X   X  : r  X  by replacing annotation r by  X  , i.e.,  X  : X  .
 gered by undesirable inferences, i.e., inconsistency or potential inconsistency. the results of reasoning with requirements specifications. Informally, we can adopt a meta-level approach to prescribe vagueness-clarifying strategies of the form  X  Being involved in (potential) inconsistency implies Degradation ;  X  Being free from inconsistency implies Confirmation .
 In detail, the inconsistency-based strategy for clarifying vague requirements can be described as follows.
 specification. We may choose the following actions to modify the requirements statements.  X  Confirming Vague Requirements .For  X   X   X   X  V ,if  X   X   X   X   X  Degrading Problematical Requirements .For  X   X   X   X  ,if  X   X   X   X  Logical analysis of redundancy The expected response of the scenario plays an important role in checking redun-dancy. If the related specification is redundant relative to the scenario I , E , then the simplest specification relative to the scenario should be paid attention. We start with the following definitions. Definition 4.6 Let I , E be a scenario. Let be the related requirements specification. is a minimal simplification of relative to the scenario iff  X  is a simplification of relative to the scenario;  X   X   X  ,if is a simplification of relative to the scenario, then  X  .
 Let SM () be the set of minimal simplifications of relative to the scenario. qualifications for a requirements statement in .
 Definition 4.7 Let I , E be a scenario. Let be the related requirements specification. We form the following qualifications for requirements statements,  X   X   X  is a necessary requirements statement relative to the scenario if  X   X   X   X   X  is a useful requirements statement relative to the scenario if  X   X   X   X   X  is a useless requirements statement relative to the scenario if  X   X  tion of the specification. A requirements statement is necessary if it belongs to each minimal simplification of , whereas a requirements statement is useless if there is no minimal simplification of specification containing it. Note that useful requirements include all necessary ones, and that useless and useful are opposite concepts.
 Example 4.1 Consider ={  X  : t  X   X  : t  X   X  : f , X  : t  X   X  : t , X  : f  X   X  : t , X  : t  X   X  : f  X   X  : t } .Let Therefore,  X  : t  X   X  : t  X   X  : f is a necessary requirements statement.  X  : t  X   X  : t and  X  : f  X   X  : t are useful requirements statements, whereas  X  : t  X   X  : f  X   X  : t is a useless requirements statement relative to the scenario. cations because they provide a clear relationship between requirements statements with simplifications. Intuitively, necessary requirements statements cannot be re-moved, since they are not redundant at all. Useful but not necessary requirements trast, useless requirements statements could be considered as strongly redundant, and they can be always removed.
 Definition 4.8 Let I , E be a scenario. Let be the related requirements specification.
 USEF () is the set of useful requirements statements, whereas USEL () is the set of useless requirements statements.
 follows:  X  remove USEL ( ) from ;  X  compare the minimal simplifications from multiple perspectives, and choose volve estimating the relative value and relative cost of each requirements state-ments, such that the most beneficial simplification provides the largest fraction of the total product value at the smallest fraction of the total cost. In essence, we are trying to identify the simplifications that will maximize the product value within the existing cost constraints.
 subject to the modification of requirements specification. However, a more rational strategy should focus on the scenario as well as the requirements specification. In this sense, the strategy for removing USEL () from takes the risk of removing really useful requirements. Therefore, we provide a cautious alternative strategy for simplifying the requirements specification as follows:  X  Fo r  X   X   X   X  USEL () , we view it as a TBD requirements, that is, we  X  Compare the minimal simplifications from multiple perspectives, and choose Handling incompleteness Generally, incompleteness can be viewed as a signal of missing some information about customer X  X  needs. We may view the expected result that cannot be entailed by  X  0 as being neglected, that is, we may provide the following strategy for handling incompleteness:  X  Let I , E be a scenario. Let be a related requirements specification. If Example 4.2 Consider I ={  X  : t , X  : t } and E ={  X  : t , X  : f , X  : t } . Assume that S ={  X  : t  X   X  : f , X  : t  X   X  : t  X   X  : f , X  : t  X   X  : t  X   X  : t } is the related requirements specification. So, we can get the following result: I  X  S |  X  : t . Thus, we may add  X  : X  to  X  . 5 Case study Our motivation is to handle the undesirable information about customer X  X  needs. For the following example of requirements elicitation, we will view the scenarios as being correct and not subject to the modification of requirements specification. This will allow us to focus our attention on redundancy or incompleteness of re-quirements specification.
 Example 5.1 At first, we consider the following setting in development of close residential area management system, which deals with the distribution of fixed garage to vehicles. The stakeholder A , one of managers of the residential area, who is in charge of safety, supplies the information about the software requirements as follows: tial area can enter the residential area; The Management Board must authorize the logistic vehicle.
 supplies the vague information about the software requirements as follows: fixed garage to the vehicle with authorization, and each logistic vehicle should have a fixed garage.
 ( X has a fixed garage ) are predicate symbols. Note, X is a variable symbol, and Dump cart is a constant symbol. (i) Aut hori zed ( X ) : t  X  Enter ( X ) : t , (ii) Logistics ( X ) : t  X  Aut hori zed ( X ) : t , (iii) Aut hori zed ( X ) : t  X  Garage ( X ) : t p , (iv) Logistics ( X ) : t  X  Garage ( X ) : t p .
 To identify the potential defects in 1 , we consider the scenario I 1 , E 1 ,where 1 has a fact: (v) Logistics ( Dump cart ) : t and the expected response is (vi) Garage ( Dump cart ) : t p (vii) Garage ( Dump cart ) : t p ( from (ii), (iii), and (v) ) , (viii) Garage ( Dump cart ) : t p ( from (iv) and (v) ) .
 requirements statements is useless relative to the scenario. and are both the minimal simplifications of 1 relative to the scenario. Furthermore, suppose we have an expected process of reasoning about Garage ( Dump cart ) : t as follows: Then the fourth requirements statement is also a redundancy. Further, we may remove the first and the fourth requirements from 1 .
 agement system, which deals with maintenance of fixed garages that have been maintenance, supplies the vague information about the software requirements as follows: expiration of utilization should be routinely maintained.
 tated formulae, 2 , where  X  Distributed ( Y )  X ( Y has been distributed to a vehi-of utilization ), and  X  Maintain ( Y )  X ( Y should be maintained ) are predicate sym-bols. Note, Y is a variable symbol. garage 1, garage 2, and garage 3 are constant symbols. (ix) Distributed ( Y ) : t  X  Damaged ( Y ) : t  X  Maintain ( Y ) : t , (x) Distributed ( Y ) : t  X  Expire ( Y ) : t  X  Maintain ( Y ) : t p To identify the potential defects in 2 , we consider the scenario I 2 , E 2 ,where 2 has three facts: (xi) Distributed ( garage 1 ) : t  X  Expire ( garage 1 ) : t , (xii) Distributed ( garage 2 ) : t  X  Damaged ( garage 2 ) : t , (xiii)  X  Distributed ( garage 3 ) : t  X  Damaged ( garage 3 ) : t and the expected response E 2 is the set of following formulae: (xiv) Maintain ( garage 1 ) : t p , (xv) Maintain ( garage 2 ) : t , (xvi) Maintain ( garage 3 ) : t . However, It signifies that 2 is incomplete relative to the scenario I 2 , E 2 . Thus, Maintain ( garage 3 ) maybeviewedasa TBD , that is, we add to requirements specification. It may remind the developer to collect information about the kind of garage. 6 Related work Transforming a rough sketch into a correct and feasible requirements specifica-the evolution of requirements, consistency and completeness are two critical is-consistency/completeness only rather than both of them.
 definitions of  X  X nconsistency X  have been proposed in research literature. For ex-ample, Easterbrook et al. [ 8 ] summarized them and generalized inconsistency to any situation in which two parts of a specification do not obey some relationship that should hold between them. However, these definitions of  X  inconsistency  X  X re too general to be informative [ 25 ]. As for handling inconsistency, most practition-ers and researchers advocate adopting flexible inconsistency-handling strategies, including resolving the inconsistency immediately, ignoring it completely, or tol-erating it for a while [ 6 , 7 ]. The paraconsistent logic has been viewed as a tool this kind of logic can only deal with precise statements, the vague requirements statements cannot be taken into account.
 tion recently. Some approaches touch on the topic. In process-control application, Leveson [ 16 ] argues that a formal specification language associated with a set of extended criteria for identifying missing, incorrect, and ambiguous requirements [ 18 ] rather than the formal specification language is appropriate for finding incom-pleteness in specifications. In goal-oriented requirements analysis such as I  X  [ 21 ] and AGORA [ 13 ], incompleteness of specifications is detected by refining and elaborating goals in the form of AND/OR graph. Recently, formal or algebraic methods for analysis and validation are appealing for studies of completeness of specification [ 2 , 22 ]. For the same reason as mentioned earlier, these approaches ignore the vagueness of requirements statements. Redundancy has not yet received much attention. For example, in proving correctness, completeness of specifica-tion rather than the minimal completeness of specification is emphasized [ 25 ]. lems in the requirements evolution. Rather, compared to these related works, the paper focuses on both the vague requirements statements and the clear require-ments statements. APC adopted in the paper provides an uniform tool to represent the requirements specification containing vague information as well as clear in-formation. We paid special attention to vague information, as we think the vague information may be the real source of the potential inconsistency or redundancy in many cases. Furthermore, the paper offers a better theoretical characterization of the non-canonical requirements including inconsistency , redundancy ,and in-completeness based on APC, so that these non-canonical requirements have un-ambiguous logical meanings. Moreover, in the paper, inconsistency, vagueness, redundancy, and incompleteness can be handled by using an uniform framework. With regard to the modification or evolution of specifications and scenarios, the paper offers general strategies at a coarse grain. For example, when redundancy is identified, a cautious strategy of degrading related requirements rather than that of removing them is recommended. As many complex factors could be involved feasible. 7Conclusion We have presented an approach to handling non-canonical requirements based on APC.
 ing an appropriate belief semilattice to representing the level of stakeholder X  X  be-lief in vague requirements, we translated requirements specification into APC. We defined vague inconsistency and potential inconsistency as well as classical inconsistency based on reasoning with specifications. Furthermore, we defined re-dundancy and incompleteness of requirements specification relative to a certain scenario. The expected response of the scenario plays an important role in charac-terizing redundancy and incompleteness.
 particular, logical analysis of redundancy is detailed. According to the framework, given a scenario and the related requirements specification, we may simulate the behavior of system-to-be in the scenario by reasoning about the union of the spec-ification and the input of scenario. The expected response is used to determine if the simulation is desirable.
 References
