 In this paper we propose a fully decentralized approach for recommending new contacts in the social network of mo-bile phone users. With respect to existing solutions, our approach is characterized by some distinguishing features. In particular, the application we propose does not assume any centralized coordination: it transparently collects and processes user information that is accessible in any mobile phone, such as the log of calls , the list of contacts or the inbox/outbox of short messages and exchanges it with other users. This information is used to recommend new friend-ships to other users. Furthermore, the information needed to perform recommendation is collected and exchanged be-tween users in a privacy preserving way. Finally, information necessary to implement the application is exchanged trans-parently and opportunistically, by using the residual space in standard short messages occasionally exchanged between users. As a consequence, we do not ask users to change their habits in using SMS.
 C.2.4 [ Computer-Communication Networks ]: Distributed Systems; H.3.3 [ Information Storage and Retrieval ]: Information Search and Retrieval X  relevance feedback Algorithms, Design, Experimentation, Security Similarity estimation, Jaccard coefficient, Mobile applica-tions, Privacy Partially supported by EU STREP Project ICT-215270 FRONTS and by PRIN 2008 research project COGENT, funded by the Italian Ministry of University and Research.
Mobile social networking is an emerging trend. eMarketer forecasts [1] that mobile social networking will grow from 82 million users in 2007 to over 800 million worldwide by 2012. In most mobile communities, mobile users can create their own profiles, make friends, create and participate in chat rooms, hold private conversations, share photos and videos. Major players in social networking, such as Facebook, MyS-pace and LinkedIn, have already deployed mobile versions of their applications.

Moreover, mobile applications can be extended to support physical presence detection and thus eventually create a link and some kind of convergence between the virtual and real world. For example, Centrl (centrl.com/mobile) is a smart-phone application that lets you see which of your Facebook friends are around and Pelago (www.pelago.com) provides a similar application for Twitter users.

On the other hand, while western countries are experienc-ing the increasing availability of high speed connections and the diffusion of last generation smart phones with advanced interfaces to access mobile social networks, many still con-sider Short Messages the most convenient means for instant message exchange 1 . In any case, SMS traffic is still a con-sistent part of non-voice traffic. According to Lloyd X  X  [5], overall Person-to-Person SMS traffic has been 4.5 trillion of messages in 2008. These figures seem to justify the invest-ments of some companies in social networking applications based on Short Messages, such as Jyngle 2 [3] and Peekamo [4]. Furthermore, in large parts of the world, in particular Asia and Africa, SMS are expected to remain the primary means for data communication, at least in the near future. In 2007, nearly 1.5 trillion mobile messages were sent in the Asia-Pacific region [12].

Mobile social networks are thus raising in popularity, but along with clear benefits for users and companies, some con-cerns primarly related to privacy issues are arising. In the last W3C Workshop on the Future of Social Networking [6], several position papers on this issue appeared. For exam-ple, the basic operation of establishing a  X  X riendship X  in a social network, whatever the term means for the specific ap-plication, is a simple operation (e.g. a mouse-click), but it necessarily entails trust in the likely exchange of private in- X  X f you look at instant messaging, e-mail or even social networking, they don X  X  have the ubiquity and the reach to replace messaging X  -Bill Dudley, Sybase 365 X  X  group director for product management.
Jyngle closed in August 2009. formation. As a matter of fact, privacy is one of the main concerns in mobile communities. As Jeff Chester, executive director of the Center for Digital Democracy , put it:  X  X he fact of the matter is that the business model they have de-veloped for mobile advertising is one where lots of user data is collected and user profiles are analyzed X  and  X  X ou X  X e talk-ing about multiple layers of surveillance at the heart of the mobile marketing business model that raise serious privacy concerns. X  Contribution of the paper. In this paper we propose an approach that uses Short Messages (SMs) and local infor-mation available on mobile phones to design a fully decen-tralized application for recommending new contacts in the social network of mobile phone users. Recommending new contacts is a basic service provided by virtually every social network application. With respect to existing solutions, our approach is characterized by some distinguishing features: The social networking application we propose is completely decentralized. This implies that the social network is not maintained in a centralized fashion, as usually done in nowa-days social networking applications, but it is updated and managed in a fully distributed way by the collective effort of user devices. It transparently collects and processes user in-formation that is accessible in any mobile phone, such as the log of calls , the list of contacts or the inbox/outbox of short messages possibly enriched by user profile information. This information is used to recommend new contacts.
 The techniques we propose greatly reduce the amount of personal information that is disclosed, since it is exchanged with other users in the form of a compact summary that allows limited extraction of private data. In addition, we provide a simple and practical cryptographic protocol that can be used to ensure that the computation required by our recommendation system is performed without revealing any additional private information.
 Information necessary to implement the application is ex-changed transparently and opportunistically, by using the residual space in standard short messages occasionally ex-changed by users. As a consequence, we do not ask users to change their habits in using SMS.

Past research has also considered decentralized systems for item recommendation, such as in [16], where the authors propose the P2P-based PocketLens architecture. We are aware of this body of work, but recommending items using statistical information about past user transactions is not the focus of our work, which is rather on the related but well distinguished  X  X ocial matching X  problem [19], in which we want to infer the latent structure of a social network. Organization of the paper. The rest of the paper is or-ganized as follows: in Section 2 we describe the approach we follow. In particular, we discuss some social networks naturally arising when analyzing the behaviour of users in a (mobile) telephone network. We then discuss the issues aris-ing in the recommendation of new contacts in such networks, in the first place the notion of similarity between users. In Section 3 we review and discuss the application of sophisti-cated hashing techniques that allow to estimate the degree of similarity between users in a fully decentralized and privacy preserving way. In Section 4 we discuss experimental work assessing the effectiveness of our approach on real, publicly available datasets and in Section 5 we quickly introduce a working prototype of our receommendation system.
In this work, a node in the social network of mobile phone users is a mobile phone subscriber generating some amount of user-to-user communication. A link connecting two nodes, represents an ongoing social relationship (e.g. nodes are friends, colleagues, classmates, etc.) between the corre-sponding users. In our approach, this social relationship can only be inferred estimating the users X  social profiles similar-ity. Speaking in general terms, two users are similar when their social profiles are similar. In fact, the profile of a user is a general notion that depends on the information available to the system. In some cases this includes some biograhpical data, such as date of birth, sex, information about tastes, interests or activities. A profile is also completed by infor-mation that can be extracted transparently from the system, without explicit user intervention, such as the log of calls , the list of contacts or the inbox/outbox of short messages .
We stress that in many cases, even limited information, e.g., example the address book or the log of calls, can be used to infer possible relationships: for example, two users appearing in each other X  X  address books are likely to be so-cially related, be it through a shared interest, a professional relationship, or simply because they are friends.

Mining the social network underlying telephone traffic has been considered in the past, for example in [8, 7]. Here, there is a (possibly labelled) link from A to B if A calls B at some point. The main goal in [8, 7] was to study the way in which such networks evolve over time, so as to infer and analyze probabilistic generative models [17] describing their evolution.
Recommending new social relationships is one of the most basic services provided by social network applications. In our context, we are interested in strategies to recommend new contacts of potential interest to users. The challenge here is clearly to find contacts that are likely to share some common traits or, put differently, that are in some way  X  X im-ilar X  to the user to whom the recommendation is being pro-vided. As stated, this problem is very close to the link pre-diction problem studied by Liben-Nowell and Kleinberg [15], whose focus is on statistical indicators of social closeness and not on their efficient and decentralized computation.
More formally, if a node A recommends a node B to a third node C , A is suggesting a potential interest or utility for C in establishing a contact with B (unless this contact already exists). Recommendation is performed on the ba-sis of knowledge about the social profiles L ( B ) and L ( C ), which are used to estimate the extent to which B and C are  X  X imilar X . The underlying assumption, made more precise in Subsection 2.2, is that the more similar B and C , the more likely it is that they either have a contact, or they might benefit from establishing one.

Privacy requirements make the explicit exchange of pri-vate profile information or user contact lists unrealistic for applications. Furthermore, data must fit into the residual space of person-to-person short messages and thus they must be represented in a compact form (i.e. a sketch ). Figure 1 outlines the general application scenario we consider. In step 1, users A and B compute the sketches sk ( L ( A )) and sk ( L ( B )) of their respective social profiles. As observed be-fore, this is a compact representation of the user X  X  social profile preserving her privacy. In step 2 and 3, A and B occasionally send a short message to C. The message space is partially filled with some personal text (e.g. SM Text =  X  X hall we meet this evening? X ) while the residual space is ex-ploited to deliver the sketches. Observe that users interact with the SMS as usual, while the residual space is transpar-ently managed by a suitable application. In step 4, user C (i.e. the recommender) infer a high degree of similarity be-tween A and B on the basis of their respective sketches. In steps 5 and 6, C eventually recommends a possible friendship to users A and B.
One of the main issues in recommendation systems for social networking is predicting the potential benefit of new links between users. In the fully decentralized scenario we consider here, this amounts to answering the following ques-tion: when should a user A recommend a contact between two other users B and C she is aware of. This in turn im-plies a number of other issues: i) What information about B and C does A combine in order to decide whether or not she should suggest a contact between B and C if not existing al-ready; ii) how is this information obtained, manipulated and exchanged; iii) how are computational, storage and commu-nication constraints met; iv) how is privacy preserved.
Alike many networking applications, we recommend new contacts on the basis of similarities between users. Thus, A will recommend B and C to establish a contact if A as-sesses that B and C are  X  X imilar X . In particular, if we view profiles as feature sets, we say that two users A and B are similar when their social profiles L ( A ) and L ( B ) overlap significantly. In this perspective, we estimate user similarity by the Jaccard coefficient J ( L ( A ) ,L ( B )) = | L ( A )  X  L ( B ) | widely accpeted measure of similarity between sets. In the social networking scenario we consider, it captures the well known fact [17, 15] that social networks are densely con-nected at a local level or, roughly put, the folklore that two friends of the same person are significantly more likely to be friends than any two randomly chosen people.
A key aspect in the applications we consider is estimating the size of the intersection between the social profiles of two users in a fully decentralized way. More precisely, if a user C receives short messages from A and B, she should be able to estimate J ( L ( A ) ,L ( B )) from summary information about L ( A ) and L ( B ) piggybacked in the messages themselves. It is clear that short message size poses stringent constraints on the amount of information that can be piggybacked. This is at most 140 bytes, but recalling that we only use the resid-ual space on the message, a variable number of those bytes will be occupied by the message body itself. We show be-low how to address these issues in the following way: i) we adapt a technique initially conceived for Web page similar-ity estimation to the scenario we consider. The adoption of this technique allows to compute compact summaries or sketches of each social profile, which in turn allows efficient estimation of the Jaccard coefficient between social profiles. The space required by the proposed sketches is in the order of a few tenths of bytes; ii) we address the issue of variable SMS size under the assumption [20] that SMS sizes are (ap-proximately) uniformly distributed. Specifically, for those messages created in person-to-person communications, the length seems to evenly span the whole range of the allowed message sizes [20], whose maximum value depends on the en-coding that is used for each message, but it is typically 140 bytes. In the following, we refer to profiles based on users X  contact lists, since contact information is locally available on virtually every recent commercial device. For this reason, the terms social profile and contact list will be used inter-changeably. We emphasize that the techniques described in the remainder can be extended to more general notions of user profile, as described in section 2.
Consider the set of possible contact identifiers. Recall that, as motivated further in this section, they can be re-garded as integer numbers falling in the range [ n ] = { 0 ,...,n  X  1 } for suitable n . The only assumption we need is that they are unique, a constraint that is met in practice in the ap-plications we consider; they are users X  telephone numbers or a suitable representation of them. As a consequence, con-sidered any two users A and B, their contact lists L ( A ) and L ( B ) may be simply regarded as two subsets of [ n ]. Our goal is to measure their overlap using the Jaccard coeffi-
A very simple and elegant technique to estimate the Jac-card coefficient has been proposed in several equivalent forms by Broder et al. [10, 11]. Assume we are able to choose a per-mutation  X  (  X  ) mapping [ n ] onto itself uniformly at random. For every X  X  [ n ], denote by  X  ( X ) the set of the images of elements in X when  X  (  X  ) is applied and let min(  X  ( X )) denote their minimum. Then it can be shown [10] that ( i ) consid-ered a set S  X  [ n ] and for every a  X  S , P [ a = arg min(  X  ( S ))] = 1 / | S | ; ( ii ) for every S 1 , S 2  X  [ n ]: P [min(  X  ( S J ( S 1 ,S 2 ). This property immediately yields a technique to estimate J ( S 1 ,S 2 ).

The algorithm consists in performing m independent ex-ecutions of the following procedure: i) pick one permuta-tion  X  (  X  ) of [n] uniformly at random from the n ! possible ones; ii) in the i -th iteration, let min( S 1 ) = min(  X  ( S and min( S 2 ) = min(  X  ( S 2 )). We increment a counter C whenever min( S 1 ) = min( S 2 ). At the end of the process, our estimation of J ( S 1 ,S 2 ) is C m /m . Standard tools from probability theory tell us that C m is an increasingly (with m ) accurate estimation of J ( S 1 ,S 2 ). UPDATE( sk ( A ) , pn) Require: Sketch sk ( A ) , number pn 1: x = hash(pn) {Hash pn to an integer in [n]} 2: for i: 1 ...m do 3: M i = h i ( x ) {Map x according to a random per-4: if M i &lt; min i ( A ) then 5: min i ( A ) = M i 6: end if 7: end for 8: return sk ( A )
Unfortunately, generating permutations uniformly at ran-dom requires a number of truly random bits that is in the order of n [10]. Fortunately, suitable families of simple, lin-ear hash functions perform well in practice (e.g. see [14, 9]). In particular, we use linear permutations [9], i.e., func-tions of the form h ( x ) = (( ax + b ) mod p ) mod n . Here, p is large prime, while a and b are integers belonging to the intervals [1 ,p  X  1] and [0 ,p  X  1] respectively.

We next describe how each node A of the network main-tains the local sketch sk ( A ) associated to L ( A ). As pointed out before, we assume below that every number in L ( A ) is an integer falling in [ n ]. To this purpose, it is enough to perform a first step in which each contact identifier (e.g., a user X  X  mobile phone number) is regarded as a string and this string is mapped onto an integer in [ n ], using any hash function, as long as the probability of collision is sufficiently small. This is for instance the case if we hash contact iden-tifiers to 32-bit integers using a good hash function, e.g., implemented in Java standard classes. As a second step, m hash functions are generated. The i -th hash function has the form h i ( x ) = (( a i x + b i ) mod p ) mod n . The in-tegers { a 1 ,b 1 ,...,a m ,b m } are generated independently and uniformly at random, respectively in the interval [1 ,p  X  1] for the a i  X  X  and [0 ,p  X  1] for the b i  X  X . Finally, for i = 1 ,...,m , ordered vector sk ( A ) = (min 1 ( A ) ,..., min m ( A )). A version of this algorithm that allows dynamic updates when new numbers are added to the contact list is given in Figure 2.
The cost of algorithm UPDATE( sk ( A ) , pn) is O ( m ). The deletion of items from the contact list is more expensive, since the element removed might be the one achieving mini-mum value on one or more of the hash functions. Therefore, in the case of deletions sk ( A ) has to be recomputed from scratch and the cost becomes O ( m | L ( A ) | ). Note however, that m is in the order of a few tenths at most (10 in our experiments). This complexity is therefore fully compatible with standard commercial mobile phones.

In addition to sk ( A ), A X  X  device stores sk ( B ), if available, for every B in her contact list. The required amount of additional memory, as discussed further in greater detail, is a few tenths of bytes for each entry in the contact list (40 in the current implementation), thus perfectly compatible with standard commercial devices. In the scenario we envision, if both user A and B run RECOMMEND(A, sk ( B ) , sk ( C ) ,  X  ) Require: Node A, Sketch sk ( A ) , sk ( C ) , threshold  X  1: Estimate J ( L ( B ) ,L ( C )) from sk ( B ) and sk ( C ) 2: if J ( L ( B ) ,L ( C )) &gt;  X  then 3: A recommends B to C or viceversa 4: end if the application and B sends an SMS to A, B will use the available free space of the message to send its own sketch sk ( B ), or part of it, to A. Let X  X  assume for the moment that there is enough residual space in the message to send the whole sk ( B ). Note that this is likely to be often the case since, as we see later, the size of a sketch is typically a few tenths of bytes, 40 in the present implementation. Morover, we discuss how to address cases in which the SMS free space is not sufficient to contain sk ( B ) in a further paragraph of this section. Whenever A X  X  device receives the message, it transparently extracts sk ( B ) from the message body. If B is one of A  X  X  contacts, then sk ( B ) is stored in A X  X  contact list, associated to B, possibly replacing an older copy of sk ( B ).
Recall that we assume that two users are similar to the purpose of the application whenever their contact lists over-lap significantly. The algorithm in Figure 3 implements this general idea. In particular, the algorithm describes the be-haviour of the generic, mobile terminal of some user A. If A has the sketches of both B X  X  and C X  X  contact lists, A will recommend B (C) to C (B) whenever the local estimation of J ( L ( B ) ,L ( C )) exceeds some given threshold  X  . In Section 4 we study, among others, how the choice of the threshold affects the quality of recommended contacts.
We discuss in this paragraph several implementation is-sues.

If we consider the generic node A, the amount of memory needed to store its contact list is  X ( L ( A )). In our implemen-tation, A also needs to store i) its own sketch sk ( A ) and, in the worst case, ii) sk ( B ), for a subset of nodes from which A received SMS messages in the past. If we assume that A stores the sketch of every contact, the required amount of memory is O ( m ( | L ( A ) | )). In practice, if we use m = 10, the additive amount of bytes required for each contact is about 40. This is in the same order of magnitude of an entry in any address book of a commercial device.

The computational cost of maintaining sketches and pro-viding recommendations is also compatible with current com-mercial devices. In particular, adding a new contact to the contact list of a node A requires updating sk ( A ) (algorithm UPDATE(  X  X  X  ) in Figure 2) and has cost ( O ( m )). Removing a contact from L ( A ) (typically a less frequent operation) is more expensive but it has (up to m ) still linear cost, i.e., O ( m | L ( A ) | ). Finally, for two nodes B and C other than A, deciding at A as to whether recommending each of them to the other requires estimating J ( L ( B ) ,L ( C )), which has cost O ( m ). Computation is performed at user devices. Nowa-days, these are typically small computers, whose computa-tional capabilities are perfectly compatible with the compu-tational effort required by the proposed techniques.
The number of hash functions required (i.e., m ) is cho-sen, so that probability that the estimation of the Jaccard coefficient differs from the true value by more than a cho-sen constant is below a suitably small constant. We refer the reader to specific work (e.g., [11, 10]) for technical details. In our case, experimental evidence suggests that 10 hash func-tions are sufficient to strike a reasonable balance between accuracy of the estimation and memory requirements.

A further constraint is that all user devices use the same set of hash functions. In practice, hash functions and the al-gorithms we propose will be implemented and maintained in the device X  X  memory. This in turn requires storing, for each hash function, its coefficients and p in binary form. In our implementation, coefficients are 32-bit integers, while p is the well-known Mersenne prime 2 32  X  1, which does not need to be stored explicitely. So, it turns out that the actual stor-age requirements for maintaining hash functions is around 80 bytes. The overall implementation (code, hash functions, runtime data structures) requires less than 1Kbyte space. To this, we must add the (variable) size of the user X  X  (modified) contact list. Thus, the storage requirement of the modified contact list is in the same order of magnitude as in a stan-dard implementation.

We observed earlier that we cannot always assume that the message body of an SMS sent from some node A to an-other node B has enough free space to host sk ( A ). The most direct way to circumvent this problem is for A to send its sketch whenever the avaiable free space in the message body exceeds | sk ( A ) | . In fact, the distribution of SMS message sizes seems to be approximately uniform [20]. Assuming for the sake of simplicity that it is exactly uniform and that mes-sage sizes of different messages are independent variables, we have that half of the messages have 80 bytes available space in the average, more than 75% have at least 40 bytes avail-able to carry sketches and so on. This means that, in the average, 1.34 message are enough for A to send its sketch to B, which means that, in practice, if A sends 2 SMS to B, the latter is very likely to receive A X  X  sketch. 3
As described in the previous sections, a sketch is a rep-resentation of the contact list that, besides reducing the amount of data to be exchanged, does not fully discloses a user X  X  contact list. As an example of the type of information that is leaked by the sketch sk ( A ) = (min 1 ( A ) ,..., min of contact list L ( A ), we point out that if h i ( x ) &lt; min then certainly x 6 X  L ( A ). In this section we show how to se-curely compute the Jaccard coefficient of two contact lists, L ( A ) and L ( B ), without revealing any information except what can be deduced from the Jaccard coefficient itself.
Let us consider two parties A and B , each holding a vec-tor of length m ; with a slight abuse of notation we identify each party with his/her input vector. In our application to the computation of the Jaccard coefficient, the vectors will be the sketches of the respective contact lists. A and B wish
An alternative solution is that A sends to B part of its sketch, compatibly with the available space in the SMS mes-sage body. This solution requires bookeeping both at A and B, to keep track of the portions of sk ( A ) still missing at B. In fact, the former solution can be more easily implemented than the latter and it requires no additional data structures. to compute the number of positions i for which A [ i ] = B [ i ] without revealing any additional information on the vectors. We will describe a protocol that uses an additively homo-morphic encryption scheme ( E ; D ; K ) like Paillier cryptosys-tem (see [18] for further information).
 Homomorphic encryption scheme. Let ( E ; D ; K ) be a homomorphic encryption scheme and assume that the mes-sage space for a public key pk returned by the key gen-erator algorithm K on input security parameter m is Z p for some integer p of length m . The following additive ho-momorphic properties hold: ii) the product of two cipher-texts is a ciphertext for the sum of the plaintexts; that is, for all messages a ; b  X  Z p and public keys pk , we have D ( E ( pk,a )  X  E ( pk,b ) ,sk ) = a + b ; ii) raising a ciphertext for message a to power r gives a ciphertext for r  X  a ; that is, for all r  X  Z p we have that D ( E ( pk,a ) r ,sk ) = r  X  a .
The protocol . The protocol can be described as follows: 1. A picks a pair of public and secret key ( pk,sk ) for en-2. for i  X  [ n ], B computes encryption b i = E ( pk,  X  B [ i ]) 3. A decrypts the m ciphertexts received from A , counts Properties of the protocol. We make the following sim-ple observations: Correctness. The value s computed by the protocol is the number of indices i for which A [ i ] = B [ i ], with probability exponentially close to 1. Privacy of the input. Each of A and B gets no information on the other party X  X  vector, besides what can be obtained from the output of the protocol. For A , this can be easily seen by exhibiting a prob-abilistic polynomial-time simulator S that, for all vectors A and B , on input vector A and the number s of positions in which A and B coincide (but not vector B ) outputs A  X  X  view of the protocol. Similarly, we can construct a simulator for B .

Coming back to the recommendation system, we have two parties A and B, each with a private contact list, L ( A ) and L ( B ), that wish to compute the Jaccard coefficient J ( L ( A ) ,L ( B )) . Obviously, the Jaccard coefficient can be computed by applying the above protocol to the character-istic vector of the two sets. The protocol will then run in time linear in the size of the underlying universe set. A much more efficient protocol is instead obtained by running the above protocol with each party holding as an input the sketch of his/her contact list computed using the same se-quence of random (or min-wise independent) permutations.
In this section we present the results of experimental on real, publicly available data sets, in our opinion supporting the effectiveness of the approach we propose.
Our experimental work had the following main goals. In the first place, we wanted to understand the intrinsic effec-tivess of the Jaccard coefficient to infer social relationships in the mobile phone user network. A further issue was to as-sess whether the techniques we use to approximate the Jac-card coefficient and discussed in Section 3, are compatible with the hard space constraints, imposed by Short Message size. In particular, these severely limit the number of hash functions we can use to to compute contact list sketches (we considered the use of 10 or 20 hash functions in our imple-mentation). This in turn affects the accuracy of the esti-mation, especially when the value of the Jaccard coefficient is relatively small in absolute terms, as is the case for the data set we consider. Finally, we wanted to investigate the effectiveness of our overall approach in suggesting contacts to users. The problem here is that the data do not allow us to directly assess the a posteriori effect of recommendations. For this reason, in our experiments we considered the ability of our approach in predicting existing links as a proxy of its effectiveness in providing useful recommendations.
Accessing telephone traffic data is far from trivial, since very few public datasets are available. The Reality Min-ing project [2, 13] represents the largest mobile phone ex-periment ever attempted in academia. Its dataset contains thousands hours of continuous data on daily human behav-ior and contains information on call logs , Bluetooth devices in proximity, cell tower IDs, application usage, phone status. We used call logs to build a call graph where nodes are mo-bile users characterized by unique ids (i.e., telephone num-bers) and there is an edge connecting two users i and j if and only if the call log contains a number of calls between i and j that exceeds a given threshold 4 . For the purpose of this experimental analysis, we exploited the call graph to build the contact list of users in the network. To avoid problems related to data incompleteness, we restricted our experiments only to the people actually participating in the Reality Mining project (around 100 people), whose logs are complete and accurate.

Formally, the call graph G w ( V,E ) is built as follows:
Note that the graph G w is undirected , i.e., we assume that contact lists are symmetric , i.e., i belongs to the contact list of j (and viceversa) if at least w calls occurred between i and j during the period of observation. Following the definition above, changing values of w can originate different graphs modeling stronger or weaker relations (i.e. a higher w can filter out occasional contacts). In our experiments we con-sidered G 1 ( V,E ) and thus worked directly on the call graph,
Note that this threshold is the number of calls above which we declare the existence of a link between the involed users. It is different from the threshold  X  in Figure 3 of Section 3, i.e., the value of the estimated Jaccard coefficient above which a contact is recommended.
 Require: G w ( V,E ) 1: for v 1 ...v n  X  V do 2: for each v a ,v b among the contacts of v i do 3: retrieve sk ( A ) , sk ( B ) by emulating an SMS 4: RECOMMEND(A, sk ( A ) , sk ( B ) ,  X  ) 5: end for 6: end for since the data set is relatively small and higher values of w further reduced the data set size.
We assessed the quality of our technique in providing rec-ommendations of good quality by using its ability to uncover existing relationships as a proxy. In particular, for each node v and for each pair { v a ,v b } both belonging to v i  X  X  contact list, we ran our algorithm to predict the existence or non-existence of link ( v a ,v b ). We then checked whether the link existed or not. This is synthetically described by the algo-rithm in Figure 4, which simulates the general recommen-dation algorithm described in Section 3.
The error of the recommendation strategy we propose is potentially affected by two factors: i) inaccuracy in the esti-mation of the actual value of the Jaccard coefficient; ii) error in the recommendation itself, i.e., the contact we recommend is not interesting to the user. These two aspects are clearly interrelated in complex ways. We treat them separately, which corresponds to the worst-case assumptions that the effects of the two sources of error sum up. As for the for-mer aspect, assessing the accuracy of our approximation of the actual Jaccard coefficient poses some issues. In the first place, our data show that even values of the Jaccard coeffi-cient related to a significant degree of social relationship can be low in absolute terms. This makes an accurate estimation harder to attain given the stringent constraints we have to comply with. In particular, if we use m hash functions, we only have m possible values for our estimation of the Jaccard coefficient. When m = 10 as we assume, this provides very little granularity. Namely, possible values of the estimated Jaccard coefficient are 0 . 1 j , with j = 0 ,..., 10, whereas val-ues of the true Jaccard coefficient corresponding to a sig-nificant degree of social interaction are around [0 . 05 , 0 . 1] in the dataset collection we consider. On the other hand, our algorithm is threshold-based: it recommends a contact be-tween two nodes A and B whenever J ( L ( A ) ,L ( B )) is above the threshold. For this reasons, we consider the Jaccard-Estimation Performance (JEP), defined as the fraction of times that our algorithm gives the same recommendation as it would give if it knew the exact values of the Jaccard co-efficient. We call the two versions of the algorithm apxJacc and exactJacc in the definitions that follows. Formally, for every node i , let C i denote the number of times that apx-Jacc and exactJacc take the same recommendation decision for pairs of nodes beloning to i  X  X  contact list.

The Jaccard-Estimation Performance (JEP) is formally defined as: where V is the vertex set, i.e., the overall number of users and t is the overall number of node pairs evaluated.
To assess the quality of our recommendations, we checked to which extent the contacts that are recommended corre-spond to actual links evaluating precision (i.e., the fraction of existing links that have been recommended over the total number of given recommendations) and recall (i.e., fraction of all existing links that have been recommended over the total number of actual links) of our recommendation algo-rithm.
In this section, we provide experimental results that ad-dress the following issues: i) whether or not the Jaccard coefficient is a good indicator of social ties in the datasets we consider and which are reasonable threshold values for the recommendation heuristic we propose; ii) how good is our estimation of the Jaccard coefficient, at least in the sense made precise in the previous subsection; iii) how good are the recommendations we provide, which we indirectly an-swer by to which extent we are able to infer existing contacts between node pairs. Since our algorithms contain a proba-bilistic part in the selection and use of the hash functions used to estimate the Jaccard coefficient, all results reported below refer to averages taken over 5 indipendent runs of the algorithm.
Figure 5 synthetically describes the correlation existing between values of the Jaccard coefficient and existence of links between node pairs. More in detail, the x -axis is di-vided into interval of width 0.05 each, starting at 0.0 and ending at 0.2. For the j -th interval ( j = 0 , 1 , 2 , 3), the or-dinate represents the fraction of pairs ( A,B ) of users such and ii) A and B are contacts, i.e., they are in each other X  X  contact lists. The x -intervals stops at the value 0 . 2, since we observed too few pairs with Jaccard coefficient beyond this interval, to be statistically meaningful. This picture clearly shows that the Jaccard coefficient is a good indicator of so-cial ties in mobile user networks. Furthermore, at least in the datasets we considered, the Jaccard coefficient allows to identify a sharp transition around the value 0 . 05, from a re-gion characterized by sporadic ties to one characterized by frequent social relationships. In light of these observations, we chose the value 0 . 05 as a threshold in our recommenda-tion algorithm. Figure 6 shows the behaviour of the Jaccard-Estimation Performance, as defined in the previous subsection, as a function of the threshold, both when 10 and 20 hash func-tions are used to estimate the Jaccard coefficient. In par-ticular, the function has been computed in 5 points for 20 hash functions. Each point represents an indipendent run of the algorithm. More precisely, for j = 1 ,..., 5, the j -th run is executed with threshold value 0 . 05 j . For 10 hash func-tions we only considered two points, since for values of the threshold above 0 . 1 the distance between the two curves be-comes smaller and smaller. Results show that the algorithm
Figure 5: Existing linked pairs over total pairs that estimates the Jaccard coefficient using hash functions takes the same decisions as the one knowing the exact value of the Jaccard coefficient in most cases. This means that, even under the stringent constraints for sketch sizes, we are able to follow the ideal algorithm pretty close, as far as the recommendation decision is concerned.

Figure 7 shows the effectiveness of our algorithms in pre-dicting the existence of contacts in the social network of mobile users. In particular, Figure 7 is a scatter-plot show-ing the trade-off between precision and recall as the thresh-old and number of hash functions used vary 5 . For a better reading, values with precision &lt; 0 . 2 or recall &lt; 0 . 2 have been filtered out 6 . The following remarks are in order: i) the best trade-off between precision and recall is struck near rithm using exact Jaccard coefficient and for our heuristics; ii) For higher values precision increases and recall decreases, meaning that on one hand, a similarity beyond the threshold implies a contact with increasing probability, but we omit to recommend many contacts that fall below the threshold; iii) the values of precision/recall we obtain for the best choice are indeed relatively high, since they refer to the predic-tion of really existing links; if we were only recommending links that already exist, there would be no point in providing
The threshold is represented as a label over each point in the scatterplot.
This is the reason why only one point of the 10 hash algo-rithm is represented on the scatterplot. recommendations. These results in our opinion provide an indication that our fully decentralized strategies might prove effective in providing recommendations of good quality.
We actually implemented a proof of concept of our so-lution as a Java Card TM Applet exploiting the Sim Ap-plication Toolkit on the Gemalto Developer Suite. The Java Card TM technology allows applets written in the Java TM language to be executed on a smart card. It defines a Java Card TM Runtime Environment (JCRE) and provides classes and methods to help developers create applets. The Gemalto Develper suite also features Card, Server and Mo-bile Simulators, together with a rich developement environ-ment. The Applet we developed, shown in figure 8 imple-ments the application we envised in the previous sections. It transparently uses the residual space in an SMS and fills it with the user Sketch. Figure 8 shows the screenshot of the Mobile Simulator during the reception of a message contain-ing the sender X  X  sketch. This sketch is then exploited from our recommendation algorithm to find similarities with other contacts.
The authors wish to thank an anonymous reviewer for helpful suggestions.
 Figure 8: A screenshot of the Proof-of-concept im-plementation in Gemalto Developer suite [1] emarketer forecasts online. [2] Reality mining project. http://reality.media.mit.edu/. [3] Jyngle web site. http://www.jyngle.com/, 2008. [4] Peekamo web site: http://peekamo.com/, 2008. [5] Market intelligence on messaging and marketing. [6] W3c workshop on the future of social networking. [7] W. Aiello, F. Chung, and L. Lu. A random graph [8] W. Aiello, F. Chung, and L. Lu. Random evolution in [9] T. Bohman, C. Cooper, and A. M. Frieze. Min-wise [10] A. Z. Broder, M. Charikar, A. M. Frieze, and [11] A. Z. Broder, S. C. Glassman, M. S. Manasse, and [12] G. Consulting. Gartner says mobile messages to [13] N. Eagle and A. Pentland. Reality mining: sensing [14] P. Indyk. A small approximately min-wise [15] D. Liben-Nowell and J. Kleinberg. The link-prediction [16] B. N. Miller, J. A. Konstan, and J. Riedl. Pocketlens: [17] M. E. J. Newman. The structure and function of [18] P. Paillier. Public-key cryptosystems based on [19] L. Terveen and D. W. McDonald. Social matching: A [20] P. Zerfos, X. Meng, S. H. Wong, V. Samanta, and
