 A publish/subscribe system receives me ssages from publishers and delivers to subscribers who require the messages. Ea rlier publish/subscribe systems are topic-based, in which subscribers subscribe topics and a published message is delivered to subscribers w ho subscribed the topic of the published message. Re-cent publish/subscribe systems are content -based, in which subs cribers register  X  rules  X  and a published message is delivered to subscribers whose rules can be matched by the message. Content-based systems are more flexible and power-ful than topic-based systems and are widely used in message oriented systems such as online auctions and financial information exchange. Almost all database and middleware vendors offer some publish/subscribe feathers in their software suits, in which users can use SQL-like language to express subscriptions and the messages may be something like relational tuples or dictionary data structures.
XML has become the standard data exchange format. There is an increasing demand for XML-based publish/subscrib e systems which can support flexible document structures, and subscription rules should be expressed by powerful language such as XPath and XQuery; at the same time, the system must support high message throughput in case of millions of subscriptions. The main challenge of building such a system is how to match a published XML document with millions of XPath or XQuery subscriptions. Current matching strategies can be classified into two classes. The first c lass of strategies see subscriptions as filters, and subscribers are notified if a message passes through the filters. The filters are implemented by decision tree or finite state automata, and common computations between filters can be shared. This class of strategies maybe quite efficient if the decision tree or finite stat e automata can fit in memory; however, the scalability is limited by amount of available physical memory. The second class of strategies store subscriptions into a relational database, when a message is published, matching it with stored subscriptions by queries inside the database. The matching queries may be efficiently evaluated by using some appropriate indices, and the scalability is no longer limited by amount of available memory.
In this paper, we will introduce our publish/subscribe algorithm for imple-menting an XML-based publish/subscribe system by relational database, in which subscriptions are expressed by XPaths. To the best of our knowledge, our work is the first that implements the algorithm by non-recursive SQL language.
The rest of the paper is structured as follows. Section 2 describes previous works on publish/subscribe systems. Sect ion 3 presents our publish/subscribe algorithm. Experiments are presented in Section 4, followed by our conclusions. Some content-based publish/subscribe s ystems treat subscriptions as data; the matching between published messages and the subscriptions is implemented by join queries, and similar queries can share common computations. NiagaraCQ [1] uses signatures to group similar subscriptions, it uses a constant table extracted from the subscriptions along with a join to implement the matching algorithm. Commercial database vendors also use relational database engines to implement publish/subscribe systems [2], [3] whose scalability is not limited by available physical memory. However, most of the systems only handle tuple-like messages and rules are expressed by SQL. Some of these systems can handle XML mes-sages, but the systems either use a wrapper to extract tuple-like data from XML messages [2] or use a very simple language to express the subscription rules [1].
Other content-based publish/subscribe s ystems treat subscriptions as filters over messages. In [4], a in-memory decision tree is built for all subscriptions. The system walks down the decision tree for each message and subscriptions at the leaf node are notified. Several XML-based publish/subscribe systems employee a finite state automata for all XPath subscriptions in the main memory. A sequence of SAX parsed events of an XML message are streamed through the finite state automata to match the XPath subscriptions. [5] first introduced how to match an XML message with many XPath subscriptions using an in-memory finite state automata, a later paper [6] introduced how to share states in finite state automata construction, and [7], [8] introduced how to build an index on sub-strings of XPath expressions and share common computations between common sub-strings. [9], [10] introduced how to use in-memory finite state automata to evaluate XPath subscriptions over XML streams. [11] introduced a dynamic state construction approach, in which each state of a finite sate automata is constructed in memory when it is actually used; this approach is less attractive for long running systems. The main disadvantage of the in-memory approaches is the number of the subscriptions is limited by available physical memory, and insertions and deletions of subscriptions are difficult in the long-running systems. [12] is the first that implements a long -running XML publish/subscribe system using a relational database, in which the subscriptions are expressed by an XPath subset called  X  branching path expression  X , and the number of the subscriptions is no longer limited by amount of available physical memory. Each XPath is rewritten as a conjunction of predicates, and each predicate contains one branch in the graph presentation of the XPath. For each published XML document, the branch path of each predicate is match ed firstly, then a recursive SQL query is used to match all the predicates of each XPath. If all the predicates and branch points of an XPath are matched successfully, the owners of the XPath are notified. Our method is different from that proposed in [12] for we match XPaths with the XML document level-by-level using non-recursive SQL. Fig. 1 shows our publish/subscribe framework. Subscribers subscribe XML-style messages by XPaths; subscribe algorithm translates the XPath subscriptions into relational tuples and stores the tuples into a relational database. Publishers publish XML documents; publish algorithm translates an XML document into relational tuples and stores the tuples into a relational database. Matching algo-rithm matches stored XPath subscriptions with a stored XML document inside the relational database by relational operators to find out matched subscriptions and deliver the XML document to subscribers whose subscriptions are matched. 3.1 Publish Algorithm We use the range-based static labeling scheme [13] to label the nodes of an XML tree. The scheme initializes a cou nter to one and carries out a depth-first traversal of the XML tree. If a node is seen for the first time, it is assigned the value of the counter as its  X  start-point  X , and the node is assigned the counter value as its  X  end-point  X  when it is encountered again. The counter is incremented by one each time its value is assigned to a node. Compared with dynamic label-ing schemes such as the float number labeling scheme [14], the prefix labeling scheme [15], [16], and the prime number labeling scheme [17] which need not to re-label after insertions and deletions of nodes, the range-based labeling scheme has smaller storage requirements, so it i s possible to use a fixed length repre-sentation to store the labels, and we can take advantage of the standard SQL92 data types and operations to determine the ancestor-descendant relationships between nodes. For example,  X  is the ancestor of  X  iff start-point  X  &lt; start-point  X  and end-point  X  &gt; end-point  X  . In addition to start-point and end-point , we record the  X  depth  X  X feachnode.  X  is the parent of  X  iff  X  is the ancestor of  X  and depth  X  = depth  X  + 1. Each XML document is parsed by a SAX parser, and the parsed structure information and value information are stored in relational table XMLFrame and XMLValue respectively. Fig. 2 shows an XML document and the corresponding XML tree. Table 1 and Table 2 demonstrate how the XML document shown in Fig. 2 is stored in XMLFrame and XMLValue respectively. 3.2 Subscribe Algorithm Fig. 3 shows our XPath subscription grammar and two XPath subscriptions with the corresponding XPath trees. The grammar is a subset of XPath called  X  branching path expression  X . The grammar does not include the boolean OR expression, an XPath with boolean OR e xpression should be rewritten to dis-junctive normal form and disjunctions are submitted as separate subscriptions.
The depths of XML trees are usually very low; a statistical analysis over 200,000 XML documents had been performed [18], and discovered that 99% of the documents have less than 8 levels of nesting. For  X  //  X  X aybeusedinXPath expressions, the depths of XPath trees should be less than the depths of XML trees; so, we match XPath subscriptions with each published XML document level-by-level; XPath subscriptions are parsed level-by-level, and the edges and the predicates in the i th level of the XPath tree are stored in relational table XPathFrame [ i ]and XPathPred [ i ] respectively. Each XPath subscription has an  X  id  X  which can uniquely identify the XPath. Each edge connects two nodes in the XPath tree; we use  X  high-node  X  X nd X  low-node  X  to record the node that is close to the root and the node that is close to the leaf respectively. As shown in Fig. 3, the elements and the attributes that have the same depth in an XPath tree each has a unique serial number; we use  X  high-num  X  X nd X  low-num  X  X o record the serial number of the high-node and the serial number of the low-node respectively. The edges in the XPa th tree that are connected by  X   X  are merged into a single edge; for example, the path from  X  StudentList  X  X o X  FirstName  X  X n the XPath tree of XPath 1 in Fig. 3 has been merged into a single edge, and the depth difference between  X  StudentList  X  X nd X  FirstName  X  in the XML tree must be not less than 3. We use  X  max-diff  X  X nd X  min-diff  X  X orecordthemaximal depth difference and the minimal depth difference between the high-node and the low-node in the XML tree respectively; in this way,  X  //  X ,  X  /  X , and merged edge can be recorded in a uniform manner. In addition, we use  X  branch-point  X  and  X  final  X  to record whether the high-node of an edge is a branching point and whether the low-node of an edge is a leaf node respectively. For predicates, we use  X  node  X ,  X  node-num  X ,  X  value  X , and  X  operation  X  to record the tag of the node, the serial number of the node, the value, and the operation respectively; operations are recorded by integer values from 0 to 5, which mean  X = X ,  X  &gt;  X ,  X   X   X ,  X  &lt;  X ,  X   X   X , and  X  = X  respectively. Table 3 and T able 4 demonstrate how the twoXPathsinFig.3arestoredinthe XPathFrame tables and the XPathPred tables respectively. Deleting an XPath s ubscription on line is as easy as deleting all the tuples whose id equals to the id of the to be deleted XPath subscription. 3.3 Matching Algorithm Fig. 4 and Fig. 5 show our algorithm for matching XPath subscriptions with an XML document inside the relational database by relational operations to find out matched subscriptions. The matching algorithm tries to reconstruct each XPath tree from the XML tree in a bottom-up manner; if an XPath tree can be reconstructed from the XML tree, the corresponding subscription is matched. Firstly, id s of all XPath subscriptions are inserted into the Match-edXPath table; then, all XPath subscriptions a re reconstructed level-by-level in the bottom-up manner, and the reconstruction process for each level is con-sisted of five successive steps called frame matching, predicate matching, neigh-bor pruning, branching point pruning, and matched XPath cutting respectively. After the bottom-up level-by-level matching, id sinthe MatchedXPath table are id s of the matched XPath subscriptions, and the published XML document should be delivered to all the subscribers whose subscriptions can be matched ultimately.
 Step 1: Frame Matching. The frame matching step reconstructs the i th level edges of each XPath subscription from the published XML document and in-serts the reconstructed edges into the XMLMatch [ i ] table. Only the i th level edges of the XPaths whose id is in current MatchedXPath table are consid-ered to be recons tructed. The XMLFrame table occurs two times in the FROM clause, one for matching the high-node of the edge, the other for matching the low-node of the edge. As presented in Section 3 .1, the ancestor-descendent rela-tionship between two nodes  X  and  X  is determined by start-point  X  &lt; start-point  X  and end-point  X  &gt; end-point  X  , and as presented in Section 3.2, the depth differ-ence between the descendent and the ancestor is kept between min-diff and max-diff .
 Step 2: Predicate Matching. The predicate matching step reconstructs the i th level predicates of each XPath subscription from the published XML docu-ment and inserts the reconstructed predicates into the XMLMatch [ i ]table.Only the i th level predicates of the XPaths whose id is in the MatchedXPath table are considered to be reconstructed. As pr esented in Section 3.2, integer values from 0 to 5 mean  X = X ,  X  &gt;  X ,  X   X   X ,  X  &lt;  X ,  X   X   X , and  X  = X  respectively, and a CASE-WHEN clause was used to math the XML node values with the XPath predicate values.
 Step 3: Neighbor Pruning. The neighbor pruning step deletes the i th level reconstructed edges from the XMLMatch [ i ] table whose low-node is not a leaf node ( final = false ) and not exists an ( i +1)th level reconstructed edge whose high-node is the same as the i th level reconstructed edge X  X  low-node and not ex-ists an ( i +1)th level reconstructed predicate whose node is the same as the i th level reconstructed edge X  X  low-node . Since the edges can not contribute to the reconstruction of the XPaths, they are deleted from the XMLMatch [ i ] table.
 Step 4: Branching Point Pruning. The branching point pruning step deletes the i th level reconstructed edges from the XMLMatch [ i ] table whose high-node is a branching point and not all the branches of the branching point can be reconstructed from the published XML document. If the set difference between the set of branches in the XPath tree and the set of matched branches is not empty, we can ensure that not all the branches of the branching point can be reconstructed, and the branches should be deleted from the XMLMatch [ i ]table. Step 5: Matched XPath Cutting. After neighbor pruning and branching point pruning, the matched XPath cutting step deletes id s of the XPath sub-scriptions from the MatchedXPath table which can not be reconstructed from the published XML document. If an XPath has at least one i th level edge or predicate, but not exists a reconstructed i th level edge or predicate, it is definite that the XPath can not be reconstructed from the published XML document, and the id of the XPath should be deleted. Without the cutting step, our algo-rithm still functions correctly, for we may delete id s of the XPath subscriptions which can not be reconstructed only in the top level. But, with the cutting step, id s of the XPaths which can not be reconstructed from the published XML document are deleted as early as possibl e; so, upper level frame matching and predicate matching need not to match the edges and the predicates of the sub-scriptions that had been deleted, and our algorithm can achieve better time performance. With our implementation, a wide variety of experiments can be conducted under different conditions. Due to space limitation, we only use two sets of experimental results to report the performance and the scalability of our publish/subscribe algorithm. The experiments run on a 1.4 GHz Pentium IV CPU with 2G of memory and a 160GB of SCSI hard disk d river running RedHat Enterprise Linux Advanced Server 4 and Oracle 9i Enterprise Edition; the database cache size was set to 32MB, and the database block size was set to 8KB. Only three SQL92 data types are used in the relational tables, which are integer , boolean , and varchar respectively. We set primary key f or each relational table, and a B + tree unique index on the primary key will be created implicitly by the database { id , high-num } ,and { id , high-num , low-num , high-start-point , low-start-point } were set as primary key of the MatchedXPath table, the XMLFrame table, the XMLValue table, XPathFrame tables, XPathPred tables, and XMLMatch tables respectively. In addition, two B + tree indices on the XMLFrame table are created explicitly for improving time performance of the frame matching step, one is on the depth attribute, the other is on the node attribute. The matching algorithm was implemented by a stored procedure in the Oracle database server, and the procedure has only one parameter which is the maximal level of the subscriptions. In our experiments, XML messages and XPath subscriptions generated from Document Type Definition for the data and metadata at the Astronomical Data Center at NASA/GSFC [19] are used. Each XML message contains information about the metadata for a dataset, such as ti tle, keywords, references, authors etc, and all of the associated tables, descriptions, and history. The XML messages are generated from the DTD by IBM X  X  XML generator [20]; four XML messages are generated, whose size is 3KB, 15KB, 40KB and 100 KB respectively, and the maximal level of nesting is 5, 10, 11, and 12 r espectively. The XPath subscriptions are generated from the DTD by XPath generator; each node in the XPath tree has a 30% probability of being a branching point, has a 10% probability of being a X   X ; each edge in the XPath tree has a 20% probability of being a  X // X ; the average and the maximal depth of the XPa th trees are 5 and 10 respectively. In addition, due to the code of the complicated publish/subscribe system proposed in [12] belongs to IBM, and the paper only gives a brief introduction of the matching algorithm, we did not conduct comparison with the algorithm in [12].
In the first set of experiments, we match the 15KB XML message whose XML tree contains 328 inner nodes and 227 values with XPath subscriptions whose number increases from 0 to 100000. Fig 6.1 shows the time performance of the matching algorithm with and without matched XPath cutting. We can see that the matching algorithm with matched XPath cutting outperforms the algorithm without matched XPath cutting in a ratio of about 50%. In the second set of experiments, we match each of the generated 4 XML messages with 10000 XPath subscriptions. Fig 6.2 shows the time performance of the matching algorithm with matched XPath cutting. We can see that the growth rate of the matching time increases with the in crease of the XML message si ze, the reason is that the percentage of the matched subscriptions increases at the same time. In the paper, we introduced an XML publish/subscribe algorithm which is con-sisted of publish algorithm, subscribe algorithm, and matching algorithm. The matching algorithm uses relational operators to match XPath subscriptions with XML documents inside relational databases, so the scalability of the algorithm is no longer limited by amount of available physical memory. Experimental results show that the matching algorithm has good performance and scalability, so the algorithm should be a good choice for imple menting publish/subscribe systems.
