 Alessandro Epasto  X   X  X gni lassada xe persa X  1  X  Proverb from Trieste, Italy. We present tri X st , a suite of one-pass streaming algorithms to compute unbiased, low-variance, high-quality approxima-tions of the global and local (i.e., incident to each vertex) number of triangles in a fully-dynamic graph represented as an adversarial stream of edge insertions and deletions.
Our algorithms use reservoir sampling and its variants to exploit the user-specified memory space at all times. This is in contrast with previous approaches, which require hard-to-choose parameters (e.g., a fixed sampling probability) and offer no guarantees on the amount of memory they use. We analyze the variance of the estimations and show novel con-centration bounds for these quantities.

Our experimental results on very large graphs demon-strate that tri X st outperforms state-of-the-art approaches in accuracy and exhibits a small update time.
Exact computation of characteristic quantities of Web-scale networks is often impractical or even infeasible due to the humongous size of these graphs. It is natural in these cases to resort to efficient-to-compute approximations of these quantities, which, when of sufficiently high quality, can be used as proxies for the exact values.

In addition to being huge, many interesting networks are fully-dynamic and can be represented as a stream whose ele-ments are edges/nodes insertions and deletions occurring in an arbitrary (even adversarial) order. Characteristic quan-tities in these graphs are intrinsically volatile , hence there is limited added value in maintaining them exactly. The goal is rather to keep track, at all times , of a high-quality
Work partially done at Brown University. Any missed chance is lost forever.
 approximation of these quantities. For efficiency, the algo-rithms should aim at exploiting the available memory space as much as possible and they should require only one pass over the stream .

We introduce tri X st , a suite of sampling-based, one-pass algorithms for adversarial fully-dynamic streams to approx-imate the global number of triangles and the local number of triangles incident to each vertex . Mining local and global triangles is a fundamental primitive with many applications (e.g., community detection [4], topic mining [10], spam/anomaly detection [3, 27], ego-networks mining [12] and protein in-teraction networks analysis [29].)
Many previous works on triangle estimation in streams also employ sampling (see Sect. 3), but they usually require the user to specify in advance an edge sampling probability p that is fixed for the entire stream. This approach presents several significant drawbacks. First, choosing a p that allows to obtain the desired approximation quality requires to know or guess a number of properties of the input (e.g., the size of the stream). Second, a fixed p implies that the sample size grows with the size of the stream, which is problematic when the stream size is not known in advance: if the user specifies a large p , the algorithm may run out of memory, while for a smaller p it will provide a suboptimal estimation. Third, even assuming to be able to compute a p that ensures (in expectation) full use of the available space, the memory would be fully utilized only at the end of the stream, and the estimations computed throughout the execution would be suboptimal.
 Contributions. We address all the above issues by taking a significant departure from the fixed-probability, indepen-dent edge sampling approach taken even by state-of-the-art methods [27]. Specifically:  X  We introduce tri X st ( TRI angle E stimation from ST reams), a suite of one-pass streaming algorithms to approximate, at each time instant, the global and local number of tri-angles in a fully-dynamic graph stream (i.e., a sequence of edges additions and deletions in arbitrary order) using a fixed amount of memory . This is the first contribution that enjoys all these properties. tri X st only requires the user to specify the amount of available memory , an inter-pretable parameter that is definitively known to the user.  X  Our algorithms maintain a sample of edges: they use the reservoir sampling [37] and random pairing [14] sampling schemes to exploit the available memory as much as pos-sible. To the best of our knowledge, ours is the first appli-cation of these techniques to subgraph counting in fully-dynamic, arbitrarily long, adversarially ordered streams.
We present an analysis of the unbiasedness and of the variance of our estimators, and establish strong concen-tration results for them. The use of reservoir sampling and random pairing requires additional sophistication in the analysis, as the presence of an edge in the sample is not independent from the concurrent presence of another edge. Hence, in our proofs we must consider the com-plex dependencies in events involving sets of edges. The gain is worth the effort: we prove that the variance of our algorithms is smaller than that of state-of-the-art meth-ods [27], and this is confirmed by our experiments.  X  We conduct an extensive experimental evaluation of tri X st on very large graphs, some with billions of edges, compar-ing the performances of our algorithms to those of existing state-of-the-art contributions [18, 27, 32]. Our algorithms significantly and consistently reduce the average estima-tion error by up to 90% w.r.t. the state of the art, both in the global and local estimation problems, while using the same amount of memory. Our algorithms are also extremely scalable, showing update times in the order of hundreds of microseconds for graphs with billions of edges. Due to space constraints, the proofs and additional experi-mental results can be found in the extended version [9].
We study the problem of counting global and local tri-angles in a fully-dynamic undirected graph as an arbitrary (adversarial) stream of edge insertions and deletions.
Formally, for any (discrete) time instant t  X  0 , let G ( t ) ( V ( t ) ,E ( t ) ) be the graph observed up to and including time t . At time t = 0 we have V ( t ) = E ( t ) =  X  . For any t &gt; 0 , at time t + 1 we receive an element e t +1 = (  X  , ( u,v )) from a stream, where  X  X  X { + ,  X  X  and u,v are two distinct vertices. a new edge or deleting an existing edge as follows: If u or v do not belong to V ( t ) , they are added to V ( t +1) Nodes are deleted from V ( t ) when they have degree zero.
Edges can be added and deleted in the graph in an arbi-trary adversarial order, i.e., as to cause the worst outcome for the algorithm, but we assume that the adversary has no access to the random bits used by the algorithm. We assume that all operations have effect : if e  X  E ( t ) (resp. e 6 X  E (+ ,e ) (resp. (  X  ,e ) ) can not be on the stream at time t + 1 .
Given a graph G ( t ) = ( V ( t ) ,E ( t ) ) , a triangle in G  X  E ( t ) . We refer to the vertices forming a triangle as its cor-ners . We denote with  X  ( t ) the set of all triangles in G and, for any vertex u  X  V ( t ) , with  X  ( t ) u the subset of  X  containing all and only the triangles that have u as a corner. Problem definition. We study the Global (resp. Local ) Triangle Counting Problem in Fully-dynamic Streams, which requires to compute, at each time t  X  0 an estimation of |  X  ( t ) | (resp. for each u  X  V an estimation of |  X  ( t ) u
The literature on triangle counting is extremely rich, in-cluding exact algorithms, graph sparsifiers [35, 36], complex-valued sketches [20, 28], and MapReduce algorithms [30, 31, 33]. Here we restrict the discussion to the works most related to ours, i.e., to those presenting algorithms for counting or approximating the number of triangles from data streams. We refer to the survey by Latapy [25] for an in-depth dis-cussion of other works.

Many previous contributions presented algorithms for more restricted (i.e., less generic) settings than ours, or for which the constraints on the computation are more lax [2, 6, 19, 22]. For example, Becchetti et al. [3] and Kolountzakis et al. [21] present algorithms for approximate triangle counting from static graphs by performing multiple passes over the in-put. Pavan et al. [32] and Jha et al. [18] propose algorithms for approximating only the global number of triangles from edge-insertion-only streams. Kutzkov and Pagh [23] present a one-pass algorithm for fully-dynamic graphs, but the tri-angle count estimation is (expensively) computed only at the end of the stream and the algorithm requires, in the worst case, more memory than what is needed to store the entire graph. Ahmed et al. [1] apply the sampling-and-hold approach to insertion-only graph stream mining to obtain, only at the end of the stream and using non-constant space, an estimation of many network measures including triangles.
None of these works has all the features offered by tri X st performs a single pass over the data, handles fully-dynamic streams, uses a fixed amount of memory space, requires a single interpretable parameter, and returns an estimation at each time instant. Furthermore, our experimental results show that we outperform the algorithms from [18, 32] on insertion-only streams.

Lim and Kang [27] present an algorithm for insertion-only streams that is based on independent edge sampling with a fixed probability. Since the memory is not fully utilized dur-ing most of the stream, the variance of the estimate is large. Our approach handles fully-dynamic streams and makes bet-ter use of the available memory space at each time instant, resulting in a better estimation, as shown by our analytical and experimental results.

Vitter [37] presents a detailed analysis of the reservoir sampling scheme and discusses methods to speed up the algorithm by reducing the number of calls to the random number generator. Random Pairing [14] is an extension of reservoir sampling to handle fully-dynamic streams with in-sertions and deletions. Cohen et al. [8] generalize and ex-tend the Random Pairing approach to the case where the elements on the stream are key-value pairs, where the value may be negative (and less than  X  1 ). In our settings, where the value is not less than  X  1 (for an edge deletion), these generalizations do not apply and the algorithm presented by Cohen et al. [8] reduces essentially to Random Pairing.
We present tri X st , a suite of three novel algorithms for approximate global and local triangle counting from edge streams. The first two work on insertion-only streams, while the third can handle fully-dynamic streams where edge dele-tions are allowed.
 Parameters. Our algorithms keep an edge sample S of up to M edges from the stream, where M is a positive integer parameter. For ease of presentation, we realistically assume M  X  6 . In Sect. 1 we motivated the design choice of only requiring M as a parameter and remarked on its advantages over using a fixed sampling probability p . Our algorithms are designed to use the available space as much as possible. Counters. tri X st algorithms keep counters to compute the estimations of the global and local number of triangles. They always keep one global counter  X  for the estimation of the global number of triangles. Only the global counter is needed to estimate the total triangle count. To estimate the local triangle counts, the algorithms keep a set of lo-cal counters  X  u for a subset of the nodes u  X  V ( t ) . The local counters are created on the fly as needed, and always destroyed as soon as they have a value of 0 . Hence our algo-rithms use O ( M ) space (with one exception, see Sect. 4.2). Notation. For any t  X  0 , let G S = ( V S ,E S ) be the sub-graph of G ( t ) containing all and only the edges in the current sample S . We denote with N S u the neighborhood of u in G N u = { v  X  V ( t ) : ( u,v )  X  S} and with N S u,v = N S u the shared neighborhood of u and v in G S .
We first present tri X st-base , which works on insertion-only streams and uses standard reservoir sampling [37] to maintain the edge sample S :  X  If t  X  M , then the edge e t = ( u,v ) on the stream at time t is deterministically inserted in S .  X  If t &gt; M , tri X st-base flips a biased coin with heads probability M/t . If the outcome is heads, it chooses an edge ( w,z )  X  X  uniformly at random, removes ( w,z ) from S , and inserts ( u,v ) in S . Otherwise, S is not modified. After each insertion (resp. removal) of an edge ( u,v ) from S , tri X st-base calls the procedure UpdateCounters that increments (resp. decrements)  X  ,  X  u and  X  v by |N S u,v  X  by one, for each c  X  X  S u,v .
 The pseudocode for tri X st-base is presented in Alg. 1. Algorithm 1 tri X st-base Let  X  ( t ) (resp.  X  ( t ) u ) be the value of the counter  X  at the end of time step t (i.e., after the edge on the stream at time t has been processed by tri X st-base ) (resp. the value of the counter  X  u at the end of time step t if there is such a counter, 0 otherwise). When queried at the end of time t , tri X st-global (resp. local for u  X  V ( t ) ) triangle count. Analysis.

Theorem 1. We have
The tri X st-base estimations are not only unbiased in all cases , but actually exact for t  X  M , i.e., for t  X  M , they are the true global/local number of triangles in G ( t ) .
We now analyze the variance of the estimation returned by tri X st-base for t &gt; M (the variance is 0 for t  X  M .) Let t  X  of distinct triangles from  X  ( t ) u sharing an edge. 1 Similarly, pairs of distinct triangles from  X  ( t ) sharing an edge. We pairs of distinct triangles that do not share any edge, and analogously for w ( t ) u .

Theorem 2. For any t &gt; M , let f ( t ) =  X  ( t )  X  1 , and We have:
In our proofs, we carefully account for the fact that, as we use reservoir sampling [37], the presence of an edge a in S is not independent from the concurrent presence of an-other edge b in S . This is not the case for samples built using fixed-probability independent edge sampling. When computing the variance, we must consider not only pairs of triangles that share an edge (as for independent edge sampling approaches), but also pairs of triangles sharing no edge, as their respective presences in the sample are not independent events. The gain is worth the additional so-phistication needed in the analysis, because the contribu-tion to the variance by triangles not sharing edges is non-positive ( h ( t )  X  0 ), i.e., it reduces the variance. A compari-son of the variance of our estimator with that obtained with a fixed-probability independent edge sampling approach, is discussed below.

Let h ( t ) denote the maximum number of triangles sharing a single edge in G ( t ) . The following concentration theo-rem relies on 1. a result by Hajnal and Szemer X di [15] on graph coloring, 2. a novel concentration result for fixed-probability independent edge sampling, and 3. a Poisson-approximation-like result on probabilities of general events under reservoir sampling w.r.t. their probabilities under in-dependent edge sampling. These ingredients are then com-bined to obtain the following result. The details can be found in our extended online version [9].
Two distinct triangles can share at most one edge.
Theorem 3. Let t  X  0 and assume |  X  ( t ) | &gt; 0 . 2 For any  X , X   X  (0 , 1) , let If
Results analogous to those in Thms. 1, 2, and 3 hold for the local triangle count for any u  X  V ( t ) , replacing the global quantities with the corresponding local ones.
 Comparison with fixed-probability approaches. We now compare the variance of tri X st-base to the variance of the fixed probability sampling approach mascot-c [27], which samples edges independently with a fixed probability p and uses p  X  3 |  X  S | as the estimate for the global number of triangles at time t . As shown by Lim and Kang [27, Lemma 2], the variance of this estimator is where  X  f ( p ) = p  X  3  X  1 and  X  g ( p ) = p  X  1  X  1 .
Assume that we give mascot-c the additional information that the stream has finite length T , and assume we run mascot-c with p = M/T so that the expected sample size at the end of the stream is M . 3 Let V ( t ) fix be the resulting variance of the mascot-c estimator at time t , and let V ( t ) be the variance of our estimator at time t (see (1)). For For M &lt; t &lt; T , we can show the following result. Lemma 1. Let 0 &lt;  X  &lt; 1 be a constant. For any constant M &gt; max( 8  X  1  X   X  , 42) and any t  X   X T we have V ( t ) For example, if we set  X  = 0 . 99 and run tri X st-base with M  X  400 and mascot-c with p = M/T , we have that tri X st-base has strictly smaller variance than mascot-c for 99% of the stream.

What about t = T ? The difference between the definitions of
V ( t ) fix and V ( t ) is in the presence of  X  f ( M/T ) instead of term w ( t ) h ( M,t )  X  0 in our V ( t ) . Let M ( T ) be an arbitrary slowly increasing function of T . For T  X   X  we can show
A similar discussion also holds for the method we present in Sect. 4.2, and explains the results of our experimental evaluations, which show that our algorithms have strictly lower (empirical) variance than fixed probability approaches for most of the stream.
 Update time. The time to process an element of the stream is dominated by the computation of the shared neigh-borhood N u,v in UpdateCounters . A Mergesort -based algorithm for the intersection requires O (deg( u ) + deg( v ))
If |  X  ( t ) | = 0 , our algorithms correctly estimate 0 triangles.
We are giving mascot-c a significant advantage: if only space M were available, we should run mascot-c with a sufficiently smaller p 0 &lt; p , otherwise there would be a con-stant probability that mascot-c would run out of memory. time, where the degrees are w.r.t. the graph G S . By storing the neighborhood of each vertex in a Hash Table (resp. an AVL tree), the update time can be reduced to O (min { deg( v ) , deg( u ) } ) (resp. amortized time O (min { deg( v ) , deg( u ) } + log max { deg( v ) , deg( u ) } ) ). tri X st-impr is a variant of tri X st-base with small mod-ifications that result in higher-quality (i.e., lower variance) estimations. The changes are: 1.

UpdateCounters is called unconditionally for each ele-ment on the stream , before the algorithm decides whether or not to insert the edge into S . W.r.t. the pseudocode in Alg. 1, this change corresponds to moving the call to
UpdateCounters on line 6 to before the if block. mas-cot [27] uses a similar idea, but tri X st-impr is signif-icantly different as tri X st-impr allows edges to be re-moved from the sample, since it uses reservoir sampling. 2. tri X st-impr never decrements the counters when an edge is removed from S . W.r.t. the pseudocode in Alg. 1, we remove the call to UpdateCounters on line 13. 3.

UpdateCounters performs a weighted increase of the counters using  X  ( t ) = max { 1 , ( t  X  1)( t  X  2) / ( M ( M  X  1)) } as weight. W.r.t. the pseudocode in Alg. 1, we replace  X  1  X  with  X  ( t ) on lines 19 X 22 (given change 2 above, all the calls to UpdateCounters have  X  = + ).
 Counters. If we are interested only in estimating the global number of triangles in G ( t ) , tri X st-impr needs to maintain only the counter  X  and the edge sample S of size M , so it still requires space O ( M ) . If instead we are interested in estimating the local triangle counts, at any time t tri X st maintains (non-zero) local counters only for the nodes u such that at least one triangle with a corner u has been detected by the algorithm up until time t . The number of such nodes may be greater than O ( M ) , but this is the price to pay to obtain estimations with lower variance (Thm. 5).
 Estimation. When queried for an estimation, tri X st-impr returns the value of the corresponding counter, unmodified. Analysis.
 Theorem 4. We have  X  ( t ) = |  X  ( t ) | if t  X  M and E As in tri X st-base , the estimations by tri X st-impr are ex-act at time t  X  M and unbiased for t &gt; M .

We now show an upper bound to the variance of the tri X st-impr estimations for t &gt; M . The proof relies on a very care-ful analysis of the covariance of two triangles which depends on the order of arrival of the edges in the stream (which we assume to be adversarial). Let z ( t ) be the number of un-ordered pairs (  X , X  ) of distinct triangles in G ( t ) that share an edge g and are such that g is neither the last edge of  X  on the stream nor the last edge of  X  on the stream. For any node u  X  V ( t ) , let z ( t ) u be similarly defined, but considering only the triangles incident to u .
 Theorem 5. Then, for any time t &gt; M , we have For the sake of clarity, in Thm. 5, we chose not to present a stricter but more complex bound involving triangles that do not share any edge, which, as in Thm. 2, would add a non-positive term to the variance (i.e., reduce the variance). The following result relies on Chebyshev X  X  inequality and Thm. 5.

Theorem 6. Let t  X  0 and assume |  X  ( t ) | &gt; 0 . For any  X , X   X  (0 , 1) , if M &gt; max In Thms. 5 and 6, it is possible to replace the value z ( t ) the more interpretable r ( t ) , which is agnostic to the order of the edges on the stream but gives a looser upper bound to the variance.

Results analogous to those in Thms. 4, 5, and 6 hold for the local triangle count for any u  X  V ( t ) , replacing the global quantities with the corresponding local ones. tri X st-fd computes unbiased estimates of the global and local triangle counts in a fully-dynamic stream where edges are inserted/deleted in any arbitrary, adversarial order . It is based on random pairing (RP) [14], a sampling scheme that extends reservoir sampling and can handle deletions. The idea behind the RP scheme is that edge deletions seen on the stream will be  X  X ompensated X  by future edge insertions. Following RP, tri X st-fd keeps a counter d i (resp. d o ) to keep track of the number of uncompensated edge deletions involving an edge e that was (resp. was not ) in S at the time the deletion for e was on the stream.

When an edge deletion for an edge e  X  E ( t  X  1) is on the stream at the beginning of time step t , then, if e  X  X  at this time, tri X st-fd removes e from S (effectively decreasing the number of edges stored in the sample by one) and increases d by one. Otherwise, it just increases d o by one. When an edge insertion for an edge e 6 X  E ( t  X  1) is on the stream at the beginning of time step t , if d i + d o = 0 , then tri X st-fd follows the standard reservoir sampling scheme. If |S| &lt; M , then e is deterministically inserted in S without removing any edge from S already in S , otherwise it is inserted in S with probability M/t , replacing an uniformly-chosen edge already in S . If instead d i + d o &gt; 0 , then e is inserted in S with probability d i / ( d i + d o ) ; since it must be d then it must be |S| &lt; M and no edge already in S needs to be removed. In any case, after having handled the eventual insertion of e into S , the algorithm decreases d i by 1 if e was inserted in S , otherwise it decreases d o by 1 . tri X st-fd keeps track of s ( t ) = | E ( t ) | by appropriately incrementing or decrementing a counter by 1 depending on whether the element on the stream is an edge insertion or deletion. The pseudocode for tri X st-fd is presented in Alg. 2 where the UpdateCounters procedure is the one from Alg. 1.
 Estimation. We denote as M ( t ) the size of S at the end of time t (we always have M ( t )  X  M ). For any time t , let d and d ( t ) o be the value of the counters d i and d o at the end of time t respectively, and let  X  ( t ) = min { M,s ( t ) + d Define  X  Algorithm 2 tri X st-fd For any three positive integers a,b,c s.t. a  X  b  X  c , define When queried at the end of time t , for an estimation of the global number of triangles, tri X st-fd returns  X  When estimating |  X  ( t ) u | for u  X  V ( t ) , the definition for  X  uses  X  ( t ) u and has the additional condition that  X  ( t ) there is no counter  X  u . tri X st-fd can keep track of  X  ( t ) during the execution, each update of  X  ( t ) taking time O (1) . Hence the time to return the estimations is still O (1) . Analysis. Let t  X  be the first t  X  M + 1 such that | E ( t ) M + 1 , if such a time step exists (otherwise t  X  = +  X  ).
Theorem 7. We have  X  ( t ) = |  X  ( t ) | for all t &lt; t E The proof relies on properties of RP and on the definitions
Theorem 8. Let t &gt; t  X  s.t. |  X  ( t ) | &gt; 0 and s ( t ) deletions at time t , with 0  X   X  &lt; 1 . If M  X  1 for some  X  &lt;  X  0 &lt; 1 , we have:
The following result relies on Chebyshev X  X  inequality and on Thm. 8.
Theorem 9. Let t  X  t  X  s.t. |  X  ( t ) | &gt; 0 and s ( t )  X , X   X  (0 , 1) , if for some  X  &lt;  X  0 &lt; 1
M &gt; max
Results analogous to those in Thms. 7, 8, and 9 hold for the local triangle count for any u  X  V ( t ) , replacing the global quantities with the corresponding local ones.
We evaluated tri X st on several real-world graphs with up to a billion edges. The algorithms were implemented in C++, and ran on the Brown University CS department cluster. 4 Each run employed a single core and used at most 4 GB of RAM. We report here only a subset of the results. Additional details are available in the extended online ver-sion. The code is available from http://bigdata.cs.brown. edu/triangles.html.
 licly available graphs (properties in Table 1).
 Patent (Co-Aut.) and Patent (Cit.). The Patent (Co-Aut.) and Patent (Cit.) graphs are obtained from a dataset of  X  2 million U.S. patents granted between  X 75 and  X 99 [16]. In Patent (Co-Aut.) , the nodes represent inventors and there is an edge with timestamp t between two co-inventors of a patent if the patent was granted in year t . In Patent (Cit.) , nodes are patents and there is an edge ( a,b ) with timestamp t if patent a cites b and a was granted in year t . LastFm. The LastFm graph is based on a dataset [7, 34] of  X  20 million last.fm song listenings,  X  1 million songs and  X  1000 users. There is a node for each song and an edge between two songs if  X  3 users listened to both on day t . Yahoo! Answers. The Yahoo! Answers graph is obtained from a sample of  X  160 million answers to  X  25 millions questions posted on Yahoo! Answers [38]. An edge connects two users at time max ( t 1 ,t 2 ) if they both answered the same question at times t 1 , t 2 respectively. We removed 6 outliers questions with more than 5000 answers.
 Twitter. This is a snapshot [5, 24] of the Twitter follow-ers/following network with  X  41 million nodes and  X  1 . 5 billions edges. We do not have time information for the edges, hence we assign a random timestamp to the edges (of which we ignore the direction).
 Ground truth. To evaluate the accuracy of our algorithms, we computed the ground truth for our smaller graphs (i.e., the exact number of global and local triangles for each time step), using an exact algorithm. The entire current graph is stored in memory and when an edge u,v is inserted (or deleted) we update the current count of local and global https://cs.brown.edu/about/system/services/hpc/grid/ Table 1: Properties of the dynamic graph streams analyzed. | V | , | E | , | E u | , |  X  | refer respectively to the number of nodes appearing in the graph, the num-ber of edge addition events, the number of distinct edges additions, and the maximum number of trian-gles in the graph (for Yahoo! Answers and Twitter estimated with tri X st-impr M = 1000000 , otherwise computed exactly with the na X ve algorithm). Figure 1: Estimation by tri X st-impr of the global number of triangles over time. Our estimations have very small error and variance: the ground truth is indistinguishable from max/min point-wise estima-tion over ten runs. triangles by checking how many triangles are completed (or broken). As exact algorithms are not scalable, computing the exact triangle count is feasible only for small graphs such as Patent (Co-Aut.), Patent (Cit.) and LastFm. Table 1 reports the exact total number of triangles at the end of the stream for those graphs (and an estimate for the larger ones using tri X st-impr with M = 1000000 ).
We now evaluate tri X st on insertion-only streams and compare its performances with those of state-of-the-art ap-proaches [18, 27, 32], showing that tri X st has an average es-timation error significantly smaller than these methods both for the global and local estimation problems, while using the same amount of memory.
 Estimation of the global number of triangles. Start-ing from an empty graph we add one edge at a time, in timestamp order. Figure 1 illustrates the evolution, over time, of the estimation computed by tri X st-impr with M = 1 , 000 , 000 . For smaller graphs for which the ground truth can be computed exactly, the curve of the exact count is practically indistinguishable from our estimation showing the precision of the method. Our estimators have very small variance even on the very large Yahoo! Answers graph (point-wise max/min estimation over ten runs is almost co-incident with the average estimation). These results show that tri X st-impr is very accurate even when storing less than a 0 . 001 fraction of the total edges of the graph. Comparison with the state of the art. We compare quantitatively with three state-of-the-art methods: Mas-Table 2: Global triangle estimation MAPE for tri X st and Mascot . The rightmost column shows the reduction in terms of the avg. MAPE ob-tained by using tri X st . Rows with Y in column  X  X mpr. X  refer to improved algorithms ( tri X st-impr and mascot-i ) while those with N to basic algo-rithms ( tri X st-base and mascot-c ).
 Table 3: Comparison of the quality of the local tri-angle estimations in LastFM between tri X st-impr and Mascot-I ). We outperform Mascot-I using the same amount of memory. cot [27], Jha et al. [18] and Pavan et al. [32]. Mas-cot is a suite of local triangle counting methods (but pro-vides also a global estimation). The other two are global triangle counting approaches. None of these can handle fully-dynamic streams, in contrast with tri X st-fd . We first compare the three methods to tri X st for the global trian-gle counting estimation. Mascot comes in two memory efficient variants: the basic Mascot-C variant and an im-proved Mascot-I variant. 5 Both variants sample edges with fixed probability p , so there is no guarantee on the amount of memory used during the execution. To ensure fairness of comparison, we devised the following experiment. First, we run both Mascot-C and Mascot-I for ` = 10 times with a fixed p using the same random bits for the two algo-rithms run-by-run (i.e. the same coin tosses used to select the edges) measuring each time the number of edges M 0 i stored in the sample at the end of the stream (by construc-tion this the is same for the two variants run-by-run). Then, we run our algorithms using M = M 0 i (for i  X  [ ` ] ). We do the same to fix the size of the edge memory for Jha et al. [18] and Pavan et al. [32]. 6 This way, all algorithms use the same amount of memory for storing edges (run-by-run).
We use the MAPE (Mean Average Percentage Error) to assess the accuracy of the global triangle estimators over time. The MAPE measures the average percentage of the
In the original work [27], this variant had no suffix and was simply called Mascot . We add the -I suffix to avoid confusion. The variant Mascot-A can be forced to store the entire graph with probability 1 (using an adversarial edge order) so we do not consider it here.
More precisely, we use M 0 i / 2 estimators in Pavan et al. as each estimator stores two edges. For Jha et al. we set the two reservoirs in the algorithm to have each size M 0 This way, all algorithms use M 0 i cells for storing (w)edges. Figure 2: Average MAPE and average update time of the various methods on the Patent (Co-Aut.) graph with p = 0 . 01  X  insertion only. tri X st-impr has the lowest error. Both Pavan et al. and Jha et al. have very high update times compared to our method and the two Mascot variants. prediction error with respect to the ground truth, and is widely used in the prediction literature [17]. For t = 1 ,...,T , let  X  ( t ) be the estimator of the number of triangles at time
In Fig. 2(a), we compare the average MAPE of tri X st-base and tri X st-impr as well as the two Mascot variants and the other two streaming algorithms for the Patent (Co-Aut.) graph, fixing p = 0 . 01 . tri X st-impr has the smallest error of all the algorithms compared.

We now turn our attention to the efficiency of the meth-ods. Figure 2(b) shows the average update time per opera-tion in Patent (Co-Aut.) graph, fixing p = 0 . 01 . Both Jha et al. [18] and Pavan et al. [32] are up to  X  3 orders of magnitude slower than the Mascot variants and tri X st . This is expected as both algorithms have an update com-plexity of  X ( M ) (they have to go through the entire reser-voir graph at each step), while both Mascot algorithms and tri X st need only to access the neighborhood of the nodes involved in the edge addition. 8 This allows both al-gorithms to efficiently exploit larger memory sizes. We can use efficiently M up to 1 million edges in our experiments,
The MAPE is not defined for t s.t.  X  ( t ) = 0 so we compute it only for t s.t. |  X  ( t ) | &gt; 0 . All algorithms we consider are guaranteed to output the correct answer for t s.t. |  X  ( t )
We observe that Pavan et al. [32] would be more efficient with batch updates. However, we want to estimate the tri-angles continuously at each update. In their experiments they use batch sizes of million of updates for efficiency. Figure 3: Variance of tri X st-impr with M = 10000 and of mascot with same expected memory, on LastFM. tri X st-impr has a smaller variance: the max/min estimation lines are closer to the ground truth. (Average estimations are qualitatively similar and not shown). which only requires few megabytes of RAM. 9 Mascot is one order of magnitude faster than tri X st (which runs in  X  28 micros/op), because it does not have to handle edge removal from the sample, as it offers no guarantees on the used memory. As we will show, tri X st has much higher precision and scales well on billion-edges graphs.
Given the slow execution of the other algorithms on the larger datasets we compare in details tri X st only with Mas-cot . 10 Table 2 shows the average MAPE of the two ap-proaches. The results confirm the pattern observed in Fig-ure 2(a): tri X st-base and tri X st-impr both have an aver-age error significantly smaller than that of the basic Mascot-C and improved Mascot variant respectively. We achieve up to a 91% (i.e., 9 -fold) reduction in the MAPE while us-ing the same amount of memory. This experiment confirms the theory: reservoir sampling has overall lower or equal variance in all steps for the same expected total number of sampled edges. To further validate this observation we run tri X st-impr and of the improved Mascot variant using the same (expected memory) M = 10000 . Figure 3 shows the max-min estimation over 10 runs. tri X st-impr shows significantly lower variance over the evolution: the maxmin estimation lines are closer to the ground truth virtually all time. This confirms our theoretical observations in the pre-vious sections. Even with very low M (about 2 / 10000 of the size of the graph) tri X st gives a good estimation. Local triangle counting. We compare the precision in local triangle count estimation of tri X st with that of Mas-cot [27] using the same approach of the previous experi-ment. We can not compare with Jha et al. and Pavan et al. algorithms as they provide only global estimation. As in [27], we measure the Pearson coefficient and the average  X  error (see [27] for definitions). In Table 3 we report the Pearson coefficient and average  X  error over all timestamps for the smaller graphs. 11 tri X st (significantly) improves
The experiments in [18] use M in the order of 10 3 , and in [32], large M values require large batches for efficiency.
We attempted to run the other two algorithms but they did not complete after 12 hours for the larger datasets in Table 2 with the prescribed p parameter setting.
For efficiency, in this test we evaluate the local number of triangles of all nodes every 1000 edge updates. Figure 4: Trade-offs between M and MAPE or avg. update time (  X  s)  X  edge insertion only. Higher M implies lower errors but higher update times. (i.e., has higher correlation and lower error) over the state-of-the-art Mascot , using the same amount of memory. Memory vs accuracy trade-offs. We study the tradeoff between the sample size M vs the running time and accuracy of the estimators. Figure 4(a) shows the tradeoffs between the accuracy of the estimation and the size M for the smaller graphs for which the ground truth number of triangles can be computed exactly using the naive algorithm. Even with small M tri X st-impr achieves very low MAPE value. As expected, larger M corresponds to higher accuracy and for the same M tri X st-impr outperforms tri X st-base . Fig-ure 4(b) shows the average time per update in microseconds (  X  s) for tri X st-impr as function of M . Larger M requires longer update times (a larger sample implies larger graph on which to count triangles). On average a few hundreds of microseconds are sufficient for handling any update even in very large graphs with billions of edges. Our algorithms can handle hundreds of thousands of edge updates per second with very small error (Fig. 4(a)), and therefore can be used efficiently and effectively in high-velocity contexts. Alternative edge orders. In all previous experiments the edges are added in their natural order (i.e., in order of their appearance). 12 While the natural order is the most impor-tant use case, we have assessed the impact of other ordering on the accuracy of the algorithms. We experiment with both the uniform-at-random (u.a.r.) order of the edges and the random BFS order: until all the graph is explored a BFS is started from a u.a.r. unvisited node and edges are added in order of their visit (neighbors are explored in u.a.r. order). The results for the random BFS order (Fig. 5) and for the
Excluding twitter for which we used the random order, given the lack of timestamps. Figure 5: Average MAPE on Patent (Co-Aut.), with p = 0 . 01  X  insertion only in Random BFS order. tri X st-impr has the lowest error. Figure 6: Evolution of the global number of triangles  X  fully dynamic case. u.a.r. (omitted for lack of space) confirm that tri X st has the lowest error and is very scalable in every tested ordering.
We evaluate tri X st-fd on fully-dynamic streams. We cannot compare tri X st-fd with the algorithms previously used [18, 27, 32] as they only handle insertion-only streams.
In the first set of experiments we model deletions using the widely used sliding window model , where a sliding window of the most recent edges defines the current graph. The sliding window model is of practical interest as it allows to observe recent trends in the stream. For Patent (Co-Aut.) &amp; (Cit.) we keep in the sliding window the edges generated in the last 5 years, while for LastFm we keep the edges generated in the last 30 days. For Yahoo! Answers we keep the last 100 millions edges in the window 13 .

Figure 6 shows the evolution of the global number of tri-angles in the sliding window model using tri X st-fd us-ing M = 200 , 000 ( M = 1 , 000 , 000 for Yahoo! Answers). The sliding window scenario is significantly more challeng-ing than the addition-only case (very often the entire sample of edges is flushed away) but tri X st-fd maintains good vari-
The sliding window model is not interesting for the Twitter dataset as edges have random timestamps. We omit the re-sults for Twitter but tri X st-fd is fast and has low variance. Figure 7: Trade-offs between the avg. update time (  X  s) and M for tri X st-fd .
 ance and scalability even when, as for LastFm and Yahoo! Answers, the global number of triangles varies quickly.
Continuous monitoring of triangle counts with tri X st-fd allows to detect patterns that would otherwise be difficult to notice. For LastFm (Fig. 6(c)) we observe a sudden spike of several order of magnitudes. The dataset is anonymized so we cannot establish which songs are responsible for this spike. In Yahoo! Answers (Fig. 6(d)) a popular topic can create a sudden (and shortly lived) increase in the number of triangles, while the evolution of the Patent co-authorship and co-citation networks is slower, as the creation of an edge requires filing a patent (Fig. 6(a) and (b)). The almost constant increase over time 14 of the number of triangles in Patent graphs is consistent with previous observations of densification in collaboration networks as in the case of nodes X  degrees [26] and the observations on the density of the densest subgraph [13].

Table 4 shows the results for both the local and global triangle counting estimation provided by tri X st-fd . In this case we can not compare with previous works, as they only handle insertions. It is evident that precision improves with M values, and even relatively small M values result in a low MAPE (global estimation), high Pearson correlation and low  X  error (local estimation). Figure 7 shows the tradeoffs between memory (i.e., accuracy) and time. In all cases our algorithm is very fast and it presents update times in the order of hundreds of microseconds for datasets with billions of updates (Yahoo! Answers).
 Alternative models for deletion. We evaluate tri X st-fd using other models for deletions than the sliding window model. To assess the resilience of the algorithm to massive deletions we run the following experiment. We added edges in their natural order but each edge addition is followed with probability q by a mass deletion event where each edge cur-
The decline at the end is due to the removal of the last edges from the sliding window after there are no more edge additions. rently in the graph is deleted with probability d indepen-dently. We run experiments with q = 3 , 000 , 000  X  1 (i.e., a mass deletion expected every 3 millions edges) and d = 0 . 80 (in expectation 80% of edges are deleted). We observe that tri X st-fd maintains a good accuracy and scalability even in face of a massive (and unlikely) deletions of the vast ma-jority of the edges: e.g., for LastFM with M = 200000 (resp. M = 1 , 000 , 000 ) we observe 0 . 04 (resp. 0 . 006 ) Avg. MAPE. More results are available in our full version online [9].
We presented tri X st , the first suite of algorithms that use reservoir sampling and its variants to continuously main-tain unbiased, low-variance estimates of the local and global number of triangles in fully-dynamic graphs streams of ar-bitrary edge/vertex insertions and deletions using a fixed, user-specified amount of space. Our experimental evaluation shows that tri X st outperforms state-of-the-art approaches and achieves high accuracy on real-world datasets with more than one billion of edges, with update times of hundreds of microseconds. Interesting directions for future work include the use of color-coding techniques [30], and the extension to 3 -profiles and complex graph motifs [11].
 Acknowledgments. This work was supported in part by NSF grant IIS-1247581 and NIH grant R01-CA180776.
