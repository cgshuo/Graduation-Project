 The active participation of end-users in the early phases of the software development life-cycle is key when developing software [1]. Among other benefits, the collaboration promotes a continual validation of the software to be build [2], thus guaranteeing that the final software will satisfy the users X  needs.

When the software targets a very specific and complex domain, this collaboration makes even more sense. Only the end-users have the domain knowledge required to drive the development. This is exactly the scenario we face when specifying a Domain-Specific Modeling Language (DSML). A DSML is a language specifically designed to perform a task in a certain domain. DSMLs a ppeared as an alternative to General-Purpose (modeling) Languages (GPLs), like UML, to facilitate the modeling of systems in domains that could not be easily represented using the concepts provided by GPLs.
Clearly, to be useful, the concepts and notation of a DSML should be as close as possible to the domain concepts and representation used by the end-users in their daily practice. Therefore, the role of domain expe rts during the DSML specification is vital, as noted by several authors [3,4]. Unfortunately, nowadays participaton of end-users is still mostly restricted to the initial set of interviews to help designers analyze the domain and/or to test the language at the end, which re quires the development of fully functional language prototypes (including a model editor, a parser, etc.) [4,5]. This long iteration cycle is a time-consuming and repetitive task that hinders the process performance [3] since end-users must wait until the end to see if designers correctly understood all the intricacies of the domain. A second major problem is the lack of traceability of the design decisions. The rationale behind decisions made during the language specification are implicit so it is not possible to understand or justify why, for instance, a certain element of the language was created in that specific way or given that particular type. This hampers the future evolution of the language.

Existing project management tools such as Trac 1 or Jira 2 provide the environments required to develop collaboratively software systems. These tools enable the end-user participation during the process, thus allo wing developers to receive feedback at any time [6]. However, their support is usually defined at file level, meaning that discussions and change tracking are expressed in terms of lines of textual files. This is a limitation when developing DSMLs, where a special support to discuss at language element level (i.e., domain concepts and notation symbols) is required to address the two challenges previously described and therefore promote the participation of the end-users. In order to alleviate these shortcommings, in this paper we present Collaboro ,a DSML which enables the involvement of the community (i.e., end-users and develop-ers) in the DSML creation process. The language allows modeling the collaborations between community members taking place during the definition of a new DSML. Col-laboro supports both the collaborative definitio n of the abstract (i.e., metamodel) and concrete (i.e., notation) syntaxes for DSMLs by providing specific constructs to enable the discussion. Thus, each community member will have the chance to request changes, propose solutions and give an opinion (and vote) about those from others. We believe this discussion will enrich the language de finition significantly and ensure that the end result satisfies as much as possible the expectations of the end-users. Moreover, the explicit recording of these interactions will provide plenty of valuable information to explain the language evolution and justify all design decisions behind it, as also pro-posed in requirement engineering [7]. Together with the Collaboro DSML we provide the tooling infrastructure and process guidance required to apply Collaboro in practice. Paper Structure . Section 2 presents the collaborative process we are proposing while Section 3 the language infrastructure needed. Next, the implemented tool and a case study are described in sections 4 and 5, re spectively. Finally, Section 6 reviews the related work and Section 7 draws some conclusions and future work. A DSML is defined through three main components [8]: abstract syntax, concrete syn-tax, and semantics. The abstract syntax defines both the language concepts and their relationships, and also includes well-formedness rules constraining the models that can be created with the language. Metamodellin g techniques are normally used to define the abstract syntax. The concrete syntax defines a notation (textual, graphical or hybrid) for the concepts in the abstract syntax, and a translational approach is normally used to provide semantics, though most of th e time it is no explicitly formalized 3 .
The development of a DSML consists in five different phases [4]: decision, analysis, design, implementation and deployment. The first three phases are mainly focused on the DSML definition whereas the implementation phase is aimed at developing the tool-ing support (i.e., modeling environment, parser,...) for the DSML. Clearly, the commu-nity around the language is a key element in the process. We call community the group of people involved with the DSML under development, which includes both technical level users (i.e., language developers) and domain expert users (i.e., end-users of the language), where both categories can overlap, especially when the DSML is a technical DSML.

As a running example, imagine the development of a DSML for managing the trans-portation service of a city. Typically, the domain expert users are only heavily involved at the very beginning and very end of the p rocess. Assuming this is also the case for our transportation DSL, during the analysis phase, the developers will study the trans-portation domain with the help of the city hall members in charge of the city trans-portation policies and decide that it should include concepts such as Vehicle (i.e., Bus or Tram ), and Route , which is composed by Stop s. The developers therefore design and later implement the tooling of the language, thus coming up with a tex-tual DSML whose abstract syntax and an example of the concrete syntax are shown in Figure 1 (all elements except the ones included in grey-filled boxes). Once the lan-guage is developed, end-users can play with it and check whether it fits their needs. Quite often, if the end-users only provided the initial input but did not closely follow how that was interpreted during the language design, they will detect problems in the modeling environment (e.g., missing concepts, wrong notation, etc.) that will trigger a new (and costly) iteration to modify the language and recreate all the associated tools. For instance, end-users could detect that the language lacks of a construct to represent whether a Stop is adapted for handicapped people.
 Therefore, our aim is to incorporate the community collaboration aspect into all DSML definition phases, making the early phases of the process more participative and promoting the early detection of possible bugs or problems. The resulting collab-orative process is summarized in Figure 2. O nce there is an agreement to create the language, community defines the collaboration strategy to make decisions (e.g., how can vote, number of votes to reach an agreemen t, etc.). Next, language developers get the requirements from the end-users to create a preliminary version of the language to kickstart the actual collaboration process (step 1). This first version should include at least a partial abstract syntax but could also include a first concrete syntax draft (see DSML Definition ). An initial set of sample models conforming to the DSML are also defined to facilitate an example-based discussion, usually easier for non-technical users. These sample models are rendered according to the current concrete syntax definition (see Rendered Examples ). It is worth noting that the rendering is done on-the-fly with-out the burden of generating the DSML tooling since we are just showing the snapshots of the models to discuss the notation, not actually providing at this point a full modeling environment.
 Now the community starts working together in order to shape the language (step 2). Community members can propose ideas or changes to the DSML, e.g., they can ask for modifications on how some concepts should be represented (both at the abstract and concrete syntax levels). These change proposals are shared in the community, who can also suggest and discuss how to improve the change proposals themselves. All community members can also suggest solutions for the requested changes and give their opinion on the solutions presented by others. At any time, rendering the sample models with the latest proposals gives members an idea of how a proposal will evolve the language (if accepted). All these proposals and solutions (see Collaborations )are eventually accepted or rejected.

Acceptance/rejection depends on whethe r the community reach es an agreement re-garding the proposal/solution. For that, community members can vote (step 3). A de-cision engine (see Decision Engine ) then takes these votes into account to calculate which collaborations are accepted/rejected by the community. The engine could follow an automatic process (accordin g to the collaboration strat egy defined at the beginning of the process) but a specific role of community manager could also be assigned to a member/s to consolidate the proposals and get a consensus on conflicting opinions (e.g., when there is no agreement between techni cal and business considerations). Once an agreement is reached, the contents of the sol ution are incorporated into the language, thus creating a new version. The process keeps iterating until no more changes are pro-posed. Note that these changes on the language may also have an impact on the model examples which may need to be updated to the new language definition.
 At the end of the collaboration, the final DSML definition is used to implement the DSML tooling (see DSML Tooling ) with the confidence that it has been validated by the community. Note that even whether the language does not comply to commonly applied quality patterns (e.g., graphical vs . textual, redundant elements in the DSML, etc.), developers can be sure that fulfills th e end-users X  needs. Moreover, all aspects of the collaboration are recorded (see Collaboration History ), thus keeping track of every interaction and change performed in th e language. Therefore, at any moment, this traceability information can be queried to discover the rationale behind the elements of the language (e.g., the argumenta tion provided for its acceptance).

To illustrate our approach, the development of the Transport DSML mentioned above could have been included the following collaboration scenario. The developers start designing a very first version of the language. Then, the collaboration begins and a community member detects the need of expressing the support for handicapped people when checking some language snapshots. Si nce now we are still in the definition phase the community has the chance to discuss the best way to adapt the language to support this new handicapped information. The mem ber that identified a problem would cre-ate a change proposal. If the change is deemed as important by the community, other members could propose a solution/s to ada pt the language. As an example, Figure 3 graphically depicts a possible collaboration scenario assuming a small community of one end-user and two developers. Each collaboration is represented as a bubble and each step has been numbered. In the Figure, End-User 1 proposes a language change (step 1), which is accepted by the community (step 2), and then Developer 1 specifies a solution (step 3). The solution is rejected by End-User 1 , including also the explanation of the rejection (step 4). As the rejection is accepted (step 5), the Developer 1 redefines the solution, which is eventually accepted ( step 6) and the changes are then incorpo-rated into the language. The resulting changes i n the abstract and concrete syntaxes are shown in grey-filled boxes in Figure 1a. Clearly, it is important to make this collabora-tion iterations as quick as possible and with the participation of all types of community members. Moreover, the discussion information itself must be preserved to justify the rationale behind each language evolution, from which desi gn decisions can be derived. Our proposal for enabling the collaborativ e definition of DSMLs is built on top of the Collaboro DSML, a DSML for modeling the collaborations that arise in a community working towards the development of a DSML for that community. In the next sections we will describe how Collaboro makes the collaboration feasible by (1) enabling the discussion about DSML elements, (2) providing the metaclasses for representing col-laborations and (3) giving support to the decision-making process regarding the changes to be incorporated into the DSML based on the results of the collaboration so far. 3.1 Representing the Elements of a DSML To be able to discuss about changes on the DSML to-be, we must be able to represent its elements both the abstract syntax (i.e., the concepts of the DSML) and the concrete syntax (the notation to represent those concepts) elements. The abstract syntax is com-monly defined by means of a metamodel wr itten using a metamodelling language (e.g., MOF or Ecore). Metamodelling languages normally offer a limited set of concepts to be used when creating DSML metamodels (like types, relationship or hierarchy). A DSML metamodel is then defined as an instantiation of this metamodeling concepts. Figure 4a shows an excerpt of the well-known Ecore metamodelling language.

Regarding the concrete syntax, since the notation of a DSML is also domain-specific, to promote the discussion we need to be able to explicitly represent the elements defin-ing the notation of a DSML. Thus, community members will have the freedom to create a notation specially adapted to their domain, thus avoiding coupling with other exist-ing notations (e.g., Java-based textual languages or UML-like diagrams). Given that nowadays there is no technology-independe nt metamodel to model the concrete syn-tax of a DSML, we have defined our own metamodel for concrete syntaxes. Figure 4b shows an excerpt of the core elements of this notation metamodel. As can be seen, the metamodel is far from exhaustive but it suffices to discuss about the concrete syntax elements most commonly used in the definitio n of graphical, textual or hybrid concrete syntaxes. Note that with this metamodel, it is possible to describe how to represent each language concept, thus facilitating keeping track of language changes.

Concrete syntax elements are classified following the NotationElement hierar-chy, which includes graphical elements ( GraphicalElement metaclass), textual ele-ments ( TextualElement metaclass), composite elements ( Composite metaclass) and references to the concrete synt ax of other abstract elements ( SyntaxOf meta-class) to be used in composite patterns. The main graphical constructs are provided by the GraphicalElement hierarchy, which allows referring to external pictures ( External metaclass), building figures (see Figure hierarchy), lines ( Line meta-class) and labels for the DSML elements. A label ( Label metaclass) serves as a con-tainer for a textual element. Textual elements can be defined with the TextualElement hierarchy, which includes tokens, keywords and values directly taken from the abstract syntax elements expressed in a textual form ( Value metaclass). It is possible to obtain the textual representation from either an attribute ( AttValue metaclass) by specifying the attribute to be queried ( attribute reference), or a reference ( RefValue meta-class) by specifying both the reference ( reference reference) and the attribute of the referred element to be used ( attribute reference). The attribute sep of the Value metaclass allows defining the separator for multivalued elements. The Composite el-ement can be used to define complex concrete syntax structures, allowing both graph-ical and textual composites but also hybrids. Finally, the SyntaxOf metaclass allows referencing to already specified concrete synt ax definitions of abstract syntax elements, thus allowing modulariza tion and composition. The reference reference of the SyntaxOf metaclass specifies the reference to be queried to obtain the set of elements whereas the sep reference indicates the separator between elements.

As example of the notation metamodel, Figure 4c shows the notation model for the textual representation of the metaclass Tram of the Transport DSML. Note that AttValue and RefValue metaclass instances are referring to elements from the ab-stract syntax metamodel. 3.2 Representing the Collaborations The third metamodel required in the Collaboro process focuses on representing the collaborations that annotate/modify the DSML elements described before. This collab-oration metamodel, which is shown in Figure 5, allows representing both static (e.g., change proposals) and dynamic (e.g., voting) aspects of the collaboration. A prelimi-nary version of this metamodel was presented in [9] but, among other limitations, only supported the collaborative design of abstract syntaxes.
 Static Part. Similarly to how version control systems track source code, Collaboro also allows representing different versions of a DSML. The VersionHistory meta-class represents the set of versions ( Version metaclass) through which the collabo-ration evolves. There is always a main version history set as trunk ( type attribute in VersionHistory metaclass), which keeps the baseline of the collaborations about the language under development. Other version histories (similar to branches) can be forked when it is necessary to isolate the collaboration about concrete parts of the lan-guage. Different version histories can be merged into a new one (or the trunk ).
Language evolution is the cons equence of collaborations ( Collaboration meta-class). Collaboro supports three types of collaborations: change proposals ( Proposal metaclass), solutions proposals ( Solution metaclass) and comments ( Comment metaclass). A collaboration is proposed by a user ( proposedBy reference) and in-cludes an explanation ( rationale attribute).
A change proposal describes which language feature should be modified and con-tains some meta information (e.g., priority or tags). Change proposals are linked to the set of solutions proposed by the community to be discussed for agreement. It is also possible to specify possible conflicts between similar proposals (e.g., the acceptance of one proposal can involve rejecting others) with the conflictWith reference.
Solution proposals are the answer to change proposals and describe how the language should be modified to i ncorporate the new features. Each solution definition involves a set of add/update/delete changes on the elements of the DSML ( Change hi-erarchy). Change links the collaboration metamodel with the DSML under discussion ( SyntaxElement metaclass), which can refer to the abstract syntax ( AbstractSyn taxElement metaclass) or the concrete syntax ( ConcreteSyntaxElement meta-class). The latter links ( maps reference) to the abstract elem ent to which the notation is defined. Both AbstractSyntaxElement and ConcreteSyntaxElement have a reference linking to the element which is being changed ( element reference). Changes in the abstract syntax are expressed in terms of the metamodelling language (i.e., EMode lElement elements, which is the interf ace implemented by every ele-ment in the Ecore metamodel) while change s in the concrete syntax are expressed in terms of elements conforming to the notation metamodel presented before.

The metaclass Change has a reference to the container element affected by the change ( referredElement reference) and the element to change ( target refer-ence). Thereby, in the case of Add and Delete metaclasses, referredElement refers to the element to which we want to add/delete a  X  X hild X  element whereas target refers to the actual element to be added/deleted. In the case of the Update metaclass, referredElement refers to the element which contains the element to be updated (e.g., a metaclass) whereas target refers to the new version of the element being up-dated (e.g., a new version for an attribute). The additional source attribute indicates the element to be updated (e.g., the attribute which is being updated).
 Dynamic Part. During the process, community members vote collaboration elements, thus allowing to reach agreements. Votes ( Vote metaclass) indicate whether the user ( votedBy reference) agrees or not with a collaboration ( agreement attribute). A vote against a collaboration usually includes a comment explaining the reason of the disagreement ( comment reference of Vote metaclass). This comment can then be voted itself and if it is accepted by the community, the proponent of the voted pro-posal/solution should take such comment into account (the included attribute of Comment metaclass records this fact).

The acceptance of a proposal means that the community agrees that the requested change is necessary ( accepted attribute). For each proposal we can have several solutions but in the end one of them will be selected ( selected reference of the Proposal metaclass) and its changes applied to the DSML definition. Part of this data (like the accepted and selected properties) is automatically filled by the decision engine analyzing and resolving the collaboration. 3.3 Decision Engine As explained in Section 2, community votes are used to decide which collaborations are accepted and must be incorporated into the language. Collaboration models include all the necessary collaboration information, thus allowing the automation of the deci-sion process (i.e., approval of change proposals and selection of solutions). A decision engine can therefore apply resolution strategies (e.g., unanimous agreement, majority agreement, etc) to deduce (and apply) the c ollaborations accepted by the community. As commented before, most times it is necessary to have the role of the community manager to trigger the decision process and solve possible decision locks.
The application of resolution strategies could be implemented as in-place model-to-model transformations for collaboration mode ls for instance using graph transformation rules enforcing the agreed decision policies and updating the involved models (i.e., collaboration model, DSML metamode l and notation model) accordingly. 3.4 Example To illustrate the proposed infrastructure, we show in Figure 6 the collaboration model which would be obtained as a result of the example discussed in Section 2. The figure is divided in several sections according to t he collaboration steps enumerated previ-ously. For the sake of clarity, the references to User metaclass instances have been represented as string-based attributes and the rationale attribute is not shown.
Section 1 of Figure 6 shows the collaboration model just after End-User 1 makes the request. It includes a new Proposal instance whose id attribute is p1 . The pro-posal meta-information specifies that such proposal is High priority and has the tag extension . Once the proposal has been created, the community can vote for/against it as well as add comments and solutions. In this case, the proposal is voted positively by the rest of the users and therefore accepted (see the Vote instances referred by the proposal in the section 2 of Figure 6). Then, a new solution is proposed by Developer 1 (see the Solution instance in section 3 of Figure 6), which involves enriching the Stop metaclass with a boolean-based attribute i n addition to define the concrete syntax.
However, this solution is not accepted by a ll the community me mbers: when voting such solution, End-User 1 does not agree and explains his disagreement with the cor-responding comment (see section 4 of Figure 6). Since the comment is accepted (see section 5 of Figure 6), Developer 1 decides to update the solution to incorporate the community recommendations (see section 6 of Figure 6). Note that the elements de-scribing the model changes in sections 3 and 6 are mutually exclusive (i.e., section 6 is an evolution of section 3 once the comm unity agrees that the comment from End-User 1 must be taken into account). Moreover, the attribute included of the Comment el-ement in section 4 of Figure 6 will be activated as a consequence of the solution update.
Once everybody agrees on the improved solution, it is selected as the final solution for the proposal (the selected reference is initialized with the Solution instance). Now the development team can modify the DSML tooling knowing that the commu-nity needs the language to be changed and agrees on how the change must be done. Moreover, the rationale of the change will be tracked by the collaboration model (from which an explanation in natural language could be generated, if needed), which will allow community members to know why the Stop metaclass was changed. We have developed an Eclipse plugin 4 implementing the Collaboro process and DSML. Current version works with the EMF framework (the standard de facto modeling frame-work nowadays) and includes a decision engine implementing a total agreement strat-egy to infer community agreements from the voting information as well as a notation generator to enable the lightweight creation of SVG images from notation models to help users  X  X ee X  how the notation they are discussing will look like when used to de-fine models with that DSL. To support concurrent collaboration the tool uses the CDO 5 model repository.

The plugin provides a set of new Eclipse views and editors to facilitate the collabo-ration, which can be considered a kind of concrete syntax of Collaboro itself for non-expert users. Figure 7a includes a snapshot of the environment showing the last step of the collaboration described in Section 3.4. In particular, the Version view lists the col-laboration elements (i.e., proposals, solutions and comments) of the current version of the collaboration model. The Collaboration View shows the detailed information of the selected collaboration element in the Version view and a tree-based editor to indicate the changes to discuss for that element, as shown in Figure 7a. Finally, the Notation view uses the notation generator to render a full example model of the language. For in-stance, the Notation view in Figure 7b shows the notation for an example model, which allowed detecting the missing attribute regarding handicapped support. We have used Collaboro in the development of a new DSML for MoDisco 6 , an Eclipse project aimed at defining a group of tools for Model-Driven Reverse Engineering (MDRE) processes. The goal of this new DSML is facilitating the development of MDRE workflows that chain several atomic reverse engineering tasks to extract the model/s of a running system. At the moment, the only way to define a MDRE work-flow is by using an interactive wizard. MoDisco users have been asking for a specific language to do the same in a more direct way, i.e., without having to go through the wizard.

Some years ago an initial attempt to create such language was finally abandoned but, to simplify the case study, we reused the metamodel that was proposed at the time to kickstart the process. The initial version of the workflow metamodel is shown in Figure 8 (elements in black). A workflow element ( Element metaclass) is identified by its name ( name attribute) and has a type ( type attribute) and an index ( index attribute) specifying the order in which such element will be executed. There are two types of elements: workflows ( Workflow metaclass), which represents a workflow itself; and works ( Work metaclass), which represents individual tasks to execute. The Workflow metaclass inherits from the ExportInfos metaclass, that can be used to indicate additional metadata. Each work parameter ( WorkParameter metaclass) includes a name ( name attribute), a type ( type attribute), a direction ( direction attribute), whether they are mandatory ( required attribute) and a description ( description attribute). Parameters can have a value assigned ( WorkParameterValue hierarchy).
Five researchers of the team followed our collaborative process to complete/improve the abstract syntax of the DSML and create from scratch a concrete syntax for it. Two of the members were part of the MoDisco development team so they took the role of developers in the process while the other three were only users of MoDisco so they adopted more the role of end-user in the process. One of the members was in a different country during the collaboration so only asynchronous communication was possible.
