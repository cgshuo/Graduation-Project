 This paper will introduce k-best suffix arrays , which are similar to standard suffix arrays (Manber and Myers, 1990), an index that makes it conven-ient to compute the frequency and location of a substring, s, in a long sequence, corpus . A suffix array, suf , is an array of all N suffixes, sorted al-phabetically. A suffix, suf [ i ], also known as a semi-infinite string, is a string that starts at po sition j in the corpus and continues to the end of the cor-pus. In practical implementations, a suffix is a 4 -byte integer, j . In this way, an int (constant space) denotes a long string ( N bytes). 
The make_standard_suf program below creates a standard suffix array. The program starts with a corpus , a global variable containing a long string of N characters. The program allocates the suffix array suf and initializes it to a vector of N ints (suf-fixes) ranging from 0 to N  X 1. The suffix array is sorted by lexicographic order and returned. This program is simple to describe (but inefficient , at least in theory) because strcmp can take O( N ) time in the worst case (where the corpus contains two copies of an arbitrarily long string). See http://cm.bell-labs.com/cm/cs/who/doug/ssort.c for an implementation of the O( N log N ) Manber and Myers algorithm. However, in practice, when the corpus is a dictionary of relatively short entries (such as web queries), the worst case is unlikely t o come up. In which case, the simple make_suf pro-gram above is good enough, and maybe even better than the O( N log N ) solution. 1.1 Standard Suffix Array Lookup To compute the frequency and locations of a sub-string s , use a pair of binary searches to find i and j , the locations of the first and last suffix in the suf-fix array that start with s . Each suffix between i and j point to a location of s in the corpus. The frequency is simply: j  X  i + 1. 
Here is some simple code. We show how to find the first suffix. The last suffix is left as an exercise. As above, we ignore the unlikely worst case (two copies of a long string). See references mentioned above for worst case solutions. K-best suffix arrays are like standard suffix array s, except there are two orders instead of one. In add i-tion to lexicographic order, we assume a figure of merit, which we will refer to as popularity. For example, the popularity of a string could be its fr e-quency in a search log. The code below assumes that the corpus is a sequence of strings that comes pre-sorted by popularity, and then the popularities have been stripped off. These assumptions make it very easy to compare two strings by popularity. All popcomp has to do is to compare the two posi-
The make_kbest_suf program below is similar to the make_standard_suf program above except we now sort by the two orders at alternating depths in the tree. First we sort lexicographically and then we sort by popularity and so on, using a construc-tion similar to KD-Trees (Bentley, 1975). The code below is simple to describe (though there are more efficient implementations that avoid unnec-essary qsorts). 2.1 K-Best Suffix Array Lookup To find the k-best matches for a particular sub-string s , we do what we would normally do for standard suffix arrays on lexicographic splits. However, on popularity splits, we search the more popular half first and then we search the less popu -lar half, if necessary. 
An implementation of kbest-lookup is given be-low. D denotes the depth of the search thus far. Kbest-lookup is initially called with D of 0. Pro-pose maintains a heap of the k-best matches found thus far. Done returns true if its argument is less 2.2 A Short Example: To be or not to be Suppose we were given the text,  X  X o be or not to be. X  We could then generate the following dic-tionary with frequencies (popularities). The dictionary is sorted by popularity. We treat the second column as an N =13 byte corpus (with underscores at record boundaries): to_be_or_not_ suf corpus + suf[i] suf corpus + suf[i] table above. For illustrative convenience, we show split is a lexicographic split at 9 ( X  X ot_ X ). On b oth sides of that split we have a popularity split at 5 ( X  X or_not_ X ) and 7 ( X  X _not_ X ). (Recall that relativ e popularity depends on corpus position.) Following there are 4 lexicographic splits, and so on. 
If k-best lookup were given the query string s =  X  X , X  then it would find 1 (o_be_or_not_), 6 (or_not_) and 10 (ot_) as the best choices (in that order). The first split is a lexicographic split. All the matches are below 9 (not_). The next split is on popularity. The matches above this split (1&amp;6) are as popular as the matches below this split (10) . 
It is often desirable to output matching records (rather than suffixes). Records are output in popu -larity order. The actual popularity can be output, using the side table mentioned in footnote 1: 2.3 Time and Space Complexity The space requirements are the same for both stan-dard and k-best suffix arrays. Both indexes are permutations of the same suffixes. 
The time requirements are quite different. Stan-dard suffix arrays were designed to find all matches, not the k-best. Standard suffix arrays ca n find all matches in O( log N ) time. However, if we attempt to use standard suffix arrays to find the k -best, something they were not designed to do, then it could take a long time to sort through the worst case (an embarrassment of riches with lots of matches). When the query matches every string in the dictionary, standard suffix arrays do not help us find the best matches. K-best suffix arrays were designed to handle an embarrassment of riches, which is quite common, especially when the sub-string s is short. Each popularity split cuts the search space in half when there are lots of lexico-graphic matches. 
The best case for k-best suffix arrays is when the popularity splits always work in our favor and we never have to search the less popular half. The worst case is when the popularity splits always fai l, such as when the query string s is not in the corpus. In this case, we must always check both the popu-lar half and the unpopular half at each split, sinc e the failure to find a lexicographic match in the fi rst tells us nothing about the existence of matches in the second. Asymptotically, k-best lookup takes between log N and sqrt N time. To see this complexity result, let P(N) be the work to process N items starting with a popularity splits and let L(N) be the work t o process N items starting with a lexicographic splits. 
Thus, P ( N ) =  X  L ( N /2) + C 1
L ( N ) = P ( N/ 2) + C 2 where  X  = 2 X  p , when p is the probability that the popular half contains sufficient matches.  X  lies between 1 (best case) and 2 (worst case). C 1 and C 2 are constants. Thus, where C = C 1 +  X  C 2 . Using the master method (Cormen et al , 2001), P ( N ) = O( log 2 N ) in the best case (  X  =1) . In the worst case (  X  =2), P ( N ) = O ( sqrt N ). In general, for  X  &gt; 1, P ( N ) = O( N (log2  X  )/2 ). 
In practical applications, we expect popularity splits to work more often than not, and therefore we expect the typical case to be closer to the best case than the worst case. 
The plot below shows the k-best lookup time as a function of square root of corpus size. We ex-tracted sub-corpora from a 150 MB collection of 8M queries, sorted by popularity, according to the logs from Microsoft www.live.com . All experi-ments were performed on a Pentium 4, 3.2GHz dual processor machine with enough memory to avoid paging. 
The line of diamonds shows the worst case, where we the query string is not in the index. Not e that the diamonds fit the regression line quite wel l, confirming the theory in the previous section: The worst case lookup is O ( sqrt N ). 
To simulate a more typical scenario, we con-structed random samples of queries by popularity, represented by squares in the figure. Note that th e squares are well below the line, demonstrating that these queries are considerably easier than the wors t case. 
K-best suffix arrays have been used in auto-complete applications (Church and Thiesson, 2005). The triangles with the fastest lookup times demonstrate the effectiveness of the index for this application. We started with the random sample above, but replaced each query q in the sample with a substring of q (of random size). A new data structure, k-best suffix arrays , was pro-posed. K-best suffix arrays are sorted by two or-ders, lexicographic and popularity, which make it convenient to find the most popular matches, espe-cially when there are lots of matches. In many ap-plications, such as the web, there are often embarrassments of riches (lots of matches). 
Lookup time varies from log N to sqrt N , de-pending on the effectiveness of the popularity splits. In the best case (e.g., very short query strings that match nearly everything), the popular-ity splits work nearly every time and we rarely have to search the less popular side of a popularit y the other hand, in the worst case (e.g., query strings that match nothing), the popularity splits never work, and we always have to search both sides of a popularity split. In this case, lookup time is sqrt N . In many cases, popularity splits work more often than not, and therefore, perform-ance is closer to log N than sqrt N . 
