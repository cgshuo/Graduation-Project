 Incremental method engineering [18,24] is a paradigm that proposes to change infor-mation systems development methods through a continuous improvement process. This strategy adheres to the common understanding that spreading changes over a time pe-riod is less risky and more efficient than introducing them all at once.

Empirical studies have provided significant evidence in favor of incremental method engineering [24,16,7], including cases on the introduction of Scrum [21], showing that it helps to cope with the major obstacles to change, including resistance to change, fear of ineffectiveness by the involved personnel, and resource constraints [2].
However, existing research has largely ignored the relevant problem of identifying a plan that specifies when to implement the changes. This requires defining which are the most (and least) urgent changes, how many changes can be implemented given time and budget constraints, and when a plan is better than another. See the following example. Example 1. A software organization wants to improve customer satisfaction by intro-ducing the Kano analysis [13]. However, introducing and learning the Kano analysis requires a significant effort, due to its comp lexity (Fig. 4). Th e management team is concerned with upfront costs and risks of resistance to change. A product manager sug-gests introducing it incrementally, but sh e cannot devise a proper plan. How can Kano analysis be embedded within the current process? Are there any variations possible? In this paper, we address the problem of devising a plan for the incremental imple-mentation of a set of method changes in an org anization (as elaborated in Sec. 2). We use automated reasoning techniques for generating optimal and quasi-optimal plans. We propose a formalization of the Process-Deliverable Diagram (PDD) modeling lan-guage [23], that we use to describe the changes to be implemented.

We combine these elements in to a method that, based on a description of the changes to be enacted, assists the analysts by suggesting possible plans, and helps to refine these plans to improve fitness with the organizational context. These plans have to satisfy mandatory constraints, and should satisfice [19] weak (nice-to-have) constraints.
While we are inspired by automated planning techniques, we develop a novel so-lution that copes with the specificities of method engineering. This includes defining sequencing based on deliverables rather than activities, and using weak constraints to derive a plan leading to an incremental maturity growth in the organization.
After stating our problem in Sec. 2, and discussing our research baseline in Sec. 3, we propose the following contributions:  X  We formalize the PDD modeling language, adding clear semantics, so as to make  X  We define a formal framework that defines optimal and quasi-optimal plans with  X  We propose a process that guides the analysts in applying the framework to generate  X  We develop tool support for our method: PDD models can be created via a graphical
Sec. 7 illustrates our approach using the scenario in Example 1. Sec. 8 discusses related work, presents conclusions, and outlines future directions. Our research context is method evolution, i.e, the process through which an organi-zation X  X  methods change over time. We focus on incremental method engineering, a well-defined process for managing and inc rementally introducing method changes.
This approach is illustrated in Fig. 1. Whenever the process is triggered (either by an occurred event, or every N months/years), the maturity of the current processes is assessed. If any process shows low maturity, the stakeholders X  needs are considered to identify what to change, and, subsequently, by defining a plan that specifies how and when to deploy these changes in the organization. Finally, the changes are enacted as per the plan. This process is highly iterative, for organizations are in constant evolution.
In this paper, we focus on the important yet under-explored activity of change plan-ning . The problem is that of determining a (quasi-)optimal scheduling for implementing the changes, based on all the constraints (hard and soft ones) of the stakeholders. To ad-dress this non-trivial problem, several sub-questions have to be answered:  X  Which factors determine the optimality of a plan?  X  Which elements describe the hard constraints that cannot be violated?  X  Which factors determine the priority of changes?  X  How can one ensure that, even when partia lly deployed, the introduced changes can
In this paper, we consider the gradual introduction of new methods. In reality, it is more common to deal with changes to existing methods, which also requires to consider the removal and replacemen t of fragments. We leave d ealing with the more complex case of decrements (as opposed to increments) for future research. We approach the challenges in Sec. 2 as part of the Online Method Engine (OME) [22], a knowledge management system for incre mental method engineering. The OME con-sists of a method base that contains method fragments (generic descriptions of common approaches to software development tasks), rules for combining fragments, and organi-zational experience related to the fragments. These elements feed the four main func-tions of the OME: (a) disseminating method knowledge; (b) assessing the maturity of an organization X  X  processes; (c) suggesting improvements based on method fragments and experience from similar organizations; and (d) enacting improvement proposals.
Process-deliverable Diagrams (PDDs) are a fundamental component of the method base: method fragments are modeled using a combination of UML activity diagrams X  to describe the procedural aspects X  X nd UML class diagrams X  X o express the data aspects (using classes called  X  X eliverables X ). These models are connected through a  X  X esults in X  relationships from the activitie s to the deliverables. PDDs also distinguish between simple, closed, and open activities and deliverables [23]. Fig. 2 illustrates the core components of a PDD through an example. More details can be found in [23].
We also adopt the notion of focus area maturity matrix from the Situational As-sessment Method (SAM) [4] (see Tab. 1). This matrix is filled in based on questions concerning situational factors as well as organizational capabilities. Each of these ca-pabilities (with level A-F) contributes to the maturity of the organization in a specific focus/process area. For example, capability A in the focus area (row)  X  X equirements gathering X  corresponds to a basic registration of the requirements, which contributes to maturity level 1, while capability F in the same area corresponds to the involvement of partners in the product management process, which contributes to maturity level 8.
By using a focus area maturity matrix instead of a fixed level maturity matrix, we are able to suggest more detailed improvement suggestions [4]. SAM enables assessing the maturity level of an organization and identifying the desired (target) maturity level. Focus Area Maturity Levels Title Code 0 1 2 3 4 5 6 7 8 9 10 Requirements Management Requirements Gathering RG A B C D E F Requirements Identification RI A B C D
Requirements Organizing RO A B C We formalize the relevant parts of the PDD language [23] so as to make it usable for automated reasoning. We state the requirements for our refinement in Sec. 4.1, and we present a revised metamodel and its semantics in Sec. 4.2. 4.1 Requirements We want to leverage previous work: PDDs are a simple yet expressive means to model a method fragment X  X  activities, deliverables, and their relationships. This choice is made to reuse the method base of fragments (modeled as PDDs) within the OME system.
PDDs were designed as a means to intuitively communicate methods and fragments to users. The price of this choice is that some constructs have ambiguous semantics that cannot be readily used for automated reasoning. Thus, we need to provide a clear se-mantics of the PDD metamodel, by fulfilling the three requirements ( R 1 to R 3 )below.
R 1 : Avoid Generic Associations. Consider a directed association between two de-liverables:  X  X ustomer wish X  and  X  X heme X . The original PDD metamodel does not spec-ify a detailed semantics for associations, which inhibits determining the nature and the strength of the link. Thus, we require our language to avoid generic associations.
R 2 : Include Input and Output Relationships. PDDs do not express input relation-ships, i.e., that an activity needs to use a deliverable. This choice eases readability, but does not express when a deliverable is needed. This obstacles planning for change: an activity that requires a deliverable cannot be introduced until that deliverable is pro-duced. Our language needs to unambiguously express input and output relationships.
R 3 : Distinguish Deliverable Dependency Types. Consider the following depen-dency between deliverables: the priority of a requirement is based on the input from customers and partners, but one of them suffices. This can be represented as an asso-ciation between a requirement and an aggregated input deliverable in PDDs, but the semantics are not sufficiently detailed to indicate the choice. We thus require our lan-guage to support more specialized deliverable relationships. 4.2 PDD Metamodel In Fig. 3, we present a refinement of the part of the PDD metamodel [23] that relates with describing method change. The seman tics of the language should enable describ-ing what changes have to be introduced, and expressing the dependencies between de-liverables that pose constraints on when the different activities are introduced.
Since we are interested in the implementation order of a set of activities, rather than in their execution order, our metamodel does not restrict the process side of the PDD: ControlFlowElement in Fig. 3 is a generic placeholder for all the control flow constructs of PDDs (sequence, decision point, fork and merge, etc.).

ContributesTo: this relationship indicates that an Activity contributes to a certain Ca-pability , thus helping the organization to reach that capability X  X  maturity level. An ac-tivity can contribute any number of capabilities, and a capability can be contributed by any number of activities. Graphically, contri butions are textual annotations  X  X ocusArea-Code:Capability X  on the left of activities. In Fig. 1, e.g., activity  X  X nalyze Product En-vironment X  contributes to capability D of focus area  X  X equirements Gathering X .
We implement several changes to fulfill R 1  X  R 3 . We remove the distinction between simple, complex, and closed deliverables, as these concepts are not useful for our pur-poses. Also, we replace generic associations ( R 1 ) with the following relationships.
Requires : a transitive and asymmetric binary relationship between deliverables D 1 and D 2 , indicating that the D 1 can be produced only when D 2 already exists. In Fig. 4, deliverable  X  X unctional Questi ons X  requires  X  X equirements X .
Produces / Updates : in a PDD, activities can be linked to deliverables only through the  X  X esults in X  relationship between activity A and deliverable D . Here, we specialize this relationship into Produces , to denote that A creates a previously non-existent deliv-erable, and Updates , to indicate the modification of a previously available deliverable. In Fig. 4, activity  X  X ist Results of Individual Criteria X  produces deliverable X  X able of Results X , while activity  X  X valuate Answer Frequencies X  updates it.

Together, the Requires , Produces ,and Updates relationships satisfy R 2 : Requires ( D 1 , D 2 ) denotes that any activity that produces or updates D 1 needs D 2 as an input; Produces ( A , D ) indicates that A has output D ;and Updates ( A , D ) specifies that D is both an input and output for A .

HasOne / HasAll : to allow for fine-grained deliverable dependencies ( R 3 ), we spe-cialize aggregation into the HasOne and HasAll relationships. The former indicates that at least one of the parts of a deliverable shall be available in order to produce the deliver-able itself, while the latter requires that all of its parts are available. In Fig. 4,  X  X equire-ments X  requires both ( HasAll )  X  X ustomer Requirements X  and  X  X roduct Requirements X ; on the contrary,  X  X uestionnaires X  requires at least one among  X  X unctional Questions X ,  X  X ysfunctional Questions X ,  X  X mporta nce Scales X , and  X  X atisfactory Scales X . We present the formal framework that derives plans for implementing a set of changes described in a PDD (Sec. 5.1). We introduce a process for determining the most ade-quate plan (Sec. 5.2), and illustrate our approach on the Kano analysis scenario (Sec. 7). 5.1 Formal Framework We introduce the necessary elements to define the plan generation function genplans , which returns all plans for implementing a set of changes, given a set of constraints. We represent time instants via natural numbers: typically, 0 would denote the current time (CT), 1 would denote CT + X milliseconds, 2 would denote CT + 2  X  X milliseconds, etc. Definition 1. Implementation cost is defined by a function cst : ACT  X  ORG  X  R + s.t. cst ( A , Org ) is the cost of implementing activity A in the organization Org . The notion of cost here goes beyond monetary expenses, and it includes additional costs for the organization, including the learning effort, risk of failure, impact on motivation, time, etc. We measure cost in terms of abstract cost units; the definition of a mapping that reduces real cost to units is beyond the purpose of this paper.
 Definition 2. A scheduling schema is a list of time slots ( St 1 , End 1 , Bdg 1 ,..., St n , End n , Bdg n ) wherein changes can be implemented. The i-th time slot St i : N 0 , End i : N , Bdg i : R + starts at time St i , ends at time End i , and has budget Bdg i . For all i ,it is required that St i  X  End i and End i &lt; St i +1 .
 A scheduling schema defines the time slots within which changes are to be imple-mented. Each slot has a budget, i.e., an uppe r bound on the implementation cost in that slot X  X  time frame. The specification of a sche duling schema depends on the character-istics and strategy of the organization, and on the changes to implement. For example, an organization may define a linear schema where all slots have the same duration and budget, while another may start with low effort, and increase it in later slots. Definition 3. Given a PDD model Mdl and a scheduling schema ( St 1 , End 1 , Bdg 1 , ..., St n , End n , Bdg n ) ,asetof scheduling constraints Cstr defines temporal restric-tions on the allocation of the activities and the production of the deliverables of Mdl with respect to a time T : N 0 :  X  actBefore ( A , T ) : activity A shall be scheduled in a slot i ,s.t. End i &lt; T ;  X  delBefore ( D , T ) : deliverable D shall be produced in a slot i ,s.t. End i &lt; T ;  X  actAfter ( A , T ) : like actBefore ,but St i &gt; T ;  X  delAfter ( D , T ) : like delBefore ,but St i &gt; T ;  X  actAt ( A , T ) : activity A shall be scheduled in a slot i ,s.t. St i  X  T  X  End i ;  X  delAt ( D , T ) : deliverable D shall be produced in a slot i ,s.t. St i  X  T  X  End i . Scheduling constraints enable imposing fine-grained temporal restrictions on the allo-cation of activities and on the production of deliverables. In Sec. 7, we will show how these constraints are a useful tool in our method to identify the most suitable plan. Definition 4. Given a PDD model Mdl and a scheduling schema Schema ,a plan is a set Pln = { A 1 , T 1 ,..., A n , T n } such that:  X  A 1 ,..., A n are all and only activities in Mdl , and  X  for each i , 1  X  i  X  n , there exists exactly one slot St j , End j , Bdg j in Schema A plan is an allocation of all and only the activities of a PDD model into a scheduling schema. The activities shall be allocated within exactly one slot.

We say that a plan is feasible if it respects budget constraints, i.e., if for each slot, the sum of the implementation costs of the act ivities in that slot does not exceed the budget. We say that a plan is contiguous when all slots have at least one allocated activity. In this paper, we are concerned with the generation of feasible and contiguous plans.
The function genplans brings together the concepts defined above and generates the feasible and contiguous plans for implementing a set of changes described by a PDD model in an organization, according to a specified scheduling schema, additional temporal constraints, and considering a cost function for implementing the changes. Definition 5. Plan generation is a function that returns all feasible and contiguous plans for implementing a set of changes in an organization. Formally, genplans : PDD  X 
ORG  X  CSTF  X  SS  X  CSTR  X  X  2 PLN , and genplans ( Mdl , Org , cst , Schema , Cstr )= {
Pln 1 ,..., Pln n } is such that:  X  Mdl is a description of the changes to implement in PDD;  X  Org is the organization where the changes are implemented;  X  cst defines the cost of implementing the activities of Mdl in Org (Def. 1);  X  Schema is a scheduling schema (Def. 2);  X  Cstr is a set of constraints on scheduling (Def. 3);  X  for each i , 1  X  i  X  n , Pln i is a feasible and contiguous plan (Def. 4) for Mdl and While genplans deals with hard scheduling constraints that cannot be violated, it does not consider the optimality of a plan. In this paper, we conceive plan optimality in terms of incremental maturity improvement : the changes should be introduced in accordance with a growing maturity level of the organization. The activities that contribute to ca-pabilities with lower maturity levels shall be i ntroduced first, followed by the activities contributing to higher maturity levels, up to the highest maturity. Def. 6 introduces the notion of penalty for a plan, i.e., its distance from an optimal plan where activities are introduced with a monotonic increasing level of maturity.
 Definition 6. Plan penalty is a function that returns the distance between a given plan and an optimal plan that would i ntroduce all activities in increasing order of maturity. Let the predicate preceeds ( A , A , Pln ) indicate that activity A is scheduled before activ-ity A in Pln . The maturity of an activity mat ( A ) is the lowest maturity level among the capabilities that the activity contributes to. Formally, penalty : PLN  X  PDD  X  N 0 , When an activity contributes to multiple capabilities, we consider the capability having the lowest maturity level, for that activity is important for the organization to achieve that level. The penalty is the number of  X  X teps X  that have been skipped in the plan: for instance, consider only activities  X  X ather Requirements X  and  X  X nalyze Customer Problems X  in Fig. 4. The former activity has lowest maturity level 1 (it contributes to capability A in area requirements gathering), while the latter has lowest maturity level 6 (the contributed capability with lowest maturity is D in requirements gathering). If the former activity is introduced before the latter, the plan penalty would be 5.
We call a plan optimal when its penalty is zero, and quasi-optimal when its penalty is greater than zero but lower than  X  . This number  X  is domain-specific, and it depends on the number of activities in the plan, the organization, the cost of activities, etc.
In this paper, we limit ourselves to a special kind of scheduling schema, where for each slots i ( 1  X  i  X  n ), St i = End i , and the slots are such that St 1 =1 , ..., St n = n .
We do not consider constraints related to organizational resources (other than the abstract unit Cost) and human factors (such as worker resistance), as such factors are harder to attribute to single activities a nd deliverables. The method we propose is a support tool for analysts, and does not replace their role as decision makers. 5.2 A Method for Identifying and Refining Plans We present an elaboration of the Change planning step in Sec. 2 that uses genplans (Def. 5) for identifying plans and for refining them to fit well with the organization at hand. This method, illustrated in Fig. 5, helps to restrict or widen the space of alternative plans, depending on the plans that the function genplans returns.

The process begins with two preparatory steps that provide the inputs to the genplans function: the planning context is defined (th e changes to implement, the organization, and the cost function), and an initial version of the scheduling constraints is created (the scheduling schema and constrai nts, and the quasi-optimality upper bound  X  ). This input feeds the genplans function, which returns all optimal and quasi-optimal plans. The analyst then judges the adequacy of the returned plans:  X  Adequate : a plan is identified and change enactment starts (see also Fig. 1);  X  Uncertain : a final decision cannot be made at the moment, due to scarcity or excess  X  Inadequate : no satisfactory plan can be devised in the current planning context, We have developed a graphical modeling tool for PDD within MetaEdit+ [20]. This tool is built around the Graph, Object, Property, Relationships, Role (GOPRR) metamodel, which we used to describe the PDD metamode l; instances of the latter metamodel are PDDs. The editor enforces syntactical rules, thereby ensuring the well formedness of the model. In addition, we have developed a set of code generators that transform any PDD model into a set of Datalog statemen ts, which are needed to generate plans.
We have realized the mechanisms for identifying optimal and quasi-optimal plans via logic programming (specifically, via the disjunctive Datalog engine DLV [15]). The program consists of a set of inference rules (Tab. 2) that returns feasible and contiguous plans for a given input. The input consists of the Datalog statements that are generated from the PDD model, the temporal constraints, and the  X  quasi-optimality upper bound.
The following extensional predicates formalize in Datalog the primitives of our lan-guages (Sec. 4 and Sec. 5): activity(A) states that A is an activity; produces(A,D) and up-dates(A,D) denote the relationships between activities and deliverables; requires(D1,D2) indicates that namesake relation between deliverables in Sec. 4. The predicate atLea-stOnePart(D) ( allParts(D) ) says that D requires at least one (all) of its parts, each part being stated through hasPart(D,D1) ; cost(A,N) states that the deployment of activity A costs N (a natural number); slot(N1,N2) states that slot at time N1 has a budget of N2 cost units; actAt(A,N) , delAt(D,N) , actBefore(A,N) , delBefore(D,N) , actAfter(A,N) , de-lAfter(D,N) state constraints telling that activity A or deliverable D shall be scheduled at/before/after slot N; contributes(A,C) states that activity A contributes to capability C; depends(C1,C2) says that capability C1 shall be implemented strictly after capability C2; maturity(C,N) states that capability C has maturity level N.

Tab. 2 presents the inference rules (syntax head :-tail .) to generate plans. By default, the program returns all possible plans that satisfy the constraints. A plan is defined as a set of predicates chosen(A,N) , each stating that the deployment of activity A will be scheduled in slot N. Rules without a head (those starting with  X :- X ) are integrity constraints: the condition expressed in the tail shall not become true in any model.
Rules 1 X 3 ensure that all activities are assigned to exactly one slot. Rule 4 guaran-tees that all slots have at least one assigned activity. Rules 5 X 7 deal with actAt and delAt constraints: the activity (the deliverable) shall be scheduled (produced) in the specified slot. Rules 8 X 9 and rules 10 X 11 guarantee the fulfillment of the similar constraints in the before/after variant. Rule 12 ensures that the sum of the costs for implementing the activities in a slot does not exceed the slot budget. Rules 13 X 14 ensure that deliverables are produced before their use. Rule 15 states that an activity A uses a deliverable D1 if X produces D, and D requires D1. Rule 16 says that updating a deliverable implies using it. Rule 17 says that the requires relationship is transitive. Rules 18 X 20 take care of atLeastOnePart(D) ( allParts(D) ): at least one part of D (all parts) shall be available when D is produced. Rule 21 handles the depends(C1,C2) relationship between capa-bilities: all activities that contribute to C1 are scheduled strictly before any activity that contributes to C2. Rules 22 X 23 compute the penalty of the plan as in Def. 6.
The program can be run with different param eters to return only optimal and quasi-optimal plans. By adding the rule :  X  penalty(Cs). [Cs:1] , only the plans with mini-mum penalty are listed ( X :  X   X  is a weak constraint that DLV optimizes by returning the models that minimize it). In order to retu rn all quasi-optimal plans, the parameter  X -costbound=  X   X  can be specified when executing DLV. We apply our planning method to the scenario of Example 1 and Fig. 4. Kano analysis uses a two-dimensional quality model used for the analysis of customer requirements, which is useful to elicit customer needs about a service or product under design. It uses two types of questionnaires and an evaluation table for classifying the requirements into different categories [13]. We show how the company can use our method to identify an incremental plan to introduce the 15 activitie s and 13 deliverables of Kano analysis. Step 1: Define the Planning Context. We begin with the creation of a PDD model that describes the changes to introduce (Kano analysis, as in Fig. 4), the organiza-tional context (our example organization), and the cost function that returns the costs for each activity. In this example, we use a s imple cost scheme, where we use natu-ral numbers in the range [1,5] to describe the complexity of implementing and learn-ing each activity. For each activity, we add a fact as input to our datalog program: cost(analyze customer problems, 4). cost(analyze product environment, 2). ,etc. Step 2: Set Scheduling Constraints. This activity involves the specification of the number of slots for implementing the pl an, and the budget for each of them. Here, we define four slots, each with a budget of nine cost units (adopting the same unit as for activities cost). We do not define any temporal constraint, and we set  X  =25 . Step 3: Run Planning. When we run our planner with the settings above, we obtain 1,442 plans, with penalties between 8 and 22. Making a choice at this point would obviously be difficult; moreover, no optimal plan exists (no plan has penalty 0). Some constraints have to be introduced. Step 4: Strengthen Constraints. The company wants to have a running implementa-tion of Kano analysis in slot 0. This requires to have at least a table of results based on requirements from the customer and the product environment. More advanced tools, such as the QI-index plots and the CS-coefficient plots, can be introduced later. To such extent, the following temporal constraints are added: When we re-run the planner, we obtain no results. By forcing the planner to schedule the activity that produces the table of results at slot 0, the require relationships between the deliverables imply that several other activities have to be schedules in slot 0 as well. Their total cost exceeds the budget of slot 0 . This forces us to relax some constraints. Step 5: Relax Constraints. To cope with the required effort for implementing the table of results in slot 0, the organization can either combine the effort of multiple slots, thereby lengthening the implementation time, or allocate more resources to slot 0. We assume the analyst opts for the latter: the budget of slot 0 is raised to 20, but a slight reduction in the overall budget is required (-4 units); the remaining units are allocated in two slots with budget 6, and the last slot is removed.

When we re-run our planner, we obtain 5 plans. Tab. 3 shows them and outlines their differences via a gray background color. Two of them have a penalty of 12, the other three have a penalty of 8. The analyst is free to consider a restricted set of plans. The choice is between introducing both plots in slot 2, implementing QI index plots first and then CS coefficient plots, or vice versa.
 We have presented a method that assists analysts in the planning phase of method evolution, i.e., to identify plans for implementing a set of changes in an organization. Our method enables representing changes via PDD models, and is supported by our graphical modeling tool. The method includes the automated generation of plans that comply with scheduling constraints, and that maximize incremental growth in matu-rity, by trying to introduce changes accordin g to an increasing maturity level. We also propose a process that guides analysts in refining plans by strengthening and relaxing constraints.

This work is performed within the context of the Online Method Engine, and it touches upon several related fields. We discuss our approach in the light of these fields. Software Process Improvement. Research in the area of software process improve-ment has produced effective frameworks to determine what to change, including CMMI [6] and SPICE [8]. We complement these works by proposing a method for planning the implementation order of these changes.
 Situational Met hod Engineering. This discipline deals with describing, constructing and adapting software development methods for a specific situational context, thus pro-moting reuse of standardized approaches while maintaining flexibility [11,12,3]. In this research, we employ the method fragment concept [5] for compatibility with the OME system; however, other notations can be used, as long as they satisfy the requirements of Sec. 4.1. There has been some work related to the notion of method evolution [18,17]. Most approaches in method evolution cons ist of manual activities, although some ap-proaches support (semi-)automatic method construction [1].
 Automated Planning. The problem of identifying a plan to reach a given goal is well-known in Artificial Intelligence [10]. Recen t planners are able to deal with sophisti-cated planning constraints on s tate trajectory, preferences , soft constraints, and plan quality [9]. Our approach differentiates from existing solutions in that it employs a capability-driven planning policy that takes in to account deliverable-based constraints, as opposed the activity-based constraints that are typical of AI planning. We do not preclude that an extended version of our framework could employ PDDL.
 Project Management. The implementation of a set of changes in the methods of an organization is usually executed in the form of a project. Project management is a very mature field, which offers effective mechan isms and tools to deal with change by plan-ning, scheduling, and controlling it [14]. Our approach is inspired by this field, but focuses on a very specific type of scheduling that relates to method change.
We have focused only on introducing new fragments; the next step is to consider the removal and replacement o f fragments. We will also explore the preceding step of method construction . Furthermore, we plan to convert our prototype into a comprehen-sive tool that supports the analysts in the plan refinement process by recommending possible refinements. We will evaluate the efficacy of our approach with case studies in the industry, and based on the feedback from p ractitioners, we will extend the supported constraints. Finally, we aim to assess the scalability of our reasoning techniques.
