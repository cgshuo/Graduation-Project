 The optimal sequenced rout e (OSR) query method has been proposed in recent years. It has been used for several trip planning applications, such as location-based services (LBS) and car navigation systems. The OSR finds the minimum-length route, starting from an origin location and passing through a number of locations or points of interest (POIs), following a prespecified route sequence.
Fig. 1 shows an example of an OSR query. You are currently at the  X  X urrent position, X  and the final destination of your trip is home, which is labeled  X  X es-tination. X  During the trip, you want to stop at a bank to withdraw money, and next at a Chinese restaurant to have dinner, and then at a movie theater, and finally return home. Although there may be many banks, restaurants, and movie theaters in the area, the OSR query chooses one from each category according to the specified sequence in order to minimize the total cost of the trip. The cost can be measured by several cr iteria, including distance, total trip time, safety, and the ease of the drive. However, in thi s paper we measure the cost according to the total trip distance.

The thick line in Fig. 1 shows the result of the OSR query, which provides the shortest distance route. In some app lications, multiple result routes may be presented, so that the user can select th e route he prefers. This case is called the  X  X equested k shortest OSR ( k -OSR) X .

The OSR query was first proposed by Sharifzadeh et al.[10]. They proposed several algorithms to find the k -OSR in both vector (based on the Euclidean distance) and metric (based on the road-n etwork distance) spaces. Among them, the progressive neighbor expansion (PNE) is the only algorithm that can be applied to road networks.

On a road network, the nearest neighbor (NN) object calculated by the Eu-clidean distance is not always the NN calculated on a road network [9]. The com-putation cost can drastically differ betw een these two distance measurements. The Euclidean distance between two point s can be easily calculated; however, for the distance on a road network, we need to find the shortest path that connects two points. To find the shortest path, Dijkstra X  X  algorithm [2] and the A* algo-rithm [5] are usually used. However, these algorithms consume a large amount of CPU power compared to the Euclidean d istance-based search. In addition, a Euclidean distance-based algorithm can use the simple spatial index structures, such as, R-tree [4], to narrow the search space. In fact, the R-LORD algorithm proposed by Sharifzadeh et al. [10] employed R-tree for this purpose. Moreover, a spatial index based on the Euclidean distance is not effective for road network distance-based queries[9].

In this paper, we propose efficient algorithms for an OSR query on road net-works. In an usual trip planning, a final destination is normally provided. For example, a home or an office can be a final destination of a trip. In this regard, in our trip planning method, the starting (usually the current position) and the destination positions of the trip are provided explicitly. When the destination is specified explicitly, we can adopt an efficient A* algorithm and the bidirectional search [6] for an OSR query.

The contributions of this paper are the following:  X  To propose a visited POI graph (VPG), in order to reduce the number of  X  To present an efficient unidirectional search algorithm for a k -OSR query  X  To prove that the proposed method performs 100 times faster than the PNE The OSR query was first proposed by Sharifzadeh et al.[10]. They proposed sev-eral algorithms for an OSR query to operate on the Euclidean distance. Among them, the light optimal route discoverer (LORD) first finds a greedy route which is composed by the successive nearest nei ghbor search. The greedy route is found by performing a consecutive NN search from the starting point to the last vis-iting category. The search area is restricted by the length of this greedy route. Then, the LORD finds the optimal route in the reverse order (from the last category to the starting point), by narrowing the search area. The authors also proposed a more efficient algorithm called the R-LORD (R-tree-based LORD). However, these algorithms cannot be adapted directly to the road-network dis-tance. Hence, for road network distance query, they proposed another algorithm named progressive neighbor exploration (PNE).

During almost the same time, Li et al. proposed the trip planning query (TPQ) [7].The TPQ is similar to an OSR query; however, the visiting order of the POI is not specified in the TPQ. Because of this free visiting order, the complexity of the TPQ is NP-hard, as in the traveling salesman problem. Therefore, Li et al. proposed several types of approximation algorithms. However, these algorithms cannot be directly applied to road networks, because of the heavy burden of the NN search. For TPQ on a road network, Li et al. proposed the minimum distance query (MDQ) algorithm. Basically, the MDQ expands nodes on the road network successively, finding the NN POI in the same way as by Dijkstra X  X  algorithm. This causes duplicated node expansion, and the calculation time increases, especially when multiple trip-plan routes ( k -TPQ) are requested.

Chen et al. [1] proposed another type of route query called the multi-rule partial sequenced route (MRPSR) quer y. This query generalizes both the OSR and the TPQ. For example, suppose we want to visit a bank, a restaurant, and a movie theater in that visiting order. A user may want to visit a bank before visiting both the restaurant and the movie theater because he needs to withdraw some money. However, the order of visiting to the movie theater and the restaurant can be exchanged. In this case, the visiting order is specified as a semi-ordered set, which can be represen ted as a directed gra ph. They called this graph an activity on vertex (AOV) network. When we plan a trip, the starting position is obvious. In general, the current position acquired by GPS can be taken as the starting position, or the user specifies the starting position explicitly. In most situations, the final destination is also decided. Then, a trip planning query can be invoked with the starting ( S ) and the final destination ( E ) positions. In this case, we can adopt an A* algorithm for the efficient search of the TP Q. We can also use bidirectional search [8] for this purpose. Our algorithm proposed in this section uses both these methodologies, because they can reduce the calculation cost, which is mainly due to the considerable node expansion on the road network. We first describe an OSR query using the single-source A* algorithm (unidirectional search). We then develop it into a bidirectional search. 3.1 OSR Query by A* Algorithm Let U i be a category of the POI to be visited, and M be a sequence of U i to specify the visiting order. That is, M = { U 1 ,U 2 ,...,U m } , and here m is the length of M ( m = | M | ). Our OSR query finds k optimal sequenced routes from the starting point S to the destination E , visiting each POI belonging to U (1  X  i  X  m ) one after another, according to the given sequence M . The partial sequenced route (PSR) is the shortest route from the starting point S to one of the POIs in U i , by passing through the POIs one after another choosing from U j (1  X  j&lt;i ) on the way according to the given sequence. SR is the total routes from S to E , visiting the POIs according to the given sequence M . To simplify the algorithm explanation, we assume that the POI is on a road-network node. However, this restriction can be easily resolved [9].
 The A* algorithm has been applied to find the shortest route given S and E [5]. Here, we apply it to the k -OSR query. The A* algorithm evaluates the favorable node n to be expanded next by the cost C = d ( S, n )+ h ( n, E ). Here, d ( x, y )isthe distance from node x to y moving on the road network, and h ( y,z ) is a heuristic function between y and z . Because we evaluate the cost of the OSR by the route length, we use the Euclidean distance between y and z as the value of h ( y,z ).
Fig. 2 shows an example of a search using the A* algorithm. In this example, the search starts from S , and then finds P 1 1 belonging to U 1 .FromthisPOI,a new search targeted at the U 2  X  X  POI starts. In parallel, the search starts from S , finds P 1 2 belonging to U 1 , and then another new search starts from the POI.
As mentioned above, the A* algorithm decides the next-expanded node on the road network ( n a ) by an extracted record from th e priority queue (PQ), which gives the minimum cost d ( S, n a )+ h ( n a ,E ). For each road segment connected to n a , the cost is calculated to compose a new record, as shown in Eq. (1), and it is then inserted back into the PQ: Here, n b shows the opposite-side node to n a of the road segment. In the record, C is the abovementioned cost, U i is the next POI category to be visited, and L is the distance on the road network from S to n b (i.e., L = d ( S, n b )). P prev is the last-visited POI that belongs to U i . n a is necessary in the record to restore the PSR by backtracking from n b to S . For the backtracking, Eq.(1) is recorded in a hash table indexed by n b , after it is removed from the PQ. The term org is the origin of the PSR, i.e., S or E .Thistermisnot always necessary for a unidirectional search where the origin of the search is predetermined; that is, a unidirectional search can start from either S or E . Both S and E can be the origins of a bidirectional search. Hence, both search origins are required for the bidirectional search.

Repeating the node extraction from the PQ and the node expansion, the search area is gradually enlarged. The search is terminated when the item n b of the record extracted from the PQ is E . This terminating condition is the same for the typical A* algorithm.
 Every time a POI P i belonging to U i is found, we start a new search targeting U i +1 , and simultaneously, we need to continue the search for another POI that belongs to the same U i , ignoring P i . Fig. 3 explains this necessity. This figure shows a situation where the POIs that belong to several categories of POI are arranged in a line. The search starting from S first finds P a in U 1 . Then, the next search targeting a POI in U 2 starts, and the search finds P b . Next, a search targeting U 3 starts from P b , and then finds P f . Finally, the search reaches E and is then terminated. By this search, the sequence S  X  P a  X  P b  X  P f  X  E has been found. However, there are other OSRs that have the same length. For example, the other sequences S  X  P a  X  P c  X  P f  X  E ,and S  X  P d  X  P e  X  P continue to search the same category, then the search can subsequently find S , and thus the sequence S  X  P d  X  P e  X  P f  X  E can be found.
In a typical shortest-path search, Dijkstra X  X  algorithm and the A* algorithm use a close set (CS) to avoid multiple node expansions. Once a node is expanded, it is registered to the CS, and the node will not be expanded again. On the other hand, an OSR query requires multiple CSes. Each CS records an expanded node from an individual source of searching (e.g., S or P i j ).This characteristic of an OSR query causes multiple node expansions; that is, a node on a road network is expanded several times. For example, the search paths targeting U 1 started from S to find the POIs P 1 1 and P 1 2 , belonging to U 1 , then new searches targeting U 2 start from both of them. These two searches are executed independently. Therefore, a node that has been expande d by another search can be expanded again, which causes a rapid increase in processing time. This also happens with the PNE when it adopts an incremental k -NN on a road network. We will deal with this problem using the bidirectional search in Section 4. 3.2 Bidirectional Search The unidirectional searc h described above can be extended to a bidirectional search in a straightforward manner. A bidirectional search starts from S and E simultaneously under the control of one PQ. The record of Eq. (1) is put into the same PQ, which is independent of the origin of search. The search starting from S tries to find the POI according to t he predetermined POI sequence M , and the search starting from E tries to find the POI in the reverse order of M ; that is, E  X  U m  X  U m  X  1  X  ...  X  U 1  X  S .
 The search is terminated when the search paths from both origins meet at a POI. Every time a search encounters the next POI to be visited, the arrival to the POI from another origin is checked. Suppose the POI is P c belonging to U C ,and both PSRs from S to P c and from E to P c have been found; we can then obtain a complete SR by combining these two PSRs at P c . When we need up to the k -th-shortest OSRs, we can obtain them by repeating node expansions until the k -th-shortest OSR is found. The abovementioned bidirectional search appears simple when only one shortest OSR is requested. However, when multiple k -OSRs are requested, there are some problems to be considered. In Section 4, we explain the problems and propose a solution.

When one of the categories in M has POIs with a very dense distribution, sev-eral independent searches will start from each POI belonging to the category. This causes an enormous number of node expans ions, because the node expansions take place independent of each other such that the computation takes a long time. To avoid this effect, Fujii et al. [3] proposed a method to set a midway category (MC), named bidirectional search with midway category (BSWMC). The MC is selected from the POI category that has the highest density. When a search reaches a POI in the MC, no new search targeted at the next category starts. At this time, a PSR from S or E to a POI belonging to the MC is found. There is no additional search to find the next category starting from a POI in MC. Meanwhile, node expansions from another origin are advanced until one of them reaches the POI from the other side. At this time, a complete OSR is found.

The BSWMC method is suitable when we know the density of the POI in each category. In general, however, we cannot know the POI density. Even if we can conjecture the density, the POI is apt to be distributed with bias. Therefore, we need to improve the efficiency without setting the MC. Both the abovementioned approaches start a new node expansion from a POI belonging to U i toward a POI belonging to U i +1 , every time a POI belonging to U i is found. In Fig. 4, a search for a POI belonging to U 1 starts from S ,andthen the search finds P 1 1 and P 1 2 in that order. New searches for a POI belonging to U 2 start from P 1 1 and P 1 2 . Then, the search that started from P 1 1 finds P 2 1 as the second-visited POI, at which a further new search starts for a POI belonging to U . Later, the search starting from P 1 2 reaches P 2 1 , and then another new search for a POI belonging to U 3 starts. However, these two s earches will consequently find the same path (PSR) from P 2 1 to E , as is shown in Property 1. Therefore, we need to suppress this redundant node ex pansion. A similar duplication also happened in the PNE when it adopted the in cremental network expansion (INE). Property 1. k -PSRs starting from a POI belonging to U i to E ,obeyingapre-specified visiting sequence are determined uniquely.
 Proof. We deal with a time-invariant road network, and the constellation of thePOIsisfixed.If k -PSR from a POI position belonging to U i to E will not be changed at query time, then they are determined uniquely. Therefore, this supports the property.
 Despite Property 1, a unidirectional search always starts a new search when a new POI is found. This causes duplicated node expansions, which find the same PSR. By reducing these duplicated node expansions, an efficient k -OSR query can be conducted.
 Property 2. Consider searching an SR , the search started from S , finding POIs in order, then reaches a POI ( P i j ) belonging to U i .LetthePSRfrom S to P i j be R , and the length be L R . To advance this search, a new search targeted at the next category U i +1 starts from P i j . Consider another search path R whose length is L R has reached P i j . Then, we have the following relation between L R and L R : Proof. The priority queue (PQ) returns a node to be expanded according to the expected path length in ascending order. When R is returned from the PQ prior to R , the following relation stands: The heuristic distance value h ( P i j ,E ) is the same in both the left and right terms, so we obtain the following relation: Consequently, the equality in Eq.(3) is true when R and R have the same length.
 From these two properties, we can suppr ess duplicated node expansions. When P 1 is the nearest POI belonging to U 3 from P dependent when the paths reached P 2 1 from S . Then, when the search already started from P 2 1 , which is the head of the PSR S  X  P 1 2  X  P 2 1 ,tostartafurther node expansion from the same POI that is the head of another path is not useful.
In Fig. 4, we explained that a late-arrival PSR to P 2 1 (e.g., S  X  P 1 1  X  P 2 1 ) cannot be the shortest path among SRs through P 2 1 , because the first-arrival PSR to P 2 1 (e.g., S  X  P 1 2  X  P 2 1 ) is shorter than the other late-arrival PSR. Then, when we need to find only one shortest OSR, we do not need to consider the late-arrival PSR at any POI. However, when we need to find k -OSR ( k&gt; 1), late arrival PSRs could be a part of the SR s. In this case, we need to consider the late-arrival PSR. Simultaneously, we need to consider suppressing the duplicated node expansions, which gives the same result.
 To cope with this problem, we use the visited POI graph (VPG) as shown in Fig. 5. In the graph, nodes are visiting POIs (and two terminal points S and E ) and edges are paths connecting neighboring POIs. An edge in VPG can be shared by plural OSR routes. For example, OSR routes R 1 and R 2 are sharing the link P 2 2 P 3 3 and P 3 3 E . Therefore, if we calculate for a link once, we can avoid the calculation for the same link again. This reduces the calculation cost of road network distance considerably, especially, when m is large.
Hereafter, we refer to the unidirectional search with the VPG as the USVPG, and the bidirectional search with the VPG as the BSVPG. Algorithm 1 shows the BSVPG algorithm. The USVPG algorithm is almost similar to the BSVPG algorithm, although it is simpler. Line 1 initializes PQ with S and E . R is the result set returning k -OSR. The size of R is bounded by k , i.e., the number of requested SRs. Then R.i , the number of found SRs in R , does not exceed k . Algorithm 1. Bi-directional Search with VPG R.L max is the maximum SR length found so far; it has the value  X  while R.i is less than k .When R.i reaches k , R.L max shows the R.i -th shortest SR length. Line 2 initializes the VPG by inserting the two vertices S and E .

In Line 4, the entry that has the smallest cost is removed from the PQ .When the entry is the next POI to be visited, the VPG is checked as to whether the POI has already registered in it (Line 8). Then, a record ( e.P prev  X  e.nb )is composed and inserted into the VPG (Li ne 8). Next, a check is performed as to whether a PSR from another origin has already reached the POI (Line 8). In this case, generated SR is called to m ake all SRs passing through the POI e.nb . The resulting SRs are registered in R ,and R.i and R.L max are altered by the results (Line 12).
 Algorithm 2. Generatesr( e , VPG , R ) Lines 15 to 18 are always executed when e.nb is the next visiting POI and the PSR from the opposite side has not reached e.nb . The record ( e.P prev  X  e.nb )is inserted into the VPG, and then the POI that belongs to the next visiting POI category is searched (Line 17).

The steps below Line 21 are always executed because of the reason described in Section 3.1. Then, when e is a POI, the search advances in two ways, one is to search the POI that belongs the next visiting POI category (Line 17), and the other is to search the POI that belongs to the same POI category (Line 22). When e is not a POI, usual node expansion is continued. This SR search is repeated until the number of found SRs exceeds the requested number k ,and the cost of e becomes greater than R.L max (Line 23). After the latter condition has been satisfied, no shorter SR than k -th shortest SR in R will be created. To evaluate the performance of the proposed methods, we conducted extensive experiments. We used digital road-network data published by the Geospatial Information Authority of Japan (GSI), in the area of Saitama city, Japan. The road map consists of 25,586 road segments. We implemented the algorithms using the C# language. The computer used was a Core 2 Quad 2.40GHz CPU with 4GB RAM, and the operating system was Windows Vista.

We generated several sets of POIs in a pseudo-random sequence, with varying distribution density ( p ), which means the existence probability of a POI on a road segment (a road segment means a pol yline between two intersections, or between an intersection and a dead end). F or example, there are approximately 25 POIs in the subject area in the case of p =10  X  3 , and approximately 256 POIs when p =10  X  2 .

Fig. 6 shows the results between the unidirectional search (USVPG) and the bidirectional search (BSVPG). (a) compares their processing time among the unidirectional searches that start from S (USVPG-S), E (USVPG-E), and BSVPG. The density of the POI increases from the first POI (0.001) to the last POI (0.01). In these cases, the USVPG-S is the fastest, the USVPG-E is the slowest, and the BSVPG is moderate. Wh en the density distributions of POIs are not equal, the unidirectional search starting from the less-dense side always outperforms the other.

Fig. 6(b) shows the result of another pattern. In this case, the middle category has the highest density, and the third category has the second-highest density. The BSVPG outperforms the others in this case. The experiments using the other combinations show the same tendency. Consequently, when we estimate the density of each visiting POI category, we can choose the fastest strategy by starting the search from the less-dense side. In general, however, the estimation is not easy. Even if we can know the statis tical density of each POI category, the density may vary depending on its location.

Fig. 7(a) and (b) compare the performance between BSVPG and PNE ac-cording to the processing time. The experiments were conducted under three POI categories in which p =0 . 001, p =0 . 002, and p =0 . 01, with shuffling of the order to be visited. In these figures, the pattern is shown by the three-digit number that corresponds to the three di fferent POI densities:  X 1 X  corresponds to 0.001,  X 2 X  to 0.002, and  X 3 X  to 0.01. (a) shows k =1and(b)shows k = 10. As indicated by these results, the BSVPG always outperforms the PNE, and the processing time becomes stable with increasing k , independent of the POI density patterns. In this paper, two fast algorithms called USVPG and BSVPG have been pro-posed to search the k -OSR for the road-network distance. Both algorithms are controlled by the A* algorithm. The BSVPG searches POIs from S and E simul-taneously. This paper also proposes the VPG to reduce multiple node expansions, which is unavoidable in trip planning. This fact holds for all the existing trip plan-ning methods that work on road-network distance measurements, for example, the OSR, TPQ, and MRPSR. Therefore, a strategy to reduce them can be the key to the fast trip planning. The VPG can be applied not only to the OSR, but also for several other types of trip planning that use road-network distance measurements.
Experimental results confirm that the presented algorithm can search the OSR approximately 100 times faster than the PNE. The USVPG and BSVPG largely contribute to the improvement in the VPG. The USVPG search, starting from the less-dense POI side, can find the OSR faster than the BSVPG, while the USVPG search starting from the other side will degrade. Therefore, in the case when the POI density cannot be known in advan ce, the BSVPG can be a good selection.
In this paper, we proposed an efficien t method based on INE, however, in-cremental Euclidean restriction strategy [9] can also be applied for OSR search based on road network distance. On this strategy, two kinds of efficient algo-rithms are essential; one is an incremental OSR candidates generation method in Euclidean distance, and the other one is the efficient road network distance verification method for those candidates. Our future direction is to develop them. Acknowledgments. This work was supported by Grants-in-Aid for Scientific Reaserch (KAKENHI) 24500107 and 23300337.

