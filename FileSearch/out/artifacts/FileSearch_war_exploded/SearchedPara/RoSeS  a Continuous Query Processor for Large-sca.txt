 We present RoSeS , a running system for large-scale content-based RSS feed filtering and aggregation. The implemen-tation of RoSeS is based on standard database concepts like declarative query languages, views and multi-query op-timization. Users create personalized feeds by defining and composing content-based filtering and aggregation queries on collections of RSS feeds. These queries are translated into continuous multi-query execution plans which are optimized using a new cost-based multi-query optimization strategy. H.3.3 [ Information Systems ]: Information Search and Re-trieval X  Online Information Services, Information Filtering Algorithms, Performance, Experimentation RSS, continuous query processing, multi-query optimization
Global news sites such as Yahoo! News or AOL News attract millions of users each month. For example, during January 2011, 46.3 million unique U.S. people visited Ya-hoo! News using PCs and laptops from home and work locations 1 . Staying informed by consulting online journals  X  The authors acknowledge the support of the French Agence Nationale de la Recherche (ANR), under grant ROSES (ANR-07-MDCO-011)  X  X eally Open, Simple and Efficient Syndication X  http://blog.nielsen.com/nielsenwire/online mobile/january-2011-top-u-s-web-brands-and-news-sites/ retrieved on June 15th 2011.
 and news aggregators has become a daily activity of millions of people and the previous numbers do not take account of the increasing use of mobile phones and tablets for access-ing web contents. On the back-end side of this process, tra-ditional commercial online media (journals) are more and more complemented by new content-producing social media (Facebook, Twitter) which generate an abundant number of text streams for promoting recently published contents.
The increasing number of news producers and the over-whelming amount of news articles published online each day calls for advanced filtering and aggregation techniques for the efficient personalized delivery of news. In this demon-stration we present a prototype for large-scale content-based RSS feed querying and aggregation. This prototype is part of the Really Open Simple and Efficient Syndication ( RoSeS ) framework (ANR-07-MDCO-011) [4] implementing a range of services for crawling, filtering and aggregating of RSS feeds. A central goal of this framework is to enable large-scale RSS aggregation based on algorithms and data struc-tures which are scalable in terms of the number of feeds, ag-gregation queries (publications) and subscription. Our cho-sen approach is to revisit, redefine and re-implement stan-dard online RSS aggregation services by applying traditional database concepts like declarative languages and views and by extending current data stream management and continu-ous query processing solutions. Multi-query optimization [7] is an important aspect in the implementation of RoSeS to achieve scalability. Users create personalized feeds by defin-ing and composing content-based filtering and aggregation queries on collections of RSS feeds. These queries are trans-lated into continuous multi-query execution plans which are optimized using a new cost-based multi-query optimization strategy.

The paper is organized as follows. Section 2 briefly de-scribes the RoSeS language and model. An overview of the platform, query processing and the optimization process are presented in Section 3. Finally Section 4 shortly describes the demonstration scenario. A detailed description of our approach as well as a comparison with existing pub-sub tech-niques can be found in [4].
The language we have implemented in the RoSeS system provides instructions for registering feeds (register), com-posing feeds (create) and creating subscriptions (subscribe). Declarative feed composition is the most important feature of this language. The underlying query language is expres-sive and simple to use, designed to facilitate most common operations and large scale multi-query optimization. The publication language favors the expression of nested union-filtering expressions, combined with joins through three clauses: (1) A mandatory from clause, which specifies the input feeds called main feeds , (2) zero or more join clauses for joining feeds with other feeds called annotation feeds (see example below) and (3) an optional where clause for defin-ing filtering conditions on main feeds and annotation feeds. Main and annotation feeds are also called source feeds . The stream of items generated by a create feed instruction is called a publication . Note that the contents (title, descrip-tion) of items cannot be modified by publication queries. Source feeds are either registered RSS feeds or publications. External feeds can be referenced directly by their URL (im-plicit registration) or by a local name defined by using the register feed instruction. It is also possible to register pub-lications which allows to transform the contents of items (see examples below). Finally, subscriptions can be defined on registered source feeds or publications by using the instruc-tion subscribe to . A subscription specifies for a given feed, a notification mode (RSS, mail, etc.), a periodicity and an optional transformation.

The items of a feed can only be transformed by registra-tion and subscription. It is important to mention here the difference between an unregistered and a registered publica-tion. Unregistered publications are standard views which can be reused in other queries and be replaced by their definitions (publication queries) for enabling optimization through query rewriting (for example push filtering condi-tions to the source feeds). Registered publications are ma-terialized views of transformed items. Whereas the newly generated stream might be used as input for new queries, transformation makes query rewriting through the replace-ment by its defining publication impossible.

We will illustrate the different features of the language by the following examples. For organizing outings to rock concerts with his friends, Bob wants to publish a RSS feed which filters and aggregates the news of a public web site and the messages of a personal Twitter stream. This can be achieved by the following three instructions registering the corresponding source streams in the system and creating a new publication RockConcertStream : Publication RockConcertStream filters all items containing the term  X  X oncert X  from two feeds EventAnnounces and Fol-lowedTwitterStream . Observe that variable $r denotes the union of both streams. Additionally, items generated by the first feed (variable $a) must contain the term  X  X ock X  in their title.

Bob is also a fan of the rock group Muse and wants to create a feed MusePhotoStream annotating news about this group with appropriate photos. MusePhotoStream publishes all items in feed MuseNews and all items in feed Rock-ConcertStream containing the term  X  X use X  in their descrip-tions. Each item in this main stream $a is annotated by photo items having similar titles published in two anno-tation feeds FriendsPhotos and MusicPhotos (restricted to category  X  X ock X ). Annotation consists in joining a main feed ($a) with a window on a union of annotation feeds. As men-tioned before, annotation items are  X  X nvisible X  until they are merged into the contents of their main items by an explicit registration instruction applying some transformation ( In-cludePhotos.xsl in the example). The final example shows two subscriptions to the Rock-ConcertStream publication: the first one extracts item titles ( X  X itle.xsl X  transformation) and sends them by mail every 3 hours, the second one simply outputs an RSS feed refreshed every 10 minutes.
The RoSeS system is composed of five modules for pro-cessing RSS feeds and managing meta-data about users, publications and subscriptions. As shown in Figure 1, RSS feeds are processed by a three layered architecture completed by two modules (catalog and system manager) providing meta-data management services for storing, adding, updat-ing and deleting source feeds, publication queries and sub-scriptions:
Acquisition : The main task of this module is to trans-form evolving RSS documents into a continuous stream of RoSeS items which can be processed by the evaluation mod-ule. This transformation includes an efficient refresh strat-egy optimizing the bandwidth usage [5].

Evaluation : The core of the RoSeS system is an alge-braic multi-query plan which encodes all registered publica-tion queries. The evaluation of this query plan follows an asynchronous pipe-lined execution model where the evalua-tion module (1) continuously evaluates the set of algebraic operations according to the incoming stream of RoSeS items, and (2) manages the addition, modification and deletion of publication queries.

Dissemination : This module is responsible for transform-ing RoSeS items into different output formats and notifying new items to corresponding user subscriptions. The goal of this module is to define the way items are rewritten in given formats (SMS, email, RSS/Atom feed. . . ).
Query processing consists in continuously evaluating a col-lection of publication queries. This collection is presented by a multi-query plan composed of physical operators reflecting the operators presented in section 2 (union, selection, join and window). The query graph is observed by a scheduler that continuously decides which operators (tasks) must be executed. The scheduler has at his disposal a pool of threads for executing in parallel a fixed number of threads. The choice of an inactive operator to be evaluated is influenced by different factors depending on the input buffer of each operator (number/age of the items in the input queue).
Based on this execution model, we define a cost model for estimating the resources (memory, processor) necessary for the execution of a query plan. Compared to the traditional cost estimation based on the input data size, the estimation parameters of a continuous plan must reflect the streaming nature of the data. We adapt a simplified version of the model presented in [1] and define the cost of each operator as a function of the publishing rate R ( b ) of its input buffer b . In table 1, p denotes a filter (  X  ) or join ( S ( w ) is the size of the annotation window w of a join and d denotes the duration of the window operator  X  (1 week, 2 days, etc.). The cost of each operator mainly depends on the publishing rate of its input buffer(s). The selection operator assumes a constant execution cost for each item (items are in general small text fragments). The publishing rate of the selection operator reduces the rate of its input by the selectivity factor sel ( p )  X  [0 , 1] depending on the selection predicate p . Union generates an output with a publishing rate corresponding to the sum of its input rates. We assume zero memory and processing cost since each union can be implemented by a set of buffer iterators, one for each input. It is easy to see that the input rate of each operator strongly influences the global cost of the execution plan (sum of all operators cost). We will describe in the following section how we can reduce this rate by pushing selections and joins towards the source feeds of the query plan.
A novel aspect of our framework with respect to most of the other multi-query optimization solutions (except [1]) lies in the explicit integration of a cost model taking account of term selectivity in filtering conditions. Our optimization strategy is based on the heuristic that selections and joins should be applied as early as possible in order to reduce the global cost of the plan. Standard snapshot semantics for con-tinuous queries allows us to use traditional rewriting rules for algebraic expressions such as distributivity of selection over union and commutativity of selection with joins.
The optimization process is decomposed into (1) a nor-malization phase which applies all rewriting rules for push-ing selections towards their source feeds and for distributing joins over union, and (2) a factorization phase of the se-lection predicates of each source based on a new cost-based factorization technique.

Query normalization : The goal of the first phase is to ob-tain a normalized query plan where all filtering selections are applied first to each source before applying joins and unions. This is possible by iteratively applying distributivity of se-lections on unions and commutativity between selection and join. It is easy to show that these properties always allow us to obtain a normalized plan which is a four level tree where the leaves of the tree are the sources involved in the query (first level), the second level nodes are the selection operators which can be applied to each source (leaf), the third level are window/join operators applied to the results of the selections and the final (fourth) level are unions ap-plied to the results of the selections/windowed-joins to build the final results. Normalization also flattens all cascading selection paths into a single conjunctive selection.
Query factorization : Normalization generates a global query plan where each source s is connected to a set of selection predicates P ( s ). Factorization consists in building a mini-mal filtering plan for each source. To find a best operator factorization, we proceed in two steps: we first generate for each source a predicate subsumption graph which contains all predicates subsuming the set of predicates in P ( s ). Each subsumption link in this graph is labeled by a weight cor-responding to the output rate of the source node (source or filtering operation). Such a graph is shown in Figure 2. The Figure 2: A Predicate Subsumption Graph and Min-imal Steiner Tree filtering predicates applied to source s 2 are a  X  b , a  X  c and a  X  c  X  d . The subsumption graph is composed of these three predicates and all their subsuming predicates: a , b , c , d , a  X  d and c  X  d . Each subsumption arc from some predicate p to some predicate q is labeled by the estimated evaluation cost of evaluating q on the result of p . Corresponding to our cost model, this evaluation cost can be estimated by the product between the publishing rate rate ( s 2 ) of source s estimated selectivity of predicate p .

It is easy to see that any sub-tree of this graph covering the source s (root) and all predicates in P ( s ) corresponds to a filtering plan which is equivalent to the original plan. Such a tree is called a Steiner tree [2] where the cost is obtained by the sum of all arc weights in the tree. Based on this observation our optimization problem then consists in finding a Steiner tree of minimal cost. This is illustrated in Figure 2 showing a subsumption graph for the source s 2 and a minimal Steiner tree of this graph (in bold).
The Steiner tree problem [3, 6] is known to be NP-complete and we have developed an approximate algorithm which ex-ploits the particular properties of a filtering plan (all outgo-ing arcs of a node have the same weight and the weight is monotonically decreasing with the depth of the node in the graph). This algorithm is based on a local heuristic for dy-namically building the subsumption graph by choosing the most selective subsuming predicates. Whereas it will find only an approximate solution, our experiments on real data and synthetically generated queries show that the evaluation cost of the obtained approximate plan generally is near to the evaluation cost of the minimal Steiner tree plan with a much lower optimization cost.
We present a Java prototype integrating all RoSeS com-ponents described in Section 3. The prototype is based on a multi-threaded architecture and uses Rome , the Java X  X  stan-dard library for RSS management. The usage and func-tioning of the system will be explained using two graphical user interfaces. The first interface (fig. 3) is a Web interface powered by GWT (Google Web Toolkit) that allows users to register and share RSS feeds and to visually build pub-lications through an easy-to-use visual programming inter-face. The second interface is a Java client using IBM X  X  SWT (Standard Widget Toolkit) and the JUNG (Java Universal Network/Graph) framework for visualizing the multiquery evaluation (fig. 4) as well as predicate subsumption graphs and the resulting optimized filter plans. Both user inter-faces permit to access the RoSeS System. The prototype and the Java client can be downloaded from http://www-bd.lip6.fr/roses/doku.php?id=prototypes .

Our demonstration is composed of two scenarios. In the first scenario we will present the Web user interface for creat-ing publication queries. We will show how a user can create in some seconds a publication query aggregating hundreds of registered news feeds and personalize this publication by defining some content-based filtering criteria. Secondly, we will illustrate the usage of join for annotating social network messages (Twitter, Facebook) with critics about new movies published in form of RSS feeds ( eg. www.filmcritic.com).
The second scenario will illustrate the query processing steps of our prototype using the Java interface. We will load a script of publications containing a workload of 1000 conjunctive filtering queries of the form q =  X  a 1  X  X  X  X  X  a  X  X  X  X  src n ), where k  X  [1 , 3], n  X  [1 , 10] and n defines the number of query sources randomly picked from a fixed set of 25 feeds. Using the Java client, we will visualize the multi-query plan generated by the system, as well as the predi-cate subsumption graphs and the optimized filtering trees. Finally, we will also compare query plan optimization and query execution costs for higher workload up to 10000 ran-domly generated publication queries. [1] M. Cammert, J. Kr  X  amer, B. Seeger, and S. Vaupel. A [2] M. Charikar, C. Chekuri, T. Cheung, Z. Dai, A. Goel, [3] X. Cheng and D. Du. Steiner Trees in Industry , [4] J. Creus, B. Amann, N. Travers, and D. Vodislav. [5] R. Horincar, B. Amann, and T. Arti`eres. Best-effort [6] F. Hwang, D. Richards, and P. Winter. The Steiner [7] T. K. Sellis. Multiple-query optimization. ACM Trans.
