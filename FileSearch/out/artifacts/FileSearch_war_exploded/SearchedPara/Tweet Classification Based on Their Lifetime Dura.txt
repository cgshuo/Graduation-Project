 Many microblog messages remain useful only within a short time, and users often find such a message after its informa-tional value has vanished. Users also sometimes miss old but still useful messages buried among outdated ones. To solve these problems, we develop a method of classifying messages into the following three categories: (1) messages that users should read now because their value will diminish soon, (2) messages that users may read later because their value will not largely change soon, and (3) messages that are not useful anymore because their value has vanished. Our method uses an error correcting output code consisting of binary classi-fiers each of which determines whether a given message has value at specific time point. Our experiments on Twitter data confirmed that it outperforms naive methods. H.3 [ Information Storage and Retrieval ]: Information Search and Retrieval microblog, filtering, time-dependency, real-time, Twitter
Real-time information sharing is an important feature of microblogs, and many microblog messages are related to some real-time events. When users have many incoming messages, however, they often find a message including real-time information only after its informational value has van-ished. For example, if a user finds a message  X  X aining out-side X  X n the next day, it has little value. In addition, because the ratio of such real-time information is high in microblogs, old but still useful messages are often buried among many old messages that are not useful anymore.

To help users to determine which messages to read, we classify messages into the following three categories: (1) messages that users should read now because their value will diminish soon, (2) messages that users may read later because their value will not largely change in a short time, and (3) messages that are not useful anymore because their value has vanished. When a user is busy, the user can read only messages in the first category, and when a user has time, the user can also read messages in the second category.
To classify messages, we develop a method of determin-ing the lifetime duration of messages, i.e., how long they keep their informational value. Instead of estimating dura-tion of arbitrary length, we consider a fixed set of typical durations, and formulate the problem as a multiclass classi-fication problem. We use a kind of error correcting output coding consisting of multiple binary classifiers each of which determines if a given message has its value at a specific time point. We conducted experiments on data from Twitter 1 , and confirmed that our method outperforms naive methods.
In Twitter, if a user  X  X ollows X  others, all  X  X weets X  posted by them are shown in real-time in his  X  X imeline X  in the re-verse chronological order. Users can also use Twitter for conversation by posting a tweet as a  X  X eply X  to another user.
There have been many studies on the classification of mi-croblog messages. Their classification may help our classi-fication, but none of them coincide with ours. For exam-ple, Sriram et al. [8] classified messages into five categories: news, opinions, deals, events, and private messages, but a private message  X  X ho wants to get lunch? X  have very short lifetime while a private message  X  X  X  X  spending my vacation at Hawaii X  have longer lifetime. Similarly, news messages reporting stock prices have very short lifetime, while news messages reporting tomorrow X  X  weather have longer lifetime.
There is also research on ranking microblog messages based on how valuable they are, e.g., [1]. On the other hand, we do not consider the absolute amount of informational value of messages, but focus on its relative change over time. For example, even if some message includes more valuable infor-mation than another message, if the value of the former will not change over time while the value of the latter will vanish soon, we classify the former into the category  X  X ay-read-later X  and the latter into the category  X  X hould-read-now. X 
Sakaki et al. [7] focused on real-time nature of microblogs, and proposed a method of monitoring Twitter for detecting occurrences of real-time events, such as earthquakes. Be-cause messages reporting real-time events usually have short lifetime, identification of such messages may help our clas-h ttp://twitter.com/
Fi gure 1: Change of values of messages over time sification. In their method, however, we need to specify one event type, e.g., earthquakes, and train the classifier for it.
Mathioudakis et al. [6] also showed a method of detecting real-time trends by identifying bursty keywords in Twitter stream. Because messages including such keywords are often related to real-world events, and have short lifetime, we also use the information on bursty keywords in this research.
There has been also many studies on classification of SNS users [4, 3] or their relationships [5, 2]. These classifications must also indirectly help our classification.
We consider whether a given message has informational value for a given user, i.e., the message is worth reading for the user. Value of some messages does not largely change over time, while value of some messages start to diminish immediately after they are posted, or after some time has passed. For example, Figure 1 shows how the value of mes-sages  X  X arthquake! X  and  X  X awaii is beautiful X  changes over time. The value of the former is high for a while after it was posted, but then it starts to decrease, and after some time, the message has little value. On the other hand, the value of the latter does not largely change over time (although it de-pends on the context and the reader). Note that the absolute amount of value is not important here. These two examples correspond to the two most typical types of value: time-dependent value and time-independent value. The mes-sage  X  X arthquake! X  mainly has time-dependent value, while  X  X awaii is beautiful X  mainly has time-independent value.
Time-dependent value shown in this example changes in a relatively simple way. It has its peak at the posting time, it starts to decrease at a certain time point, and it almost vanishes at another time point. Sometimes time-dependent value changes in more complex way. For example, the value of a message  X  X affe latte 10% off 17:00-19:00 everyday X  peri-odically changes. In this paper, however, in order to simplify the problem, we focus on whether the current value of a mes-sage will diminish within a given time span. Therefore, if the current time is 10:00, and the given time span is one hour, the current value of the  X  X affe latte X  message will not largely change within the time span. On the other hand, if the current time is 18:30 and the time span is one hour, the value of the message will largely decrease within one hour.
More formally, we define the time-dependency of a mes-sage as the ratio of the amount of value it will lose within a given time span, to the amount of value it has now. There-fore, time-dependency of a message has two parameters: cur-rent time and time span. We call the latter parameter span . Now we define T imeDependency ( a; t c ; ), time-dependency of a message a at the current time t c for a span , as follows:
T imeDependency ( a; t c ; ) = val ( a; t c ) val ( a; t where val ( a; t ) denotes the value of a message a at time t .
For example, if = 30 minutes, the time-dependency of the message  X  X arthquake! X  is high when it was posted be-cause its current value will be mostly lost after 30 minutes. One hour later, however, the time-dependency of the mes-sage becomes low because its current value is already low, and will not largely change anymore. Time-dependency of a message changes depending on the current time in this way.
Time-dependency of a message also changes depending on the span. For example, the value of a message  X  X omorrow night, we have a party X  will not largely change in an hour, but the message will have little value after the party. There-fore, its time-dependency is low if the span in an hour, but its time-dependency is high if the span is a couple of days.
On the other hand, if the value of  X  X awaii is beautiful X  will not largely change forever, its time-dependency is low for any current time and for any span. In this way, time-dependency of messages with time-independent value is low.
Two messages above has either time-dependent or time-independent value, but some messages have both. For ex-ample, a message  X  X loe-vera cream is good for quick care of burns X  X ncludes general knowledge and has time-independent value, but if it was posted in response to a message  X  X y son burned his hand. What do I do? X , the message is especially valuable within a short time, i.e., it also has time-dependent value for the reader who posted the question.

Sometimes a message also has time-dependent value which is a mixture of time-dependent value with various lifetimes. In this paper, however, in order to simplify the problem, we only separate time-independent and time-dependent value, and we do not further decompose time-dependent value.
By using the concepts defined above, we formulate the problem in this research as follows: Given a microblog mes-sage a , its posting time t p , the current time t c , and the span in which we consider the change of values, we determine: 1. whether T imeDependency ( a; t p ; t c t p ) is high, 2. whether T imeDependency ( a; t c ; ) is high, and 3. whether a has time-independent value.
 If the answer to 1 is yes, the original time-dependent value of a at the posting time has already been mostly lost until the current time. In that case, users may ignore the message unless it also has some time-independent value. If the answer to 1 is no and the answer to 2 is yes, a is still useful, but its current value will mostly vanish within the time span , which means users should read the message now.
In this section, we explain our method of determining time-dependency of messages, particularly in Twitter.
In this paper, we assume that each Twitter user periodi-cally visits the timeline at a fixed interval, and we use the length of the interval, which is given in advance, as the span of the time-dependency. Every time a user visits the time-line, we classify messages whose value will vanish before the next visit into the category  X  X hould-read-now X .

We also assume that time-dependent value is binary. When a message with time-dependent value is posted, the value first exists, and then vanishes when its lifetime has passed.
Then the problem is simplified to the following two prob-lems: For each message, we determine: 1. whether it has time-independent value, and 2. the lifetime duration of its time-dependent value.
In addition, we fix values for lifetime durations only to the following six values: less than 10 minutes (or no time-dependent value), 10 minutes or longer, 1 hour or longer, 6 hours or longer, 1 day or longer, and 1 week or longer. It simplifies the second problem to a multiclass classification. Here we do not distinguish a message with time-dependent value whose duration is shorter than 10 minutes, and a mes-sage without time-dependent value from the beginning.
For determining the existence of time-independent value, we use a simple binary classifier. For determining duration of time-dependent value, we compare two approaches: using one multiclass classifier, or using multiple binary classifiers, each of which determines whether the message has time-dependent value after 10 minutes, 1 hour, 6 hours, 1 day, and 1 week, respectively, from the posting time. The latter is a kind of ensemble learning, and we produce the final result by using the results of the five classifiers. We tested the following three methods to produce the final result. (1) No aggregation
Suppose the results of five classifiers for a message are 0, 1, 1, 0, 0, where 1 means yes. In the first method, we use this result as it is. For example, if the message was posted two hours ago, and the interval of the user is one hour, then we classify this message into the category  X  X ay-read-later X  because the message will keep its current time-dependent value until the user comes back one hour later. (2) Monotonically Decreasing Assumption
In the second method, we assume that time-dependent value of a message monotonically decreases over time, which is true for most real microblog messages. When the answer of five classifiers conflicts with this assumption, we correct it to the closest (in the Hamming distance) monotonically decreasing sequence. If there is no unique closest one, we do not correct it (but we had no such a case in our experiments). (3) Probabilistic Correction
In the third method, from the training data set, we com-pute the conditional probability of every correct answer given an original answer by the classifiers, and correct the original answer based on this probability. In other words, if the clas-sifiers produce an answer 0, 0, 1, 1, 1 for a message in the test data set, we collect all messages in the training data set for which the classifiers produce the same answer, examine the correct answers for them, and choose the most frequent one. We correct the answer by using this method only when the original answer is not monotonically decreasing.
Next, we list the features we used for the classifiers. Some of them are specific to Twitter. For space limitation, we omit the details of how to compute or normalize them. (1) Number of Characters
We use the length of messages because messages about what is going on tend to be short. (2) Type of the user who posted the message
Some users use microblogs for information publishing, and some users use them for personal communication. To include information on user types, we retrieve at most 200 past mes-sages by the user who posted the message, and compute the average and the standard deviation of their length, and also the frequency of reply. The standard deviation is useful to identify  X  X ot X  whose messages have a fixed format. The fre-quency of reply reflects the frequency of personal conversa-tion. We also use information on whether the users posting and reading the message have reciprocal follow relationship. (3) Inclusion of bursty words
Messages including bursty words are usually related to real-time events, and have high time-dependency. We con-sider both local frequency in the user X  X  timeline and global frequency. To approximate global frequency, we use the words shown in buzztter, a service that shows words whose frequency is increasing in Twitter stream in real-time 2 . (4) Interval of Reply
If a message is a part of a real-time conversation, it has short lifetime, while if it is a part of a long discussion, its lifetime is longer. In order to include this information, if a message is a reply, we use the time difference between the message and the preceding message. (5) Time expressions in the message
Time expressions in messages may represent the starting or ending time of some event. We extract the closet future time expressions, and the closest past time expressions, and compute the difference from the posting time. (6) Inclusion of URL and photos
Messages including URLs are often about some recent news, and messages including photos are often about what is going on now. We use two boolean values for them. (7) Time dependency of each terms
Some words, e.g.,  X  X ow, X  suggest some real-time events, and some words are rarely related to real-time events. For each word, we assign the most frequent lifetime duration of messages including the word in the training data set. Then for each message in the test data set, we choose a word with the longest duration, and use its duration as a feature value.
In this section, we explain the result of our experiments.
We randomly selected 989 Twitter users in Japan time-zone who are following 50 to 1,000 users. These 989 users were following 168,975 users in total, and we collected the tweets by these 168,975 users from April 8 2012 to April 14 2012. The collected data set includes 5,354,733 tweets.
Then we randomly selected a time point between April 8 and April 14 for each of the 989 users, and reproduced their timelines consisting of 10 most recent tweets at that time point. For these 989 10 = 9 ; 890 tweets, we manu-ally determine the existence of time-independent value and the duration of time-dependent value by using a micro-task crowdsourcing service in Japan 3 . The result is our data set.
The reviewers in the task were asked to choose the dura-tion of time-dependent value from the following choices: no time-dependent value, 10 minutes, 1 hour, 6 hours, 1 day, 1 week, longer than 1 week. When  X  X onger than 1 week X  was chosen, we regard that the message has no time-dependent value, but has time-independent value.
 As classifiers, we used a SVM library LIBSVM 4 with the Gaussian kernel, and a decision tree library scikit-learn results were evaluated by 10-fold cross validation. h ttp://buzztter.com http://task.lancers.jp/ http://www.csie.ntu.edu.tw/~cjlin/libsvm/ http://scikit-learn.org/stable/modules/tree.html
First, we show the results of the experiments determin-ing the duration of time-dependent value. The first row of Table 1 shows the accuracy of the multiclass decision tree classifying messages into six classes explained before. The accuracy of multiclass SVM was lower, and is omitted here.
The second column shows the ordinary accuracy, i.e., the ratio of correctly classified messages, which was 34.55%. The third column shows the accuracy that allows misclassifica-tion into one shorter class (e.g., misclassifying a message with 1 hour duration into the class of 10 minutes). The fourth column shows the accuracy that allows misclassifica-tion to one shorter or longer classes. Notice that our final goal is the classification into three categories, and many mes-sages can be correctly classified even with such small errors.
The second row of Table 1 shows the accuracy of the method that uses the result of five SVMs as it is. This accuracy is the ratio of messages for which all five SVMs re-turn the correct answer. We also tested five binary decision trees, but its accuracy is lower, and we omit it here. The third row shows the accuracy after the correction based on the monotonic decreasing assumption, and the fourth row shows the accuracy after the probabilistic correction.
Table 2 shows the statistics of errors used in the prob-abilistic correction. The two most frequent patterns are: SVMs return 00111 or 01111 while the correct answer is 00000. Notice that these two patterns are corrected to 11111 in the monotonic decreasing assumption method.

The first row of Table 3 shows the accuracy of five SVMs separately. The accuracy is higher for longer durations. In order to see which feature has the biggest impact, we run SVMs with removing each feature, and for 10 minutes and 1 hour, the accuracy becomes lowest when we remove bursty words, while for longer durations, URLs have a biggest im-pact. These suggest that bursty words are usually related to topics with short duration, while Web pages pointed by URLs usually include information with longer duration.
We also run the experiment of determining the existence of time-independent value. The accuracy of a binary decision tree was 52.36%, while that of a binary SVM was 55.90%.
Figure 2 shows the accuracy of the final classification into three categories by a multiclass decision tree, five SVMs, and SVMs with the probabilistic correction. Here, the span is 30 min. and 3 hours, and the current time is 0 min., 5 min., 30
Table 3: Accuracy of SVMs without Each Feature min. after the posting time. As shown in Figure 2, SVMs with the probabilistic correction have the highest accuracy.
In this paper, we propose a classification scheme for mi-croblog messages in order to help users to determine which messages to read. To implement the classification system, we developed methods of determining lifetime duration of mes-sages. Our experiments with Twitter data confirmed that our methods outperform a naive method. The accuracy of our method, however, has a large room for improvement. Furthermore, we simplified the problem in many ways in this paper. For example, we simplified the problem to a multi-class classification problem, but prediction of lifetime duration, which is a real value, is more naturally a regres-sion problem. We are now working on a method that is more faithful to the original problem definition. This work was supported by MEXT/JSPS Kakenhi 23650048. [1] Y. Duan, L. Jiang, T. Qin, M. Zhou, and H.-Y. Shum. [2] J. E. Hopcroft, T. Lou, and J. Tang. Who will follow [3] A. Java, X. Song, T. Finin, and B. Tseng. Why we [4] H. Kwak, C. Lee, H. Park, and S. Moon. What is [5] J. Leskovec, D. Huttenlocher, and J. Kleinberg. [6] M. Mathioudakis and N. Koudas. TwitterMonitor: [7] T. Sakaki, M. Okazaki, and Y. Matsuo. Earthquake [8] B. Sriram, D. Fuhry, E. Demir, H. Ferhatosmanoglu,
