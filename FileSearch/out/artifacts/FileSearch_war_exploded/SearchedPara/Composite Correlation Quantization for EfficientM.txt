 Efficient similarity retrieval from large-scale multimodal database is pervasive in modern search engines and social networks. To sup-port queries across content modalities, the system should enable cross-modal correlation and computation-efficient indexing. While hashing methods have shown great potential in achieving this goal, current attempts generally fail to learn isomorphic hash codes in a seamless scheme, that is, they embed multiple modalities in a con-tinuous isomorphic space and separately threshold embeddings into binary codes, which incurs substantial loss of retrieval accuracy. In this paper, we approach seamless multimodal hashing by proposing a novel Composite Correlation Quantization (CCQ) model. Specif-ically, CCQ jointly finds correlation-maximal mappings that trans-form different modalities into isomorphic latent space, and learns composite quantizers that convert the isomorphic latent features into compact binary codes. An optimization framework is devised to preserve both intra-modal similarity and inter-modal correlation through minimizing both reconstruction and quantization errors, which can be trained from both paired and partially paired data in linear time. A comprehensive set of experiments clearly show the superior effectiveness and efficiency of CCQ against the state of the art hashing methods for both unimodal and cross-modal retrieval. Hashing, quantization, multimodal retrieval, correlation analysis
While big data with large volume, high dimensions, and multiple modalities are ubiquitous in search engines and social networks, it has attracted increasing attention to distill the correlation structures across heterogenous data modalities. For example, an uploaded im-age on Flickr is usually annotated with some relevant descriptions or tags, while a featured article on Wikipedia may consist of some correlative images. As relevant data from different modalities may endow semantic correlations, it is desirable to support multimodal search , which retrieves semantically-relevant results of all modals  X  Corresponding authors: Jianmin Wang and Mingsheng Long.
 in response to a unimodal query. Taking Flickr as an example, when a query image is given, the system should return both relevant tags and images. Due to large volume and semantic gap [18], effective and efficient retrieval of multimodal data remains a challenge.
In the case that the reference database is large-scale or that the distance calculation between query item and database item is costly, an efficient solution to enabling similarity search is hashing based methods [22], which perform approximate nearest neighbor (ANN) search with both computation efficiency and acceptable accuracy. The principle of hashing is to transform high-dimensional data into compact binary codes and generate similar binary codes for similar data items. The seminal work includes Locality Sensitive Hashing (LSH) [1] and Spectral Hashing (SH) [25]. However, traditional unimodal hashing methods cannot support multimodal search as ANN cannot be directly computed across different modalities.
Recently, several useful attempts have been made to multimodal hashing , which builds correlation structures across multiple modal-ities in the process of hash function learning and index multimodal data in a common Hamming space [5, 29, 13, 32, 33, 34, 20, 24, 27, 28, 8, 26, 16]. These methods generally work in two-step pipeline: first, embed multiple data modalities into a continuous isomorphic latent space by maximizing inter-modal correlations, and second, quantize the isomorphic embeddings into binary hash codes by sign thresholding. While showing promising performance, the two-step pipeline may encounter two limitations: first, conversion from real-valued features to discrete codes may incur substantial information loss, making the continuous latent space suboptimal for binary cod-ing and the binary codes suboptimal for retrieval [24, 10]; second, directly binarizing latent features may lead to unbalanced encoding schemes [32, 33]. Fundamentally, by continuous relaxation of the binary constraints, most methods solve an optimization problem which may deviate significantly from the hashing objective as the quantization error is not accounted for in the optimization process. This somewhat contradicts the motivation of multimodal hashing. Hence, how to learn isomorphic hash codes for multimodal data in a seamless optimization framework remains an open problem.
In this paper, we propose Composite Correlation Quantization (CCQ), a novel model towards seamless multimodal hashing. Tech-nically, CCQ jointly finds correlation-maximal mappings that trans-form different modalities into an isomorphic latent space, and learns composite quantizers that convert the isomorphic latent features into compact binary codes. The flowcharts of CCQ and prior work are shown in Figure 1. To create a seamless optimization frame-work, we are inspired by Latent Semantic Analysis (LSA) [7] and decompose each datum into three latent factors, namely, correlation-maximal mapping, similarity-preserving codebook, and compact binary code. The three latent factors are jointly learned through an optimization problem, which preserves both intra-modal similarity and inter-modal correlation while minimizing both reconstruction and quantization errors. The CCQ model can construct extremely compressed and balanced binary codes to enable efficient multi-modal search, can readily handle a ubiquitous semi-paired scenario where only a fraction of input data are multimodal, and can scale linearly to large sample size. Comprehensive empirical evidence on large-scale datasets confirms that the CCQ model exhibits superior performance in both effectiveness and efficiency on both unimodal and cross-modal search against state of the art hashing methods.
The subsequent paper is organized as follows. We review related works in Section 2. We formally present our model in Section 3 and algorithm with analysis in Section 4. Empirical evaluations are reported in Section 5, while conclusions are enclosed in Section 6.
Recently, hashing-based multimodal search is a prevalent research focus in machine learning and information retrieval communities [5, 13, 34, 20, 27, 8, 10, 28, 26, 23, 31], which enables approximate similarity search on multimedia database with significant speedup and acceptable accuracy. Refer to [22] for a comprehensive survey.
Existing multimodal hashing methods can be organized into two categories: supervised methods and unsupervised methods. CMSSH [5], SCM [28], QCH [26], and SePH [14] are supervised hashing methods that require labeled pairs to indicate if the objects from dif-ferent modalities are similar (positive) or dissimilar (negative). As supervised information is usually unavailable in many applications, the deployment of these methods may be severely restricted. CVH [13], IMH [20], MSAE [24] and CorrAE [8] are unsupervised hash-ing methods applicable to the most general multimodal retrieval case given that paired data are available, while our proposed CCQ model falls into this category. IMH [20] is an extension of spectral hashing [25] to multimodal data, which is restricted by the train-ing burden since constructing and eigendecomposing the similarity matrices require O ( N 2 ) . While CVH [13] tackles the scalability issue, it does not jointly maximize cross-modality correlation and preserve intra-modality similarity. MSAE [24] and CorrAE [8] can capture both intra-modal similarity and inter-modal correlation by deep autoencoders, but they require spectral hashing or sign thresh-olding for obtaining binary codes from the continuous embeddings, which will give rise to uncontrollable quantization errors [9, 12].
A crucial problem with existing methods is that they essentially work in a separated two-step pipeline: first embed multimodal data into a common continuous latent space and then threshold the con-tinuous embeddings into binary codes of the Hamming space. Such conversion from real-valued features to discrete codes may result in substantial information loss, making the continuous latent space suboptimal for the binary codes and the binary codes suboptimal for retrieval [30]. Furthermore, directly binarizing latent represen-tation may lead to unbalanced encoding schemes, as shown in [32, 33]. Although IMVH [10] learns multimodal hash functions using a graph-cut quantizer instead of the sign thresholding, the quantizer solves a fast approximation of energy function with orthogonal con-straints and recurs large quantization error and unbalanced codes. CCQ approaches this problem by learning the modality-consistent latent space and balanced binary codes in a principled framework.
In the multimodal search system, the database and query consist of objects from different modalities. We only use image and text as two modalities to explain our approach, but the approach is formu-lated to support any number V of modalities. Let X 1  X  R P an image set of N 0 images with tags and the rest  X  N 1 images without tags, where N 1 = N 0 +  X  N 1 and each image is represented by P dimensional feature vector. Let X 2  X  R P 2  X  N 2 be a text set of N documents of the image tags and additional  X  N 2 documents, where N 2 = N 0 +  X  N 2 and each text is represented by P 2 -dimensional feature vector. Note that the proposed approach can handle semi-paired data where only a fraction N 0 / ( N 1 + N 2 ) of objects are multimodal, and is more realistic than typical multimodal methods.
An efficient approach to calculating the distance between image and text is to map images and texts to modality-isomorphic binary codes in which different modalities of the objects are comparable. In this paper, we will approach this problem by a joint optimization framework, dubbed Composite Correlation Quantization (CCQ). x R D and f 2 : R P 2 7 X  R D that transform images and texts into a D -dimensional isomorphic latent space, and jointly learn two com-posite quantizers q 1 : R D 7 X  { 0 , 1 } H and q 2 : R D 7 X  { 0 , 1 } that quantize latent embeddings into compact H -bits binary codes.
In the common H -bits binary space, image and text can be easily comparable such that both intra-modal and cross-modal search can be readily supported. After mappings f 1 , f 2 and quantizers q have been learned, the multimodal search problem can be converted into classical approximate nearest neighbor (ANN) search problem.
The main idea of CCQ is to jointly learn a correlation-maximal latent space and a similarity-preserving composite quantization in a unified optimization framework. To achieve this mission, we are inspired by Latent Semantic Analysis (LSA) [7] and decompose each input datum (image or text) x v n into three latent factors R C v , b v n , that is, x v n  X  R v C v b v n . While sharing similar formation as LSA, our formulation endows these latent factors with different semantics and thus constrains them with different conditions. More specifically, R v is correlation-maximal mapping, C v is similarity-preserving codebook, and b v n is the compact binary code of x present how to formulate the CCQ approach under these semantics.
To represent inputs with compact binary codes, two mainstream paradigms are sign thresholding in Hamming embedding methods [25], and vector quantization in codebook-based encoding methods [12]. As sign thresholding cannot guarantee minimal quantization error, we therefore adopt the vector quantization paradigm. CCQ is based on a set of M codebooks C v = [ C v 1 ,..., C v M ] , where each codebook C v m contains K codewords C v m = [ C v m 1 ,..., C and each codeword C v mk is a D -dimensional vector like the cluster centroid in kmeans clustering. Corresponding to the M codebooks, we partition the binary codewords assignment vector b v n of-K indicator vectors b v n = [ b v 1 n ; ... ; b v mn ] , and each indicator vector b v mn indicates which one (and only one) of the K codewords in the m th codebook is selected to approximate the n th data point. The CCQ model encodes each x v n as the sum of M codewords, one codeword per codebook, each indicated by the binary assignment vector b v n . This yields a novel and more accurate composite ap-proximation scheme x v n  X  R v P M m =1 C v m b v mn . Consistent with LSA and kmeans, the sum of squared loss between all x v n sum of selected codewords after transformed by R v , is minimized, where k X k 0 denotes the ` 0 -norm that simply counts the number of the vector X  X  nonzero elements. The constraint guarantees that only one codeword in each codebook can be activated to approximate the input data, hence it can lead to compact binary codes. As the binary constraints are directly imposed to the learning objective and are valid throughout the optimization procedure, the derived binary codes are much more accurate than sign thresholding binary codes. The rationale of using M codebooks instead of single codebook to approximate each input datum is to further minimize quantization error, as the latter is shown to yield significantly lossy compression and incur evident performance drop [30, 3]. Quantization based on multiple codebooks yields balanced composite binary codes which are more effective than Hamming embedding binary codes [12, 17].
The most desirable value of multimodal retrieval is to enable transfer of knowledge across different modalities so that cross-modal retrieval performance can be improved. A fundamental assumption for multimodal retrieval is that by mapping objects in a modality-consistent latent space, the latent space representations of semanti-cally relevant inter-modal pairs should be consistent. More specif-ically, for each input object with both image modality x 1 modality x 2 n , after being transformed by R 1 and R 2 in Equation (1), the latent space representations for image modality C 1 b modality C 2 b 2 n should be similar. To our knowledge, most prior work adopts the coupling strategy to minimize C 1 b 1 n  X  C In this paper, we propose to maximize cross-modal correlation by sharing codebooks { C m } M m =1 for different modalities and sharing binary codes { b n } N 0 n =1 for semantically relevant inter-modal pairs. While for the data points with only one modality, the multimodal sharing strategy does not apply. Hence, the proposed condition that the modality-consistent latent space should satisfy is formulated as where  X  (  X  ) distinguishes multimodal objects from unimodal ones. Different from most prior methods [20, 8], our modality-consistent condition requires identical code b 1 n = b 2 n , instead of minimized distance b 1 n  X  b 2 n , for the semantically relevant inter-modal pairs. There are two advantages of our approach. First, since our learning objective keeps the binary constraint valid throughout optimization procedure, it is very difficult to require minimized distance between two binary codes as their nonzero elements may differ significantly. Note that prior methods simply drop the binary condition and solve a continuous problem, which leads to uncontrollable quantization error with the post-step sign thresholding. Second, integrating the minimized distance condition in the learning objective as existing methods may introduce a trade-off term, or parameter, that is hard to tune since its magnitude is very different from learning loss (1).
To approach CCQ, which jointly learns a similarity-preserving composite quantization and a correlation-maximal latent space in a unified optimization framework, we jointly require the codebooks { C m } M m =1 subject to minimizing the quantization error of all modal-ities as Equation (1), and the mappings R v subject to maximizing the correlations between semantically relevant inter-modal pairs as Equation (2) while jointly minimizing the reconstruction error of input data as LSA. This leads to a joint optimization framework as where  X  v is the weight parameter for each modality, and in bimodal problems with V = 2 , we can simplify the notations by denoting  X  1 = 1 and  X  2 =  X  , while such notations are used throughout this paper. R v is the transformation matrix that maps the inputs of each modality to a D -dimensional modality-consistent latent space. The orthogonal constraints are motivated by LSA, which can turn latent factors R v into transformation matrices for efficient out-of-sample quantization. The binary codes b v n are M  X  K -dimensional, fortunately however, each b v mn is 1 -of-K encoding with only one nonzero element and can be represented using log 2 K bits, hence the final hash codes b v n can be compacted into H = M log which is independent on the dimensions of input or latent spaces. To fit each b v mn into one byte, K = 256 is a good choice [12, 30]. We simply set D = min( { P v } V v =1 ,H ) , in the sense that an H -bit binary code can reconstruct a D -dimensional vector accurately.
Formally, we derive correlation-maximal mappings f v ( x v R v T x v n and similarity-preserving quantizers q v ( f v ( x There are several advantages of the CCQ approach. First, CCQ jointly learns a correlation-maximal latent space and a similarity-preserving composite encoding, which can minimize the quantiza-tion loss and guarantee search quality. Second, CCQ explores both paired and unpaired data in a semi-paired quantization paradigm, which can benefit from semi-supervised learning in that paired data consolidate inter-modality correlation and unpaired data enhance intra-modality quantization. Third, CCQ is formulated with only two easy-tuning model parameters D and  X  , where D can be set as simply as LSA to retain most covariance information, and  X  can be selected by trading off different modalities using prior information. In particular, the proposed sharing of codebooks and binary codes across modalities (2) enables joint learning of latent semantics that are maximally correlated in the isomorphic feature space, which contributes most significantly to the efficacy of the CCQ approach.
Approximate nearest neighbor (ANN) search based on Euclidean distance is a powerful task for quantization techniques [12]. Given a database of CCQ hash codes { b v n } N v n =1 , we follow [12, 17] and use Asymmetric Quantizer Distance (AQD) as similarity metric that computes the distance between query q  X  v and database point x where  X  q  X  v = R  X  v T q  X  v is the transformed query. In the second row, the first term computes the inner products between  X  q  X  v words selected by b v n . Given a query, these inner products for all M codebooks { C m } M m =1 and all K possible values of b pre-computed and stored in a query-specific M  X  K lookup table, which is used to compute AQD between the query and all database points, each entails M table lookups and additions and is slightly more costly than Hamming distance. The second term computes the squared norm of decoded database point, which is independent on the query and can be encoded using one byte by quantizing these scale values on held-out dataset [3]. At quantization, we augment CCQ code with the norm byte, which costs one more lookup and one more byte per database point. We can eliminate this norm byte by composite quantization [30], but will leave it to our future work. The CCQ optimization problem (3) consists of three variables, R v , C , and B v . We adopt alternating optimization [12, 17, 3, 30] which iteratively updates one variable with the rest variables fixed. 4.1.1 Update R v We update R v by fixing C and B v as known variables, and write Equation (3) with R v as unknown variables in matrix formulation, This is equivalent to the Orthogonal Procrustes problem [19] and can be solved exactly using SVD. More specifically, we perform SVD as X v [ C  X  ( B v )] T = USV T , then we achieve R v We update C by fixing R v and B v as known variables, and write Equation (3) with C as unknown variables in matrix formulation, Algorithm 1: CCQ: Composite Correlation Quantization Input : Data { X v } V v =1 ; latent dimension D , modal weight  X  .
Output : Mappings { R v } , codebook C , binary codes { B
Initialize { R v } by identity, C randomly, { B v } by NN search. repeat 3 Update { R v } by Orthogonal Procrustes as Eqn. (5). 4 Update C by Quadratic Optimization as Eqn. (6). 5 for n  X  1 to N v do 6 Update { b v n } by ICM or greedy algorithm as Eqn. (7). 7 end until Convergence This is an unconstrained quadratic problem with analytic solution Algorithms such as L-BFGS can be used to speed up computation. 4.1.3 Update B v
It is obvious that each b v n is independent on { b v n 0 optimization problem for B v is decomposed to N v subproblems, This optimization problem is generally NP-hard. As shown in [30], this problem is essentially high-order Markov Random Field (MRF) problem and can be solved by the Iterated Conditional Modes (ICM) algorithm [4] which solves M indicators { b v mn } M m =1 Given { b v m 0 n } m 0 6 = m fixed, we update b v mn by exhaustively check-ing all the codeword in codebook C m , finding the codeword such that the objective in (7) is minimized, and setting the corresponding entry of b v mn as 1 and the rest as 0 . The algorithm is guaranteed to converge, and can be terminated if maximum iterations are reached. To accelerate quantization, we can explore hierarchical structure of codebooks { C m } and update { b v mn } by a new greedy algorithm. Specifically, after updating { b v m 0 n } m 0 &lt;m , we can update b C m . The overall learning procedure is summarized in Algorithm 1.
Batch algorithms are memory-inefficient for large-scale datasets, hence we formulate CCQ optimization into mini-batch algorithms for large-scale problems [24]. The main idea is to split the training set into mini-batches and load a fraction of data points into memory each time. Hence, the memory usage stays constant when the size of the training set increases. The update of B v in Equation (7) is already mini-batch in that update of each data point is independent on the other data points. To update R v in mini-batch, we notice that the matrix for SVD is X v [ C  X  ( B v )] T  X  R P v  X  D , which if given, the SVD can be solved in O ( P 2 v D ) , independent on the number of data points. We thus formulate the matrix for SVD in a point-wise summation form as P N v n =1 x v n [ C  X  ( b n )] T , then it can be computed by traversing all data points in a mini-batch paradigm. Similarly, the update of C can also be formulated in a summation form for mini-batch implementation. Note that we can allocate all available memory to mini-batch and trade off memory and disk reading costs.
We analyze the cost of each iteration to show CCQ scales linearly to sample size N v . To update R v , it takes O ( N v P v to prepare the problem and O P 2 v D + D 3 to compute the SVD. To update C , it takes O N v P v D + N v DM + N v M 2 to prepare the problem and O DM 2 K 2 + M 3 K 3 to compute the quadratic optimization. To update B v , it takes O ( N v P v D + N v where T i is the number of iterations and T i = 3 in ICM algorithm or T i = 1 in greedy algorithm can obtain satisfactory performance. As a rule of thumb, D = H and K = 256 are good choices for most applications. For longer codes, update of C is inefficient, in which case we can adopt the online L-BFGS algorithm for speedup.
Given a query q  X  v and a database point x v n , after transformed by correlation-maximal mappings  X  q  X  v = R  X  v T q  X  v and  X  x they can be comparable in the modality-consistent latent space, and their Euclidean distance is computed as d  X  q  X  v ,  X  x As computing Euclidean distance on real-valued vectors is too costly for large-scale search, we compute AQD (4) on binary codes. Hence, we need to analyze the error bound of using AQD to approximate real-valued distance. Denote  X  x v n = P M m =1 C m b v mn vector of x v n , then AQD q  X  v , x v n = d  X  q  X  v ,  X  x
T HEOREM 1 (B OUND ). The error is bounded by learning loss
P ROOF . From the triangle inequality, d  X  q  X  v ,  X  x d (  X  x v n ,  X  x v n ) . Then where R v  X  is an orthogonal complement of R v , R v T R v The theorem confirms that the error of using AQD to approximate real-valued distance is statistically bounded by CCQ learning loss. Hence, CCQ is more accurate than sign thresholding methods [25]. An important advantage of CCQ in Equation (9) is that mapping R v is learned by a joint optimization of canonical correlation anal-ysis (CCA) and principal component analysis (PCA) corresponding to the first and second terms of Line 2 in Equation (9). This can be much more effective than most CCA-based methods [13, 28, 26].
We conduct extensive evaluation of CCQ against state of the art methods on three public multimodal datasets. We investigate both effectiveness and efficiency in terms of search precision, recall, and time. The codes, data, and configurations will be available online. The evaluation is conducted on three datasets: NUS-WIDE [6], Wiki [18], and Flickr1M [11], with statistics depicted in Table 1. We preprocess all datasets by applying ZCA [24] to normalize each dimension of image/text features to be zero mean and unit variance.
NUS-WIDE 1 is a Web image dataset containing 269, 648 images downloaded from Flickr, each associated with 6 tags on average. There are 81 ground truth concepts manually annotated for search evaluation. Following prior works [34, 24], we prune the original NUS-WIDE to form a new dataset consisting of 195,834 image-text Complete Set 195,834 2,866 1,000,000 pairs by keeping the pairs that belong to one of the 21 most frequent concepts. The images are represented by 500-dimensional bag-of-words vectors extracted from the SIFT features using k-means, and the texts are represented by 1,000-dimensional vectors extracted from the tag occurrence features using PCA. A query set of 2,000 image-text pairs are randomly sampled from the dataset, while the remaining 193,834 image-text pairs are serving as the database. The hash models are learned on the training set containing 10,000 image-text pairs randomly sampled from the database [34, 20].
Wiki 2 contains 2,866 image-text pairs selected from Wikipedia X  X  featured articles comprised of multiple sections of images and texts. Every image-text pair is labeled by one of the 10 concepts in the article categories. Each image is represented by a 128-dimensional bag-of-words vector extracted from SIFT features, and each text is represented by the probability distribution over 10 topics learned by a latent Dirichlet allocation (LDA) model. The dataset is released with a query set of 693 pairs and a database of 2,173 pairs, and the whole database is used as the training set for hash coding [18, 34]. Flickr1M comprises 1,000,000 images associated with tags from Flickr, in which 25,000 are labeled with 38 concepts while the re-maining 975,000 are unlabeled. The public available preprocessed dataset 3 is employed for evaluation, in which each image is repre-sented by a 3,857-dimensional vector concatenated by local SIFT feature, global GIST feature, etc [21]. Each text is represented by a 2,000-dimensional vector extracted from tag occurrences. The query set contains 1,000 image-text pairs randomly sampled from the 25,000 labeled pairs, and the rest 24,000 labeled pairs are used as the database. In scalability test of CCQ (Section 5.7), all 975,000 unlabeled pairs are used as the training set for learning hash codes.
We compare CCQ against many state of the art hashing methods. (c) T  X  I @ 16 bits (g) T  X  I @ 16 bits
We perform four types of multimodal retrieval schemes: (1) I  X  I : use image queries to retrieve relevant images; (2) T  X  T : use text queries to retrieve relevant texts; (3) I  X  T : use image queries to retrieve relevant texts; and (4) T  X  I : use text queries to re-trieve relevant images. The first two tasks are intra-modal retrieval and the last two tasks are cross-modal retrieval. As CCQ can also handle multimodal search where both modalities are available for the database, we show the results of multimodal retrieval schemes where each image-text pair is quantized into a unified hash code by fusing knowledge of different modalities: (5) I  X  IT : use image queries to retrieve relevant image-text pairs; (6) T  X  IT : use text queries to retrieve relevant image-text pairs. The baseline methods do not support multimodal search because they do not use shared coding for different modalities of the same object. Given a query, the ground truth is defined as: if a result shares at least one common concept with the query, it is relevant; otherwise it is irrelevant.
We adopt Mean Average Precision (MAP) to measure the effec-tiveness of multimodal search [20, 34, 24, 27, 8]. Given a set of queries, we first calculate Average Precision (AP) of each query as where R is the number of retrieved documents, P ( r ) denotes the precision of the top r retrieved results, and  X  ( r ) = 1 if the r -th retrieved result is a true neighbor of the query, otherwise  X  ( r ) = 0 . Then MAP is computed as the mean of all the queries X  average pre-cision, and the larger the MAP, the better the retrieval performance. In the experiments, we follow [15, 27, 24] to report MAP@ R = 50 . We also report another two standard retrieval criteria, precision-recall curves and precision@top-R curves of all retrieval tasks. In addition to effectiveness, we report time and memory costs as the efficiency measures for query processing and model training.
The CCQ approach involves two model parameters: dimension of modality-consistent subspace D and modality trade-off weight  X  . In principle, CCQ is almost immune to different choices of D , as long as D is large enough to retain the majority amount of covari-ance information as LSA. While no prior knowledge is available, we can simply set equal weights  X  = 1 for different modalities, which can already achieve satisfactory performance. Nonetheless, for image-text bimodal search, the text modality usually carry more semantic information, hence we equip CCQ with the flexibility for selecting the optimal  X  to encode such important prior knowledge. Given annotation ground truths as in the evaluation datasets, we can automatically select D and  X  using cross-validation. However, we choose to blindly fix  X  = 5 throughout the comparative study. This is desirable as cross-validation may be impossible in the pervasive unsupervised multimodal search. We will study parameter sensitiv-ity in Section 5.8 to validate that CCQ can consistently outperform the state of the arts with a wide range of parameter configurations.
For the comparison methods, we adopt cross-validation to select their optimal parameters, respectively. As cross-validation requires annotation ground truths, this further confirms CCQ X  X  superior pa-rameter stability. Subject to computation burden, it is too costly to train CMSSH and IMH on the complete Flickr1M dataset, hence we randomly sample 10,000 image-text pairs to train these models. Each experiment repeats ten runs and the average result is reported.
We compare CCQ with state of the art methods in terms of MAP and precision-recall on 4 multimodal retrieval tasks ( I  X  I , T  X  T , I  X  T , T  X  I ) of three datasets (NUS-WIDE, Wiki, and Flickr1M).
We evaluate CCQ against state of the arts with different lengths of hash codes, i.e. 8, 16, 32, and 64 bits, and report the MAP results in Table 2. For all multimodal retrieval tasks, CCQ achieves signif-icantly better performance than all unsupervised hashing methods CVH, IMH, and CorrAE, and generally outperforms the state of the art supervised hashing methods CMSSH, SCM, QCH in most cases. It is very worth noting that, CCQ is an unsupervised hashing method that does not require labeled similarity information. Hence CCQ is particularly beneficial when labeled information is unavail-able, which is the most common scenario in big data era. A notable limitation of orthogonal constrained methods CVH and IMH is that longer codes do not necessarily improve performance in cross-modal tasks I  X  T and T  X  I . The reason is that these methods learn uncorrelated hash bits via eigenvalue decomposition on sim-ilarity matrix, which leads to unbalanced hash codes with the first k eigenvectors (hash bits) dominating the whole hash codes. CCQ via composite quantization in isomorphic space can learn balanced binary codes, hence its performance improves with longer codes.
It is interesting to observe that the performances of cross-modal search task I  X  T is generally better than that of intra-modal search task I  X  I , while this observation does not hold for the counter-parts T  X  I and T  X  T . This seems abnormal at first sight as cross-modal search tasks are often more challenging than intra-modal search tasks due to semantic gap [18]. However, in general, text retrieval is much easier than image retrieval, making different modalities of the objects contribute differently the cross-modal re-trieval performance. We believe that T  X  T is much easier than T  X  I , but I  X  T may be easier than I  X  I because image-to-image retrieval is often the most difficult task. In the case of cross-modal task I  X  T , the knowledge of text modality is transferred to image modality, making cross-modal retrieval easier. This shows cross-modal retrieval can be improved by knowledge transfer.
The precision-recall curves and the precision@top-R curves [34, 24] are illustrated in Figure 2. For space limitation, only the results of cross-modal tasks I  X  T and T  X  I are presented, while sim-ilar trends of results are observed on intra-modal tasks I  X  I and T  X  T . CCQ shows the best cross-modal retrieval performance on all recall levels and top-R ranks. This validates that CCQ is capable for diverse retrieval scenarios, which may emphasize higher preci-sion at smaller number of top-R retrieved results, i.e. Web search, or higher recall tolerating fairly lower precision, i.e. vertical search.
Table 2 also compares the search performance of CCQ and the state of the art methods on the Wiki dataset, which shows that CCQ significantly outperforms the unsupervised hashing methods CVH, IMH, and CorrAE, and performs comparably to supervised hashing methods SCM and QCH. A notable observation is that the MAPs are much smaller than those on the NUS-WIDE dataset. This is rea-sonable as the images of Wiki are of low-quality (low-resolution) and high-diversity, i.e. the text can well describe the semantics of the image-text pair while the image may not be well related to the semantics of the image-text pair, which makes it more challenging to capture the semantic correlations between image query and text database. Note that the texts of Wiki are featured articles which are well edited by experts and rich in semantic information, hence it is fairly easy to correlate a text query with the multimodal database.
The precision-recall curves and the precision@top-R curves [34, 24] are demonstrated in Figure 3. Again, CCQ is among the top-performing methods on all recall levels and all top-R ranks. A noticeable performance drop can be examined from the precision-recall curves to the precision@top-R curves. And this is because the Wiki dataset is very small-scale with only 2,173 database items, hence all relevant results will be retrieved at small R and no more relevant results can be further retrieved when R grows too large. This highlights the importance of evaluation with different metrics.
A crucial superiority of CCQ over the comparison methods lies in that CCQ jointly learns the isomorphic latent space and compact binary codes by minimizing both correlation and quantization er-rors in a unified optimization framework, while comparison meth-ods merely learn the isomorphic space and binary codes in a sepa-rated two-step pipeline. As examined by CorrAE [8], the quality of searching with binary codes using Hamming distance is evidently inferior to searching with continuous features using Euclidean dis-tance, due to substantial information loss by converting continuous features to binary codes without minimizing the quantization error. The search quality loss due to binarization is shown in Figure 5(a), and for CCQ, we use R v T x v n for continuous features and Cb (c) T  X  I @ 16 bits (g) T  X  I @ 16 bits (c) T  X  I @ 16 bits (g) T  X  I @ 16 bits binary codes. We see that IMH and CorrAE suffer from substantial MAP loss (similar trends are observed from other methods) while CCQ is almost lossless to binarization. In other words, by jointly minimizing the correlation error and quantization error, CCQ can circumvent information loss and learn more accurate binary codes.
In practical retrieval systems, it is crucial to process large-scale datasets in both training and testing phases, and thus we compare CCQ with state of the art methods on large-scale Flickr1M dataset. We report the MAP results in Table 2 and illustrate the detailed precision-recall curves and precision@top-R curves in Figure 4. As mentioned before, we randomly select 10,000 image-text pairs as training set to learn hash functions if it is computationally too de-manding to train these methods on the complete Flickr1M dataset. We can observe that CCQ significantly outperforms the compari-son methods on all retrieval tasks and performs better with longer codes. This validates the superiority of CCQ in processing large-scale datasets, as the experimental setting on Flickr1M is consistent with real-word system setting where a sufficiently accurate model needs to be derived on a sufficiently large training set. We will ex-amine CCQ X  X  ability to process real semi-paired data in the sequel.
Most of the existing methods, including the ones in comparison, require full correspondences between different modalities. In other words, the multimodal data objects are fully paired, e.g. image-text pairs. As a result, these methods are unable to tackle more realis-tic scenarios in which only a limited number of paired data points are available. CCQ explores the idea of semi-supervised learning and can leverage both paired data (all modalities of the objects are available) and unpaired data (partial modalities of the objects are available) to boost the search quality when paired data are limited. To verify this, we consider the NUS-WIDE and Flickr1M datasets and for each dataset, we randomly sample as the training set 1) 10,000 images without text modality, 2) 10,000 texts without im-age modality, and 3) different numbers, i.e. [0 . 5 , 1 , 2 , 4 , 8]  X  10 of image-text pairs. We train CCQ with these semi-paired data and evaluate the search performance in terms of MAP @ 32 bits.
The search performances of CCQ on NUS-WIDE and Flickr1M (c) I  X  T @ 32 bits are demonstrated in Figures 5(b) and 5(c) respectively, where solid lines indicate training with both paired and unpaired data, and dashed lines indicate training with only paired data. We can observe that when the number of paired data points is small, CCQ trained with both paired and unpaired data significantly outperforms CCQ trained with only paired data on most of the multimodal search tasks; when the number of paired data points increases, the search performance of CCQ will gradually saturate while the search quality of the two training paradigms will finally match. This clearly shows that CCQ can effectively leverage both paired and unpaired data (partial mul-timodal data) to boost search quality in a semi-paired data scenario.
An unexpected phenomenon is that semi-paired training slightly deteriorates search performance on task I  X  T . We conjecture the plausible reason is that searching text database with image queries significantly relies on maximizing the image-text correlations to bridge the semantic gap between low-level image features and high-level image semantics, i.e. its associated texts. When the number of paired data points is obviously smaller than the number of unpaired data points, semi-paired training may tend to weaken correlation learning from image-text pairs and incur performance degradation.
To search for approximate nearest neighbors (ANN) in database for a given query, all methods in comparison perform linear scan using symmetric or asymmetric distance. Specifically, to compare a query vector with a database vector, CVH, IMH, and CorrAE all compute symmetric Hamming distance via lookup tables, and CCQ constructs a distance lookup table for each query that stores the Euclidean distances between the query and the multiple codebooks. As a result, CVH, IMH, CorrAE, and CCQ compute exactly the same number of table lookups for linear scan, while their costs of computing the query-codebook distance lookup tables are slightly different, which can be negligible as they are infinitesimal w.r.t. the cost of linear scan. For example, the cost of computing the distance lookup table for CCQ takes only less than 1% of the cost for linear scan on Flickr1M. The average search time of each query by CVH, IMH, CorrAE, and CCQ on the Wiki, NUS-WIDE, Flickr25K, and Flickr1M datasets is illustrated in Figure 5(d), from which we can observe that the search efficiency are comparable for all methods. While it is beyond the scope of this paper, we want to note that one can adopt a Multi-Index [2] approach to achieve sub-linear search complexity on the binary codes and further boost search efficiency.
The training time and memory costs of CCQ scale linearly with the training sample size and hence can process large-scale dataset. To verify this, we follow [24] and use the complete Flickr1M dataset to evaluate the consumptions of training time and memory. CMSSH and IMH are not compared in this study since they require O ( N complexity and run out of either time or memory on this dataset. The comparison of training time costs is illustrated in Figure 6(a). We can observe that the training time of CCQ increases linearly with respect to the sample size. Due to multiple iterations between three sets of variables, i.e. transformation matrices R v codebook C , and modal-specific binary codes B v , CCQ is not as efficient as CVH. However, CCQ performs much more efficiently in time than CorrAE, which is a deep learning based method solv-ing a time-demanding non-convex nonlinear optimization problem. The training memory consumptions are compared in Figure 6(b). Both batch and mini-batch (large-scale) implementations of CCQ store the model parameters in memory, which are independent of training dataset size. For the batch implementation, all training data is loaded in memory, while for the mini-batch implementation, the training data is partitioned into multiple mini-batches while only one mini-batch is loaded in memory each time. Hence in the mini-batch (large-scale) implementation, the memory cost stays constant when training dataset size increases. We can flexibly allocate mem-ory to each mini-batch to trade off memory and disk reading costs.
Towards unsupervised multimodal retrieval, CCQ is designed to involve only two parameters, dimension of modality-isomorphic subspace D and modality trade-off weight  X  , and the performance is expected to be stable against parameter variations. Since we have fixed D = min( { P v } V v =1 ,H ) , we only inspect the sensitivity of  X  .
We compute MAP @ 32 bits on both cross-modal retrieval tasks by varying  X  between 0.1 and 200. The performance of CCQ w.r.t. parameter  X  is shown in Figure 6(c) and 6(d). We see that CCQ can consistently outperform all the unsupervised baseline methods by a large margin with  X  varying between 1 and 200 . This validates that CCQ is robust against parameter selection and is applicable to un-supervised multimodal retrieval with easily-configured parameters.
In this paper, we have formally approached seamless multimodal hashing through a novel composite correlation quantization (CCQ). It integrates multimodal correlation and composite quantization into a seamless latent semantic analysis (LSA) framework, which yields compact binary codes that encode both intra-modal similarity and inter-modal correlation. The sharing of codebooks and binary codes across modalities enables joint learning of latent semantics that are maximally correlated in the isomorphic feature space, which serves as the key contributor to the efficacy of the proposed CCQ method.
In the future, we plan to equip our model with a deep learning ar-chitecture which can learn highly abstract nonlinear representations to better distill the correlation structures across multiple modalities.
The authors would like to thank Dr Jingdong Wang for insightful comments. This work was supported by National Natural Science Foundation of China (61325008, 61502265), China Postdoctoral Science Foundation (2015T80088), National Science&amp;Technology Supporting Program (2015BAH14F02), NSF grant III-1526499, and Tsinghua TNList Lab Fund for Big Data Science and Technology. [1] A. Andoni and P. Indyk. Near-optimal hashing algorithms for [2] A. Babenko and V. Lempitsky. The inverted multi-index. In [3] A. Babenko and V. Lempitsky. Additive quantization for [4] J. Besag. On the statistical analysis of dirty pictures. Journal [5] M. Bronstein, A. Bronstein, F. Michel, and N. Paragios. Data [6] T.-S. Chua, J. Tang, R. Hong, H. Li, Z. Luo, and Y.-T. Zheng. [7] S. Deerwester, S. T. Dumais, G. W. Furnas, T. K. Landauer, [8] F. Feng, X. Wang, and R. Li. Cross-modal retrieval with [9] Y. Gong and S. Lazebnik. Iterative quantization: A [10] Y. Hu, Z. Jin, H. Ren, D. Cai, and X. He. Iterative multi-view [11] M. J. Huiskes and M. S. Lew. The mir flickr retrieval [12] H. Jegou, M. Douze, and C. Schmid. Product quantization for [13] S. Kumar and R. Udupa. Learning hash functions for [14] Z. Lin, G. Ding, M. Hu, and J. Wang. Semantics-preserving [15] X. Lu, F. Wu, S. Tang, Z. Zhang, X. He, and Y. Zhuang. A [16] L. Ma, Z. Lu, L. Shang, and H. Li. Multimodal convolutional [17] M. Norouzi and D. J. Fleet. Cartesian k-means. In CVPR . [18] J. C. Pereira, E. Coviello, G. Doyle, N. Rasiwasia, G. R. G. [19] P. H. Sch X nemann. A generalized solution of the orthogonal [20] J. Song, Y. Yang, Y. Yang, Z. Huang, and H. T. Shen. [21] N. Srivastava and R. Salakhutdinov. Multimodal learning [22] J. Wang, H. T. Shen, J. Song, and J. Ji. Hashing for similarity [23] Q. Wang, L. Si, and B. Shen. Learning to hash on partial [24] W. Wang, B. C. Ooi, X. Yang, D. Zhang, and Y. Zhuang. [25] Y. Weiss, A. Torralba, and R. Fergus. Spectral hashing. In [26] B. Wu, Q. Yang, W.-S. Zheng, Y. Wang, and J. Wang. [27] Z. Yu, F. Wu, Y. Yang, Q. Tian, J. Luo, and Y. Zhuang. [28] D. Zhang and W.-J. Li. Large-scale supervised multimodal [29] D. Zhang, F. Wang, and L. Si. Composite hashing with [30] T. Zhang, C. Du, and J. Wang. Composite quantization for [31] F. Zhao, Y. Huang, L. Wang, and T. Tan. Deep semantic [32] Y. Zhen and D.-Y. Yeung. Co-regularized hashing for [33] Y. Zhen and D.-Y. Yeung. A probabilistic model for [34] X. Zhu, Z. Huang, H. T. Shen, and X. Zhao. Linear
