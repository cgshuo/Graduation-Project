 Ontology has been widely adopted as the basis of knowledge sharing and knowledge-based public services. In this kind of knowledge-based systems, a rich and high-quality ontology model is the premise of satisfactory knowledge services. Therefore, ontology creation and maintenance. In fact, ontology construction itself is a big chal-broad audience[1]. is a complex, expensive and time-consuming process (e.g. [10]). In recent years, some methods and tools for collaborative ontology construction are also proposed which audience better. For these systems, it is essential to keep knowledge in consistency. ditional way, collaborative conflicts are usually handled by mechanisms of locking or branching/merging provided by version management systems (e.g. CVS). The con-ontology, the basic units are concepts and relationships between them, without ex-exist. The rich semantic relationships in ontology model exacerbate the situation, since different parts of the ontology model have much more complicated impacts on pose an approach to classify and detect th ree kinds of collaborative conflicts accord-evaluation.
 work. Section 3 addresses the overview of our framework. Section 4 proposes an approach to detect collaborative conflicts. Section 5 shows experiments with evalua-tion. The last section is our conclusion. KAON [5] focuses on that changes in ontology can cause inconsistencies, and pro-open, modular fashion. OntoEdit [7] supports the development and maintenance of execution of rules. OntoWiki [3] fosters so cial collaboration asp ects by keeping track of changes, allowing comment and discuss every single part of a knowledge base, users. OILEd [12] is a graphical ontology editor that allows the user to build ontolo-gies with FACT reasoner [2] to classify ontologies and check consistency. provides concurrent access control wi th transaction oriented locking, Noy [8] provides SCROL[11] provides a systematic method for automatically detecting and resolving various semantic conflicts in heterogeneous databases with a dynamic mechanism of comparing and manipulating contextual knowledge of each information source. Cupid presents a model considering structural, logical, and user-defined consistency. cy checking. But based on our humble knowledge, none of them distinguishes col-laborative conflicts from logical inconsistency. It is helpful to differentiate them from 3.3). Furthermore, concurrent access contro l with transaction or iented locking as database is not suitable for ontology, for the rich semantic relationships among ontol-ogy entities. Therefore, we need new approach to overcome these deficiencies. 3.1 System Framework select an ontology segment from server. All revisions the user performs will be trans-ferred into a Command-Package and stored until submission. In the public workspace, there are 5 main processes: 1) a command package pool stores all packages received conflicts will be handled by Conflicts Handler, in this paper we omit the detail of the process. 3) The 2 nd checking is consistency checking, which deals with logical incon-sistency, and all inconsistency will be handled by another handler which is also omit-ted in this paper. 4) After 2 proceeding checking, some mistakes still remain for they can not be found automatically. Therefore, experts X  review is necessary. 5) Lastly, all correct revisions will be executed to update ontology base. In this paper, we focus on collaborative conflicts detection. 3.2 Ontology Commands In our method, we provide a set of commands named Onto-Command for users to modify the ontology content, each of which is composed of an operation and some operands (ontology entity). Table 1 lists a part of atomic commands. parameter. Our system differentiates these commands into three kinds: and MOD is for modifying. 3.3 Collaborative Conflicts and Logical Inconsistency As mentioned in the last paragraph of section 2, some conflicts may not always result pected. For example, fig.2(a) shows an original ontology segment, which depicts the relation between Animal and Plant as well as their subclasses. If one participator adds Apple to be a subclass of Computer, as showed in fig.2(b). There is no inconsistency should be handled different from logical inconsistency. Definition 2(Collaborative Conflicts). We call two revisions performed by different participators on the same ontology entity conflict with each other, if one changes the semantic of the entity, while the other still uses its original semantic. Definition 3 ( Logical Inconsistency ) . We call a revision on ontology O, is inconsist-ent with a set of consistency conditions K, iff K k  X   X  such that O X  does not satisfies the consistency condition k(O X ), where O X  is the result from O by the revision. breaks the logical condition  X  Animal owl:differentFrom Plant  X . Command Impact Range, and base on it we classify 3 kinds of collaborative conflicts, and finally propose two algorithms with comparison between them. 4.1 Command Impact Range Because subtle semantic relationship exists among entities in ontology, change one entity may produce chain reaction. This means that for each revision, there is a set of entities may be impacted. Therefore, for each atomic Onto-Command we define a unique IR(Impact Range) value, table 2 lists some of them. lete class  X  Carnivore X  . According to table 2, IR( oc ) ={ Carnivore, prey , Tiger }. 4.2 Three Kinds of Collaborative Conflicts In our method, according different criterions, we classify three kinds of collaborative conflicts, i.e. hard soft and latent conflicts. They are following. 4.2.1 Hard Conflicts possible for two commands conflict with each other. OTC (OC Type Conflicts Table) is a function table returns whether it is possible for two commands (oc and oc X ) conflict with each other. As table 3 lists, F/T is false/true, which means that it is impossible/possible for oc directly conflicts with oc X . tity with same value, we will unite two operations as one. Therefore, there is no con-OTC(DEL,DEL)=F and OTC(ADD,ADD)=F . OTC_MOD (MOD OC Conflicts Table) is a function table returns whether it is possible for two MOD commands (i.e. OCKind( oc ) = MOD ) directly conflict with each other. Table 4 lists a part of them. 
For example, if one participator use command AddEquivalentClass oc1 to make class1 and class2 equivalent, while the other use command AddDifferentClass oc2 to make class1 and class2 different, then OTC_MOD(oc1,oc2)=T . Definition 4 (Hard Conflicts  X  X  X ). Given 2 commands oc and oc X  performed by different users, oc@oc X  if OTC ( oc,oc X  )  X  (IR(oc) IR(oc ')) NULL  X  I . For example, look back on fig.2(b), if user U1 performs a DelCalss command oc for delete class Carnivore , and user U2 performs AddSubClass command oc X  to add a and OTC(oc,oc X ) holds, then oc@oc X , that means oc conflicts with oc X  directly. 4.2.2 Soft Conflicts inconsistency if both were accepted. Therefore, we define Semantic-Rule-Set which includes with e2 , where e1 and e2 originate from e by executing oc and oc X  respectively .
For example, Functional Same VS Different is one semantic rule, whose principle where, Definition 6 (Soft Conflicts  X # X ). Given 2 commands oc and oc X  performed by differ-ent users, oc # oc X  if  X  OTC(oc,oc X )  X  ( , e , SEM  X   X  s.t. SEM(e,oc,oc X )=0), where,  X  X  X  I Semantic-Rule-Set . 
For example, fig. 4 (a) shows another ontology segment. If participator U1 adds a functional object property Favorite from Cat to Rat and Mouse by command oc , ac-puterEquipment that is different from Animal by command oc X  . We can infer that it is oc # oc X  . Fig.4 (b) and (c) show the result. 4.2.3 Latent Conflicts flicts are not so easy to judge. Look back on the first example in section 3.3, suppose unacceptable case. In this case, it is not easy to judge whether the changes on concept and differentiate them into two types. Table 6 lists a part of them. Two Types of Heuristic Similarity Measures:
For example, Depth Distance is one structural measure that calculates similarity deeper the two entities locate in one hierarchy, the higher the similarity is. Therefore, where, LCA(e1,e2) gets the nearest ancestor of e1 and e2. Similarity Aggregation: for all measures, OntoSIM is given: where, where, N is the number of semantical matchers. M is the number of structural match-ers. i w is the weight of each individual structural measure. Definition 7 (Latent Conflicts X !! X ): Given 2 commands oc and oc X  performed by diff- X  , where e1 and e2 originate from e by executing oc and oc X  respectively . 4.3 Checking Algorithm CCD. We will give their performance comparison with experiments in section 5.3. 4.3.1 Simple Algorithm Algorithm 1 lists the simple algorithm. It scans command-pool by 2 loops and gets all possible command pairs. For each pair, we do three kinds of conflicts checking, and each detected conflict will be added to appropriate conflicts set. Complexity Analysis. Because 1) in line 0, it scans pool by two loops which makes Semantic-Rules-Set and the number of heuristic similarity measures in OntoSIM are 4.3.2 High Effective Collaborative Conflicts Detection Algorithm (CCD ) In order to detect conflicts effectively, we define a structure STRU_CON_SET (see includes e . All instances are stored and sorted by e in Sorted-List v. Theorem 1: IRSet scs ' oc , oc .  X   X  , oc@oc X  if OTC (oc,oc X ) holds. and e2 are produced from e by executing oc and oc X  respectively . Algorithm 2 presents a high effective checking algorithm named CCD . It scans Command-Pool only once, for each command c in the pool, we compare it with can-remainder is similar with Algorithm 1. Complexity Analysis. As stated in Algorithm 2, in line 1 it scans the pool by a loop, whose complexity is O(n). In line 3 the binary retrieval X  X  complexity is O(Log 2 (n)). the extra spending of v whose space complexity is O(n). We developed our system by Java1.5 and MySql. Client runs on web, and the server was conducted on Intel Centrino Duo T2400 1.83GHz PC with 2GB RAM, running FAO (Food and Agriculture Organization). 5.1 Experiment 1 the detected result P returned by CCD , and determine the true positives, I, as well as 5.1.1 Hard and Soft Conflicts Detection Result (a) and (b) show the result. Analysis. From fig.7 we can infer, 1) the algorithm is good enough for detecting soft With number increasing, the precision/recall of hard conflicts converge 95%/94%, and we consider the constant is the real data we need. 5.1.2 Latent Conflicts Detection Result and then add a number, finally we add enough. Fig. 8 (a) and (b) show the result. analysis is not enough, 2) with more and more conflicts coming, the results converge to a constant, and we consider the constant is the real data we need, too. 3)  X  Enough Matchers  X  produces higher precision and recall than  X  Few Matcher  X  and  X  A Number of Matchers  X . Therefore, we can say that heuristic matchers play an important role in the collaborative conflicts detecting process. 5.2 Experiment 2 In this experiment, we adopt  X  X nough Matchers X  in OntoSIM with threshold 0.65, and make a running time comparison between Simple and CCD algorithm. Table 8 and fig.9 present the performance comparison. Analysis. 1) It clearly shows that with commands increasing, the running time of CCD increases flatly, while the performance of optimized simple algorithm is far worse than CCD. 2) According to the analysis in section 4.3.1 and 4.3.2, the running time of Simple algorithm should be ( N/ Log 2 (N) ) times of the time of CCD. From the Ontology construction itself is a big challeng e, especially in large-scale collaboration-based ontology development, because, 1) in ontology, the basic units are concepts and relationships between them, without explicit file-based artifact, which makes conflicts their co-workers at all, let alone have enough sufficient communications. Therefore, it is obvious that effective conflicts detection and resolution are essential for large-scale collaborative ontology development. our ontology construction system. The main contributions are: 1) differentiate col-tive conflicts, i.e. hard conflicts soft conflicts and latent conflicts. 3) Propose a formal method to detect collaborative conflicts with an effective algorithm and evaluation. Acknowledgements. This work is supported by the National High Technology Development 863 Program of China under Grant No. 2007AA01Z179. 
