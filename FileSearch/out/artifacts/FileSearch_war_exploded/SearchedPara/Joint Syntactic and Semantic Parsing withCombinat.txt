 Integrating syntactic parsing with semantics has long been a goal of natural language processing and is expected to improve both syntactic and se-mantic processing. For example, semantics could help predict the differing prepositional phrase at-tachments in  X  X  caught the butterfly with the net X  and  X  X  caught the butterfly with the spots. X  A joint analysis could also avoid propagating syntactic parsing errors into semantic processing, thereby improving performance.

We suggest that a large populated knowledge base should play a key role in syntactic and se-mantic parsing: in training the parser, in resolv-ing syntactic ambiguities when the trained parser is applied to new text, and in its output semantic representation. Using semantic information from the knowledge base at training and test time will ideally improve the parser X  X  ability to solve diffi-cult syntactic parsing problems, as in the exam-ples above. A semantic representation tied to a knowledge base allows for powerful inference op-erations  X  such as identifying the possible entity referents of a noun phrase  X  that cannot be per-formed with shallower representations (e.g., frame semantics (Baker et al., 1998) or a direct conver-sion of syntax to logic (Bos, 2005)).

This paper presents an approach to training a joint syntactic and semantic parser using a large background knowledge base. Our parser produces a full syntactic parse of every sentence, and fur-thermore produces logical forms for portions of the sentence that have a semantic representation within the parser X  X  predicate vocabulary. For ex-ample, given a phrase like  X  X y favorite town in California, X  our parser will assign a logical form to the  X  X own in California X  portion. Additionally, the parser uses predicate and entity type informa-tion during parsing to select a syntactic parse.
Our parser is trained by combining a syntactic parsing task with a distantly-supervised relation extraction task. Syntactic information is provided by CCGbank, a conversion of the Penn Treebank into the CCG formalism (Hockenmaier and Steed-man, 2002a). Semantics are learned by training the parser to extract knowledge base relation in-stances from a corpus of unlabeled sentences, in a distantly-supervised training regime. This ap-proach uses the knowledge base to avoid expen-sive manual labeling of individual sentence se-mantics. By optimizing the parser to perform both tasks simultaneously, we train a parser that pro-duces accurate syntactic and semantic analyses.
We demonstrate our approach by training a joint syntactic and semantic parser, which we call A SP . A
SP produces a full syntactic analysis of every sentence while simultaneously producing logical forms containing any of 61 category and 69 re-lation predicates from NELL. Experiments with A
SP demonstrate that jointly analyzing syntax and semantics improves semantic parsing perfor-mance over comparable prior work and a pipelined syntax-then-semantics approach. A SP  X  X  syntactic parsing performance is within 2.5% of state-of-the-art; however, we also find that incorporating semantic information reduces syntactic parsing ac-curacy by  X  0 . 5% . This paper combines two lines of prior work: broad coverage syntactic parsing with CCG and semantic parsing.

Broad coverage syntactic parsing with CCG has produced both resources and successful parsers. These parsers are trained and evaluated using CCGbank (Hockenmaier and Steedman, 2002a), an automatic conversion of the Penn Treebank into the CCG formalism. Several broad cover-age parsers have been trained using this resource (Hockenmaier and Steedman, 2002b; Hocken-maier, 2003b). The parsing model in this paper is loosely based on C&amp;C (Clark and Curran, 2007b; Clark and Curran, 2007a), a discriminative log-linear model for statistical parsing. Some work has also attempted to automatically derive logi-cal meaning representations directly from syntac-tic CCG parses (Bos, 2005; Lewis and Steedman, 2013). However, these approaches to semantics do not ground the text to beliefs in a knowledge base.
Meanwhile, work on semantic parsing has fo-cused on producing semantic parsers for answer-ing simple natural language questions (Zelle and Mooney, 1996; Ge and Mooney, 2005; Wong and Mooney, 2006; Wong and Mooney, 2007; Lu et al., 2008; Kate and Mooney, 2006; Zettlemoyer and Collins, 2005; Kwiatkowski et al., 2011). This line of work has typically used a corpus of sen-tences with annotated logical forms to train the parser. Recent work has relaxed the requisite su-pervision conditions (Clarke et al., 2010; Liang et al., 2011), but has still focused on simple ques-tions. Finally, some work has looked at applying semantic parsing to answer queries against large knowledge bases, such as YAGO (Yahya et al., 2012) and Freebase (Cai and Yates, 2013b; Cai and Yates, 2013a; Kwiatkowski et al., 2013; Be-rant et al., 2013). Although this work considers a larger number (thousands) of predicates than we do, none of these systems are capable of parsing open-domain text. Our approach is most closely related to the distantly-supervised approach of Kr-ishnamurthy and Mitchell (2012).

The parser presented in this paper can be viewed as a combination of both a broad coverage syn-tactic parser and a semantic parser trained using distant supervision. Combining these two lines of work has synergistic effects  X  for example, our parser is capable of semantically analyzing con-junctions and relative clauses based on the syn-tactic annotation of these categories in CCGbank. This synergy gives our parser a richer semantic representation than previous work, while simulta-neously enabling broad coverage. This section describes the Combinatory Categorial Grammar (CCG) parsing model used by A SP . The input to the parser is a part-of-speech tagged sen-tence, and the output is a syntactic CCG parse tree, along with zero or more logical forms representing the semantics of subspans of the sentence. These logical forms are constructed using category and relation predicates from a broad coverage knowl-edge base. The parser also outputs a collection of dependency structures summarizing the sentence X  X  predicate-argument structure. Figure 1 illustrates A
SP  X  X  input/output specification. 3.1 Knowledge Base The parser uses category and relation predicates from a broad coverage knowledge base both to construct logical forms and to parametrize the parsing model. The knowledge base is assumed to have two kinds of ontological structure: a gen-eralization/subsumption hierarchy and argument type constraints. This paper uses NELL X  X  ontology (Carlson et al., 2010), which, for example, speci-fies that the category ORGANIZATION is a general-ization of SPORTSTEAM , and that both arguments to the LOCATED I N relation must have type LOCA -TION . These type constraints are enforced during parsing. Throughout this paper, predicate names are shown in SMALLCAPS . 3.2 Syntax A
SP uses a lexicalized and semantically-typed Combinatory Categorial Grammar (CCG) (Steedman, 1996). Most gram-matical information in CCG is encoded in a lexicon  X  , containing entries such as:
Each lexicon entry maps a word to a syntactic category, semantic type, and logical form. CCG has two kinds of syntactic categories: atomic and functional. Atomic categories include N for noun and S for sentence. Functional categories are functions constructed recursively from atomic cat-egories; these categories are denoted using slashes to separate the category X  X  argument type from its return type. The argument type appears on the right side of the slash, and the return type on the left. The direction of slash determines where the argument must appear  X  / means an argument on the right, and \ means an argument on the left.
Syntactic categories in A SP are annotated with two additional kinds of information. First, atomic categories may have associated syntactic features given in square brackets. These features are used in CCGbank to distinguish variants of atomic syn-tactic categories, e.g., S [ dcl ] denotes a declara-tive sentence. Second, each category is anno-tated with head and dependency information us-ing subscripts. These subscripts are used to pop-ulate predicate-argument dependencies (described below), and to pass head information using unifi-cation. For example, the head of the parse in Fig-ure 1 is  X  X rea, X  due to the coindexing of the argu-ment and return categories in the category N 1 \ N 1 .
In addition to the syntactic category, each lexi-con entry has a semantic type and a logical form. The semantic type is a category or relation pred-icate that concisely represents the word X  X  seman-tics. The semantic type is used to enforce type constraints during parsing and to include seman-tics in the parser X  X  parametrization. The logi-cal form gives the full semantics of the word in lambda calculus. The parser also allows lexicon entries with the semantic type  X  X  X , representing words whose semantics cannot be expressed using predicates from the ontology.

Parsing in CCG combines adjacent categories using a small number of combinators, such as function application:
The first rule states that the category X/Y can be applied to the category Y , returning category X , and that the logical form f is applied to g to produce the logical form for the returned category. Head words and semantic types are also propa-gated to the returned category based on the anno-tated head-passing markup. 3.3 Dependency Structures Parsing a sentence produces a collection of depen-dency structures which summarize the predicate-argument structure of the sentence. Dependency structures are 10-tuples, of the form:
A dependency structure captures a relationship between a head word and its argument. During parsing, whenever a subscripted argument of a syntactic category is filled, a dependency structure is created between the head of the applied func-tion and its argument. For example, in Figure 1, the first application fills argument 1 of  X  X eautiful X  with  X  X ondon, X  creating a dependency structure. 3.4 Logical Forms A
SP performs a best-effort semantic analysis of every parsed sentence, producing logical forms for subspans of the sentence when possible. Logical forms are designed so that the meaning of a sen-tence is a universally-and existentially-quantified conjunction of predicates with partially shared ar-guments. This representation allows the parser to produce semantic analyses for a reasonable subset of language, including prepositions, verbs, nouns, relative clauses, and conjunctions.

Figure 1 shows a representative sample of a log-ical form produced by A SP . Generally, the parser produces a lambda calculus statement with sev-eral existentially-quantified variables ranging over entities in the knowledge base. The only excep-tion to this rule is conjunctions, which are rep-resented using a scoped universal quantifier over the conjoined predicates. Entity mentions appear in logical forms via a special mention predicate, , instead of as database constants. For exam-ple,  X  X ondon X  appears as M ( x,  X  X ondon X  , CITY ) , instead of as a constant like L ONDON . The mean-ing of this mention predicate is that x is an en-tity which can be called  X  X ondon X  and belongs to the CITY category. This representation propagates uncertainty about entity references into the logical form where background knowledge can be used for disambiguation. For example,  X  X ondon, Eng-land X  is assigned a logical form that disambiguates
Lexicon entries without a semantic type are au-tomatically assigned logical forms based on their head passing markup. For example, in Figure 1, the adjective  X  X eautiful X  is assigned  X f.f . This approach allows a logical form to be derived for most sentences, but (somewhat counterintuitively) can lose interesting logical forms from constituent subspans. For example, the preposition  X  X n X  has syntactic category ( N 1 \ N 1 ) /N 2 , which results in the logical form  X f. X g.g . This logical form dis-cards any information present in the argument f . We avoid this problem by extracting a logical form from every subtree of the CCG parse. 3.5 Parametrization The parser  X  is trained as a discriminative linear model of the following form:
Given a parameter vector  X  and a sentence s , the parser produces a score for a syntactic parse tree t , a collection of dependency structures d and a logical form ` . The score depends on features of the parse produced by the feature function  X  .  X  contains four classes of features: lexicon features, combinator features, dependency fea-tures and dependency distance features (Table 1). These features are based on those of C&amp;C (Clark and Curran, 2007b), modified to include seman-tic types. The features are designed to share syn-tactic information about a word across its distinct semantic realizations in order to transfer syntactic information from CCGbank to semantic parsing.
The parser also includes a hard type-checking constraint to ensure that logical forms are well-typed. This constraint states that dependency structures with a head semantic type only accept arguments that (1) have a semantic type, and (2) are within the domain/range of the head type. This section describes the training procedure for A
SP . Training is performed by minimizing a joint objective function combining a syntactic parsing task and a distantly-supervised relation extraction task. The input training data includes: 1. A collection L of sentences s i with annotated 2. A corpus of sentences S (e.g., Wikipedia). 3. A knowledge base K (e.g., NELL), contain-4. A CCG lexicon  X  (see Section 5.2).

Given these resources, the algorithm described in this section produces parameters  X  for a se-mantic parser. Our parameter estimation proce-dure constructs a joint objective function O (  X  ) that decomposes into syntactic and semantic compo-nents: O (  X  ) = O syn (  X  ) + O sem (  X  ) . The syntac-tic component O syn is a standard syntactic pars-ing objective constructed using the syntactic re-source L . The semantic component O sem is a distantly-supervised relation extraction task based on the semantic constraint from Krishnamurthy and Mitchell (2012). These components are de-scribed in more detail in the following sections. applied, or dependency structures are instantiated. 4.1 Syntactic Objective The syntactic objective is the structured percep-tron objective instantiated for a syntactic parsing task. This objective encourages the parser to accu-rately reproduce the syntactic parses in the anno-tated corpus L = { ( s i ,t i ) } n i =1 :
O syn (  X  ) =
The first term in the above expression represents the best CCG parse of the sentence s i according to the current model. The second term is the best parse of s i whose syntactic tree equals the true syntactic tree t i . In the above equation | X | + de-notes the positive part of the expression. Minimiz-ing this objective therefore finds parameters  X  that reproduce the annotated syntactic trees. 4.2 Semantic Objective The semantic objective corresponds to a distantly-supervised relation extraction task that constrains the logical forms produced by the semantic parser. Distant supervision is provided by the following constraint: every relation instance r ( e 1 ,e 2 )  X  K must be expressed by at least one sentence in S ( e 1 ,e 2 ) , the set of sentences that mention both e 1 and e 2 (Hoffmann et al., 2011). If this constraint is empirically true and sufficiently constrains the parser X  X  logical forms, then optimizing the seman-tic objective produces an accurate semantic parser.
A training example in the semantic objective consists of the set of sentences mentioning a pair of entities, S ( e binary vector representing the set of relations that the two entities participate in, y ( e supervision constraint  X  forces the logical forms predicted for the sentences to entail the relations checks whether each logical form entails the re-lation instance r ( e 1 ,e 2 ) , deterministically setting y r = 1 if any logical form entails the instance and y r = 0 otherwise.

Let ( ` , d , t ) represent a collection of seman-tic parses for the sentences S = S ( e  X ( ` , d , t | S ;  X  ) = the total weight assigned by the parser to a collec-tion of parses for the sentences S . For the pair of entities ( e 1 ,e 2 ) , the semantic objective is: 4.3 Optimization Training minimizes the joint objective using the structured perceptron algorithm, which can be viewed as the stochastic subgradient method (Ratliff et al., 2006) applied to the objective O (  X  ) . We initialize the parameters to zero, i.e.,  X  0 = 0 . On each iteration, we sample either a syntactic example ( s i ,t i ) or a semantic example ( S pled, we apply the following parameter update:
This update moves the parameters toward the fea-tures of the best parse with the correct syntactic derivation,  X  ( d  X  ,t i ,s i ) . If a semantic example is sampled, we instead apply the following update:
This update moves the parameters toward the fea-tures of the best set of parses that satisfy the distant supervision constraint. Training outputs the aver-age of each iteration X  X  parameters,  X   X  = 1 In practice, we train the parser by performing a single pass over the examples in the data set.
All of the maximizations above can be per-formed exactly using a CKY-style chart parsing algorithm, except for the last one. This maxi-mization is intractable due to the coupling between logical forms in ` caused by enforcing the dis-tant supervision constraint. We approximate this maximization in two steps. First, we perform a beam search to produce a list of candidate parses for each sentence s  X  S ( e relation instances from each parse and apply the greedy inference algorithm from Hoffmann et al., (2011) to identify the best set of parses that satisfy the distant supervision constraint. The procedure skips any examples with sentences that cannot be parsed (due to beam search failures) or where the distant supervision constraint cannot be satisfied. The experiments below evaluate A SP  X  X  syntactic and semantic parsing ability. The parser is trained on CCGbank and a corpus of Wikipedia sentences, using NELL X  X  predicate vocabulary. The syntactic analyses of the trained parser are evaluated against CCGbank, and its logical forms are evaluated on an information extraction task and against an an-notated test set of Wikipedia sentences. 5.1 Data Sets The data sets for the evaluation consist of CCG-bank, a corpus of dependency-parsed Wikipedia sentences, and a logical knowledge base derived from NELL and Freebase. Sections 02-21 of CCGbank were used for training, Section 00 for validation, and Section 23 for the final results. The knowledge base X  X  predicate vocabulary is taken from NELL, and its instances are taken from Free-base using a manually-constructed mapping be-tween Freebase and NELL. Using Freebase rela-tion instances produces cleaner training data than NELL X  X  automatically-extracted instances.

Using the relation instances and Wikipedia sen-tences, we constructed a data set for distantly-supervised relation extraction. We identified men-tions of entities in each sentence using simple string matching, then aggregated these sentences by entity pair. 20% of the entity pairs were set aside for validation. In the remaining training data, we downsampled entity pairs that did not participate in at least one relation. We further eliminated sentences containing more than 30 to-kens. The resulting training corpus contains 25k entity pairs (half of which participate in a relation), 41k sentences, and 71 distinct relation predicates. 5.2 Grammar Construction The grammar for A SP contains the annotated lex-icon entries and grammar rules in Sections 02-21 of CCGbank, and additional semantic entries pro-duced using a set of dependency parse heuristics.
The lexicon  X  contains all words that occur at least 20 times in CCGbank. Rare words are re-placed by their part of speech. The head pass-ing and dependency markup was generated using the rules of the C&amp;C parser (Clark and Curran, 2007b). These lexicon entries are also annotated with logical forms capturing their head passing re-lationship. For example, the adjective category N 1 /N 1 is annotated with the logical form  X f.f . These entries are all assigned semantic type  X .
We augment this lexicon with additional entries logical form is extracted from the underlined sentence portion. 0 . 2 0 . 4 0 . 6 0 . 8 1 . 0 Figure 3: Logical form precision as a function of the expected number of correct extracted logical forms. A SP extracts more correct logical forms because it jointly analyzes syntax and semantics. mapping words to logical forms with NELL pred-icates. These entries are instantiated using a set of dependency parse patterns, listed in an online ing corpus, heuristically identifying verbs, prepo-sitions, and possessives that express relations, and nouns that express categories. The patterns also include special cases for forms of  X  X o be. X  This process generates  X  4000 entries (not counting en-tity names), representing 69 relations and 61 cate-gories from NELL. Section 3.2 shows several lex-icon entries generated by this process.

The parser X  X  combinators include function ap-plication, composition, and crossed composition, as well as several binary and unary type-changing rules that occur in CCGbank. All combinators were restricted to only apply to categories that combine in Sections 02-21. Finally, the grammar includes a number of heuristically-instantiated bi-nary rules of the form , N  X  N \ N that instanti-ate a relation between adjacent nouns. These rules capture appositives and some other constructions. 5.3 Supertagging Parsing in practice can be slow because the parser X  X  lexicalized grammar permits a large num-ber of parses for a sentence. We improve parser performance by performing supertagging (Banga-lore and Joshi, 1999; Clark and Curran, 2004). We trained a logistic regression classifier to pre-dict the syntactic category of each token in a sen-tence from features of the surrounding tokens and POS tags. Subsequent parsing is restricted to only consider categories whose probability is within a factor of  X  of the highest-scoring category. The parser uses a backoff strategy, first attempting to parse with the supertags from  X  = 0 . 01 , backing off to  X  = 0 . 001 if the initial parsing attempt fails. 5.4 Syntactic Evaluation The syntactic evaluation measures A SP  X  X  ability to reproduce the predicate-argument dependencies in CCGbank. As in previous work, our evalu-ation uses labeled and unlabeled dependencies. Labeled dependencies are dependency structures with both words and semantic types removed, leaving two word indexes, a syntactic category, and an argument number. Unlabeled dependen-cies further eliminate the syntactic category and argument number, leaving a pair of word indexes. Performance is measured using precision, recall, and F-measure against the annotated dependency structures in CCGbank. Precision is the fraction of predicted dependencies which are in CCGbank, recall is the fraction of CCGbank dependencies produced by the parser, and F-measure is the har-monic mean of precision and recall.

For comparison, we also trained a syntactic ver-sion of our parser, A SP -SYN , using only the CCG-bank lexicon and grammar. Comparing against this parser lets us measure the effect of the rela-tion extraction task on syntactic parsing.
 Table 2 shows the results of our evaluation. For comparison, we include results for two ex-isting syntactic CCG parsers: C&amp;C, the current state-of-the-art CCG parser (Clark and Curran, 2007b), and the next best system (Hockenmaier, 2003a). Both A SP and A SP -SYN perform rea-sonably well, within 2.5% of the performance of C&amp;C at the same coverage level. However, A SP -Table 3: Logical form accuracy and extraction pre-cision/recall on the annotated test set. The high extraction recall for A SP shows that it produces more complete logical forms than either baseline. SYN outperforms A SP by around 0.5%, suggesting that A SP  X  X  additional semantic knowledge slightly hurts syntactic parsing performance. This perfor-mance loss appears to be largely due to poor en-tity mention detection, as we found that not us-ing entity mention lexicon entries at test time im-proves A SP  X  X  labeled and unlabeled F-scores by 0.3% on Section 00. The knowledge base contains many infrequently-mentioned entities with com-mon names; these entities contribute incorrect se-mantic type information that confuses the parser. 5.5 Semantic Evaluation We performed two semantic evaluations to bet-ter understand A SP  X  X  ability to construct logical forms. The first evaluation emphasizes precision over recall, and the second evaluation accurately measures recall using a manually labeled test set. 5.5.1 Baselines For comparison, we also trained two base-line models. The first baseline, P IPELINE , is a pipelined syntax-then-semantics approach de-signed to mimic Boxer (Bos, 2005). This base-line first syntactically parses each sentence using A
SP -SYN , then produces a semantic analysis by assigning a logical form to each word. We train this baseline using the semantic objective (Section 4.2) while holding fixed the syntactic parse of each sentence. Note that, unlike Boxer, this baseline learns which logical form to assign each word, and its logical forms contain NELL predicates.

The second baseline, K&amp;M-2012, is the ap-proach of Krishnamurthy and Mitchell (2012), representing the state-of-the-art in distantly-supervised semantic parsing. This approach trains a semantic parser by combining distant seman-tic supervision with syntactic supervision from dependency parses. The best performing vari-ant of this system also uses dependency parses at test time to constrain the interpretation of test sentences  X  hence, this system also uses a pipelined syntax-then-semantics approach. To im-prove comparability, we reimplemented this ap-proach using our parsing model, which has richer features than were used in their paper. 5.5.2 Information Extraction Evaluation The information extraction evaluation uses each system to extract logical forms from a large cor-pus of sentences, then measures the fraction of extracted logical forms that are correct. The test set consists of 8.5k sentences sampled from the held-out Wikipedia sentences. Each system was run on this data set, extracting all logical forms from each sentence that entailed at least one cat-egory or relation instance. We ranked these ex-tractions using the parser X  X  inside chart score, then manually annotated a sample of 250 logical forms from each system for correctness. Logical forms were marked correct if all category and relation instances entailed by the logical form were ex-pressed by the sentence. Note that a correct logical form need not entail all of the relations expressed by the sentence, reflecting an emphasis on preci-sion over recall. Figure 2 shows some example logical forms produced by A SP in the evaluation.
The annotated sample of logical forms allows us to estimate precision for each system as a func-tion of the number of correct extractions (Figure 3). The number of correct extractions is directly proportional to recall, and was estimated from the total number of extractions and precision at each rank in the sample. All three systems initially have high precision, implying that their extracted logical forms express facts found in the sentence. However, A SP produces 3 times more correct log-ical forms than either baseline because it jointly analyzes syntax and semantics. The baselines suf-fer from reduced recall because they depend on re-ceiving an accurate syntactic parse as input; syn-tactic parsing errors cause these systems to fail.
Examining the incorrect logical forms produced by A SP reveals that incorrect mention detection is by far the most common source of mistakes. Ap-proximately 50% of errors are caused by marking common nouns as entity mentions (e.g., marking  X  X oin X  as a COMPANY ). These errors occur be-cause the knowledge base contains many infre-quently mentioned entities with relatively com-mon names. Another 30% of errors are caused by assigning an incorrect type to a common proper noun (e.g, marking  X  X olivia X  as a CITY ). This analysis suggests that performing entity linking before parsing could significantly reduce errors. 5.5.3 Annotated Sentence Evaluation A limitation of the previous evaluation is that it does not measure the completeness of predicted logical forms, nor estimate what portion of sen-tences are left unanalyzed. We conducted a second evaluation to measure these quantities.

The data for this evaluation consists of sen-tences annotated with logical forms for subspans. We manually annotated Wikipedia sentences from the held-out set with logical forms for the largest subspans for which a logical form existed. To avoid trivial cases, we only annotated logical forms containing at least one category or relation predicate and at least one mention. We also chose not to annotate mentions of entities that are not in the knowledge base, as no system would be able to correctly identify them. The corpus contains 97 sentences with 100 annotated logical forms.
We measured performance using two met-rics: logical form accuracy, and extraction preci-sion/recall. Logical form accuracy examines the predicted logical form for the smallest subspan of the sentence containing the annotated span, and marks this prediction correct if it exactly matches the annotation. A limitation of this metric is that it does not assign partial credit to logical forms that are close to, but do not exactly match, the anno-tation. The extraction metric assigns partial credit by computing the precision and recall of the cat-egory and relation instances entailed by the pre-dicted logical form, using those entailed by the an-notated logical form as the gold standard. Figure 4 shows the computation of both error metrics on two examples from the test corpus.

Table 3 shows the results of the annotated sen-tence evaluation. A SP outperforms both baselines in logical form accuracy and extraction recall, sug-gesting that it produces more complete analyses than either baseline. The extraction precision of 90% suggests that A SP rarely extracts incorrect in-formation. Precision is higher in this evaluation because every sentence in the data set has at least one correct extraction. We present an approach to training a joint syntac-tic and semantic parser. Our parser A SP produces a full syntactic parse of any sentence, while simul-taneously producing logical forms for sentence spans that have a semantic representation within its predicate vocabulary. The parser is trained by jointly optimizing performance on a syntac-tic parsing task and a distantly-supervised rela-tion extraction task. Experimental results demon-strate that jointly analyzing syntax and semantics triples the number of extracted logical forms over approaches that first analyze syntax, then seman-tics. However, we also find that incorporating se-mantics slightly reduces syntactic parsing perfor-mance. Poor entity mention detection is a major source of error in both cases, suggesting that fu-ture work should consider integrating entity link-ing with joint syntactic and semantic parsing. This work was supported in part by DARPA under award FA8750-13-2-0005. We additionally thank Jamie Callan and Chris R  X  e X  X  Hazy group for col-lecting and processing the Wikipedia corpus.
