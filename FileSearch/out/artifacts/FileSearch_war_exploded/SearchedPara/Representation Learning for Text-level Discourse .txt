 Discourse structure describes the high-level or-ganization of text or speech. It is central to a number of high-impact applications, such as text summarization (Louis et al., 2010), senti-ment analysis (Voll and Taboada, 2007; Somasun-daran et al., 2009), question answering (Ferrucci et al., 2010), and automatic evaluation of student writing (Miltsakaki and Kukich, 2004; Burstein et al., 2013). Hierarchical discourse representa-tions such as Rhetorical Structure Theory (RST) are particularly useful because of the computa-tional applicability of tree-shaped discourse struc-tures (Taboada and Mann, 2006), as shown in Fig-ure 1.

Unfortunately, the performance of discourse parsing is still relatively weak: the state-of-the-art F-measure for text-level relation detection in the RST Treebank is only slightly above 55% (Joty Figure 1: An example of RST discourse structure. et al., 2013). While recent work has introduced increasingly powerful features (Feng and Hirst, 2012) and inference techniques (Joty et al., 2013), discourse relations remain hard to detect, due in part to a long tail of  X  X lternative lexicalizations X  that can be used to realize each relation (Prasad et al., 2010). Surface and syntactic features are not capable of capturing what are fundamentally se-mantic distinctions, particularly in the face of rel-atively small annotated training sets.

In this paper, we present a representation learn-ing approach to discourse parsing. The core idea of our work is to learn a transformation from a bag-of-words surface representation into a latent space in which discourse relations are easily iden-tifiable. The latent representation for each dis-course unit can be viewed as a discriminatively-trained vector-space representation of its meaning. Alternatively, our approach can be seen as a non-linear learning algorithm for incremental struc-ture prediction, which overcomes feature sparsity through effective parameter tying. We consider several alternative methods for transforming the original features, corresponding to different ideas of the meaning and role of the latent representa-tion.

Our method is implemented as a shift-reduce discourse parser (Marcu, 1999; Sagae, 2009). Learning is performed as large-margin transition-based structure prediction (Taskar et al., 2003), while at the same time jointly learning to project the surface representation into latent space. The resulting system strongly outperforms the prior state-of-the-art at labeled F-measure, obtaining raw improvements of roughly 6% on relation la-bels and 2.5% on nuclearity. In addition, we show that the latent representation coheres well with the characterization of discourse connectives in the Penn Discourse Treebank (Prasad et al., 2008). The core idea of this paper is to project lexical fea-tures into a latent space that facilitates discourse parsing. In this way, we can capture the meaning of each discourse unit, without suffering from the very high dimensionality of a lexical representa-tion. While such feature learning approaches have proven to increase robustness for parsing, POS tagging, and NER (Miller et al., 2004; Koo et al., 2008; Turian et al., 2010), they would seem to have an especially promising role for discourse, where training data is relatively sparse and ambi-guity is considerable. Prasad et al. (2010) show that there is a long tail of alternative lexicalizations for discourse relations in the Penn Discourse Tree-bank, posing obvious challenges for approaches based on directly matching lexical features ob-served in the training data.

Based on this observation, our goal is to learn a function that transforms lexical features into a much lower-dimensional latent representation, while simultaneously learning to predict discourse structure based on this latent representation. In this paper, we consider a simple transformation function, linear projection. Thus, we name the ap-proach D PLP : Discourse Parsing from Linear Pro-jection. We apply transition-based (incremental) structured prediction to obtain a discourse parse, training a predictor to make the correct incremen-tal moves to match the annotations of training data in the RST Treebank. This supervision signal is then used to learn both the weights and the projec-tion matrix in a large-margin framework. 2.1 Shift-reduce discourse parsing We construct RST Trees using shift-reduce pars-ing, as first proposed by Marcu (1999). At each point in the parsing process, we maintain a stack and a queue; initially the stack is empty and the first elementary discourse unit (EDU) in the docu-then choose either to shift the front of the queue onto the top of the stack, or to reduce the top two elements on the stack in a discourse relation. The reduction operation must choose both the type of relation and which element will be the nucleus. So, overall there are multiple reduce operations with specific relation types and nucleus positions. Shift-reduce parsing can be learned as a classifi-cation task, where the classifier uses features of the elements in the stack and queue to decide what move to take. Previous work has employed deci-sion trees (Marcu, 1999) and the averaged percep-tron (Collins and Roark, 2004; Sagae, 2009) for this purpose. Instead, we employ a large-margin classifier, because we can compute derivatives of the margin-based objective function with respect to both the classifier weights as well as the projec-tion matrix. 2.2 Discourse parsing with projected features More formally, we denote the surface feature vo-cabulary V , and represent each EDU as the nu-meric vector v  X  N V , where V = # |V| and the n -th element of v is the count of the n -th surface fea-ture in this EDU (see Table 1 for a summary of no-tation). During shift-reduce parsing, we consider the stack ( v 1 and v 2 ), and the front of the queue ( v 3 ) . The vertical concatenation of these vectors is denoted v = [ v 1 ; v 2 ; v 3 ] . In general, we can formulate the decision function for the multi-class shift-reduce classifier as where w m is the weight for the m -th class and f ( v ; A ) is the representation function parametrized by A . The score for class m (in our case, the value of taking the m -th shift-reduce operation) is computed by the inner prod-uct w &gt; m f ( v ; A ) . The specific shift-reduce opera-tion is chosen by maximizing the decision value in Equation 1.

The representation function f ( v ; A ) can be de-fined in any form; for example, it could be a non-linear function defined by a neural network model parametrized by A . We focus on the linear projec-tion, sentation v of three EDUs into a latent space of size K V .

Note that by setting  X  w &gt; m = w &gt; m A , the decision scoring function can be rewritten as  X  w &gt; m v , which is linear in the original surface features. Therefore, the expressiveness of D PLP is identical to a linear separator in the original feature space. However, the learning problem is considerably different. If there are C total classes (possible shift-reduce op-erations), then a linear classifier must learn 3 V C parameters, while D PLP must learn (3 V + C ) K parameters, which will be smaller under the as-sumption that K &lt; C V . This can be seen as a form of parameter tying on the linear weights  X  w m , which allows statistical strength to be shared across training instances. We will consider special cases of A that reduce the parameter space still further. 2.3 Special forms of the projection matrix We consider three different constructions for the projection matrix A .  X  General form : In the general case, we place  X  Concatenation form : In the concatenation  X  Difference form . In the difference form, we We apply a large margin structure prediction ap-proach to train the model. There are two pa-rameters that need to be learned: the classifica-tion weights { w m } , and the projection matrix A . As we will see, it is possible to learn { w m } us-ing standard support vector machine (SVM) train-ing (holding A fixed), and then make a simple gradient-based update to A (holding { w m } fixed). By interleaving these two operations, we arrive at a saddle point of the objective function.
Specifically, we formulate the following con-strained optimization problem, where m  X  { 1 ,...,C } is the index of the shift-reduce decision taken by the classifier (e.g., S { 1 ,  X  X  X  ,l } is the index of the training sample, and w m is the vector of classification weights for class m . The slack variables  X  i permit the margin con-straint to be violated in exchange for a penalty, and the delta function  X  y zero otherwise.
 As is standard in the multi-class linear SVM (Crammer and Singer, 2001), we can solve the problem defined in Equation 6 via Lagrangian optimization: Then, to optimize L , we need to find a saddle point, which would be the minimum for the vari-ables { w 1: C , X  1: l } and the projection matrix A , and the maximum for the dual variables {  X  1: l, 1: C } .
If A is fixed, then the optimization problem is equivalent to a standard multi-class SVM, in the transformed feature space f ( v i ; A ) . We can obtain the weights { w 1: C } and dual variables {  X  1: l, 1: C } from a standard dual-form SVM solver. We then update A , recompute { w 1: C } and {  X  1: l, 1: C } , and iterate until convergence. This iterative procedure is similar to the latent variable structural SVM (Yu and Joachims, 2009), although the specific details of our learning algorithm are different. 3.1 Learning Projection Matrix A We update A while holding fixed the weights and dual variables. The derivative of L with respect to A is Setting  X  L because the dual variables for each instance must sum to one,
Note that for a given i , the matrix ( w y P fore, the solution of A can be viewed as the lin-ear combination of a sequence of rank-1 matrices, where each rank-1 matrix is defined by distribu-tional representation v i and the weight difference between the weight of true label w y pected X  weight
One property of the dual variables is that f ( v i ; A ) is a support vector only if the dual vari-instance are guaranteed to sum to one, we have w words, the contribution from non support vectors to the projection matrix A is 0. Then, we can fur-ther simplify the updating equation as This is computationally advantageous since many instances are not support vectors, and it shows that the discriminatively-trained projection matrix only incorporates information from each instance to the extent that the correct classification receives low confidence. Algorithm 1 Mini-batch learning algorithm
Input : Training set D , Regularization parame-ters  X  and  X  , Number of iteration T , Initializa-tion matrix A 0 , and Threshold  X  while t = 1 ,...,T do end while Re-train SVM with D and the final A
Output : Projection matrix A , SVM classifier with weights w 3.2 Gradient-based Learning for A Solving the quadratic programming defined by the dual form of the SVM is time-consuming, espe-cially on a large-scale dataset. But if we focus on learning the projection matrix A , we can speed up learning by sampling only a small proportion of the training data to compute an approximate op-timum for { w 1: C , X  1: l, 1: C } , before each update of A . This idea is similar to the mini-batch learning, which has been used in large-scale SVM problem (Nelakanti et al., 2013) and deep learning models (Le et al., 2011).

Specifically, in iteration t , the algorithm ran-domly chooses a subset of training samples D t to train the model. We cannot make a closed-form update to A based on this small sample, but we can take an approximate gradient step, where  X  t is a learning rate. In iteration t , we choose  X  t = 1 weights w by applying the SVM over the entire dataset, using the final A . The algorithm is sum-marized in Algorithm 1 and more details about im-plementation will be clarified in Section 4. While minibatch learning requires more iterations, the SVM training is much faster in each batch, and the overall algorithm is several times faster than using the entire training set for each update. The learning algorithm is applied in a shift-reduce parser, where the training data consists of the (unique) list of shift and reduce operations re-quired to produce the gold RST parses. On test data, we choose parsing operations in an online fashion  X  at each step, the parsing algorithm changes the status of the stack and the queue ac-cording the selected transition, then creates the next sample with the updated status. 4.1 Parameters and Initialization There are three free parameters in our approach: the latent dimension K , and regularization pa-rameters  X  and  X  . We consider the values K  X  { 30 , 60 , 90 , 150 } ,  X   X  { 1 , 10 , 50 , 100 } and  X   X  using a development set of thirty document ran-domly selected from within the RST Treebank training data. We initialize each element of A 0 to a uniform random value in the range [0 , 1] . For mini-batch learning, we fixed the batch size to be 500 training samples (shift-reduce operations) in each iteration. 4.2 Additional features As described thus far, our model considers only the projected representation of each EDU in its parsing decisions. But prior work has shown that other, structural features can provide useful in-formation (Joty et al., 2013). We therefore aug-ment our classifier with a set of simple feature templates. These templates are applied to individ-ual EDUs, as well as pairs of EDUs: (1) the two EDUs on top of the stack, and (2) the EDU on top of the stack and the EDU in front of the queue. The features are shown in Table 2. In computing these features, all tokens are downcased, and nu-merical features are not binned. The dependency structure and POS tags are obtained from MALT-Parser (Nivre et al., 2007). We evaluate D PLP on the RST Discourse Tree-bank (Carlson et al., 2001), comparing against state-of-the-art results. We also investigate the in-formation encoded by the projection matrix. 5.1 Experimental Setup Dataset The RST Discourse Treebank (RST-DT) consists of 385 documents, with 347 for train-ing and 38 for testing in the standard split. As we focus on relational discourse parsing, we fol-low prior work (Feng and Hirst, 2012; Joty et al., 2013), and use gold EDU segmentations. The strongest automated RST segmentation methods currently attain 95% accuracy (Xuan Bach et al., 2012).
 Preprocessing In the RST-DT, most nodes have exactly two children, one nucleus and one satellite. For non-binary relations, we use right-branching to binarize the tree structure. For multi-nuclear relations, we choose the left EDU as  X  X ead X  EDU. The vocabulary V includes all unigrams af-ter down-casing. No other preprocessing is per-formed. In total, there are 16250 unique unigrams in V .
 Fixed projection matrix baselines Instead of learning from data, a simple way to obtain a pro-jection matrix is to use matrix factorization. Re-cent work has demonstrated the effectiveness of non-negative matrix factorization (NMF) for mea-suring distributional similarity (Dinu and Lapata, 2010; Van de Cruys and Apidianaki, 2011). We can construct B nmf in the concatenation form of the projection matrix by applying NMF to the EDU-feature matrix, M  X  WH . As a result, W describes each EDU with a K -dimensional vector, and H describes each word with a K -dimensional vector. We can then construct B nmf by taking the pseudo-inverse of H , which then projects from word-count vectors into the latent space.

Another way to construct B is to use neural word embeddings (Collobert and Weston, 2008). In this case, we can view the product Bv as a com-position of the word embeddings, using the simple additive composition model proposed by Mitchell and Lapata (2010). We used the word embeddings from Collobert and Weston (2008) with dimension { 25 , 50 , 100 } . Grid search over heldout training data was used to select the optimum latent dimen-sion for both the NMF and word embedding base-lines. Note that the size K of the resulting projec-tion matrix is three times the size of the embed-ding (or NMF representation) due to the concate-nate construction.
 We also consider the special case where A = I . Competitive systems We compare our approach with HILDA (Hernault et al., 2010) and TSP (Joty et al., 2013). Joty et al. (2013) proposed two dif-ferent approaches to combine sentence-level pars-ing models: sliding windows (TSP SW) and 1 sentence-1 subtree (TSP 1-1). In the comparison, we report the results of both approaches. All re-sults are based on the same gold standard EDU segmentation. We cannot compare with the re-sults of Feng and Hirst (2012), because they do not evaluate on the overall discourse structure , but rather treat each relation as an individual classifi-cation problem.
 Metrics To evaluate the parsing performance, we use the three standard ways to measure the per-formance: unlabeled (i.e., hierarchical spans) and labeled (i.e., nuclearity and relation) F-score, as defined by Black et al. (1991). The application of this approach to RST parsing is described by on RST-DT, we use the 18 coarse-grained relations defined in (Carlson et al., 2001). 5.2 Experimental Results Table 3 presents RST parsing results for D PLP and some alternative systems. All versions of D PLP outperform the prior state-of-the-art on nuclearity and relation detection. This includes relatively simple systems whose features are simply a projection of the word count vectors for each EDU (lines 7 and 8). The addition of the features from Table 2 improves performance further, leading to absolute F-score improvement of around 2.5% in nuclearity and 6% in relation prediction (lines 9 and 10).

On span detection, D PLP performs slightly worse than the prior state-of-the-art. These sys-tems employ richer syntactic and contextual fea-tures, which might be especially helpful for span identification. As shown by line 4 of the re-sults table, the basic features from Table 2 pro-vide most of the predictive power for spans; how-ever, these features are inadequate at the more semantically-oriented tasks of nuclearity and re-lation prediction, which benefit substantially from the projected features. Since correctly identifying spans is a precondition for nuclearity and relation prediction, we might obtain still better results by combining features from HILDA and TSP with the representation learning approach described here.
Lines 5 and 6 show that discriminative learning of the projection matrix is crucial, as fixed projec-tions obtained from NMF or neural word embed-dings perform substantially worse. Line 7 shows that the original bag-of-words representation to-gether with basic features could give us some ben-efit on discourse parsing, but still not as good as results from D PLP . From lines 8 and 9, we see that the concatenation construction is superior to the difference construction, but the comparison between lines 10 and 11 is inconclusive on the merits of the general form of A . This suggests that using the projection matrix to model interre-lationships between EDUs does not substantially improve performance, and the simpler concatena-tion construction may be preferred.

Figure 3 shows how performance changes for different latent dimensions K . At each value of K , we employ grid search over a development set to identify the optimal regularizers  X  and  X  . For the concatenation construction, performance is not overly sensitive to K . For the general form of A , performance decreases with large K . Recall from Section 2.3 that this construction has nine times as many parameters as the concatenation form; with large values of K , it is likely to overfit. 5.3 Analysis of Projection Matrix Why does projection of the surface features im-prove discourse parsing? To answer this question, we examine what information the projection ma-trix is learning to encoded. We take the projec-tion matrix from the concatenation construction and K = 60 as an example for case study. Re-calling the definition in equation 4, the projection matrix A will be composed of three identical sub-matrices B  X  R 20  X  V . The columns of the B ma-trix can be viewed as 20-dimensional descriptors of the words in the vocabulary.

For the purpose of visualization, we further re-duce the dimension of latent representation from K = 20 to 2 dimensions using t-SNE (van der Maaten and Hinton, 2008). One further simpli-the additional features from Table 3 fication for visualization is we consider only the top 1000 frequent unigrams in the RST-DT train-ing set. For comparison, we also apply t-SNE to the projection matrix B nmf recovered from non-negative matrix factorization.

Figure 4 highlights words that are related to dis-course analysis. Among the top 1000 words, we highlight the words from 5 major discourse con-nective categories provided in Appendix B of the PDTB annotation manual (Prasad et al., 2008): C SULT , and S UCCESSION . In addition, we also highlighted two verb categories from the top 1000 words: modal verbs and reporting verbs, with their inflections (Krestel et al., 2008).

From the figure, it is clear D PLP has learned a projection matrix that successfully groups several major discourse-related word classes: particularly modal and reporting verbs; it has also grouped succession and precedence connectives with some success. In contrast, while NMF does obtain com-pact clusters of words, these clusters appear to be completely unrelated to discourse function of the words that they include. This demonstrates the value of using discriminative training to obtain the transformed representation of the discourse units. Early work on document-level discourse parsing applied hand-crafted rules and heuristics to build trees in the framework of Rhetorical Structure Theory (Sumita et al., 1992; Corston-Oliver, 1998; Marcu, 2000a). An early data-driven approach was offered by Schilder (2002), who used distribu-tional techniques to rate the topicality of each dis-course unit, and then chose among underspecified discourse structures by placing more topical sen-tences near the root. Learning-based approaches were first applied to identify within-sentence dis-course relations (Soricut and Marcu, 2003), and only later to cross-sentence relations at the docu-ment level (Baldridge and Lascarides, 2005). Of particular relevance to our inference technique are incremental discourse parsing approaches, such as shift-reduce (Sagae, 2009) and A* (Muller et al., 2012). Prior learning-based work has largely focused on lexical, syntactic, and structural fea-tures, but the close relationship between discourse structure and semantics (Forbes-Riley et al., 2006) suggests that shallow feature sets may struggle to capture the long tail of alternative lexicaliza-tions that can be used to realize discourse rela-tions (Prasad et al., 2010; Marcu and Echihabi, 2002). Only Subba and Di Eugenio (2009) incor-porate rich compositional semantics into discourse parsing, but due to the ambiguity of their seman-tic parser, they must manually select the correct semantic parse from a forest of possiblities.
Recent work has succeeded in pushing the state-of-the-art in RST parsing by innovating on sev-eral fronts. Feng and Hirst (2012) explore rich linguistic linguistic features, including lexical se-mantics and discourse production rules suggested by Lin et al. (2009) in the context of the Penn Dis-course Treebank (Prasad et al., 2008). Muller et al. (2012) show that A* decoding can outperform both greedy and graph-based decoding algorithms. Joty et al. (2013) achieve the best prior results on RST relation detection by (i) jointly perform-ing relation detection and classification, (ii) per-forming bottom-up rather than greedy decoding, and (iii) distinguishing between intra-sentence and inter-sentence relations. Our approach is largely orthogonal to this prior work: we focus on trans-forming the lexical representation of discourse units into a latent space to facilitate learning. As shown in Figure 4(a), this projection succeeds at grouping words with similar discourse func-tions. We might expect to obtain further improve-ments by augmenting this representation learning approach with rich syntactic features (particularly for span identification), more accurate decoding, and special treatment of intra-sentence relations; this is a direction for future research.

Discriminative learning of latent features for discourse processing can be viewed as a form of representation learning (Bengio et al., 2013). Also called Deep Learning, such approaches have recently been applied in a number of NLP tasks (Collobert et al., 2011; Socher et al., 2012). Of particular relevance are applications to the de-tection of semantic or discourse relations, such as paraphrase, by comparing sentences in an in-duced latent space (Socher et al., 2011; Guo and Diab, 2012; Ji and Eisenstein, 2013). In this work, we show how discourse structure annotations can function as a supervision signal to discriminatively learn a transformation from lexical features to a la-tent space that is well-suited for discourse parsing. Unlike much of the prior work on representation learning, we induce a simple linear transforma-tion. Extension of our approach by incorporating a non-linear activation function is a natural topic for future research. We have presented a framework to perform dis-course parsing while jointly learning to project to a low-dimensional representation of the discourse units. Using the vector-space representation of EDUs, our shift-reduce parsing system substan-tially outperforms existing systems on nuclearity detection and discourse relation identification. By adding some additional surface features, we ob-tain further improvements. The low dimensional representation also captures basic intuitions about discourse connectives and verbs, as shown in Fig-ure 4(a).

Deep learning approaches typically apply a non-linear transformation such as the sigmoid function (Bengio et al., 2013). We have con-ducted a few unsuccessful experiments with the  X  X ard tanh X  function proposed by Collobert and Weston (2008), but a more complete exploration of non-linear transformations must wait for future work. Another direction would be more sophis-ticated composition of the surface features within each elementary discourse unit, such as the hierar-chical convolutional neural network (Kalchbren-ner and Blunsom, 2013) or the recursive tensor network (Socher et al., 2013). It seems likely that a better accounting for syntax could improve the latent representations that our method induces. We thank the reviewers for their helpful feedback, particularly for the connection to multitask learn-ing. We also want to thank Kenji Sagae and Vanessa Wei Feng for the helpful discussion via email communication. This research was sup-ported by Google Faculty Research Awards to the second author.
