 Abstract This paper overviews the International Standards Organization X  X inguis-tic Annotation Framework (ISO X  X AF) developed in ISO TC37 SC4. We describe the XML serialization of ISO X  X AF, the Graph Annotation Format (GrAF) and discuss the rationale behind the various decisions that were made in determining the standard. We describe the structure of the GrAF headers in detail and provide multiple examples of GrAF representation for text and multi-media. Finally, we discuss the next steps for standardization of interchange formats for linguistic annotations.
 Keywords Linguistic annotation Standards Language resources Interoperability 1 Introduction The Linguistic Annotation Framework (LAF) was developed by the International Standards Organization (ISO) X  X  TC37 SC4, the ISO sub-committee on Language Resource Management. LAF was the first work item established by the sub-committee in order to provide a broad framework for more specific standards for representing linguistic annotations that have been and continue to be developed in other SC4 working groups. The earliest work on LAF involved identifying the fundamental properties and principles for representing linguistic annotations, and led to the design of an abstract data model that has since served as the basis for SC4 standards for lexicons, 1 morpho-syntactic and syntactic annotations, as well as a range of semantic annotation types.

Despite its early start, and while several of the SC4 standards that depend on LAF have been approved and published over the past eight years, LAF has only recently been finalized. However, the overall LAF architecture has not changed since 2001; what has changed is the implementation of a concrete representation format that satisfies the LAF criteria for expressive adequacy, media independence, flexibility, processability, and X  X erhaps most critically X  X appability to the objects and relations in a variety of formats suitable for different tools and applications. In 2007, the Graph Annotation Format (GrAF) (Ide and Suderman 2007 ) was introduced as the final XML serialization of the LAF abstract data model; it has since been modified slightly in response to input from experience with full-scale implementation in two multi-layered corpora [OANC 2 and MASC (Ide et al. 2010a )] and implementations for multi-media data, as well as issues that have arisen in the course of developing the ISO standards for specific annotation types. The ISO standard describing LAF and GrAF is published as ISO 24612:2012 (ISO 2012 ).
This paper provides an overview of LAF and describes the GrAF XML pivot format, as well as the process and rationale for decisions that fed its final form. For completeness, we provide an outline of the LAF architecture, although this has been described elsewhere (Ide and Romary 2001 , 2003 , 2004b , 2007 ). We describe the structure of the GrAF headers in detail, as this has not been presented elsewhere, and provide multiple examples of GrAF representation for text and multi-media. Finally, we discuss the next steps for standardization of interchange formats for linguistic annotations. 2 Background The motivation for developing LAF is to provide an architecture for annotated language resources that can serve the needs of all the annotation activities in the field of computational linguistics and offer full interoperability among annotation formats. At the time of LAF X  X  initial development, most annotation formats were developed without any underlying data model in mind, and choices were often primarily driven by the needs of particular processing software. Exceptions were the Corpus Encoding Standard [CES, the SGML predecessor of the XML version, the XCES (Ide et al. 2000 )], 3 which was an early attempt to provide a more principled scheme for linguistic annotation, and which introduced the concept of  X  X  X emote markup X  X  [eventually called  X  X  X tandoff markup X  X  (Thompson and McKelvie 1997 )]. Later, annotation graphs (AG) (Bird and Liberman 2001 ), developed primarily for read-only speech data distributed over a timeline, were introduced and subsequently widely adopted in the field. Neither scheme was entirely satisfactory: the XCES was not comprehensive enough for many types of linguistic annotation, and AG posed problems for representing hierarchical relations such as syntactic phrase structure. 4 LAF X  X  development takes these and other established best practices as a starting point for identifying a more comprehensive and general model for representing linguistic annotations.

LAF identifies a set of fundamental principles to inform the development of the architecture. One of the most important is the clear separation of annotation structure , i.e., the physical format of annotations, and annotation content , which includes the categories or labels used in an annotation scheme to describe linguistic phenomena. A related principle, although seemingly obvious, is the requirement that all annotation information be explicitly represented. Some schemes rely on implicit knowledge about particular categories and relations to be interpreted correctly; for example, brackets may signal that the components are a set of alternatives, or that they comprise an ordered list; it is necessary to have knowledge of the categories themselves to determine which applies. This is in itself a major obstacle to interoperability, because processing the annotations often requires the use of specialized software in which this knowledge is embedded.

Based on these principles, the LAF architecture comprises two distinct parts: (1) a data structure for representing relations among annotations, together with a mechanism for associating linguistic categories with appropriate parts of that data structure; and (2) a means to define linguistic categories that is not tied to a specific theory or naming convention. Part (2) ensures semantic coherence; from the outset it was envisaged that this would be provided by a registry of linguistic categories and features that would be universally accessible for reference (Ide and Romary 2004a ). This plan eventually led to the creation of ISOCat (Kemps-Snijders et al. 2009 ), which has become a stand-alone effort independent of LAF development. Work on LAF is therefore focused on part (1): the development of an abstract data model for the structure of annotations that could be serialized in a  X  X  X ivot X  X  XML represen-tation format, into and out of which user-defined formats could be mapped for the purposes of interchange and merging. As a result, LAF has nothing to say about annotation content, per se; however, full interoperability for linguistic annotations requires standardization of some organizational practices for interchanging linguistic information that fall in the intersection of representation format and semantic content. See Sect. 9 for a discussion of next steps for extending LAF to accommodate this need.

The LAF data model must capture the general principles and practices of both existing and foreseen linguistic annotations, including annotations of all media types such as text, audio, video, image, etc. in order to ultimately provide common mechanisms for handling all of them. In addition, the model has to allow for variation in annotation schemes while at the same time enabling comparison and evaluation, merging of different annotations, and development of common tools for creating and using annotated data. To accomplish this, LAF adopts two well-established, generalized data structures: the graph, for representing objects and relations, and feature structures for representing linguistic information. The complete LAF data model ultimately includes (1) a structure for describing media, consisting of anchors that reference locations in primary data, and regions defined in terms of these anchors; (2) a graph structure , consisting of nodes, edges, and links to regions; and (3) an annotation structure for representing linguistic information with feature structures. The data model for annotations thus comprises an acyclic di-graph decorated with feature structures (coupled with a moderate admixture of algebra, e.g. disjunction, sets), grounded in n -dimensional regions of primary data. The graph itself is a generalization of models for a wide range of phenomena, including syntax trees, semantic networks, W3C X  X  RDF/OWL, the Unified Modeling Language (UML), entity X  X elation (ER) models for databases, etc. X  X ot to mention the overall structure of the web, as a dense inter-connected network of effective objects X  X nd grows naturally out of pre-existing annotation models, including Annotation Graphs (Bird and Liberman 2001 ) and XML-based formats such as the XCES (Ide et al. 2000 ). However, LAF differs from other graph-based annotation models in a few significant ways: 1. Nodes in the graph do not represent annotations, but rather they are simply 2. Nodes may be associated directly with a region or regions in primary data or 3. Edges in the graph are first class citizens of the data model. In many data A rendering of the LAF data model in the Unified Modeling Language (UML), 6 which reflects the roles and relationships among nodes, edges, and links, is given in Fig. 1 . The figure also shows that each annotation is associated with an AnnotationSpace ; like namespaces in XML, AnnotationSpaces enable disambigu-ation of homonym labels, which can occur when two or more annotations of the same phenomenon from different sources are merged. They are also commonly used to identify logical groups of annotations, such as annotations in different linguistic layers or tiers that are to be used together (e.g., token annotations that are the basis for a particular syntactic annotation).
 To achieve interoperability among formats while retaining maximal flexibility, LAF prescribes that conformant annotation schemes, either pre-existing or newly developed, are (or may be rendered via mapping) isomorphic to the LAF data model. The mapping between user formats and the LAF abstract data model is via an XML serialization of the data model, called the Graph Annotation Format (GrAF) (Ide and Suderman 2007 ). GrAF thus serves as a reference or  X  X  X ivot X  X  into and out of which annotations may be mapped for interchange, or into which different annotations may be mapped for comparison or merging. We have previously demonstrated the applicability of the model to a wide range of pre-existing annotation types and schemes (Ide and Suderman 2007 ; Ide et al. 2011 )asa proof-of-concept that the model can accommodate a broad range of linguistic annotation types. The Manually Annotated Sub-Corpus (MASC) (Ide et al. 2010a ) provides a concrete example where the GrAF rendering enables full interoperability among diverse annotations; at the time of this writing, MASC includes sixteen different annotation types, originally rendered in various formats that have been transduced to a GrAF representation so that they can be searched, retrieved, or otherwise manipulated as a single object. So, for example, a user can extract all annotations of a Penn Treebank NP that includes both a named entity of type country and a FrameNet frame element of type food . 7
The overall architecture of a linguistically-annotated resource rendered in GrAF consists of the following:  X  One or more primary data documents , in any medium 8 ;  X  One or more documents defining a set of regions over each primary data  X  Any number of annotation documents containing feature structures associated  X  Header documents associated with each primary data document and annotation We describe these components in the following sections. We describe the headers components. Note that the full description of GrAF, including GrAF schemas and a description of all components, elements, and attributes, is published as ISO 24612: Language Resource Management X  X inguistic Annotation Framework; additional documentation is available at http://www.anc.org/graf . 3 GrAF headers Each primary data, segmentation, and annotation document, as well as the resource as a whole, requires a header. The GrAF resource header plays a key role in providing meta-data for the resource by establishing resource-wide definitions and relations among files, datatypes, and annotations that can enable automatic validation of the resource file structure and contents. All of the headers have been designed with the aim of facilitating the processing of annotations. 3.1 Resource header The GrAF resource header is based on the CES header 9 (which is in turn based on the TEI header 10 ), omitting information that is relevant to single documents. The most important addition is a resourceDesc (resource description) element, which provides detailed definitions of file naming conventions, annotation types, annotation spaces, encoding specifications, data types, etc. All elements in the resourceDesc have an @xml:id attribute, 11 which is used to relate object definitions where applicable. The dependencies among several of these elements are shown graphically in Fig. 3 , which also shows the use of the @suffix attribute for file types and the @extension attribute for media in a sample file name.

The overall structure of the resource description is shown in Fig. 2 ; the relevant elements are described below.  X  fileStruct : Provides the file structure of the resource, including the directory  X  annotationSpaces : Provides a set of one or more annotation spaces, which are  X  annotationDecls : A set of one or more annotation declarations, which provide  X  media : Provides a set of one or more media types that files may contain, the  X  anchorTypes : a set of one or more types of anchors used to ground annotations  X  groups : Definition of one or more groups of annotations that are to be regarded Figure 5 provides an example of a groups definition illustrating the grouping mechanisms described above as well as the use of ids for cross-reference among objects defined in the header. It assumes that declarations of the form shown in Fig. 4 appear elsewhere in the resource header. 3.2 Primary data document header The primary document header is stored in a separate XML document with root element documentHeader . The document header contains TEI-like elements for describing the primary data document, including its title, author, size, source of the original, language and encoding used in the document, etc., as well as a textClass element that provides genre/domain information by referring to classes defined in the resource header. Additional elements provide the locations of the primary data document and all associated annotation documents, using either a path relative to the root (declared on a directory element in the resource header) or a Uniform Resource Identifier (URI). 3.3 Annotation documents header Annotation documents contain both a header and the graph of feature structures comprising the annotation. The annotation document header is brief; it provides four pieces of information: 1. a list of the annotation labels used in the document and their frequencies; 2. a list of documents required to process the annotations, which will include a 3. a list of annotation spaces referenced in the document, one of which may be 4. (optional) The root node(s) in the graph, when the graph contains one or more Information about references to other documents is intended for use by processing software, to both validate the resource (ensure all required documents are present) and facilitate the loading of required documents for proper processing. Information about annotation spaces provides a reference to required information in the resource header. When there is more than one tree in a graph, specification of their root nodes is required for proper processing. An example annotation document header is shown in Fig. 12 . 4 Annotation documents Following the header, annotation documents contain a graph or graphs and associated annotations. LAF recommends that each annotation type or layer be placed in a separate annotation document, although in the absence of a standard definition of layers it is likely that there will be considerable variation in how this is implemented in practice. A newly-proposed ISO work item will address this and other organization principles in the near future (see Sect. 9 ).

GrAF defines the XML serialization of the data model, for which the fundamental data structure is a graph consisting of nodes and edges. An annotation is defined as a label and a feature structure that is associated with a node or an edge using the XML representation defined in ISO Document ISO/DIS 24610-1 (ISO 2005 ).

Nodes may be associated with regions in the primary document defined in a base segmentation document, or connected to other nodes in the same or another annotation document by one or more edges. The node element is empty when connected by an edge element to another node in the graph (i.e., when the node is a non-terminal node). A child link element is used when the node refers to a region or regions of primary data (i.e., when the node is a terminal/leaf node).

Annotations associated with a node are represented with a elements that appear at the same level in the XML hierarchy, which have a @ref attribute that provides the id of the associated node. The @label attribute on an a element gives the main category of the annotation; this may be the string used to identify the annotation as described by the annotation documentation, 14 a category identifier from a data category registry such as ISOCat, an identifier from a feature structure library, or any PID reference to an external annotation specification. The LAF recommenda-tion is to use PID references to ISOCat categories wherever possible, in order to move toward greater standardization of category definitions.

If the only annotation information is the label, the a element is empty. Otherwise, it contains the feature structure or feature structures that provide detailed linguistic information. The ISO specification for representing feature structures allows for feature structures of any complexity and supports the full range of operations over feature structures (subsumption, unification, etc.). It also provides a simplified format that may be used for features consisting of simple name-value pairs, for example (see also Fig. 6 ): Edges connect two nodes with @from and @to attributes referring to the node ids, and may themselves be labeled with annotations, using the same mechanism described above. By default, edges from a node represent an ordered set of constituents, where the order is determined by the order in which they are defined in the annotation document. Other relationships may be specified by associating an annotation that provides the relational information with the edge, for example, coreference relations (antecedent, etc.) or temporal links. Like any annotation, annotations providing relational information may include a feature structure with more detailed information, as shown in Fig. 6 . 5 Primary data documents Primary data in a LAF-compliant resource is frozen as read-only to preserve the integrity of references to locations within the document or documents. Thus, a primary data document will contain only the data that is being annotated. Corrections and modifications to the primary data are treated as annotations and stored in a separate annotation document.

In the general case, primary data does not contain markup of any kind. If markup appears in primary data (e.g., HTML or XML tags), it is treated as a part of the data stream by referring annotations; no distinction is made between markup and other characters in the data when referring to locations in the document. Although LAF does not recommend anchoring annotations in primary data by referencing markup, when necessary, XML elements in a document that is valid XML may be referenced by defining a medium type as XML and defining the associated anchor type as an XPath expression. References to locations within these XML elements (i.e., XML element content) can be made using standard offsets, which will be computed by including the markup as part of the data stream; in this case, two media types would be associated with the primary document X  X  file type, as shown in Fig. 7 . 6 Segmentation documents An annotation document is called a segmentation document if it contains only segmentation information X  X .e., delineations of regions in the data that are associated with one or more annotations. Although regions and anchors may also be defined in an annotation document containing the graph of annotations over the data, LAF strongly recommends that when a segmentation is referenced from more than one annotation document, it appears in an independent document in order to avoid a potentially complex jungle of references among annotation documents. 6.1 Regions and anchors Segmentation information is specified by defining regions over primary data. Regions are defined in terms of anchors that directly reference locations in primary data. All anchors are typed; anchor types used in the resource are each defined with an anchorType element in the resource header. The type of the anchor determines its semantics and therefore how it should be processed by an application. Figure 8 shows a set of region definitions and the associated anchor type and medium definitions from the resource header. 15
Anchors are first-class objects the LAF data model (see Fig. 1 ) along with regions, nodes, edges, and links. The anchor is the only object in the model that may be represented in two alternative ways in the GrAF serialization: as the value of an @anchors attribute on the region element, or with an anchor element. When anchors are represented with the anchor element, the region element will include a @refs attribute (and must not include an @anchors attribute) providing the ids of the associated anchors. For example, an alternative representation for region  X  X  X 2 X  X  in Fig. 8 is given in Fig. 9 .

In general, the design of GrAF follows the principle of orthogonality, wherein there is a single means to represent a given phenomenon. The primary reason for allowing alternative representations for anchors is that the proliferation of anchor elements in a segmentation document is space-consuming and potentially error-prone. As shown in Fig. 8 as well as Sect. 7 , the attribute representation can accommodate most references into text, video, and audio; the only situation in which use of an anchor element may be necessary is one where a given location in a document needs to be interpreted in two or more ways, as, for example, a part of two regions that should not be considered to have a common border point. In this case, multiple anchor elements can be defined that reference the same location, and each anchor may then be uniquely referenced. Because of its brevity and in the interests of orthogonality, the attribute representation is recommended in LAF. 6.2 Base segmentation A base segmentation for primary data is one that defines minimally granular regions to be used by different annotations, usually annotations of the same type. For example, it is not uncommon that different annotations of the same text X  X specially annotations created by different projects X  X re based on different tokenizations. A base segmentation can define a set of regions that include the smallest character span isolated by any of the alternative tokenizations X  X .g., for a string such as  X  X  X hree-fold X  X , regions spanning  X  X  X hree X  X ,  X  X - X  X , and  X  X  X old X  X  may be included; a tokenization that regards  X  X  X hree-fold X  X  as a single token can reference all three regions in the @targets attribute on a link element associated with the node with which the token annotation is attached, as shown in Fig. 10 . 16
Multiple segmentation documents may be associated with a given primary data document. This is useful when annotations reference very different regions of the data; for example, in addition to the base segmentation document containing the minimal character spans that is partially shown in Fig. 10 , there may also be a segmentation based on sentences, which may in turn be referenced by annotations for which this unit of reference is more appropriate. 17 Alternative segmentations for different granularities, such as phonetic units, may also be useful for some purposes. 7 Examples Extensive examples of several types of annotations over text are provided elsewhere [see for example (Ide and Suderman 2007 ; Ide and Bunt 2010 ; Ide et al. 2011 )]. Here, we provide one example for text together with examples for multi-media.
Figure 11 shows an original FrameNet (Baker et al. 1998 ) annotation; 18 its GrAF rendering is given in Fig. 12 . Figure 13 shows a fragment of the associated document defining the tokens referenced in Fig. 12 . The FrameNet conceptualiza-grammatical function (GF), phrase type (PT), etc.) in a FrameNet annotationSet , requires re-specifying the start and end locations of the annotated region. The GrAF rendering instead groups the elements of an annotation set as children of a node with the annotation label annotationSet , which are in turn linked to the tokens defined over the text, as shown graphically in Fig. 14 .

The multi-media annotations in Figs. 15 and 16 show a segment of gesture annotation as represented in the video and audio annotation tool ELAN 19 and its GrAF rendering. ELAN X  X  internal representation defines time-slots that specify a temporal offset (anchor) in the video or audio stream and then defines regions bounded by a start ( X  X  X ime_slot_ref1 X  X ) and end ( X  X  X ime_slot_ref2 X  X ) timeslot. This translates naturally into the GrAF serialization, using anchors as timeslots and regions as  X  X  X lignable_annotations X  X , and associating the appropriate annotations with nodes that reference these regions.

Figures 17 and 18 similarly show a segment of spatial annotation of video represented using Anvil (Kipp 2001 ) and its GrAF rendering. Anvil video anchors may consist of a time (frame) reference and a set of x, y coordinates. In the GrAF rendering, the anchor values are given as features of an element annotation, rather than being represented as actual GrAF anchors. This is done to remain consistent with the Anvil XML representation, in which the region being annotated and the trajectory are defined using different mechanisms; and in particular to conform to the Anvil data model, which represents a trajectory as an annotation and feature structure, not directly as links into the media. An alternative representation using GrAF regions and anchors similar to the definition for region  X  X  X 3 X  X  in Fig. 8 could also be used. 8 GrAF support tools and environment All GrAF schemas and full documentation of all elements and attributes is available at http://graf.anc.org/ . An API for GrAF is available at http://graf.anc.org/graf-api/ apidocs/index.html . It provides methods for adding nodes, edges, and annotations to a graph in GrAF format as well as retrieving annotations, features, etc. from the graph. Methods also exist that render annotations in GrAF format in a variety of output formats, such as input to the GraphViz Graph Visualization Software. 20 Two implementations of GrAF in major corpora have been used to inform the GrAF development process, and are freely available via download from the American National Corpus (ANC) website for any use: (1) the Open American National Corpus (OANC) 21 and the Manually Annotated Sub-Corpus (MASC) 22 (Ide et al. 2010a ).

The ANC project provides a web application  X  X  X NC2Go X  X  23 (Ide et al. 2010b ) that comprises a suite of web services for transducing annotations in GrAF to a variety of other formats, including inline XML (suitable for input to XML-aware software); token ? part of speech (with choice of separation character), a common input format for general-purpose concordance software and numerous parsers; word/pos output in a format readable with the Natural Language Toolkit X  X  (NLTK) 24 TaggedCor-pusReader; CONLL IOB format, used in the Conference on Natural Language Learning 25 shared tasks; UIMA CAS (Ferrucci and Lally 2004 ), for input to the Unstructured Information Management Architecture (UIMA) (Ferrucci and Lally 2004 ); and the W3C Resource Description Framework (RDF). The ANC project also provides plugins for the General Architecture for Text Engineering (GATE) (Cunningham et al. 2002 ) to input and/or export annotations in GrAF format, and a stand-alone UIMA CAS Consumer to import and/or export annotations in GrAF from UIMA. We also provide a MASCCorpusReader to import all MASC data and annotations into NLTK and a tool that renders GrAF annotations for input to the GraphViz 26 graph visualization program, for display of the graphs.
 An independent effort within the European project CLARIN 27 has developed a Python implementation of GrAF 28 and an API for mapping data formats used in language documentation into GrAF and back 29 (Blumtritt et al. 2013 ). Most recently, researchers at Universita  X  t Potsdam developed a GrAF importer for ANNIS 30 (Zeldes et al. 2009 ), a powerful corpus query and visualization application (Neumann et al. 2013 ). 31
The ANC project has also developed a GrAF Compact Syntax (GCS), which represents annotations in a compressed form. The general format of the GCS is:
The GCS provides a means to represent the verbose XML representation of GrAF annotations in a compact way. Information and GrAF-to-GCS and GCS-toGrAF converters are available at http://graf.anc.org/gcs . 9 Next steps LAF and GrAF have been designed to provide a basic scaffolding for linguistic annotations. In principle, GrAF provides no guidelines for naming linguistic categories or organizing or relating specific categories in any way X  X his principle enabled us to identify and focus on the basic mechanisms required to accommodate the structural and referential properties of these annotations. The result is a generic mechanism that can be used as a pivot for interchanging and combining annotations that has proven to satisfy the many requirements for a LAF outlined in the earliest work on LAF [see for example (Ide and Romary 2001 , 2003 , 2004b )].

Complete standardization for linguistic annotation, however, requires much more than the scaffolding that GrAF provides. In addition to standardization of linguistic category semantics, which is the work now being undertaken by ISOCat, it is necessary to establish the inventory and at least a coarse ontology of linguistic objects and features typically exchanged among NLP tools such as tokenizers, POS taggers, parsers, etc. This is especially urgent in the light of the movement toward building language applications from minimally granular modules, implemented as web services, that provide and ultimately integrate various layers of linguistic annotation. These services must necessarily exchange the same object types and know about the features associated with these objects. As a simple example, the object representing a word with its part of speech could be represented as a  X  X  X oken X  X  object with features  X  X  X art-of-speech X  X  and  X  X  X emma X  X , or as a  X  X  X oun X  X  object (for example) with a feature  X  X  X emma X  X . 32
Even a simple set of standard linguistic objects has yet to be widely accepted, but it is essential to establish some basis for communication among web services and other language processing tools in order to advance the field. To this end, a new work item has been proposed within ISO TC37 SC4 WG1 to develop a basic set of linguistic object/feature descriptors, by working from existing proposals developed or under development in a number of recent projects (e.g., LAPPS, 33 Language Grid, 34 Panacea, 35 CLARIN 36 ), together with best practice in the field as shown in, for example, the design of UIMA type systems. Given that there is now a wide base of recommendations and experience together with increasing convergence of practice, this group aims to develop at least a basic scheme relatively rapidly that can serve the burgeoning development of modular web services for NLP. 37 10 Conclusion This paper provides an overview of the final version of LAF and GrAF, together with a description of the development process that led to the final standard. Despite only recently being finalized, GrAF has already been adopted by many projects, including major European projects such as KYOTO, 38 The Australian National Corpus project, 39 and several projects in the BioNLP area. Other projects have relied heavily on GrAF to inform development of standards and resources. Even when GrAF is not adopted wholesale, the work on LAF and GrAF has had a significant impact on the way people think about representing annotation information associated with language data and multi-media. As a result, most if not all newly-developed annotation schemes and formats are based on the LAF abstract data model, and are thus mappable to GrAF X  X hich is in fact all that LAF requires.
 References
 Abstract This paper overviews the International Standards Organization X  X inguis-tic Annotation Framework (ISO X  X AF) developed in ISO TC37 SC4. We describe the XML serialization of ISO X  X AF, the Graph Annotation Format (GrAF) and discuss the rationale behind the various decisions that were made in determining the standard. We describe the structure of the GrAF headers in detail and provide multiple examples of GrAF representation for text and multi-media. Finally, we discuss the next steps for standardization of interchange formats for linguistic annotations.
 Keywords Linguistic annotation Standards Language resources Interoperability 1 Introduction The Linguistic Annotation Framework (LAF) was developed by the International Standards Organization (ISO) X  X  TC37 SC4, the ISO sub-committee on Language Resource Management. LAF was the first work item established by the sub-committee in order to provide a broad framework for more specific standards for representing linguistic annotations that have been and continue to be developed in other SC4 working groups. The earliest work on LAF involved identifying the fundamental properties and principles for representing linguistic annotations, and led to the design of an abstract data model that has since served as the basis for SC4 standards for lexicons, 1 morpho-syntactic and syntactic annotations, as well as a range of semantic annotation types.

Despite its early start, and while several of the SC4 standards that depend on LAF have been approved and published over the past eight years, LAF has only recently been finalized. However, the overall LAF architecture has not changed since 2001; what has changed is the implementation of a concrete representation format that satisfies the LAF criteria for expressive adequacy, media independence, flexibility, processability, and X  X erhaps most critically X  X appability to the objects and relations in a variety of formats suitable for different tools and applications. In 2007, the Graph Annotation Format (GrAF) (Ide and Suderman 2007 ) was introduced as the final XML serialization of the LAF abstract data model; it has since been modified slightly in response to input from experience with full-scale implementation in two multi-layered corpora [OANC 2 and MASC (Ide et al. 2010a )] and implementations for multi-media data, as well as issues that have arisen in the course of developing the ISO standards for specific annotation types. The ISO standard describing LAF and GrAF is published as ISO 24612:2012 (ISO 2012 ).
This paper provides an overview of LAF and describes the GrAF XML pivot format, as well as the process and rationale for decisions that fed its final form. For completeness, we provide an outline of the LAF architecture, although this has been described elsewhere (Ide and Romary 2001 , 2003 , 2004b , 2007 ). We describe the structure of the GrAF headers in detail, as this has not been presented elsewhere, and provide multiple examples of GrAF representation for text and multi-media. Finally, we discuss the next steps for standardization of interchange formats for linguistic annotations. 2 Background The motivation for developing LAF is to provide an architecture for annotated language resources that can serve the needs of all the annotation activities in the field of computational linguistics and offer full interoperability among annotation formats. At the time of LAF X  X  initial development, most annotation formats were developed without any underlying data model in mind, and choices were often primarily driven by the needs of particular processing software. Exceptions were the Corpus Encoding Standard [CES, the SGML predecessor of the XML version, the XCES (Ide et al. 2000 )], 3 which was an early attempt to provide a more principled scheme for linguistic annotation, and which introduced the concept of  X  X  X emote markup X  X  [eventually called  X  X  X tandoff markup X  X  (Thompson and McKelvie 1997 )]. Later, annotation graphs (AG) (Bird and Liberman 2001 ), developed primarily for read-only speech data distributed over a timeline, were introduced and subsequently widely adopted in the field. Neither scheme was entirely satisfactory: the XCES was not comprehensive enough for many types of linguistic annotation, and AG posed problems for representing hierarchical relations such as syntactic phrase structure. 4 LAF X  X  development takes these and other established best practices as a starting point for identifying a more comprehensive and general model for representing linguistic annotations.

LAF identifies a set of fundamental principles to inform the development of the architecture. One of the most important is the clear separation of annotation structure , i.e., the physical format of annotations, and annotation content , which includes the categories or labels used in an annotation scheme to describe linguistic phenomena. A related principle, although seemingly obvious, is the requirement that all annotation information be explicitly represented. Some schemes rely on implicit knowledge about particular categories and relations to be interpreted correctly; for example, brackets may signal that the components are a set of alternatives, or that they comprise an ordered list; it is necessary to have knowledge of the categories themselves to determine which applies. This is in itself a major obstacle to interoperability, because processing the annotations often requires the use of specialized software in which this knowledge is embedded.

Based on these principles, the LAF architecture comprises two distinct parts: (1) a data structure for representing relations among annotations, together with a mechanism for associating linguistic categories with appropriate parts of that data structure; and (2) a means to define linguistic categories that is not tied to a specific theory or naming convention. Part (2) ensures semantic coherence; from the outset it was envisaged that this would be provided by a registry of linguistic categories and features that would be universally accessible for reference (Ide and Romary 2004a ). This plan eventually led to the creation of ISOCat (Kemps-Snijders et al. 2009 ), which has become a stand-alone effort independent of LAF development. Work on LAF is therefore focused on part (1): the development of an abstract data model for the structure of annotations that could be serialized in a  X  X  X ivot X  X  XML represen-tation format, into and out of which user-defined formats could be mapped for the purposes of interchange and merging. As a result, LAF has nothing to say about annotation content, per se; however, full interoperability for linguistic annotations requires standardization of some organizational practices for interchanging linguistic information that fall in the intersection of representation format and semantic content. See Sect. 9 for a discussion of next steps for extending LAF to accommodate this need.

The LAF data model must capture the general principles and practices of both existing and foreseen linguistic annotations, including annotations of all media types such as text, audio, video, image, etc. in order to ultimately provide common mechanisms for handling all of them. In addition, the model has to allow for variation in annotation schemes while at the same time enabling comparison and evaluation, merging of different annotations, and development of common tools for creating and using annotated data. To accomplish this, LAF adopts two well-established, generalized data structures: the graph, for representing objects and relations, and feature structures for representing linguistic information. The complete LAF data model ultimately includes (1) a structure for describing media, consisting of anchors that reference locations in primary data, and regions defined in terms of these anchors; (2) a graph structure , consisting of nodes, edges, and links to regions; and (3) an annotation structure for representing linguistic information with feature structures. The data model for annotations thus comprises an acyclic di-graph decorated with feature structures (coupled with a moderate admixture of algebra, e.g. disjunction, sets), grounded in n -dimensional regions of primary data. The graph itself is a generalization of models for a wide range of phenomena, including syntax trees, semantic networks, W3C X  X  RDF/OWL, the Unified Modeling Language (UML), entity X  X elation (ER) models for databases, etc. X  X ot to mention the overall structure of the web, as a dense inter-connected network of effective objects X  X nd grows naturally out of pre-existing annotation models, including Annotation Graphs (Bird and Liberman 2001 ) and XML-based formats such as the XCES (Ide et al. 2000 ). However, LAF differs from other graph-based annotation models in a few significant ways: 1. Nodes in the graph do not represent annotations, but rather they are simply 2. Nodes may be associated directly with a region or regions in primary data or 3. Edges in the graph are first class citizens of the data model. In many data A rendering of the LAF data model in the Unified Modeling Language (UML), 6 which reflects the roles and relationships among nodes, edges, and links, is given in Fig. 1 . The figure also shows that each annotation is associated with an AnnotationSpace ; like namespaces in XML, AnnotationSpaces enable disambigu-ation of homonym labels, which can occur when two or more annotations of the same phenomenon from different sources are merged. They are also commonly used to identify logical groups of annotations, such as annotations in different linguistic layers or tiers that are to be used together (e.g., token annotations that are the basis for a particular syntactic annotation).
 To achieve interoperability among formats while retaining maximal flexibility, LAF prescribes that conformant annotation schemes, either pre-existing or newly developed, are (or may be rendered via mapping) isomorphic to the LAF data model. The mapping between user formats and the LAF abstract data model is via an XML serialization of the data model, called the Graph Annotation Format (GrAF) (Ide and Suderman 2007 ). GrAF thus serves as a reference or  X  X  X ivot X  X  into and out of which annotations may be mapped for interchange, or into which different annotations may be mapped for comparison or merging. We have previously demonstrated the applicability of the model to a wide range of pre-existing annotation types and schemes (Ide and Suderman 2007 ; Ide et al. 2011 )asa proof-of-concept that the model can accommodate a broad range of linguistic annotation types. The Manually Annotated Sub-Corpus (MASC) (Ide et al. 2010a ) provides a concrete example where the GrAF rendering enables full interoperability among diverse annotations; at the time of this writing, MASC includes sixteen different annotation types, originally rendered in various formats that have been transduced to a GrAF representation so that they can be searched, retrieved, or otherwise manipulated as a single object. So, for example, a user can extract all annotations of a Penn Treebank NP that includes both a named entity of type country and a FrameNet frame element of type food . 7
The overall architecture of a linguistically-annotated resource rendered in GrAF consists of the following:  X  One or more primary data documents , in any medium 8 ;  X  One or more documents defining a set of regions over each primary data  X  Any number of annotation documents containing feature structures associated  X  Header documents associated with each primary data document and annotation We describe these components in the following sections. We describe the headers components. Note that the full description of GrAF, including GrAF schemas and a description of all components, elements, and attributes, is published as ISO 24612: Language Resource Management X  X inguistic Annotation Framework; additional documentation is available at http://www.anc.org/graf . 3 GrAF headers Each primary data, segmentation, and annotation document, as well as the resource as a whole, requires a header. The GrAF resource header plays a key role in providing meta-data for the resource by establishing resource-wide definitions and relations among files, datatypes, and annotations that can enable automatic validation of the resource file structure and contents. All of the headers have been designed with the aim of facilitating the processing of annotations. 3.1 Resource header The GrAF resource header is based on the CES header 9 (which is in turn based on the TEI header 10 ), omitting information that is relevant to single documents. The most important addition is a resourceDesc (resource description) element, which provides detailed definitions of file naming conventions, annotation types, annotation spaces, encoding specifications, data types, etc. All elements in the resourceDesc have an @xml:id attribute, 11 which is used to relate object definitions where applicable. The dependencies among several of these elements are shown graphically in Fig. 3 , which also shows the use of the @suffix attribute for file types and the @extension attribute for media in a sample file name.

The overall structure of the resource description is shown in Fig. 2 ; the relevant elements are described below.  X  fileStruct : Provides the file structure of the resource, including the directory  X  annotationSpaces : Provides a set of one or more annotation spaces, which are  X  annotationDecls : A set of one or more annotation declarations, which provide  X  media : Provides a set of one or more media types that files may contain, the  X  anchorTypes : a set of one or more types of anchors used to ground annotations  X  groups : Definition of one or more groups of annotations that are to be regarded Figure 5 provides an example of a groups definition illustrating the grouping mechanisms described above as well as the use of ids for cross-reference among objects defined in the header. It assumes that declarations of the form shown in Fig. 4 appear elsewhere in the resource header. 3.2 Primary data document header The primary document header is stored in a separate XML document with root element documentHeader . The document header contains TEI-like elements for describing the primary data document, including its title, author, size, source of the original, language and encoding used in the document, etc., as well as a textClass element that provides genre/domain information by referring to classes defined in the resource header. Additional elements provide the locations of the primary data document and all associated annotation documents, using either a path relative to the root (declared on a directory element in the resource header) or a Uniform Resource Identifier (URI). 3.3 Annotation documents header Annotation documents contain both a header and the graph of feature structures comprising the annotation. The annotation document header is brief; it provides four pieces of information: 1. a list of the annotation labels used in the document and their frequencies; 2. a list of documents required to process the annotations, which will include a 3. a list of annotation spaces referenced in the document, one of which may be 4. (optional) The root node(s) in the graph, when the graph contains one or more Information about references to other documents is intended for use by processing software, to both validate the resource (ensure all required documents are present) and facilitate the loading of required documents for proper processing. Information about annotation spaces provides a reference to required information in the resource header. When there is more than one tree in a graph, specification of their root nodes is required for proper processing. An example annotation document header is shown in Fig. 12 . 4 Annotation documents Following the header, annotation documents contain a graph or graphs and associated annotations. LAF recommends that each annotation type or layer be placed in a separate annotation document, although in the absence of a standard definition of layers it is likely that there will be considerable variation in how this is implemented in practice. A newly-proposed ISO work item will address this and other organization principles in the near future (see Sect. 9 ).

GrAF defines the XML serialization of the data model, for which the fundamental data structure is a graph consisting of nodes and edges. An annotation is defined as a label and a feature structure that is associated with a node or an edge using the XML representation defined in ISO Document ISO/DIS 24610-1 (ISO 2005 ).

Nodes may be associated with regions in the primary document defined in a base segmentation document, or connected to other nodes in the same or another annotation document by one or more edges. The node element is empty when connected by an edge element to another node in the graph (i.e., when the node is a non-terminal node). A child link element is used when the node refers to a region or regions of primary data (i.e., when the node is a terminal/leaf node).

Annotations associated with a node are represented with a elements that appear at the same level in the XML hierarchy, which have a @ref attribute that provides the id of the associated node. The @label attribute on an a element gives the main category of the annotation; this may be the string used to identify the annotation as described by the annotation documentation, 14 a category identifier from a data category registry such as ISOCat, an identifier from a feature structure library, or any PID reference to an external annotation specification. The LAF recommenda-tion is to use PID references to ISOCat categories wherever possible, in order to move toward greater standardization of category definitions.

If the only annotation information is the label, the a element is empty. Otherwise, it contains the feature structure or feature structures that provide detailed linguistic information. The ISO specification for representing feature structures allows for feature structures of any complexity and supports the full range of operations over feature structures (subsumption, unification, etc.). It also provides a simplified format that may be used for features consisting of simple name-value pairs, for example (see also Fig. 6 ): Edges connect two nodes with @from and @to attributes referring to the node ids, and may themselves be labeled with annotations, using the same mechanism described above. By default, edges from a node represent an ordered set of constituents, where the order is determined by the order in which they are defined in the annotation document. Other relationships may be specified by associating an annotation that provides the relational information with the edge, for example, coreference relations (antecedent, etc.) or temporal links. Like any annotation, annotations providing relational information may include a feature structure with more detailed information, as shown in Fig. 6 . 5 Primary data documents Primary data in a LAF-compliant resource is frozen as read-only to preserve the integrity of references to locations within the document or documents. Thus, a primary data document will contain only the data that is being annotated. Corrections and modifications to the primary data are treated as annotations and stored in a separate annotation document.

In the general case, primary data does not contain markup of any kind. If markup appears in primary data (e.g., HTML or XML tags), it is treated as a part of the data stream by referring annotations; no distinction is made between markup and other characters in the data when referring to locations in the document. Although LAF does not recommend anchoring annotations in primary data by referencing markup, when necessary, XML elements in a document that is valid XML may be referenced by defining a medium type as XML and defining the associated anchor type as an XPath expression. References to locations within these XML elements (i.e., XML element content) can be made using standard offsets, which will be computed by including the markup as part of the data stream; in this case, two media types would be associated with the primary document X  X  file type, as shown in Fig. 7 . 6 Segmentation documents An annotation document is called a segmentation document if it contains only segmentation information X  X .e., delineations of regions in the data that are associated with one or more annotations. Although regions and anchors may also be defined in an annotation document containing the graph of annotations over the data, LAF strongly recommends that when a segmentation is referenced from more than one annotation document, it appears in an independent document in order to avoid a potentially complex jungle of references among annotation documents. 6.1 Regions and anchors Segmentation information is specified by defining regions over primary data. Regions are defined in terms of anchors that directly reference locations in primary data. All anchors are typed; anchor types used in the resource are each defined with an anchorType element in the resource header. The type of the anchor determines its semantics and therefore how it should be processed by an application. Figure 8 shows a set of region definitions and the associated anchor type and medium definitions from the resource header. 15
Anchors are first-class objects the LAF data model (see Fig. 1 ) along with regions, nodes, edges, and links. The anchor is the only object in the model that may be represented in two alternative ways in the GrAF serialization: as the value of an @anchors attribute on the region element, or with an anchor element. When anchors are represented with the anchor element, the region element will include a @refs attribute (and must not include an @anchors attribute) providing the ids of the associated anchors. For example, an alternative representation for region  X  X  X 2 X  X  in Fig. 8 is given in Fig. 9 .

In general, the design of GrAF follows the principle of orthogonality, wherein there is a single means to represent a given phenomenon. The primary reason for allowing alternative representations for anchors is that the proliferation of anchor elements in a segmentation document is space-consuming and potentially error-prone. As shown in Fig. 8 as well as Sect. 7 , the attribute representation can accommodate most references into text, video, and audio; the only situation in which use of an anchor element may be necessary is one where a given location in a document needs to be interpreted in two or more ways, as, for example, a part of two regions that should not be considered to have a common border point. In this case, multiple anchor elements can be defined that reference the same location, and each anchor may then be uniquely referenced. Because of its brevity and in the interests of orthogonality, the attribute representation is recommended in LAF. 6.2 Base segmentation A base segmentation for primary data is one that defines minimally granular regions to be used by different annotations, usually annotations of the same type. For example, it is not uncommon that different annotations of the same text X  X specially annotations created by different projects X  X re based on different tokenizations. A base segmentation can define a set of regions that include the smallest character span isolated by any of the alternative tokenizations X  X .g., for a string such as  X  X  X hree-fold X  X , regions spanning  X  X  X hree X  X ,  X  X - X  X , and  X  X  X old X  X  may be included; a tokenization that regards  X  X  X hree-fold X  X  as a single token can reference all three regions in the @targets attribute on a link element associated with the node with which the token annotation is attached, as shown in Fig. 10 . 16
Multiple segmentation documents may be associated with a given primary data document. This is useful when annotations reference very different regions of the data; for example, in addition to the base segmentation document containing the minimal character spans that is partially shown in Fig. 10 , there may also be a segmentation based on sentences, which may in turn be referenced by annotations for which this unit of reference is more appropriate. 17 Alternative segmentations for different granularities, such as phonetic units, may also be useful for some purposes. 7 Examples Extensive examples of several types of annotations over text are provided elsewhere [see for example (Ide and Suderman 2007 ; Ide and Bunt 2010 ; Ide et al. 2011 )]. Here, we provide one example for text together with examples for multi-media.
Figure 11 shows an original FrameNet (Baker et al. 1998 ) annotation; 18 its GrAF rendering is given in Fig. 12 . Figure 13 shows a fragment of the associated document defining the tokens referenced in Fig. 12 . The FrameNet conceptualiza-grammatical function (GF), phrase type (PT), etc.) in a FrameNet annotationSet , requires re-specifying the start and end locations of the annotated region. The GrAF rendering instead groups the elements of an annotation set as children of a node with the annotation label annotationSet , which are in turn linked to the tokens defined over the text, as shown graphically in Fig. 14 .

The multi-media annotations in Figs. 15 and 16 show a segment of gesture annotation as represented in the video and audio annotation tool ELAN 19 and its GrAF rendering. ELAN X  X  internal representation defines time-slots that specify a temporal offset (anchor) in the video or audio stream and then defines regions bounded by a start ( X  X  X ime_slot_ref1 X  X ) and end ( X  X  X ime_slot_ref2 X  X ) timeslot. This translates naturally into the GrAF serialization, using anchors as timeslots and regions as  X  X  X lignable_annotations X  X , and associating the appropriate annotations with nodes that reference these regions.

Figures 17 and 18 similarly show a segment of spatial annotation of video represented using Anvil (Kipp 2001 ) and its GrAF rendering. Anvil video anchors may consist of a time (frame) reference and a set of x, y coordinates. In the GrAF rendering, the anchor values are given as features of an element annotation, rather than being represented as actual GrAF anchors. This is done to remain consistent with the Anvil XML representation, in which the region being annotated and the trajectory are defined using different mechanisms; and in particular to conform to the Anvil data model, which represents a trajectory as an annotation and feature structure, not directly as links into the media. An alternative representation using GrAF regions and anchors similar to the definition for region  X  X  X 3 X  X  in Fig. 8 could also be used. 8 GrAF support tools and environment All GrAF schemas and full documentation of all elements and attributes is available at http://graf.anc.org/ . An API for GrAF is available at http://graf.anc.org/graf-api/ apidocs/index.html . It provides methods for adding nodes, edges, and annotations to a graph in GrAF format as well as retrieving annotations, features, etc. from the graph. Methods also exist that render annotations in GrAF format in a variety of output formats, such as input to the GraphViz Graph Visualization Software. 20 Two implementations of GrAF in major corpora have been used to inform the GrAF development process, and are freely available via download from the American National Corpus (ANC) website for any use: (1) the Open American National Corpus (OANC) 21 and the Manually Annotated Sub-Corpus (MASC) 22 (Ide et al. 2010a ).

The ANC project provides a web application  X  X  X NC2Go X  X  23 (Ide et al. 2010b ) that comprises a suite of web services for transducing annotations in GrAF to a variety of other formats, including inline XML (suitable for input to XML-aware software); token ? part of speech (with choice of separation character), a common input format for general-purpose concordance software and numerous parsers; word/pos output in a format readable with the Natural Language Toolkit X  X  (NLTK) 24 TaggedCor-pusReader; CONLL IOB format, used in the Conference on Natural Language Learning 25 shared tasks; UIMA CAS (Ferrucci and Lally 2004 ), for input to the Unstructured Information Management Architecture (UIMA) (Ferrucci and Lally 2004 ); and the W3C Resource Description Framework (RDF). The ANC project also provides plugins for the General Architecture for Text Engineering (GATE) (Cunningham et al. 2002 ) to input and/or export annotations in GrAF format, and a stand-alone UIMA CAS Consumer to import and/or export annotations in GrAF from UIMA. We also provide a MASCCorpusReader to import all MASC data and annotations into NLTK and a tool that renders GrAF annotations for input to the GraphViz 26 graph visualization program, for display of the graphs.
 An independent effort within the European project CLARIN 27 has developed a Python implementation of GrAF 28 and an API for mapping data formats used in language documentation into GrAF and back 29 (Blumtritt et al. 2013 ). Most recently, researchers at Universita  X  t Potsdam developed a GrAF importer for ANNIS 30 (Zeldes et al. 2009 ), a powerful corpus query and visualization application (Neumann et al. 2013 ). 31
The ANC project has also developed a GrAF Compact Syntax (GCS), which represents annotations in a compressed form. The general format of the GCS is:
The GCS provides a means to represent the verbose XML representation of GrAF annotations in a compact way. Information and GrAF-to-GCS and GCS-toGrAF converters are available at http://graf.anc.org/gcs . 9 Next steps LAF and GrAF have been designed to provide a basic scaffolding for linguistic annotations. In principle, GrAF provides no guidelines for naming linguistic categories or organizing or relating specific categories in any way X  X his principle enabled us to identify and focus on the basic mechanisms required to accommodate the structural and referential properties of these annotations. The result is a generic mechanism that can be used as a pivot for interchanging and combining annotations that has proven to satisfy the many requirements for a LAF outlined in the earliest work on LAF [see for example (Ide and Romary 2001 , 2003 , 2004b )].

Complete standardization for linguistic annotation, however, requires much more than the scaffolding that GrAF provides. In addition to standardization of linguistic category semantics, which is the work now being undertaken by ISOCat, it is necessary to establish the inventory and at least a coarse ontology of linguistic objects and features typically exchanged among NLP tools such as tokenizers, POS taggers, parsers, etc. This is especially urgent in the light of the movement toward building language applications from minimally granular modules, implemented as web services, that provide and ultimately integrate various layers of linguistic annotation. These services must necessarily exchange the same object types and know about the features associated with these objects. As a simple example, the object representing a word with its part of speech could be represented as a  X  X  X oken X  X  object with features  X  X  X art-of-speech X  X  and  X  X  X emma X  X , or as a  X  X  X oun X  X  object (for example) with a feature  X  X  X emma X  X . 32
Even a simple set of standard linguistic objects has yet to be widely accepted, but it is essential to establish some basis for communication among web services and other language processing tools in order to advance the field. To this end, a new work item has been proposed within ISO TC37 SC4 WG1 to develop a basic set of linguistic object/feature descriptors, by working from existing proposals developed or under development in a number of recent projects (e.g., LAPPS, 33 Language Grid, 34 Panacea, 35 CLARIN 36 ), together with best practice in the field as shown in, for example, the design of UIMA type systems. Given that there is now a wide base of recommendations and experience together with increasing convergence of practice, this group aims to develop at least a basic scheme relatively rapidly that can serve the burgeoning development of modular web services for NLP. 37 10 Conclusion This paper provides an overview of the final version of LAF and GrAF, together with a description of the development process that led to the final standard. Despite only recently being finalized, GrAF has already been adopted by many projects, including major European projects such as KYOTO, 38 The Australian National Corpus project, 39 and several projects in the BioNLP area. Other projects have relied heavily on GrAF to inform development of standards and resources. Even when GrAF is not adopted wholesale, the work on LAF and GrAF has had a significant impact on the way people think about representing annotation information associated with language data and multi-media. As a result, most if not all newly-developed annotation schemes and formats are based on the LAF abstract data model, and are thus mappable to GrAF X  X hich is in fact all that LAF requires.
 References
