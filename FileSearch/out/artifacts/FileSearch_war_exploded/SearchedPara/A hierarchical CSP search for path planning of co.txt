 fi ned by supplying the relevant physical, geometrical, and time-related 1. Introduction
A fi xture is a device for locating, constraining, and adequately supporting a deformable workpiece during a manufacturing operation ( Bi and Zhang, 2001 ). In keeping with current trends in manufacturing, fi xture systems are gradually being transformed to allow increased fl exibility, recon fi gurability, and automation ( Boyle et al., 2011; Leitao et al., 2012 ). A recent example of such approach is the self-recon fi gurable fi xture system, developed within the European SwarmItFIX project ( de Leonardo Girard et al., 2013; Zieli  X  ski et al., 2013 ), primarily targeted at the aerospace industry.

The system uses mobile robotic fi xture agents continuously repositioning to provide support to the thin-sheet workpiece near the moving machine tool ( Fig. 1 ). Hereafter, the term agent refers to a single mobile fi xturing robot consisting of a mobile base, a parallel kinematic machine (PKM) and an adaptable head. This automation solution has undeniable industrial appeal as it eliminates the need for the costly dedicated solid-mold fi currently used for the manufacturing of large thin airplane parts, with the associated increases in production time and the required storage space.
 system is the ability to reliably and automatically generate complete time-dependent path (or motion) plans for the agents' actions ( Gonzalez-Rodriguez, 2011 ). For a highly recon fi system such as SwarmItFIX, the typical combinatorial or global-optimisation approaches ( Choset et al., 2005; LaValle, 2006 )to fi xture planning are of high complexity because of the presence of numerous and non-comparable criteria, related to task descrip-tion, robot design or workpiece arrangement. The emphasis shifts from the search of an optimum to the satisfaction of constraints and a discrete variable setting. Therefore, a natural approach to such a planning task is to view it as a multi-agent constraint satisfaction problem and to modify the solution techniques of discrete constraint satisfaction problems (CSP) ( Russel and Norvig, 2002; Salido et al., 2008 ). In a classic CSP the problem is represented in terms of state variables which satisfy a given set of constraints (a graph of constraints). A state consists of a set of variables, to which eventually values from fi nite domains are assigned. A solution to a CSP is every complete state (with values assigned to all variables) which satis fi es the graph of constraints.
Having de fi ned such a model of the problem, an application-independent re-usable search algorithm can be designed. To get a complete solution algorithm, it is suf fi cient to fi t the search-based control with some agent-dependent data and functions, related to single-variable assignments and constraints.

For the solution of a CSP problem two classes of search algorithms are generally possible: (1) incremental state search  X  adepth-search with backtracking, improved by local ordering of variables and values, and by path prediction ( Kondrak and van Beek, 1997 ), or (2) complete state search  X  an informed search, with a global fringe fringe (e.g. hill climbing) ( Russel and Norvig, 2002 ). A graphsearchalgorithmbutonl y under consistent heuristics ( Pearl, 1984 ). If for some application the design of a  X  judgment is not possible, but one wants to keep the search complexity suf fi ciently low, locally optimal search ( Korf, 1990 )and hybrid methods (optimal search combined with depth-fi rst search) ( Chakrabarti, 1989 ) can be applied.

A hierarchical decomposition of the application domain has been proposed in Papadias et al. (1999) in order to ef fi a CSP search. According to Papadias et al. it is most useful in applications where the number of variables is relatively small (e.g. less than ten), while the domains of values are very large (e.g. more than 100,000 values). Because of this large amount of data a domain decomposition, driven by an appropriate indexing scheme, seems to be an obvious need and this approach has been used to speed up the process of database queries. However, in all existing applications a single CSP process is performed and a single
CSP-search tree is managed. Hence, there is a need for signi change of any type of CSP-search algorithm, to make it dependent on an R-tree for domain decomposition, and to specify subpro-blems within a single CSP process, as every level of the search tree operates on different sub-domains of the variable. The authors of
Papadias et al. (1999) tested several algorithms while focusing of incremental search with the forward checking technique and a local search with a min-con fl ict heuristics. The experiments have shown an advantage of the hierarchical CSP but only with a small number of discrete variables (less than 10) with a suf fi domain (more than 10 5 values).

Multi-agent planning problems are naturally described as distributed constraint satisfaction problems (distributed CSPs) ( Yokoo et al., 1998 ), like problems of distributed task scheduling and resource allocation in information systems ( Salido and Giret, ) or the multi-agent truth-maintenance task in AI applications ( Yokoo and Hirayama, 2000 ). In a distributed CSP, variables and constraints are distributed among multiple agents. A solution to a distributed CSP is a set of values to distributed variables that satis fi es all distributed constraints. A solution to a distributed CSP is not equivalent to a distributed or parallel search. Indeed, in a distributed CSP the distribution of problems is given in advance, whereas in distributed/parallel search any distribution of the problem can be chosen.

Sometimes a CSP can be overconstrained so that no complete solution exists. It has been proposed to deliver at least a partial solution to over-constrained CSPs ( Freuder and Wallace, 1992 ), distributed CSPs ( Hirayama and Yokoo, 1997 ) and also similarly to handle hierarchical distributed CSPs ( Hirayama and Yokoo, 2000 ). In partial CSP, one tries to fi nd assignments that minimise the importance value of violated constraints. This is achieved by employing a problem relaxation technique expressed in terms of removing constraints. Hence, the basic CSP is extended to a partial CSP by de fi ning a set of relaxed CSPs and a partial order over them based on a distance function. Additionally, necessary and suf bounds on the distance between an original CSP and some solvable (partial) CSP are de fi ned. A solution to a partial CSP is a combination of a solvable CSP and its solution, where the distance between an original CSP and the solvable CSP is less than the necessary bound. Any partial solution will suf fi ce if the distance value is not greater than the suf fi cient bound. An optimal partial solution has a minimum distance value.

The extension of partial CSP to a multi-agent partial CSP is straightforward ( Hirayama and Yokoo, 1997 ), as for every indivi-dual CSP (one per agent) a corresponding partial CSP is de given above, and a global distance metric is also de fi ned, that combines the distance values of individual partial CSPs. An optimal partial solution has a minimum global distance value.

When combining multi-agent (distributed) partial CSP with a hierarchical approach, it was proposed to build the hierarchy of relaxed CSPs by de fi ning importance values of individual con-straints ( Hirayama and Yokoo, 2000 ). Thus, the particular agents try to fi nd assignments that minimise the maximum importance value of violated constraints over agents.

Let us observe that our speci fi c application problem (and also many other industrial applications) can be considered both as a multi-agent planning (because at least two mobile supports are needed) and a hierarchic planning problem (because each agent is composed of three main mobile parts). To fi nd a path and time plan for several constrained parts of several agents means here to fi nd a consistent and timely synchronised combination of actions under some inner agent's constraints (workspaces of parts, motion constraints), between-agent constraints (collision-free paths) and outer constraints (due to the workpiece and CNC machining process). A natural consequence is to handle the planning problem as a hierarchic CSP (but with the decomposition made according to parts and not agents) and a partial CSP (but without direct relaxation of the constraints, while fi nding a subset of consistent variable assignments).
The remainder of the paper is organised as follows. The industrial application case  X  the design of cooperating fi agents and their general path and time planner are presented in Section 2 . The hierarchic CSP framework  X  its application-independent search algorithms and required problem de fi nition interface  X  is presented in Section 3 . It is also introduced how the particular path planning problem can fi t into this general frame-work. A detailed implementation of the path planner in terms of the hierarchic CSP framework is the scope of Section 4 . Particular agent-dependent constraints and functions needed to represent the search space for the mobile fi xtures are given. Examples of experiments are presented in Section 5 . The fi nal section presents conclusions of this work.
 2. The application problem 2.1. Cooperating mobile fi xtures
The industrial application is illustrated in Fig. 1 . The machined object is a stationary thin-sheet workpiece, which is subject to a sequence of processes (such as milling, holing, or drilling) by a moving machine tool, i.e. an instance of the general task .
The part is held in place by a limited number of static fi ( Fig. 1 ) that can support its weight but cannot adequately resist the large machining forces. The latter task is ful fi lled by two (or more) mobile robotic agents that follow the progress of the machine tool and alternate to provide support of the piece in the immediate vicinity of the machined area.

As mentioned above, every mobile unit, referred to as a physical agent, is composed of a mobile platform, a parallel kinematic machine (PKM) ( Neumann, 2008 ) fi xed to the mobile platform, and an adaptable head ( Avvenente et al., 2010; Mol fi no and Mol
The manipulator is placed on a mobile base capable of rapid locomotion along and secure instant docking to a fl at (but not necessarily horizontal) bench ( Li et al., 2011; Zoppi et al., 2011 ).
The proposed system works in the following way. The object (a thin sheet workpiece, a panel) is introduced into the work-cell manually. Static clamps fi x the workpiece initially and locate it accurately, except for sagging due to gravity. The supporting robots move to the vicinity of the place of machining to rigidly support the workpiece so that the CNC machine can perform its operation in that location. The robots relocate themselves over a bench, which contains docking elements. The docking elements form a mesh of equilateral triangles. The base of the robot, when supporting the machined panel, is docked to three adjacent dock-ing elements forming a triangle. During transfer to another location it detaches from two of the docking elements and rotates itself around the one that remains attached to the bench. Once the robot is again securely locked to the bench the PKM lifts the supporting head to the prescribed location, thus providing support to the machined metal sheets. Initially the head is soft, but once it has reached the prescribed location it is solidi fi ed and vacuum is applied to suck the sheet to the head, thus holding it fi The panels are either subjected to drilling or milling. 2.2. The planner
The primary goal of the planner is to generate the path plan and the time-related execution plan for mobile fi xtures ( Fig. 2 ). The supporting agents must guarantee stable support at the region of the workpiece being currently machined. The required support stability for a given machining process is achieved when a set of constraints on the relative location of the tool and the supporting heads is satis fi ed. Moreover, for each agent, the supporting head can move continuously but must remain within the workspace of the PKM, while the mobile bases can only make discrete displace-ment steps between a fi nite set of locations, as determined by the docking and locomotion subsystems. Furthermore, motion speed must match the motor constraints. 2.3. Workpiece modelling
The goal of workpiece modelling is to analyse the path of the tool on the workpiece and to decompose it into segments. For example, before the path planning for a milling process will start, the milling contour is divided into line segments separated by vertices. In practice, an equilateral triangular head is used with circa 70 mm sides. In general, a contour's segment is a polyline with many intermediate line endings ( corners ), and two segment endings called vertices . One can expect the length of a line segment to be equal to or larger than the side length of the head. conditions: (1) it marks a line segment ending, i.e. a point at which a rapid (2) two consecutive vertices should be connected by a suf points of segments) if their angles are larger than 120 o at a small distance (as compared to the head-side length) to a  X  dominating  X  corner (i.e. with a lower vertex-type index). Hence, some more corners are fi ltered from the vertices list in order to avoid small-size segments. This leads to the classi fi cation of segments into: type 1 (a single-line segment), type 2 (a many-line convex segment) and type 3 (a many-line concave segment). 2.4. The path planner of a hierarchic CSP search process. The path planner is composed of the Main control module and three path planning modules (CSP 1, CSP 2, CSP 3), which are called: Head-CSP, Base-CSP and PKM-CSP. path-and time-plan creation for current environment parameter setting. In particular its goal is to react of failures of the plan creation process. A failure means that at some contour segment no on-line continuation of the fi xture plan will be possible. Then the machining process must be split into several parts or the control asks for environment parameter change.
 subpart of the contour, starting at the  X  failed  X  vertex. hierarchic CSP process. By applying an incremental state-space search with backtracking, these modules create head paths, base paths, and PKM paths, respectively. 2.5. Time plan de fi nes a time schedule for actions contained in the path plan. The actions of agents are performed sequentially according to a time plan. The state of every part of every agent (a vector variable) contains, among others, two time points: the time point of latest possible action end to reach current position (state) and the time point of earliest possible action start to move to next position (state). 3. The hierarchic CSP search 3.1. CSP de fi nition as follows:
There is an action set A , where each action, a k A A , means a transition between two states: a k : s i -s j .

A graph of constraints, C  X  x  X  , specifying allowed combinations of values for subsets of the variable set.

To solve a discrete CSP means to search for assignments to a fi nite set of variables: f X i  X  d i j i  X  1 ; ... ; N g , where X variables and assigned values, respectively. Typically, a solution to a problem represented as a CSP is found by a (partly application-independent) depth-fi rst search with backtracking in the decision tree of alternative assignments to given problem variables.
A solution to the CSP is every complete assignment (i.e. a path from root node to terminal node of length N ) that satis fi of constraints ( Fig. 3 ). A complete state s  X  X  x 1 d
C  X  d ; d 2 ; ... ; d n  X  X  True . With such a model of the problem an application-independent re-usable search algorithm can be designed. Then, it is suf fi cient to fi t the search-based control with some agent-dependent data and functions  X  related to single-variable assignments and constraints  X  to design a complete solution algorithm. 3.2. Incremental search for CSP
This is a tree search problem in which every solution appears at depth n of the search tree, where n is the number of discrete variables (or assignments). Typically a strategy of depth-fi rst search with backtracking is applied. In this strategy the search operates on assigned to variables. Speci fi cfeaturesofthisstrategyare:
Initial state is a state with the empty assignment to each variable.

A state expansion means to generate possible successor states of current state s by assigning a value to an unassigned variable in s . The application-dependent subroutine that returns the set of competitive expansions will be called as NextNodes().
The consistency test : check that the constraint set is not violated by existing assignments. This will be implemented by an application-dependent subroutine ConsistencyTest().
The backtrack step : reverse the last action and try another action if no legal assignments of current state exists or no goal state can be reached from this state.

The goal test : the assignments in current state must be complete and must satisfy the constraint set. This will be implemented by an application-dependent subroutine
StopTest(). 3.3. A partial CSP search
In our approach the CSP search not necessarily has to return a success, i.e. a complete solution. It is the case of a workpiece being too complex to be machined without a static re-fi xturing. Then, our CSP search should deliver a partial plan. Thus one has to modify a typical incremental search for CSP in order to track the current plan and collect partial solutions as well.

Observe the strategy de fi ned in Tables 1 and 2 . The recursive subfunction RecursiveBacktrackPartial stores the current partial plan in a collection called solutions . In case of success (complete solution found) this collection will contain the only complete solution, but in case of failure there will be alternative (most largest and unique) partial solutions returned (consisting of a sequence of variable-to-value assignments).

In the main function CSPSearchPartial the best solution (even-tually a partial one) is selected and thus it provides at least a partial plan (if not a complete one) for the workpiece contour. 3.4. A complete CSP search
The partial plan is allowed only for the head path plan. In our hierarchic CSP approach the consistency check for a single assign-ment of a head variable includes an immediate call to CSP search for a corresponding base plan. Remember that the CSP variable for heads corresponds to an array of head positions allocated for a single contour segment. The veri fi cation of this (array-like) assign-ment consists of a run of CSP search for bases and another complete run of CSP search for the PKM-s. The eventually detected plans for bases and PKM-s are limited in range to a single contour segment, the currently assigned CSP-head variable. As these two CSP searches play a veri fi cation role, there should be complete solutions obtained for these limited CSP problems.
 A typical incremental search for complete CSP is given in Tables 3 and 4 . Here the recursive subfunction RecursiveBacktrack has only to store current partial plan and there is no need to select among many partial solutions in the main function CSPSearch. 3.5. Computational complexity
Computational complexity expressed in terms of the number of expanded search tree nodes is comparable to the complexity of a depth-limited search ( Russel and Norvig, 2002 ). (There is a limit value, since the limitation is due to the backtracking step and a particular execution depends on whether the constraints are satis fi ed or not.) The expected computational complexity is determined by the number of visited search tree nodes and the number of constraints checked during the search process.
The number of search tree nodes depends on two parameters of a single CSP search: N , the number of variables and B , the average branching factor of the tree. For a complete CSP search the expected number of visited nodes is Nodes  X  B ; N  X  X  1 2  X  i.e. the tree is expanded to half of the depth and width before a solution path of length N is found.
 For a partial CSP search the expected number of visited nodes is Nodes P  X  B ; N  X  X  3 4  X  i.e. the tree is alternatively expanded to half of the depth and to a full width, when no complete solution is found, or it is expanded to half of the depth and width, when a complete solution exists. following meaning: the planner is also in fl uenced by the number of constraints de fi ned for the variable set. To make the times of node visitation (and expansion) comparable with times required to calculate predicates for these constraints, let us model them as follows:
Under the above assumptions, the expected computational com-plexity of a complete CSP search is given as
O  X  B ;
N ; C  X  X  1 2 B 1  X  C N  X  B 2 1  X  2 C N  X   X   X  B N = 2 1  X  N
O  X  B ; N ; C  X  X  1 2 B N = 2 1  X  C 2  X  res fg :  X  3  X  A comparable complexity of a partial CSP search is O  X  B ;
N ; C  X  X  3 4 B 1  X  C N  X  B 2 1  X  2 C N  X   X   X  B N = 2 1  X  N O  X  B ; N ; C  X  X  3 4 B N = 2 1  X  C 2  X  res P fg :  X  4  X  Thus, the expected computational complexity of both CSP algorithms is polynomial with respect to the branching factor, exponential  X  with respect to the number of variables and linear  X  with respect to the number of constraints per vari-able.

In the hierarchic CSP approach the fi rst (upper) layer CSP 1 is assumed to be a partial CSP, while the lower layers (CSP 2, are complete CSPs. For simplicity, let us estimate the computa-tional complexity of the triple-CSP case, as given in our applica-tion. The particular parameters are:  X  B 1 ; N 1 ; C 1  X  ; N ; C 3  X  . The inherent assumption of the hierarchic CSP is that N r N 2 r N 3 , i.e. there is a non-decreasing number of variables in CSP 1, CSP 2 and CSP 3 when moving from top to bottom of the hierarchy. Thus, after each next assignment to a variable in CSP 1, a  X  local  X  CSP 2 search is called by the ConsistencyTest() (a search  X  means that it will assign values to those variables in CSP 2 only, that are related to variables in CSP 1, already assigned by the upper-level CSP search). In turn, a single variable assignment in CSP-2 search is  X  veri fi ed  X  by a call to a  X  local  X 
When all CSPs are solved by a single CSP, a nonhomogeneous search process is needed (with different structures of variables and constraints). The computational complexity of such a single partial CSP depends on:
The total number of variables, which is the sum of the variables of individual problems: N s  X  N 1  X  N 2  X  N 3 .

The average branching factor, which is a weighted average of branching factors: B s  X  1 = N s  X  i  X  N i B i  X  .

The average number of constraints that are checked with a new assignment: C s  X  1 = W  X  i  X  N i B i C i  X  , where W  X   X  For a single partial CSP search the expected complexity is O  X  B s ; N s ; C s  X  O  X  B s ; N s ; C s  X  X  3 4 B N s = 2 s 1  X  C s 2  X  res s fg
The complexity of the hierarchic triple -CSP can be estimated as follows: Nodes 1  X  3 4  X  Nodes 2  X  Nodes 1 0 : 5  X  O  X  B i ; N i ; C i i  X  1 ; 2 ; 3  X  O  X  B i ; N i ; C i j i  X  1 ; 2 ; 3  X  X  3 16 B N 1 = 2 1 B N different parameter settings. The comparison of results for a single
CSP search, that integrates three sets of variables, and the proposed hierarchic CSP search, clearly documents the ef fi advantage of the second approach. 4. Hierarchic CSP search-based path planning 4.1. CSP variables and discrete domains nents of each agent,  X  h i ;  X  b i ;  X  p j , containing the consecutive locations of heads, bases, and PKMs, respectively. Let us limit the illustration to two agents only and to a one-to-one correspondence of head-to-base states. Then the fi rst agent's head and base states are indexed by odd numbers, while the second agent's states even numbers. There are several states (for example 5) of the PKM corresponding to a pair of head-base states. Hence, the index not directly related to the index  X  i  X  . A transition between two consecutive states of one agent is speci fi ed together by: 1. a head transition h i -h i  X  2  X  there is an appropriate rotation around the local Y H axis performed, while the main movement of head is resulting from a sequence of actions of the base and the PKM; 2. a base transition b i -b i  X  2  X  there is an appropriate rotation of the mobile base performed by 0 1 , 7 60 1 or 7 120 1 (this action may be empty when the same base state is needed for consecutive head states); 3. a sequence of PKM states p j -p j  X  1 - X  -p j  X  5 , where the state p j corresponds to  X  h i ; b i  X  and state p j  X  5 to  X  h i  X  2 transition between 2 consecutive PKM states is de fi ned in the object space.

In general, the state variables for the heads, the mobile bases and the PKMs are real-valued vectors. This would lead to an in fi nite number of possible positions and con fi gurations of the agent. But a discrete CSP can ef fi ciently handle only a space. Therefore, the continuous domain of each variable needs to be approximated by a fi nite set of discrete values taken with suf fi cient resolution.

For example, if a parameter representing a rotation angle can take values from a continuous interval, [ 30 1 ,30 1 ], then one might be satis fi ed with an approximation with resolution of 1 a set of 61 discrete angle values: f 30 ; 29 ; ... ; 0 ; ...
The resolution of relative discrete locations for a single head can be set to: n n , where n  X  1  X  X  2 D max = D min  X  (for the de of D max ; D min see next subsection).

Even with such a necessary digitalisation, the number of domain values can be very high. Fortunately, for most of our CSP variables there exist local optimisation criteria, that allow to order the domain values starting with the most promising ones. For example, looking for a relative orientation of the head triangle along a workpiece contour the parallel-to-contour orientation (i.e. with angle value 0 1 ) is selected as the best one. 4.2. Head path planning by partial CSP search
This planner module is designed as a partial CSP search with matrix-like variables. Each variable corresponds to a sequence of heads for a single segment of the workpiece contour. Thus, in a single assignment step a sequence of head positions is assigned at once.

The Head-CSP module is executed by a call from the Main control module. This occurs once for the entire contour, or one time per part of the contour if there are break points and multiple sub-plans are generated. A CSP search requires application depen-dent data and functions to be supplied. In the case of Head-CSP ,a set of head variable constraints and a function generating alter-native head variable assignments, are needed:
Head-workpiece constraints : A labelled graph and a program code for the meaning of predicates.

Next-Head : Application-dependent program code for the gen-eration of alternative head variable assignments, which corre-spond to successor nodes of the search tree in a given state of the CSP-search process.

In a single extension of the search tree by Head-CSP head states are assigned to one contour segment. For ef fi ciency reasons, before making the next extension, it is useful to check whether suitable corresponding base-and PKM-paths can be found. Currently assigned head states are passed to Base-CSP , which eventually returns Failure , or, in case of success, a partial base-and PKM-plan corresponding to the current contour segment. In case of failure, the head planner module performs a backtracking step in order to revise the last segment assignment. 4.2.1. Head constraints
Due to the inherent character of a milling or holing process (during which part of the original metal sheet is cut off) the workpiece can be supported only from one side of the contour. In the fi nal path plan, consecutive head states along the workpiece contour are numbered h 1 ; h 2 ; h 3 ; ... , where odd and even indices denote head locations of the fi rst and second agents (head 1 and head 2), respectively ( Fig. 4 ). Obviously, the assigned values should satisfy the geometric constraints of not having con fl icts with other heads or with the workpiece contour. Please note, that a variable X in Head-CSP search is de fi ned by a sequence of heads allocated for given contour segment (with index  X  i ), i.e. X h head states within of a single variable X i or between two consecutive variables X i and X i  X  1 .

The FEM analysis delivered sets of feasible support regions for a single head or for two heads. Then it is converted into the form of geometric constraints  X  requirements posed onto distances and orientations between heads and machined workpiece contour. Support quality and stability depends on the head-edge distance to the tool. After locating two supporting heads along the machined contour their joined support for every point of the contour can be computed by numeric integration of FEM data over surface patches. The support force depends on the location of each other (distance d h ).

Assuming a required minimum force threshold one can deter-mine the largest allowed distance between contour line and head ( D max ) and the largest allowed distance between two heads ( D i.e. maximum distances for which the force threshold is still satis fi ed. The test of constraint D h also includes an obvious check whether the two heads do not intersect. A constraint D min for machining safety reason. It represents the minimum allowed distance between a head and a contour. 4.2.2. Alternative head assignments
For every CSP search it is an essential to properly order the alternative assignments generated for one variable. For the Head-CSP this means to fi nd the  X  best  X  number of heads (i.e. the lowest acceptable number) and their  X  best  X  positions (i.e. an interpolation between two terminal head positions for given segment) ( Szynkiewicz et al., 2010 ).

The head variable assignment strategy depends on the vertex and the segment types. The head planning step starts with an initial line segment having a start vertex, preferably of Type 0 (the attached angle is below 60 1 ).

After having located the heads at the end-vertices of a given line segment, a sequence of intermediate head locations along this line is generated. Note that for the second and subsequent segments the start vertex has already been assigned a head location, namely the one assigned for the same vertex for the preceding segment.

Depending on the segment length between the two heads at the endpoints, an appropriate number of intermediate head locations is used. If exactly N head-side lengths fi t into the free distance, a standard in-line allocation is selected. Small differences are compensated by adding small intervals between consecutive heads. But when N heads are too much, and N 1 insuf fi cient, for the given distance, a  X  shifted-fi t  X  strategy is selected b): odd-numbered heads are located at a distance of D min from the contour line, while even-numbered heads are offset at D max (or vice versa). In this way, N heads can be allocated along a larger distance. Many other allocation alternatives are possible, as different distances from the contour line can be selected (in the range from D D max ), many distances between consecutive heads (from 0 to D as well as rotated heads are possible. 4.2.3. Regularity conditions
The path planner can return a feasible head path if the work-piece contour is regular , i.e., if it satis fi es these properties: 1. Line regularity: For each segment, at least one head can be placed between the adjoining vertices. 2. Area regularity: The inner area bordering three consecutive edges of a contour is suf fi ciently large to include two consecutive heads.

These are necessary properties  X  required by the applied head allocation strategy. A single segment need to be supported by at least one head position (causing line regularity) and a single head can have up to two  X  active  X  sides (this explains the area regular-ity). In general there is no guarantee that a feasible head plan will be found for regular contours. 4.3. Base path plan
The goal of this module is to fi nd an appropriate base path for a given head path (as related to one contour segment). The solution is again seen as a CSP search. To each Base-CSP variable a single base state corresponding to an already speci fi ed single head state needs to be assigned. From previous module the Base-CSP receives a sequence of head states, given in the path plan related to a single segment of the workpiece contour. Recall that consecutive seg-ments share their vertices, i.e. the last head and base position for one segment is at the same time the fi rst position for the next segment.
 function generating new base variable assignments, must be supplied.
 the next module, the PKM-CSP, is called. A PKM path plan will be generated, corresponding to the existing head and base plans.
In opposite direction, the noti fi cation about success or failure is returned to the Head-CSP. In case of success a path plan is returned with a sequence of base and PKM states, that are consistent with the current head plan. 4.3.1. Constraints for Base-CSP straints ( Fig. 5 ). First, there is a collision avoidance constraint de fi ned for the two agents. An agent's base is supposed to move from its current state, X i 1 , to the next state, X i  X  1 a collision with the other agent's base and head, ( b i ; be avoided. This is checked by the constraint: No _ collision assigned to variable X k and its corresponding head state: In _ workspace  X  b k ; h k  X  ; k  X  i 1 ; i  X  1.
 time is spent to move its base. All base transitions must contain a single unlock  X  lock sequence (one rotation only around some pin).
This is represented by the constraint: Single _ step  X  b i 1 4.3.2. Alternative base assignments docking places on the bench. The locally optimal strategy for base assignments, when head positions are already given, is sum-marised as follows : attain each from the current location of the corresponding agent. In case of equality, positions closer to the line connecting the two head position projections are preferred.

If no such common base centre (serving the two head posi-tions) exists, the next base location corresponds to one head only. It is determined by a single transition into a position within the inverse workspace at the next head location and in the direction of the second to next head.

As a result of the above preference strategy one obtains base plans with a minimum of base locomotion actions. Typically two or three head locations correspond to a single base location.
The transition between two consecutive positions of a mobile base can be decomposed into fi ve steps ( Fig. 6 ). The minimisation of the number and amount of necessary rotations of mobile bases is the most crucial requirement for a feasible time plane. Due to its heavy weight, the mobile base determines in practice the action speed of the entire robot. 4.4. PKM path plan
This module is called by the Base-CSP module and it receives as input a partial path plan with corresponding base and head locations for the workpiece segments, considered so far. The PKM-CSP returns a failure noti fi cation or a partial PKM plan, corresponding to the input data. 4.4.1. Basic sequence of PKM states For a given contour segment, the module generates a path of PKM con fi gurations using the obtained paths of heads and bases. For a pair (predecessor  X  successor) of head and base states, and a given predecessor PKM con fi guration, fi ve consecutive agent states with up to four PKM different postures are generated. Let the successor state is numbered N  X  5 -then the transitions are ( Fig. 7 ):
Transition to state 1: Retracting the head (away from the workpiece surface) in order to avoid collision with the part.
Transition to state 2: Moving the retracted head back to a parking position above the base, to avoid collision with the other agent.

Transition to state 3: A displacement of the base follows. DOFs 1  X  6 remain unchanged. The PKM frame is rotated and the  X  orientation angle changes to the goal value.

Transition to state 4: Moving the PKM so that the head is only a normal approach away from its desired support location.
Transition to state 5: The fi nal approach of the head is executed and the required state is reached.
 Solving the inverse kinematics of the PKM, provides most of the PKM state variable assignments and allows to check if the desired position of the head can be reached with the current position of the PKM base. 4.4.2. Constraints for PKM-CSP
The third CSP search (PKM-CSP) is called for every pair of corresponding base-head states of the current agent,  X  X  b ; h and Head-CSP, given the knowledge of the other agent's base and head state  X  b i ; h i  X  ( Fig. 8 ).

Let us observe that an agent state, S  X  X  h ; b ; p , is an aggregation of states of its three parts. There are three types of PKM constraints: required PKM state p must satisfy the inverse kinematics relation of the agent, i.e. a valid con fi guration of the PKM must correspond to them.
 transition of the current agent from state S i  X  1 ; k 1 to state
S i  X  1 ; k with the currently fi xed other agent (in state S 5. Experiments sections, has been tested in real-life conditions. Various path plans for drilling and milling processes have been generated using the triple-CSP approach. The exact computation time of the planner is not a crucial factor as the plan is computed in an off-line manner.
It turned out, that when the problem is not over-constrained a feasible solution for a typical machining process can usually be found in less than one minute. An over-constrained problem leads in practice to several partial solutions, instead of a single complete one. In the experiments the planner needed up to 30 min to accomplish this task.
 plans for heads, bases and PKMs, as well as the time plan for all positions and actions in the path plans. Let us consider the hole drilling or milling process along the outer contour of the fi rst workpiece. In the experiment the tool speed along di-stances between holes is assumed to be 5 mm/s, while the total time for drilling a single hole is 3 s. The plan contains also a reference time schedule for visiting contour corners (in milling) and holes (in drilling), that allows the agent's con-troller ( Zieli  X  ski et al., 2011 ) to synchronise the plan execution with the CNC machine and to react to unexpected events or time delays.
 constraints and parameters in fl uence the path plan.
 5.1. Workpiece modelling parameters A circle needs fi rst to be approximated by a regular polygon.
Our head allocation strategy requires that every workpiece's line segment is at least equal or longer than the half of the head side length. This may be relaxed for circular and convex contours. The circle approximation is performed during the workpiece model-ling step. In given example, 7 holes need to be drilled around a circle. Let us fi rst approximate the circle by a 7-sided (open) polyline, where the lines are of tangential directions to the circle at the drilling points. The edge lengths are similar to a head side length and the path plan consists of 7 head states. The second approximation uses a 15-sided closed polygon and the plan needs 8 head states ( Fig. 9 ). In both cases the workpiece modelling module creates a contour which consists of a single segment (i.e. a single polyline) only. 5.2. Bench location parameters
Next type of environment parameters represents the relocation of workpiece in the horizontal or vertical plane w.r.t. the bench. First, one can change the height of workpiece location over the bench (a vertical shift). This modi fi cation is needed when the workpiece's height location is outside of the scope of the PKM. In order to get the same effect, dually the agent's height could be changed. At second, the workpiece can be shifted in the horizontal plane w.r.t. the bench ( Fig. 10 ). This modi fi cation is needed when no base plan is found that corresponds to given head plan or when the base movements need to be minimised (for time ef fi ciency). To get the same effect, dually the head arm could be redesigned (enlarged). 5.3. Agent dependent parameters
In order to change agent-dependent parameters one need to redesign the entire agent or at least one of its components (e.g. the head).

First, when the contour contains short line segments and a complete head plan can not be generated, it may be necessary to apply a head of smaller size.

At second, when the workpiece is out of reach of the head, it may be necessary to change the length of the arm that connects the head with the wrist of the PKM;
At third, when some head state has no base state, it may be necessary to change (increase) the PKM workpiece radius w.r.t. the mobile base's longitudinal axis ( Fig. 11 ). 6. Conclusions
This paper discusses the novel use of arti fi cial intelligence tools for the task and motion planning of a fl exible fi xturing system with multiple cooperating mobile robotic agents. The introduced new approach, which views robot task and motion planning as a constraint satisfaction problem (CSP), and the proposed solution in the form of hierarchical search algorithms, makes this work potentially applicable to other automation problems. The consid-ered application case, a self-recon fi gurable fi xture system, is primarily targeted at the aerospace industry. However it can also be applied in the automotive, shipbuilding and other industries, where large thin-walled parts are machined. In order to change the application one needs to supply the search algorithms with appropriate agent-dependent and process-dependent data and to implement functions that are related to the speci fi c search domain and constraints.

The core of the system is the path planner that follows the methodology of constraint satisfaction problems (CSP). In the presented application, the path planning problem is solved for the three parts of each agent (head, mobile base and PKM) in terms of three CSPs. For ef fi ciency reasons, a hierarchy of three incremental CSP searches is proposed. This structure allows to verify single assignments within the head CSP, performed for the head plan, by assignments within the base CSP, and these in turn are veri fi ed by assignments within the PKM CSP.
 Methods referred to as distributed CSP ( Yokoo et al., 1998; Yokoo and Hirayama, 2000 ), hierarchic CSP ( Papadias et al., 1999 ), partial CSP ( Freuder and Wallace, 1992; Hirayama and Yokoo, 1997 ) and hierarchic partial CSP ( Hirayama and Yokoo, 2000 )have been used in the past, but they differ from our approach. A distributed CSP, as de fi ned in Yokoo et al. (1998) or Yokoo and Hirayama (2000) , is not considered in this paper, as the actions of agents have to be performed synchronously in time and typically in an interleaved fashion  X  one after the other.

The hierarchical CSP has been understood as the decomposition of a large domain of values into a resolution hierarchy (e.g. speci fi ed by R-trees that accompany the CSP) ( Papadias et al., 1999 ) or preference (importance) levels of particular constraints ( Hirayama and Yokoo, 2000 ). In our approach, the set of variables of every agent is decomposed into subsets according to part types of agents (e.g. a head, a base and a PKM). Thus, the multi-agent system is not distributed horizontally (into CSPs that can even-tually be solved in parallel) but is decomposed vertically into different CSPs, where the integration of a parent CSP with its child
CSP is performed via the constraint consistency test of the parent search. To the best of our knowledge the use of such hierarchical
CSP searches is a novel technique in the path planning of mobile robots.
 sequence of relaxed CSPs, inherited from a single basic CSP by cancelling particular constraints from the graph of constraints of the basic CSP ( Freuder and Wallace, 1992 ). The solution to a partial
CSP is a complete solution to the nearest relaxed CSP. In our approach, relaxed CSPs are not made explicitly, while the optimal partial solution is not expressed in terms of minimising a distance to a complete graph of constraints but in terms of maximising the number of successfully assigned variables.
 Acknowledgements Program Theme [NMP-2007-3.2-1] within the Project SwarmIt-FIX , Grant No. FP7-214678.
 References
