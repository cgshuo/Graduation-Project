 1. Introduction
On-line analytical processing (OLAP) systems have become increasingly popular in many application areas, as they considerably ease the process of analyzing large amounts of enterprise data. Designed specifically with the aim of better supporting the retrieval of higher-level summary information from detail data, these systems offer substantial additional user-friendliness over general database management systems (DBMSs). The special dimensional data models employed in
OLAP systems enable visual querying, as well as contribute to enable OLAP systems to offer better performance for aggregate queries than do traditional DBMSs. As another example, most OLAP systems support automatic aggregation [34,49] , which means that the system knows which aggregate functions to apply when retrieving different higher-level summaries.
Almost all OLAP systems are based on a dimensional view of data, in which numeric values, termed measures, are char-acterized by descriptive values drawn from a number of dimensions; and the values of a dimension are typically organized in a containment-type hierarchy, where an upper-level value contains several lower-level values, e.g., a diagnosis group con-performed in OLAP analysis, it also limits the abilities of OLAP systems to capture complex relationships in the data. As a result, an OLAP database only captures some of the structure available in the data from which it derives. Furthermore, it is often difficult or impossible to combine data from an OLAP system with data from other sources.
In contrast, object database (ODB) systems excel at capturing and querying general, complex data structures. These sys-tems offer semantically rich data models and query languages that include constructs such as classes, inheritance, complex associations between classes, and path expressions. However, ODB systems do not support aggregate queries well. For exam-
ODB systems are optimized to perform more general types of queries, mostly on the detail level, so the performance for aggregate queries is usually not satisfactory.

Federated database systems [14,25,26,52] support the logical integration of autonomous database systems, without requiring data to be physically moved and while allowing the individual autonomous database systems to function as before.
Federation is a flexible solution that may leverage existing technology and adapt quickly to changing information require-ing approach [57]. This approach has its own advantages, perhaps most significantly in terms of performance when combining data from different databases, but it is very difficult to keep the warehouse data up to date. Thus, it is often The two approaches are complimentary, in that they are appropriate under different circumstances.
When integrating data from databases based on different data models, the traditional approach has been to map all data into one common data model and federate the (logically) transformed data rather than the original data [52,25,14] . In this paper, we adopt an alternative approach that combines data from multidimensional databases (MDDBs) and object dat-abases using a federated database approach, where data is handled using the most appropriate data model and database technology: MDDB systems for multidimensional data and ODB systems for complex, general data. No attempt is made at  X  X  X hoehorning X  the data into one common format, which is unlikely to fit all the data.

Focus is on enabling OLAP-style queries over existing MDDBs to also include data from existing, external ODBs, without ical MDDB for the core multidimensional data. This will allow the data analysis over the OLAP data to be significantly en-riched by the use of the extra object data. Specifically, aggregation safety remains enforced, meaning that incorrect or meaningless extended queries are avoided. As a first step in demonstrating the capabilities of the system, a prototypical, user-oriented query language for MDDBs, termed SumQL, is defined. The concept of a link , which enables the connection of MDDBs to ODBs in a general and flexible manner, is then integrated into SumQL along with object features, yielding an extended language, termed SumQL++.

With this language as a vehicle, it is shown how the system enables using path expressions for referencing data in MDDBs query may be decorated with object data. Finally, MDDB data may be grouped based on ODB data. All extensions are accom-panied by formal definitions in terms of SumQL and the underlying object query language (the ODMG data model and OQL query language [9] are used for the ODBs). The paper X  X  contribution is presented in terms of the SumQL and SumQL++ lan-precision. Other languages such as SQL [36], OQL [9], and MDX [37] may take the place of SumQL++ once enriched with the constructs in SumQL++ that they do not already offer. We also describe how the approach can handle external relational and XML data using an object wrapping.

A prototype has been built [22] that supports the execution of SumQL++ queries over a federation of autonomous MDDBs and ODBs. Performance experiments show that the federated approach in most cases have faster query response time than a tional solution.

The major contribution of this paper is to consider the integrated querying of data from existing independent multidi-mensional and object databases without prior physical integration of the databases, with the objective of giving OLAP users enced by federation with external data and how they may be preserved to ensure safe query results.
The remainder of the paper is structured as follows: Section 2 presents a real-world case study and motivates the feder-ation of multidimensional and object databases. Section 3 introduces the foundations for the MDDBs and ODBs. It describes a prototypical multidimensional data model and its high-level, user-oriented multidimensional query language, SumQL, as well as the central concept of summarizability. It also briefly presents the Object Data Management Group (ODMG) data model and its OQL query language. Section 4 describes the notion of link that connects MDDBs to ODBs, and Section 5 proceeds to describe the federated data model, which incorporates links, and its extended SumQL query language, which enables queries to access information in both MDDBs and ODBs. Section 6 describes how to integrate relational and XML data sources. Section 7 describes the prototype implementation of a system that implements the concepts and techniques formal syntax and semantics of SumQL. 2. Motivation
In this section, we discuss why it is a good idea to federate existing multidimensional and object databases and present a real-world case study that is used for illustration throughout the paper. 2.1. Reasons for federation
Many reasons exist for preferring federating existing MDDBs and ODBs, as opposed to physically integrating these. The generic arguments for federation include leveraging existing technology, accessing the most current information, and allow-ing the autonomous existence of the systems being federated. These arguments also apply in this case, so we concentrate on the advantages specific to multidimensional and object databases.

In many situations, MDDBs only contain abstract summary data and do not contain the base data from which the sum-example, multidimensional databases provided by the Ministry of Health do not permit access to base data, because the base census databases, where only high-level information is disclosed publicly.

In many cases, an organization maintaining a specific database will not allow other organizations to maintain a copy of their database, but will however allow that certain specific queries from external systems are answered. This may be due to of a specific building, but explicitly prohibits other parties to maintain a copy of the database.
Federating MDDBs and ODBs enables a simple and special-purpose MDDB system. An MDDB needs not contain all objects, capturing all information in the MDDB unnecessarily impedes casual use of the MDDB system. Indeed, most OLAP systems The federated approach allows the MDDB to remain simple, while still allowing access to relevant external data. When
MDDB data resides in a special-purpose MDDB system, we cannot use existing database middleware to access it, leading to a need for technology that enables federations of MDDBs and ODBs. Using our approach, the multidimensional schema in the MDDB may be enriched with the extra object data, meaning that the extended MDDB schema becomes powerful en-ough to handle all analysis requirements.

It is possible to obtain better performance when performing multidimensional querying in an OLAP-type system rather than in a general-purpose DBMS. The former type of system typically employs specialized, performance enhancing tech-niques, such as multidimensional storage and pre-aggregation. This performance gain can often outweigh the performance better) performance without the limitations incurred by physical integration. Next, it is easier to formulate multidimensional queries in an MDDB system than in a general (relational or object) DBMS.
This is because an MDDB query language is designed exclusively for expressing multidimensional queries over categories, taking advantage of, e.g., the automatic aggregation implied by the multidimensional database semantics. Even when extending an MDDB language to access object data (as we do in Section 5), it is easier to pose multidimensional queries in the extended language than in a general database query language such as OQL or SQL.

An MDDB system may support the formulation of multidimensional queries that return correct, or meaningful, query re-sults . When building an MDDB, the data may be shaped in order to satisfy summarizability conditions [34]. Briefly, a mul-tidimensional query satisfies summarizability conditions if the query result is correct w.r.t. the real world. For example, summarizing the populations over cities to get summaries for states will produce incorrect results if the populations in towns and farms outside cities are not accounted for. As another example, if patients have several diseases, and we summa-than once. We may enrich an MDDB system with information that enables the system to ensure correctness. For example, we may specify that inventory levels should not be added across time [34] or that patient counts for diseases should not be added. In a general-purpose DBMS, no mechanisms for ensuring correct aggregate results are available.
The federated approach offers additional flexibility when query requirements change. MDDBs may be huge, and therefore rebuilding them may be time consuming. This is true even when using optimized DW evolution techniques (please see Sec-the database. Because of the rebuild time, a rebuild of the MDDB will most likely be refused by the IS department or post-contrast, a new link can be added in a matter of minutes, yielding much faster access to newly required information. This key selling points for the Cohera federated DBMS [23].

An issue may be that the federated approach  X  X  X isturbs X  existing OLTP databases. However, the external object DBs may or may not be OLTP databases, that is an implementation choice made by the system designer, e.g., based on performance con-siderations. There are many examples of object databases that are read-mostly and thus not OLTP systems, so the issue of disrupting OLTP systems is orthogonal to our proposal and thus not investigated further.

Another problematic issue may be that some data integration problems are harder to handle in a federated setting than in important issue when using our approach, due to the relatively simple queries that we perform over the object data, but in some cases, data quality may prevent the correct use of external object data. Performing data cleansing in our approach is however outside the scope of the present paper, and is left for future work.

OLAP and object databases instead of performing physical integration of the databases. 2.2. Case study
The case study concerns data in three different databases, each managed by a separate organization. Each database serves a different purpose, but the databases contain related data. A graphical illustration of the databases is seen in Fig. 1 .
The databases are modeled using the Unified Modeling Language (UML) [38]. Compound boxes denote classes. The class are specified. A  X  X * X  denotes any natural number.

The demographic database is maintained by the Department of the Interior and offers central access to demographic data more cities in each state, and each city has exactly one current mayor.

Next, the admissions database is maintained by the Department of Health and provides an overview of the admissions pat-meric code, determined by a standard classification of diseases, e.g., the World Health Organization X  X  International
Classification of Diseases (ICD-10) [58]. The classification also determines how the diagnoses are grouped into diagnosis groups . Diagnosis groups consist of at least two related diagnoses and a diagnosis belongs to exactly one diagnosis group. For diagnosis groups, we record a alphanumeric code, determined by the classification.

The last database is an epidemiology database maintained by a medical school for research purposes. Data are collected from hospitals, practicing physicians, and insurance companies to obtain a rich overview of the occurrence of diseases.
The database is organized around the diagnoses in the standard disease classification also used in the admissions database, records the number of incidences per year, the number of deaths per year, and whether the disease is dependent on the life-recorded. For symptoms, we record a name and a description of the symptom.

The three databases were built and are used separately, which explains the differences in their information contents. But, we want to use them together, to include information from the demographic and epidemiology databases in queries against the admissions database. Thus, we need to provide at least a logical integration of the databases.
In this case study, the organizations maintaining the separate databases will not allow other organizations to maintain a copy of their database. However, they do allow for certain, specific queries from external systems to be answered. Thus, solution will possess all the advantages described in Section 2.1, both the advantages related to the MDDB system, and in particular the flexibility with respect to new query requirements.

To obtain some example data, we assume a standard mapping of the UML schemas to relational schemas, i.e., one table unique values. Subclasses are supported by sharing of IDs with the superclass. For example, the Contagious Diagnosis sub-sions, and epidemiology databases are shown in Tables 1 X 3 , respectively. 3. Federation data models and query languages
This section defines a prototypical multidimensional data model and query language used for the MDDB component in the federation; and it briefly presents the data model and query language of the federation X  X  ODB component.
The multidimensional model precisely and concisely captures core multidimensional concepts such as categories, dimen-and query language are equivalent in expressive power to previous approaches such as the ones proposed by Cabbibo et al. [8] and Jagadish et al. [30]. The ODB data model and query language is the ODMG data model and OQL query language. 3.1. Multidimensional data model The model has constructs for defining the schema , the instances , and the aggregation properties .
An n-dimensional fact schema is a two-tuple S  X  X  F ; D  X  , where F is a fact type and D  X f T sponding dimension types . A fact type is a name describing the type of the facts considered.

Example 1. In the case study we will have Admissions as the fact type, and Diagnosis , Place , Reason , and Time as the dimension types.
 A dimension type T is a four-tuple  X  C ; 6 T ; &gt; T ; ? that one category type is  X  X  X reater than X  another category type if each member of the former X  X  extension logically contains
We say that C j is a category type of T , written C j 2 T ,if C the hierarchy.

Example 2. Diagnoses are contained in Diagnosis Groups. Thus, the Diagnosis dimension type has the following order on its category types: ? Diagnosis  X  Diagnosis &lt; DiagnosisGroup &lt; &gt; case study.

A category C j of type C j is a set of dimension values e .A dimension D of type T  X  X f C where C ={ C j } is a set of categories C j such that Type  X  C in the individual categories.

The partial order is defined as follows. Given two values e considered as a set containing e 1 . We say that C j is a category of D , written C that e is a dimensional value of D , written e 2 D ,if e 2[
We assume a partial order 6 C on the categories in a dimension, as given by the partial order est value size, &gt; D , contains exactly one value, denoted &gt; . For all values e of the categories of D , e
ALL construct of Gray et al. [21]. We assume that the partial order on category types and the function Anc work directly on categories, with the order given by the corresponding category types.
 Example 3. The Diagnosis dimension has the following categories, named by their type. Diagnosis = {50,51,52}, Diagnosis i.e., logically contains, all the other diagnosis values.
 main is a function M : C 1 C n  X  T . We say that M is a measure for the set of dimensions D ={ D for the categories ? D 1 ; ... ; ? D n . Every measure M has associated with it a default aggregate function f category values. As is the case for SQL, the aggregate functions ignore null values.
 Example 4. In the case study we have one measure, TotalAdmissions , which is the total number of admissions by Diagnosis, Place, Time, and Reason. The default aggregation function is SUM.

The measures associated with each dimension may have different aggregation properties. For different kinds of measures, different aggregate functions are meaningful. For example, it is meaningful to sum up the number of admissions; and be-cause this data is ordered, it is also meaningful to compute the average, minimum, and maximum values. In contrast, in at least some situations, it may not be meaningful to compute the sum (over time) of measures such as the number of pa-tients hospitalized, but it remains meaningful to compute the average, minimum, and maximum values. Next, it makes little sense to compute these aggregate values on data such as diagnoses, which do not have any ordering defined on them. Here, the only meaningful aggregation is the count of occurrences. Whether or not an aggregate function is meaningful also de-pends on the dimensions being aggregated over. For example, patient counts may be summed over the Place dimension, but not over the Time dimension. For additional discussion of these issues, we refer to [34].

By recording what aggregate functions may be meaningfully applied to what data, it is possible to support correct aggre-users that the results may not be meaningful.

Following previous research [33,41,48] , we distinguish between three distinct sets of aggregate functions: R , applicable that may only be counted.
 Considering only the standard SQL aggregate functions, we have that R = {SUM, COUNT, AVG, MIN, MAX}, / = {COUNT,
AVG, MIN, MAX}, and c = {COUNT}. The aggregation types are ordered, c / R . If a set of aggregate functions is meaningful for some data, so are the functions in lower sets.

For each measure M for a set of dimensions D ={ D 1 , ... , D gation type for each dimension. In Section 3.2 we further discuss issues related to correct aggregation of data. Example 5. In the case study, a TotalAdmissions ( Diagnosis )= R .

An n -dimensional multidimensional database (MDDB) is a 3-tuple S  X  X  S ; D ; M  X  , where S is the schema, D ={ D set of dimensions, and M ={ M 1 , ... , M k } is a set of measures for the categories ?
Example 6. The case study has a four-dimensional multidimensional database with Diagnosis, Place, Reason, and Time as dimensions. Thereisonemeasure,the TotalAdmissions ,as describedabove.A graphical illustrationoftheMDDBisseenin Fig.2 . 3.2. Summarizability This section defines summarizability , an important property of MDDBs related to the use of pre-computed aggregates. Intuitively, summarizability captures when higher-level aggregates may be obtained directly from lower-level aggregates.
Definition 1. Given a type T , a set S ={ S j , j =1, ... , k }, where S may occur multiple times.

Summarizability is important since it is a condition for the flexible re-use of computed aggregates. Without summariz-tions, we have to compute the higher-level results from base data, which may be computationally expensive.
It has been shown that summarizability is equivalent to the aggregate function ( g ) being distributive and the mappings ble-counted or ignored.

Summarizability is closely related to the aggregation types defined in the previous section. We use the aggregation types to capture when it is safe to aggregate a measure over a given dimension. If we have aggregated over a non-summarizable aggregate results for the diagnosis groups to compute the result for the entire dimension, as the same admissions will then be counted more than once. We use the aggregation types to prevent this. Problems related to summarizability also occur when we extend the queries over MDDBs to include data from external ODBs, see Section 5 for details. 3.3. The summary query language
The query language of the MDDB component is termed SumQL and is meant to be language that makes it easy for the user to pose aggregate queries over MDDBs. We have chosen to define a separate summary language rather than attempting to augment the object query language, OQL, for querying MDDBs because we wish to refer explicitly to the special data struc-tures in MDDBs.

Using OQL, or some variant thereof, for querying MDDBs would mean that we would have to overload some of the language guage. Also, we would have to introduce OLAP constructs such as measures, dimensions, and hierarchies, which would conflict do not use ODB technology and existing ODBs, rather than providing OLAP-style querying over object databases only.
SumQL is reminiscent of SQL, but includes constructs that reflect MDDB concepts such as measures, dimensions with hierarchically organized categories, and automatic aggregation, thus supporting naturally the expression of aggregate que-ries over multidimensional databases. Using SumQL enables us to concisely and precisely define the extensions for referenc-ing object data.

The general format of a SumQL query is displayed below and explained in the following. Symbol  X  X + X  indicates one or more occurrences and square brackets denote optional parts. The formal syntax and semantics of SumQL are given in Appendix A .
SumQL query ::= SELECT measure +
The SELECT clause contains a list of measures for which a result is to be computed. Unlike in SQL, aggregate functions such as SUM need not be specified; rather, the default aggregation function specified in the schema is automatically applied to aggregate the data. An optional INTO clause follows that specifies the MDDB into which the result of the query is stored. Thus, a SumQL query takes an MDDB as argument and return an MDDB as result.

The BY_CATEGORY clause specifies the aggregation level at which the measures are to be computed. For each dimension not mentioned in this clause, the measures are aggregated over the whole dimension, i.e., the same behaviour as SQL GROUP BY clauses. Effectively, all dimensions and measures not mentioned in the BY_CATEGORY and SELECT clauses are ignored.
The FROM clause specifies either the MDDB from which to aggregate or a subquery that returns an MDDB for further vided. However, the data model and query language can easily be extended to handle this (see [41] for an example). The optional WHERE clause specifies predicates that are applied to the MDDB before aggregation occurs. The predicates can in-or similar to those found in SQL and OQL [9].

Example 7. The following SumQL statement computes the  X  X  X otal Admissions X  measure from the  X  X  X dmissions X  MDDB, aggregated to the level of Year and State, for the years after 1997. The resulting MDDB is called  X  X  X estdb. X  SELECT TotalAdmissions INTO testdb BY_CATEGORY year, state
FROM admissions WHERE year &gt; 1997 3.4. The object model and query language
This section briefly reviews the object data model and query language used by the ODB component of the federation. We use the Object Data Management Group X  X  object data model, ODMG 2.0 [9], and its associated query-language, OQL. The the ODMG data model and the OQL language may be found in the literature [9].

Example 8. Data definitions for the demographic (left column) and epidemiology (right column) databases from the case The  X  X : X  denotes a sub-class relationship, while  X  X  X et h X i  X  specifies a set-valued relationship.
The OQL query language has constructs such as path expressions and class selectors. Path expressions are used to navi-certain subclass.

Example 9. The following query uses a path expression to select the city name only for cities where the current mayor is more than 40 years old. The path expressions navigates from cities to mayors via reference attribute  X  X  X urrent_mayor X . SELECT C.name FROM C IN City WHERE C.current_mayor.age &gt; 40
Example 10. The next query navigates from symptoms to the diagnoses that exhibit those symptoms using a path expres- X  X  X ontagious Diagnosis. X  Thus, only transfer modes for contagious diagnoses with the symptom  X  X  X ough X  are returned: SELECT S.diagnoses[ContagiousDiagnosis].transfer_mode FROM S IN Symptom WHERE S.name= X  X  X ough X  4. Linking databases
This section defines the links that are used to connect MDDBs and ODBs. As mentioned in the introduction, we use explicit links to connect the databases, rather than relying solely on implicit knowledge of relationships among the databases when formulating queries.
 the complete mapping may be unknown because of substitutions for missing data and other types of data cleansing, inter-polation, etc. Second, explicit links are needed when linking an MDDB to an unrelated ODB, i.e., an ODB other than the base data from which the MDDB was extracted. So, we propose to explicitly link even multidimensional data to the base data from which it was derived.

Links are considered separately from the federated databases to better capture their special semantics and to aid the opti-mization of queries involving links. However, links can be physically implemented as part of these databases. to distinguish them. This is because each category and even pair of category and object class may have several links. base terms. Equivalence links occur when a category in the MDDB represents the same real-world entities as does some ob-in C and object ids from class O are explicitly enumerated. Therefore multiple dimension values may be assigned to the same object. Enumerated links are typically used for linking a category in an MDDB and an object class that do not represent the same real-world entities. The actual mapping from dimension values to object ids in an enumerated link may be obtained the purpose of serving in the federation.

Example 11. In our case study, we can specify an equivalence link between the Diagnosis category in the Admissions MDDB and the Diagnosis Class in the Epidemiology ODB by the predicate  X  X  X iagnosis = Diagnosis.Code, X  as the values of the diagnosis category are the codes of the diagnoses. In subsequent examples, we term this link  X  X  X iag_link X .
Example 12. An enumerated link from the Hospital category in the MDDB to the City class in the Demographic ODB may be name  X  X  X ity_link X  for this link.
 L ={( c , o )} between category C and object class O is [1 1] if j L j = j p jj denotes relation cardinality; the cardinality of L is [ n 1] if j L j = j p [ n n ].
 Example 13. The cardinality of link  X  X  X iag_link X  is [1 1] and the cardinality of  X  X  X ity_link X  is [ n 1]. define that a link L ={( c , o )} from category C to object class O covers C if C = p the set of object ids for O .If L covers both C and O , L is complete ; otherwise, L is incomplete . For example, the city of Oakland is not present in the link.
 incomplete links and [ n ] links, which are analogous to non-summarizable hierarchies, require special attention. Interest-
In some situations, it is desirable to have links that are more powerful than enumerated links. For example, the database designer may want to annotate links with what may be termed metadata, e.g., the reason why the link was added, who added the link, or the time interval when the link is valid.
 general solution along these lines X  X hich allows general annotations, including complex object structures with set-valued attributes, references to other classes, embedded objects, etc. X  X ould amount to the reinvention of a complete object model, an unnecessary complication.

Instead, we propose that annotations be stored in a separate ODB, and we propose to store the potentially complex link link to originally.

We do not consider links between ODBs, as this is supported by object database federation systems, e.g., the  X  X  X PM*QS X  multidatabase system [13]. 5. The federated data model and query language
Having described the data models and query languages of the MDDB and ODB components to be federated, as well as a minimal mechanism for linking MDDBs and ODBs, the next step is to provide language facilities that enable OLAP-type que-ries across the entire federation. Specifically, we extend SumQL.

The federation approach presented here has the distinguishing feature that it uses the aggregation semantics of the data erage combine to provide aggregation-safety for queries. 5.1. The federated data model
The federation consists of a collection of independent components, supplemented with additional information and com-ponents that enable functioning of the federation. Specifically, the federation consists of an MDDB, a number of ODBs, and links that interrelate information in the different databases. Formally, a federation F of an MDDB S and a set of ODBs
O ={ O 1 , ... , O n } is a three-tuple F =( S , O , L ), where L ={ L ses in O 1 , ... , O n .

We assume only a single MDDB. Permitting multiple MDDBs introduces additional challenges, e.g., the matching of cat-ation naturally centers around one MDDB: Typical queries concern MDDB measures, grouped by MDDB categories, and it is desirable to actually group MDDB data by categorical ODB data.

Rather than requiring that the MDDB and ODB data comply with one common data model, the federation adopts a multi-paradigm approach [24,4] , where the data remain in their original data models. This approach has previously been advocated in programming languages, where research has been done on how to allow programs to be written that exploit imperative, object-oriented, functional, and logical programming paradigms in a single program [7].

Allowing multiple data models (or paradigms) to co-exist in the federation enables us to exploit the strengths of the dif-solution paradigm, while other problem subsets are better suited for other paradigms.

Like the arguments to queries are federated databases, the results are also federated databases, i.e., query results may have MDDB, ODB, and link components. This closure property mirrors those of the well-known relational, object, and mul-tidimensional data models and query languages, and permits the result of one query to be used in a subsequent query. We allow the sets of ODBs and links, O and L , to be empty. Thus, an MDDB in itself is a federation. 5.2. The SumQL++ language
As our objective is to allow more powerful OLAP queries over MDDBs by allowing the queries to include data from ODBs, we take SumQL as the outset and extend this language. The new, extended language is termed  X  X  X umQL++ X  as it introduces object-oriented concepts into its predecessor, akin to the C++ successor to the C programming language.
The queries we are interested in are the typical OLAP queries that select a set of measures from an MDDB, grouped by a set cates, in order to integrate ODB data. Second, we introduce so-called decorations [21] of SumQL results, which enable ODB data to be returned along with the SumQL result. Third, SumQL is extended to enable MDDB data to be grouped by data belonging to ODBs, i.e., attributes of object classes, rather than just the built-in MDDB categories. 5.2.1. Extended selection predicates well-known dot-notation for path expressions.
 The link that is used to get to the ODB is included in the category expression. A category expression always starts with an
MDDB category, and is followed by an optional part consisting of the link name and a path expression. Inside the path being defined. Nonterminals not defined below are strings. category_exp: :  X  category [.link object_path attribute] object_path: :  X  class_connector j path_list class_connector: :  X  . j  X  X  X  X lass X  X  X  path_list: :  X  class_connector path_element j path_list path_element path_element: :  X  reference_attribute class_connector
Example 15. We want to use the Epidemiology ODB to get the total admissions by year for only the diagnoses for which cough is a symptom. We use the  X  X  X iag_link X  link to do so in the following the SumQL++ statement. SELECT TotalAdmissions INTO testdb BY_CATEGORY Year FROM Admissions WHERE Diagnosis.diag_link.symptoms.name= X  X  X ough X 
Example 16. We use a class selector in the Epidemiology ODB to get the total admissions by year for only contagious diag-noses with the transfer mode  X  X  X ir, X  with the following SumQL++ statement.
 SELECT TotalAdmissions INTO testdb BY_CATEGORY Year FROM Admissions WHERE Diagnosis.diag_link[ContagiousDiagnosis].transfer_mode= X  X  X ir X 
To describe the semantics of this extension to SumQL, we first need some additional definitions. Given a category expres-is an attribute of an object class, the cardinality of E is defined next.

Let R be the set of attribute values resulting from the OQL query  X  X  X ELECT X k , X OP a FROM X IN Y  X , where Y is the class nality of E is defined as the link cardinality of L 0 .

Informally, the cardinality of a category expression is the combination of the cardinalities that we encounter as we go and array types), the result type is a bag.

Example 17. The cardinality of the category expression  X  X  X ospital.city_link.locatedin.name X  is [ n 1] as we only go through [ n 1] relationships and the state name is a key attribute. The cardinality of the category expression  X  X  X iagno-sis.diag_link.symptoms.name X  is [ n n ] because the  X  X  X ymptoms X  reference attribute is set-valued.
The cardinality and covering properties of a category expression affect the meaning of a SumQL++ statement. If the car-[ n ], the predicate will reference more than one attribute value, leading to several possible semantics for the query. For example, the category predicate  X  X  X iagnosis.diag_link.symptoms.name= X  X  X ough X  in Example 15 has a [ n ] cardinality. least one symptom has name  X  X  X ough X . This is the interpretation chosen in the OQL language, and as we also think it is the most sensible to end users, we will also adopt this interpretation.

Similar problems may arise when a category expression E does not cover its starting category C , because L 0 then will be bute value must match the predicate, the meaning is well-defined. The values in C not covered by E will then be excluded O referenced by E .

Formally, the semantics of the extended SumQL++ predicates are as follows. We are given a SumQL++ query Q with a number of category predicates P 1 , ... , P N of the form P
C
L i OP i a i , i =1, ... , n , where C i is a category, L
E . The POP i are the predicate operator parts of P i , i.e., comparison and BETWEEN, IN, and MATCH operators. The V value parts of the predicates.

For each E i , let R i be the set of attribute values resulting from the OQL query  X  X  X ELECT X
OP i a i POP i  X , where Y i is the class that L i links to, and k a modified predicate P 0 i  X  C i IN  X  e 1 i ; ... ; e k i ing with the link, and finally form a (pure) SumQL predicate with the resulting dimension values using the  X  X  X N X  notation.
With Q 0 being the query obtained from Q by substituting all the P links components, which makes sense as the ODB data was only used to select a subset of the MDDB for evaluation. Example 18. We evaluate the query from Example 15 . First we get the result of the query  X  X  X ELECT D.code FROM D IN
Diagnosis WHERE D.symptoms.name= X  X ough. X  The result of this is the set R = { X  X  N 12 X  X  (the code for pneumonia). We then dimension value  X  X  X 12 X . We then form the pure SumQL query:  X  X  X ELECT TotalAdmissions INTO testdb BY_CATEGORY Year
FROM Admissions WHERE Diagnosis IN ( X  X  X 12 X ), X  evaluating it over the Admissions MDDB. 5.2.2. Decorating the query result
It is often desirable to display additional descriptive information along with the result of an MDDB query. This is com-monly referred to as decorating the result of the query [21]. For example, when asking for the number of admissions by hos-pital, it may be desirable to display the name of the city and the name of the city X  X  mayor along with the hospital name.
This can be achieved by extending the SumQL with features for decorating the result. One possibility would be to allow category expressions with path expressions in the SELECT clause, but we advise against this as it would then be unclear which parts of the SELECT clause referred to measures and which parts referred to decorations. Instead, we extend SumQL with an optional  X  X  X ITH X  clause. The extended syntax is shown below.

SumQL query ::= SELECT measure +
Example 19. Using this extension, we select the number of admissions by hospital, decorated with the names of the city and its mayor.
 SELECT TotalAdmissions INTO testdb BY_CATEGORY Hospital WITH Hospital.city_link.name, Hospital.city_link.current_mayor.name FROM Admissions erenced in the WITH clause MUST be part of the BY_CATEGORY clause.

Formally, assume a SumQL++ query Q with category expressions E
C i L i OP i a i , i =1, ... , n , where C i is a category, L
E , the semantics is as follows. For each E i , let R i be the result of the OQL query  X  X  X ELECT X
Y and k i are the class that L i links to and the attribute that L set of tuples L i ffl R i using the concatenation of the category C result of evaluating Q 0 over F , O 0 ={ {Z i }}, and L 0 Thus, the decoration data is returned in the ODB and link parts of the federation and is not integrated into the result
MDDB. This loose coupling of decoration data and MDDB data is essential in avoiding semantic problems, which might other-wise occur if the category expressions E i do not cover the categories C subset of the C i , i.e., we perform an operation equivalent to an outer join. Similarly, no cardinalities for the E Diagnosis value  X  X  X 12 X  (pneumonia).
 and  X  X  X ayor hospital, X  again with the latter as the object identifier. The links have the specifications  X  X  X ospital=City-
Name.Hospital X  and  X  X  X ospital=MayorName.Hospital. X  5.2.3. Grouping by object class attributes
The last extension is to allow the measures of an MDDB to be grouped by attribute values in ODBs, enabling aggregation over hierarchies outside the MDDB. This feature will be used when aggregation requirements change suddenly.
To achieve this, we allow category expressions instead of just categories in the BY_CATEGORY clause. The syntax of the extension is given below. The only difference from the previous syntax is that the BY_CATEGORY clause now is a list of cat-followed by a link, an object path, and an attribute.

SumQL query: :  X  SELECT measure + Example 21. The number of admissions grouped by symptoms may be retrieved as follows.
 SELECT TotalAdmissions INTO testdb BY_CATEGORY Diagnosis.diag_link.symptoms.name FROM Admissions This type of SumQL++ queries will return MDDBs where one new dimension is added for each category expression in the
BY_CATEGORY clause, thereby reflecting the hierarchy specified by the category expression, and aggregation will occur over these new dimensions.
 Formally, given a SumQL++ query, with the category expressions in the BY_CATEGORY clause being of the form E egory, L i is a link, OP i is a object path, and a i is an attribute of the final class of E may be specified as follows.
First, let S 0  X  X  S 0 ; D 0 ; M 0  X  be the MDDB obtained from S as follows. For each E category types &gt; i ; A 0 i , and ? 0 i . Category type A dimension values of the bottom category in S . The ordering of the types is &gt;
For each dimension type, new dimensions D 0 i are added to D 0 . The categories of D category has just the &gt; value. If L 0 i is the resulting link of E specified by  X  e 1 ; e 2  X 2 R i () e 1 2? i ^ e 2 2 C i ^ e values. Let B i  X  R i ffl L 0 i ( ffl is the natural join). Then the values of the category ? 0 sion D 0 i ; 6 0 i , is specified as follows: e 1 6 0 i e The set of measures M 0 is identical to the original set of measures M as the measures operate on the same categories.
If S is a SumQL query itself, we define the semantic meaning of S to be the MDDB resulting from the evaluation of the subquery.

The result of evaluating the SumQL query  X  X  X ELECT M 1 , ... , M result.

Example 22. For the query in Example 21 we get one new dimension type  X  X  X ymptomName X  with the category types  X  X  &gt;
SymptomName , X   X  X  X ymptomName, X  and  X  X  X iagnosis. X  The new  X  X  X ymptomName X  dimension has the categories specified by the category types. The partial order on the new dimension is given by joining the  X  X  X iagnosis, X   X  X  X iagnosis_Symptom, X  and  X  X  X ymptom X  tables from Table 3 and then projecting on the  X  X  X ode X  and  X  X  X ame X  attributes. We note that the resulting hierarchy is non-strict, as the  X  X  X cetone Breath X  symptom occurs for both  X  X  X nsulin Dependent Diabetes X  and  X  X  X on Insulin Dependent Diabetes. X 
Depending on the properties of the E i s, problems may occur in the aggregation process. If E data in the MDDB (the data characterized by the non-covered subset of C in O i . This means that the result of the aggregation function will be undefined for multidimensional tuples containing the non-covered objects. To remedy these problems, we require that the E
Even when the category expressions are complete, special attention is needed to ensure summarizability. Problems may for more than once in the overall result, e.g., for different symptoms.

This result is meaningful and correct in itself because the data belongs to several groups. However, the result should not be used for further aggregation as the same data may then be accounted for more than once for the same group, e.g., we may not aggregate over all symptoms to get the total number of admissions. To avoid this, we set the aggregation type for all measures to c , i.e., we disallow further aggregation on the data, if the cardinality of E [ 1] the aggregation types are not changed.

Finally, we note that it does not make sense to introduce a  X  X  X ITH-like X  construct for the BY_CATEGORY clause. The rea-thus includes it in the BY_CATEGORY clause) or not (and thus leaves it out of the BY_CATEGORY clause). 5.3. Summary
Although the extensions to SumQL were described separately above, they can be used together in one SumQL++ state-ment. Assuming an SumQL++ statement that contains all three extensions, query evaluation proceeds as follows. First, the rules for handling grouping by object attributes are used, producing a statement without object attribute grouping. This a WITH clause, which can then be evaluated using the rules for extended selection predicates as described in Section 5.2.1.
The statement produced by the extended predicate rules is a pure SumQL statement which may be evaluated following stan-dard SumQL semantics. 6. Integrating relational and XML data
We have now demonstrated the capability of our system to logically integrate external object data with OLAP data. How-be able to access relational and XML data as well. This section describes how to integrate such data sources using our approach.

The extension with relational and XML data can be achieved in several ways. One way would follow the  X  X  X ulti-paradigm X  approach of the paper, and extend the current data model and query language with two new sets of constructs for integrat-ing relational and XML data, respectively. For example, for the XML integration, these constructs would be similar to those scope (and size) of the present paper. Instead, we will explain a more pragmatic approach that wraps relational and XML data as object data, and thus allows their integration using the current approach.

Relational data . For relational systems, the mapping to object classes is rather simple. For each table, one object class is a relational DBMS with an OPM object mapping on top of the relational schema. The OPM system already takes care of mapping all OQL data manipulation queries into their SQL equivalents, and we thus need not specify this mapping ourselves.
XML data . The solution for handling XML data is rather similar. We first note that we are only interested in integrating comply with a strict schema, we will have very little knowledge of the possible data values and thus it will be either very risky or entirely meaningless to perform OLAP-style analyses based on such data. In the XML database community, it is com-mon to distinguish between these two forms of XML data, where the structured form is called  X  X  X ML data X  and the unstruc-For regular XML data, the following mapping to object classes is performed. We assume that at least a Document Type
Description (DTD) [59] is available, more advanced schema information such as XML Schema is handled similarly. For each element type, an object class with the same name (if necessary prefixing parent element names for uniqueness) is con-classes. Nested elements are handled by adding a set-valued reference attribute with the name of the nested element in the data manipulation queries, we have to map OQL queries to XQuery/XPath queries. This can be done using the approach of the ST YX system [3]. In summary, we have shown how our approach can also be used for integrating structured XML data in
OLAP-style analyses. 7. Prototype implementation
This section describes the architecture and a proof-of-concept prototype implementation of the OLAP++ federated system capable of answering SumQL++ queries, the query evaluation strategy, and presents performance results obtained with the prototype. 7.1. System architecture
The overall architecture of the federated system is seen in Fig. 4 . The system has six major components: the GUI, the ODB systems, the link DB system, the MDDB system, the federation coordinator, and the metadata database. The ODB, link DB, and MDDB components are treated as independent units by the federation system; only their published interfaces are used, and no assumptions about their internal workings are made. The link component stores enumerated links and is placed in an independent  X  X  X ink X  DB, as it cannot generally be assumed that these links may be stored in some ODB component. Should on federation metadata specified in the metadata database. This allows for a very flexible system that may adapt quickly to changes. For example, if a new connection to an outside ODB is desired, appropriate links just needs to be specified and stored as metadata, after which queries can start using the new ODB. Queries are generated by the GUI and sent to the fed-eration coordinator which then parses the query. Based on the content of the query, the system looks up the relevant meta-data (link specifications, ODB names, etc.) in the metadata database and processes the query according to the metadata by issuing queries to the DB components.

The parts of the system handling object and link data are based on the commercially available OPM tools [10,35,18] that implement the Object Data Management Group X  X  (ODMG) object data model [9] and the Object Query Language (OQL) [9] on top of a relational DBMS, in this case the ORACLE RDBMS. The use of the OPM tools means that it is not important which particular version of the RDBMS is used, e.g., it makes no difference whether the RDBMS has object-relational features or soft X  X  SQL Server OLAP Services using the Multi-Dimensional eXpressions (MDX) [37] query language. The graphical user interface (GUI) is implemented as Java classes running in a standard Web browser for optimal flexibility. The prototype is a proof-of-concept prototype aiming to demonstrate the feasibility of our approach. It handles only extended predicates, not decoration or grouping by object data, as we think that extended selection predicates is by far the most useful of the operations. Since grouping by object data is the only operation that may have an impact on summarizability, it is thus not necessary for the prototype to perform checks for summarizability. 7.2. Query evaluation
The query evaluation strategy is explained using an example. Example 23 below explains how a particular query is processed.

Fig. 5 shows the specification of query conditions. Initially, each dimension is shown with its categories and links to the object database. If a category is selected, a category condition can be entered. In the figure, selections is a concise SumQL++ query, as shown next.
 SELECT TotalAmount INTO testdb BY _ CATEGORY Manufacturer, Nation FROM OrderSummary
WHERE (Region= X  X  X SIA X  X ) AND as a symptom and years later than 1997.
 SELECT TotalAdmissions INTO testdb BY_CATEGORY Diagnosis,State,Year FROM Admissions WHERE (Diagnosis.diag_link.symptoms.name= X  X  X ough X ) AND (Year &gt; 1997)
This query is processed as follows. The Federation Coordinator (FC) parses the query and identifies the link and ODB parts of the query. Based on the link name (diag_link), the FC looks up in the metadata which ODB, object class, and below.
 SELECT code=@n001 FROM @n000 IN SUMDB:Diagnosis, @n001 IN @n000.code WHERE @n000.symptoms.name= X  X  X ough X 
The OQL query is then executed against the Demographic ODB, giving as result the single diagnosis code  X  X  X 12 X . Based on the result of the OQL query, the FC now forms the SumQL query seen below, which is executed against the MDDB component has been transformed into the predicate  X  X  X iagnosis IN ( X  X 12 X ) X  by substituting literal values from the Diagnosis dimension into the new predicate. The new predicate can then be evaluated entirely in the OLAP component. We refer to this process as inlining of the predicate.
 SELECT TotalAdmissions INTO testdb BY_CATEGORY Diagnosis,State,Year FROM Admissions WHERE (Diagnosis IN ( X  X 12 X ) AND Year &gt; 1997) The SumQL query is now translated into the MDX statement seen below and executed against the MDDB managed by MS SQL Server OLAP Services. The reason for using the intermediate SumQL statement is to isolate the implementation of the
OLAP data from the FC. As another alternative, we have also implemented a translator into SQL statements against a relational  X  X  X tar schema X  design.

SELECT [Measures].[TotalAdmissions] ON COLUMNS, INTERSECT (CROSSJOIN(CROSSJOIN([Diagnosis].[N12], [Place].[State].MEMBERS), [Time].[Year].MEMBERS),CROSSJOIN(CROSSJOIN([Diagnosis]. [Diagnosis].MEMBERS, [Place].[State].MEMBERS),
FILTER([Year].MEMBERS, [Time].CURRENTMEMBER.NAME &gt;  X  X 1997 X ))) ON ROWS FROM Admissions
We have now illustrated the amount of work that users will ultimately have to perform on their own, if they are without from them.
 8. Performance evaluation
We now describe the performance experiments that we have carried out in order to validate the practical applicability of our approach.
 Fig. 6 shows the federation schema used for the performance experiments, in UML notation. The schema is based on the
TPC-R benchmark [55]. We have chosen to use TPC-R data for our experiments for two reasons. First, the TPC-R benchmark and its data are well-known to the database community. Second, we did not have access to databases containing the medical information used as examples previously in the paper that were large enough to make interesting performance studies. The schema has been divided into an OLAP part and an object part. The measured facts in the OLAP schema are the total number of orders and the total cost amount for the orders. The facts are characterized by a Supplier dimension and a Manufacturer dimension. The Supplier dimension has Supplier, Nation, and Region categories that allow the facts to be summarized to the has Region, Nation, Supplier, and Part classes and relationships between them. Link nationlink connects the Nation category which means that the database contains around 6,000,000 line items, 200,000 parts, 10,000 suppliers, 25 nations and five regions. The TPC-R based case has only equivalence links, thus the Link Data component is not used in the query evaluation.
The idea of the experiments is to compare the performance of the OLAP++ system with an alternative implementation where all data is physically integrated in the same data warehouse. Dedicated multidimensional OLAP (MOLAP) systems such as MS OLAP Services cannot handle complex data such as irregular hierarchies. Specifically, MOLAP systems cannot latest versions of commercial OLAP software such as MS Analysis Services. This means that a comparison of our federated approach to an integrated DW based on a MOLAP system would not be fair, as the MOLAP system cannot handle data with the same complexity as our federated approach. However, existing RDBMS technology can handle data with this complexity and is also the natural choice for integrated data warehouses for most enterprises. The most logical RDBMS alternative to a given MOLAP system is the RDBMS offering from the same vendor. Thus, we have chosen to compare OLAP++ to an inte-grated relational data warehouse using MS SQL Server 7.0 as the RDBMS.

As a side note, experiments comparing the performance of a federation of OLAP and XML data with the same data phys-ically integrated in a physical (MOLAP) MDDB actually showed that the OLAP-XML federation approach (which has a query processing strategy very similar to the one in our OLAP-object federation) still only entailed a modest overhead (less than 50% for most queries, and in many cases almost no overhead) [43,61 X 63] . This is true both for queries with XML-extended selection predicates and queries that use external XML data for grouping.
 The hardware/software configuration is as follows. The OLAP component of OLAP++ uses MS OLAP Services running under Windows 2000 on a 400 MHz Pentium machine with 164 MB RAM and one disk. The OPM tools runs on top of an Oracle
DBMS under Solaris on a Sun Sparc machine with 1 disk, i.e., quite a modest hardware setup. The federation coordinator also runs on the Sun machine. The relational system uses MS SQL Server 7.0 running on the Pentium machine mentioned above.
Note that OLAP++ runs on two machines, introducing additional communication overhead, whereas the integrated DW runs on a single machine. Thus, OLAP++ would have been faster on a single machine, but we considered the multiple-machine scenario to be more realistic.

We compare OLAP++ to three different configurations of the relational data warehouse:  X  X  X elational with no indexing X  of indexing. We note that the TPC schema used in the experiments is very similar to typical relational DW schemas ( star or snowflake schemas) as all the keys (primary and foreign) are auto-generated numeric keys and thus optimized for the com-parison operations in large joins.
 The first comparison concerns the storage space used by the four different alternatives. The storage use is illustrated in Fig. 7 .

The exact figures are: OLAP++ (414 MB), RNI (1340 MB), RPI (1700 MB), ROI (2620 MB). The figure for OLAP++ consists of 359 MB for the OLAP component, including 10 pre-computed aggregations, and 55 MB for the object data. We see that RNI takes over three times the space of OLAP++, whereas RPI and ROI used more than four and six times the space of OLAP++, respectively. Thus, OLAP++ is far more efficient with respect to storage use. This is due to the fact that the OLAP data in
OLAP++ can be stored using dedicated multidimensional database technology. The storage use of 359 MB for OLAP data should be compared to the approximately 1285 MB (1340 minus the 55 used for object data in OLAP++) used in the relational system. This difference is even more remarkable as the 359 MB even includes multidimensional indices and 10 pre-com-puted aggregates.

Next, we consider the query performance of the four alternatives. As our focus is on OLAP applications, we evaluate a set of TPC-R style aggregate queries that aggregate OrderSummary data to the different levels in the cube, namely Region (Reg),
Nation (Nat), and Supplier (Sup) from the Supplier dimension and Part and Manufacturer (Man) from the Part dimension. All performance for the four different alternatives are seen in Table 4 . The actual queries are given in Appendix B .
The  X  X  X uery X  column indicates the query number. The  X  X  X ims X  column indicates the number of dimensions used in the query, in the BY_CATEGORY and/or WHERE clauses. The  X  X  X iff X  column indicates the level difference between a level used in the BY_CATEGORY clause and the lowest level from the same dimension used in the WHERE clause (0 means same level,
NR means that there are no related levels, i.e., levels from the same dimension, between the BY_CATEGORY and the WHERE clauses). For example, the query  X  X  X ELECT TotalAmount INTO testdb BY_CATEGORY Region FROM OrderSummary WHERE query requires that the OLAP++ system first selects the nations with population &gt; 100,000,000 from the Object database.
Then it provides the nation IDs to the OLAP system as a restriction on the nations to be considered for the aggregate (sum) operation. We would assume that the Dim and Diff columns are a measure of the complexity of the query, the higher come more complex from top to bottom in the table. The next two columns show what levels used in the BY_CATEGORY and
WHERE clauses, respectively. The  X  X  X ond. size X  column shows the total number of dimension values that match the predi-cates in the WHERE clause. For conjunctive/disjunctive predicates, the number of dimension values matching each part of Fig. 8 .

We first note that OLAP++ is always much faster (4.6 times faster on the average) than the RNI configuration. Most of the remembering that RNI uses more than three times the space of OLAP++. More interesting, OLAP++ is faster than the RPI con-OLAP++. For the one query where OLAP++ is slower than RPI, the difference is only around 19%. Thus, we can conclude that of 14 queries, but the average response time for ROI is 44% higher than for OLAP++, meaning that some queries will run slowly for ROI even with the optimized indices. We note that the storage space for ROI is more than six times the space for OLAP++. Thus, we can conclude that OLAP++ performs as well as even the best indexed relational system, using only a small fraction of the storage space.

The main reason for the good performance of OLAP++ is that MS OLAP Services can use optimized MOLAP storage, includ-the database size is four times smaller for OLAP++, the cache performance will invariably be better than for the relational system. Additionally, MS OLAP Services caches both aggregate results as well as detailed data. One could ask whether this is unfair to the relational system (SQL Server). Indeed, SQL Server could have performed much better if materialized aggre-gates were available, but materialized aggregates would have take even more space than the ROI configuration. Thus, top performance for the relational system can only be achieved at a very high cost. Summing up, it is safe to say that OLAP++ will almost always perform better than a relational system (SQL Server or other RDBMSes) for the same storage use, due to the optimized MOLAP storage.
 As a side remark, our measurements show that most of the response time for OLAP++ is spent in the OLAP component.
Apart from this time around 2 X 3 s is spent in the OPM/Oracle system plus the FC to get the object data and form new  X  X  X nlined X  predicates.

If we look into how the performance varies over the queries, we see that neither the number of dimensions, nor the level differences, i.e., the assumed parameters of query complexity, determine the query performance for OLAP++ or any of the times as a function of the condition size. The result is seen in Fig. 9 .
 such queries, i.e., even well designed OLAP systems may not be optimized for queries with large predicates in them.
As a side note, a similar behavior is seen in the above-mention OLAP-XML federation system, where queries with high selectivities (large condition sizes) are not performing as well as queries with a lower selectivity [62,63] .
In summary, the performance experiments showed that in comparison to relational systems, OLAP++ performed approx-tional configuration (RPI), using much less storage space (four to six times less). In comparison to OLAP systems, OLAP++ tems cannot. 9. Related work
Federated database systems [52,25,26,14] support the logical integration of autonomous database systems, without requiring data to be physically moved and while allowing the individual autonomous database systems to function as before.
Federation is a flexible solution that may leverage existing technology and adapt quickly to changing information require-ing approach [57]. This approach has its own advantages, perhaps most significantly in terms of performance when combining data from different databases, but it is very difficult to keep the warehouse data up to date. Thus, it is often
The two approaches are complimentary, in that they are appropriate under different circumstances. This paper tries to com-offering the aggregation safety and a level of performance that is comparable to that of a physically integrated data warehouse.

The issue of providing very  X  X  X resh X  data is also considered by the recent trend of  X  X (near) real-time data warehousing X  [6,46,53] where the goal is to update the DW as quickly as possible when data in the source systems change. However, al-ways keeping the DW updated is only feasible in some situations. In comparison, our approach is useful in other situations where it is more advantageous not to physically integrate all the data.

There has been a great deal of previous work on data integration, e.g., on integrating relational data [23,28,39] , object-line of work, the arguably most related previous work concerned the system based on the n enables the querying of a federation of solely relational data sources, which are treated symmetrically, using n ever, none of these approaches handle the advanced issues related to OLAP systems, e.g., dimensions with (possibly irregu-lar) hierarchies and the problems related to correct aggregation. This renders the formulation of distributed OLAP-style queries cumbersome and errorprone in comparison to this paper X  X  proposal. In contrast, this paper fully supports general dimension hierarchies and aggregation semantics, enabling safe aggregation and shielding the users from incorrect results, while at the same time providing much easier formulation of distributed OLAP-style queries.

When integrating data from databases based on different data models, the traditional approach has been to map all data into one common data model (often called the  X  X  X anonical X  data model) and federate the (logically) transformed data rather
BLOOM data model is used as the canonical data model. In this paper, we adopt an alternative approach that combines data from multidimensional databases (MDDBs) and object databases using a federated database approach, where data is handled using the most appropriate data model and database technology: OLAP systems for multidimensional data and ODB systems the data.

Several papers propose extensions of the Unified Modeling language (UML) for the conceptual multidimensional modeling of DWs [2,40] and one paper uses a conceptual multidimensional model to model OLAP security [47]. Common to these papers (and of course the associated federation mechanisms). This work can thus be considered orthogonal to ours. Indeed, the men-tioned models could be used to model a DW at the conceptual level that was then implemented as a federation using our approach.

The work in this paper builds on previous work on multidimensional data models supporting irregular hierarchies [41,49] and work on ensuring the summarizability of OLAP data [34,41,49] . This previous work is here leveraged in a federated sce-nario where there is much less control over the contents of the data, and thus many more potential problems related to incorrect aggregation, than in a traditional physically integrated DW where such problems will often have been handled dur-ing the warehouse construction phase. The primary tool for supporting correct aggregation is the use of aggregation types [33,41,48] for blocking further aggregation on  X  X  X nsafe X  data. The SQL:1999 standard has some support for OLAP operations [16,29] . However, the explicit support for dimension hierarchies is still not strong. Unlike SQL:1999, our SumQL language offers built-in support for irregular dimension hierarchies and associated support for summarizability checking.
An orthogonal line of work considers the correct and efficient handling of updates of dimensions [15,27] or complete cubes [5,15,31] . In contrast, we do not need to perform any updates on the underlying cube structure and data, and thus save the (still) large cost of updating the physical structures. This line of work can be considered as orthogonal to ours, and one can even imagine a combined approach where our federation approach is used when external data is first que-ried, followed by a physical integration of the most commonly used external data using the techniques mentioned above.
However, in some situations (source data or data requirements changing too frequently, IT department refusing a change of the DW, etc.), it will still not be feasible to physically integrate the data, leaving a federated approach as the only choice.

A related line of work concerns the logical federation of OLAP and XML data sources [43,61,62] , please see [45] for a sur-to the rich and complex semantics that can be captured (and exploited) using the object data model.
The present paper significantly extends two previous conference/demo papers [44,22] . In comparison, the present paper has a much more detailed case study (Section 2.2), gives many more details on the data model, summarizability issues, and aspects (Section 5), provides a new Section 6 on integrating relational and XML sources, provides a new Section 8 with per-formance experiments, gives a more thorough treatment of related work, and gives the formal syntax and semantics of the
SumQL language (appendices). In total, the present paper is approximately twice as long as the conference papers combined. 10. Conclusion and future work
Motivated by the increasingly widespread use of OLAP technology, we have presented the concepts and techniques underlying a prototype system that logically integrates data in OLAP databases with data from outside object databases, without requiring physical integration of the data.

Multidimensional data is best handled using OLAP technology, while complex detail-level data structures are best han-dled with object database technology. The enables the handling of the data using the most appropriate data model and tech-map data into one common data model, which would be sub-optimal for some of the data. To our knowledge, this is the first example of a  X  X  X ulti-model X  federation that includes a dedicated multidimensional data model. We also believe this study to be the first that considers the impact on core OLAP concepts, e.g., summarizability, when federating with external data. In contrast to earlier works, the approach presented here uses the aggregation semantics of data to guard against meaningless or incorrect queries.

More specifically, as a vehicle for presenting the paper X  X  contributions, a high-level language for multidimensional dat-abases, SumQL, has been introduced. This has then been extended to support queries that reference data in separate object databases. The resulting language, SumQL++ embodies the concept of links that connect an MDDB to ODBs in a general and group data in the MDDB according to object data. We have focused on the extension of aggregate queries over MDDBs to also include data from ODBs. The formal semantics of SumQL++ is given in terms of a formal multidimensional data model and the ODMG data model and OQL query language. It is possible to use other languages such as SQL, OQL, and MDX in the place of SumQL++ once these are enriched with the necessary SumQL++ constructs that they do not already offer.
Interesting research directions include extending the approach to handle federations with several MDDBs, as well as the federation with XML databases, which offer less structure than object databases and thus may benefit even more from the ing of the OLAP schema, enabling the use of measures as dimensions and vice versa. Yet another interesting direction would be to consider the optimization of queries over the federation. For example, it may in some situations be advantageous to perform aggregation before selection, to take advantage of OLAP techniques such as pre-aggregation. Finally, it should be investigated how to perform data cleansing in our approach.
 Appendix A. Formal definition of SumQL This sections formally defines the syntax and semantics of the SumQL language.
 A.1. Syntax of SumQL
We now list the syntax for SumQL. The following notation is used in the syntax below: lower case letters are used for space, we have not included definitions of strings, reals, and integers, as their definitions are obvious. select_query : :  X  SELECT measure_list measure_list: :  X  measure j measure_list measure measure : :  X  string
MDDB : :  X  string category_list : :  X  category j category_list category category : :  X  string predicate_clause : :  X  predicate_factor j predicate_factor : :  X  predicate_element j (predicate_clause) boolean_op : :  X  AND j OR predicate_element : :  X  category_predicate j NOT category_predicate : :  X  category_exp predicate_op value j category_exp : :  X  category predicate_op : :  X  = j != j &gt; j P j &lt; j 6 value : :  X  integer j real j  X  X tring X  value_list : :  X  value j value_list value A.2. Semantics of SumQL
To describe the formal semantics of SumQL, we first specify a formal algebraic query language on the multidimensional data model. The algebraic query language is rather low-level and not for end-users, but is convenient for describing seman-is not meant to be computationally complete. We only include the operators that correspond to standard OLAP functions, that the computational power of the language will not surpass that of any commercial OLAP tool, rendering the results pre-sented here widely applicable to commercial OLAP tools. A.3. Selection
Given an MDDB S  X  X  S ; D ; M  X  and a predicate p on the dimension types D  X f T r  X  p  X  S  X  X  X  S 0 ; D 0 ; M 0  X  , where S 0  X  S ; D 0  X  D ; M null . The aggregation types are not changed by the selection operator.

Thus, the schema and the dimensions are retained, while the measures are restricted to the part of the multidimensional space where predicate p holds.

Example 24. If selection is applied to the sample MDDB with the predicate Year = 1998, the resulting MDDB has the same schema and dimensions, but the Total Admissions measure is restricted to only return non-null values for the multidimensional combinations where the days d 6 Time 1998 and where the original measure returned non-null values for those combinations. All other combinations return the null value.
 A.4. Projection
Given an MDDB S  X  X  S ; D ; M  X  , where S  X  X  F ; D  X  , a set of measures M f T 1 ; ... ; T j m g # D such that T i  X   X f&gt; T i g ; identity ; &gt;
T j 1 ; ... ; T j m ; M q 1 ; ... ; M q p  X  S  X  X  X  S 0 ; D 0
D g ; M 0  X f M 0 i ; i 2f q 1 ; ... ; q p gg , and M 0 i  X  e types are not changed by the projection operator.
 only the dimension types specified in the projection and their corresponding dimensions. The measures are modified to take only the remaining dimensions as arguments. Only the measures specified in the projection are kept. Note that we do not have to perform any other modifications (such as aggregation) on the measures, as the requirement on the dimensions left out makes sure that the measures have well-defined results, even when the number of dimensions is reduced.
Example 25. Imagine having a version of the example MDDB, S 0 , where the Reason and Time dimensions have only the &gt; category. This could for instance be the result of aggregating along these dimensions (see the aggregation operator below). set of dimension types and dimensions, making the MDDB 2-dimensional, and the new  X  X  X otal Admissions X  measure gives the same values for the combination ( d , p ) as the old measure gave for the combination ( d , p , &gt; , &gt; ). A.5. Aggregation
Given an MDDB S  X  X  S ; D ; M  X  and a set of categories C 1 a  X  C ; ... ; C n  X  S  X  X  X  S 0 ; D 0 ; M 0  X  , where S 0  X  X  F 0 ; D
Type  X  C i  X  6 T i C ij g ; 6 0 T 6 set on the right-hand side of the last equation is a multi-set, or bag).

If the hierarchies up to the grouping categories are summarizable, the aggregation types for the new dimensions are the same as for the original. If one or more of the hierarchies in the dimensions being aggregated over are not summarizable, then the aggregation types for all dimensions are set to c , as no further aggregation should be based on the data. Example 26. On the example MDDB, S, we apply the operation a [ Diagnosis , Hospital , &gt; all of the Reason and Time dimensions, but not over the Diagnosis and Place dimensions. This gives us the MDDB described in the previous example. To make the new MDDB, for each (diagnosis,hospital) combination ( di , h ), we find the group of (diagnosis,hospital,reason,day) combinations ( di , h , r , da ) such that r multiset, to which we apply the default aggregation operator, SUM. The measure values for the new  X  X  X otal Admissions X  measure, M 0 for a combination ( di , h ) is thus M  X  di ; h  X  X  SUM
A.6. We can now give the formal semantics of a SumQL statement in terms of the algebraic query language. The semantics are as follows. Given an MDDB S  X  X  S ; D ; M  X  , categories C ... ; T j m and measures M 1 , ... , M p the result of the SumQL statement:
SELECT M 1 , ... , M p INTO S 0 BY CATEGORY C j 1 ; ... ; C
S itself, we define the semantic meaning of S to be the MDDB resulting from the evaluation of the subquery. Appendix B. Experiment queries The actual queries used for the experiments are seen in Table B.1 .

References Table B.1 Experiment queries.

Query no. Query 1 SELECT TotalOrder,TotalAmount FROM OrderSummary BY_CATEGORY Nation 2 SELECT TotalOrder FROM OrderSummary BY_CATEGORY Nation 3 SELECT TotalOrder,TotalAmount FROM OrderSummary BY_CATEGORY Region 4 SELECT TotalAmount FROM OrderSummary BY_CATEGORY Region 5 SELECT TotalOrder,TotalAmount FROM OrderSummary BY_CATEGORY Region 6 SELECT TotalAmount FROM OrderSummary BY_CATEGORY Region 7 SELECT TotalAmount FROM OrderSummary BY_CATEGORY Region 8 SELECT TotalOrder FROM OrderSummary BY_CATEGORY Nation,Manufacturer 9 SELECT TotalOrder FROM OrderSummary BY_CATEGORY Nation,Manufacturer 10 SELECT TotalOrder,TotalAmount FROM OrderSummary BY_CATEGORY Region 11 SELECT TotalOrder FROM OrderSummary BY_CATEGORY Nation,Manufacturer 12 SELECT TotalOrder FROM OrderSummary BY_CATEGORY Region,Manufacturer 13 SELECT TotalOrder FROM OrderSummary BY_CATEGORY Region 14 SELECT TotalOrder,TotalAmount FROM OrderSummary BY_CATEGORY Region
