
Recent work in document summarization do not only extract sentences but also compress sentences. Sentence compression enables summarizers to re-duce the redundancy in sentences and generate in-formative summaries beyond the extractive summa-rization systems (Knight and Marcu, 2002). Con-ventional approaches to sentence compression ex-ploit various linguistic properties based on lexical information and syntactic dependencies (McDonald, 2006; Clarke and Lapata, 2008; Cohn and Lapata, 2008; Galanis and Androutsopoulos, 2010).

In contrast, our approach utilizes another property based on semantic roles (SRs) which improves weak-nesses of syntactic dependencies. Syntactic depen-dencies are not su ffi cient to compress some complex sentences with coordination, with passive voice, and with an auxiliary verb. Figure 1 shows an example with a coordination structure. 1 Figure 1: Semantic Role vs. Dependency Relation
In this example, a SR labeler annotated that Harari is an A0 argument of left and an A1 argument of became . Harari is syntactically dependent on left  X  SBJ(left-2, Harari-1) . However, Harari is not depen-dent on became and we are hence unable to utilize a dependency relation between Harari and became di-rectly. SRs allow us to model the relations between a predicate and its arguments in a direct fashion.
SR constraints are also advantageous in that we can compress sentences with semantic information. In Figure 1, became has three arguments, Harari as A1, businessman as A2, and shortly afterward as AM-TMP. As shown in this example, shortly after-word can be omitted (shaded boxes). In general, modifier arguments like AM-TMP or AM-LOC are more likely to be reduced than complement cases like A0-A4. We can implement such properties by SR constraints.

Liu and Gildea (2010) suggests that SR features contribute to generating more readable sentence in machine translation. We expect that SR features also help our system to improve readability in sentence compression and summarization.
Before describing our system, we show the statis-tics in terms of predicates, arguments and their rela-
Table 1: Statistics of Arguments in Compression tions in the Written News Compression (WNC) Cor-pus. It has 82 documents (1,629 sentences). We di-vided them into three: 55 documents are used for training (1106 sentences); 10 for development (184 sentences); 17 for testing (339 sentences).
Our investigation was held in training data. There are 3137 verbal predicates and 7852 unique argu-ments. We performed SR labeling by LTH (Johans-son and Nugues, 2008), an SR labeler for CoNLL-2008 shared task. Based on the SR labels annotated by LTH, we investigated that, for all predicates in compression, how many their arguments were also in. Table 1 shows the survival ratio of main argu-ments in compression. Labels A0, A1, and A2 are complement case roles and over 85% of them survive with their predicates. On the other hand, for modifier arguments (AM-X ), survival ratios are down to lower than 65%. Our SR constraints implement the di ff er-ence of survival ratios by SR labels. Note that de-pendency labels SBJ and OBJ generally correspond to SR labels A0 and A1, respectively. But their total numbers are 777 / 919 (SBJ) and 918 / 1211 (OBJ) and much fewer than A0 and A1 labels. Thus, SR la-bels can connect much more arguments to their pred-icates.
This section describes our new approach to sen-tence compression. In order to introduce rich syn-tactic and semantic constraints to a sentence com-pression model, we employ Markov Logic (Richard-son and Domingos, 2006). Since Markov Logic sup-ports both soft and hard constraints, we can imple-ment our SR constraints in simple and direct fash-ion. Moreover, implementations of learning and inference methods are already provided in existing Markov Logic interpreters such as Alchemy 2 and Markov thebeast . 3 Thus, we can focus our e ff ort on building a set of formulae called Markov Logic Network (MLN). So, in this section, we describe our proposed MLN in detail. 3.1 Proposed Markov Logic Network
First, let us define our MLN predicates. We sum-marize the MLN predicates in Table 2. We have only one hidden MLN predicate, inComp ( i ) which mod-els the decision we need to make: whether a token i is in compression or not. The other MLN predicates are called observed which provide features. With our MLN predicates defined, we can now go on to in-corporate our intuition about the task using weighted first-order logic formulae. We define SR constraints and the other formulae in Sections 3.1.1 and 3.1.2, respectively. 3.1.1 Semantic Role Constraints
Semantic role labeling generally includes the three subtasks: predicate identification; argument role la-beling; sense disambiguation. Our model exploits the results of predicate identification and argument role labeling. 4 pred ( i ) and role ( i , j , r ) indicate the results of predicate identification and role labeling, respectively.

First, the formula describing a local property of a predicate is which denotes that, if token i is a predicate then i is in compression. A formula with exact one hidden predicate is called local formula.

A predicate is not always in compression. The for-mula reducing some predicates is which implies that a predicate i is not in compression with n height in a dependency tree. Note the + nota-tion indicates that the MLN contains one instance of the rule, with a separate weight, for each assignment of the variables with a plus sign.

As mentioned earlier, our SR constraints model the di ff erence of the survival rate of role labels in compression. Such SR constraints are encoded as: role ( i , j , + r )  X  X  inComp( i )  X  X  inComp( j ) (4) which represent that, if a predicate i is (not) in com-pression, then its argument j is (not) also in with role r . These formulae are called global formulae because they have more than two hidden MLN pred-icates. With global formulae, our model makes two decisions at a time. When considering the example in Figure 1, Formula (3) will be grounded as: role (9 , 7 , AM-TMP )  X  inComp(9)  X  inComp(7) . (6) In fact, Formula (5) gains a higher weight than For-mula (6) by learning on training data. As a re-sult, our system gives  X 1-Harari  X  more chance to survive in compression. We also add some exten-sions of Formula (3) combined with dep ( i , j , + d ) and path ( i , j , + l ) which enhance SR constraints. Note, all our SR constraints are  X  X redicate-driven X  (only  X  not  X  as in Formula (13)). Because an argument is usually related to multiple predicates, it is di ffi cult to model  X  X rgument-driven X  formula. 3.1.2 Lexical and Syntactic Features
For lexical and syntactic features, we mainly refer to the previous work (McDonald, 2006; Clarke and Lapata, 2008). The first two formulae in this sec-tion capture the relation of the tokens with their lexi-cal and syntactic properties. The formula describing such a local property of a word form is which implies that a token i is in compression with a weight that depends on the word form.

For part-of-speech (POS), we add unigram and bi-gram features with the formulae, POS features are often more reasonable than word form features to combine with the other properties. The formula, is a combination of POS features and a height in a dependency tree.

The next formula combines POS bigram features with dependency relations.
Moreover, our model includes the following global formulae, which enforce the consistencies between head and modifier tokens. Formula (12) represents that if we include a head token in compression then its modifier must also be included. Formula (13) en-sures that head and modifier words must be simul-taneously kept in compression or dropped. Though Clarke and Lapata (2008) implemented these depen-dency constraints by ILP, we implement them by soft constraints of MLN. Note that Formula (12) ex-presses the same properties as Formula (3) replacing dep ( i , j , + d ) by role ( i , j , + r ). 4.1 Experimental Setup
Our experimental setting follows previous work (Clarke and Lapata, 2008). As stated in Section 2, we employed the WNC Corpus. For preprocessing, we performed POS tagging by stanford-tagger. 5 and dependency parsing by MST-parser (McDonald et al., 2005). In addition, LTH 6 was exploited to perform both dependency parsing and SR labeling. We implemented our model by Markov Thebeast with Gurobi optimizer. 7
Our evaluation consists of two types of automatic evaluations. The first evaluation is dependency based evaluation same as Riezler et al. (2003). We per-formed dependency parsing on gold data and system outputs by RASP. 8 Then we calculated precision, re-call, and F1 for the set of label ( head , modi fier ).
In order to demonstrate how well our SR con-straints keep correct predicate-argument structures in compression, we propose SRL based evalua-tion. We performed SR labeling on gold data and system outputs by LTH. Then we calculated precision, recall, and F1 value for the set of role ( predicate , argument ).

The training time of our MLN model are approx-imately 8 minutes on all training data, with 3.1GHz Intel Core i3 CPU and 4G memory. While the pre-diction can be done within 20 seconds on the test data. 4.2 Results
Table 3 shows the results of our compression models by compression rate (CompR), dependency-based F1 (F1-Dep), and SRL-based F1 (F1-SRL). In our experiment, we have three models. McDonald is a re-implementation of McDonald (2006). Clarke and Lapata (2008) also re-implemented McDonald X  X  model with an ILP solver and experimented it on the WNC Corpus. 9 MLN with SRL and MLN w / o SRL are our Markov Logic models with and with-out SR Constraints, respectively.

Note our three models have no constraint for the length of compression. Therefore, we think the com-pression rate of the better system should get closer to that of human compression. In comparison between MLN models and McDonald, the former models out-perform the latter model on both F1-Dep and F1-SRL. Because MLN models have global constraints and can generate syntactically correct sentences.
Our concern is how a model with SR constraints is superior to a model without them. MLN with SRL outperforms MLN without SRL with a 7.6 points margin (F1-Dep). The compression rate of MLN with SRL goes up to 73.1% and gets close to that of gold standard. SRL-based evaluation also shows that SR constraints actually help extract cor-rect predicate-argument structures. These results are promising to improve readability.

It is di ffi cult to directly compare our results with those of state-of-the-art systems (Cohn and Lapata, 2009; Clarke and Lapata, 2010; Galanis and An-droutsopoulos, 2010) since they have di ff erent test-ing sets and the results with di ff erent compression rates. However, though our MLN model with SR constraints utilizes no large-scale data, it is the only model which achieves close on 60% in F1-Dep. 4.3 Error Analysis Table 4 indicates two critical examples which our SR constraints failed to compress correctly. For the first example, our model leaves an argument with its predicate because our SR constraints are  X  X redicate-driven X . In addition,  X  X ay X  is the main verb in this sentence and hard to be deleted due to the syntactic significance.

The second example in Table 4 requires to iden-tify a coreference relation between artificial lake and Roadford Reservour . We consider that discourse constraints (Clarke and Lapata, 2010) help our model handle these cases. Discourse and coreference infor-mation enable our model to select important argu-ments and their predicates.
In this paper, we proposed new semantic con-straints for sentence compression. Our model with global constraints of semantic roles selected correct predicate-argument structures and successfully im-proved performance of sentence compression.
As future work, we will compare our model with the other state-of-the-art systems. We will also inves-tigate the correlation between readability and SRL-based score by manual evaluations. Furthermore, we would like to combine discourse constraints with SR constraints.
