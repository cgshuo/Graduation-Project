 1. Introduction has gained much attention in the liter ature. Despite the differences between the several proposed m odels, they all deal with the coordination of material handling devices and classical problem scheduling decisions. In this section we review the most important research concerning the Cyclic Hoist Scheduling Problem (CHSP). This problem is a branch stemming of the Hoist Scheduling Problem (HSP).
Since the first model given by Phillips and Unger (1976 ), several researchers have been interested in the Hoist Scheduling Problem ( Manier and Bloch, 2003 ) and a large number of mathematical
Che and Chu, 2007 ) have been developed. Nevertheless, the cyclic problem and more precisely, the single-job cyclic schedule, was the 2000 ) due to the strong complexity of the problem, even with a tanks). However, the problem is so complex that the most practical path consists of addressing the simplest cases, and then studying possible extensions. One of these extensions that we propose to study in this paper is the multi-parts jobs. For a given cyclic schedule, we have to minimize the cyc le time duration for n different part-jobs. n-degree cyclic schedule, exactly n parts enter and leave the produc-with this extension are presented as follows.

Ptuskin studied a multi-parts problem (single job problem, line with 50 tanks, nparts jobs and nop operations) denoted (CHSP nc / Manier and Bloch (2003 ) and dedicated to Hoist Scheduling
Problems. In this problem, parts are processed according to the same sequence, with various processing times, where the sequence periodically alternates jobs of different parts and is known in advance. Moreover, the date of each part has to be computed. This problem is decomposed in several mono-product sub-problems and the solution corresponds to a common period ( Ptuskin, 1995 ). Nevertheless, the obtained cyclic schedule is feasible but it is not guaranty to be optimal.

Varnier and Jeunehomme used a branch and bound method for a similar multi-part problem (CHSP 9 mt//load-unload 9 / nps , nop
T min problem). A difference with Ptuskin (1995 ) is that the entry sequence of jobs (configuration) is not known in advance. Each level of the search tree consists in adding a possible state at the beginning of the cycle, which is called configuration. The possible schedulesfromthisconfiguratio n constitute the branches of the search tree and then a linear program is achieved to check if the problem has a solution. If not, backtrack is allowed to consider the other schedules. However, Varnier and Jeunehomme mainly study the transition part of the schedule ( Varnier and Jeunehomme, 2000 ). A branch and bound method has also been used by Mateo and Companys to study the CHSP 9 mt //diss 9 /2,2 mt  X  2 9 T min different part jobs problem. The branch and bound procedure builds the sequence of movements progressively. Each level of the search tree consists of adding one tank and thus, the stages to be done on it (stage is a new indexation used by authors to define the soaking operations). A linear program is then solved at each node to check the consistency of the constraint system. Never-theless, this method cannot be easily extended to the general n -parts jobs ( Mateo and Companys, 2006 ).

Lei and Liu present first, a formal analysis of the hoist scheduling problem with two non-identical parts (CHSP 9 1,20, ct / 9 /42 9 T min ). Then, the results are used to develop a new branch-and-bound procedure in order to find the optimal schedules. This procedure uses a depth search strategy. In each step, it chooses a node at the greatest depth to branch first. Whenever a tie is found, it chooses the one with the minimum lower bound to branch first. They state that each node at level k of their tree has two partial cycles. Then the minimum lower bound given by those two cycles is used as the lower bound of this node. For each newly generated node, authors use the result of their analysis to check its feasibility. If the offspring nodes are either infeasible or do not improve the best obtained lower bound, the node is eliminated and backtrack is allowed to its upper level. This procedure provides good computational results. Authors tested their procedure on mono-product benchmarks. They also ran-domly generated some test problems without really detailing them. But the efficiency and robustness of their procedure was not evaluated considering variations of hoist speed and width of time windows. Moreover, their model was dedicated to basic line configurations X  (single capacity resources y ) and for 2-degree cyclic schedule ( Lei and Liu, 2001 ).

Many other studies deal with scheduling of the other produc-tion lines or even with the CHSP with relaxed constraints: mainly bounded processing times and no-wait constraints; which are problems near the CHSP ( Fleury et al., 2001 ; Ge and Yih, 1995 ; Che et al., 2009 ; Che and Chu, 2005 ; Kats et al., 2006 ; Liu et al., 2002 ; Song et al., 1995 ).

A synthesized comparison between these works (dealing with the Multi-Parts CHSP) is presented in Table 1 . Therefore, all of these works carried out on this issue, to date, have several limitations. Thus and in order to improve the electroplating line production, a general n -cyclic model could be developed by incorporating additional constraints to previous works.
Getting motivated by such class of scheduling problem and previous researches using evolutionary approach, we propose a genetic algorithm approach in order to optimality or near-optimality solve an n-degree CHSP problem for n different jobs. In such kind of industrial problems, electroplating compa-nies are looking for optimizing the simultaneous manufacturing of several kinds of products through a single line. This paper can be considered as the first paper tackling the n-degree cyclic hoist scheduling problem with heterogeneous part-jobs and time-window constraints. And it is organized as follows. In Section 2 , we formally describe the problem and formulate it as a Mixed
Integer Linear Programming model. In Section 3 , we firstly propose a conjunctive graph model of the problem and then a polynomial computational procedure to compute the cycle time for a fixed cyclic schedule. In Section 4 , we develop our Genetic
Algorithm approach. At last, in Section 5 and Section 6 , we make some concluding remarks based on the computational results and suggest directions for future research. 2. Problem statements
We consider the single-hoist cyclic scheduling problem in an automated system (CHSP 9 mt //diss 9 / n , nop 9 T min ) which may be described as follows. We are given mc tanks M 1 , y , M mc jobs J 1 , y , J n . In general, loading and unloading buffers (or tanks) are assimilated to fictitious tanks numbered respectively 0 and mc  X  1. Processing stations are containing chemical baths and arranged in a row (see Fig. 1 ). Each job J j consists of n treatments O ij { i  X  1, y , n j }. During the soaking process, no preemption is allowed. It means that the soaking operation O has to be processed in one time on a dedicated tank a ij A
M } for p ij Z 0 time units (t.u.). This soaking duration, is confined within a minimum (0 r a i , j r p i , j ) and a maximum ( p time durations as specified in the processing specifications. One of the specificities of the CHSP is that consecutive soaking opera-tions of the same job are not allowed to be assigned to the same tank. Moreover, we assume that tanks cannot receive more than one job on same time, in this case we speak about what we call a single capacity tank ( ct  X  1). Precedence constraints are given by the job processing sequences. Where, O ij -O i  X  1 j means that the i th soaking operation of job J j has to be finished completely before starting i  X  1th soaking operation of the same job. This problem description can be valuable for a general shop-scheduling pro-blem. Nevertheless, the CHSP presents additional specified con-straints class, called transport times constraints. They occur when a job has to be transported from one tank to another, i.e. if a job J has to be transported from tank M u to M v , the hoist (or automated guided vehicles) insuring this moving operation ( m j , u , v spend d u , v t.u. This duration can be, sometimes, job dependent ( d ). We suppose that the hoist has a single job capacity, where it cannot handle more than one job at the same time. Moreover, as different from the classical shop problems, it is not allowed that jobs have to wait before to finish all there soaking operations.
This means that no buffer space exists between tanks and the hoist is not allowed to wait while transporting a job.
In this paper, we consider that all jobs are processed on the same order soaking tanks, but with different time windows-soaking durations. Our objective is to minimize the cycle time duration, defined as the time needed for the hoist to make each of the loaded moves (for all the different part-jobs) exactly once. decisions to be made: (1) scheduling decision-sequence, in which the hoist has to move jobs (cyclic sequence), and (2) soaking decision (real soaking durations p ij ). The strong dependence between these two decisions makes the problem very hard to solve.
It can be classified as a NP-hard problem. Since our considered problem can be reduced to a single job CHSP problem with a single transport resource which is NP-hard ( Lei and Wang, 1989 ). 3. Mathematical modeling 3.1. Notations 3.1.1. Problem parameters: 10. a i,j and b i , j : minimum and maximum values for p i , j 11. M : a sufficiently large positive constant.
 1. T : the desired cycle scheduling period; 3.2. Problem Mixed Integer Linear Programming formulation integer linear program formulation of the problem in hand. Min T  X  1  X 
Subject to: d t d t t t t
X y y t 0 , 1  X  0 :  X  13  X  y  X  , u , j A f 0 , 1 g8 u , j ,  X  14  X  t Z 0 8 u , j ,  X  15  X  T Z 0 :  X  16  X 
In this model, the objective function (1) minimizes the cycle time T . Constraints (2) X (5) ensure that the processing time in each tank and for each job must belong to the specified time windows.
Constraints (6) X (9) ensure that there is enough time for the empty hoist to travel between any two loaded moves. The schedule tank feasibility is traduced by constraints (10) and (11) . For more clarity, the constraint (10) specifies that for each n soaking process sharing the same tank, at most one of them is crossing the cycle boundary (i.e. it starts on a cycle and take end on the next one). And constraint (11) is defined for each pair of soaking operations u and v sharing the same tank to avoid conflicts. Constraints (12) and (13) define the first hoist move in the cycle schedule (i.e. as the transport of the first part job of J from tank 0 to tank 1). Constraints (14) X (16) are non-negative and binary constraints.

Although the elaborated mixed integer linear programming model provides the optimal solution, variables and constraints increase drastically when the number of tanks and/or jobs increases.

Because of the inherent intractability of the scheduling pro-blem, developing Genetic Algorithm approach for yielding near-optimal solution is justifiable. Before presenting the proposed approach, we propose in the following subsection a first con-junctive graph modeling of our problem and then a polynomial procedure to compute the cycle time. 3.3. Problem modeling by conjunctive graph
In this subsection we propose a conjunctive graph modeling presentation of a feasible schedule.
 Let us define first a general feasible sequence of our problem.
A feasible cyclic sequence is defined simultaneously by an operator sequence of the hoists moves ( H  X  / m [0] , y , m m an operation cycle), a sequence of relative starting times of the moves in H ( X  X  / t [0] , y , t [ k ] , y , t [ nop 1] S cycle time T .

Even though the vector H is unknown beforehand, it must take different values to obtain the corresponding vector X of starting times and therefore the values of the cycle time T . To define a cyclic schedule for the hoist moves in a cycle, we shall use ( H , X , T ). Moreover, in general, for nop hoist movements, there are exactly nop! possible cyclic schedule, given by the cyclic permutation.

In order to compute easily the cycle time for any given cyclic sequence of moves performed in two successive cycles defined by H . Moreover, to simplify the presentation we number consecu-tively all the hoist moves m j , u , u  X  1 ( j  X  1, y , n ; u  X  0, to ( nop 1) (i.e. for more details, see Section 4.1 ). For any operation a A {0, y , nop 1}, let define J ( a ) as the index of the job part and let From ( a ) and To ( a ) be respectively departure and arrival of the hoist move a .

For each cyclic schedule configurations H and HM  X  ( H X  X  ), a represents a particular move in HM . And each conjunction (i.e. precedence constraints) is defined by a directed arc on G and weighted by the function e defined as follows: e : E -R  X   X  a , g  X  / e a , g  X  e  X  a , g  X  where e ( a , g ) is the edge length joining node a to node g . From each vertices in V at most two edges can be generated in E ( G ). They represent two kinds of precedence constraints. The first one is matching two successive moves for the same part job while the second one is defined between two consecutive moves in G ( V ). For more clarity, the first class of arc ensures that the processing time at each soaking stage is at least equal to the lower duration. And the second one guarantees that there is enough time for the hoist to travel empty between two successive moves assigned to it.

Let a -g an arc on G and where hoist move a has to be finished before g starts. This arc is weighted with: e y ,2 nop 1)).

In order to reduce the problem complexity, we propose as follows, a polynomial computational procedure to compute the cycle time for a feasible cyclic schedule. This procedure will be used in Section 4 to evaluate the cycle time of each generated solution.
Let us define Z k , k as the maximum length spanning tree between two k moves, where the two k moves are in two successive hoist sequence moves H .

And for more clarity, we propose in Fig. 2 , an illustration of Z parameters for a given cyclic hoist sequence H  X  (0, 1, 3, 2).
For a given cyclic sequence H , a direct graph G ( V , E )is constructed. Then, for all 0 r k r 2 nop 1, Z k , k can be computed easily by a recursive procedure (see computational procedure). We define x , a binary parameter, which is not null and the departure tank of the vertices V ( k ) is not the loading station.
 Moreover, each two consecutives vertices V ( i ) and V ( i  X  1) in
Computational procedure for ( i  X  0, y , 2nop 1) do end for ; while ( i o k o 2 nop 1) do
Z end while ;
Applying this procedure, the starting time for hoist moves in load for the same cyclic sequence can be computed by the following equality: t
And the cycle time for a given sequence H and for the associated direct graph G ( V , E ) can be defined by
T  X  max
In order to illustrate the fitness evaluation procedure an example is given below. 3.3.1. Illustrative example
In this example, two products must be soaked in a line with 5 tanks including the loading and the unloading stations. The processing time windows for every part product are given by Table 2 . This benchmark was proposed in literature by Mateo and Companys (2006 ).

The two part jobs have the same processing sequence and each one must pass through the three soaking tanks starting by tank 1 then tank 2 and finally tank 3. Tank 0 and tank 5 are the loading and unloading stations.

The time needed for the hoist to move empty between tanks of successive treatments is 10 time unit (t.u.). With load, the time needed for the hoist to move is 15 t.u.
 Firstly, let us consider the following cyclic sequence
H  X  (0,6,1,7,2,4,3,5) associated to the hoist sequence ( m m the directed graph of this cyclic schedule and we present it, as shown in Fig. 3 . Finally, we describe analytically the procedure of how to compute the cycle time, as detailed as follows. The first type of arcs, represented by discontinuous arrays in Fig. 3 , are weighted by in Fig. 3 , are: the computational procedure. We present as follows the steps of how to compute the parameter Z 0,0 .
 times:
As similarly, we compute all the others Z k , k and therefore the cycle time T : when drawing the conjunctive graph of the cyclic sequence, all the edges defined before are generated except the edge e 3,4 matching the versus 3 and 4. This is because moves 3 and 4 are related to different kind of jobs. Moreover, between this two versus, only one edge can exist to guarantee the time needed for the hoist to travel empty.

The real soaking durations are given in Table 3 . We can, notice that time windows constraints are satisfied and all the processing durations are confined within the minimum and maximum specified bounds. 4. Genetic Algorithm
Genetic Algorithm (GA) is an intelligent optimization techni-que based on natural selection which is the process that drives biological evolution. GA is a search algorithm used for solving both constrained and unconstrained optimization problems. It has been widely studied and experimented in many fields since its introduction by Holland (1975 ). Moreover, it has been applied efficiently for closely related problems such as scheduling opti-mization ( Manier and Lamrous, 2008 ; Lim, 1997 ).

Each solution is defined by a chromosome (or individual) which represents a given solution in the search space. Repeatedly, the GA modifies a population (called generation) of individual solutions, using genetic operators (selection, crossover and muta-tion) toward an optimal solution for the specific problem objec-tive function. At each step of the algorithm, individuals from the current population, called parents, are selected and used to produce new chromosomes called offspring (called also children), to form the new population. We formally describe the procedure of our GA as follows:
Step 1 : Initialize the probabilities of the crossover operator ( p and the mutation operator ( p m  X  1 p c ). Then, define the e e generation number of chromosomes ( popsize ) and generate at random an initial population pop (0).

Step 2 : Generate a new initial population pop (0) by applying a first repair procedure ( repair 1).

Step 3 : Apply a suitable crossover operator to combine two selected parents to form children. Then, affect random changes to some individual parents by applying mutation rules.
Step 4 : Compute the fitness value of the strings in the population pop (0) using the polynomial procedure (detailed in Section 3.3 ).

Step 5 : Carry out the second repair procedure ( repair 2) and choose popsize strings between the 2 popsize parents and offspring using elitist selection strategy. The best solution in the population defines the best problem cyclic schedule.
Step 6 : If the maximum number of iteration ( nb_iteration )is reached, then stop the algorithm and choose the best solution in the population as the final solution of the problem. Other-wise, go to Step 3 and change pop (0) by the current population and increase the iteration parameter by one.

In the following subsections we define and detail the specifi-cities of the main elements of our elaborated GA. 4.1. Encoding scheme
A variety of encoding methods are used to represent a chromosome and the most used ones are binary coding and real number coding method. The chromosome representation can have a big impact on the searching capability of the algorithm. In fact, the adopted chromosome encoding must represent all the possible solutions of the problem otherwise the algorithm will never find a solution if it is not represented.

As described in Section 3.3 , the variables of the considered problem are drastically defined by the order of the hoist moves, m reason and due to the specificities of this class of problems, we choose the real number coding method. So, each gene of the chromosome is encoded with an array integer number corre-sponding to a specific hoist move.

Table 4 illustrates the adopted encoding scheme for an example of three part-jobs and two tanks (not including the loading (tank 0) and the unloading (tank 3) stations).
In order to reduce solutions redundancy, the first gene of each chromosome must be fixed to zero. It indicates that the initial hoist move of the initial job index is used as the first hoist move in our cyclic sequence. Moreover, each chromosome is composed by nop genes. Here, the cyclic sequence is represented by the order number of genes from the left side to the right side. If we number consecutively all the gene of a chromosome (from 0 to nop 1) the obtained solution is always feasible but it has the highest objective function value. 4.2. Generation of initial population
The optimal solution of the problem can be anywhere in the solution space. This gives us reason to generate random initial population for our GA. Nevertheless, the speed convergence of the algorithm is affected straightly by the quality of this population.
Thus, a promising way to improve the randomly generated initial solution is to apply a repair procedure ( repair 1) on it.
The studied problem can be characterized by the low number of feasible solutions, even though, for the single part job problem ( Manier and Lamrous, 2008 ). Further, no indications are given ( Lim, 1997 ) for the population size popsize . So after some experi-ments, we choose 30 as the size of the population in our GA. 4.3. Selection
The main propose of this phase is to improve the average population fitness. We can reach this objective by applying, in our paper, the elitist selection strategy. Where, the best popsize chromosomes of the population are conserved for the next generation. Thus, the best chromosomes produced in each gen-eration will remain until the end of the algorithm. It is important to note that clones are not removed from the population. How-ever, the diversity of the population is assured by a second repair procedure ( repair 2). 4.4. Crossover operator
The core idea of applying a crossover operation is to recombine the features of two randomly selected parents from the popula-tion in the aim of producing better offsprings. Here, we design a single subsequence crossover operator. This subsequence is cho-sen randomly for each couple and each generation. The chosen parents are selected with a certain probability called crossover probability ( p c ).

The steps of the adopted crossover operator are given as follows:
Step 1 : Select two parents randomly using the crossover probability ( p c ).

Step 2 : Choose a subsequence of genes from the first parent with a random size within 2 and nop 1. (i.e. the size of the subsequence defines the randomly chosen substring two-point)
Step 3 : Locate the same subsequence, as found in Step 1 , in the second parent.

Step 4 : Generate offsprings by placing the genes in a parent X  X  subsequence to the other parent X  X  as illustrated in Fig. 4 . 4.5. Mutation operator
The main purpose of the mutation operation is to introduce some diversity in the population. Several mutations operator are available in literature. However, in this paper, we apply swapping operator to parents selected with a mutation probability ( p  X  1 p c ). This chromosome structure perturbation, as shown in Fig. 5 , takes in by the exchange of two genes selected randomly within 2 and nop 1.
 4.6. Repair algorithms constraints: tank availability constraints as well as time window constraints. Therefore, the number of feasible solutions is not so important even though for the single part job problem ( Manier and Lamrous, 2008 ). So to ensure the chromosomes feasibility in the initial population first, and then in the following populations, we propose two repair functions.
 generated initial population in order to check and then to ensure its viability. The proposed algorithm is described as follow: chromosomes feasibility for the generated populations. Its algo-rithm is described as follows: change it, with the best chromosome found in the previous population.

Step 3 : If the total number of the chromosomes in the current population is not yet reached, go to Step 1.

In these two repair algorithms we define a neighborhood local search strategy. We incorporate it in the aim to ensure the population feasibility and to speed up the convergence of the algorithm. The search of a reliable neighborhood for the non-feasible chromosome is done by swapping randomly two of its genes. The first feasible neighborhood we find is then selected to substitute the original chromosome, and this solution can be optimal or near-optimal. 5. Computational experiments
In this section, experiments are carried out to evaluate the performance of our GA. It has been coded in C  X  X  language and implemented on a HP computer with 2.13 GHz and 4 GB of memory. Cplex solver, has been used to solve the Mixed Integer
Linear Programming model, described in Section 3 . And to estimate the efficiency of the proposed GA, we use optimal solutions found by our MILP model (for n  X  2) ( El Amraoui et al., 2008 , 2012 ) for the instances proposed in Mateo and Companys (2006 ). 5.1. Instances description
The experiments consist in running the algorithm for the literature instances ( Mateo and Companys, 2006 ). Those ones were randomly generated. The number of tanks, not including the loading and the loading ones, varies from 5 to 10. The input data for each instance where: the width of time windows and the hoist speed (see Appendix A ).

The minimum time durations for bath operation ( a i , j ) are generated using a uniform distribution from 20 to 80. The maximum time durations for bath operation ( b i , j ) is then pro-duced according to three kinds of Time Windows (TW), defined subsequence by Mateo ( Mateo and Companys, 2006 ): Close Windows (CW), b  X  U[1.2 a i , j , 1.5 a i , j ]; Half-opened Windows (HW), b 2 a i , j ] and Open Windows (OW), b i , j  X  U [2 a i , j ,10 a movements without load between consecutives baths ( c u , u  X  1 are generated using a uniform distribution from 5 to 10. Accord-ing to the value of the hoist move in load between consecutives (HS) series: Fast Hoist (FH), d u , u  X  1  X  1.5 c u , u  X  1 5.2. Tuning phase
This subsection is dedicated to present the steps of how to find the best performance GA parameters (the population size ( pop-size ), the probability of crossover ( p c ) and the probability of mutation ( p m )). For this aim, a fixed number of combinations was tested on some known instances. A three-step process is applied here, similarly to Nguyen et al. (2012 ):
Step 1 : Choice of the test instances: we use the large-sized benchmarks of Mateo and Companys (2006 ).

Step 2 : Parameter values selection: we start by setting the initial metaheuristic parameters to the best theoretical values. Then, using the sign test as detailed in Conover (1999 and Sheskin (2000 ) we compare the obtained results. These results are found as follows: first, we modify one of the GA parameters. Then, we run the heuristic; if the new result is better we accept it.
Otherwise, if the two results are the same, we choose the one with the smallest running time. Finally, we stop the procedure when it is performed exactly 20 times. The obtained results for the GA parameters are reported in Table 5 .

Step 3 : According to results of step 2, two values are promising for each GA parameters. Therefore, a Friedman and a Bonferroni X  X unn tests are performed successively, like in
Nguyen et al. (2012 ), in order to help us to choose one parameter combination among the o  X  8 generated ( o  X  8  X  2 3 ) combinations ( C i ;1 r i r 8).

In Table 5 , the combination cost ( Cost ) defined the means of the combination ranks. Where, the rank of the best solution is equal to 1 while o for the worst one.

Regarding to Table 5 and to Bonferroni X  X unn test, based on pairwise comparisons of mean ranks (see Nguyen et al. (2012 ) for more details), we can assert that C 7 is the best choice.
Due to the important influences of the parameter settings on the performance of the GA and after the previous tests, we choose the following parameters for our GA. The population size ( popsize ) is equal to 30 chromosomes, the probability of crossover ( p
The maximum number of generations ( nb_iteration ) is equal to 1000 and the maximum numbers of iterations of the repair functions ( nb_iteration_ 1 and nb_iteration_ 2) are both equal to 75. For each instance, 20 independent runs are performed. 5.3. Simulation results hoist speed. For each, test series, we take the best value of the cycle time ( BestValue ), the average value of the cycle time ( AvgValue ) and the average Cpu time ( AvgCpu ) for our GA tests.
These last two parameters denote respectively the averages of the obtained results for the BestValue and the Cpu parameters by the number of runs carried out for each test instance.
 of absolute deviation between the average value and the best find value of the cycle time: ER  X  %  X  X  100  X  AvgV alue BestV alue  X  = AvgV alue : in sub Section 5.1 are presented in Tables 6 X 11 .

For instances with small sizes (see Tables 6 X 11 ), all the optimal solutions are reached in no more than 6 min for 2-cyclic schedule and lines with 5 X 10 tanks. Moreover, these results show that the error ratio, for the 10 performed runs, is less than 20% for all the tested instances. This can traduce the viability of the applied repair algorithms to improve results qualities and to increase the speed convergence of the GA.
 For instances with large sizes, 24 problems are solved (see Table 12 ). Yet, we do not have optimal solutions to compare with.
This can be traduced by the restrictions occurred by exact solving methods. In fact, the linear programming method is unable to solve large scale combinatorial optimization problems. Even so, the GA heuristic is capable to generate optimal or near-optimal solutions for this kind of problems.

Obviously, a basic comparison can be done between the general n -cyclic problem for heterogeneous jobs and the n different 1-cyclic single job problems, in order to evaluate the percentage of the sum of the n different 1-optimal values and the best find value of the cycle time: GR  X  %  X  X  100  X  sum optimal value best value  X  = sum optimal value :
The obtained solutions are reached in no more than 16 min for instances with 10 different jobs and a cyclic sequence of 110 hoist moves. The optimality of the best obtained value of the cycle time is not guaranteed but thanks to the comparisons we make and the computed gap ratio, we can perceive the very good quality of the obtained objective function value. In fact, the obtained cyclic schedule solutions for n different jobs can allow as, in the great majority of the studied cases, to improve the electroplating line production. This increase in the line output rate can reach 40% which cannot be neglected. These results show also the big advantage of considering n degrees cyclic schedules on optimizing the cycle time.

In almost all the solved examples the obtained solutions are very satisfactory. Indeed, we were able to reduce considerably the total cycle time through heterogeneous multi-product cycles. In addition, the simulation times of the proposed approach are quite satisfactory and acceptable (not exceeding 16 min) in contrast to the linear programming approach. It is worth noting that, solving linear cyclic model for a degree greater or equal to four and for line with five soaking tanks, we were forced to stop the simula-tion after a period of 24 h and before reaching the optimal.
Moreover, among the examples, shown in Table 12 , we succeed to solve to optimality only three examples (nos.: 1, 2 and 3). These results are reported in Table 13 . However, the simulation times are quite impressive: more than 24 h for lines 6 and 7 tanks. terms of objectives. Firstly, the obtained solutions are very interesting and improved in terms of cycle time. Secondly, the simulation time is reduced notably compared to the exact method, which shows one more time the limitation of the exact method to solve NP problems. 6. Conclusions of GA to solve the single hoist cyclic scheduling problem with time windows constraints and heterogeneous jobs. A new mixed integer linear programming model is proposed to minimize the cycle time for n different jobs. Due to the hardness of solving the proposed linear model for instances with large sizes, we firstly propose a conjunctive graph model for the problem. Then, we elaborate a polynomial procedure for computing the cycle time for a fixed cyclic schedule. And we finally propose a GA heuristic for solving the considered problem. The initial as well as the following populations of the GA are improved by applying repair algorithms based in neighborhood local search procedures. For small size instances, we compare the solutions obtained by our
GA and optimal solutions found with the mixed integer linear model (for n  X  2); and for large size instances, we evaluate the GA solutions using a basic comparison drawn from the problem specificities. The obtained results indicate the efficiency of the proposed GA and provide the basis for further research, such as multi-hoist problems.

Appendix A. Example of benchmark for a line with 5 soaking tanks References
