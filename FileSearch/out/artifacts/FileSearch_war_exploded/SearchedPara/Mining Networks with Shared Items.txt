 Recent advances in data processing have enabled the gener-ation of large and complex graphs. Many researchers have developed techniques to investigate informative structures within these graphs. However, the vertices and edges of most real-world graphs are associated with its features, and only a few studies have considered their combination. In this paper, we specifically examine a large graph in which each vertex has associated items. From the graph, we extract sub-graphs with common itemsets, which we call itemset-sharing subgraphs (ISSes) . The problem has various potential appli-cations such as the detection of gene networks affected by drugs or the findings of popular research areas of contribut-ing researchers. We propose an efficient algorithm to enu-merate ISSes in large graphs. This algorithm enumerates ISSes with two efficient data structures: a DFS itemset tree and a visited itemset table . In practice, the combination of these two structures enables us to compute optimal solutions efficiently. We demonstrate the efficiency of our algorithm in mining ISSes from synthetic graphs with more than one million edges. We also present experiments performed using two real biological networks and a citation network. The experiments show that our algorithm can find interesting patterns in real datasets.
 Categories and Subject Descriptors: H.2.8 [Database Applications]: data mining General Terms: Algorithms, Performance Keywords: Large Graph, Itemset, Gene Network, Citation Network, Social Network
Large graphs can represent real-world relationships, and there has been considerable interest in graph analysis in var-ious domains. Researchers have studied the common prop-erties of network structures with various degrees of vertices [2], and have developed techniques to find dense subgraphs within graphs efficiently [10]. At the same time, data mining researchers have extracted frequent subgraphs from graph databases [4, 13].
 ber of subgraphs increases exponentially according to the size of a given graph. To overcome this difficulty, we de-signed an algorithm called COmmon Itemset Network min-ing ( COIN ), which computes the optimal solution and con-tains the following two data structures: depth-rst search (DFS) itemset tree and visited itemset table . By combining the two structures, we can reduce the search space dramati-cally. We demonstrate the scalability of our algorithm with respect to the amount of data by using synthetic data, and we demonstrate the algorithm X  X  application to a real biolog-ical network dataset and a citation network.
In this section, we formally define the problem of finding the maximum ISS.

Let G be an undirected, unlabelled, unweighted graph where each vertex has a set of items (an itemset). We de-fine this graph as the itemset-associated graph (IA graph) . Let V ( G ), E ( G ), I ( G ), and I ( v ) respectively signify a set of vertices in G , a set of edges in G , a set of itemsets on vertices in G , and an itemset on v 2 V ( G ). For this de-scription, j G j = j E ( G ) j is the size of graph G . Figure 1(A) portrays an example of the IA graph. Each vertex in G has an itemset. Next, we define a graph having common items.
Definition 1. (Subgraph) Let G be an IA graphs. We de ne I ( G ) as set of G . We de ne G 0 a subgraph of G when V ( G 0 ) V ( G ) , E ( G 0 ) E ( G ) and I ( G 0 ) I ( G ) . We describe G 0 G when G 0 is a subgraph of G .
 With this definition of subgraph in terms of an IA graph, we define an important feature of a subgraph.

Definition 2. (Itemset-Sharing Subgraph (ISS)) Let G 0 be a connected subgraph of the IA graph G . G 0 is also an IA graph. When I ( G 0 ) 6 = , we say that G 0 is an itemset-sharing subgraph (ISS) with I ( G 0 ) .
 We present two examples of ISSes in Figures 1(B) and (C), which are indicated by the bold lines.

To introduce the formal definition of ISS discovery, we define a connected graph in terms of an IA graph.
Definition 3. (Connected Graph) Let G be an IA graph, and G 1 and G 2 be the subgraphs of G and ISSes. We say that G 1 and G 2 are mutually connected when E ( G 1 ) \ E ( G 2 ) 6 = and j I ( G 1 ) \ I ( G 2 ) j = min fj I ( G 1 ) j ; j I ( G 2 ) jg . We only consider the graphs to be connected when the inclu-sion relation between the itemsets of the two graphs exists. By this definition, G B and G C shown in Figures 1(B) and (C) are disconnected.

If connected graphs exist, we are interested in the largest one. The following definitions of the largest ISS enable us to select the ISSes of interest.
 Definition 4. (Largest ISS) Given an IA graph G . Let G 0 be an ISS with I . When no edge ( v v 2 G 0 satis es I ( V ( G ) [ f v 2 g ) = I , G 0 is called maximal ISS with I . We call the maximal ISS whose size is the largest as the largest ISS, and the N largest maximal ISSes as the N largest ISSes.
 With this definition, we formalize the problem of finding the N largest ISSes.
 Definition 5. (Finding the N Largest ISSes) Given an IA graph G , user-speci ed values N and I , we compute the N largest ISSes G 0 such that j I ( G 0 ) j I .
Table 1: A Visited Item-set Table.
 This property implies that if we visit an already visited node v and the shared itemset of the current path is the same or a subset of an itemset when we previously visited on v , we can prune the subtree rooted by the current node in the DFS itemset tree. Therefore, this property enables us to avoid unnecessary subgraph exploration.

Theorem 1 prompts us to make the following hash table for the efficient pruning of subgraphs.

Definition 6. (Visited Itemset Table) We denote a set of itemsets associated with a vertex v as P ( v ) . We add I to
P ( v ) when we visit a node n = ( v; I ) of the DFS itemset tree. We de ne the hash table as a visited itemset table. While constructing a DFS itemset tree, we can build a vis-ited itemset table. Table 1 shows the contents of P when we visit n 4 in Figure 2.

However, two problems might occur. First, it might be too costly to check an inclusion relation in a visited itemset table. Second, in a real network, this pruning technique might not work well. With regard to these problems, in Section 4, we show that our algorithm is sufficiently fast to solve problems dealing with synthetic and real data. With the DFS itemset tree and visited itemset table, we designed a novel algorithm to quickly discover the largest common pattern graph.
In this section, we describe the performance of the COIN algorithm. All experiments were performed on a 2.2 GHz AMD Opteron machine with 1GB main memory, running on Linux 2.6. The COIN algorithm was implemented using Java 5. First, we experimented using synthetic data and then we showed the results obtained using a real biological dataset and a DBLP dataset.
 Synthetic Data. We generated a synthetic IA graph to evaluate the performance of the COIN algorithm over a large range of data characteristics. Their graph structures match those of a random graph.
 Performance Results. We introduced the visited itemset table, but we must consider the fact that the scanning cost of the table might be high. We therefore examined the ef-fectiveness of the table using synthetic data. Figure 3 (A) shows the execution times obtained with and without the use of the visited itemset table, which is indicated by  X  X OIN X  and  X  X /o Visited Itemset Table X , respectively. We changed the degrees to check the dependency of the network complex-ity. An increase in the average degree can result in numerous graphs that do not yield the largest ISS. The execution time increases exponentially, and almost quadratically, both with and without the use of the visited itemset table. Note that the y axis is on a log scale. From this figure, COIN is shown to be about an order of magnitude faster than the algorithm without the visited itemset table.

Figure 3(B) reports the execution time of COIN as a func-tion of the number of edges (the number of edges is the av-method can find the sparse subgraphs sharing items; hence our method can extract the modules of signal transduction cascade that form a hierarchical structure.
 DBLP Dataset.

We investigated the usefulness of the largest ISS by using the DBLP dataset [6] consisting of a snapshot as of April 12, 2006. The DBLP network has 22,178 papers (vertices), 112,304 references (edges) and 16,638 authors (items). All of the papers had at least one author and one reference. The average number of authors over all the papers is 2.29. The parameters for COIN were set to I = 2 and S = 10. The computation time was 7.9s on the same machine and environment as the synthetic dataset.

Table 3 shows the top 5 largest network results extracted by COIN. All of the researchers in the Top 5 networks are famous within the database and data mining community; hence, our method can effectively extract the important net-works. All of the papers in this network contains at most 33 papers, and the support value of the number of itemsets was 33 = 22 ; 178 0 : 14%. It is difficult to find association rules in such a very low support network.
 In this experimental result, we used author names as items. If the authors of every paper were replaced by keywords about the papers, COIN also can extract the reference net-work that has members that share topics.
One might think that graph clustering methods [7] pro-vide solutions to the ISS enumeration. Although some meth-ods use the edge weight, our common pattern graphs might share one edge between two different graphs such as the edge ( v 1 ; v 4 ) in Figures 1(B) and (C). Therefore, we require a method that specifically addresses the common itemset in subgraph.

Upon the ISS enumeration, frequent pattern mining [1, 3] might provide the first step finding ISSes because the fre-quent itemset mining constructs a large ISS. However, since support of the largest ISS might be very low, the develop-ment of an efficient algorithm is required to find ISSes.
MATISSE [12] and CoPaM [8] study the combinatorial mining of networks with feature vectors. Both methods find dense subgraphs with vertices that have similar features. However, we are not concerned with the density of the sub-graphs, and our method can find the sparse hub network shown in Figure 4.
In this paper, we introduced a new graph structure, namely, an undirected relational graph in which the nodes contain a set of items. We also proposed a novel graph mining problem called itemset-sharing subgraph (ISS) problem , which deals
