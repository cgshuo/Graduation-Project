 H.2.5 [ Database Management ]: Heterogeneous Databases  X  Data Translation; I.2.7 [ Artificial Intelligence ]: Natural Language Processing  X  Language parsing and understanding General Terms: Algorithms, Design, Experimentation Database Selection, Mediator, Na tural Language Query, Ontology Within an organization, a growing number of structured data sources are readily available online for ordinary users. While each of them provides a particular interface for users, the need for a uniform interface to all the data sources and a one-stop search of information has been growing. For example, a university may have a database about various co lleges and departments, a second one about courses and teaching a ssignments and a third one about libraries, books and borrowers. To fi nd information, a user has to first locate the proper database, and then formulate a query on a specific interface. Sometimes, the user needs to search multiple data sources and manually combine the results to obtain the useful information. This mode of seek ing information makes the search task difficult. Mediators [2,4] provide a uniform interface to interact with a user and a variety of heterogeneous data sources. However, their uniform interface requires users to have a prior knowledge of the mediator schema and use a st ructured query language, which place a heavy burden on ordinary users. For example, we have a database about course assignment for instructors, whose schema is shown in Figure 1. It has two entity-type tables Course and Instructor , and one relationship-type table Teach . CourseNum is the key of Course , and Name is the key of Instructor . Arrows show the primary and foreign ke y relationships. For the question ( Query 1 )  X  X here is the office of the instructor who teaches the course Advanced Database System s? X , a user needs to know the mediator schema and then write a SQL query. Form-based interfaces are a solution for ordinary users. However, for mediators that integrate da ta sources performing different functions, it is also non-trivial to integrate schemas and then build a suitable form-based uniform interface. Keyword based interface has been very successful on web search and is drawing many interests on structured databa se querying [1,3]. However, keyword-based search considers a query as a sequence of keywords, and it cannot deal Wh -words and semantic relations in natural language queries. Thus, it is desirable to have a natural language interface [5], which can be used by ordinary users and yet does not need to integrate schemas. We envision this interface as a significant application for mediators (We consider keyword-based queries as a simplified form at of natural language queries.). Such an intranet mediator provides a natural language interface to ordinary users and works as follows: (1) Analyze a given natural language query (NLQ). (2) Rank da tabases and select the top ones which most likely contain the answers. (3) Formulate a source specific query to each of the selected databases. (4) Combine results from different local databa ses, and return a ranked list of possible answers along with a ranked list of the databases, similar to what are produced by a web search engine. Instead of giving one final answer, we give a ranked list for a given query. Users will be satisfied as long as the correct answer is among the top few answers. In case the selected databases are incorrect, users can choose the desired one from th e ranked list of databases for new answers. In this paper, we address Steps 1 and 2, which we call a database selection (in intr anet mediators for NLQs) problem. Steps 3 and 4 will be addresse d in a subsequent paper. In the remaining of the paper, we briefly describe the semantic-based graph model, as well as th e method of computing semantic distances between queries and data bases in Section 2. Section 3 describes how to utilize an ontology. Section 4 reports the experimental results. We do not integrate schemas; instead, for each database, a database graph is constructed automatically based on the database schema as well as some seman tics derived from the database. Definition 1 (Database Graph) : A database graph is an undirected graph } , , { P E V DG = , where V is a set of schema nodes, E is a set of edges with non-negative weights, and P is a set of labeled paths (paths have directions and one path may have multiple labels). A database gra ph has 3 types of schema nodes: table nodes, attribute nodes and value nodes. A table node is created for each table; an attribute node and a value node are created for each attribute. Between two table nodes, if they have a primary and foreign key relationshi p, we draw an edge; between a table node and each of its attribute nodes, we draw an edge; draw an edge. Each edge is given a non-negative weight, which represents the semantic distan ce between the two nodes. Labeled paths are another way to represen t database semantics. A path from one node to another may embed some basic semantic relations; we assign labels to pa ths to represent the corresponding semantic relations. We classify 3 types of labels: Be , Of , and Related . Label Be represents Equal or IS-A semantic relations; label Of represents Part-Of, Belong-to or Member-Of semantic relations; label Related represents two nodes are semantically related in other ways. We have designed rules to automatically determine meaningful paths with labels for any given pair of schema nodes. Figure 2 shows the database graph of the course assignment database (attributes for Teach are not shown here.) We view each NLQ as a set of query terms and a set of semantic relations between them. We use a labeled directed graph to represent a NLQ. Definition 2 (Query Graph) : A query graph is a labeled directed graph } , , { E S V QG = , where V is the node set (query terms), V S  X  (called the target set, which represents what the user wants as the output.), and E is a set of directed edges with labels (semantic relations). Figure 3 shows a query graph of Query 1 . Each node in the query graph is a query term, which represents a basic semantic unit and corresponds to some schema node(s) in a database graph. E ach directed edge between two query terms denotes that there is a semantic relation between them. Each label represents a relation type. We identify 5 relation types:  X  X e X ,  X  X ave X ,  X  X f X ,  X  X ossessive X  and  X  X ttached X . We use a set of NLP tools to automatically generate a query graph for a given NLQ. We map the query graph QG into the database graph DG as follows: (1) Associate each query term in QG with a schema node in DG suing a mediator lexicon. Each mediator lexicon attribute names, Wh -words and attribute values), s is a schema node in the database graph, and d is the semantic distance between t and s . We also develop a few functions to identify person's names, locations, date and times, amount of money, and other numbers in case they are not in the lexicon. (2) Associate each edge in QG with a path in DG using a mapping table. (3) The portion of the mapped database graph is called an Answer Graph . Given a query graph and a da tabase graph, we propose an algorithm to find an answer graph that has the smallest sum of weights. This answer graph is called a Minimal Answer Graph (MAG) and its sum of weights is the semantic distance between the query and the database. Data bases will be ranked based on the semantic distances. Figure 4 shows the MAG for Query 1 . A typical ontology is organized into a concept hierarchy that is a tree or a graph. It specifies a conceptualization of a domain in terms of concepts, their attri butes and relationships. We use WordNet to construct the ontology construction semi-automatically. We use it to solve two problems: (1) Users use not only synonyms but also hypernym s (more generic terms for nouns and verbs) and hyponyms (more specific terms for nouns) or troponyms (more specific terms for verbs) to denote table or attribute names. (2) In NLQs, us ers often use verbs, some of which are difficult to be associated with any database nodes. We evaluate our approach in a university intranet with 21 databases. 112 NLQs were collect ed from CS graduate students. They identified the set of relevant databases for each NLQ. This information is used as the relevance assessment. We report the precision of correctly selecting th e top 1 ranked database to use for given user queries. If we only map keywords (i.e., query terms) to database values, the t op 1 precision is 53.6%; if we map keywords into all nodes in database graphs, the top 1 precision is 84.8%; if we map NLQs (keywo rds, Wh-words and semantic relations) into database graphs, th e top 1 precision is 89.3%; if we map NLQs and use an ontology, the the top 1 precision is 96.4%. The results show that: (1) Databa se schema is very useful. (2) Natural Language based search is superior to keyword based search. (3) Utilizing an ontology improves the effectiveness. This work is supported in part by NSF grants: IIS-0208434 and IIS-0208574. [1] S. Agrawal, S. Chaudhuri, a nd G. Das. DBXplorer: A system [2] D. A. Grossman, S. M. Beitzel, E. C. Jensen, and O. Frieder. [3] V. Hristidis and Y. Pa pakonstantinou. DISCOVER: Key-[4] A. Levy, A. Rajaraman, and J. Ordille. Querying hetero-[5] A. Popescu, O. Etzioni, and H. Kautz. Towards a theory of 
