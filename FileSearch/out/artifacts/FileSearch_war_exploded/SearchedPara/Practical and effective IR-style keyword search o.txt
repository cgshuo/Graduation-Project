 1. Introduction 1.1. Motivation
With the increasing amount of ontologies encoded in RDF/S or OWL languages available in semantic web, extensive sified into two major categories: the structured query approach and the semantic search. The former is standardized by detailed knowledge of underlying schemas and ontology languages. Nevertheless, the assumed scenario is not always true in practice, since these languages are complicated even for developers of semantic web applications. An alternative ap-mation retrieval.

This paper focuses on the problem of supporting effective keyword search over semantic web data. The semantic web data model (RDF/S or OWL) conforms to a node-labeled and edge-labeled directed graph (Hayes, 2004 ), where nodes repre-sent resources or literals and edges represent properties carrying heterogeneous semantics. In our proposed model, an answer to a keyword querying is a connected  X  X  X inimal X  subgraph, which contains all the query keywords. In a real-world semantic web application, there may exist a large number of literal nodes matching individual keywords and hence many query over an RDF graph with thousands of nodes). In addition, these answers should be reasonably ranked in decreasing relevance. Otherwise, uses will be discouraged to apply keyword search.

To illustrate our model, suppose a simplified scientific literature knowledge base shown in Fig. 1 . We assume the user
R tween those answers shown in Fig. 2 a and the one in Fig. 2 b. The candidate answer C same keyword K6 simultaneously. Actually, answers R 1 ; R users. For example, R 1 might be more desirable than R 2 and R
John and K6 . 1.2. Contributions The key contributions of this paper are the following:
We propose a novel IR-style keyword searching model for semantic web data retrieval. Our search scheme supports a free-model can generate answers with explicit semantics (connected subgraphs) and return ranked top-k results effectively.
We present an efficient searching algorithm for finding answers. The key problem is that there may be many potential answers matching a keyword querying over a large data graph. Efficiently locating these answers is a non-trivial challenge.

We conduct experiments over real datasets. Experimental results show that our model is feasible and delivers high-qual-ity search results.
 the experimental results. Finally, we conclude the paper and point out future research directions in Section 6. 2. Related work the problem of more complex semantic relationships (e.g., connected graphs other than individual paths) among multiple (e.g., more than 3) entities/keywords.
 To the best of our knowledge, only two papers Tran, Cimiano, Rudolph, and Studer, 2007; Zhou, Wang, Xiong, Wang, and translating keyword queries into formal logic queries. For example, Tran et al. (2007) translate keyword queries to
SHOIN  X  D  X  conjunctive ones using background knowledge available in ontologies. But the effectiveness of their methods still an unresolved yet difficult problem in information extraction or natural language understanding/processing (NLP).
Keyword search has also attracted a great deal of interest in the structured relational database (RDBMS) community re-degree. However, RDF graphs can carry much more complicated semantics than database graphs. Therefore, keyword search poses greater challenges in semantic web than in RDBMS. 3. Problem definition 3.1. Graph data model
Assume there is an infinite set U (URI references), an infinite set B  X f N the subject , has a property whose value is the object . An RDF graph is a set of RDF triples (Hayes, 2004 ).
We extend RDF semantics and model the data as a weighted directed graph G  X  X  V ; E ; w  X  , where V  X f between connected entities. The cost of the graph G is defined as the sum of the weights of all edges, that is,
A uniform edge weight function w (as in the web) might be insufficient since each edge ( property ) conveys different problem. On the instance level, if given the source node v w  X  e  X  is computed as follows: where w  X  T  X  is the weight of the edge typed T , and Degree  X  that, if a node has more incident nodes for a specific edge type, it represents a weaker relationship between them. 3.2. Query and answer semantics
Consider a query with l distinct keywords: Q  X f k 1 ; ... ; k Every keyword is contained in at least one literal node in R .
 corresponding keyword matching is lost. Additionally, if any none-literal node is removed, R becomes disconnected. To simplify the representation, we introduce a keyword-to-node mapping function p : K ! 2 the data. For each keyword k i 2f k 1 ; ... ; k l g , there is a set of literal nodes denoted with V p  X  k i  X  X  V i # V . As a result, there are totally l groups, i.e., V dant nodes/edges.
 As mentioned earlier, there may exist many possible answers satisfying the above requirements for a large data graph. mum cost answers/subgraphs to a keyword query. The answer with a smaller cost is ranked higher. When the number of 1981). Some approximation algorithms have been proposed for the group Steiner tree problem, such as minimum spanning generates the top-k answers, distinguished from the previous algorithms which are only to find one optimal/approximate one  X  X  X est X  answer in a large data graph. 4. Our solution for keyword search 4.1. An approximate algorithm
Then we construct the answer tree through repeatedly adding shortest paths to nodes which groups are not covered by give the definition of Shortest Path .

Definition 1. Shortest path The shortest path between a graph  X  V min{cost  X  u ; ... ; v  X j u 2 V 0 ;  X  u ; ... ; v  X  is a path between u and
Fig. 3 details major parts of the algorithm. Inputs are an RDF graph G  X  X  V ; E ; w  X  , a keyword query Q  X f k we assume V 1 ) and repeatedly construct an answer tree from each node in V execution of line 13, the Results will have j V 1 j answer trees satisfying the query, where j V
Then, we remove the original node from the tree and clean it up. Lines 23 X 25 are employed to prevent generating answer trees which may have been produced previously. We choose the newly produced tree with minimum cost and insert it into above processing. From Fig. 3 , we can see that the answer tree cost computation is incremental. are all indicated by circles. Suppose a query Q  X f K1 ; K2 ; K3 g . The algorithm first identifies three groups (i.e. V
As shown in Fig. 4 b, the tree is initialized to one node in group V node in group V 2 . Next, it continues to find another shortest path from the tree shown in Fig. 4 c to a node in V has not been covered. So one answer tree, with the total cost 7, is produced and inserted into Results , as shown in
Fig. 4 d. After generating the first result, we continue to initialize a tree to another node in V tree is omitted in the figures.

Now we can dequeue Results and produce other results (line 14 X 28). The algorithm finds a shortest path to another node by truncating redundant nodes and corresponding edges. Since V cost 8 is then inserted into Results . 4.2. Complexity analysis
The execution time of the proposed algorithm is dominated by the time needed for the shortest path computation. We mize the algorithm. For example, we can select the smallest group instead of any group (i.e., V query has only two keywords, the problem can be reduced to finding Dijkstra X  X  single-source shortest paths in time
O  X  k  X j V j log j V j X j E j X  X  . 5. Experiments 5.1. Experimental setup 5.1.1. Data set
We use real datasets from CiteSeer (http://www.citeseer.ist.psu.edu/oai.html ), including CiteSeer BibTex records and quickly identify groups for keywords.

We manually chose 40 queries for evaluation. These queries include a wide variety of keywords. The maximum number of based evaluation is simple and subjective, however, it still can indicate the effect of our approach compared to other methods in a certain degree.
 5.1.2. Evaluation metrics and comparison setup
As far as we know, there are no published works compared to ours. Although two works Tran et al., 2007, 2007 have ever and (2) Optimum model : this method first exhaustively finds all answer trees with their optimum costs (thus an NP-hard problem) and then selects top-k minimum cost trees.

The major goal of the experiments is to show the search performance and effectiveness of our model. Search performance returned for each query. 5.2. Results 5.2.1. Search performance cost of Optimum is much higher (more than 10 s) than the other two. In addition, the cost of Optimum almost keeps un-changed (very smoothly increasing). The reason is that it always exhaustively finds all answers and then simply outputs top-k results. Thus, the search performance of Optimum is unacceptable even for a medium sized semantic data graph. of results significantly, as shown later.

Next, we fix k  X  10 and vary the number of keywords l from 2 to 6. The average time costs are presented in Fig. 7 . The able in real-world applications. 5.2.2. Effectiveness better than Random , similar to the results in Fig. 8 . The MAP of Random is just 0.139.

From all the above the experimental results, we observe that our proposed model is effective in keyword searching. In addition, its search performance is much better than Optimum . Our model gives a good balance between the effectiveness and efficiency. Thus, we can draw the conclusion that our model achieves better overall performance compared to Random and Optimum . 6. Conclusion and future work
Existing semantic web data retrieval methods can be classified into two major categories: the structured query approach model, an answer to a query is defined as a minimal connected subgraph that contains all the query keywords. We provide about an order of magnitude (0.93 vs. 10 s). Hence, our model has better overall performance, compared to Random and Optimum .
 computing and indexing.
 Acknowledgements This work is supported by the National 973 Key Basic Research Program under Grant No. 2003CB317003, and the CityU Strategic Research Grants 7002102 and 7002214.
 References
