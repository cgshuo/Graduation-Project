 Wenjing Ruan 1 , Chaokun Wang 1 , 2 , 4 ,LuHan 1 ,ZhuoPeng 1 ,andYiyuanBai 1 , 3 With the rapid development of web technology, graph has considerable impor-tance in modeling of data in diverse scenarios, e.g., social networks, mobile networks and sensor networks. If the graph-structured data is uncertain, it is called an uncertain graph. For example, each edge of the graph has a probabil-ity of its existence in this paper. That i s to say the uncertainty is embodied in the relationships between nodes of the graph. A typical example of the uncer-tain graph is protein-protein interaction networks (PPI networks for short) [5]. In PPI networks, nodes denote protein mol ecules while edges denote the interac-tion relationships between protein molecu les. Limited by the measuring methods, we cannot accurately detect whether there is an interaction between two protein molecules. Therefore, an existence probability is set for each interaction.
Recently, uncertain graphs have become an increasing ly attractive focus in many fields. There are a number of algorithms proposed to solve mining and query problems in uncertain graph datab ase. Representative mining techniques in this area include finding top-k maximal cliques [11] and mining frequent sub-graph patterns [10]. Various query methods have been proposed to solve the essential problems of uncertain graph database, e.g., KNN query [4], the short-est path query [9], reliable subgraph query [3], and so on. All of the prior works haven not considered the uncertainty of the query graph, which is used to search matches in the uncertain graph database.

In the research field of uncertain graph management, the problem of uncertain subgraph query emerges when both the dataset and the query are uncertain. As shown in Figure 1, Q is an uncertain query graph, and D is an uncertain data graph. The uncertain subgraph query returns all the pairs of isomorphic existences between Q and D .

There are two challenges to deal with the above-mentioned problem. Firstly, the subgraph isomorphism verification is an NP-hard problem, and it will be more complex when the dataset and the query are both uncertain. Secondly, uncertain subgraph query problem has hig h complexity, especially when the size of the uncertain dataset is large.

To address the above challenges, a novel algorithm called Mutual-Match is proposed in this paper. The intuitive idea of Mutual-Match is using distributed computing methods to greatly improve the query performance. Thanks to the MapReduce model [1], Mutual-Match can effectively find out all matching pairs, each of which is composed by two isomorphic subgraphs derived, respectively, from the query graph and the data graph.
To the best of our knowledge, this paper is the first one addressing the problem of uncertain subgraph query. The main contributions of the paper are summa-rized as follows. 1. The problem of uncertain subgraph query over uncertain graph is formally presented. 2. An algorithm called Mutual-Match is proposed to process the uncertain sub-graph query over uncertain graphs with the MapReduce model. It can also exe-cute on dynamic uncertain graphs. 3. Extensive experiments are conducted to show the correctness and effectiveness of our proposed method.
 The rest of the paper is organized as follows. Section 2 gives the formal definition of the problem of uncertain subgraph query processing. We present a brute-force algorithm, and then propose an index structure and the Mutual-Match algorithm in Section 3. Moreover, we conduct an empirical study on both real-world and synthetic datasets in Section 4. Finally, we conclude in Section 5. Definition 1. An uncertain graph is defined as G ( V,E, X , X , X  ) ,where(1) V is a set of nodes; (2) E  X  V  X  V is a set of edges; (3)  X  is a set of labels; (4)  X  : V  X   X  is a function that sets a label to each node of V ;and(5)  X  : E  X  [0 , 1] is a probability function for edges.
 Given an uncertain graph G ( V,E, X , X , X  ), we can find out a certain graph G  X  ( V,E, X , X , X  ) which is generated from G when all the edges X  probabilities of G are 1. We call G  X  the underlining graph of G .

For a clear formalization of the problem of uncertain subgraph query over uncertain graphs, we use the possible world model. Each possible world of G corresponds to a subgraph of G  X  and has an existence probability that is com-puted according to the probability of every edge in G . In this paper, we assume that all the probabilities of edges distribute independently.
 Definition 2. Given an uncertain query graph Q and an uncertain data graph D , uncertain subgraph query is to find a set of matches. Each match which is denoted as a pair m ( q, d ) should satisfy the following two requirements. 1. q and d are certain graphs from the possible worlds of Q and D , respectively. 2. q and d are isomorphic.
 As shown in Figure 1, if we limit that the edge number of isomorphic subgraph is not less than 3, there are 5 matching pairs when searching uncertain subgraph matches of Q in D . One of the pairs is m ( q, d ).
 Definition 3. For n given uncertain query graph Q , an uncertain data graph D and one of their matches m ( q, d ) , the matching probability of m ( q, d ) is defined as where Pro ( q ) and Pro ( d ) are the existence probabilities of the corresponding possible worlds of Q and D , respectively. In this section, we first present the brute-force algorithm of uncertain subgraph query and then propose an effective index and the mutual-match algorithm which transforms the complex uncertain subgraph query on a large uncertain database to a series of MapReduce operations with the index structure. 3.1 Brute-Force Algorithm For a given uncertain query Q and an uncertain data graph D , the brute-force algorithm first transforms them into possible worlds W Q = { g 1 ,g 2 ,  X  X  X  ,g s } and W which contains all connected components of W Q . Each element of CS or W D is a certain graph with an existence probability, so that the brute-force algorithm evaluates the uncertain subgraph query by processing certain subgraph queries on W D m times. We build an index structure on all elements of W D with gIndex [7,8], which performs the best for most queries for sparse datasets in recent researches about indexes [2]. And then, search subgraph matches against each graph in CS using the gIndex.

This brute-force algorithm has to deal with exponential times of subgraph queries within an extremely large search space, if the query and data graphs are large. Clearly, it can only be applied to small datasets. 3.2 Mutual-Match Algorithm With the Mutual-Match algorithm, we need not know the possible worlds of uncertain data and query graphs before the query processing. In order to get amatchingpair m ( q, d ) from the uncertain query graph Q and the uncertain data graph D , the Mutual-Match algorithm first splits both Q and D into some small components which are denoted as bi-edge graphs. Then, with the help of the edge join operation (EJoin) which joins components together, q and d are gradually construc ted respectively.
 Definition 4. Given an uncertain graph G , a subgraph of G is called a bi-edge two corresponding edges e l , e r . In a bi-edge graph, v m is called the middle node. Bie ( G ) is the set containing all bi-edge graphs of G .
 Definition 5. Given two uncertain graphs G 1 and G 2 ,and e is one of their common edges. The operator EJoin ( G 1 ,G 2 ,e ) joins two graphs by merging the common edge e . Bi-Edge Index Structure. Before the query processing, we build an index struc-ture of the uncertain graph database based on the bi-edge graphs. Given an uncer-tain data graph D , we generate Bie ( D ) by decomposing D into bi-edge graphs. If where label m is from v m and label l &lt;label r ( &lt; is the partial order). The value We index bi-edge graphs by their labels. This bi-edge graph based index is imple-mented by a hash chain H . The ids of bi-edge graphs which have the same keyword are saved in a list denoted by blist ( label ).

We generate Bie ( Q ) and store each bi-edge graph in Bie ( Q )withthesame method as the data graph. And then, we search the database index for every label of bi-edge graphs of Bie ( Q ) and get the input file for MapReduce jobs. from  X  (  X   X  Bie ( D )) and qbi id is the unique identifier of  X  (  X   X  Bie ( Q )). posv and pose are vectors that save the matched nod es and edges, respectively. Every record of the input file is an initial matching pair.
 Algorithm Description. The Mutual-Match algorithm decomposes the query and data graphs into bi-edge graphs and then joins different bi-edge graphs according to the matching relation of these two graphs by EJoin. It coincides with the idea of MapReduce. The map and reduce phase can process this kind of query very well.

A MapReduce job chain assembles these initial matching pairs to find out all the query answers. The mapper of the Job 1 maps each line of the input file into two key-value pairs. Every edge of a bi-edge graph of the data graph acts as the key of a pair. Pairs that have the same key may be joined together with the common edge so as to form a bigger matching pair.

The reducer constructs matching pairs by the EJoin operation. It finds out the pairs with the same keyword, and then finds the joinable pairs, according to some join rules. These join rules contain: (1) common edge check, (2) join manner check, (3) identity check. The first two rules can be obtained from the process that decomposes the query graph into bi-edge graphs, and the last one will be obtained through the EJoin process. The common edge check aims to find out whether the two bi-edge graphs of the query graph, matched by bi-edge graphs from the data graph respect ively, have a common edge. If there is a common edge, the matched bi-edge graphs from the data graph are joinable. Apart from this, there are two kinds of join manners about different matching pairs. As shown in Figure 2, when the two bi-edge graphs are joined as the above manner, they have the same middle node. This is a middle-join . On the contrary, when joined as the below manner, their middle nodes are different, and this is a non-middle-join . The EJoin operation requires the two bi-edge graphs from data graph have the same join manner with the two matched bi-edge graphs from the query graph. If the two key-value pairs are joinable, nodes from Q and D must satisfy the one-to-one correspondence in their two posv vectors. The identity check will do the job to ensure that nodes of the two posv vectors satisfy the one-to-one correspondence.
 3.3 Improvement Our method can adapt to dynamic uncertain graphs well. That is the Mutual-Match algorithm can be improved to address the problem of uncertain subgraph query over dynamic uncertain graphs.
 When new edges are inserted or existin g edges are removed and original graph D becomes the new graph D , we don X  X  need to rebuild the bi-edge index for D considering all edges of D . Instead, we only take the new edges and the removed edges into consideration.

Suppose we have run the Mutual Match Algorithm for the data graph D and the query graph Q , and get the uncertain subgraph query result file RF which contains all matching pairs of D and Q .When D changes, for each removed edge e , we find matching pairs which contain e and remove these pairs from RF .For each new edge e , we build new bi-edge index related with e .Thenwegetthe new input file F . We process F in Mapper to produce key-value pairs P and choose records in RF whose keys are the same with the keys in P .Thenwe add these records to the file F . Finally, we construct new matching pairs of D and Q by EJoin operation in the MapReduce job chain (Job 2  X  Job 3  X  ...  X  Job n ) with F as the input file. Our experiments are conducted on two different environments. The index con-struction, MapReduce input file construction and the brute-force algorithm are performed on a 2.4GHZ, 2GB-memory, Intel(R) Core(TM) i5 CPU PC, running Ubuntu 10.10 operation system. The other is a MapReduce platform with 5 multithreaded cores. All the algorithms are implemented with Java. 4.1 Results on the Real-World Dataset We use a real-world dataset of CAL road network in our experiments. It con-tains 21,692 edges and 21,047 nodes. Every edge has a weight that indicates the uncertainty. We distribute labels to all of the nodes randomly.

Figure 3 shows the results on the real dataset. Firstly, we compare the time costs of the index construction of both Mutual-Match and brute-force algorithms. As shown in Figure 3(a), the time cost of the index construction of the brute-force algorithm increases rapidly. Meantime, that of the Mutual-Match algorithm is satisfactory and nearly constant. For example, the Mutual-Match method can index a 16-edge uncertain graph within just 2 ms.

The query efficiencies of both methods a re showed as Figure 3(b). The query time of Mutual-Match is computed by the sum of time costs to get MapReduce input file and MapReduce jobs. It shows that the MapReduce-Based Mutual-Match has a poor performance when the uncertain data size is too small. MapRe-duce is not designed for small data size. With the increasing of the data size, Mutual-Match is much more effective than brute-force. 4.2 Results on the Synthetic Dataset The synthetic dataset is generated using the gengraph win [6]. It is a node-labeled, undirected, uncertain data graph which contains 50,000 edges, and the average degree of the nodes is 3. As same as the real-world dataset experiments, labels of every node are distributed randomly. The probabilities of every edge that describe the uncertainty are distributed as Gaussian distribution.
Figure 4 shows the efficiency of our method on the synthetic dynamic graph dataset. We use MRMM to stand for the algorithm that computes matches from the beginning and DMRMM to stand for the algorithm that only takes changed edges into consideration. Figure 4(a) shows that the time cost of the index building of the DMRMM method is much smaller than that of the MRMM method for DMRMM does not compute all edges of the new graph. Figure 4(b) shows the efficiency of query processing in the MapReduce jobs. Clearly, the DMRMM method is faster than the MRMM method. Uncertain subgraph query is an essential operation on uncertain graph database. It is complicated due to the NP-hard isomorphism verification and uncertainty. MapReduce provides a good solution to this problem. In this paper, we have explored a Mutual-Match algorithm and an applicative index method to con-duct the uncertain subgraph query problem within MapReduce framework. Our MapReduce-Based Mutual-Match algorithm has effective performances on un-certain subgraph matching processing over static uncertain graphs and dynamic uncertain graphs.

