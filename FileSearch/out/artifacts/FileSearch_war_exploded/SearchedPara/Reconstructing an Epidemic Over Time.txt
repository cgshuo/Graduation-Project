 We consider the problem of reconstructing an epidemic over time, or, more general, reconstructing the propagation of an activity in a network. Our input consists of a temporal network , which contains information about when two nodes interacted, and a sample of nodes that have been reported as infected. The goal is to recover the flow of the spread, in-cluding discovering the starting nodes, and identifying other likely-infected nodes that are not reported. The problem we consider has multiple applications, from public health to so-cial media and viral marketing purposes.

Previous work explicitly factor-in many unrealistic assump-tions: it is assumed that (a) the underlying network does not change; (b) we have access to perfect noise-free data; or (c) we know the exact propagation model. In contrast, we avoid these simplifications: we take into account the temporal net-work, we require only a small sample of reported infections, and we do not make any restrictive assumptions about the propagation model.

We develop CulT , a scalable and effective algorithm to reconstruct epidemics that is also suited for online settings. CulT works by formulating the problem as that of a tem-poral Steiner-tree computation, for which we design a fast algorithm leveraging the specific problem structure. We demonstrate the efficacy of the proposed approach through extensive experiments on diverse datasets.
Rumours, like infections, spread over time. Consider a temporal network , which records when two nodes have inter-acted. Given such a temporal network in which a  X  X irus X  has been propagating, and a small sample of infected nodes over time, can we reconstruct the flow of the epidemic? That is, can we automatically identify the starting points of the epidemic, and reliably tell when every node got infected, including for those truly infected nodes that were never re-ported as such? Moreover, can we do so without having to assume a model for the virus spread? And, can we do this efficiently, with approximation guarantees, and in an online setting? We answer these questions affirmatively.

Reconstructing an epidemic, or a network propagation in general, has many important applications. These include studying how real viruses such as the flu or Ebola spread. This type of analysis is done by the Centre for Disease Con-trol (CDC) with the goal of better understanding of viruses for both preventing and controlling outbreaks. Other exam-ples include the analysis of influence propagation in social networks, as is done by social scientists and marketeers for better understanding and leveraging human behaviour.
Although diffusion processes have been widely studied, the problem of  X  X everse engineering X  network propagations has received relatively little attention. Moreover, existing work only considers few and relatively simple settings [7, 11, 13, 14]. For example, it is generally assumed that the graph over which the contagion spreads is static , that we know the model of how the contagion spreads, and that we can obtain complete noise-free observations of the state of the network. In this paper we do not make these unrealistic assumptions.
First of all, we explicitly take into account that influence can only spread when there is an interaction ; you have to read a status update from a friend to possibly be influenced by it. We therefore consider temporal networks , directed and weighted graphs that tell when two nodes interact. These highly dynamic graphs can be considered at different reso-lutions, from micro-seconds, to hours. Our algorithms work regardless of the time-resolution of the graph.

Second, we acknowledge that in reality, we can only obtain a small and noisy sample of the state of the network over test the entire population (see for example the surveillance pyramid [17]). Additionally, we face situations in which test results arrive over time, and they may include false posi-tives [15]. To address these considerations, we consider a general setting where over time we receive (possibly noisy) reports of the state of individual nodes. Our algorithm can operate both off-line and on-line given a stream of reports and a stream of network interactions.

Third, we acknowledge that in practice we seldom know how influence propagates exactly, and, that parametric mod-els such as Independent Cascade (IC) and Susceptible-Infected (SI) are strong simplifications of reality. We therefore take a non-parametric approach that relies on just a single as-sumption: shorter paths of infection are more likely.
All together, this allows us to define a cost of a descrip-tion of an epidemic based on interactions. We show that this formulation is related to the concept of directed Steiner trees, and that the problem of recovering the flow of an epi-demic can be efficiently solved with approximation guaran-tees. Empirical evaluation shows our method reliably recon-structs epidemics, outperforming meaningful benchmarks, regardless of whether the epidemic was truly generated by multiple fundamental models such as the IC, the SI, or the Forest Fire model.
Let V be a set of nodes. We write ( u,v,t ) to denote an interaction that occurs between nodes u and v at time t  X  R ; so t is a time-stamp . Interactions are directed , so ( u,v,t ) starts in u and ends in v , and can be weighted. For simplicity, however, we consider only unweighted graphs. A temporal network G = ( V,E ) consists of a set of interactions E = { ( u,v,t ) | u,v  X  V,t  X  R } over the set of nodes V . The number of nodes in the temporal network is denoted by | V | = n and the number of interactions by | E | = m . We assume that more than one interaction between two nodes u and v can appear in E with different time-stamps.
For a temporal network G = ( V,E ) and a node u  X  V we write V ( u ) to denote the set of all time-stamped copies of u for which u participates in some interaction of E , i.e., V ( u ) = { ( u,t ) | ( u,v,t )  X  E or ( v,u,t )  X  E } . We write V = S u  X  V V ( u ) for the set of all time-stamped nodes. Given a node u and a time interval [ t s ,t e ] we denote by V ( u, [ t s ,t e ]) the subset of nodes of V ( u ) whose time-stamp falls in the interval [ t s ,t e ]. Additionally, given an arbitrary set of time-stamped nodes X = { ( u,t ) } we define V ( X ) to be the set of nodes that appear in X , that is, V ( X ) = { u  X  V | ( u,t )  X  X } .

Next we consider a dynamic propagation process in the network, such as the spread of a virus in a physical social network or the adoption of an action/idea in an online social-media platform. We use the generic term active to refer to nodes that are activated (infected/adopted-a-product etc.) during the propagation process.

We assume that the propagation process is starting ex-ternally, from a small set of nodes ( S ), and all other nodes become active via interactions. In particular, if node u is active, and an interaction ( u,v,t ) occurs, then the node v may become active at time t , or it may not become active; it depends on the dynamics of the propagation process. Al-though our approach trivially generalises to multiple states, e.g., susceptible, infected, recovered, etc., for simplicity of exposition in the remainder we assume that once a node becomes active it remains active for the rest of its lifetime.
Apart from the previous very generic assumptions, we do not assume any particular model of the propagation process.
The activity-propagation flow in the network can be de-scribed as a set of time-stamped active nodes A = { ( u,t ) } X  V , where the time-stamp t indicates the first time that node u becomes active. Then we call V \A as the set of all po-tentially susceptible time-stamped nodes.

We consider the set A as the true activity propagation that occurs in the network, even though it may be non-observable . Instead we consider that we observe a (relatively small) set of activity reports R = { ( u,t ) } . A report ( u,t )  X  R indicates that node u was reported (or observed) to be active at time t . For a node to be reported it should have been activated earlier, thus, if there is a report ( u,t 1 then there should be an activation ( u,t 0 )  X  X  with t 0  X  t We write t R ( u ) to refer to the time that a node u is reported as active in R . If a node u is never reported as active, we define t R ( u ) = T , where T is the last time stamp in E .
Finally, we need to define temporal connectivity , as net-work activity propagates over temporal paths. A temporal path p between two time-stamped nodes ( u,t s ) and ( v,t a sequence of node-disjoint interactions ( u,w 1 ,t 1 ), ( w . . . , ( w j  X  1 ,v,t j ), such that t s  X  t 1 , t j  X  t all 1  X  i  X  j  X  1. Given a time-stamped root node ( r,t 0 and a set of terminals T = { ( u,t ) } , a rooted temporal Steiner tree is a subgraph of the temporal network G , which con-tains r with no incoming interactions and unique temporal paths from ( r,t 0 ) to every terminal node ( u,t )  X  X  .
Let P = { p 1 ,..., p ` } be a set of temporal paths. Denote by V ( P ) the set of time-stamped nodes that appear in any path in P , and by V ( P ) = V ( V ( P )) the set of non time-stamped nodes that appear in any path in P . We say that P spans a set of time-stamped nodes X  X  X  if every ( u,t )  X  X  comes after (i.e. t  X  t 0 ) corresponding ( u,t 0 )  X  X  ( P ).
Finally, given a set of temporal paths P , a node u is called a seed if u  X  V ( P ) and there is no interaction ( v,u,t )  X  p for any p i  X  P . The set of seed nodes induced by a set of temporal paths P is denoted by S ( P ).
Given a temporal network and a (partial) report log of ac-tive nodes, our goal is to discover a sequence of time-stamped node activations (which nodes and when) that explains best the observed report log, given the set of interactions in the temporal network. In general, the problem is as follows.
Problem 1. We are given a temporal network G = ( V,E ) , where E is a set of interactions over a set of nodes V . We are also given a report log R = { ( u,t ) } of time-stamped ac-tivated nodes, a set of candidate seeds C , and an integer k . The goal is to find a set of temporal paths P in order to minimize a cost function cost( P |R ) subject to: ( i ) P spans R ; ( ii ) S ( P )  X  C ; and ( iii ) | S ( P ) | X  k .

To make Problem 1 concrete we need to define the cost function cost( P |R ). Our approach is to introduce a weight function w : E  X  R on the network interactions E , which depends on the temporal network G and the report log R .
The weight function that is used in all the experiments of this paper is discussed in Section 5. We note, however, that there are many possible weighting schemes that can be explored and tested in practice. Our problem formulation is also meaningful for uniform weights, in which case we want to explain the activity-propagation history with as few in-teractions as possible. In any case, our theoretical results do not depend on the particular definition of w and are ap-plicable for any weight function.

Given a weight function, we then assume that the cost of a path is the sum of the weights of the interactions on the path. Then it is natural to model the total cost of the set of paths P , as total cost of all interactions that are included in P , i.e.,
Problem 2. ( TempSteinerTree ) Solve Problem 1 with cost function cost( P |R ) given by Equation (1).
Regarding the complexity of the TempSteinerTree prob-lem, we can show the following.
 Proposition 1. Problem TempSteinerTree is NP -hard.
A proof of Proposition 1 can be obtained in a similar man-ner as in the work of Huang et al. [6].
To solve the Steiner-tree problem on temporal networks, as defined in the previous section, we map it to the stan-dard Steiner-tree problem on static (not temporal) directed graphs. The latter problem is defined as follows.

Problem 3. ( MinDirSteinerTree ) We are given a di-rected static graph H = ( U,F ) with edge weights w : F  X  a root node r  X  U and a set of terminal nodes R  X  U . We want to find a directed tree T , rooted in r and containing directed paths from r to every node in R such that total tree cost P e  X  F ( T ) w ( e ) is minimized.

We first show that for k = 1 the TempSteinerTree prob-lem can be mapped to MinDirSteinerTree .

Proposition 2. For k = 1 the TempSteinerTree prob-lem can be solved by | C | calls to MinDirSteinerTree . Proof. Let us consider an instance of the TempSteiner-Tree problem: a temporal network G = ( V,E ), a report log R = { ( u,t ) } , and a set of candidate seeds C . Given this problem instance, we construct a directed static graph H = ( U,F ) as follows. We first define U to be the set of time-stamped nodes V . For each node u  X  V of the tem-poral network G we order its time-stamped copies { ( u,t ) } in V in ascending time order, and we connect every two consequent copies ( u,t i ) and ( u,t i +1 ) by a directed edge with zero weight. Additionally, for each interaction ( u,v,t )  X  E we create a directed edge e (( u,t ) , ( v,t )), which is added in F with weight w (( u,t ) , ( v,t )) = w ( u,v,t ).
From the construction it follows that there is a bijection between the set of all temporal paths in G and the set of all directed paths in H .

Next, for every candidate seed node u  X  C we create a dummy node z ( u ). The set of all dummy nodes is z ( C ) and it is also added to the set of static nodes U . For each candidate seed node u  X  C we define t 0 ( u ) = arg min { t | ( u,t )  X  V} , that is, the earliest possible start of a temporal path for that seed node. An edge connecting z ( u ) with ( u,t 0 ( u )) is created and it is added to F with zero weight.
 Finally, we need to specify the set of terminals R for Min-DirSteinerTree . For each report ( u,t )  X  R we find the latest time t  X  ( u,t ) that node u participated in an interaction that took place before t , that is, t  X  ( u,t ) = arg max { t ( u,t 0 )  X  X  and t 0  X  t } , and we add ( u,t  X  ( u,t )) in the set of terminals R .

It is easy to see that there is a bijection between the set of directed Steiner trees of H rooted in z ( C ) and the set of temporal Steiner trees in G rooted in C . Furthermore, the corresponding trees have the same cost. Also if a terminal is connected in a directed Steiner tree then the corresponding report is covered in the corresponding temporal Steiner tree. It follows that the TempSteinerTree problem in G can be solved by | C | calls to the MinDirSteinerTree problem in H , one for each root z ( u ), for seed u  X  C .

The next step is to consider the TempSteinerTree prob-lem for k &gt; 1. The straightforward generalization of the con-struction presented in Proposition 2 is to create a dummy node for each k -size subset of C , and make a call to MinDir-SteinerTree for each such dummy node. This approach, however, is not scalable as it requires | C | k calls to MinDir-SteinerTree .

To avoid such a combinatorial explosion we follow a dif-ferent approach. We introduce a Lagrange-type parameter  X  and we modify the objective by adding a term represent-ing the number of temporal Steiner trees, weighted by  X  . A target value for k can be found by varying  X  . The  X  -version of TempSteinerTree is defined below.

Problem 4. (  X  -TempSteinerTree ) We are given a tem-poral network G = ( V,E ) , reports R , a set of seed candi-dates C , and a number  X  . We want to find a set of temporal Steiner trees T , which spans all nodes in R and the total cost cost  X  ( T ) =  X  |T| + P T  X  X  P e  X  T w ( e ) is minimized, where |T| denotes the number of temporal Steiner trees in T .
It is easy to see, by setting  X  appropriately large so that the optimal solution contains only one tree, that Problem 4 remains an NP -hard.

Proposition 3. Problem  X  -TempSteinerTree is NP -hard.
 We can now show that for a given value of  X  ,  X  -Temp-SteinerTree can be reduced to an instance of the Temp-SteinerTree problem with k = 1. The mapping follows the proof of Proposition 2 and constructs a static graph H . In addition, a new dummy node z 0 is added, and it is connected via a directed edges of weight  X  to other dummy nodes z ( u ) (as before there is one dummy node z ( u ) for each candidate seed u  X  C ). Then, given a minimum Steiner tree T H rooted at z 0 , the optimal set of Steiner trees for the  X  -TempSteinerTree problem can be obtained as the level-1 branches of T  X  . Thus, we obtain the following proposition. Proposition 4. For a given value of  X  , the problem  X  -TempSteinerTree can be solved with one call to the Min-DirSteinerTree problem.

For a z 0 -rooted Steiner tree T  X  returned as a solution to the MinDirSteinerTree problem, we denote the degree of z in T  X  by d ( z 0 | T  X  ). Note that for a large  X  the degree of z will be small, while for  X  = 0 the degree of z 0 can be as large as the number of candidate seeds in C .
 As our goal is to find a target number k of temporal Steiner trees by varying  X  , and as the number of returned Steiner trees is given by d ( z 0 | T  X  ) in the solution of DirSteinerTree , we would like to show that d ( z 0 | T  X  a monotone function of  X  .
 Proposition 5. Let  X  1 &lt;  X  2 and consider the optimal Steiner trees T  X   X  1 and T  X   X  2 obtained by the mapping to DirSteinerTree . Then d ( z 0 | T  X   X  1 )  X  d ( z 0 | T  X 
Proof. Let c 1 and c 2 be total costs of the branches of z in the optimal trees T  X   X  1 and T  X   X  2 , respectively. By the opti-mality of the two solutions in their corresponding problem instances we have and It follows that  X  ( d ( z 0 | T  X   X  1 )  X  d ( z 0 | T  X   X  2 ))  X   X  2 ( d ( z and thus, Hence, d ( z 0 | T  X   X  1 )  X  d ( z 0 | T  X   X  2 ).

As the number of branches of z 0 in T  X  is a non-increasing function of  X  we can use binary search on  X  to obtain a feasible solution for the TempSteinerTree problem, for a given k . The lower boundary for the binary search is set to  X  ` = 0, while the upper boundary  X  u must be selected so as to ensure that d ( z 0 | T  X   X  u )  X  k , or asserting that it is not possible to find a tree with less than k branches from z The following proposition provides such a value for  X  .
Proposition 6. Let L be the weighted length of the longest shortest path from a node in the candidate seed set C to a node in the reports set R . Then the value  X  u = L |R| pro-est possible degree for z 0 among all Steiner trees that can be found as a solution to the MinDirSteinerTree problem, for any  X  .

Proof. Let c 1 be the minimum total cost along the bran-ches of the Steiner tree that has the smallest possible number of branches k min from z 0 . Let c 2 be the minimum total cost along the branches of any feasible Steiner tree with more than k min branches from z 0 .

We want a value of  X  for which solution tree T  X   X  has at most k min branches from z 0 . Thus, we require  X k min + c  X  ( k min + 1) + c 2 , which gives  X   X  c 1  X  c 2 . Upper bounding c by L |R| and lower bounding c 2 by 0 proves the claim.
Note that the value of  X  given by Proposition 6 guarantees that d ( z 0 | T  X   X  ) = 1, if there exists a directed Steiner tree rooted in one of the nodes of the candidate seeds C and spanning all nodes in the reports set R .
The best approximation algorithm for the directed Steiner-tree problem is given by Charikar et al. [1]. The algorithm is based on the recursive construction of  X  -level trees by concatenating subtrees with the lowest marginal normalized length . The approximation guarantee of this algorithm is  X  (  X   X  1) s 1 / X  , where  X  is a depth of the recursion and s is the number of terminals. Note that  X  is a user-controled param-eter that offers a quality X  X fficiency trade-off. Increasing  X  improves the approximation guarantee of the algorithm at the cost of running time. Huang et al. [6] proposed a time-efficient modification of this algorithm with running time O ( n  X  s  X  ), where n is the number of nodes in the graph. How-ever, the algorithm is still not practical for large networks.
In this section we show how to further improve the run-ning time of the Steiner-tree algorithm so that it becomes scalable to large networks. Our algorithm leverages the spe-cial structure of the problem, that is, the fact that the static directed graph is derived from a temporal network. We show that it is sufficient to keep track only on a small number of paths, which we call global shortest temporal paths .
Algorithm 1: A i ( j,r,X ) : i -level directed Steiner tree (Charikar et al. [1])
Input: Directed graph H = ( U,F ), set of uncovered
Output: Steiner tree T rooted at r that covers at least 1 if there are not j terminals in X reachable from r then 2 return  X  3 T =  X  ; 4 while j &gt; 0 do 5 T  X  =  X  ; 6 foreach r 0  X  U and j 0 : 1  X  j 0  X  j do 7 T 0 = A i  X  1 ( j 0 ,r 0 ,X )  X  X  ( r,r 0 ) } ; 8 if len( T  X  ) &gt; len( T 0 ) then 9 T  X  = T 0 ; 10 T = T  X  T  X  ; 11 j = j  X  X  X  X  U ( T  X  ) | ; 12 X = X  X  U ( T  X  ); 13 return T
Additionally, our algorithm can be executed in an online fashion, as new interactions and/or new reports arrive. The basic approximation algorithm. We start by de-scribing the basic algorithm of Charikar et al. [1], which is also presented as Algorithm 1. Let H = ( U,F ) be the di-rected graph defined in the proof of Propositions 2 and 4. For any pair of nodes ( u,v )  X  U  X  U we define ` ( u,v ) to be the length of the shortest path from u to v in H . If no such path exists, then ` ( u,v ) =  X  .
 The algorithm uses the variable A i ( j,r,X ) to denote a Steiner tree rooted at node r and covering at least j nodes from a set of terminals X  X  U . The zero-level tree Steiner tree A 0 ( j,r,X ) consists of the root r itself. The Steiner tree A ( j,r,X ) is constructed by connecting the root r with the j closest terminals in X . For i &gt; 1 the algorithm recursively finds the best subroot r 0 , and the best number of terminals j so as to minimize the normalized length of the subtree T 0 A terminal covered. The best choice for T 0 is used as a subtree in the current level of recursion, the terminals reachable by T are declared covered, and the algorithm continues to cover the remaining j  X  j 0 terminals required. As mentioned, the normalized length of a tree T is defined as its total length divided by the number of covered terminals, that is, Algorithm 1 provides an approximation guarantee for the MinDirSteinerTree but is quite inefficient. In order to avoid re-computing shortest paths multiple times, we can pre-compute all shortest-path distances ` ( u,v ) for all pairs of nodes ( u,v )  X  U  X  U , but such a pre-computation requires O ( | U | 2 ) space and O ( | U |  X  ) time. 1 In terms of the temporal-network input size, it is | U | = O ( |V| ) = O ( | E | ), where E is the set of interactions in the network. When space require-ments are limited we can execute the algorithm without pre-
O ( n  X  ) refers to the fastest algorithm for matrix multipli-cation. The current value of the exponent is  X   X  2 . 373. computing all-pairs shortest paths, but then running-time cost is higher. Clearly such a space and running-time com-plexity is prohibitive for large networks.
 Improving the running time. We can improve the run-ning time of the algorithm significantly by exploiting the special structure of our problem, namely, the fact that the directed graph H = ( U,F ) has been constructed in a specific manner from the input temporal network. Recall that the set of nodes of H consists of time-stamped copies of nodes { ( u,t ) } = S u  X  V V ( u ) and dummy nodes S u  X  C { z ( u ) } X  X  z where z ( u ) is a dummy node for a candidate seed u  X  C .
Our main observation is that it suffices to compute short-est paths only between dummy nodes z ( u ) and a single time-stamped node ( v,t ), for each candidate seed u  X  C and each v  X  V . The time-stamp of ( v,t ), for which the shortest path is kept, is the report time t R ( v ) (recall that if a node v is not in the reports set, then t R ( v ) is defined to be the last time stamp in E ). We refer to these paths as global shortest temporal paths . More specifically, the global shortest tem-poral path between candidate seed u  X  C and node v  X  V is defined to be where p is a temporal path. We also write L ( u,v ) = ` ( q ( u,v )) to denote the length of a global shortest temporal path q ( u,v ). It is easy to see that we can compute and store global shortest temporal paths using O ( | C || V | ) space and O ( | C || E | ) time. Furthermore, global shortest temporal paths can be updated for all candidate seeds in O ( | C | ) time, when a new interaction arrives in the temporal network. Thus, global shortest temporal paths not only yield significant per-formance improvement but they also make the algorithm suitable to be executed in a streaming fashion.

If we consider a 2-level Steiner tree, we can notice that it essentially consists of a dummy root z 0 with branches, rooted in dummy candidate seeds z ( u ). Each branch is a 1-level Steiner tree, thus it is simply a set of shortest paths from z ( u ) to terminals. By definition, a global shortest tem-poral path is no longer than any other path to a terminal. Thus, each branch can be viewed as a set of global shortest temporal paths from z ( u ) to terminals. In addition, for a 2-level Steiner tree we can avoid trying all possible subsets of terminals to be covered: we can simply consider terminals in order of increasing global shortest path length.
We can now show that while keeping only global short-est temporal paths we can still calculate the minimum-cost Steiner tree on H with the same guarantee as Algorithm 1. Proposition 7. Consider the transformed directed graph H = ( U,F ) , and assume a set of candidate seeds C = U . Assume that we want to find a Steiner tree rooted at z 0 and spanning a set of terminals X , with | X | = s . Then, by executing Algorithm 1 for depth  X  = 2 and using only global shortest temporal paths we can calculate the minimum-cost Steiner tree with approximation guarantee  X  (  X   X  1) s 1 / X 
Proof. First note that the global shortest temporal paths prune away only information about non-optimal paths from a dummy node z ( u ) to a node ( v,t )  X  U , while preserving the shortest one. To see this, consider a global shortest tem-poral path q ( u,v ) from z ( u ) to ( v,t i ). For all shortest paths Algorithm 2: Temporal Steiner forest construction
Input: Temporal network G = ( V,E ), set of candidate
Output: Temporal Steiner forest T  X  G , rooted at 1 foreach u  X  C and v  X  V do 2 obtain global shortest temporal path L ( z ( u ) ,v ); 3 T =  X  ; 4 X = V ( R ); 5 while X 6 =  X  do 6 T 0 1 =  X  ; 7 foreach z ( u )  X  C do 8 T 1 =  X  ; cost =  X  ; profit = 0; 9 for v  X  X ordered by increasing L ( z ( u ) ,x ) do 10 T 1 = T 1  X  q ( z ( u ) ,v ); 11 cost + = L ( z ( u ) ,v ); 12 profit + = 1; 15 T = T  X  T 0 1 ; 16 X = X \ V ( T 0 1 ); 17 return T ; p in H between z ( u ) and a time-stamped node ( v,t j ) with t  X  t i we have ` ( p 0 ) = L ( u,v ).

Next, we show that for any best tree selected in the for-loop of Algorithm 1, there is always a tree, which has at most the same normalized length and it is rooted in a dummy node z ( u ), for some u  X  C .

Indeed, assume that Algorithm 1 picks a 1-level tree T 0 , which is rooted at a node ( u,t 0 ) and covers a subset of ter-X 0 is reachable from ( u,t 0 ), it is also reachable from any rooted in z ( u ) that covers the same set of terminals X claim that T is less expensive than T 0 . To see this note that T is P x  X  X 0 ` ( z ( u ) ,x ), while by the definition of the global shortest temporal path ` (( u,t 0 ) ,x )  X  ` ( z ( u ) ,x ).
Proposition 7 requires that the set of candidate seeds C is equal to U . Note that in many applications we do not have a reason to exclude any candidate seeds, so this is a perfectly reasonable assumption. In cases that the set of candidate seeds is a subset of the whole node set we can still use the algorithm and obtain improved running time, however, the approximation guarantee does not hold.

The resulting algorithm is presented in detail as Algo-rithm 2. The input is the temporal network G = ( V,E ), a set of candidate seeds C , and a report log R . For every candidate v  X  C (and corresponding dummy node z ( v )) we compute the global shortest temporal path to every node in V and sort these paths in ascending length order. While not all terminals are covered, the algorithm computes the cost of all possible 1-level trees composed of global shortest temporal paths, finds the one with the smallest normalized density, and adds it to the solution. The ordering the global shortest temporal paths allows to test all possible trees in linear time. The algorithm returns a set of trees T , which reconstructs the observed activity propagation. Algorithm 3: Global shortest temporal paths
Input: Time series of interactions E , set of seed
Output: global shortest temporal path from each seed 1 L =  X  ; L  X  =  X  ; 2 foreach e = ( u,v,t )  X  E do 3 foreach x  X  C with t  X  t 0 ( x ) do 4 if u = x then 5 L ( x,x ) = 0; 6 q ( x,x ) = ( t,x,x ); 7 if u  X  V ( R ) and t  X  t R ( x ) and 8 L  X  ( x,x ) = L ( x,x ); q  X  ( x,x ) = q ( x,x ) 9 if L ( x,u ) 6 = NaN then 10 cost = L ( x,u ) + w ( e ); 11 if L ( x,v ) &gt; cost then 12 L ( x,v ) = cost; 13 q ( x,v ) = q ( x,u )  X  X  ( u,v,t ) } 14 if v  X  V ( R ) and t  X  t R ( v ) and 15 L  X  ( x,v ) = L ( x,v ); q  X  ( x,v ) = q ( x,v ) 16 foreach ( x,x )  X  L do 17 if L  X  ( x,x ) = NaN then 18 L  X  ( x,x ) = L ( x,x ) 19 return L  X  and q  X  ;
Note that the performance of Algorithm 2 can be further improved by incorporating the pruning techniques described in the recent paper by Huang et al. [6]. Details on this improvement are omitted for lack of space.
We now describe the last piece of our algorithm, how to compute global shortest temporal paths. The main obser-vation for computing temporal shortest paths from a set of time-stamped nodes V ( u ), for a candidate seed u  X  C , it sufficies to consider only the shortest paths from the corre-sponding dummy node z ( u ). We can then compute global shortest temporal paths by processing the interactions in as-cending time order and updating the current shortest paths from each dummy node z ( u ) to all nodes in V .

The algorithm is shown in detail in Algorithm 3. For each candidate seed u  X  C and node v  X  V we keep the For each new interaction ( w 1 ,w 2 ,t ) processed (in ascending time order) we check if the current shortest temporal path p ( z ( u ) ,v ) can be improved by using ( w 1 ,w 2 process an interaction for which t  X  t R ( v ), we fix the current p ( z ( u ) ,v ) to be the global shortest temporal path from z ( u ) to v . However, we keep updating p ( z ( u ) ,v ), as it may be used by other shortest paths.
We summarize our main algorithm, as presented in the previous sections. Starting with the temporal network G a set of reports R , and a target number of candidate seeds k , we solve the  X  -TempSteinerTree problem using the trans-formation presented in Proposition 4 and Algorithm 2. Us-ing binary search, a value of  X  is found, for which the root ( z 0 ) of the returned Steiner tree has degree equal to k .
In this section we empirically evaluate CulT . The imple-mentation of all algorithms and scripts used for the experi-mental evaluation are publicly available. 2 Datasets. We consider both synthetic and real temporal networks, and both synthetic and real activity propagations.
For Synthetic dataset, we start by generating a static background network of n = 100 nodes with a powerlaw de-gree distribution. Uniformly at random we choose k seed nodes, from which we start the activation propagation pro-cess using some model. Keeping track of the sequence of successful activations, we add  X  = 100 random interactions between each pair of consecutive activating interactions.
We also consider real networks with simulated activity propagations. We consider Facebook , Tumblr , Students , and Enron . We use subgraphs of these networks with n = 100 nodes, obtained by BFS starting from a random node. Facebook is a 3-month subset of Facebook activity in a New Orleans community [16]. The dataset contains anony-mized list of wall posts (interactions). Tumblr is subset of the Memetracker dataset, 3 which contains quoting between Tumblr users. Students 4 is an activity log of a student online community at the University of California, Irvine. Nodes represent students and edges represent messages, where the message direction is suppressed. Finally, Enron 5 is a well-known dataset of email communication. For experiments with real-world infection cascades we considered emails, con-taining word California , as infected.

To generate the infection paths, we consider four differ-ent propagation models. In particular, we experiment with susceptible-infected ( SI ), shortest path ( SP ), independent cascade ( IC ), and forest fire ( FF ). For each we simulate a propagation until at least half of the nodes are activated. For SI we use infection probability 0 . 1, threshold number of active neighbors for FF is 1, activation probability for IC is set to inverse of the largest eigenvalue of an adjacency matrix (related to the so-called  X  X pidemic threshold X  [10]).
Finally, to create the reports R , we use two different schemes. In the first (refer as RS ), for each interaction every activated node has a probability  X  to be reported. In the second ( FR ), nodes at the frontier of the activation are re-ported after a  X  interactions. By combining the two schemes we can evaluate how strongly the methods rely on frontier and on intermediate reports.

Our last dataset is Flixster 6 : A dataset from movie ratings social network. Given a friendship network and data on which user has rated which movie and when, we create an interaction ( u,v,t j ) in E , if user v has rated movie f at t his friend user u has rated f at t i and t j  X  t i  X  7 days. https://github.com/polinapolina/ reconstructing-an-epidemic-over-time snap.stanford.edu/data/memetracker9.html toreopsahl.com/datasets/#online social network www.cs.cmu.edu/  X ./enron/ www.cs.ubc.ca/  X jamalim/datasets
For Flixster we took a movie f (ID=54053), which was rated by 10 K users, constructed a history of interactions E , and defined the first 10 users who rated f before their friends to be seeds. We consider all interactions, induced by movie f and propagated from these seeds. Then we sample reports among frontier nodes with probability 0 . 5 and delay  X  = 1000 interactions.
 Baselines. As no other methods exist to reconstruct an epidemic in a temporal network, we compare CulT to two sensible baselines. The first is straightforward, we simply ac-count for the given reports R ( Reports ). Somewhat more refined, the second baseline ( Baseline ) returns the one-hop-cascade from the given reports. That is, given a reported activation ( u,t ) Baseline assumes that every future inter-action ( u,v,t ) leads to a successful activation. The acti-vation is not propagated further than one-hop-neighbors of a reported node, however, as that unduly harms precision. Although none of the two baselines returns a collection of k temporal Steiner trees, we can still evaluate their accuracy against a ground-truth set of activated nodes. For instance, note that Reports has precision 1.0.
 Weighing scheme. As pointed out in Section 3, our ap-proach relies on a weighing scheme to identify which paths are to have participated in the activity-propagation process. In particular, for a node u that is reported to be active at time t R ( u ) we assume that an interaction ( u,v,t ) is more likely to have contributed in the activation of u if the time of the interaction t is close to the report time t R ( u ). Thus, we set the weight of an interaction to be the average time dif-ference between the interaction time-stamp and the report times of the two interaction end-points. In other words, we set w ( u,v,t ) = 1 2 ( | t  X  t R ( u ) | + | t  X  t R ( v ) | ). Measures. To evaluate the quality of a set of temporal Steiner trees T , we compare the set of nodes in the Steiner trees with a ground-truth set of activated nodes. To measure the quality we use Matthews correlation coefficient ( MCC ):
MCC = TP  X  TN  X  FP  X  FN p where TP = | V ( A )  X  V ( T ) | , TN = | V \ ( V ( A )  X  V ( T )) | , FP = | V ( T ) \ V ( A ) | , and FN = | V ( A ) \ V ( T ) | .
We also evaluate how well we recover the temporal order of activations , comparing the activation order in the discovered Steiner trees with the ground-truth order. As the activation order is captured by a set of interactions, we measure agree-ment with the ground truth in precision and recall.
We ignore the exact time of the activation and we consider the sets of pairs of nodes ( u,v ) so that u activated v . We again compare the set of pairs of nodes discovered by our method against the ground-truth set. We refer to these sets of node pairs as static order of activation , and we report precision and recall.

All reported values are averaged over 100 runs.
We start by evaluating the effect of binary search. The question we want to address is the following: can we find a value for  X  to obtain a target value of seeds k ? The relation of  X  vs. k is shown in Figure 1. We use the Facebook dataset with parameters: SI , reporting scheme FR (  X  = 100), and  X  = 100. The target number of seed is set to k = 5.
To obtain Figure 1 we solve  X  -TempSteinerTree for a
Figure 1:  X  is (easily) optimizable. True K = 5 . Figure 2: MCC for Synthetic powerlaw graphs of varying  X  . We indicate the best-fitting values of  X  for each of the real world datasets we consider. range of values of  X  . All reported values are averaged over 100 of runs. The left-most plot shows how  X  influences the number of seeds found. This result is noteworthy, as in Proposition 5 we assume that we can solve  X  -TempSteiner-Tree optimally, while in practice we can only solve it ap-proximately. Since the dependence of  X  vs. k is monotonic also in practice, we can conclude that the binary-search ap-proach is effective. The right-most plot shows the solution cost as a function of k . Although in this paper we do not address the problem of discovering the optimal value of k , note the  X  X lbow X  near the ground-truth value of k = 5.
The degree distribution of many real-world graphs closely follows a power-law with  X  between 2 and 3. Hence, it is in-teresting to evaluate how well CulT performs on such data. We run CulT on synthetic networks generated for differ-ent values of  X  . MCC scores are shown in Figure 2. We observe that CulT is particularly accurate in the range of  X  = [1 . 5 , 3 . 5], which corresponds to the range in which most real networks fall. To corroborate, we also indicate the val-ues for  X  that best fit the real networks used in this paper.
Next, we investigate how well CulT can reconstruct prop-agations for a range of different settings.

First, we simulate the SI model on our four real-world datasets, and inject different numbers of noise interactions. MCC scores are reported in Figure 3. We observe that the performance of CulT slightly declines as the fraction of rel-evant interactions decreases. That is, even if only very few interactions are related to the activity propagation, we are still able to recover the ground-truth propagation.
Second, we evaluate how well we can reconstruct propaga-tions generated by different models. We simulate cascades on the Facebook network using all four models: SI , SP , IC , and FF . We again vary the number of relevant interactions. The results are shown in Figure 4. CulT performs very consistently, regardless of the generating model.

Last, we check how the delay between a node activation and its reporting affects performance. We simulate the SI model on the four real datasets, and vary the delay between 0 and 5000 time steps. Results are provided in Figure 5. CulT is almost not affected at all by delays in reports, whereas the performance of Baseline deteriorates quickly.
Next, we evaluate how well we can reconstruct the order of infections in our temporal network. We use the fron-tier ( FR ) reporting scheme, while varying the fraction of reported frontier nodes. Figure 6 shows that the precision for both temporal order and static order is quite robust. In both cases the fraction of reported frontier nodes affects only the recall. When the number of the frontier nodes in the re-ports is low, CulT ignores many activated  X  X eaves, X  which are neither in the reports, nor on the path to any other re-ported node. Thus, the number of false negative increases.
Naturally, the accuracy for static order is higher than for temporal order: an interaction between the same two nodes can occur at several time moments and it is difficult to select the correct one into a reconstructed propagation path.
Next we present our results on the Flixster dataset. The sequence of interactions E is divided into epochs ( t 0 ,t At the end of each epoch t i we consider a snapshot of the network and compare the set of discovered activated nodes Figure 7: MCC on Flixster (left) and Enron (right). with the set of ground-truth activated nodes in V ( A [ t Results shown in Figure 7 indicate that CulT gives high quality solution during the whole time interval, while the performance of Baseline degrades significantly with time. Last, but not least, we evaluate the scalability of CulT . We conducted these experiments on a 3.30GHz Intel Xeon machine with 16GB of memory.

First, we consider running time with respect to the num-ber of interactions E in the temporal network. We construct a set E of a required length by increasing  X  on the Facebook dataset. We show the results in the left-most plot of Fig-ure 8. As the plot shows, CulT scales well with | E | .
In the center plot of Figure 8 we show the running time on the Facebook dataset, where we vary the number of acti-vated nodes up till all nodes in the network are included. We see again a graceful increase in running time, almost linear.
Third, we investigate the applicability of CulT in a stream-ing scenario: we therefore report the running time per up-date , as the number of newly-arrived interactions increases. To this end we use the Facebook data, and vary the  X  param-eter to create a sequence of 3 000 interactions. We run CulT on the first 1000 interactions, and use the rest to test the update times. The total update time consists of two com-ponents, 1) the time needed to update the global shortest paths, and 2) the time needed for performing binary search. As can be seen in the right-most plot of Figure 8, the time for binary search remains constant regardless of the size of the batch of new interactions. On the other hand, as ex-pected, the time needed for path updates increases with the batch size. Note, however, that even for larger batch sizes the total update time is less than a second.
Although diffusion processes have been widely studied in general, the problem of  X  X everse engineering X  an epidemic has received relatively little attention. Shah and Zaman [14] for-malized the notion of rumor-centrality to identify the single source node of an epidemic under the SI model, and gave an optimal algorithm for d-regular trees , whereas Chen et al. [2] give a cubic-time approach. Prakash et al. [11] stud-ied recovering multiple seed nodes under the SI model by MDL, while Lappas et al. [7] study the problem of identi-fying k seed nodes, or effectors of a partially activated net-work, which is assumed to be in steady-state under the IC (Independent-Cascade) model. Feizi et al. [4] and Sefer et al. [13] do the same for multiple snapshots, where the former consider SI, and the latter do so for the SEIRS model. All assume complete graphs and noise-free snapshots.

Correcting for the effects of missing data in cascades has not seen much attention. Sadikov et al. [12] aim to cor-rect for sampling in broad statistical terms (like recovering the average size and depth of cascades) assuming a modi-fied cascade model (k-trees). Farajtabar et al. [3] consider identifying a single seed given multiple partially observed cascades, assuming the SI model.

Closest to our work are Sundareisan et al. [15], who simul-taneously find the starting points of the epidemic and miss-ing infections given one sampled snapshot, assuming the SI model. In contrast, our paper addresses the general prob-lem of finding missing nodes, given several noisy snapshots (possibly at different times), without assuming any model.
The term  X  X ynamic graphs X  is typically used to refer to the model where edges are added or deleted in a graph. In the dynamic-graph setting, once an edge is inserted in the graph it stays  X  X live X  until the current time or until it is deleted. For example, this setting is used to model individ-uals establishing friendship connections in social networks.
Our model, on the contrary, intends to capture the contin-uous interaction between individuals. In this model, which we refer to as  X  X emporal network, X  each edge has an associ-ated time-stamp recording an interaction at that point. The temporal-network model is more recent than the dynamic-graph model. Two extensive surveys are provided by Holme and Saram  X  aki [5] and Michail [9].

We refer the reader to the paper of Masuda and Holme [8] for a thorough survey on existing work related to epidemics in temporal networks. To the best of our knowledge the problem of reconstructing activity propagation and tracing back contagions has not been studied before in this context. From the methodology point-of-view, most related to our work is [6] where they use the directed Steiner-tree algorithm of Charikar et al. [1] in order to find the minimum spanning tree of a temporal network.
As should be clear by our discussion so far, CulT is de-signed to reconstruct an epidemic, or an activity propaga-tion, as it is likely to have happened in the past . That is, it is not trying to make any predictions about the future . This is an important point that can help to put in better perspec-tive the performance of CulT , as reported by MCC scores, in several of the experiments presented in the previous sec-tion. In particular, note that the ground-truth infected set may contain several nodes that are downstream from nodes in the reports set R (here we call a node downstream if there is no temporal path from it to any node in R ). Ac-cordingly, CulT has no incentive to generate trees that will cover downstream nodes, as such trees will have additional cost and will not contribute in covering any node in R .
For the sake of simplicity we have not removed down-stream nodes from our ground-truth sets, and thus, the MCC performance of CulT is conservative. However, we would like to point out that detecting infected downstream nodes is a prediction task, not a reconstruction task. More-over, it is a task that may require assuming a propagation model, and thus, a problem that we do not address here.
We consider the problem of reconstructing an epidemic over time. The novelty of our approach relies on the fact that we explicitly take into account the exact time that nodes interact, which leads to more accurate reconstruc-tions. Additionally, our method requires only a small sample of nodes reported as infected, and it does not make any as-sumption regarding the underlying propagation model. We show how to map the reconstruction task into the classic directed Steiner-tree problem, and apply known approxima-tion algorithms. We also present a new technique that sig-nificantly improves the running time of the approximation algorithm, and makes it applicable to online settings. We demonstrate the efficacy of CulT through multiple experi-ments on diverse datasets.
 Jilles Vreeken is supported by the Cluster of Excellence  X  X ultimodal Computing and Interaction X  within the Excel-lence Initiative of the German Federal Government. Aris-tides Gionis is supported by the Academy of Finland project  X  X estor X  (286211) and the EC H2020 RIA project  X  X oBig-Data X  (654024). B. Aditya Prakash is supported by NSF Grant IIS-1353346, Maryland Procurement Office under con-tract H98230-14-C-0127, NEH Grant HG-229283-15 and a Facebook faculty gift. [1] M. Charikar, C. Chekuri, T.-y. Cheung, Z. Dai, [2] Z. Chen, H. Tong, and L. Ying. Full diffusion history [3] M. Farajtabar, M. Gomez-Rodriguez, M. Zamani, [4] S. Feizi, K. Duffy, M. Kellis, and M. Medard. Network [5] P. Holme and J. Saram  X  aki. Temporal networks. [6] S. Huang, A. W.-C. Fu, and R. Liu. Minimum [7] T. Lappas, E. Terzi, D. Gunopulos, and H. Mannila. [8] N. Masuda and P. Holme. Predicting and controlling [9] O. Michail. An introduction to temporal graphs: An [10] B. A. Prakash, D. Chakrabarti, M. Faloutsos, [11] B. A. Prakash, J. Vreeken, and C. Faloutsos. Spotting [12] E. Sadikov, M. Medina, J. Leskovec, and [13] E. Sefer and C. Kingsford. Diffusion archaeology for [14] D. Shah and T. Zaman. Rumors in a network: Who X  X  [15] S. Sundareisan, J. Vreeken, and B. A. Prakash. [16] B. Viswanath, A. Mislove, M. Cha, and K. P.
 [17] Y. Zhang and B. A. Prakash. Scalable vaccine CIKM , 2014.
