 Contextual search tries to better capture a user X  X  informa-tion need by augmenting the user X  X  query with contextual information extracted from the search context (for example, terms from the web page the user is currently reading or a file the user is currently editing).

This paper presents Y!Q X  X  first of its kind large-scale contextual search system X  X nd provides an overview of its system design and architecture. Y!Q solves two major prob-lems. First, how to capture high quality search context. Second, how to use that context in a way to improve the relevancy of search queries.

To address the first problem, Y!Q introduces an informa-tion widget that captures precise search context and pro-vides convenient access to its functionality at the point of inspiration. For example, Y!Q can be easily embedded into web pages using a web API, or it can be integrated into a web browser toolbar. This paper provides an overview of Y!Q X  X  user interaction design, highlighting its novel aspects for capturing high quality search context.

To address the second problem, Y!Q uses a semantic net-work for analyzing search context, possibly resolving am-biguous terms, and generating a contextual digest compris-ing its key concepts. This digest is passed through a query planner and rewriting framework for augmenting a user X  X  search query with relevant context terms to improve the overall search relevancy and experience. We show experi-mental results comparing contextual Y!Q search results side-by-side with regular Yahoo! web search results. This evalu-ation suggests that Y!Q results are considered significantly more relevant.

The paper also identifies interesting research problems and argues that contextual search may represent the next major step in the evolution of web search engines. H.3.3 [ Information Systems ]: Information Storage and Retrieval X  Information Search and Retrieval Experimentation Contextual Search, Web Information Retrieval, Content Anal-ysis, Semantic Networks, Search Personalization, Context
Today X  X  web search engines accept keyword-based queries and return results that are relevant to these queries. These engines have proven to be extremely useful, perhaps surpris-ingly so given the short length of a typical web query [19] and the huge size of today X  X  web corpora. However, rele-vancy is a significant challenge for search engines, especially for queries with an ambiguous topic or intent (such as the popular  X  X aguar X  example.) Contextual web search aims to improve the relevancy of web search results by considering the information context of the user X  X  current task along with the user X  X  query.

Often, search queries are formulated while the user is en-gaged in some larger task. In these cases, there is often an information context available that can help refine the meaning of the user X  X  query. For instance, a user may be browsing a web page about the jaguar car . The article stim-ulates some interest (at the  X  X oint of inspiration X ) and the user then wants to know something related to that car. A contextual search engine might take that web page as an ad-ditional input to disambiguate and otherwise augment the user X  X  explicit query.

Although contextual search has been identified to be a promising direction for improving web search in the liter-ature (e.g., [10], [11], [14]), as of early 2005 there were no major web search engines that would provide a contextual search application for their users. This changed in February of 2005, when Yahoo! launched Y!Q Contextual Search in beta 1 .

In this paper we present Y!Q X  X  first of its kind large-scale contextual search application integrated with a major web search engine (Yahoo! Search 2 .) We provide an overview of Y!Q X  X  system design and architecture, and point out in-teresting research problems related to different aspects of contextual search.

Y!Q evolves around two mechanisms. The first is a novel user interface and interaction model for obtaining high qual-http://yq.search.yahoo.com http://search.yahoo.com ity search context for a given query. Instead of guessing search context, Y!Q allows users or publishers to explicitly and conveniently define context. In the scope of this paper a context represents a passage of text X  X n article, paragraph, sentence, or even just a few words. Y!Q X  X  user interaction model is designed to provide contextual search functionality to the user at the point of inspiration so as to not inter-rupt the user X  X  current work flow. We present the design of the Y!Q information widget for capturing context and dis-playing results inline within the user X  X  currently viewed web page.

The second mechanism is a semantic network for analyz-ing search context and generating a contextual digest com-prising the key concepts, possibly resolving ambiguous terms and concepts. This digest is passed through a query plan-ner and rewriting framework to augment the user X  X  search query with relevant context terms. This augmented and en-hanced rewritten query is then sent to various search engine back-end providers for query processing. The obtained re-sults are re-ranked based on a contextual ranking function, and eventually returned within an overlay embedded in the user X  X  currently viewed web page.

We show based on experimental studies that the contex-tual search results returned from Y!Q are more relevant com-pared to regular Yahoo! web search results: Over 32% of all users preferred the contextual search results, whereas only 8% preferred regular web search results (on 59% we had a tie.) The paper then concludes and argues that contextual search may represent the next major step in the evolution of web search engine.
This section points out related work and introduces the terminology we will use throughout the remainder of this paper.
The majority of the contextual search work revolves around learning user profiles based on previous searches, search re-sults and recently web navigation patterns. The information system uses this learning to represent the user interest for the refinement of future searches. Another area of learn-ing is focused on context learning (e.g., [12], [2]) based on judged relevant documents, query terms, document vectors, etc.

Context as a query, a different approach (e.g., [13], [17], [7], [9], [5]) is to treat the context as a background for topic specific search, and extract the query representing the con-text and therefore, the task at hand. Some recent search tools (e.g., Blinkx 3 , The Dashboard 4 ), and more general contextual ads (e.g., Google AdSense 5 , Yahoo! Publisher Network 6 ) explore this idea further. The body of the work in this paper is based on an initial context provided by the user as part of the user X  X  current information need.
Finkelstein et al. describe IntelliZap [10], a contextual search system, so a careful comparison is needed. IntelliZap defines context to be the text that is around the vicinity of a query. A query is limited to text that a user selects, http://www.blinkx.com/ http://nat.org/dashboard/ https://www.google.com/adsense/ http://publisher.yahoo.com and the surrounding context is then used to augment the query. Y!Q X  X  information widget is designed to also provide this functionality, but in addition provides more flexibility by allowing users to type in whatever query they want, not limiting them to pre-defined text. In addition, Y!Q supports a web API that publishers or web masters can use to easily embed Y!Q within their web pages. IntelliZap did not pro-vide a web API and was limited to a client-side application that a user had to download or install once. Furthermore, Y!Q X  X  system design focuses on scalability to possibly serve thousands of contextual search requests per second, and its processing of contextual search queries is also quite different from the IntelliZap approach (see details in Section 3.1.)
Lawrence [14] argues that next generation search engines will increasingly make use of context information. Within the Inquirus 2 project category information was added for augmenting queries. Y!Q is designed to also take advan-tage of additional meta-data (e.g., for instance in form of categories.)
In the previous section we suggested that contextual search will lead to more relevant results for a query given a certain context. Unfortunately the word  X  X ontext X  has been over-loaded with many different meanings. We therefore want to define more precisely what we mean by a context and some related terminology, since this represents the foundation for our experimental evaluation.
 Context: A piece of text (e.g., a few words, a sentence, Context Term Vector: A dense representation of a con-Contextual Search Query: A search query that comprises
In the remainder of the paper we use the term  X  X uery X  to refer to regular keyword search queries. If we refer to  X  X ontextual search queries X , we will explicitly state that.
Y!Q represents to the best of our knowledge the first large-scale contextual search system integrated with a major web search engine. It captures search context explicitly defined by the user or publisher at the point of inspiration, while not disrupting the user X  X  work flow, and uses that context to augment search queries for improving the overall relevancy of results.

It achieves this by using a back-end system that performs content analysis based on a semantic network, and using a query planning and rewriting framework to support a variety of different information sources.

The following section provides an overview of the system design, comprising content analysis, query rewriting frame-work, and contextual ranking. Then we present Y!Q X  X  user interaction model and its distribution channels.
This section provides an overview of the overall Y!Q sys-tem design and architecture. The Y!Q back-end comprises three major system components (see Figure 1) for processing contextual search queries: 1. Content Analysis (CA) 2. Query Planning and Rewriting Framework (QPW) 3. Contextual Ranking (CR)
The CA component is responsible for creating a weighted context term vector representation of the specified context and the optional query (see Section 3.2 for details.)
The QPW  X  X  main purpose is to identify the best places to search in a federated search environment. It performs two major tasks. First, it examines the term vector obtained from CA, and based on the entity types and client request determines the best search targets for this contextual search query (e.g. web, multi-media, etc.). After the best sources of information are determined the QPW generates a rewritten query for each of the targeted search providers, using the context term vector and the optional query (see Section 3.3 for details.)
The list of best search targets, associated rewritten queries, and the identified weighted context term vector are for-warded to the Y!Q front-end, which in turn does a federated search using this information.

The obtained results are then processed and possibly re-ranked in CR based on a similarity distance measurement between a search result element and the context term vector. Furthermore, CR may perform blending of different result types (e.g., mix web with news results), or exclude certain result elements based on a similarity threshold criteria. The post-processed and re-ranked list of result elements will then be returned to the user as the result set for the contextual search query.

Currently each Y!Q back-end is capable for handling thou-sands of contexts/queries per second on each hardware node. The current hardware configuration per node is a dual CPU running Linux with four gigabytes of memory.
Y!Q performs content analysis of a given context and/or query. For this purpose it exposes a semantic network (de-rived from a large document corpus and query logs) as a service. The interfaces into the Y!Q content analysis ser-vice are general and broad enough that it can be used by other applications that are interested in extracting terms from text (see also Term Extraction Web Service in Section 3.6.3.) The service comprises four major components (see Figure 1): 1. Vectorizer 2. Entity Dictionary 3. Topic Disambiguation 4. Sensitivity Analysis
Vectorizer performs term extraction (e.g., using statistical and/or linguistic analysis methodologies [16]) given a con-text (plus optionally a query) to return its key concepts. As a result of the term extraction step Y!Q generates a context term vector representation of the input. This digest will then be used to determine subsequent actions (e.g., what infor-mation sources to use, how to articulate contextual search queries, etc.).

Extracted terms are then cross-referenced using an entity dictionary and matched entity information is associated to the extracted terms as meta-data. The Y!Q entity dictio-nary is periodically reviewed by an editorial team to keep its content fresh and of high quality.

Since terms can have multiple meanings (e.g., the term jaguar could represent a car , an animal , or an operating system ) Y!Q performs a topic disambiguation step using the provided contextual information to resolve term ambiguities (e.g., using various term disambiguation techniques [15].)
Another task of the content analysis part is to determine whether a contextual search query should be considered sen-sitive (e.g. family friendly, sensitive subject, etc.). If a con-text discusses sensitive content, the query rewriting frame-work may need to take special care when handling such a sensitive request. For example, a context is about terror-ist activities involving a shooting. In this case Y!Q may not want to show contextual ads for  X  X uying guns X  or show related images of injured people.

The context term vector and its associated meta-data in-formation (e.g., term weights, entities, sensitivity indicator) are passed to QPW for further processing.
QPW X  X  task is, given a context term vector with asso-ciated meta-data, to determine first a list of target search providers that would likely produce the most relevant re-sults for that contextual search query. It does this currently by analyzing the entity types within the context term vec-tor and applying various heuristics. For example, if a top ranked extracted concept is a type of musician , a music search would likely return the most relevant results. Per default QPW requests web search results.
 Once we have obtained a list of target search providers QPW needs to generate a correspondent rewritten query for each target. The problems here are similar to meta-search [18]: Each search provider may use a different search syntax, and apply different ranking algorithms. Y!Q X  X  QPW therefore contains logic to address these issues.
A naive query rewriting approach would simply concate-nate all query and context term vector terms to form a X  rather long X  X uery using AND semantics, sending such a sim-ple query to a standard search engine back-end . Unfortu-nately, there are three major problems that make this simple approach not useful:
In this preferred approach we have full access to the inter-nals of a search engine (e.g., index, runtime) and are able to modify its data structures, indexing, and query processing code to support contextual search optimally. We would also be able to expose that functionality through a specialized contextual search API.
 Having such a modified search engine back-end allows the QPW component to generate and send complex queries that contain ranking instructions. The actual query is made up of two parts, the actual query keywords (these have to be present in a matched document) and the formulated context. The formulated context terms are used to boost the ranking of documents that contain them (so matching documents that do not contain them end up with a lower overall score.) An example illustrates this better: +queryterm1 +queryterm2 contextterm1 contextterm2 contextterm3
In this case the + operator indicates that  X  X his term must be present X , whereas the context terms are optional. The main goal is to have the same level of recall as if the query was issued without a context. For this purpose we used the special ranking operator provided by the search engine to boost the score of the documents in the candidate set similar to the associated context.

There are still many challenges on how to use such a rank biasing operator optimally. For instance, the mapping of weights from the context terms into weights that the rank-biasing operator uses is not intuitive. Secondly, how many optional query terms should be used from the context term vector for biasing (e.g., none, only a few, all?) Overall the relationship between query and context is crucial for the relevancy when articulating a rewritten query. We con-ducted many experiments to determine settings that worked well. More research needs to be done to further improve the quality of contextual search results by tuning the complex queries needed by the rank biasing approach, but the results so far are quite encouraging.
The Y!Q front-end obtains search result elements from each search provider that has been contacted. In the final step of the query processing the Y!Q front-end sends the results along with the context term vector to the CR com-ponent for contextual re-ranking of the results. The main motivation here is that each search provider applies its own ranking function, which may not be ideal in relationship to the original context. User studies suggested that for con-textual search queries the relevancy metric therefore has to take the context into consideration.

One of the goals of CR is to prevent duplicative results that are too similar to the original context from appearing at the top of the result list. It achieves this by setting two similarity threshold parameters maxSim and minSim : Result elements are sorted by decreasing similarity score, and result elements having a similarity score greater than maxSim and lower than minSim are either punished or discarded.
In addition, blending result elements from different sources may be useful and requires additional logic. For example, a context is about a music artist . During the re-ranking pro-cess it is possible that results obtained from a music search provider should get a boost in relevancy. Blending of re-sults from different sources is about figuring out the right  X  X alanced mix X  that is considered most relevant for the con-textual search query. As a result of the re-ranking process CR returns a re-ordered list of result elements to the user.
The Y!Q interaction model can be divided into context ac-quisition, results preview, and a context refinement phase. The general idea is that the user starts out with some con-text, previews contextual results, and if needed has the abil-ity to gradually refine an initial context by selecting or de-selecting terms, or possibly starting over with a different context. Y!Q provides two mechanisms for context acquisition. First, a publisher can mark text in a web page to repre-sent context by using HTML tags as described in the Y!Q Web API (see Section 3.6.1.) Second, a user can use the Yahoo! Toolbar 7 or Yahoo! Messenger 8 to capture con-text. In both cases Y!Q relies on explicit publisher or user selection for context acquisition, instead of guessing or in-ferring context automatically from a page. Finkelstein et al. [10] confirmed the problems with an automatic approach for guessing context: Documents can be large and comprise a plethora of different topics, along with noise introduced from navigational templates etc. In this scenario, guessing the one topic in which the user is currently interested in X  without additional information X  X s difficult and error-prone. Therefore Y!Q avoids picking less relevant topics by focusing on the selected text provided by the user or publisher.
Y!Q introduces a novel information widget for context ac-quisition that comes in the form of a downloadable JavaScript library that will be executed in the user X  X  web browser. This library comprises advanced client side functionality for user interaction and for presenting contextual search results in-line within the current web page, therefore not interrupting the user X  X  work flow.
 Figure 2: Y!Q actuator icon along with associated context. Clicking the actuator icon opens the Y!Q overlay result preview (see Figure 3.)
The key visual element in the GUI design is represented by a little icon (e.g., Y! with magnifier in shape of a Q, or a lens), which we refer to as the Y!Q actuator . The icon is visually associated with the surrounding context (e.g., put adjacent to or below a paragraph or text region), or in-lined and embedded in text. In both scenarios (inline and asso-ciated with a text region) the icon is clickable by the user. Figure 2 shows an example of a context and the associated Y!Q actuator button. The motivation is to eventually have users recognize the Y!Q actuator as a synonym for getting related information and searching in context. http://toolbar.yahoo.com http://beta.messenger.yahoo.com
If the user clicks the Y!Q actuator button the Y!Q overlay opens up, showing a contextual search box (CSB) along with contextual search results and related information (e.g., im-ages, links to related Yahoo! resources, news articles, etc.). The actual content of the overlay is dynamically determined as a result, based on Y!Q X  X  semantic analysis of the contex-tual search query.
 Figure 3: Y!Q overlay showing results preview com-prising various related web results and links within the Yahoo! network.

Figure 3 shows an example of the Y!Q overlay, which is based on the text and example from Figure 2. In this case, interestingly, the query itself is empty (as mentioned before we refer to this as the  X  X uery-less mode X  of Y!Q.) Therefore the initial task of contextual search in this embodiment is to find related information given a specific context.
The displayed CSB then allows users to enter a query, which is related to the original context. Note that the se-mantics of a CSB are quite different compared to a regular web search box. For example, if a user would enter  X  X ammy X  Y!Q knows (based on the context in Figure 2) this would ac-tually refer to  X  X ammy Sosa. X  Or, when the user enters the query  X  X ickets X , Y!Q could infer that the user might be in-terested in buying tickets for the Chicago Cubs. In both examples the context has been used to disambiguate the user X  X  query.
If a user wants to dig deeper into the related results that are being shown, in addition to the CSB, the Y!Q overlay offers a  X  X how All Results X  link that opens up a contextual search results page (CSRP) in a new browser window. A CSRP looks very similar to a regular web search results page, but contains an interactive tool (see Figure 4) that allows users to refine a context (e.g., remove extracted terms that are not relevant.)
In addition, the user may use each search result element for replacing the current context if needed (e.g., to shift the focus of the search into a different direction). Y!Q therefore associates a  X  X ore like this X  link to each search result ele-ment. If clicked, the current context will be replaced with the content (e.g., URL, title, and summary) of the search re-sult element. The CSRP then refreshes and shows updated results based on the newly selected context.
One of the design goals of Y!Q is to distribute search to the point of inspiration. Y!Q achieves this by providing several distribution mechanisms that allows users to use Y!Q from wherever they want it. We highlight three major examples of distribution channels, but it can be seen that more could easily be added if needed.
Y!Q provides a web API that allows publishers to embed the Y!Q information widget into their web pages 9 . To do this, the publisher includes a Y!Q JavaScript library into the HTML page, and then places Y!Q information widgets in form of HTML forms within the page. Since the API was initially introduced in February 2005 it has gradually ex-panded in terms of functionality based on user feedback. It provides many options for customizing the behavior of Y!Q (e.g., allowing the publisher to provide a query for focusing results or restrict searches to specific sites, etc.).
For web pages that do not include Y!Q information wid-gets a browser toolbar or instant messenger integration al-lows users to select arbitrary text on a web page, and then use that selected text as context when sending queries to Y!Q. The Y!Q overlay (described in Section 3.5.2) is then used for previewing search results and issuing subsequent queries.
In addition, Y!Q exposes a web services interface for pub-lishers and developers who want to integrate Y!Q on a lower data level. For instance, a contextual web search service returns web results given a context and optionally a query. Or, a content extraction web service 11 allows retrieval of terms that were extracted from a given context. Both web services provide developers the flexibility to generate new and interesting services and applications on top of the Y!Q platform (e.g., TagCloud 12 represents a good example for such a service.)
This section presents experimental results comparing Y!Q contextual search results side-by-side to regular Yahoo! web search results to point out qualitative differences.
To measure the relevance of contextual search, we em-ploy a perception-based evaluation methodology using side-by-side human judgments [1]. We focus on the interaction described in Section 3.5.2 and Section 3.5.3, where queries issued by users are biased by the context they have just chosen or seen. Given a query, we compare two sets of re-sults: one generated by Y!Q X  X  contextual search with both the context and the query as input, and another generated by Yahoo! web search (WS) with only the query as input. In other words, as one result set has been biased by the con-text and another has not, we seek to measure the effect of this bias on perceived relevance.

In our side-by-side testing, the result sets were randomized and blinded so that half the time Yahoo! web search results were shown on the left side and half the time on the right. Judges were asked to issue a judgment about which side was more relevant to the context and query. For every result in a set, judges were presented with the title, abstract, and URL of each result and could opt to click on the URL if they preferred. Sides displayed no more than five results (the current Y!Q overlay interface shows typically no more than three results.)
We sampled 98 contexts from actual Y!Q traffic resulting from user evaluation studies during two weeks in December of 2004. We associated each context with the actual query issued by the user; if no query was issued, we asked the editorial staff to come up with five reasonable queries to go with that context and we then randomly selected one out of the five queries for testing.

A staff of 20 expert editors issued judgments on 96 of these 98 contexts. The average context had 56 words; the longest context had 182 and the shortest context had 11 words. A total of 275 judgments were collected: an average of 2.86 judgments per query and no query received more than three judgments.

For each context and query pair, judges provided a judg-ment on a 7-point scale with -3 representing that Y!Q was much better, +3 that Yahoo! WS was much better, and 0 that Y!Q was about the same as Yahoo! WS (after remov-ing the blindness.) We computed a metric called SBS-Avg , which is obtained by averaging all judgments for a query and then averaging the averages for all queries. We also computed SBS-Triplet , which consists of three components: the percentage of queries for which Y!Q is superior to Ya-hoo! WS ( judgment&lt; 0), Y!Q is about the same as Yahoo! WS ( judgment = 0), and Y!Q is inferior to Yahoo! WS ( judgment&gt; 0) respectively.
Table 1 shows the SBS-Avg metric, which is about -0.13, meaning that Y!Q contextual search results are more rele-vant to Yahoo! WS. We performed three statistical tests  X  two non-parametrics (Wilcoxon and Sign) and one paramet-ric (Student t-test)  X  all of which came out significant at the 95% confidence level.

Figure 5 shows the per-query judgment histogram (judg-ments are averaged for each query and rounded to the next integer.)
SBS-Triplet shows that Y!Q is superior to Yahoo! WS 32.3% of the context and query pairs, while Yahoo! WS is better only 8.3% of them (with 59.4% tied.) of contextual search results.
 confidence level.
A key observation is that Y!Q does a much better job disambiguating ambiguous queries. This is not surprising and strengthens our belief that in the presence of contexts a user can afford to  X  X ype less X  and still get relevant results for what he or she is looking for. When we split our results between one/two word queries and three-plus word queries, Yahoo! WS actually performed reasonably well on the lat-ter. It is not clear if just adding more words to the search box would give us the same effect. It depends on how web search engines handle very long queries. Also, users may not be willing to spend the time entering such queries to begin with (the average number of terms per query on the Web is between two and three terms [19].)
One example of disambiguation was a context about  X  X pache helicopters X  and the query was  X  X pache cost. X  Ya-hoo! WS returned irrelevant results which had nothing re-lated to helicopters. Again, apache is an ambiguous query (other meanings include Apache Indians and Apache web server .)
Another example was a context about a  X  X erfectly pre-pared meatloaf dish X  and the query was  X  X ecipes X  . Not sur-prisingly, Yahoo! WS returned generic recipe sites that had no direct relation to meatloaf.
We presented Y!Q X  X  first-of-its-kind large-scale contex-tual search system X  X ntegrated with Yahoo! X  X  web search en-gine. We showed its overall system design and architecture. Y!Q X  X  key system components are content analysis, a query planning and rewriting framework, and contextual ranking. In addition, we introduced a novel user interaction model for contextual search that allows users or publishers to spec-ify context that can be used for automatically augmenting search queries. The user interaction model depends on a client-side JavaScript library that provides rich user inter-action features (e.g., display of search results in-line). This allows users to focus on their task at hand and perform searches at the  X  X oint of inspiration X , minimizing interrup-tion of thought and eliminating the requirement to go to a different search page.

When comparing regular web search results to contex-tual Y!Q results, the experimental results showed that users actually prefer contextual Y!Q results. Particularly for am-biguous queries the context helped to provide more rele-vant and targeted results. We therefore argue X  X ased on the results outlined in this paper X  X hat the greatest bene-fit of using context is that it helps to disambiguate queries. Another benefit is that Y!Q is presenting a highly related mix of results from possibly many different sources (e.g., news, images, links within the Yahoo! network), which is worthwhile, and should be explored in future work.
Although there are different ways that web search engines may improve and evolve within the near future (e.g., natural language analysis that better understands a user X  X  intent) X  based on the results of the research presented here X  X e have reason to believe that contextual search may represent the next major evolutionary step in web search. This confirms a trend already predicted by Lawrence [14] who argues that next generation search engines will increasingly make use of context information. Our paper points out open research problems, and we hope it stimulates more research in the area related to contextual search.
We are grateful to Raymie Stata for his helpful comments and advice. Furthermore, we are thankful to Michele Repine and our editorial team, and Josh Coalson for helping with the Y!Q relevancy evaluations. [1] K. Ali, C. Chang, and Y. F. Juan. Exploring [2] N. J. Belkin, R. Oddy, and H. M. Brooks. ASK for [3] K. Bharat. Searchpad: explicit capture of search Y! WS is better only 8.3% of them (with 59.4% tied.) [4] D. M. Bikel, R. L. Schwartz, and R. M. Weischedel. [5] D. Billsus, D. Hilbert, and D. Maynes-Aminzade. [6] A. Borthwick, J. Sterling, E. Agichtein, and [7] J. Budzik and K. Hammond. Watson: Anticipating [8] T. Calishain and R. Dornfest. Google Hacks: 100 [9] M. Czerwinski, S. Dumais, G. Robertson, S. Dziadosz, [10] L. Finkelstein, E. Gabrilovich, Y. Matias, E. Rivlin, [11] E. J. Glover, S. Lawrence, W. P. Birmingham, and [12] A. Goker. Capturing information need by learning [13] M. Henzinger, B.-W. Chang, B. Milch, and S. Brin. [14] S. Lawrence. Context in web search. IEEE Data [15] D. Maynard and S. Ananiadou. Term sense [16] D. Maynard and S. Ananiadou. Identifying contextual [17] B. Rhodes and T. Starner. The remembrance agent: A [18] E. Selberg and O. Etzioni. The MetaCrawler [19] C. Silverstein, H. Marais, M. Henzinger, and [20] C. T. Yu, K. Lam, and G. Salton. Term weighting in
