 In this paper, we propose a SAT-based encoding for the problem of discovering frequent, closed and maximal pat-terns in a sequence of items and a sequence of itemsets. Our encoding can be seen as an improvement of the approach proposed in [8] for the sequences of items. In this case, we show experimentally on real world data that our encoding is significantly better. Then we introduce a new extension of the problem to enumerate patterns in a sequence of item-sets. Thanks to the flexibility and to the declarative aspects of our SAT-based approach, an encoding for the sequences of itemsets is obtained by a very slight modification of that for the sequences of items.
 F.4.1 [ Mathematical logic and formal languages ]: Math-ematical Logic X  Logic and constraint programming ; H.2.8 [ Database management ]: Database applications X  Data mining Data mining; Propositional satisfiability and modeling
Frequent sequence data mining is the problem of discov-ering frequent patterns shared across time among an input data-sequence. Sequence mining is a central task in compu-tational biology, temporal sequence analysis and text min-ing.
 In this paper, we consider the pattern discovery problem for a specific class of patterns with wildcards in a sequence. The data-sequence can be seen as a sequence of items, while the pattern can be seen as a subsequence that might con-tains wildcards or jokers in the sense that they match any item [18, 20, 2]. At the first sight, allowing wildcards to oc-cur in a pattern can be seen as an even more restrictive type of patterns in general. However as argued in [18]  X  studying patterns with wildcards has the merit of capturing one impor-tant aspect of biological features that often concerns isolated positions inside a motif that are not part of the biological feature being captured  X . The enumeration problem for max-imal and closed motifs with wildcards has been investigated recently by several authors [19, 20, 2, 8]. One of the major problem is that the number of motifs can be of exponential size. This combinatorial explosion is tackled using different approaches. For example, in Parida et al. [18], the number of patterns is reduced by introducing the maximal non re-dundant q-patterns (patterns occurring at least q times in a sequence). Arimura and Uno [2] proposed a polynomial space and polynomial delay algorithm MaxMotif for maxi-mal pattern discovery of the class of motifs with wildcards. In this work, we follow the constraint programming (CP) based data mining framework proposed recently by Luc De Raedt et al. in [10] for itemset mining. This new framework offers a declarative and flexible representation model. New constraints often require new implementations in specialized approaches, while they can be easily integrated in such a CP framework. It allows data mining problems to benefit from several generic and efficient CP solving techniques. The au-thors show how some typical constraints (e.g. frequency, maximality, monotonicity) used in itemset mining can be formulated for use in CP [14]. This first study leads to the first CP approach for itemset mining displaying nice declar-ative opportunities without neglecting efficiency. More re-cently, Coquery et al. [8] have proposed a SAT-Based ap-proach for Discovering for enumerating frequent, closed and maximal patterns with wildcards in a sequence of items. In this paper, we first propose a new SAT encoding of the prob-lem of enumerating frequent, closed and maximal patterns with wildcards in a sequence of items. Our contribution can be seen as an improvement of the approach proposed in [8]. Indeed, the experimental results clearly show that the new encoding is significantly better than the original SAT encod-ing proposed in [8].
 Encouraged by these promising results, we propose in our second contribution a new variant of the problem of discov-ering patterns with wildcards in a sequence, by considering a sequence of itemsets instead of a sequence of items. In this extension the emptyset will simply play the same role as the wildcard symbol. Indeed, one can use the emptyset to match any itemset. This new problem admits some simi-larities and differences with the classical sequential pattern mining problem introduced in [1]. Indeed, given an alpha-bet or a set of items  X , in both problems we consider a sequence s as an ordered list of itemsets s 0 ,...,s s  X   X  for i = 0 ,...,n . However, the first difference resides in the definition of a subsequence. Indeed, in the sequen-tial patterns, we say that s 0 is a subsequence of s if there exists a one-to-one order-preserving function f that maps (inclusion relation) itemsets in s 0 with itemsets in s . In our new setting, the notion of subsequence is defined w.r.t. to a given location and by using empty itemsets as wildcards. The other difference is that in the sequential pattern min-ing we consider a database of sequences of itemsets, while in our setting, we consider only a single sequence of item-sets. These differences leads also to different definitions of the notions of support, closeness and maximality. In sum-mary, our new problem of discovering patterns in a sequence of itemsets can be seen as a simple and natural extension of the same problem in a sequence of items. As we can show later, the SAT encoding can be derived from the one used for the sequences of items with a very slight modification demonstrating its flexibility.
 The paper is organized as follows. In the next section, we give a short overview of necessary definitions and notations about Boolean Satisfiability (SAT) and Frequent Pattern mining in a Sequence of items (FPS). The extension to the Frequent Pattern mining in a Sequence of Itemsets (FPSI) is presented in Section 3, followed by a discussion of some related works. Then our new SAT-based approach for FPS is described in Section 4, while the closeness and maximal-ity constraints are discussed in Section 5. In Section 6, we show how the SAT encoding of FPSI, can be obtained by a slight modification of the SAT encoding of FPS. Finally, experimental results are conducted and discussed before con-cluding.
In this section, we introduce the Boolean satisfiability problem, called SAT. It corresponds to the problem of decid-ing if a formula of propositional classical logic is consistent or not. It is one of the most studied NP-complete decision problem. In this work, we consider the associated problem of Boolean model enumeration.

We consider the conjunctive normal form (CNF) repre-sentation for the propositional formulas. A CNF formula  X  is a conjunction of clauses, where a clause is a disjunc-propositional variable. The two literals p and  X  p are called complementary .

A CNF formula can also be seen as a set of clauses, and a clause as a set of literals. Let us recall that any propositional formula can be translated to CNF using linear Tseitin X  X  en-coding [22]. We denote by V ar ( X ) the set of propositional variables occurring in  X .
 An interpretation B of a propositional formula  X  is a func-tion which associates a value B ( p )  X  X  0 , 1 } (0 corresponds to false and 1 to true ) to the variables p  X  V ar ( X ). A model of a formula  X  is an interpretation B that satisfies the for-mula. SAT problem consists in deciding if a given formula admits a model or not.
 We denote by  X  l the complementary literal of l , i.e., if l = p then  X  l =  X  p and if l =  X  p then  X  l = p . For a set of literals L ,  X  L is defined as {  X  l | l  X  L } . Moreover, B ( B is an interpreta-tion over V ar ( X )) corresponds to the clause W p  X  V ar ( X ) where if B ( p ) = 0 then f ( p ) = p , otherwise f ( p ) =  X  p .
Let us informally describe the most important compo-nents of modern SAT solvers. They are based on a rein-carnation of the historical Davis, Putnam, Logemann and Loveland procedure, commonly called DPLL [9]. It performs a backtrack search; selecting at each level of the search tree, a decision variable which is set to a Boolean value. This assignment is followed by an inference step that deduces and propagates some forced unit literal assignments. This is recorded in the implication graph, a central data-structure, which encodes the decision literals together with there im-plications. This branching process is repeated until finding a model or a conflict. In the first case, the formula is an-swered satisfiable, and the model is reported, whereas in the second case, a conflict clause (called learnt clause) is gen-erated by resolution following a bottom-up traversal of the implication graph [17, 24]. The learning or conflict analy-sis process stops when a conflict clause containing only one literal from the current decision level is generated. Such a conflict clause asserts that the unique literal with the cur-rent level (called asserting literal) is implied at a previous level, called assertion level, identified as the maximum level of the other literals of the clause. The solver backtracks to the assertion level and assigns that asserting literal to true . When an empty conflict clause is generated, the literal is implied at level 0, and the original formula can be reported unsatisfiable.

In addition to this basic scheme, modern SAT solvers use other components such as activity based heuristics and restart policies. An extensive overview about propositional Satisfiability can be found in [6, 15].
In this section, we present the frequent pattern mining problem of enumerating frequent, closed and maximal pat-terns with wildcards in a sequence of items [18, 20, 2]. Let us first give some preliminary definitions and notations.
Let  X  be a finite set of items, called alphabet. A sequence of items s over  X  is a simple sequence of symbols s 0  X  X  X  s belonging to  X . We denote by | s | its length and by P s the set { 0 ,... | s | X  1 } of all the locations of its symbols. A wildcard is a new symbol  X  which is not in  X . This symbol matches any symbol of the alphabet.

A pattern over  X  is a sequence p = p 0 ...p m  X  1 , where p 0  X   X , p m  X  1  X   X  and p i  X   X   X  X  X } for i = 1 ,...,m  X  2. We say that p is included in s = s 0 ...s n  X  1 at the location l  X  P s , denoted p l s , if  X  i  X  { 0 ...m  X  1 } , p i = s p =  X  . We also say that p is included in s , denoted p s , if  X  l  X  X  s such that p l s . The cover of p in s is defined as the set L s ( p ) = { l  X  P s | p l s } . Moreover, The support of p in s is defined as the value |L s ( p ) | .
Let s be a sequence, p a pattern and  X   X  1 a minimal support threshold, called also a quorum. We say that p is a frequent pattern in s w.r.t.  X  if |L s ( p ) |  X   X  . The fre-quent pattern mining problem in a sequence of items (FPS) consists in computing the set M  X  s of all the frequent pat-terns w.r.t.  X  . For instance, let us consider the sequence s = aaccbcabcba and then pattern p = a  X  c . We have L ( p ) = { 0 , 1 , 6 } , since p 0 s , p 1 s and p 6 s . In this case, if we consider that the minimal support thresh-old is equal to the value 3, then the pattern p is a frequent pattern of s .

A frequent pattern p of a sequence s is said to be closed if for any frequent pattern q satisfying q p , there is no integer L ( p ) } . Moreover, it is said to be maximal if for any frequent pattern q , q 6 p . Clearly, the set of closed frequent patterns (resp. maximal frequent patterns) is a condensed represen-tation of the set of frequent patterns. Indeed, the frequent patterns can be obtained from the closed (resp. maximal) ones by replacing items with wildcards.
 Note that if p 1 and p 2 are two patterns such that p 1 p called anti-monotonicity.
In this section, we define a new variant of the problem of discovering patterns with wildcards in a sequence, by consid-ering a sequence of itemsets instead of a sequence of items. The role of wildcard symbol is nicely played by the empty itemset as it match any itemset. As mentioned in the in-troduction, this new problem admits some similarities and differences with the classical sequential pattern mining prob-lem introduced in [1]. The main difference resides in the definition of the notion of subsequence (inclusion), where empty itemsets are used as wildcards, and in the use or not of a single or several sequences A sequence of itemsets s over an alphabet  X  is defined as a sequence s 0 ,...,s n  X  1 , where s i  X   X  for i = 0 ,...,n  X  1. Similarly to the sequences of items, we denote by | s | its length ( | s | = n ) and by P s the set { 0 ,... | s | X  1 } of the lo-cations.
 A pattern p = p 0 ,...,p m  X  1 over  X  is also defined as a se-quence of itemsets where the first and the last elements are different from the empty itemset. In this context, let us men-tion that we do not need the wildcard symbol. Indeed, one can use the empty itemset to match any itemset. Further-more, we say that p is included in s = s 0 ...s n  X  1 , denoted p l s , at the location l  X  X  s if  X  i  X  X  0 ...m  X  1 } , p The relation and the set L s ( p ) are defined in the same way as in the case of the sequences of items. The cover (resp. support ) of p in s is defined as the set L s ( p ) (resp. as the value |L s ( p ) | ).
 The frequent, closed and maximal patterns are also defined in the same way. For instance, a frequent pattern p of a sequence s is said to be closed if for any frequent pat-tern q satisfying q p , there is no integer d such that L ( q ) = L s ( p ) + d , where L s ( p ) + d = { l + d | l  X  L The frequent patterns can be obtained from the closed (resp. maximal) ones by replacing itemsets with their subsets. For example, let us consider the sequence of itemsets s = the pattern p = { a,b } , {} , { c } . If we set the minimal sup-port threshold to 3, then p is a frequent pattern in s , since L ( p ) = { 0 , 1 , 7 } . The pattern p is also a closed frequent pattern, but p 0 = { a } , {} , { c } is not closed, since p  X  p The pattern mining task that we consider in the sequences of itemsets allows to exhibit a high degree of self similarity for better understandings of large volumes of data. For in-stance, a sequence of itemsets can be seen as a record of the articles bought by a customer over a period of time. In such a case, a frequent pattern could be  X  X he customer bought acetylsalicylic acid two days after buying beer and wine in 20% of the days from 2008 to 2012 X .
SAT-based encodings for enumerating frequent, closed and maximal patterns in the sequences of items have been pro-posed in [8]. They follows the constraint programing (CP) based approach proposed recently by Luc De Raedt et al. in [10] for itemset mining. The SAT and CP based ap-proaches in data mining are proposed in order to offer declar-ative and flexible frameworks. Indeed, new constraints re-quire often new implementations in specialized approaches, while they can be easily integrated in such frameworks.
In this paper, we propose a SAT-based encodings for enu-merating frequent, closed and maximal patterns in the se-quences of items and the sequences of itemsets. The choice of SAT comes from our desire to exploit the efficiency of modern SAT solvers [6]. In this context, our encodings can be seen as an improvement and an extension of the encod-ings proposed in [8]. Indeed, we show experimentally on real world data that our encodings are better than those in [8]. Furthermore, we show that encodings in the case of the sequences of itemsets are obtained by a very slight modification of that for the sequences of items.
We describe here our new Boolean encoding for the prob-lem of enumerating the frequent patterns in a sequence of items FPS. The base idea consists in using a propositional variable to represent the location of an element of the al-phabet in the candidate pattern. Moreover, we use the well-known cardinality constraint to reason about the support of the candidate pattern.
 Let  X  = { a 1 ,...,a m } be an alphabet, s a sequence over  X  of length n and  X  a minimal support threshold. We associate to each character a appearing in s a set of k a propositional vari-1 ,n  X   X  + 1). The variable p a,i means that a is in the candi-date pattern at the location i . In fact, that explains why we associate only min ( max ( L s ( a )) + 1 ,n  X   X  + 1) variables to each character a , because { 0 ,...,min ( max ( L s ( a )) ,n  X   X  ) } corresponds to the set of all possible locations of a in the candidate patterns. We first need to encode that the first symbol must be a solid character (different from the wildcard symbol). This property is expressed by the following simple clause:
The following constraint composed of binary clauses al-lows us to capture the locations where the candidate pattern does not appear: where b 0 ,...,b n  X  1 are n new propositional variables. In the previous formula b j = 1 if the candidate pattern does not appear in s at the location j . Let us recall that, in clas-sical propositional logic, we have A  X  B :=  X  A  X  B , and that explains why the previous formula can be seen as a set of binary clauses (the expressions of the for s l + i constants, i.e. s l + i 6 = a  X  X  0 , 1 } ).
 In the problem of enumerating all the frequent patterns in s w.r.t.  X  , we need to express that the candidate pattern occurs at least  X  times. This property is obtained by the following cardinality constraint :
Indeed, if this constraint is not satisfied, then we know that there exist at least n  X   X  + 1 locations where the can-didate pattern does not appear. This is equivalent to say that there exist at most  X   X  1 locations where the candidate pattern appears, i.e. it is not frequent. Otherwise, there exist at least  X  locations of the candidate pattern , i.e. it is frequent. Hence this constraint allows us to reason about the support of the considered candidate pattern an to de-cide whether it is greater or equal to the minimal support threshold or not.
 The previous constraint involves the well known cardinality constraint (0/1 linear inequality). Several polynomial en-coding of this kind of constraints into a CNF formula have been proposed in the literature. The first linear encoding of general linear inequalities to CNF have been proposed by J. P. Warners [23]. Recently, efficient encodings of the cardinality constraint to CNF have been proposed, most of them try to improve the efficiency of constraint propagation (e.g. [4, 21, 3, 16]).

Proposition 1. The problem of enumerating all frequent patterns in a given sequence s is expressed by the constraints (1), (2) and (3).

Proof. We first prove that if p = a 0 ,...,a k  X  1 is a fre-quent pattern, then there exists an extension of its corre-sponding Boolean interpretation B p which is a model of (1), (2) and (3). Note that B p is defined as follows: for all a  X   X  and for all i  X  { 0 ,...,k a } , if a i = a then B p ( p One can easily see that the constraint (1) is satisfied by B since B p ( p a 0 , 0 ) = 1. Let us now extend the Boolean Inter-pretation B p to the variables b 0 ,...,b n  X  1 . This extension is obtained as follows: for all 0  X  i  X  n  X  1, if p 6 i B ( b i ) = 1. Clearly this extension corresponds to a Boolean interpretation that satisfies (2). Finally, it also satisfies (3), since p is a frequent pattern, i.e. its support is greater or equal to the minimal support threshold  X  .
 Conversely, we have to prove that if a Boolean interpretation B is a model of (1), (2) and (3), then there exists a unique pattern p B corresponding to B which is frequent. Note that, using the constraints (2) and (3), we have, for all a,a  X  and for all i  X  { 0 ,...,k a  X  1 } , if B ( p a,i ) = B ( p 1, then a = a 0 . Indeed, if there exists a 6 = a 0 in contradiction with P n  X  1 l =0 b l  X  n  X   X  (  X  6 = 0). Furthermore, using the constraint (1), we know that the first symbol of p is different from  X  . Therefore, we deduce that there exists a unique pattern associated to B . This pattern corresponds to p B = a 0  X  X  X  a k  X  1 such that, for all i  X  X  0 ,...,k  X  1 } with a a 6 = a i . Moreover, using the constraint (2), we know that if B ( b i ) = 1, then p 6 i s . Hence, using the cardinality constraint (3), we deduce that the support of p is greater or equal to the support threshold  X  .

Example . Consider the frequent pattern mining problem in the case of the sequence aabb with 2 as minimal support threshold. Our encoding corresponds to the following for-mulae:
Note that, for all Boolean interpretation B , if B ( p a,i B ( p b,i ), then b 0 + b 1 + b 2 + b 3 = 4. Hence we cannot have dif-ferent solid characters at the same position. Moreover, using the last constraint, for all Boolean interpretation B which is a model of the encoding, we must have B ( p a, 1 ) = B ( p and B ( p a, 0 ) 6 = B ( p b, 1 ). If we describe each Boolean model of the formula by a subset of { p a, 0 ,p a, 1 ,p a, 2 ,p then we obtain as models { p a, 0 } , { p b, 0 } and { p These Boolean models correspond to the patterns a , b and a  X  b .

Note that in order to consider the frequent patterns with at least min solid characters, we just have to add the fol-lowing constraint:
Conversely, in order to only consider the frequent patterns with at most max solid characters, we add:
Moreover, the combination of the two previous constraints allows us to only consider with the number of solid char-acters between min and max . Let us mention that such extensions show that our approach is flexible.
In order to provide constraints allowing to enumerate the closed frequent patterns, we associate to each symbol a a set of k a + ( n  X  min ( L s ( a ))  X  1) propositional variables: where k 0 a = n  X  min ( L s ( a ))  X  1. Similarly to our previous encoding, the propositional variables p a, 0 ,...,p a,k a us to reason about the possible locations of a in the candi-date pattern. The variables with negative indices are used to force the candidate pattern to be closed. Our encoding of the problem of enumerating the closed frequent patterns in a sequence of items CPS is obtained by extending the previous one with new constraints.
 We first have to capture all the locations where the can-didates pattern appears. This is obtained by the following constraint: Indeed, the previous constraint combined to the constraint (2) allows us to obtain that, if the Boolean interpretation B is a model of the constraints (1), (2) and (6), then the candidate pattern that corresponds to B appears only in the locations { 0  X  l  X  n  X  1 |B ( b l ) = 0 } .
 Now, we introduce a necessary, but not sufficient, constraint, w.r.t. the previous constraints, for obtaining a closed fre-quent pattern:
Intuitively, the previous constraint maximizes the number of the symbols different from wildcard on the right side of the symbol represented by the propositional variable having 0 as index.
 We now define a constraint with the propositional variables having the negative indices. Conversely to the previous con-straint, the following constraint allows us to to maximize the number of the symbols different from wildcard on the left side:
Let us note that if the Boolean interpretation B is a model of (1)  X  (2)  X  (3)  X  (6)  X  (7)  X  (8) and B ( p a,i ) = 1, then, for all b  X   X  such that a 6 = b and p b,i exists, B ( p b,i ) = 0 holds. This property is mainly obtained from the constraints (2) and (8) (see arguments used in the proof of Proposition 1). A closed motif is obtained from a model by using the propositional variables associated to the elements of  X  and evaluated to 1 by this model. Let p a 0 ,i 0 ,p a 1 ,i 1 ,...,p a variables. In this case, the closed motif is:
We now provide another encoding without using propo-sitional variables with negative indices. The idea consists in excluding each interpretation whenever its corresponding pattern is not closed. This encoding is obtained by replacing the constraint (8) with the following constraint:
By the previous constraint, we simply force the candidate pattern to be closed.

Proposition 2. The problem of enumerating all the closed frequent patterns in a given sequence s is expressed by the constraints (1), (2), (3), (6), (7) and (9).

Proof. Let p = a 0 ,...,a k  X  1 be a closed frequent pat-tern. We define its corresponding Boolean interpretation B as follows: for all a  X   X  and for all i  X  X  0 ,...,k a } , if a then B p ( p a,i ) = 1. We extend B p to the propositional vari-ables { b 0 ,...,b n  X  1 } as follows: p 6 i s iff B p ( b i = 0 ,...,n  X  1. By using similar arguments as in our proof of Proposition 1, we know that B p satisfies the constraints (1), (2) and (3). It also satisfies (6), since if B then p 6 i s . In this context, the support of p is equal to |{ b i |B p ( b i ) = 0 }| . This allows us to deduce that B p (7) and (9), since p is closed. Indeed, if (7) or (9) are not sat-isfied by B p , then there exists a pattern p 0 such that p  X  p with a support greater or equal to that of p and we get a con-tradiction because that means that p is not a closed pattern. Conversely, consider B a model of (1), (2), (3), (6), (7) and (9). Using the constraints (2) and (3), we have, for all a,a  X  and for all i  X  { 0 ,...,k a  X  1 } , if B ( p a,i ) = B ( p then a = a 0 . Hence, there exists a unique pattern associated to B that corresponds to p B = a 0  X  X  X  a k  X  1 such that, for all i  X  X  0 ,...,k  X  1 } with a i 6 =  X  , B ( p a i ,i ) = 1, and B ( p for all a  X   X  with a 6 = a i . Using Prposition 1, we know that the pattern p B is frequent. The constraint (6) allows us to obtain that the support of p is equal to |{ b i | B ( b i Using the constraints (7) and (9), we now that there is no frequent pattern q having the same support as p such that p  X  q . Therefore, we deduce that p is a closed frequent pattern.

Note that in order to enumerate all frequent patterns with-out any condition on their supports, we only have to remove the constraint 3.
In our encoding of the problem of enumerating the maxi-mal frequent patterns in a sequence of items MPS, we only use the propositional variables associated to the elements of  X  with positive indices, i.e. we associate to each symbol a a set of k a propositional variables p a, 0 ,...,p a, ( k encoding of MPS is obtained by extending the one of FPS in a similar way as our encoding of CPS.
 In order to enumerate the maximal frequent patterns, we need to capture all the locations where the candidates pat-tern appears. To this end, similarly to our encodings of CPS, we use the constraint (6). Indeed, the combination of the constraints (2) and (6) allows us to obtain, if B is a Boolean model of these two constraints, then { 0  X  l  X  n  X  1 |B ( b 0 } corresponds to the set of the locations where the candi-date pattern appears.

We now provide the constraint allowing to maximize the number of symbols different from wildcard on the right side of the symbol represented by the propositional variable hav-ing 0 as index:
Intuitively, the constraint means that if p = a 0  X  X  X  a k  X  1 the patter candidate and there exists a  X   X  such that then pattern a 0  X  X  X  a k  X  1  X  X  X  X  X  X  a have the same support as p , then p is not a maximal frequent pattern.

Coversely to the previous constraint, we finally introduce the constraint allowing to maximize the number of symbols different from wildcard on the left side of the symbol repre-sented by the propositional variable having 0 as index:
One can easily see that it is equivalent to the following constraint:
Indeed, the constraint  X  ( P n  X  1 l =0 x  X   X  ) is equivalent to cardinality constraint P n  X  1 l =0 x  X   X   X  1.

Proposition 3. The problem of enumerating all the max-imal frequent patterns in a given sequence s is expressed by the constraints (1), (2), (3), (6), (10) and (12).
 Proof. Similar to our proof of Proposition 2.

Let us mention that we can also use the constraints (4) and (5) to reason about the number of the solid characters in the considered patterns in the cases of CPS and MPS. Furthermore, we can use a constraint in order to only con-sider the closed and maximal patterns with support between  X  and  X  0 . This constraint is the following:
In this section, we extend our SAT-based approach for discovering frequent, closed and maximal patterns in a se-quence of itemsets. We will show that our encodings in this case can be obtained from the previous ones with a very slight modification.

Our encoding of the problem of enumerating the frequent patterns in a sequence of itemsets FPSI can be easily ob-tained from the one of FPS. We only have to replace the equalities of the form s l + i 6 = a with a /  X  s l + i :
In this case, the variable p a,i means that the symbol a is in the candidate pattern in the itemset at the location i . Let us recall that we use the empty itemset as wildcard. We denote by CPSI (resp. MPSI) the problem of enumer-ating the closed (resp. maximal) frequent patterns in a se-quence of itemsets. Similarly to FPSI, Boolean encodings of CPSI and MPSI can be directly obtained from the ones of re-spectively CPS and MPS by replacing the expressions of the form s l + i 6 = a (resp. s l + i = a ) with a /  X  s l + i Constraints of closeness:
Constraints of maximality: to express the maximality, we add the following two constraints to (17):
The slight modification of our encodings in the case of the sequences of items in order to obtain encodings for the sequences of itemsets clearly shows the high flexibility of our proposed framework.
In our study, we carried out a preliminary experimental evaluation of our proposed approaches using two different datasets. 1. Bioinformatics : proteinic data encoded as a sequence http://www.biomedcentral.com/1471-2105/11/175/additional/ 2. Synthetic datasets: we use the well-known IBM item-To make fair our comparison with the approach proposed in [8], we adopted the similar choices in our implementa-tions. First, as we deal with the problem of enumerating all the models of a given CNF formula encoding our se-quence mining problem, we implemented a model enumera-tion solver based on the CDCL-based solver MiniSAT 2.2 3 . To enumerate all the models, each time a model is found, we add only the negation of the sub-model restricted to the literals encoding the pattern to the formula and we restart the search. Secondly, as our SAT encodings include cardi-nality constraints, we also use the BDD encoding [5] using BoolVar/PB open source java library 4 .
 In the first experiment, we compare our new SAT encod-ing (noted CPS1) against the SAT encoding proposed in [8] (noted CPS2), on bioinformatics datasets (sequences of items). This first evaluation concerns the enumeration of fre-quent closed patterns with wild cards in a sequence of items. We consider a sequence of fixed length and we measure the evolution of computation time with respect to the minimal support threshold (quorum)  X  . The quorum evolves linearly (  X  0 = 5 and  X  i =  X  i  X  1 + 5). Several datasets have been con-sidered, their evaluation shows similar behavior. The results obtained on a representative dataset are depicted in Figure 1. This experiment confirms that in the case of sequences of items, our new SAT-based sequence mining approach out-performs (in terms of CPU time) the approach proposed re-cently in [8]. We also obtain significant improvement w.r.t. the size of the encoding. For instance, if we consider the most difficult dataset of the Figure 1 (quorum  X  = 5), the obtained CNF formula using our encoding contains about 19 millions of clauses and 3 millions of variables, whereas with the encoding proposed in [8] the formula contains about 30 millions of clauses and 7 . 5 millions of variables. The second experiment concerns the new extension of the problem to the case of sequence of itemsets. Our goal is show the feasibility of our proposed extension and its as-sociated encodings. For our evaluation, we considered syn-thetic datasets, generated using the approach outlined in [1] and also used by several authors (e.g. [12]). In our context, we only consider a single sequence of itemsets with differ-ent features (size of the sequence, number of items, average size of the itemsets). In Figure 2, we illustrate the results obtained on two datasets: dataset1 (size of the sequence = 100, avg. size of itemsets = 15, number of items = 40) and dataset2 obtained from dataset1 by cutting the sequence at 50th position. The quorum is also varied linearly as in the first experiment. The main observation that can be made, is that the hardness of the enumeration problem increase as the quorum decrease. Indeed, for smaller values of  X  , the number of frequent closed patterns is huge, leading to even harder problems. However for higher values of  X  , the enu-http://sourceforge.net/projects/ibmquestdatagen/
MiniSAT: http://minisat.se/
BoolVAR/PB : http://boolvar.sourceforge.net/ meration problem becomes easy as the number of interesting patterns decreases. Figure 1: Bioinfo: time Vs quorum (Sequence of Items -Frequent Closed Patterns) Figure 2: Synthetic datasets: time Vs quorum (Se-quence of Itemsets -Frequent Closed Patterns)
As a summary, in the above experiments, we have shown that our encoding significantly improve the one proposed in [8, 7]. For comparison purposes, we used the same encoding of the cardinality constraint and also the same algorithm for enumerating all models of a CNF formula. We think that several room for future improvements can be obtained by using the state-of-the-art encoding of the cardinality [3], and by using more efficient model enumeration algorithm [13, 11, 25]. Obviously, our SAT based approach is less efficient than dedicated approaches such as the state-of-the-art algorithm proposed by Arimura et al. in [2]. However, our SAT model is declarative and highly flexible. Indeed, the SAT encoding for a sequence of itemsets is obtained with a very slight modification of the SAT encoding of a sequence of items. Also, one can easily combine several kind of constraints. Finally, SAT-based data mining benefits from the continuous progress of SAT community.
We thank the reviewers for their helpful comments. This work has been supported in part by the CNRS and the French ANR project  X  X AG: Declarative Approaches for Enu-merating Interesting Patterns X  under the D  X efis program 2009.
The contributions of this paper are twofolds. First, we proposed an interesting improvement of the SAT-based en-codings introduced in [8] for enumerating frequent, closed and maximal patterns with wildcards in a sequence of items. Secondly, we introduced a new and natural extension of the problem to deal with the sequences of itemsets. Interest-ingly, its encoding to SAT is obtained with a slight modifi-cation of the SAT encoding of the problem dealing with the sequences of items. This clearly shows the high flexibility of our proposed framework and opens several issues for future research. We first plan to investigate other variants of the problem such as sequences of sequences of items or itemsets. It would be interesting to extend our encoding with con-straints on the form of the enumerated patterns (restriction on the number of consecutive wildcards, regular expressions, etc). Finally, on the Boolean satisfiability side, the design of efficient model generation procedures is an important is-sue for SAT-based data mining framework in general and to other important application domains. [1] R. Agrawal and R. Srikant. Mining sequential [2] H. Arimura and T. Uno. An efficient polynomial space [3] R. Asin, R. Nieuwenhuis, A. Oliveras, and [4] O. Bailleux and Y. Boufkhad. Efficient CNF Encoding [5] O. Bailleux, Y. Boufkhad, and O. Roussel. A [6] A. Biere, M. J. H. Heule, H. van Maaren, and [7] E. Coquery, S. Jabbour, and L. Sais. A constraint [8] E. Coquery, S. Jabbour, L. Sa  X   X s, and Y. Salhi. A [9] M. Davis, G. Logemann, and D. W. Loveland. A [10] L. De Raedt, T. Guns, and S. Nijssen. Constraint [11] M. Gebser, B. Kaufmann, A. Neumann, and [12] K. Gouda, M. Hassaan, and M. J. Zaki. Prism: A [13] O. Grumberg, A. Schuster, and A. Yadgar. Memory [14] T. Guns, S. Nijssen, and L. D. Raedt. Itemset mining: [15] Y. Hamadi, S. Jabbour, and L. Sais. Learning from [16] S. Jabbour, L. Sais, and Y. Salhi. A pigeon-hole based [17] J. P. Marques-Silva and K. A. Sakallah. GRASP -A [18] L. Parida, I. Rigoutsos, A. Floratos, D. Platt, and [19] L. Parida, I. Rigoutsos, and D. Platt. An [20] N. Pisanti, M. Crochemore, R. Grossi, and M.-F. [21] C. Sinz. Towards an Optimal CNF Encoding of [22] G. Tseitin. On the complexity of derivations in the [23] J. P. Warners. A linear-time transformation of linear [24] L. Zhang, C. F. Madigan, M. W. Moskewicz, and [25] W. Zhao and W. Wu. Asig: An all-solution sat solver
