 This paper introduces support envelopes X  X  new tool for an-alyzing association patterns X  X nd illustrates some of thei r properties, applications, and possible extensions. Speci fi-cally, the support envelope for a transaction data set and a specified pair of positive integers ( m, n ) consists of the items and transactions that need to be searched to find any association pattern involving m or more transactions and n or more items. For any transaction data set with M trans-actions and N items, there is a unique lattice of at most M  X  N support envelopes that captures the structure of the association patterns in that data set. Because support en-velopes are not encumbered by a support threshold, this support lattice provides a complete view of the association structure of the data set, including association patterns t hat have low support. Furthermore, the boundary of the sup-port lattice X  X he support boundary  X  X as at most min ( M, N ) envelopes and is especially interesting since it bounds the maximum sizes of potential association patterns X  X ot only for frequent, closed, and maximal itemsets, but also for pat -terns, such as error-tolerant itemsets, that are more gener al. The association structure can be represented graphically a s a two-dimensional scatter plot of the ( m, n ) values associ-ated with the support envelopes of the data set, a feature that is useful in the exploratory analysis of association pa t-terns. Finally, the algorithm to compute support envelopes is simple and computationally efficient, and it is straight-forward to parallelize the process of finding all the support envelopes.
 Categories and Subject Descriptors: H.2.8 [Database Management]: Database Applications -Data Mining General Terms: Algorithms, Theory Keywords: support envelope, association analysis, formal concept analysis, error-tolerant itemsets
This paper introduces support envelopes , which provide a compact and computationally efficient approach for cap-turing the high-level structure of support based associati on patterns such as frequent, closed, and error-tolerant item -sets [8, 9, 13, 20, 19]. More specifically, the support envelope for a transaction data set and a pair of positive integers ( m, n ) consists of the items and transactions that need to be searched to find all patterns involving a minimum of m transactions and n items. Thus, the number of distinct en-velopes is at most M  X  N , where M is the number of trans-actions and N is the number of items. For sparse data sets, the number of support envelopes is typically much less than M  X  N .

Like other association patterns, e.g., frequent and closed itemsets, support envelopes form a lattice. (We will call this lattice the support lattice .) In particular, for any binary matrix with M rows (transactions) and N columns (items), there is a unique lattice that captures the structure of the association patterns for that matrix. Standard associatio n analysis techniques for finding frequent, closed, or maxima l itemsets break down when the support threshold becomes too low, and thus, cannot provide information about pat-terns with low levels of support. However, because support envelopes are not encumbered by a support threshold, the support lattice provides a complete view of the association structure of the data set, including association patterns t hat have low support.

The boundary (positive border [11]) of the support lat-tice, which we call the support boundary , is especially in-teresting since it bounds the maximum sizes of potential association patterns. For example, if an envelope on the support boundary is characterized by the pair of integers ( m, n ), then there are no non-empty envelopes or associa-tion patterns with larger values of m and n . To illustrate, if the support boundary of a data set contains the support envelope characterized by (10 , 5), then the data set cannot contain a frequent itemset with 5 or more items that also has more than 10 supporting transactions. Furthermore, the support boundary is not just a bound on frequent, closed, and maximal itemsets, but also on patterns, such as error-tolerant itemsets (ETIs) [19], that are more general. An-other attractive property of the support boundary is that it contains at most min ( M, N ) support envelopes.

In addition to providing us with a theoretical foundation for understanding X  X t least in part X  X he high-level structu re of association patterns, support envelopes allow the assoc ia-tion structure of a binary data to be represented graphicall y. Specifically, the ( m, n ) values associated with the envelopes in the data set can be displayed in a two-dimensional scatter plot, which provides a global view of the structure of associ -ation patterns in a data set. Additional information can be added to this scatter plot by shading or coloring each point based on the density X  X raction of ones X  X f its corresponding support envelope. Support envelopes are often fairly spars e, i.e., have low density, but in some cases, support envelopes can be relatively dense, and hence, are interesting not just because of the information that they provide about other association patterns, but also as patterns in their own righ t. Thus, for some data sets, e.g., the kosarak data set discusse d in Section 4, we can use the scatter plot to identify dense envelopes that can be investigated to find association pat-terns of considerable interest, e.g., low support itemsets with many items.

Support envelopes are also interesting from an algorithmic point of view. We present a simple iterative algorithm that, given only ( m , n ) and a binary data matrix, finds the sup-port envelope for all the support-based patterns character -ized by ( m , n ) in time proportional to (a) nnz , the number of non-zero entries in the data matrix, and (b) num iter , the number of iterations, which is typically small, i.e., less t han 10 for data sets in this paper. This algorithm can compute any individual support envelope without using the precedin g elements of the support lattice. (As discussed later, using the lattice does, however, improve efficiency somewhat, i.e. , the number of iterations is typically reduced to 2 or 3.) The computational complexity of computing the entire support lattice is O ( M  X  N  X  nnz  X  num iter ), while the computa-tional complexity of finding only the support boundary is O ( min ( N log( M ) , M log( N ))  X  nnz  X  num iter ). Thus, un-like many association mining tasks, the computational com-plexity of finding the support lattice or support boundary is not inherently exponential. Also, because support envelop es can be computed independently of the lattice, it should be straightforward to parallelize finding either all envelope s or just those envelopes on the support boundary.

Finally, we consider two simple extensions of support en-velopes. First, support envelopes involving only the items of one specific transaction provide a view of patterns with respect to a particular transaction, i.e., the set of such  X  X  e-stricted X  support envelopes will involve only those associ a-tion patterns that are guaranteed to contain the specified transaction. Second, we consider support envelopes that involve an additional constraint on items, namely, that a certain fraction of the occurrences of an item must be in the support envelope. Such an approach eliminates items that are frequent across many patterns.

Overview Section 2 introduces support envelopes and an algorithm for finding them via an informal example, while Section 3 provides a formal analysis of support envelopes and their properties, and also discusses algorithms for find -ing an individual support envelope, the envelopes on the support boundary, and the set of all envelopes for a data set. Section 4 uses support envelopes to explore real trans-action data sets, while extensions to the support envelope concept are considered in Section 5. Section 6 discusses re-lated work, and we conclude, in Section 7, with a summary and indications for future work.
This section contains an informal introduction to support envelopes, lattices, and boundaries. Consider the followi ng task: Construct an algorithm to identify all the items and Table 2: Data after eliminating rows with less than 3 items. Step 1.
 Table 3: Data after eliminating columns with less than 3 supporting transactions. Step 2.
 Table 4: Data after eliminating rows with less than 3 items. Step 3.
 transactions that are involved in frequent itemsets with at least n items, where by frequent we mean that the itemset must appear in m or more transactions. Instead of trying to find the interesting frequent patterns, we are asking for something simpler X  X or the items and transactions involved in such patterns.

We will use the data set provided in Table 1. Transactions have the numeric labels 1 through 12, while items are labeled with the letters  X  X  X  through  X  X . X  This table also shows the sums of each row and column, which represent, respectively, the number of items in each transaction and the number of transactions containing each item. For example, transacti on 1 contains 4 items, while item A occurs in 6 transactions.
We start with a simple idea: Any itemset that has a sup-port requirement of m must contain items that occur in at least m transactions. Similarly, any itemset that contains n items must be supported by transactions that have at least n items. Thus, for example, suppose we are interested in all itemsets that contain at least n = 3 items and have at least m = 3 supporting transactions. From Table 1, we see that we need consider only transactions (rows) 1, 3, 7, 8, 10, and 11, since all other transactions have fewer than 3 items. We are not saying that these transactions are definitely in-volved in frequent itemsets with 3 or more items, only that they might be.

Turning our attention to items, we now evaluate which items are involved in itemsets of size 3 or more with a sup-port of 3 or more. We might first look at the number of transactions in which each item appears X  X ee Table 1 X  X ut such an approach does not take into account our previous observation that some transactions should be eliminated. I n particular, it is only the support of items within transacti ons 1, 3, 7, 8, 10, and 11 that is important, as these are the only transactions capable of supporting an itemset with 3 or more items. After computing support within only these transac-tions, we get the support for the five items to be, in order, 4, 2, 6, 6, 5 X  X ee Table 2. Thus, we can eliminate item B.
Of course, once we have eliminated item B, we have in-validated our previous counts of how many items occur in each transaction. After taking the elimination of item B int o consideration, the counts for transactions 1, 3, 7, 8, 10, an d 11 are, respectively, 4, 3, 4, 4, 4, and 2 X  X ee Table 3. Thus, transaction 11 can be eliminated X  X ee Table 4. Further iter-ations yield no change, and thus, we obtain the result that all itemsets with 3 or more items and 3 or more supporting transactions occur among some subset of items A, C, D, and E and some subset of transactions 1, 3, 7, 8, and 10. This set of items and set of transactions is a support envelope.
To verify the correctness of this result, we computed the frequent itemsets with a support threshold of 3. These item-sets are shown in Table 5 and are consistent with the results of our example, i.e., they show that the only itemsets with support of 3 or more are those involving items A, C, D, and E. It is straightforward to verify X  X ee tables 1 and 4 X  X hat the only transactions that contain at least three of these items are 1, 3, 7, 8, and 10.
 Table 5: Frequent itemsets with support 3 or more.
For the data set in Table 1, all the support envelopes can readily be computed by using the algorithm that we devel-oped above for each ( m, n ) pair, where 1  X  m  X  12 and 1  X  n  X  6. (This algorithm, which we call the Support Envelope Algorithm (SEA), is formally described in Section 3.3.) Not all values of m and n will yield non-empty support envelopes, and some ( m, n ) pairs may yield the same sup-port envelope, i.e., the same set of transactions and items. Support envelopes can be organized as a lattice [4] by defin-ing one support envelope to be  X  X ess than X  (a subset of) a second support envelope if the items and transactions of the first are a subset of the items and transactions of the second.
In Figure 1, we see a tree-like display of the support lat-tice. Nodes represent individual support envelopes, while lines represent the subset relationships between envelope s, i.e., that a lower envelope is a subset of a higher envelope. Inside each box representing a support envelope are the val-ues of m and n that characterize the envelope, as well as the sets of transactions and items involved in the envelope. Thus, for the envelope represented by the topmost node in Figure 1, each of the items in the support envelope occurs in at least 5 transactions and each transaction in the support envelope contains at least 2 items. Since these conditions are satisfied by all transactions and items, this root (or top ) envelope contains all the transactions and items in the data set. While not illustrated by Figure 1, support envelopes can have multiple parents and/or children.

Since each pair of integers ( m , n ) is associated with a sup-port envelope (possibly the empty support envelope), we can represent the entire set of support envelopes as a plot of an M by N grid ( M is the number of transactions and N is the number of items), where each grid cell is shaded according to its associated support envelope, and where each support en-velope is assigned a different shade of gray. Figure 2 shows the set of support envelopes using such a representation. Once again, we have used the same shade of gray for all grid cells, i.e., ( m , n ) pairs, that represent the same support en-velope. Thus, the block in the upper left corner of Figure 2 represents the fact that all support envelopes with m  X  5 and n  X  2, are identical, i.e., contain the same transactions and items. To identify the support envelope associated with with each block in the figure, we find the largest possible values of m and n of the block, i.e., we use the values of m and n from the the lower right corner of the block. Thus, for example, the big dark block in the upper left corner is the (5, 2) support envelope. Also, as we will discuss in the next section, if a support envelope is below (to the right of) another support envelope, then it is a subset of that en-velope, i.e., the transactions and items of the lower (more rightmost) support envelope are subsets of the transaction s and items of the higher (more leftmost) support envelope.
For larger data sets, it is more convenient to view the set of support envelopes as a scatter plot of the ( m, n ) values. Such a plot is shown in Figure 3. To provide more informa-m (min transactions) Figure 2: Support lattice for sample data -rectan-gular format. tion, we have shaded each point representing a support enve-lope according to its density, i.e., the fraction of ones in t he block defined by the transactions and items in the envelope. (This information can be gathered at almost no cost when finding the support envelopes.) When a support envelope is relatively dense, e.g., more than 50% dense, the envelope is often an interesting pattern in own right, not just because o f the information it provides about other association patter ns. (All the envelopes in our example are relatively dense.) We show examples of such interesting dense envelopes for real data sets later in this paper.

A scatter plot does not explicitly show all the information of the lattice, i.e., which envelopes are the immediate desc en-dants or parents of other envelopes. However, most of this information is captured by the position of the points that represent envelopes. Specifically, an envelope (point) tha t is below and/or to the right of a second envelope (point) is contained by that envelope. In our graphical exploration of support envelopes later in the paper, we will focus on the scatter plot of all the envelopes of a data set.
After a quick review of notation and some other prelim-inaries, we define support envelopes, analyze the algorithm for finding support envelopes, and discuss some properties of support envelopes.
In this section we take care of a few preliminaries.
An overview of notation is provided in Table 6.
Support envelopes capture the structure of association patterns that can be characterized with respect to a mini-mum level of support ( m ), and a minimum number of items ( n ). We make this more formal in the following definition. m (min transactions) Figure 3: Support lattice for sample data -scatter plot.
 Notation Description
D Data matrix of M rows and N T = { t 1 , t 2 ,  X   X   X  , t M } Set of transactions (rows) of D I = { i 1 , i 2 ,  X   X   X  , i N } Set of items (columns) of D X , Y A set of items
R , S A set of transactions m Minimum number of transac-n Minimum number of items for an mm Total number of transactions in nn Total number of items in an en-Definition 1. Pattern Characterized by ( m , n ) A pattern characterized by a pair of positive integers ( m , n ) is a pattern that involves a set of items X and a set of trans-actions R such that (a) every item of X occurs in at least m transactions of R and every transaction of R contains at least n items of X , and (b) m and n are maximal. Many common types of association patterns fall into this category, e.g., frequent itemsets and variations such as cl osed and maximal itemsets [8]. Error-tolerant itemsets (ETIs) [19], or more properly a slight variation of ETIs, can also considered to be a pattern characterized by a pair of inte-gers ( m , n ), as we show in the following discussion
An ETI is a frequent itemset that allows a specified frac-tion of the items to be missing from any one transaction, e.g., if = 0 . 2, then 1/5 of the items in a transaction can be missing. While ETIs are an important approach for ex-tending association patterns, there is a problem with ETIs as currently defined. For example, consider an ETI with = 0 . 2, which consists of a set of 10 transactions and 5 items. While each transaction must contain at least 4 out of 5 items, items are not necessarily treated  X  X qually, X  e.g., each transaction could be missing the same item. The originators of ETIs noted this issue, which can be problematic in the degenerate case just mentioned, and avoided this degener-ate case in an unspecified manner in their implementation. However, it seems desirable, even beyond the current dis-cussion, to modify the notion of an ETI to be more in line with that of frequent itemsets, where all items play an equal role in the pattern. To this end, we define a symmetric ETI. Definition 2. Symmetric Error Tolerant Itemset A symmetric ETI is a frequent itemset that allows a specified fraction of the items to be missing from any one transaction and a specified fraction  X  of transactions to be missing a particular item.

Any symmetric ETI can be characterized by a pair of inte-gers ( m, n ). For example, assume that we have a symmetric ETI which has 12 transactions and 4 items, where = 1 / 4 and  X  = 1 / 3. Then, m = 8, i.e., each item must appear in 8 transactions in the ETI, and n = 3, i.e., each transac-tion must contain at least 3 of the items in the ETI. Thus, symmetric ETI X  X  are contained in support envelopes. The importance of this is that the support boundary is not only a bound on frequent, closed, and maximal itemsets, but also on patterns, such as symmetric ETIs, that are more general.
On a theoretical note, a support envelope can be consid-ered as a type of symmetric ETI. Suppose that we have a support envelope characterized by ( m, n ). If mm is the total number of transactions in the envelope and nn is the total number of items in the envelope, then the support envelope is a symmetric ETI with = n/nn and  X  = m/mm . How-ever, support envelopes have properties not shared by all symmetric ETIs. We now formally define a support envelope.
 Definition 3. Support Envelope A support envelope E m,n characterized by a pair of positive integers ( m , n ) is a set of items X  X  I and a set of trans-actions R  X  T which contains all patterns characterized by any pair of positive integers ( m 0 , n 0 ) such that m 0  X  m and n 0  X  n .
 Expressed another way, the transactions and items of the support envelope are the union, respectively, of all the tra ns-actions and items of all patterns characterized by any ( m 0 , n 0 ), such that m 0  X  m and n 0  X  n . Also, by construction, there cannot be more than one support envelope per ( m , n ) pair. However, as discussed previously and below, the support envelopes for different pairs of integers ( m, n ) may be identical, and in that case, we will refer to the support envelope using the largest values of m and n .
The algorithm for finding support envelopes X  X EA X  X s shown below. We analyze the complexity, convergence, and correctness of SEA, as well as discussing how SEA can be used as the basis of algorithms for finding either the en-velopes in the support boundary or the support lattice. Ini-tial implementations of these algorithms are available fro m [16].
 Algorithm 1 Support Envelope Algorithm (SEA). 1: { Input: Data matrix D and a pair of positive integers 2: repeat 3: Eliminate all rows whose sum is less than n . 4: Eliminate all columns whose sum is less than m . 5: until D does not change 6: return the set of rows (transactions) and columns Table 8: Statistics of Computing Support Envelopes
Some data sets that will be used to illustrate various as-pects of the following algorithms are listed in Table 7. The first three data sets can be found at the Frequent Itemset Mining Implementations Repository [6], while the LA1 data set is from the LA data of TREC-5 [22]. Table 8 shows various statistics related to the computation of support en -velopes for the given data sets. (The results in this table were gathered by experiments performed on a 3.2 GHz Intel Xeon r Linux system.) The first value in the # Envelopes column is the number of envelopes for a data set, while the value in parentheses is the number of envelopes on the sup-port boundary. The first value in the Time column is the time (in seconds) required to compute all the support en-velopes for a data set, while the value in parentheses is the time (in seconds) to compute the support boundary.
Complexity: The time complexity of SEA is propor-tional to (a) the number of iterations, num iter , and (b) the amount of time to test each row and column to see if it should be eliminated. For a sparse matrix representation , the time to sum a row or column and compare this sum to m or n , is proportional to the number of non-zero entries in the row or column. Therefore, the total time required to check which rows and columns should be eliminated is proportional to, nnz , the number of non-zero entries in the entire matrix, and the overall time complexity of SEA is O ( M  X  N  X  nnz  X  num iter ).

If a parent of a support envelope is known, then finding a support envelope is somewhat more efficient because we can use the transactions and items of the parent envelope to provide a smaller starting matrix. This effect is more im-portant for larger data sets. For example, with the kosarak data set shown in Table 7, the average number of iterations is reduced from 8 to 3 by using a parent envelope. For the LA1 data set, which is significantly smaller, the average number of iterations is reduced from 4 to 3. For mushroom and chess, the reduction is from 3 to 2.

The space required for SEA is O ( nnz ) plus the amount of space required to store the support envelopes. While the row and column indices can potentially require significant space, there are a couple strategies that can be used to sig-nificantly reduce memory requirements. First, we can store only the indices in which an envelope differs from a parent envelope. (Preliminary investigations indicate that this ap-proach seems promising.) A second approach is to not store the row and column indices at all since the entire envelope can be quickly recomputed if needed.

Convergence: We show that SEA converges to a solu-tion in a fixed number of steps.

Theorem 3.1. SEA converges to a solution in a fixed number of steps whenever the input is a binary matrix D and positive integers m and n .

Proof. Either SEA eliminates a row or column at each step, eventually producing an empty matrix, or else SEA terminates after a step in which D is unchanged. Thus, SEA will converge to a solution in at most min ( M, N ) steps. As mentioned, typically, convergence occurs in a much small er number of steps, i.e., less than 10 for the data sets in Table 7.

Correctness: Here we show that SEA finds support en-velopes.

Theorem 3.2. Given the data matrix D and a pair of positive integers ( m , n ), the set of items Y  X  I and trans-actions S  X  T returned by SEA are the support envelope of D characterized by ( m, n ) , i.e., SEA( D , m, n ) = E m,n
Proof. Consider any pattern that is characterized by m 0  X  m and n 0  X  n and that involves the set of items X  X  I and the set of transactions R  X  T . By Definition 1, every transaction in R must contain at least n items of X and every item in Y must occur in at least m transac-tions of R . Consequently, none of the transactions of R can be eliminated in Step 3 of SEA since they are  X  X upported X  by the items of Y . Also, none of the items of Y can be eliminated in Step 4 of SEA since they are  X  X upported X  by the transactions of R . Thus, X  X  Y and R  X  S , i.e., the items and transactions of this pattern are subsets of the set of items and transactions found by SEA. From this, we conclude that the items and transactions returned by SEA contain those of E m,n . We still need to show that E m,n contains the items and transactions returned by SEA. How-ever, the set of items and transactions returned by SEA is certainly a pattern characterized by ( m, n ) and must belong An Algorithm for Finding the Support Boundary A straightforward approach to finding the support boundary is to perform a binary search over possible values of n for each value of m , or to perform a binary search over possible values of m for each value of n . Such an approach results in a conservatively estimated time complexity of O ( min ( N log( M ) , M log( N ))  X  nnz  X  num iter ). (Practically, this means that it is somewhat better to perform the binary search over values of n if there are fewer rows than columns, and vice-versa.) We omit a detailed description of this algorithm. An im-plementation of this algorithm can be found at [16] and the statistics from runs for real data sets are given in Table 8.
Algorithms for Finding All Support Envelopes A simple approach to finding all the support envelopes is, for each value of m , to find envelopes for each value of n up to the limit imposed by the support boundary. (Again, this means that it is somewhat better to perform our algorithm by varying n for a fixed m if there are fewer rows than columns, and vice-versa.) An implementation of this algo-rithm can be found at [16], and statistics from runs for real data sets are presented in Table 8.

Scalability A basic strategy for parallelizing the previ-ous algorithm is to have each processor compute all the en-velopes for a fixed value of m (or n) and all values of n (or m ). A similar approach could be used to parallelize the al-gorithm for finding the support boundary. Issues that would need to be considered include load balancing and the gener-ation of duplicate support envelopes by different processor s.
Another important scalability issue that needs investiga-tion is how to best adapt the SEA algorithm for cases where the data is large, i.e., where the data does not fit in main memory and it is desirable to (a) access the data in a se-quential manner and (b) make as few passes over the data as possible. SEA can be implemented to access data in a sequential manner if two copies of the data are kept, one with the data ordered by rows and the other with the data ordered by columns.
We have already encountered a number of the proper-ties of support envelopes in the previous discussion. For completeness and clarity, we summarize the properties of support envelopes in this section. Actual proofs of these properties can be found in our technical report [17].
For for each pair of integers ( m, n ), where 1  X  m  X  M and 1  X  n  X  N , there is an associated support envelope X  perhaps the empty support envelope X  X hich is the support envelope that SEA will return when given ( m, n ) and the data set D . However, as we saw in the example, the same support envelope may be associated with more than one pair of integers since the items and transactions that satisfy th e ( m, n ) constraints may actually satisfy stronger constraints. We characterize a support envelope by the strongest support and item constraints (i.e., by the maximum ( m, n ) values) that it satisfies. A consequence of these two facts is that the number of support envelopes in a data set is at most M  X  N .
One support envelope may contain another support enve-lope, i.e., the items and transactions of one envelope may be subsets of the items and transactions of another envelope. Said another way, a support envelope defines a block of the data set (matrix) D , and this block may contain the blocks that correspond to other envelopes. Indeed, for a given sup-port envelope characterized by ( m, n ), any envelope charac-terized by ( m 0 , n 0 ), such that m 0  X  m and n 0  X  n , must be a subset of the ( m, n ) envelope. This is not surprising, since increasing m and n will likely eliminate items and transac-tions.
 Like frequent itemsets, support envelopes form a lattice. For support envelopes the order relationship is the subset relationship described above. Support envelopes that con-tain no other (non-empty) envelopes are said to be on the support boundary.

An interesting property that was not mentioned in the example, is that the density of envelopes, i.e., the fractio n of 1 X  X  in the block represented by the envelope, increases as we move down the lattice. Thus, if one envelope con-tains another, it must be less dense (or at least no more dense) than the envelope that it contains. This means that Figure 4: Support envelopes for mushroom data set. the support boundary must contain the densest envelopes in the support lattice. This does not mean, however, that every envelope on the support boundary is denser than any envelope elsewhere in the support lattice.

There can be at most min ( M, N ) envelopes on the support boundary. Otherwise, two envelopes on the boundary would have the same value of m or n and one would contain the other. For a similar reason, the values of m and n are in-versely related as we move along the support boundary, i.e., if we order the support envelopes to have increasing values of m , then successive envelopes will have decreasing values of n .
In this section we demonstrate how support envelopes can be used to explore the transaction data sets of Table 7.
We begin by showing the support envelopes for the mush-room and chess data sets in figures 4 and 5, respectively. As before, we have shaded the points to show the density of the support envelopes, i.e., the fraction of 1 X  X  in the block of items and transactions defined by the envelope. Both of these data sets are relatively dense compared to many transaction data sets and thus, the overall densities of the envelopes are relatively high. For both data sets, the den-sities of the envelopes are highest for envelopes with many transactions, but few items. This reflects the fact that both data sets have a few items that occur in most transactions. In some cases, these  X  X verly frequent X  items should be dis-carded since they yield little information.

Also, for both data sets, there are no envelopes near the origin. This reflects the fact that every item occurs in some minimum number of transactions and that every transaction contains some minimum number of items. For mushroom, every item occurs in at least 4 transactions and every trans-action contains exactly 23 items. For chess, every transac-tion contains 37 items and and every item occurs in at least 1 transaction.

However, all association patterns characterized by ( m, n ) values for which there are no points in the figures, can be found in the transactions and items of the envelopes on the
Figure 5: Support envelopes for chess data set. Figure 6: Plot of mushroom support envelope (576,23). inner boundary of the support lattice. Indeed, the root en-velope corresponding to (1 , 1) X  X nd perhaps other pairs of integers X  X s guaranteed to encompass all association pat-terns in the data set. For mushroom, the root envelope is characterized by the pair (4 , 23), while for chess, the root envelope is characterized by (1 , 37).

Despite some similarities, the two sets of support envelope s are quite distinct, e.g., the boundary of the mushroom data set curves inward (towards the origin), while that of the chess data set curves outward. Our observation, which is based on a limited number of data sets, is that for sparser data, the boundary is basically concave, while for denser data sets, the boundary is basically convex. Of course, as fig -ures 4 and 5 show, regardless of the overall curvature of the boundary, it may X  X n different sections X  X ctually be both concave and convex.

As another example of how we might use support en-velopes to analyze the structure of support patterns in a data set, we remark that there is an unusually dense sup-port envelope with 576 transactions and 23 items in the mushroom data set. It has a density of 0.65, while most of the envelopes around it have densities ranging from 0.3 to Figure 8: Support envelopes for kosarak data set. Note: log scale. 0.4. Since this support envelope is somewhat anomalous, we show its plot in Figure 6. The items and transactions of the envelope have been sorted to put the denser region of the support envelope toward the upper left hand corner. Each gray pixel corresponds to a 1 in the envelope, while each white pixel corresponds to a 0. The figure shows that there is a group of 14 items that occur together in every one of the 1728 transactions in the envelope. (Remember that the total number of transactions ( mm ) and items ( nn ) in an envelope is different from the m (support) and n (item) constraints.)
Upon further analysis, we discovered that one of the columns was the column 48,  X  X ill-color:buff. X  There are exactly 1728 instances of item 48, every one of which occurs with 13 other items (one of which is  X  X oisonous X ). This support envelope is somewhat denser than the others around it because the co-occurrence of 13 items is larger than is typical for this data set. Figure 9: Plot of kosarak support envelope (276,113).
For contrast, we show a graph of the LA1 support en-velopes in Figure 7. LA1 is much more sparse and has more items, although fewer transactions, then either mushroom o r chess. The support envelopes are relatively sparse compare d to those of both mushroom and chess. However, the density does increase from 0.0048 for envelopes near the origin (up-per left) to around 0.2 for envelopes at the boundary. The two black dots in the upper right and lower left represent, respectively, the longest document and the most frequent item (word). The support boundary is extremely concave in LA1.

The set of kosarak envelopes is shown in Figure 8. We have used log 10 scales for both the m and n axes because the m and n values have a much wider range of values. However, if this were not the case, the support boundary of kosarak would be even more concave than that of LA1.
Interestingly, some of envelopes on or near the kosarak support boundary, with values of m between 100 and 1000 (between values of 2 and 3 on the log 10 scale) have relatively high density. We investigated the boundary support enve-lope (276, 113). Note that it would be difficult to investigate patterns with such low support using traditional approache s. Indeed, the results of the FIMI workshop [6], show that cur-rent algorithms to find frequent, closed, or maximal itemset s start to experience a sharp growth in run time at a support threshold of about 0.1% (990) transactions.) The support value for envelope (276, 113) is even lower than this, i.e., less than 0.03%.

Figure 9 shows a plot of the support envelope correspond-ing to (276, 113), which has a density 0.993. This envelope contains a frequent itemset of size 250, and we tried to find this itemset using the algorithm, fpmax , which is available from the FIMI website [6]. The program ran for more than a most 5 million maximal itemsets. (We are not sure whether the program terminated normally since memory usage had grown to 1.2 GB shortly before it terminated.) In contrast, the support boundary for kosarak was computed in approx-imately 15 minutes on the same machine. (Computing the boundary on a faster machine took only about 7 minutes.)
In this section, we discuss two additional extensions of the basic approach: computing support envelopes with re-spect to specific transactions or items and adding additiona l constraints to support envelopes.
When support envelopes are not very dense, they are of interest only for the patterns that can be extracted from them and for what they tell us about the overall structure of association patterns. However, if a support envelope is relatively dense, then the envelope is interesting as a patt ern in its own right. Thus, it may be useful to seek special situ-ations where support envelopes are more likely to be dense. To that end, we consider support envelopes associated with a particular transaction (or item).

To illustrate this idea, we show an example using the LA1 data set. We constructed a data set specific to the first doc-ument (transaction) in LA1 by eliminating all words (items) that do not appear in this document. (This document comes from the  X  X inancial X  class.) We then computed the support boundary of this document specific data set. Since we are working in the document domain, we display the results in a table that shows the parameters of the support en-velopes and the words (items) that are part of the support envelopes. (LA1 was processed using standard information retrieval techniques, e.g., the words are stemmed and stop words are eliminated.) The first support envelope consists o f the selected document and all its words, while successive en -velopes consist of smaller subsets of these words. For succe s-sive envelopes along the boundary, the number of documents increases, while the number of words (usually) decreases. I n other words, the pattern represented by the support enve-lope is becoming more general as we move along the support boundary from lower to higher values of m . The most inter-esting support envelopes are those in the middle, since they are not as specific as a particular document, nor so general as to be uninteresting. The envelope with the highest value of m contains the word,  X  X ome, X  which is the most frequent word contained by the first document.

These support envelopes have a clear theme of a bank bailout of the home savings and loan industry. However, the patterns represented by these support envelopes are onl y moderately strong, i.e., the support envelopes that contai n more than a few documents and items tend to have densities in the range of 0.5 to 0.7. Nonetheless, recall that the regul ar support envelopes for LA1 only have a density that is, at best, around 0.2.
A special case of extending support envelopes that is easy to implement and interpret involves adding a constraint to the support envelope process. For example, very frequent items show up in many association patterns, but provide little useful information. One way to address this issue is to require that the fraction of an item involved in an as-sociation pattern meets some minimum threshold. (This is formally defined by the notion of a hyperclique pattern [18].) It is straightforward to add such a constraint to the computation of support envelopes. In other words, given a specified fraction f between 0 and 1, we eliminate an item Table 9: Support boundary envelopes LA1 re-stricted to words (items) in the first document (transaction). Table 10: Support boundary envelopes LA1 re-stricted to words in the first document and with the additional constraint that 50% of the occurrences of a word must be in the envelope. if does not occur in at least m transactions and at least f of its total support occurs among the transactions of the sup-port envelope. For example, if f = 0 . 5, then at least half of the supporting transactions of an item must occur in the support envelope. While a similar constraint could also be applied to the rows as well, we do not pursue that approach here.

To illustrate this approach, we find the support boundary specific to the first document in the LA1 data set using a threshold of 0.5. The results are shown in Table 10. There are far fewer envelopes, but they still seem to capture much of the meaning of the envelopes of Table 9. In particular, the first envelope on the boundary no longer consists of all the terms from the first document of LA1 that was used to generate the reduced data set.
To our knowledge, the notion of a support envelope is new, although the concept of an  X  X nvelope X  is common in mathe-matics, where an envelope is a mathematical entity X  X sually a curve X  X hat bounds a collection of other mathematical en-tities. The related notion of a cover has been used before in association analysis, but for association rules [3, 12, 14] .
The idea of support envelopes was inspired partly by var-ious concepts in lattice theory [4] and formal concept analy -sis [5], especially those ideas that have found their way int o association analysis [5, 7, 11]. In particular, a key motiva t-ing concept for us is the notion of efficiently representing frequent itemsets via a lattice of closed itemsets [1, 13, 21 ]. More generally, closed itemsets are a specific example of con -densed representations [2, 10]. However, support envelope s are not a condensed representation since it is necessary to keep the original matrix if the goal is to use support en-velopes to actually find itemsets.

The idea of error tolerant itemsets (ETIs) [19] also played an important role in our thinking. In particular, ETIs em-phasize the notion that it is useful to consider a version of frequent itemsets that relaxes the requirement that all items be contained in all transactions. Support envelopes also embrace this idea, and as we showed in Section 3.1.3, are a special type of ETI.

Finally, there has been some recent work on computing tight lower bounds for distributions of frequent and maxima l frequent itemsets [15]. Although this is a different line of inquiry than we have pursued in this paper, such work is also quite relevant to understanding the structure of suppo rt based patterns in transaction data.
In this paper, we introduced support envelopes, a new tool that is useful for exploring the high-level structure of ass oci-ation patterns in a transaction data set. Support envelopes are not encumbered by a support threshold and they pro-vide information not only about frequent, closed, and maxi-mal itemsets, but also about more general patterns, such as symmetric error-tolerant itemsets. Support envelopes pro -vide both a theoretical basis for understanding the structu re of association patterns and a graphical technique for visu-alizing this structure. Furthermore, there are simple and efficient algorithms to compute a single support envelope, the support envelopes on the support boundary, or all the support envelopes of a data set.

There is considerable potential for future work. Current implementations for finding the support boundary support or all support envelopes and could be improved and par-allelized to provide additional performance. Also, the the -oretical properties of support envelopes should be further explored. In particular, the extensions of support envelop es deserve further investigations since they may be useful bot h for finding actual patterns, as well as for providing addi-tional information about the overall structure of associat ion patterns. In particular, we hope to investigate whether we can extend the notion of support envelopes to continuous data. Finally, further work is necessary to more fully under -stand what information can be extracted from scatter plots of support envelopes. This work was partially supported by NASA grant # NCC 2 1231, by DOE/LLNL grant W-7045-ENG-48, by NSF grant IIS-0308264, and by the Army High Performance Computing Research Center under the auspices of the De-partment of the Army, Army Research Laboratory cooper-ative agreement number DAAD19-01-2-0014. The content of this work does not necessarily reflect the position or pol-icy of the government and no official endorsement should be inferred. Access to computing facilities was provided by AHPCRC and Minnesota Supercomputing Institute.
