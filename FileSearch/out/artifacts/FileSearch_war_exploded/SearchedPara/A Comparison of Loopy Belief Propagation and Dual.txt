 Accurate and efficient parsing of Combinatorial Cat-egorial Grammar (CCG; Steedman, 2000) is a long-standing problem in computational linguistics, due to the complexities associated its mild context sen-sitivity. Even for practical CCG that are strongly context-free (Fowler and Penn, 2010), parsing is much harder than with Penn Treebank-style context-free grammars, with vast numbers of nonterminal categories leading to increased grammar constants. Where a typical Penn Treebank grammar may have fewer than 100 nonterminals (Hockenmaier and Steedman, 2002), we found that a CCG grammar derived from CCGbank contained over 1500 . The same grammar assigns an average of 22 lexical cate-gories per word (Clark and Curran, 2004a), resulting in an enormous space of possible derivations.
The most successful approach to CCG parsing is based on a pipeline strategy (  X  2). First, we tag (or multitag) each word of the sentence with a lexical category using a supertagger , a sequence model over these categories (Bangalore and Joshi, 1999; Clark, 2002). Second, we parse the sentence under the requirement that the lexical categories are fixed to those preferred by the supertagger. Variations on this approach drive the widely-used, broad coverage C&amp;C parser (Clark and Curran, 2004a; Clark and Curran, 2007; Kummerfeld et al., 2010). However, it fails when the supertagger makes errors. We show experimentally that this pipeline significantly lowers the upper bound on parsing accuracy (  X  3).

The same experiment shows that the supertag-ger prunes many bad parses. So, while we want to avoid the error propagation inherent to a pipeline, ideally we still want to benefit from the key insight of supertagging: that a sequence model over lexi-cal categories can be quite accurate. Our solution is to combine the features of both the supertagger and the parser into a single, less aggressively pruned model. The challenge with this model is its pro-hibitive complexity, which we address with approx-imate methods: dual decomposition and belief prop-agation (  X  4). We present the first side-by-side com-parison of these algorithms on an NLP task of this complexity, measuring accuracy, convergence be-havior, and runtime. In both cases our model signifi-cantly outperforms the pipeline approach, leading to the best published results in CCG parsing (  X  5). CCG is a lexicalized grammar formalism encoding for each word lexical categories that are either ba-sic (eg. NN, JJ) or complex. Complex lexical cat-egories specify the number and directionality of ar-guments. For example, one lexical category for the verb like is ( S \ NP ) /NP , specifying the first argu-ment as an NP to the right and the second as an NP to the left; there are over 100 lexical categories for like in our lexicon. In parsing, adjacent spans are combined using a small number of binary combina-tory rules like forward application or composition (Steedman, 2000; Fowler and Penn, 2010). In the first derivation below, ( S \ NP ) /NP and NP com-bine to form the spanning category S \ NP , which only requires an NP to its left to form a complete sentence-spanning S . The second derivation uses type-raising to change the category type of I . As can be inferred from even this small example, a key difficulty in parsing CCG is that the number of categories quickly becomes extremely large, and there are typically many ways to analyze every span of a sentence.

Supertagging (Bangalore and Joshi, 1999; Clark, 2002) treats the assignment of lexical categories (or supertags ) as a sequence tagging problem. Because they do this with high accuracy, they are often ex-ploited to prune the parser X  X  search space: the parser only considers lexical categories with high posterior probability (or other figure of merit) under the su-pertagging model (Clark and Curran, 2004a). The posterior probabilities are then discarded; it is the extensive pruning of lexical categories that leads to substantially faster parsing times.

Pruning the categories in advance this way has a specific failure mode: sometimes it is not possible to produce a sentence-spanning derivation from the tag sequences preferred by the supertagger, since it does not enforce grammaticality. A workaround for this problem is the adaptive supertagging (AST) ap-proach of Clark and Curran (2004a). It is based on a step function over supertagger beam widths, re-laxing the pruning threshold for lexical categories only if the parser fails to find an analysis. The pro-cess either succeeds and returns a parse after some iteration or gives up after a predefined number of it-erations. As Clark and Curran (2004a) show, most sentences can be parsed with a very small number of supertags per word. However, the technique is inher-ently approximate: it will return a lower probability parse under the parsing model if a higher probabil-ity parse can only be constructed from a supertag sequence returned by a subsequent iteration. In this way it prioritizes speed over exactness, although the tradeoff can be modified by adjusting the beam step function. Regardless, the effect of the approxima-tion is unbounded.

We will also explore reverse adaptive supertag-ging , a much less aggressive pruning method that seeks only to make sentences parseable when they otherwise would not be due to an impractically large search space. Reverse AST starts with a wide beam, narrowing it at each iteration only if a maximum chart size is exceeded. In this way it prioritizes ex-actness over speed. What is the effect of these approximations? To answer this question we computed oracle best and worst values for labelled dependency F-score using the algorithm of Huang (2008) on the hybrid model of Clark and Curran (2007), the best model of their C&amp;C parser. We computed the oracle on our devel-opment data, Section 00 of CCGbank (Hockenmaier and Steedman, 2007), using both AST and Reverse AST beams settings shown in Table 1.

The results (Table 2) show that the oracle best accuracy for reverse AST is more than 3% higher than the aggressive AST pruning. 1 In fact, it is al-most as high as the upper bound oracle accuracy of 97.73% obtained using perfect supertags X  X n other words, the search space for reverse AST is theoreti-cally near-optimal. 2 We also observe that the oracle worst accuracy is much lower in the reverse setting. It is clear that the supertagger pipeline has two ef-fects: while it beneficially prunes many bad parses, it harmfully prunes some very good parses. We can also see from the scores of the Viterbi parses that while the reverse condition has access to much better parses, the model doesn X  X  actually find them. This mirrors the result of Clark and Curran (2007) that they use to justify AST.

Digging deeper, we compared parser model score against Viterbi F-score and oracle F-score at a va-riety of fixed beam settings (Figure 1), considering only the subset of our development set which could be parsed with all beam settings. The inverse re-lationship between model score and F-score shows that the supertagger restricts the parser to mostly good parses (under F-measure) that the model would otherwise disprefer. Exactly this effect is exploited in the pipeline model. However, when the supertag-ger makes a mistake, the parser cannot recover. The supertagger obviously has good but not perfect predictive features. An obvious way to exploit this without being bound by its decisions is to incorpo-rate these features directly into the parsing model. In our case both the parser and the supertagger are feature-based models, so from the perspective of a single parse tree, the change is simple: the tree is simply scored by the weights corresponding to all of its active features. However, since the features of the supertagger are all Markov features on adjacent supertags, the change has serious implications for search. If we think of the supertagger as defining a weighted regular language consisting of all supertag sequences, and the parser as defining a weighted mildly context-sensitive language consisting of only a subset of these sequences, then the search prob-lem is equivalent to finding the optimal derivation in the weighted intersection of a regular and mildly context-sensitive language. Even allowing for the observation of Fowler and Penn (2010) that our prac-tical CCG is context-free, this problem still reduces to the construction of Bar-Hillel et al. (1964), mak-ing search very expensive. Therefore we need ap-proximations.

Fortunately, recent literature has introduced two relevant approximations to the NLP community: loopy belief propagation (Pearl, 1988), applied to dependency parsing by Smith and Eisner (2008); and dual decomposition (Dantzig and Wolfe, 1960; Komodakis et al., 2007; Sontag et al., 2010, inter alia ), applied to dependency parsing by Koo et al. (2010) and lexicalized CFG parsing by Rush et al. (2010). We apply both techniques to our integrated supertagging and parsing model. 4.1 Loopy Belief Propagation Belief propagation (BP) is an algorithm for com-puting marginals (i.e. expectations) on structured models. These marginals can be used for decoding (parsing) in a minimum-risk framework (Smith and Eisner, 2008); or for training using a variety of al-gorithms (Sutton and McCallum, 2010). We experi-ment with both uses in  X  5. Many researchers in NLP are familiar with two special cases of belief prop-agation: the forward-backward and inside-outside algorithms, used for computing expectations in se-quence models and context-free grammars, respec-tively. 3 Our use of belief propagation builds directly on these two familiar algorithms.
BP is usually understood as an algorithm on bi-partite factor graphs , which structure a global func-tion into local functions over subsets of variables (Kschischang et al., 1998). Variables maintain a be-lief (expectation) over a distribution of values and BP passes messages about these beliefs between variables and factors. The idea is to iteratively up-date each variable X  X  beliefs based on the beliefs of neighboring variables (through a shared factor), us-ing the sum-product rule.

This results in the following equation for a mes-sage m x  X  f ( x ) from a variable x to a factor f where n ( x ) is the set of all neighbours of x . The message m f  X  x from a factor to a variable is where  X  { x } represents all variables other than x , X = n ( f ) and f ( X ) is the set of arguments of the factor function f .

Making this concrete, our supertagger defines a distribution over tags T 0 ...T I , based on emission factors e 0 ...e I and transition factors t 1 ...t I (Fig-ure 2). The message f i a variable T i receives from its neighbor to the left corresponds to the forward prob-ability, while messages from the right correspond to backward probability b i . f i ( T i ) = X b ( T i ) = X The current belief B x ( x ) for variable x can be com-puted by taking the normalized product of all its in-coming messages.
 In the supertagger model, this is just:
Our parsing model is also a distribution over vari-ables T i , along with an additional quadratic number of span ( i,j ) variables. Though difficult to represent pictorially, a distribution over parses is captured by an extension to graphical models called case-factor diagrams (McAllester et al., 2008). We add this complex distribution to our model as a single fac-tor (Figure 3). This is a natural extension to the use of complex factors described by Smith and Eisner (2008) and Dreyer and Eisner (2009).

When a factor graph is a tree as in Figure 2, BP converges in a single iteration to the exact marginals. However, when the model contains cycles, as in Fig-ure 3, we can iterate message passing. Under certain assumptions this loopy BP it will converge to ap-proximate marginals that are bounded under an in-terpretation from statistical physics (Yedidia et al., 2001; Sutton and McCallum, 2010).

The TREE factor exchanges inside n i and outside o i messages with the tag and span variables, tak-ing into account beliefs from the sequence model. We will omit the unchanged outside recursion for brevity, but inside messages n ( C i,j ) for category C i,j in span ( i,j ) are computed using rule probabil-ities r as follows: n ( C i,j ) =
Note that the only difference from the classic in-side algorithm is that the recursive base case of a cat-egory spanning a single word has been replaced by a message from the supertag that contains both for-ward and backward factors, along with a unary emis-sion factor, which doubles as a unary rule factor and thus contains the only shared features of the original models. This difference is also mirrored in the for-ward and backward messages, which are identical to Equations 3 and 4, except that they also incorporate outside messages from the tree factor.

Once all forward-backward and inside-outside probabilities have been calculated the belief of su-pertag T i can be computed as the product of all in-coming messages. The only difference from Equa-tion 6 is the addition of the outside message. The algorithm repeatedly runs forward-backward and inside-outside, passing their messages back and forth, until these quantities converge. 4.2 Dual Decomposition Dual decomposition (Rush et al., 2010; Koo et al., 2010) is a decoding (i.e. search) algorithm for prob-lems that can be decomposed into exactly solvable subproblems: in our case, supertagging and parsing. Formally, given Y as the set of valid parses, Z as the set of valid supertag sequences, and T as the set of supertags, we want to solve the following optimiza-tion for parser f ( y ) and supertagger g ( z ) . Here y ( i,t ) is a binary function indicating whether word i is assigned supertag t by the parser, for the set I = { ( i,t ) : i  X  1 ...n,t  X  T } denoting the set of permitted supertags for each word; sim-ilarly z ( i,t ) for the supertagger. To enforce the con-straint that the parser and supertagger agree on a tag sequence we introduce Lagrangian multipliers u = { u ( i,t ) : ( i,t )  X  I } and construct a dual ob-jective over variables u ( i,t ) .
 This objective is an upper bound that we want to make as tight as possible by solving for min u L ( u ) . We optimize the values of the u ( i,t ) variables using the same algorithm as Rush et al. (2010) for their tagging and parsing problem (essentially a percep-tron update). 4 An advantages of DD is that, on con-vergence, it recovers exact solutions to the combined problem. However, if it does not converge or we stop early, an approximation must be returned: following Rush et al. (2010) we used the highest scoring output of the parsing submodel over all iterations. Parser. We use the C&amp;C parser (Clark and Curran, 2007) and its supertagger (Clark, 2002). Our base-line is the hybrid model of Clark and Curran (2007); our integrated model simply adds the supertagger features to this model. The parser relies solely on the supertagger for pruning, using CKY for search over the pruned space. Training requires repeated calcu-lation of feature expectations over packed charts of derivations. For training, we limited the number of items in this chart to 0 . 3 million, and for testing, 1 million. We also used a more permissive training supertagger beam (Table 3) than in previous work (Clark and Curran, 2007). Models were trained with the parser X  X  L-BFGS trainer.
 Evaluation. We evaluated on CCGbank (Hocken-maier and Steedman, 2007), a right-most normal-form CCG version of the Penn Treebank. We use sections 02-21 (39603 sentences) for training, section 00 (1913 sentences) for development and section 23 (2407 sentences) for testing. We sup-ply gold-standard part-of-speech tags to the parsers. Evaluation is based on labelled and unlabelled pred-icate argument structure recovery and supertag ac-curacy. We only evaluate on sentences for which an analysis was returned; the coverage for all parsers is 99.22% on section 00, and 99.63% on section 23. Model combination. We combine the parser and the supertagger over the search space defined by the set of supertags within the supertagger beam (see Ta-ble 1); this avoids having to perform inference over the prohibitively large set of parses spanned by all supertags. Hence at each beam setting, the model operates over the same search space as the baseline; the difference is that we search with our integrated model. 5.1 Parsing Accuracy We first experiment with the separately trained su-pertagger and parser, which are then combined us-ing belief propagation (BP) and dual decomposition (DD). We run the algorithms for many iterations, and irrespective of convergence, for BP we compute the minimum risk parse from the current marginals, and for DD we choose the highest-scoring parse seen over all iterations. We measured the evolving accuracy of the models on the development set (Fig-ure 4). In line with our oracle experiment, these re-sults demonstrate that we can coax more accurate parses from the larger search space provided by the reverse setting; the influence of the supertagger fea-tures allow us to exploit this advantage.
 One behavior we observe in the graph is that the DD results tend to incrementally improve in accu-racy while the BP results quickly stabilize, mirroring the result of Smith and Eisner (2008). This occurs because DD continues to find higher scoring parses at each iteration, and hence the results change. How-ever for BP, even if the marginals have not con-verged, the minimum risk solution turns out to be fairly stable across successive iterations.

We next compare the algorithms against the base-line on our test set (Table 4). We find that the early stability of BP X  X  performance generalises to the test set as does DD X  X  improvement over several itera-tions. More importantly, we find that the applying C&amp;C  X 07 87.24 93.00 94.16 ---87.64 93.00 94.32 ---our combined model using either algorithm consis-tently outperforms the baseline after only a few iter-ations. Overall, we improve the labelled F-measure by almost 1.1% and unlabelled F-measure by 0.6% over the baseline. To the best of our knowledge, the results obtained with BP and DD are the best reported results on this task using gold POS tags.
Next, we evaluate performance when using au-tomatic part-of-speech tags as input to our parser and supertagger (Table 5). This enables us to com-pare against the results of Fowler and Penn (2010), who trained the Petrov parser (Petrov et al., 2006) on CCGbank. We outperform them on all criteria. Hence our combined model represents the best CCG parsing results under any setting.

Finally, we revisit the oracle experiment of  X  3 us-ing our combined models (Figure 5). Both show an improved relationship between model score and F-measure. 5.2 Algorithmic Convergence Figure 4 shows that parse accuracy converges af-ter a few iterations. Do the algorithms converge? BP converges when the marginals do not change be-tween iterations, and DD converges when both sub-models agree on all supertags. We measured the convergence of each algorithm under these criteria over 1000 iterations (Figure 6). DD converges much faster, while BP in the reverse condition converges quite slowly. This is interesting when contrasted with its behavior on parse accuracy X  X ts rate of con-vergence after one iteration is 1.5%, but its accu-racy is already the highest at this point. Over the entire 1000 iterations, most sentences converge: all but 3 for BP (both in AST and reverse) and all but . 41 (2.6%) for DD in reverse (6 in AST). 5.3 Parsing Speed Because the C&amp;C parser with AST is very fast, we wondered about the effect on speed for our model. We measured the runtime of the algorithms under the condition that we stopped at a particular iteration (Table 6). Although our models improve substan-tially over C&amp;C, there is a significant cost in speed for the best result. 5.4 Training the Integrated Model In the experiments reported so far, the parsing and supertagging models were trained separately, and only combined at test time. Although the outcome of these experiments was successful, we wondered if we could obtain further improvements by training the model parameters together.

Since the gradients produced by (loopy) BP are approximate, for these experiments we used a stochastic gradient descent (SGD) trainer (Bottou, 2003). We found that the SGD parameters described by Finkel et al. (2008) worked equally well for our models, and, on the baseline, produced similar re-sults to L-BFGS. Curiously, however, we found that the combined model does not perform as well when Baseline 65.8 87.38 5.9 87.36 BP k =1 60.8 87.70 5.8 88.35 BP k =5 46.7 87.70 4.7 88.34 BP k =25 35.3 87.70 3.5 88.33 DD k =1 64.6 87.40 5.9 87.38 DD k =5 41.9 87.65 3.1 88.09 DD k =25 32.5 87.71 1.9 88.29 Baseline 86.7 92.7 94.0 86.7 92.7 93.9 BP inf 86.8 92.8 94.1 87.2 93.1 94.2 BP train 86.3 92.5 93.8 85.6 92.1 93.2 the parameters are trained together (Table 7). A pos-sible reason for this is that we used a stricter su-pertagger beam setting during training (Clark and Curran, 2007) to make training on a single machine practical. This leads to lower performance, particu-larly in the Reverse condition. Training a model us-ing DD would require a different optimization algo-rithm based on Viterbi results (e.g. the perceptron) which we will pursue in future work. Our approach of combining models to avoid the pipeline problem (Felzenszwalb and McAllester, 2007) is very much in line with much recent work in NLP. Such diverse topics as machine transla-tion (Dyer et al., 2008; Dyer and Resnik, 2010; Mi et al., 2008), part-of-speech tagging (Jiang et al., 2008), named entity recognition (Finkel and Manning, 2009) semantic role labelling (Sutton and McCallum, 2005; Finkel et al., 2006), and oth-ers have also been improved by combined models. Our empirical comparison of BP and DD also com-plements the theoretically-oriented comparison of marginal-and margin-based variational approxima-tions for parsing described by Martins et al. (2010).
We have shown that the aggressive pruning used in adaptive supertagging significantly harms the or-acle performance of the parser, though it mostly prunes bad parses. Based on these findings, we com-bined parser and supertagger features into a single model. Using belief propagation and dual decom-position, we obtained more principled X  X nd more accurate X  X pproximations than a pipeline. Mod-els combined using belief propagation achieve very good performance immediately, despite an initial convergence rate just over 1%, while dual decompo-sition produces comparable results after several iter-ations, and algorithmically converges more quickly. Our best result of 88.8% represents the state-of-the art in CCG parsing accuracy.

In future work we plan to integrate the POS tag-ger, which is crucial to parsing accuracy (Clark and Curran, 2004b). We also plan to revisit the idea of combined training. Though we have focused on CCG in this work we expect these methods to be equally useful for other linguistically motivated but computationally complex formalisms such as lexi-calized tree adjoining grammar.
 We would like to thank Phil Blunsom, Prachya Boonkwan, Christos Christodoulopoulos, Stephen Clark, Michael Collins, Chris Dyer, Timothy Fowler, Mark Granroth-Wilding, Philipp Koehn, Terry Koo, Tom Kwiatkowski, Andr  X  e Martins, Matt Post, David Smith, David Sontag, Mark Steed-man, and Charles Sutton for helpful discussion re-lated to this work and comments on previous drafts, and the anonymous reviewers for helpful comments. We also acknowledge funding from EPSRC grant EP/P504171/1 (Auli); the EuroMatrixPlus project funded by the European Commission, 7th Frame-work Programme (Lopez); and the resources pro-vided by the Edinburgh Compute and Data Fa-cility ( http://www.ecdf.ed.ac.uk ). The ECDF is partially supported by the eDIKT initiative ( http://www.edikt.org.uk ).

