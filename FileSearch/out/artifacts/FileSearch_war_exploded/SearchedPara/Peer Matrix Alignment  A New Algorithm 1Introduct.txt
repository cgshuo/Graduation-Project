 Deep web presents a huge amount of useful information which is usually formatted for its users. So, extracting relevant data from various sources to be used in web ap-plications becomes not easy. Therefore, the availability of robust, flexible Information Extraction (IE) or Wrapper Induction (WI) systems that transform Web pages into program-friendly structures such as a relational database will become a great necessi-ty. For relevant data extraction, unsupervised IE systems exploit the fact that web pages of the same Web site share the same template since they are encoded in a con-template by plugging data values. Finding such a common template requires as input multiple pages (page-wide IE systems; e.g., RoadRunner [1], EXALG [2], and FiVa-Tech [3]) or a single page containing multiple records (record-wide IE systems; e.g., IEPAD [4], DeLa [5], and DEPTA [6]). 
A crucial step for most web data extraction systems (record/page level systems) is alignment: either string alignment (e.g., IEPAD and RoadRunner) or tree alignment (e.g., DEPTA). Alignment of attribute values in multiple data objects (strings/trees) is a challenging task as these attributes are subject to the following variations [7]:  X 
An attribute may have zero or more values in a data-object. If the attribute has zero multi-valued attribute. A book X  X  author may be an example of multi-valued attribute, whereas a special offer is an example of missing attribute.  X 
The set of attributes ( A 1 , A 2 , ..., A k ) may have multiple ordering, i.e., an attribute A i may have variant positions in different instances of a data-object. We call this attribute a multi-ordering attribute. For example, a movie site might list the release date before the title for movies prior to 1999, but after the title for recent movies.  X 
An attribute may have variant formats along with different instances of a data ob-generalize all cases. For example, an e-commerce site might list prices in bold face, except for sale prices which are in red. So, price would be an example of a variant-format (disjunctive) attribute in this site. On the other hand, different attributes in a data-object may have the same format, especially in table presentation, where sin-gle &lt;TD&gt; tags are used to present various attributes.  X 
Most IE systems handle input documents as strings of tokens as they are easier to process than strings of characters. Depending on the used tokenization methods, sometimes an attribute cannot be decomposed into individual tokens. Such an attribute is called an untokenized attribute. Untokenized attributes can be processed by further processing after the alignment step, while missing, multi-valued, multi-ordering, and disjunctive attributes are han-dled during the alignment step. The effectiveness of an alignment algorithm relies on its capability to handle such problems. In this paper, we suggest a new alignment algorithm to be used as a part of web data extraction systems. Our algorithm considers the above four mentioned problems. Also, to align multiple data objects, our algo-rithm processes all objects at the same time . Our algorithm doesn X  X  consider the prob-lem of multiple-objects alignment as a generalization of 2-objects alignment. So, it has a global (better) view for the input objects (strings/trees). 
The rest of the paper is organized as follows. Section 2 defines the peer matrix alignment problem. Our proposed alignment algorithm and different examples that we suggest to clarify the algorithm are discussed in sections 3 and 4, respectively. Section 5 describes our experiments. The related works are presented in Section 6. Finally, section 7 concludes our work. String alignment is simpler than tree alignment. Since web pages used with IE sys-tems are tree structured (DOM trees), tree alignment will become a great necessity. Like FiVaTech, our algorithm considers the tr ee structure of the objects to be aligned, but we simplify the problem by converting it into string alignment as follows. We consider all of the objects (web pages) to be aligned are tree structured and have the where each column keeps the child nodes for one root node p . Every node in the matrix takes a symbol which actually denotes a subtree. All similar subtrees (peer nodes) are denoted by the same symbol. Similarity here can be measured by any suit-able technique such as tree-edit distance. The peer matrix shown in Fig. 1b is con-structed from the three trees of root p in Fig. 1a. The matrix has three columns; each one includes all child nodes of one root p , where two similar nodes take the same symbol. Now, the problem is transformed into multiple-string (peer matrix) align-ment, where each string corresponds to one column in the matrix. Handling of the problems: missing, multi-valued, multi-ordering, and disjunctive attributes is based on this very important alignment step. The output of this step is an aligned list in which missing, repetitive, disjunctive, and multi-ordering patterns can be identified very easily. For example, as shown in Fig. 1d, the output aligned list has one repetitive pattern (BCD), where the two symbols B and D are optional (missing attributes) in this pattern. Definition (Aligned Row): A row in the peer matrix is called an aligned row in two cases. The first case is occurred when all symbols in this row are the same (or disap-pear in some columns of the row). The second case is occurred when the row has that each symbol appears only in its residing column (i.e., if a symbol exists in a col-umn c, then all other columns outside the current row in the matrix do not contain this symbol). All of the rows above an aligned row must be also aligned. Definition (Aligned Peer Matrix): A peer matrix is aligned if all of the rows in the matrix are aligned. Fig. 1c is an example of an aligned peer matrix. As shown in the aligned peer matrix, the symbol  X - X  refers to a null value which has been added after shifting some symbols down to patch an empty space. Definition (Aligned List): If M is an aligned peer matrix, so each aligned row in the matrix M is represented by a symbol which is either the same as the symbol in the correspond to leaf nodes). Fig. 1d is the aligned list corresponds to the one in Fig. 1c. Definition (Peer Matrix Alignment Problem): Given a peer matrix as input, the alignment problem is to modify the content of the matrix by shifting down, swapping, or replacing symbols in the matrix to transform it into an aligned peer matrix. Given a peer matrix as input, we start the matrix row by row (up-down fashion) and align each row using its contents and the conten ts of the other rows below it, to get an aligned peer matrix. Each row r is aligned by processing of zigzag lines that have been drawn to connect among the symbols in r and other symbols down r in the ma-trix. Zigzag lines are drawn as follows. For each symbol s in r , we draw a sequence of each column of the current row r or the rows below r . The zigzag line L s of the sym-connected by a line with the first occurrence in the right/left hand side column. If the symbol does not appear in the right/left column, the line will pass to connect the first occurrence in the next column, and so on. All occurrences of s in the row r belong to the same zigzag L s . If the symbol does not appear again in the row or below the row, we call it a non-zigzag symbol . This means, a non-zigzag symbol is not belonging to any zigzag line in the row. Fig. 2 shows two zigzag lines L A and L B at the first row. By process these zigzags to align the row r . Although, zigzag lines are different for dif-ferent columns order in the matrix, our algorithm solves the problem in general and covers all suitable cases. Before we go further in this section to discuss our proposed alignment algorithm, we give some definitions that are important to the algorithm. 
Let l is a line in a zigzag L s that connects two occurrences of s at the two locations ( r matrix if it is started at the first column an d terminated at the last column of the ma-trix. The vertical spans of the three lines of L A in Fig 2 are 3, 3, and 2, respectively. Also, the two zigzag lines L A and L B in Fig 2 horizontally cover the peer matrix. Definition (A Repetitive Pattern): A pattern P (a sequence of one or more consecu-some column of the matrix. If P appears at most once in each column of the matrix, we call it a free (non-repetitive) pattern. Definition (Symbol Span): The span of a symbol s is defined as the maximum num-ber of different symbols (without repetition) between any two consecutive occur-rences of s in each column plus one; i.e., span of s represents the maximum possible example, the span of the symbol B in the matrix in Fig. 2 is 3 (there are two different symbols, C and A, between the two occurrences in the second column). In our proposed algorithm, we use the calculated span value for a symbol s to control (restrict) the process of shifting down s in the matrix. Shifting down the symbol s must not violate the calculated symbol span value. This means, if s occurred only once in a column, it can be shifted down to anywhere in the column. But, the symbol s which is occurred at row r and column c cannot be shifted down if it appears up in c row and the second column of the matrix in Fig. 2 cannot be shifted down because its span is 3 and it appears up at the first row of the column. lines are equal, and it horizontally covers the matrix. Otherwise it is called irregular . Fig 2 shows examples of regular and irregular zigzag lines L B and L A , respectively. maximum number of lines a top horizontal zigzag. ( r , c 1 )) in a zigzag L b and l 1 a left-most cross if the vertical distance between r 2 and r ( m 2 = r 2 -r ) is a minimum. As shown in Fig. 3(a), the cross makes four patterns in the peer matrix: P 2 and P 3 are the two patterns of lengths m 1 under the two ending points of l 2 , while P 1 and P 4 are the two patterns of lengths m 2 under l 1 . To align the row r which has a left-most cross as in Fig.3 (a), we have three possible tional (missing pattern in c 2 or c 1 , respectively, as shown in Figures 3(c) and (d)). The second case, case II, is occurred when the two patterns P 1 ( P 3 ) and P 2 ( P 4 ) are multi-case, case III, is occurred when the two patterns P 1 and P 3 have disjunctive attributes (i.e., same data presented in different formats). Our algorithm works as follows to distinguish between these three cases I-III. shift down either P 1 or P 3 based on some criteria as we will discuss later. (but not sufficient) that P 1 ( P 3 ) is repetitive in the matrix, respectively. So, if both P 1 when either P 1 or P 3 is repetitive. Experimentally, we have observed that case I (either P or P 3 is optional) is mostly the correct al ignment choice. An exception is occurred when P 1 and P 3 have disjunctive patterns (the row is aligned using case III). 
Figure 4 shows an example of case III (disjunctive attributes) when a search engine page is presented using &lt;STRONG&gt; tag (i.e., the two tags &lt;A&gt; and &lt;STRONG&gt; are disjunctive). So, the two cases I and III are possible when either P 1 or P 3 is repetitive. We handle this problem and decide the correct alignment case based on the following assumption. The two patterns a 1 and a 2 are disjunctive, if one of the two patterns (say a ) appears randomly among different consecutive occurrences of the other one ( a 2 ) in each column of the matrix. So, we assume that, there is a left-most cross in two col-umns c 1 and c 2 such that one of the two patterns P 1 or P 3 is a sequence of the repeti-tive pattern a 2 , while the other one is a 1 . If so, we replace all occurrences (in the ma-a (&lt;STRONG&gt;) and a 2 (&lt;A&gt;) as disjunctive patterns. Our proposed algorithm which handles all of these cases and others to align the row r is shown in Fig. 5. 
As shown in Fig. 5, to align the row r in M , the algorithm recursively tries to align r and stops at three base cases: first (lines 2-3), when r is an aligned row as defined 11) when r has a top-horizontal zigzag. In the first case, the algorithm returns a sym-bol s when r has either a horizontal zigzag L s or a non-zigzag symbol s . But, if r has leaf nodes (img/text), the algorithm returns  X * X . In the second case, the algorithm function returns true if both of the following two conditions are satisfied:  X  bol s i is either a non-zigzag symbol or belonging to a horizontal zigzag line.  X 
For each different symbol s i in r , there is a zigzag line L s that connects among dif-ferent occurrences of some symbol s below s i . the second condition gives a guarantee that there exists a zigzag which prevents any of these symbols to be shifted down. The third stop case is occurred when the row r has a combination of horizontal zigzag line s (one of them is a top-horizontal), non-zigzag symbols, and other regular/irregular zigzag lines. If so, the algorithm only keeps the top-horizontal zigzag in the row r and considers all others as missing attributes. Therefore, it shifts all non-zigzag symbols (line 8) and all horizontal zigzag lines (line 9) down a distance 1, and stretches all remaining regular/irregular zigzag lines (line 10) using the function stretchZigzag( L s ). The function stretchZigzag works the matrix M and patch empty spaces with a null value. If L s is irregular (i.e., L s con-the function shifts each occurrence of s at each row r i above r  X  downward a distance  X  X   X ,...,  X   X  satisfies that r  X  -r is min( r
When the row has one regular/irregular zigzag line, the algorithm identifies it as missing attribute (lines 12-14) and uses the function stretchZigzag to stretch it. Final-cussed above. The function selectAZigzag( L a , L b , r , M ) returns one of the two zigzag First, a zigzag that has a line of non-zero minimum vertical span is returned. Second, returned. Third, the algorithm returns the right-most one. 
For an  X  X  X  matrix M, the running time to draw zigzag lines for each row is  X  X  X  X  X  X  X  . Also, the running time to check whether some pattern is repetitive or not is  X  X  X  X  X  X  X  . As a preprocessing step, for each row, the running time for calculating symbols scan values is  X  X  X  X  X  X  X  . Therefore, the running time for each call of the recursive algorithm to align a row r in the matrix M is  X  X  X   X   X  X   X   X  . Experimentally, a row is aligned after 2-3 calls. The two matrices in Fig. 6 give two examples of disjunctive attributes. To align the first row of the matrix in Fig. 6(a), the row has one horizontal zigzag L A and one non-has occurrences of C below A and F. So, the algorithm identifies A and F as disjunc-row has two horizontal zigzag lines L A and L F , and at the same time there is a zigzag L which has occurrences of C below both A an d F. So, our algorithm also identifies A and F as two disjunctive attributes, and then returns s =A||F. 
Fig. 7 gives two examples of a top horizontal zigzag (case ii in Fig. 5). To align the first row of the first matrix (Fig. 7(a)), the row has two horizontal zigzag lines L A (the top one because it has the maximum number of lines: 2) and L F . However, there is no zigzag lines that have occurrences below A and F at the same time (i.e., A and F are row in the matrix. For the matrix in Fig. 7(b), the first row has one horizontal zigzag L (the top one) and one regular zigzag L B . So, the regular zigzag L B is stretched at the second row (i.e., all occurrences of B in the first row will be shifted down a distance 1 and patch empty spaces with a null value). 
Fig. 8 gives three examples when the row has only one non-horizontal regular zig-zag (case iii). To align the third (second) row of the matrix in Fig. 8(a) (Fig.8(b)), the algorithm (line 13 in Fig. 5) stretches down L A ( L C ) at the fourth (third) row, respec-tively. Fig. 8(c) gives an example when the row has only one irregular zigzag ( L C ). To align this row, L C is stretched down (line 13 in Fig. 5) at the third row. combination of regular and irregular zigzag lines that form one or more crosses. The shown in Fig. 3(a). Fig. 9 (a) presents an example of missing attributes when either P P quence of some repetitive pattern a 2 . In the two examples, the function selectAZigzag in Fig. 5 is used to select one of the two zigzag lines (that make a left-most cross) to be stretched down. For the first matrix in Fig. 9, the function selects L C to be stretched at the third row because it has a line of the minimum vertical span (2). Also, it selects L to be stretched down for the same reason in the second matrix. Fig. 10 discusses the case of multiple-order attributes, where P 1 = P 4 = X  X BC X  and P = P 3 = X  X GH X , but both of the two patterns P 1 and P 3 are non-repetitive. So, to align the first row of the matrix, our algorithm exchanges the two patterns P 2 and P 3 in the third column because they ar e multiple-ordering patterns. We shall not give here any example of case III, because we already presented one in the previous section. We measure the performance of the proposed algorithm by collecting 300 peer ma-trices taken from a data set of 10 web sites (selected from the manually labeled Testbed for Information Extraction from Deep Web TBDW [8] Version 1.02) as follows. For each web site, we randomly select 30 matrices: 10 matrices from top matrices from the whole DOM tree. The performance of the algorithm is measured by calculating recall and precision for each selected matrix as follows. Precision is the proportion of symbols predicted by the algorithm as missing, disjunctive, or mul-tiple-ordering that are targets (correctly identified). Recall is the proportion of miss-ing, disjunctive, or multiple-ordering symbols that are predicted by the algorithm. The ( F number of missing, disjunctive, or multiple-ordering symbols that are correctly identi-symbols that cannot be identified by the algorithm. F p is the number of missing, dis-junctive, or multiple-ordering symbols that are incorrectly identified by the algorithm. Finally, T n is the number of symbols that are correctly not identified by the algorithm as missing, disjunctive, or multiple-ordering. Formally, we define recall and precision as follows: The performance of the algorithm with the 30 web sites is shown in Table 1. For each web site, the average of the calculated recall and precision for the selected 10 matrices constructed closed to the root (closed to the leaves and from the whole DOM tree) is shown in column 2-3 (4-5 and 6-7, respectively). As shown in the table, the algorithm performs perfectly with matrices near to the root of a DOM tree (columns 2-3), and gives a good result near to leaves (columns 4-5) as the matrices near to the leaves are complicated and contain many missing, disjunctive, and multi-ordering symbols. The perfect results for the matrices near to the root was not a surprise because many for the whole DOM tree (columns 6-7). Allnealthnet 1.00 1.00 0.95 0.92 0.99 0.95 G. Unlimited 1.00 1.00 1.00 0.99 1.00 0.97 IUMA 1.00 1.00 0.93 0.92 0.95 0.92 Picsearch 1.00 1.00 1.00 1.00 1.00 1.00 
Sun-Sentinel 1.00 1.00 0.98 0.96 1.00 0.97 amazon.co.uk 1.00 1.00 0.91 0.90 0.91 0.91 Amazon 1.00 1.00 0.99 0.95 0.98 0.96 Gene surname 1.00 1.00 0.95 0.95 0.95 0.97 HomePopular 1.00 1.00 0.99 0.97 1.00 0.98 NAMI 1.00 1.00 0.97 0.96 0.98 0.97 IEPAD [4] and OLERA [9] generalize extraction patterns from unlabeled Web pages. Repetitive patterns in IEPAD are discovered using the binary suffix tree PAT tree. PAT trees compute only exact match patterns, templates with exceptions cannot be discovered through PAT trees. Patterns with inexact or approximate matching are discovered using multiple string alignment technique. IEPAD applies center star algo-rithm to align multiple strings. In OLERA [9], user marks a record to be extracted to discover other similar records and generalize them using multiple string alignment. OLERA handles the problem in IEPAD when several alignments exist by proposing a matching function to compare the primitive data for text tokens. 
RoadRunner [1] considers the site generatio n process as encoding of the original database content into strings of HTML code. The system uses the ACME matching (alignment) technique to compare HTML pages of the same class and generate a wrapper based on their similarities and differences. 
DEPTA [6] discovers repetitive patterns by comparing adjacent substrings with starting tags having the same parent in the HTML tag tree. The recognition of data items or attributes in a r ecord is accomplished by partial tree alignment. The algo-rithm first chooses the record tree with the largest number of data items as center and then matches other record trees to the center tree. ViPER [10] assumes that repetitive patterns have variant lengths rather than they are of fixed length as in Depta. ViPER applies a tandem repeats algorithm before computing the edit-distance to handle miss-ing and multiple values data. It applies a data alignment technique that is based on global matching and text content information. The alignment method uses a divide-and-conquer fashion to reduce the multiple-alignment problem. 
Finally, FiVaTech [3] conducts four steps: peer node recognition, matrix align-ment, pattern mining, and optional node detection in turn. In the matrix alignment step, the system handles the two problems of disjunctive and multiple-ordering attributes as a case of missing attributes. In this paper, we proposed a new algorithm for multiple string (peer matrix) align-ment. Our algorithm looked at all of the multiple strings at the same time, so it has a global view for the inputted strings. Also, our algorithm considered the common problems in the field of web data extraction: missing, multi-valued, multi-order, and disjunctive attributes. To align a row in the peer matrix, our algorithm drew some lines to accomplish the task. 
