 Graphs can represent a large number of data types, e.g., online social networks, internet links, procedure dependency graphs, etc. The need for indexing massive graphs is an urgent research problem of great practical importance. The main challenge is the size. Each graph may contain at least tens of millions vertices. The working memory may not be able to store the database graph due to its large size, which increases the processing time significantly.
We propose a novel index based subgraph matching scheme, namely SUMMA, for graph querying in massive graphs. We devise two novel indices which capture both local and global information of the database graph. SUMMA is further optimized by the use of a matching scheme to reduce redundant calculations and disk ac-cesses. Last but not least, a number of synthetic datasets are used to evaluate the efficiency and scalability of our proposed method. H.3 [ INFORMATION STORAGE AND RETRIEVAL ]: Mis-cellaneous Theory Graph Querying
Graphs can represent a large number of data types, e.g., online social networks, procedure dependency graphs, and protein inter-action networks. These modeled graphs may consist of millions or even billions of vertices.

Finding distinct occurrences of an arbitrary small pattern is a fundamentally critical step in revealing insights into these growing networks.
We want to solve the following problem for the necessity of real life research X  X ow to match a pattern in a massive graph with a reasonable number of disk reads and memory consumption? Since the complexity of the subgraph matching algorithm grows linearly with the number of graphs, but exponentially with the average size of a graph, the solution to our problem setting is easy to extend to the problem of multiple database graphs.

We introduce our index-based method, SUMMA, for su bgraph m atching in ma ssive graphs. SUMMA consists of a twofold in-dex which captures both local and global information of a database graph. We select infrequent label combination as the local index. For the global index, we intend to use it to capture the relationships among vertices, which requires | V | 2 space to store without opti-mizations. To reduce the space usage, we use a set of shortest path trees to approximate the distances. The size of either local or global index is linear to the size of the database graph.

In addition to the index construction, we propose an innovative matching algorithm for the querying process. We use the global in-dex to estimate distance between vertices. The convenience of em-ploying distances as index structures accelerates the pruning pro-cess.

To the best of our knowledge, SUMMA is one of the first algo-rithms to tackle the subgraph matching problem when the database graph cannot be fit in the working memory. The main contributions of this paper are as follows. 1. We propose SUMMA X  X n index based graph matching al-2. By applying SUMMA to experiments, we show its effec-
The remainder of this paper is organized as follows. Section 2 defines the preliminary concepts. Sections 3 and 4 describe our indexing mechanism and the matching algorithm. Experimental results are presented in Section 5 and Section 6 concludes the paper.
D EFINITION 1. A labeled graph G =( V,E,  X  V ,  X  E ,l ) is iso-morphic to another graph G = { V ,E ,  X  V ,  X  E ,l } , denoted by G  X  G , if and only if there exists a bijection f : V  X  V s.t. (1)  X  u  X  V , l ( u )= l ( f ( u )) ,(2)  X  u,v  X  V , ( u,v ) S is subgraph isomorphic to G , denoted as S  X  G ,if S is iso-morphic to at least one subgraph G of G . G is a match of S in G .
 D EFINITION 2. Given vertices v a and v b in a connected graph G , we define the shortest distance between v a and v b as d ( G,v a ,v b ) , as the number of edges on the shortest path be-tween v a and v b .The shortest path tree of G and v , denoted as SPT ( G,v ) , is a subtree of G constructed so that the distance be-tween vertex v and all other vertices in G is minimal.
 Problem Statement: Given a large database graph G (stored as ad-jacency list on disk without any random access) and a query graph Q , we aim to construct index structures and find all matches of Q in G efficiently.

We try to construct algorithms whose space requirement is com-patible with the semi-streaming model of computation [2]. Our al-gorithm uses an amount of main memory in the order of the num-berofvertices( | V | ), whereas the amount of memory in the order of the number of edges may not be feasible. We assume that we have O ( | V | lg | V | ) bits of main (random access) memory, i.e., in general there is enough memory to store some limited amount of data as the index structure to assist the matching process, but not to store the links of the graph in main memory. A pass is defined as reading the whole database graph file from disk once. The algo-rithm should perform as small a number of passes over the graph data stored on the secondary storage as possible.
In this section, we construct two indices, local and global indices, that will accelerate the query processing.
For any vertex v ,wedefinea vertex combination of length k at v as a subset of k vertices of v  X  X  neighbors, i.e., the adjacent set of v . A length k label combination is a list of k vertex labels, sorted by their lexicographic order. The sorted vertex labels of a vertex combination vc is the corresponding label combination of vc .The set of vertices whose adjacent sets contain the vertex combinations of lc is called the center set of lc .

For example, in figure 1, the three shaded vertices form a length-three vertex combination at the vertex with dashed line. The cor-responding label combination is  X 1, 2, 3 X . The vertex with dashed line is in the center set of label combination  X 1, 2, 3 X .
In this paper, label combinations of length three as selected as our local index because (1) label combinations, also a special form of subtrees, widely occur in most graphs, (2) the frequency of a label combination can be clearly and efficiently defined by the ver-tices it involves, (3) any occurrence location of a label combination can be effectively defined by a single vertex, and (4) as long as the database graph is not a single path, it will have some label combi-nations of length three.

We select infrequent over frequent label combinations because (1) the information gain of infrequent label combinations outweighs that of frequent label combinations, and (2) when storing the same number of label combinations, infrequent label combinations use much less space than frequent ones. In the case when the query graph contains one indexed infrequent label combination, the match-ing process will be improved with the quickstart provided by the lo-cal index; otherwise, we would perform an additional pass to find a database graph vertex which is a candidate match of a query graph vertex.
Recently, a distance index based graph matching method, GADDI [6] is proposed, showing that distance between neighboring ver-tices is a useful index structure for graph matching. However, the index structure of GADDI cannot be applied here because its space complexity, O ( | V | 2 ) in the worst case. It is too high for massive database graphs. In [4], Samet et al. proposed a scalable algorithm for computing distance in networks. Since its space complexity is O ( N 1 . 5 ) , we cannot apply this algorithm either.

We use shortest path trees as our global index because (1) this index can provide global distance information for future matching, (2) the size of the index is linear to the vertex size and therefore easy to control, and (3) the index can be built in a limited number of passes.

We select a set of the shortest path trees of induced subgraphs of the database graph as our global index unit, and use this global index to prune vertices in the database graph which are unlikely to appear in the matches of the query graph. We require that (1) each vertex of the database graph occur in at least one such shortest path tree, (2) the sum of edges of the shortest path trees be linear to the number of vertices in the database graph, and (3) the index construction algorithm finish in a limited number of passes.
We randomly select K vertices v 1 ,v 2 ,...v K as root vertices, and apply a breadth first approach to construct the shortest path trees. In the first pass, we only deal with the adjacency edge lists of v 1 ,v 2 ,...v K . For each vertex w adjacent to v i , edge e added to the shortest path tree rooted at v i . The shortest path tree rooted at v i is denoted as SPT ( v i ) . In the next pass, we pro-cess the adjacency edge lists of those vertices that have been newly added to the shortest path trees. For an edge e uw , w newly added, u is assigned to the growing shortest path tree that w belongs to. We repeat this procedure until either all the database graph vertices are contained by the shortest path trees or the procedure has been repeated | V | /K times.

During the construction, a shortest path tree rooted at v reach a vertex that is already in another tree. If the intersection of any two growing trees can be arbitrarily large, the total space requirement of the global index unit might be uncontrollable. Thus, we require that growing shortest path trees in the same global index unit be disjoint with each other.

To fulfill this requirement, we adopt a greedy strategy. In pass N , after we extend one hop from the shortest path trees, we construct agraph G r which represents the relationships among the shortest path trees. In G r , each shortest path tree is a node; if two shortest path trees share at least one vertex of the database graph, an edge is added between the nodes that the shortest path trees represent in G .

Finding the maximum set of disjoint shortest path trees is equal to finding the maximum independent set of G r . Therefore, we use a greedy algorithm to find a maximal independent set S r of G For each shortest path tree SPT ( v i ) , if the nodes in SPT ( v contained by S r ,wekeepgrowing SPT ( v i ) . Otherwise, we either discard or shrink SPT ( v i ) .

Let us suppose that vertex v is the closest vertex to v i intersection of SPT ( v i ) and another shortest path tree contained by the maximal independent set S r . If the distance of v and v is larger than | V | /K  X  N , which indicates that the vertices in SPT ( v i ) may not be reached by any other shortest path tree, then we remove all vertices farther than v from SPT ( v i ) and shrink SPT ( v i ) by one hop per pass from the next pass. Otherwise, if the distance of v and v i is smaller than | V | /K  X  N , which indicates that most of the vertices are likely to be reached by the remaining shortest path trees, we simply remove SPT ( v i ) from the set of shortest path trees. In this section, we introduce the subgraph matching algorithm. We start with matching a subset of vertices by the local index, and then we use the global index to find candidate subgraphs of the database graph which can be stored in the working memory. Last, we use a subgraph isomorphism test based verification algorithm to find the exact matches.
In this step, we apply the information in the local index and try to fix a subset of vertices of the query graph Q in the database graph G . First, for the adjacent set of each vertex in the query graph, we enumerate its three-vertex combinations. If the corresponding label combination lc of any vertex combination vc is indexed, we check the vertex v in the query graph whose adjacent set contains vc as well as the center set of the indexed label combination lc .Asthe labels combinations is stored as inverted index, the center set of lc can be retrieved very efficiently.

For each vertex v in the center set of lc , we check whether v has the same vertex label and whether the degree of v is larger than or equal to that of v . If both requirements are satisfied, then v is a candidate matching vertex of v and v has a candidate match.
In the query graph, if there is only one vertex with candidate matches, we use this vertex as the starting vertex of our matching process. If more than one vertex has candidate matches, then we will select the vertex v whose maximum distance to other query graph vertices is minimum, i.e., the eccentricity of v in the query graph is the least among all vertices with candidate matches.
After mapping a vertex v s in the query graph Q to a set of ver-tices ( Mapped ( v s )= { v 1 ,...,v n } ) in the database graph G ,we will use the global index to search for a set of bounded graphs each of which can be stored in the working memory.
For any two vertices in the database graph, we need to estimate the distance between the two vertices without reading the whole database graph. This can be done with the help of global index.
In the global index, we store a set of shortest path trees. In order to estimate the distance between two vertices, v 1 and v 2 four cases in general: 1. v 1 and v 2 belong to the same indexed shortest path tree T 2. v 1 belongs to an indexed shortest path tree T 1 and v 3. v 1 belongs to an indexed shortest path tree T 1 and v 4. Neither v 1 nor v 2 belongs to any indexed shortest path tree.
In the first three cases, an upper bound can be estimated between the two vertices. In the last case, we will have to perform additional passes to estimate the distance between v 1 and v 2 .
In the beginning of algorithm, we create an inverted index for the query graph vertices by their vertex labels. Then, we can quickly find the query graph vertices with any given vertex label.
The search for the bounded graphs works as follows. Select-ing a center vertex of the query graph v s , for each vertex v Mapped ( v s ) , we create a bounded graph that starts as a single vertex v i . For each vertex v t in G , we search the query graph for a vertex v , whose adjacent set is a subset of that of v t . Moreover, the estimated distance between v t and v i in the database graph ( d ( G,v t ,v i ) ) should not be larger than the real distance between v and v s in the query graph ( d ( Q,v,v s ) ). If such vertex v in the query graph exists, then we will add v t to the bounded graph. In this case, v is a candidate matching vertex of query graph vertex v and v t is a candidate matching vertex of bounded graph vertex v . The procedure ends when all the database graph vertices has been checked.
Having obtained a bounded graph which can be stored in the working memory, we test whether it is a supergraph of the query graph by a regular subgraph isomorphism test. Since we have al-ready fixed a small set of candidate matching vertices in the bounded graph for each query graph vertex, the process for testing whether the query graph is subgraph isomorphic to the bounded graph is efficient compared to that without any preprocessing. In this section, we empirically analyze the performance of SUMMA. We compare our algorithm against GADDI [6] on synthetic datasets, generated by the PA model [3]. All experiments are performed on a Dell PowerEdge 2950, with two 3.0 GHZ dual-core CPUs and 16 GB main memory, using Linux 2.6.16.21-0.8-smp.

The first parameter is the size of G . We test SUMMA and GADDI on graphs ranging in size from 10K to 10M vertices. GADDI performs better than SUMMA when the database graph is small, as GADDI indexes more structural information and GADDI does keep the database graph in the memory, but fails to construct the in-dex structure when the graph reaches 1 M vertices, which indicates the necessity of a graph matching algorithm for very large graphs. Figure 2(a), and 2(b) show the index construction time and index size of SUMMA and GADDI. Figure 2(c) shows the query time of both methods for query graphs which are induced subgraphs of G , and figure 2(d) shows that for query graphs which are randomly generated from PA model. (a) Index Construction Time (b) Index Size
The second parameter we vary is the average degree of a vertex in G . Figure 3 (a) and (b) show the index construction time and size for SUMMA and GADDI. GADDI cannot finish when the degree increases to 20 while the index size of SUMMA remains stable. Figure 3 (c) and (d) show the query time of both methods for two types of query graphs. The query time of SUMMA increases with the average vertex degree of G since the bounded graph generated by using the global index depends strongly on the average degree of G .

Due to limitted space the figures of the following experiments are omitted here. The third parameter we vary is the number of vertices in the query graph Q . We set the size of database graph to 100 K so that GADDI can build its index. With the increase of the size of Q , SUMMA involves more external reads to find the candidate matches. The query time of SUMMA increases faster than that of GADDI. However, although the performance of GADDI is better than that of SUMMA for small database graphs, it cannot run on massive graphs, leaving SUMMA valuable for the purpose of graph matching.

Next we vary the number of distinct labels. We still set the size of database graph to 100K so that GADDI can build its in-dex. The query time decreases with the number of distinct labels in the database graphs for both types of query graphs. More labels in G means more label combinations in the neighborhood of a vertex, which increases the building time of local index in general while that of global index is not affected. Increasing the number of dis-tinct labels reduces the number of candidate matches between any pair of vertices in G and Q , which leads to a shorter execution time. The last parameter we vary is the number of matches of Q in G . The size of database graph is still set to 100 K so that GADDI can build its index. Also, we select those induced subgraphs of the (a) Index Construction Time (b) Index Size database graph as query graphs. With more matches in G , SUMMA requires more time to find all the matches. The runtime of SUMMA is still comparable to that of GADDI.

In the current computer technology, a common server has about 20 GB main memory, which can hold GADDI X  X  index for a graph with approximately 2 million vertices and an average degree of 10. Although the main memory size increases over time, the size of real world graphs also grows dramatically, e.g., up to billions of vertices. Most current graph indexing tools cannot work for such large graphs on a common server, leaving SUMMA a useful tool in the future. To conclude, SUMMA outperforms GADDI for the purpose of graph matching in massive graphs because of its better scalability.
In this paper, we have proposed an index based graph matching method (SUMMA) to find all matches of a query graph in a massive database graph. SUMMA constructs the local index structure (la-bel combinations) and global index structure (shortest path trees) to accelerate querying processing. SUMMA uses the local index structure to decide which a vertex to start with, and the global in-dex structure to search a bounded graph which can be stored in the working memory. SUMMA achieves a high pruning power and its memory usage scales linearly with the number of vertices. We demonstrated that the SUMMA approach can outperform the alter-native methods both in efficiency and accuracy.
