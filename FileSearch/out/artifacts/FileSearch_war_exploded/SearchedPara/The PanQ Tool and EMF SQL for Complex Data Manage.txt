 We have introduced the syntax of extended multi-feature (EMF) queries first in [CR961 and later in [ChaSS]. Th e novelty of these papers was the introduction of the concept of grouping variables. 
A grouping variable is a tuple variable, i.e. it denotes a set of tuples. However, the definition of a grouping variable is replicated for each group, i.e. a grouping variable denotes a (possibly different) set of tuples for each group. Several grouping variables may be defined in an EMF query. These are declared in the group by clause, following the grouping attributes and separated by them with a sem.icolon. The scope of the grouping variables is the entire ,relation. 
The newly introduced such that clause defines the range of the grouping variables X1, X2,. . .X, mentioned in the group by clause. It has the following form: Each G X  X  is a (potentially complex) condition that is used to define the Xi grouping variable, i = 1,2,. . . , n. It may involve (i) attributes of Xi, (ii) constants, (iii) grouping attributes, (iv) aggregates of the group and (v) aggregates of the X1, . . . , Xi-1 grouping variables. Part (v) means tha,t aggregates of previously defined grouping variables can be used to define subsequent grouping variables which adds greatly to the ability to express ad hoc complex queries. 
The select clause is the same as in standard SQL, but now attributes and aggregates of the grouping variables can also appear in that clause  X . The having clause is extended to contain aggregates of the grouping variables. A simple example illustrates our syntax. Example 2.1: One wants to identify for each prod-uct, those months m of 1998 such that the total sales of the previous month of m was greater than the total sales of m. This can be expressed in EMF SQL as: For each value of product and month, grouping variable 2 denotes the sales of that product on that month (i.e. the whole group), while grouping variable y denotes the sales of that product the previous month (y.month=month-1). 0 
The group by clause acts as an implicit iterator over the values of the grouping columns; for each such value one or more  X  X nteresting X  subsets of the relation are defined (the grouping variables). The challenge was to provide the user with this  X  X ooping X  ability without sacrificing the declarativeness of 
SQL. We show briefly in the following section that this syntax translates directly to an efficient, optimizable implementat,ion. We are currently working on decoupling the definition of the group-by values (e.g. could be replaced by a cube-by or even by a user-supplied set of base values) and the computation phase, unifying thus all multi-dimensional queries under one framework [CJK99]. 
We also introduce a new aggregate function called any( . &gt; that solves several known schematic problems of SQL in a clean and principled manner. 
This function is described in Section 4, Example 4.8. 
Many complex data analysis queries can be ex-pressed in EMF syntax significantly easier than in standard SQL. However, the main reason to extend 
SQL is optimizability. The structure of an extended multi-feature query is such that its evaluation can be mapped directly to an efficient implementation that is easy to optimize. A compact data structure is used for this purpose, mostly corresponding to the output of the EMF query. This is called the mf-structure or mf-table of the EMF query. The basic evaluation algorithm uses only scans of the base relation in order to compute the answer. 
Definition 3.1: Let &amp; be an extended multi-feature query and H be a table with columns the grouping attributes and the aggregates of each grouping vari-able (denoted as outp(Xi), i = 0,. . . , n, X0 denotes the group itself). Then H is called the mf-structure (or mf-table) of Q. Th e rows of H are called entries. 
Each row of H corresponds to a distinct value of the grouping attributes (i.e. a group). The following algorithm computes correctly the mf-structure H of an extended multi-feature query. 
Algorithm 3.1: Evaluation of EMF queries: is scanning (or indexed scanning). As a result, the evaluation of multiple EMF queries can overlap since the query-specific computation takes place in the individual mf-structure. We briefly describe below several immedia,te optimizations implemented in our tool. (i) Relative Entries. Algorithm 3.1 can become very expensive if the mf-structure has a large number of entries since, for every scanned tuple all H X  X  entries are examined, resulting to an implicit nested-loop join. However, this is not always necessary since, given a tuple t, one can identify a small number of mf-structure X  X  entries that may be updated with respect to t during the evaluation of a grouping variable X. Note that this implies indexing of the mf-structure which is always memory resident as shown in optimization (iv). Standard query processing techniques require indexing of the base tables (hence the  X  X everse engineering X  term for our approach). (ii) Dependency Analysis. A scan of the base relation can be very expensive, especially if the data. set is large. It is therefore essential to reduce the number of scans as much as possible. 
Algorithm 3.1 requires one pass over the base data for each grouping variable, for a total of n + 1 scans. 
This number can be reduced by performing simple dependency analysis on t&amp;he grouping variables. (iii) More Scans, Less Memory So far, we have assumed that the mf-structure fits in main memory. 
This is not always the case, e.g. for certain queries on very large data sets. Since it is essential to keep the mf-structure memory resident, the solution is to compute t,he a.nswer in m  X  X ounds X  instea.d of one at the cost of increasing the number of scans of the base table. As a result, we can always devise a query evaluation plan in which Algorithm 3.1 operates on memory-resident data. 
All the following examples describe typical ad hoc data analysis/decision support, queries. Use your imagination and combine these cases to build more complex queries. Example 4.1: (Pivoting -data become columns) 
Suppose that you want to find for each customer the average sale in  X  X Y X , the average sale in  X  X T X  and the average sale in  X  X J X . 
Example 4.2: (Hierarchical Queries -aggre-gate along some hierarchy / roll-up) For sales of 1997, show for each product each month X  X  total sales as percentage of this product X  X  yearly total sales. 
Example 4.3: (Trends -moving aggregate along some time sequence) Suppose that you want to find for each customer and for each month of 1997 
The average sales to this customer for this month, and also the average for the three preceding and the three following months. 
Example 4.4: (Dependent Aggregation -use aggregated values to further select tuples) One can use aggregates of grouping variables in order to define subsequent grouping variables. Assume that you want for each product to count for each month of 1997 the sales that were between the previous month X  X  average sale and the following month X  X  average sale. Example 4.5: Inter-Dimensional Comparisons 
One can discover customers who have the potential to increase their purchases in one or more products by comparing for each customer and product, the customer X  X  average sale on this product versus the average sale of the product to other customers. 
Example 4.6: (Medians) There are several real-life examples that require the computation of the median. Suppose that we want to find the month of 1997 by which every customer had made half of their total purchases. great flexibility in specifying the exact nature of the median to be computed. With a small modification to the above query, we could find the month by which half of the total number of purchases were made, or the 1nont.h by which 75% of the purchases were made. 
Example 4.7: (Multiple Data Sources) Infor-mation from several sources can be combined and aggrega.ted. It, resembles a join; however, only the grouping columns can be used to combine different tables. Assume that the cust column of the Sales t,able and the user-id column of the Web table are drawn from the same domain. With the following query we want to find for each customer his/her monthly total web access as percentage of the yearly total web access, but only during those months that the customer X  X  average sale before this month was less than the customer X  X  average sale after this 
The grouping variables 2, y range over table Sales, while grouping variables y, z range over table Web. 
The values for the grouping columns are selected only from the Sales table. Note that in this example we combining pieces of other queries (e.g., running sums and percent-of-total aggregates). q Example 4.8: (The any aggregate function) 
PanQ tool introduces a new aggregate function called any, with very simple semantics yet powerful enough to solve several known SQL problems (and 
EMF SQL problems). A t,uple is selected at random among the rows being aggregated (the selection is implementation specific) a.nd the value of the argument column is returned. 
Assume that you want to find for each customer, the state on which his/her maximumsale took place. 
In this case, several rows of the zz grouping variable may have sale equal to the maximum sale. 
Only one of these rows is selected. This example shows how one can have non-grouping attributes in the select clause  X . Solutions proposed in the past (e.g. [GBLP96]) suggested that attributes functionally dependent on the grouping attributes should be allowed as well. The aggregate function any provides a c1ea.n and flexible solution to this problem. The any aggregate function can be used to solve several other problems, such as pivoting without, aggregation and mappings. For exa.mple if cust and user-id attributes are not drawn from the same domain, a table mapping cust to userid values must be used. The any aggregate function can be used to express this join in one EMF query, resembling aggregation. 
In Figure l(a) we compare the performance (elapsed time, in seconds) of the SQL component of a [Gro98] Robert Groth. Data Mining : A Hands-
