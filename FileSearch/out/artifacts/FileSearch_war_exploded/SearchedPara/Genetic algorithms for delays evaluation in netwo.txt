 1. Introduction trial automation, ensuring real time requirements on one hand and devices safety on the other hand. Nowadays, the trend is also to use the same communication technology at different levels in the industrial organizations; management and automation. A solution that supports such a vertical integration has to be able to provide high throughputs in the upper level as well as small and accurate response times in the field level. The Ethernet solutions, which were initially developed to office networks, can be considered as such a new generation of fieldbuses. Currently, many automation producers and alliances developed their own industrial Ethernet standard ( Neumann,2007 ). Each solutionwitha specific protocolis best suited to a particular application. A Client/Server protocol like
Modbus over Ethernet, even not adequate for strict real time applications like motion control, is a simple and a reasonable solution for many purposes in industrial control systems. Indeed, it is an application protocol (the 7th layer of the OSI model) that is completely compliant with the standard Ethernet. Therefore, vertical integration is easily achieved. Thus, high level functions like diagnosis and device management are easily implemented.
Unfortunately, with such a protocol, no global medium access scheduling is available and different delays due to waiting for resources availability or synchronization are caused. So, the evaluation of its time performances like the response time is complex and the investigations that deal with this problem are rare. The existing methods are often studies of particular systems basedonmodelchecking( GreifenederandFrey,2007;Witschetal., 2006; Ruel et al., 2009 ) that suffers from the classical state explosion problem. Another method is based on high level colored
Petri nets simulation ( Marsal et al., 2006; Zaitsev, 2004 ). This method is time driven and very onerous of time. Moreover, it does not provide a formal analysis or proof about its capacity to sweep the worst scenarios corresponding to the worst delays. Finally, an experimentalmethodusingalogicalnetworkanalyzerdedicatedto delays measuring is presented in Denis et al. (2007) . Hence, the aim of the current paper is to propose an adequate method to assess upper bounds of end-to-end delays of switched packets in the context of Client-Sever automation systems. While a proof about the capacity of the method to assess the worst delays is provided, a genetic algorithm is developed to achieve it much faster.
The remainder of this paper is organized as follows. Section 2 introduces the context of our investigation and the motivations to develop a method for end-to-end delays evaluation. Thereafter, two algorithms, to look for the worst delays, are developed in
Section 3: an exhaustive algorithm in Section 3.1 and a genetic algorithm in Section 3.2. A case study is then considered to perform a comparison between them in Section 4. Finally, Section 5 addresses some concluding remarks. 2. Client server automation systems over switched Ethernet The studied automation architecture works according to Client/
Server protocol. It is constituted mainly of PLCs (programmable logic controllers), RIOMs (remote input output modules) and a switched Ethernet network that enables communication between all the components ( Fig. 1 ). The PLCs (clients) send periodically requeststothe RIOMs(servers) andwait foranswers. Whena RIOM receives a request, it puts it in a queue so as to process all the waiting requests according to a FIFO policy. A request is mainly to get information from the plant (e.g. is the maximal level of water reached?) or to provide orders (e.g. close the valve) or a combination of both. A major criterion of time performance of such a system is the response time D r ( Fig. 1 ). It is defined as the delay between the occurrence of an event in the plant (e.g. the maximum level is reached) and the arrival of the consequence, issued from a controller, on the controlled plant (closure of the valve). The response time can be defined intuitively as the reactivity delay of the automation system.

As a matter of fact, the evaluation of the response time of these systems is tricky. Indeed, different delays due to non synchroniza-tion of the components, resources sharing and of course the intrinsic delays (processing) are to be considered.

In Addad et al. (2010) , we developed an analytic method to evaluatethisresponsetime.Aformulagivingan upperboundofthe response time is obtained. Obviously, the delays we call the end-to-end network delays (including only the delays experienced in the switches) are involved in the formula. A typical end-to-end delay is the time for a request to cross the switches from its generation by a PLC until its arrival to a RIOM. Therefore, to assess an upper bound of the response time, upper bounds of these end-to-end delays are needed.Itcould bethoughtthenthatexistingmethodslike thewell known network calculus ( Cruz, 1991; Le Boudec and Thiran, 2004; Georges et al., 2005 ) or worst case methods ( Fan et al., 2008; Lee and Lee, 2002 ) can be used for this purpose. Unfortunately, in the context of switched packets, combined to Client-Server paradigm, it is not so obvious. Indeed, the flows independency supposed by the previous methods isnot verified.For instance,a RIOM does only answer a received request and therefore a request with its corresponding answer cannot exist at the same time in the system. Besides this impeding fact, the formula is very sensitive to the upper bounds of the end-to-end delays. Indeed, a small over-estimation of these delays may lead to a huge overestimation of the response time upper bound. As a result, the quality of control in these automation systems are dramatically degraded since the control law synthesis is based mostly on the upper bound assess-ment ( Addad and Amari, 2008 ). Thereby, an adequate method to evaluate the end-to-end delays in such systems is to be investi-gated. This is the objective of the next section. 3. End-to-end delays evaluation
As aforementioned, the studied automation architecture works according to Client-Server protocol. The PLCs, which are the clients, send requests and the RIOMs (the servers) return answers accordingly. To explain the proposed method of delays evaluation, we use the system in Fig. 1 .

K PLC1 sends a burst of three requests (series of three frames sent one after another) periodically with a period T 1 to the modules R12, R13 and R14 (Figs. 1 and 2).
 K PLC2 sends a burst of three requests periodically with a period
T 2 to the modules R14, R15 and R16.

K PLC3 sends a burst of two requests periodically with a period T to the modules R16 and R17.

Actually, the PLCs which are the sources of frames (we use the term of  X  X  X enders X  X ) are neither synchronized nor scheduled and therefore can start sending their bursts at any time. A scenario is shown in Fig. 2 where lags t 2 and t 3 with respect to the start-sending date of PLC1 (chosen as a reference) are represented.
Obviously, different lags (different scenarios) will lead to different interferences between the bursts of the PLCs and consequently different end-to-end delays within the system. Therefore, the main issue is then to find the critical scenario (the lags t i the maximum delay of a given frame. This is the purpose of the following algorithms. 3.1. Exhaustive exploration algorithm
As explained above, the interference between the bursts is entirely up to the lags t i between the senders. Intuitively, a sender will influence another if it starts sending frames at more or less the same time. A given frame experiences a delay depending on the set of frames that preceded it in a switch and are waiting to be forwarded first. In the context of our study where the pattern of generation of the frames from PLCs is known beforehand (periodi-cally), all the possibilities of this set of frames can be identified exhaustively. In Fig. 3 for example, the number of possibilities of the set E of the frames of parallel bursts that enter before a frame f * is equal to 4 3  X  12 (4 frames in the first burst and 3 in the second one). It is a simple combinatorial operation. As we notice in Fig. 3 , there are infinite situations that correspond to the same set E , but obviously not the same delays. Therefore, the issue is to handle the variation of the delays from a scenario to another. The next lemma and theorem will show that the discrepancy from a scenario to another, corresponding to the same set E , is at worst equal to a well determined length.
 experiences a delay D in it. Let f i be a frame (of a parallel burst i) that comes immediately before f n and enters the switch at time t * d
Interference domain 1 the date y i  X  t * e * with e *  X  0 + i.e. f * enters a bit after f that: d i  X  e *  X  0 + . One can equivalently write D is maximal ) y  X  t e
Proof (by contradiction). Let y i  X  t * d i be the date of arrival of the frame f i with d i 4 e * . To remain under the assumption  X  f immediate frame entering before f *  X  an enough condition on d verify: d i o d where d is the minimalinter-arrival timeof the frames (see Fig. 3 (a)). Suppose that f i enters at date y i and this scenario leads to the critical situation i.e. the delay D is maximal. Now, suppose that f i enters at date y u i  X  t e (see Fig. 3 (b)) and this second scenario leads to a delay D 0 . Since the set E remains the same, from case (a) to case (b), and the arrivals of frames of this set are delayed, then the end of their processing will be delayed too.
Finally, the frame f * will experience necessarily a delay D 0 greater than D . This is of course absurd since from the beginning D is supposed to be the maximal delay. &amp; adequate start-sending dates from PLCs or the lags t i ( Fig. 2 ).
Therefore, instead of tackling the problem by searching this set, we rather look for a combination of the lags corresponding to this worst scenario. The following theorem will provide an enough conditiontoachieveanexhaustiveexplorationwhilesearchingthis worst scenario.

Theorem. Suppose we look for the worst scenario by searching the lags t i in an enough large domain .
 combinatorial scheme, then an exhaustive exploration is achieved and the accuracy of the result is worth d e . In other words, the gap between the assessed delay and the effective worst one is smaller than d
Proof. From the lemma, the maximal delay is reached if f * enters the switch a bit after f i . Since the step d e is smaller than the inter-arrival time, then we are sure to obtain the set E and the best case is when f i enters d e before f * . Hence, if every frame f i t * , then the processing of the set E will be finished, in the best case, d e earlier. Thus, the assessed delay added up to d e is at worst d greater than the real delay. &amp;
Remark 3.1. With Ethernet d  X  min k  X  X  72  X  12  X  = C k  X  where 72 bytes is the minimal frame length (preamble included), 12 bytes is the inter-framesgap(96bitsor12bytes)and C k thephysicalcapacityof the port k of a switch.

Thereby, we can use a step d e , respecting the previous theorem condition, to vary the lags t i in a domain noted [ T Domain where T Domain is taken large enough to include the worst scenario (assessed for instance using a pessimistic method).

Hence, for each combination of the lags, we simulate the behaviour of the system and assess the corresponding delay
D end 2 end (see Fig. 4 ). This is represented by the block Simulator ( t , t 2 , y , t n )in Fig. 4 with the lags t i being introducedas entries. For a system with n senders (PLCs), the diagram of the exhaustive exploration method is drawn in Fig. 4 . The maximum of all the obtained delays is then chosen as an upper bound. The simulation can be achieved using any suitable simulation method. In the case of the current study, a virtual queuing based simulator, already applied in Addad and Amari (2009) , has been used for this purpose.
It has the advantage of being an event driven simulator and therefore much faster than the usual time driven simulators.
Despite this advantage, the simulation may last a long time when dealing with very large systems. Indeed, the number of times to run the block Simulator ( t 1 , t 2 , y , t n ) is exactly equal to  X  2 where n is the number of senders and T Domain = d e the integer part of T Domain / d e . Thus, this number grows exponentially when the number of senders grows linearly. While this exhaustive method is quite satisfactory in some cases, it can be very onerous of time in others, so other more efficient methods are to be investigated.
Genetic algorithms are then considered as an alternative in our study. 3.2. Genetic algorithms
Genetic algorithms (GAs) were first introduced by Holland (1975) and have been extensively explored later in other investigations for optimization problems resolution in almost all domains. With regard to fieldbus systems, GAs were used in Georges et al. (2006) , Zhang and Zhang (2007) and Carro-Calvo et al. (2010) to optimize the partition of switched Ethernet networks into sub-networks where the intra sub-network com-munication traffic is maximized whereas the inter sub-networks communicationis minimized. They were used in Lee et al. (2004) to help the designer to select the optimal timers in a Profibus Token Passing Protocol fieldbus so as to satisfy the maximum allowable delays of the real time data on one hand and maximize the non real time data transfer on the other hand. They were also used in Cheng and Yang (2010) and Garc X   X  a-Nieto et al. (2010) to investigate the problem of dynamic quality of service in mobile ad hoc networks. We can also quote ( Saniee Abadeh et al., 2007 ) where GAs were used to improve the security of networked computers while reducing the false alarms in determining intrusive activities. In the current study, we obviously use GAs to evaluate the maximum end-to-end delays of switched packets in Client-Server networked automation systems.

A GA is a structured stochastic optimum search method that mimics the process of biological evolution. At the beginning, a GA is initializedwithacollectionofsetsofparameters.Eachsetiscalleda chromosome whereas a parameter a gene . Then, the chromosomes are evaluated according to their fitness of solving an optimization problem (maximizationof D end 2 end in our case). At every generation (algorithm execution time), the fittest chromosomes (parents) are allowed tomate (crossover) and bearoffspring(children).Then, the best children become the parents of the next generation. The previous steps are repeated until finding a satisfactory solution of the problem. To avoid falling in a local optimum as is often the case with the traditional hill-climbing search methods, a mutation mechanism is added. Depending on the optimization problem, many ways exist to accomplish every step of the GA: codification of the chromosomes, initialization of the population, selection of the parents, crossover and mutation. Here are the features of the applied GA in our problem:
Chromosomes encoding : The parameters handled in our problem are the start-sending dates or the lags t k which are real numbers.
Therefore, we apply a continuous GA and the genes are simply real numbers. The k th gene noted g i k of each chromosome i represents the lag t k .The i th chromosome is noted Y i  X  X  g i 2 , g i fitness J ( Y i )where J ( Y i )  X  D end 2 end .

Initialization of the population : In some automation systems, we may have an idea about the worst scenario and therefore initializetheGA withthe correspondingparameters.Incomplex systems, it is rarely the case. Therefore, a random initialization of the parameters in the domain [ T Domain ,+ T Domain ] is con-sidered in the current study.

Selection of the parents : According to natural selection theory, the fittest members with the greatest fitness survive and the others die. One way to represent this strategy is to use the so-called roulette-wheel-spinning. A unit circumference is cut into slices, each slice being dedicated to one member according to its relative fitness. The i th member is then associated to the portion
P i  X  J  X  Y i  X  = P k J  X  Y k  X  . Thereafter, we spin the wheel and if the pointer stops at the j th portion, the chromosome j is selected and placed into a mating pool. Obviously, the fittest members with the biggest portions are more likely to be chosen than the others.

Crossover ( mating ): Pairs are chosen from the mating pool and mate with a given probability P Css to form the offspring. Many approaches exist to deal with the crossover in continuous GA ( Passino, 2005 ). One of the most efficient and simplest methods is combining two genes g i k and g j k of the parents Y i form the children Ch i and Ch i u (with genes noted Chg i as follows: Chg i k  X  a g i k  X  X  1 a  X  g j k 8 &lt; : a being a random real number in the domain [0,1].

Mutation : To avoid a quick convergence of the GA and the risk of being trapped in a local optimum, we force it to explore other regions of the space by introducing random changes or muta-tions in the genes. The process of mutation on a gene g i member Y i can be performed with a probability P Mt as follows: g b being a random real numberinthe domain[0,1]. Themutation is applied on all the members of the population except for the best member of the generation if elitism option is chosen. With elitism option, the best member of a generation is conserved for the next generation without any change. As a consequence, the fitness function is monotonic along the generations (non-decreasing function as in Fig. 7 ).

The process described previously is repeated until a satisfactory solution is found or the best fitness does not change during a minimum number of generations. The GA applied for our problem resolution is implemented using Matlab software and the main steps are shown in Fig. 5 . The following notations are adopted: PopNum is the total number of members of the population. MaxGen is the maximal number of generations.
 PCss is the probability of crossover.

PMt is the probability of mutation. rand is a random number from the domain 0 , 1  X  .

Remark 3.2. As can be seen in Fig. 5 , the same block representing the simulator used with the exhaustive method is used with GA.
Indeed, this block is only used to simulate the behaviour of the system for a given scenario so as to assess the corresponding delay.
Note that using a simulator and introducing manually the entries (the lags t i ) of each scenario would not be viable given the number of times the block is to be run. In this study, both the simulation block and optimization methods (either exhaustive or GA) are implemented using the same programming language (Matlab) and the whole process is therefore automated. 4. Case study
The system of the case study is shown in Fig. 6 . It works as follows: three controllers, PLC1, PLC2 and PLC3 scan, respectively, the ordered sets of RIOMs: { R 12 , R 13 , R 14 }, { R 14 with 72 bytes requests. This is the automation part we used for explanation in Section 2, but as stated previously, the studied system presents the advantage of ease of high level functions integration since standard Ethernet is considered for communica-tion. Therefore, a second part PART II is added for this purpose; PC1 exchanges long frames of 1008 bytes length with PC3 and PC4 whereas PC2 has the role of a supervisor of the first part PART I .It scans all the RIOMs every 300 ms with 72 bytes requests so as to check the good functioning of the modules. The aim is to evaluate an upper bound of the delay D end 2 end that a request, sent from PLC2 to R14, experiences in the network ( Fig. 6 ). Any request would be chosen, but we selected this one since R14 is shared by PC2, PLC1 andPLC2.Thus,particularandnottrivialscenariosleadtotheworst delay. Therefore, we should find them using different methods. To evaluate the delay in question, we applied the two previously exposed methods, exhaustive exploration and GA. We also con-sidered two cases using the exhaustive method: Exhaustive I with step d e being set up to 20 m s at the beginning and to 1 m s subsequently whereas in Exhaustive II this step is progressively narrowed from 50 to 1 m s. The results of assessment using the different approaches are reported in Table 1.

As we can note, all the methods lead to nearly the same assessment of the worst end-to-end delay. The duration of simula-tion is however very different. First, the use of a small step in the exhaustive exploration may lead to long simulation durations (Exhaustive I). Indeed, the smaller the step d e is, the greater the number of situations to check is (recall that this number is equal to  X  2 U T Domain = d e  X  n ). A more interesting method is to begin with a relatively large step d e (50 instead of 20) if possible (it must check the condition given by the theorem) and narrow it progressively.
This is made in Exhaustive II and we notice that the simulation durationis dramaticallyreduced from 2 h to about4 min. We can also note that the gap of underestimation in all the cases is smaller than the step d e . Indeed, the sum of the used step and the assessed delay is always greater than the final assessed delay. In Exhaustive
II for instance,we havean assessed delayof 283.52 m s with a step d equalto50 m s.Thesumofbothisgreaterthanthefinaldelay,which isequalto319.96 m s.Thisfeaturecanbecheckedinalltheresultsof
Table 1 . Naturally, this corroborates the statements of the theorem of Section 3.1.

On the other hand, the genetic algorithm not only provides an accurateupper bound ofthe delay(see Fig. 7 ), but also achieves it in relatively negligible simulation duration of about 29 s. Moreover, a gap of 1% from the final maximal delay is reached in almost 100 generations (about 2 s simulation duration). Compared to duration of 2 h or even 4 min using exhaustive search, GA achieved better results much faster. Finally, we can point out that the gap between the final assessed delays using Exhaustive (i.e. 319.96 m s) and GA (i.e. 320.50 m s) is smaller than 1 m s (the final step used in Exhaustive). Again, this is in accordance with the theorem since we can be confident about 320.50 m s of being the exact worst delay given that it does not change from generation 200 to generation 1000 ( Fig. 7 ). 5. Conclusion
In this paper, we proposed an approach to evaluate end-to-end delays of switched packets in networked automation systems. The Client-Server paradigm being used as the protocol of communica-tion, the existing methods of delays evaluation are indeed hardly applicable. So, an exhaustive exploration method and genetic algorithms were developed to assess upper bounds of these delays. On a case study, we showed that both methods give almost the same results but a clear advantage of using GAs has been noticed sincethesimulationdurationsare dramaticallydifferent.Whilethe exhaustive one may be preferred when dealing with simple automation systems, given its simplicity of implementation, GAs are moresuitableforevaluationwhenlargearchitecturesare under consideration.
 References
