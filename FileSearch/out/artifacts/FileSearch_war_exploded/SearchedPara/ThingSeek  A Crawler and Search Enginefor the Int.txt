 The rapidly growing paradigm of the Internet of Things (IoT) requires new search engines, which can crawl hetero-geneous data sources and search in highly dynamic contexts. Existing search engines cannot meet these requirements as they are designed for traditional Web and human users only. This is contrary to the fact that things are emerging as major producers and consumers of information. Currently, there is very little work on searching IoT and a number of works claim the unavailability of public IoT data. However, it is dismissed that a majority of real-time web-based maps are sharing data that is generated by things, directly. To shed light on this line of research, in this paper, we firstly create a set of tools to capture IoT data from a set of given data sources. We then create two types of interfaces to provide real-time searching services on dynamic IoT data for both human and machine users.
The Internet of Things (IoT) is an emerging paradigm, which aims to connect everyday physical objects to the In-ternet via wireless and identification technologies. It is rev-olutionizing numerous applications in a wide variety of real-world domains. Novel IoT-based solutions can provide com-petitive advantages in various key sectors of society. Some interesting examples are smart cities, smart homes, health-care, security and surveillance [3]. Web services are now mature enough to enable sensors to automatically publish their data on the Internet. Unfortunately, traditional World Wide Web search engines currently do not cover existing IoT data on the Web. Therefore, a major milestone in boosting this area is to create tools to search IoT.

Some of the notable works in this area are as follows [11]: (1) Snoogle/Microsearch [7, 9]; (2) Dyser [4]; and (3) SPIT-FIRE [5]. Currently, to the best of our knowledge, all of the existing search engines have been examined only for small and/or unreal data. Furthermore, all of these search engines have been designed for human users only and it is neglected that smart objects may also require this service.

To the best of our knowledge, the only tangible result of initiating an IoT search engine is the Thingful 1 project. Thingful is a search engine for the IoT, providing a geo-graphical index of connected objects around the world, in-cluding energy, radiation, weather, and air quality devices as well as seismographs, beacons, ships, aircraft and even wildlife trackers. The search engine indexes the data which is generated by publicly available sensors from different data sources. However, handling the data that should be indexed is a huge technical problem and the data on Thingful is mostly outdated. Moreover, the data collected by Thing-ful cannot be extracted by any means and the interface of the website presents raw data only. Thus, further improve-ments are required to convert the existing work to a good infrastructure for future works in this area.

Meanwhile, there is another search engine, namely Shodan 2 which also claims to be a search engine for IoT. Shodan is ba-sically designed as a search engine for hackers as it identifies and hacks password protected devices such as servers and routers as well as any other object that is connected to the Internet. Shodan itself does not process sensor outputs and despite the size of its dataset, catching everyday objects on Shodan is still not straightforward as servers, routers and network devices constitute the majority of devices on its database.

We develop a data discovery engine to extract, analyze, visualize and export IoT data from publicly available data sources on the Internet. In our design, we focus on collecting publicly available real-time IoT data. The result of our work includes integrated tools for managing IoT data sources, a crawler engine to collect highly dynamic IoT data and two novel user interfaces to serve both human and machine users.
In this section, we present the framework of the ThingSeek crawler engine and specifications of the collected dataset.
To minimize the required amount of work when collecting data from a new source, we have broken down the crawling procedure into a certain set of steps in a unified framework. http://www.thingful.net https://www.shodan.io
Figure 1 illustrates the main features of the ThingSeek crawler engine. In the first step, a URL generator initializes the queue of queries. Each entry in the queue is supplied with certain parameters to construct a query to a page or a specific location. The parameters can be the time window, the boundaries of the querying region and/or other param-eters. Then for each entity in the queue, a reader function reads the selected part of the page, and the contents are con-verted to a set of vectors and refined using a refiner. The data for each subset is separately held until all subsets are refined where we merge all of the subsets of the resource X  X  data. In this step, a specific enricher can be used to collect the missing information, if any, from other sources. This can, for example, fill the incomplete fields such as IP ad-dress by acquiring them from Shodan. Finally, the collected data from different sources are integrated and stored on a distributed backend.
 Due to the size and dynamics of the sensor-generated data, IoT data sources often provide a subset of their data with a call to their API. Thus, pagination techniques such as location-based queries are deployed to present the data. We use the same mechanism through implementing the URL generator. The URL generator plays a key role in adjusting the workload on the data source. It converts a set of spatial segments to a sequence of queries which can be submitted via the API of the data source. Thus, a highly populated area can be placed multiple times in the processing queue while an empty area may appear only once (or not appear) in the queue. For example, through a URL generator, URL b will be repeated three times for others during a scan as it contains more dynamic objects than others:
We have developed ThingSeek using a set of tools to col-lect, process and visualize the dataset. Some of the tools we used are as follows: R programming language, SparkR, Apache Spark 1.4.1 and Rails framework.

We initialized the crawler with around 20 data sources. A sample of the collected data is shown in Table 1.
We leverage Web Mapping such as Google Maps which is the most dominant way of visualizing spatial data on the Web, to achieve the goal. Thus, we limit our search scope to the sources which contain a map. We use a set of keywords to narrow our search results to find such sources such as  X  real-time map [of application]  X ,  X  live map [of application]  X  and  X  tracker map of [application]  X . In the search query, the term  X  X pplication X  can be replaced with any application of IoT such as flight . We also include some of the available IoT platforms such as Xively 3 to the initial set of data sources.
In this section, we propose our approach for query resolu-tion and the indexing approach to enable large-scale search for IoT. Figure 2 shows the procedure of retrieving query results in ThingSeek. As the figure shows, the query pro-cessing workflow works as follows. https://xively.com/ Figure 2: Query resolution and indexing in ThingSeek framework 1. Queries, which are formed as pairs of keywords and 2. The Queries are processed in two steps: location based 3. We use approximate values based on indexed data in 4. In the keyword filtering, the results of location filtering 5. Before presenting the results to the user, we update
Due to the highly dynamic nature of the IoT data, analyt-ical result may change promptly. In addition, raw IoT data are often meaningless and not very useful by themselves. Thus, we also designed a Web-based interface to visualize the IoT data as well as query the IoT data.
As objects are becoming smarter, they become the main producers and consumers of information. Thus, we created an interface for smart objects to enable them to query the dataset. To cope with the existing standards, we used Con-strained Application Protocol (CoAP), which is a protocol for simple electronic devices to allow them to communicate interactively over the Internet. We initialize a CoAP based RESTful interface for smart objects to search for things in our database. Although CoAP contains a discovery tool, its scope is limited and lacks flexibility.

Figure 3 compares our architecture with CoAP discov-ery and illustrates how the ThingSeek X  X  machine interface serves queries. For example, a smart air conditioning sys-tem searches objects related to air or weather to plan its cooling strategy. As shown, with the use of CoAP, a query-ing object can only enquire objects on the same network via distributing discovery messages to all objects on the network. Following this, the issuer gets objects X  responses if they match to the query. However, this approach can limit the scope and effectiveness of the search. To resolve this issue, in our ThingSeek architecture, the smart object Figure 3: Query resolution for smart things in ThingSeek framework uses a service to send its query directly to the search en-gine with a POST or GET message. Due to the power, network and computing limits of things, ThingSeek should respond the query with a number of messages containing only a small number of results. In this regard, we use the ECS approach [6] (Extract-Cluster-Select) to provide the best response with limited size. The ECS approach extracts co-location (objects in the same location or very close to each other) and co-ownered (objects with the same owner) correlations between things and forms a unified Things Cor-relation Graph. Then, the nodes are clustered into k groups and finally a number of things from each cluster are selected and returned. It is designed to rank objects based on their correlations and responds the query with a limited number of the top-k results based on the weight of their correlations with the query issuer. Finally, the URI of the corresponding data source is located and crawled to get the latest sensor readings. If the object is not found in the index, the latest cached records will be supplied.
In this section, we demonstrate the functionality of the proposed ThingSeek framework. ThingSeek can extract IoT data from desired data sources by providing separate sim-ple interfaces and effective search algorithms for users and machines. In particular, we demonstrate main functions through three main search scenarios: crawling an IoT data source, a human user searching IoT and a smart machine user searching IoT.
Adding and removing data sources is a key to preserving the quality of the crawled data. To add a new data source, a new crawling procedure should be created in the system. Defining a new crawling procedure starts by initializing the link of the data source. Then, the following steps of the crawling procedure should be specified according to the steps in Figure 1. We have defined a universal module for each step which by default will be used. Otherwise, the user can introduce her own modules by defining new ones. Finally, a strategic crawling queue for the new data source will be specified by the user. For example, users can choose to crawl the new data source hourly and only update certain parts of the data.
Through a Web-based user interface, a human user uses the search engine to acquire information from sensors. For example, a user would like to get information from nearby weather sensors. Figure 4 shows a screen shot of our Web-based interface where each red spot denotes an object in the result set. Users can use the query panel to generate new queries and the result can be shown as a list of sensors or through an interactive map as shown. However, users would be more interested in acquiring knowledge from the data streams rather than finding the sensors. Thus, we added an interactive plot maker to generate real-time plots.
In this scenario, we consider a smart object querying our search engine. We developed a Machine-to-Machine (M2M) interface based on the architecture in Figure 3 to enable things to use CoAP to connect to our server and submit their queries. To use the interface, on the client side, users can use any of CoAP implementations on CoAP website 4 to send a GET or POST message to our server. The message payload contains keywords followed the desired number of the result set at the end. The server would provide the results in response.
To illustrate the future of search engines, [1] identified some of the challenging issues for searching within IoT as search locality and real-time search. Furthermore, based on IoT characteristics such as networked interconnection, real-time, semantic coherence and spontaneous interaction will result in raising issues such as architectural design, search locality, scalability and real-time for designing and imple-menting IoT search engines [2]. However, due to the existing differences in the nature of Web of Things (WoT) with the IoT, WoT may even strike additional different challenges.
In order to design the next generation of search engines, many components of current search engines from data col-lection methods to user experience and semantics should be redesigned. In this section, some of the previous initiations in this area are categorized and reviewed. MAX [10], Mi-crosearch [8] and Snoogle [9] are developed based on this idea. In keyword search approach, keywords are extracted from a given term and top query results are ranked based on a score derived from the percentage of similarity between the given query term and the keyword-based description on sensors. The result is a list of sensors and thus, it might not be very useful particularly for human users. http://coap.technology/
Building future generation of crawlers and search engines is critical for research on IoT. In this paper, we demonstrate ThingSeek, a search engine with a crawler to hunt IoT data on the Web. We mainly focus on the sensor data that is published through Web Mapping. Our ThingSeek frame-work contains a crawler and two querying interfaces to cover both human and machine users, e.g., smart things. We dis-covered that a large portion of IoT data is shared using Web Mapping interfaces. [1] Christophe, B., Verdot, V., Toubiana, V.: Searching [2] Horowitz, D., Kamvar, S.: The anatomy of a [3] Miorandi, D., Sicari, S., De Pellegrini, F., Chlamtac, [4] Ostermaier, B., Romer, K., Mattern, F., Fahrmair, [5] Pfisterer, D., et al.: Spitfire: toward a semantic web of [6] Shemshadi, A., Yao, L., Qin, Y., Sheng, Q.Z., Zhang, [7] Tan, C.C., Sheng, B., Wang, H., Li, Q.: Microsearch: [8] Tan, C., Sheng, B., Wang, H., Li, Q.: Microsearch: [9] Wang, H., Tan, C., Li, Q.: Snoogle: A search engine [10] Yap, K.K., Srinivasan, V., Motani, M.: Max: [11] Zhang, D., Yang, L.T., Huang, H.: Searching in
