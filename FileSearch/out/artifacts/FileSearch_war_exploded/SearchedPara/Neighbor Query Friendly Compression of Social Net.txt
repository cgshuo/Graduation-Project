 Compress ing social networks can sub stantiall y facili tate mining a nd advanced analysis of large social networks. Preferably, social networks s hould b e compress ed in a way that t hey still can b e queried efficiently without decompres-sion. Arguably, neighb or queries, which search for all neigh-bors of a query v ertex, are the most ess ential operations on social networks. Can we compress s ocial networks effec-tively in a neighb or query friend ly mann er, that is, neigh-bor queries s till can b e answered in sub li near time using the compress ion? In this paper, we develop an effective so-cial network compress ion app roa ch achieved b y a novel Eu-lerian d ata structure using multi-position li nearizations of directed graph s. Our method comes with a nontrivial the-oretical bound on the compress ion rate. To the best of our knowledge, our app roa ch is the first t hat can answer both out-neighb or and in-neighb or queries in sub li near time. An extensive e mpirical stud y on more than a dozen b enchmark real data sets verifies our design.
 E.1 [ DATA STRUCTURES ]: Graph s and n etworks Algo rithms, Experimentation, Theory Social Networks, Compress ion, MP k li nearization, Eulerian data structure  X  This research is s upp orted in p art by an NSERC Discovery Grant and an NSERC Discovery Acc elerator Supp lement Grant. All opinions, find ings, conclusions and recommen-dations in this paper are those of the authors and d o not necess aril y reflect t he views of the fund ing ag encies.
A social network is a network of ind ividu als or orga ni-zations as nodes, li nked b y one or multiple types of inter-depend ency, such as friend ship, fin ancial relationships, and kinship. Recently, facili tated b y World Wide Web, more and more onli ne social networks have bee n formed on the Web, such as Faceboo k, Tw itt er, and LinkedIn. It has bee n well recog nized that mining social network data can p ro-vide precious actionable knowledge for bu siness and ind i-vidu als. As an evidence, the nu mber of US p atent app li -cations on n ew techn olog ies related to social networks has grown exponentiall y since 2003 a t a rate of about 250 % per year ( http://en.wikipedia.org/wiki/File:Growth_ in_Social_Network_Patent_Applications.jpg ).

Social networks are often large, and b ecome even larger and larger. For example, from Jan-uary 2008 to September 2008 , the nu mber of ac-tive users of Faceboo k grew from 60 milli ons to 140 milli ons ( http://venturebeat.com/2008/12/18/ 2008-growth-puts-facebook-in-better-position-to-make-money/ ). Faceboo k has more than 350 milli on active users nowadays. The large size and the fast growth rate present a hu ge chall enge for mining a nd analyzing large social networks.

Compress ing social networks can sub stantiall y facili tate mining a nd advanced analysis of large social networks. Preferably, we want query-able c ompress ion of social net-works. In other words, social networks s hould b e compress ed in a way that t hey still can b e queried efficiently without de-compress ion.

Many different kind s of queries can b e condu cted on so-cial networks. Arguably, neighb or queries, which search for all neighb ors of a query v ertex, are the most ess ential op-erations on social networks. Many other operations, such as commun ity find ing, network patt ern mining, and outli er detection, can b e bu il t based on n eighb or queries.
Can we compress s ocial networks effectively in a neighb or query friend ly mann er, that is, neighb or queries s till can b e answered in sub li near time using the compress ion? As to be analyzed in S ection 2, this is a chall enging task, and the existing Web or social network compress ion methods either have to maintain the compress ions of both the network and its transpose, or cann ot answer neighb or queries in sub li near time at all.

In this paper, we tackle the problem of neighb or query friend ly compress ion of social networks. We develop an effec-tive social network compress ion app roa ch. Sp ecificall y, we propose a novel Eulerian d ata structure using multi-position li nearizations of directed graph s. When the optimal MP li nearization is used, our method comes with a nontrivial theoretical upp er bound on the nu mber of bits used p er edge in the compress ion. To the best of our knowledge, our ap-proa ch is the first t hat can answer both out-neighb or and in-neighb or queries in sub li near time. Moreover, we e xplore effective e xtensions using MP k li nearization. An extensive empirical stud y on more than a dozen b enchmark real data sets verifies our design.

The rest of the paper is orga nized as foll ows. In S ection 2, we review the related work. In S ection 3, we defin e the basic notions, formulate neighb or queries, and review the concepts of Eulerian p aths and multi-position li nearization. We present our novel Eulerian d ata structure in S ection 4, and explore the e xtensions to using MP k li nearization in Section 5. We report an empirical stud y in S ection 6, and conclud e the paper in S ection 7.
Due to the fast growth of WWW , compress ing Web graph s has received sub stantial research interest. A Web graph typ-icall y contains a hu ge nu mber of Web p ag es as vertices, and an even larger nu mber of hyperli nks as directed edges.
Adler and Mitzenmacher [1] ga ve a Web graph compres-sion method b y find ing nodes with simil ar sets of neighb ors. Rand all et al. [13 ] were the first t o use the lexicog raph ic ordering o f URLs of Web p ag es for compress ing the graph . Their method takes advantag e of the fact t hat many hy-perli nks are intra-host, and many pag es on the same host have simil ar hyperli nks. Boldi and Vigna [4, 5] further ex-ploited the properties of Web p ag es in lexicog raph ic order-ing to a chieve bett er compress ion. Sp ecificall y, their method takes advantag e of the lexicog raph ic locali ty in Web graph s. That is, proximal pag es in URL lexicog raph ic order often have simil ar neighb orhoo ds. For bett er compress ion, Boldi et al. [3] further developed n ew orderings combining host information and Gray/lexicog raph ic orderings.
 Orthogo nal to the e xploitation of lexicog raph ic ordering, Rag havan and Garcia-Moli na [12 ] decomposed a Web graph into a hierarchical structure. They used the notion of S-node to capture the locali ty property of Web graph s. Su el and Yuan [15 ] also used the structural decomposition techn ique in some sense by distinguishing betwee n local and global li nks. Recently, Apostoli co a nd Drovand i [ 2] i ntrodu ced a BFS-based method. Their app roa ch also encodes the ga ps betwee n li nks, bu t uses a more general sett ing.

Buehrer and Chell apill a [7] used a data mining a pp roa ch to tackle the problem of compress ing Web graph s. Using frequent item-set mining techn iques they mined the com-plete bipartite sub graph s and replaced the e dges of those sub graph s by a virtual node conn ecting to a ll vertices in both p artitions in the complete sub graph . Their method, with the combination of ga p coding techn ique in the lexico-graph ic order, achieves the performance of und er two bits per edge.

All the methods mentioned above use the bits/edge rate as the primary evaluation measure. Some of them also report the query process ing performance. Sp ecificall y, Rag havan and Garcia-Moli na [12 ] provided a direct comparison with the method b y Rand all et al. [13 ] on a coll ection of six differ-ent complex q ueries. Boldi and Vigna [4, 5] i ntrodu ced the lazy iteration for (rand omly and sequentiall y) acc ess ing the li nks in a compress ed web graph . The acc ess time for their app roa ch is in the order of several hund red n ano second s per li nk.

Most of the e xisting Web graph compress ion methods ex-Figure 1: A directed graph and its und erlying und i-rected graph ploit t he locali ty of li nks in the lexicog raph ic order of web pag es. Can social networks, which d o not have a natural l ex-icog raph ic order for the vertices, be compress ible to the same degree ? Recently, Chierichett i et al. [8] extend ed the Web graph compress ion framework [4, 5] by Boldi and Vigna (t he BV schema) t o compress s ocial networks. The central i dea is to introdu ce an ordering based on Jacc ard coefficient [6]. By integrating this ordering into the BV schema, they in-trodu ced a compress ion schema for social networks. They further exploited the reciprocal edges. However, one draw-back is that t heir method cann ot answer neighb or queries in sub li near time.

Our stud y is also related to the famil y of graph layout (or graph ordering) problems, where the goa l i s to find an ordering o f the nodes minimizing a g iven objective fun ction. D  X  X az et al. [10 ] presented a nice survey. In p articular, Pa-padimitriou [11 ] proved the NP-hardn ess of the minimum band width p roblem, where the objective is to minimize the maximum stretch of the e dges.
In this s ection, we review the e ss ential notions used in the paper, defin e the neighb or queries of interest in this paper, discuss the background on Eulerian p ath, and introdu ce the notion of multi-position li nearization for a g raph .
In this paper, we model a social network as a direc ted graph G = ( V, E ) where V is a set of vertices and E  X  V  X  V is a set of edges. We also refer to V by V ( G ) and to E by E ( G ). For an edge e = ( u, v ), we refer to u as the source of e and v as the destination of e . ( u, v ) 6 = ( v, u ).
A simple direc ted graph is a directed graph such that t here does not exist a self-loo p, i. e., no edge ( u, u ) for any v ertex u , and there is at most one e dge from a source u to a destination v . In this paper, we consider simple directed graph s only. However, i t is s traightforward to g enerali ze our r esults and algo rithms to deal with d irected graph s that contain self-loo ps and multiple e dges betwee n two vertices.

In an undirec ted graph , edges do not carr y direction in-formation, i. e., { u, v } = { v, u } . For a directed graph G , we can obtain the underlying undirec ted graph  X  G of G such that Figure 1 shows an example.
For an und irected graph G , we can obtain the direc ted ve rsion G  X  of G by placing two directed edges ( u, v ) and ( v, u ) in G  X  for each und irected edge { u, v } in G .
Hereafter, we call a simple directed graph simply a g raph if there is no a mbiguity. Occ asionall y, we use the notion of und irected graph s which will be mentioned expli citly.
For a g raph G , the transpo se of G , denoted b y G T , i s a graph such that V ( G T ) = V ( G ) and ( u, v )  X  E ( G only if ( v, u )  X  E ( G ).

In a g raph G , an edge ( u, v )  X  E is call ed rec iprocal if ( v, u )  X  E as well. In such a case, u and v are immediately conn ected in b oth d irections. Let F re ( G ) be the fraction of reciprocal edges in E ( G ), i. e., Therefore, G = G T if and only if F re ( G ) = 1.

In an und irected graph  X  G , a vertex u is a neighbor of a vertex v if { u, v }  X  E (  X  G ). Let N v be the set of neighb ors of v and E v = {{ u 1 , u 2 }  X  E (  X  G ) | u 1 , u 2  X  N edges betwee n the vertices in N v . For a directed graph G we use its und erlying und irected graph  X  G to defin e Acc ( G ), the averag e clustering coefficient [16 ], as Moreover, we defin e Gcc ( G ), the global clustering coeffi-cient [14 ], as In a directed graph G , there are two types of neighb ors. For a vertex u  X  V ( G ), v 1  X  V ( G ) is an out-neighbor of u if ( u, v 1 )  X  E ( G ). Moreover, v 2  X  V ( G ) is an in-neighbor of u if ( v 2 , u )  X  E ( G ). An out-neighbor query on u is to find the set of out-neighb ors of u . Simil arly, an in-neighbor query on u is to search for all i n-neighb ors of u .

Exa mple 1 (Neighbor queries). In Figure 1(a), an out-neighbor query on v 5 in G returns { v 2 , v 3 , v 6 } . An in-neighbor query on v 5 returns { v 3 , v 4 , v 6 } . Please note tha t v and v 6 are b oth o ut-neighbors and in-neighbors of v 5 there are rec iprocal edge s be twee n v 3 and v 5 as well as be -twee n v 5 and v 6 .

All the e xisting methods for compress ing Web graph s or social networks encode only outgo ing edges. Consequently, most of those methods can only answer out-neighb or queries directly. In order to a nswer in-neighb or queries, they have to store a compress ed version of the transpose of the graph . As mentioned in S ection 2, some methods li ke [8] cann ot answer neighb or queries in sub li near time.
A pa th P of length k in a g raph G is a sequence of edges ( u 1 , u 2 ) , ( u 2 , u 3 ) , . . . , ( u k , u k +1 ), where ( u (1  X  i  X  k ). For the sake of simpli city, we often write path P as ( u 1 , u 2 , . . . , u k +1 ). P is a simple pa th if u are un ique among o ne another.

Definition 1 (Eulerian path). An Eulerian pa th for an undirec ted graph is a pa th in the g raph which visits each edge of the g raph exactly once .

Exa mple 2 (Eulerian path). In Figure 1(b), pa th S 1 is an Eulerian pa th for  X  G , S 2 is not bec ause it do es not visit edge { v 5 , v 3 } , S 3 is not an Eulerian pa th, either, bec ause it is not a pa th  X  { v 4 , v 6 } is not an edge in graph
It is well known that a conn ected und irected graph G has an Eulerian p ath if and only if it has at most t wo vertices with odd d egree s.

A simple algo rithm to construct t he Eulerian p ath which dates back to 1883 , known as Fleury X  X  algo rithm, i s as fol-lows: we start with a vertex of an odd d egree . If there is no such a vertex, we start with any v ertex. At each step we move across an edge whose deletion d oes not disconn ect the graph , un less there is no o ther choice. We repeat t his process un til no edge is left.
In this s ub section we introdu ce the notion of multi-po sition linearization of degree k ( MP k linearization for short) for a g iven graph G .

Let S = ( v i 1 , v i 2 , . . . , v i graph G (with p oss ible repli cation). We say S cove rs G if all the vertices of G app ear at least once in S . The length of S is m . Here, S does not nee d to be a path.
 We nee d the foll owing notion of S -distance.

Definition 2 ( S -distan ce). Give n a seq uence S tha t cove rs a graph G , the S -distance be twee n u and v , denoted by S -dist ( u, v ) , i s the minimum norm-1 d istance among all pa irs of app earance s of u and v .

Exa mple 3 ( S -distan ce). In Figure 1, the S 1 -distance be twee n v 3 and v 5 is S 1 -dist ( v 3 , v 5 ) = 1 . S dist ( v 2 , v 4 ) = 3 and S 2 -dist ( v 5 , v 3 ) = 2 .
Now w e are ready to formall y defin e the notion of MP k li nearization.

Definition 3 (MP k ). An MP k linearization of a graph G is a seq uence S of ve rtice s of the g raph with po ss ible replication, such tha t S cove rs G and for all ( u, v )  X  E ( G ) , S -dist ( u, v )  X  k . The length of an MP k linearization is eq ual to length o f S .

If S is an MP k li nearization of a g raph G , S is also a n MP li nearization of the und erlying und irected graph  X  G , and vice versa.
 Exa mple 4 (MP k ). In Figure 1, the seq uence s S 1 and S 3 are two d ifferent MP 1 linearizations of both G and  X  But t he length o f S 1 is less tha n tha t of S 3 . S 2 linearization but not an MP 1 linearization of G , bec ause for edge ( v 5 , v 3 )  X  E , S 2 -dist ( v 5 , v 3 ) = 2 .
The notion of S -distance can b e rega rded as an embedd ing of the metric space defin ed b y G to a simpler and compu ta-tionall y more e fficient metric space.
As mentioned in S ection 3.2, i n order to a nswer both out-neighb or queries and in-neighb or queries efficiently, most of the e xisting methods have to store both a g raph G and its transpose G T . Is there any schema for encoding directed graph s which can supp ort fast out-neighb or and in-neighb or queries and still retain a goo d compress ion rate? In other words, how can we e ncode the graph G and its transpose G
T at t he same time using space less than kee ping two in-depend ent copies of the e dges?
In this s ection, we introdu ce the Eulerian d ata structure that affirmatively answers this question. Our method com-press es a directed graph into a n Eulerian d ata structure. Before that, we nee d to establi sh the conn ection b etwee n MP 1 li nearization and Eulerian p ath of a g raph . The foll owing proposition is immediate: Proposition 1 (Lower boun d of MP 1 linearization). Give n a d irec ted graph G , the lower bound for the length o f the MP 1 linearization of G is Moreove r the b ound is tight if and o nly if  X  G ha s an Eulerian pa th, i. e. i t ha s at most t wo ve rtice s of odd d eg ree s. Exa mple 5 (Lower boun d of MP 1 linearization).
 The lower bound for the length o f MP 1 linearization of G in Figure 1 is 9 , since | E (  X  G ) | = 8 . We c an write | E ( in terms of | E ( G ) | using F re ( G ) . Since F re ( G ) = 6 / 11 , | E (  X  G ) | = (1  X  6 / 11 2 ) | E ( G ) | = 8 .

Unli ke the Eulerian p ath construction p roblem which is an existence problem, find ing the optimal MP 1 li nearization is an optimization p roblem. No matt er what structure a graph h as, always there e xists an optimal (i. e., shortest) MP 1 li nearization for the graph . The foll owing lemma g ives the length of an optimal MP 1 li nearization of an arbitrary directed graph .

Lemm a 1. The minimum length o f MP 1 linearization of an arbitrary direc ted graph G is | E (  X  G ) | + max { n where n odd is the numbe r of ve rtice s with odd d eg ree s in
Proo f. In any und irected graph  X  G , the sum of degree s of all vertices is even. Thu s, the nu mber of vertices with odd degree s is also even.

We first prove by indu ction that for any graph G we can obtain an MP 1 li nearization of length | E (  X  G ) | + max { n odd / 2 , 1 } .

Basis: For n odd = 0 a nd n odd = 2, the claim foll ows from proposition 1.

Indu ction: Since n odd must be e ven, we ass ume that t he lemma holds for n odd = 2 k ( k  X  1), and consider the case when n odd = 2( k + 1). There are two sub cases.

In the first sub case, there are two vertices u and v with odd d egree s s uch that t hey are not conn ected in  X  an edge { u, v } to  X  G and call the new graph  X  G  X  . Since has only 2 k vertices with odd d egree s, app lying the indu ction ass umption, we can obtain an MP 1 li nearization of  X  G length | E (  X  G  X  ) | + k = | E (  X  G ) | + k + 1. Since E ( the MP 1 li nearization of  X  G  X  is ind ee d an MP 1 li nearization for  X  G .

In the second sub case, all vertices with odd d egree s are conn ected. We arbitraril y take two vertices u and v with odd d egree s and remove the e dge { u, v } from  X  G . Let us call the resulting g raph  X  G  X  . Aga in,  X  G  X  has 2 k vertices with odd d egree s. Therefore, there is an MP 1 li nearization with length | E (  X  G  X  ) | + k = | E (  X  G ) |  X  1 + k for  X  li nearization for  X  G  X  does not cover { u, v } , we have to a dd u and v to the e nd of the li nearization. Therefore we just bu il d an MP 1 li nearization for  X  G of length | E (  X  as desired.

Now w e prove that | E (  X  G ) | +max { n odd / 2 , 1 } is also a lower bound for the MP 1 li nearizations for G . For n odd = 0 a nd n odd = 2, simply app lying Proposition 1 g ives the bound .
Now, l et us consider the case where n odd  X  4. Let v ( i ) be the vertex that app ears in the position i of an MP 1 li n-earization L . For a vertex u with an odd d egree in  X  app ears in n either the first nor the last position of L , we denote by P u = { i | v ( i ) = u } the set of all app earances of u in L . There are in total at least n odd  X  2 such vertices.
For any interior position i in L , there are two edge slots in L : ( i  X  1 , i ) and ( i, i + 1). Consider all the e dge slots ass ociated with the positions in P u . At least one of these slots must be a  X  waste X , that is, there is no edge app earing in the slot or the e dge in the slot also a pp ears in some other slot. Otherwise, the degree of u is 2 | P u | , which is an even nu mber.

In the best scenario, two vertices with odd d egree s can share a wasted edge slot. Therefore, we have at least ( n 2) / 2 wasted edge slots. In add ition, we nee d | E (  X  slots to cover the e dges of  X  G . Therefore, i n total L has to have at least | E (  X  G ) | + n odd / 2  X  1 edge slots. Hence, the length of L cann ot be small er than | E (  X  G ) | +max { n
Please note that t he indu ction in the proo f of Lemma 1 also g ives an algo rithm to find an optimal MP 1 li nearization of a g raph G . Since the complexity of find ing a n Eulerian path is O ( | E ( G ) | ) [9], find ing a n optimal MP 1 of a g raph G is also o f the same complexity.

Exa mple 6. In Figure 2,  X  G 2 ha s 6 ve rtice s of odd d e-gree s, namely v 1 , v 2 , v 4 , v 5 , v 7 and v 8 . Therefore, the lower bound o n the length o f MP 1 linearization is 15 + 6 / 2 = 18 . Indee d the MP 1 linearization of Figure 2 is op timal.
Based on the relation b etwee n Eulerian p ath and MP 1 li nearization, we present a novel data structure for encoding graph s. To kee p our discuss ion simple, simil ar to [4, 5, 8], we ass ume (1) we are all owed to renu mber the vertices; (2) for each vertex there is an identifier which can b e used for referr ing to the vertex. However, our data structure does not maintain an ind ex of the identifiers; and (3) t he e dges are not labeled. Please note that we can straightforwardly extend the data structure to remove the above ass umptions. Definition 4 (Eulerian data struct ure). The Eulerian da ta structure for a graph G stores an op timal MP 1 linearization L of G using an arr ay of the same length as L . Let v ( i ) be the ve rtex in G tha t app ears at t he po sition i of L . For ce ll i of the Eulerian da ta structure, we kee p the foll owing two p iece s of i nformation
Local information: two bits s pec if ying if edge s ( v ( i  X 
Pointer: a po inter to the next app earance of v ( i ) . If this is the last app earance of v ( i ) , then the po inter po ints to the first app earance of the ve rtex.

Exa mple 7 (Eulerian data struct ure). In Fig-ure 2(c), the Eulerian da ta structure of G in Figure 2(a) using an op timal MP 1 linearization is ill ustrated. Here we sho w the po inters by arcs. Since the length o f the linearization is 18 , we nee d  X  log 2 18  X  = 5 bits to encod e Figure 2: MP li nearizations of an arbitrary directed graph . each po inter. Therefore, f or each po sition we nee d 5 + 2 bits. In total we nee d 18  X  (5 + 2) = 126 bits, which make a compress ion rate of 128 / 19  X  6 . 63 bits per edge .
We have the foll owing important result on the compress ion efficiency of the Eulerian d ata structure.

Theorem 1. An Eulerian da ta structure to encod e a graph G uses up to bits per edge on ave rage , where  X  d is the ave rage deg ree of  X  G . Moreove r, using this da ta structure, i t is po ss ible to a n-swer the in-neighbor and o ut-neighbor queries for any ve rtex deg ree of ve rtex u in  X  G and N v is the set of out-neighbors/in-neighbors ( resp.) of v in out-neighbor/in-neighbor queries.
Proo f. Let L be an optimal MP 1 li nearization of  X  G (t herefore for G as well ). Since there are at most | V | vertices of odd d egree s in  X  G , the upp er bound for the length of L is each cell, i n total the Eulerian d ata structure uses at most  X  | E (  X  G ) | + | V (  X  G ) | / 2  X  X  2 +  X  log bits. To g et t he bits/edge rate we divide this by the nu mber of edges of G , and h ave  X  | E (  X  G ) | + | V (  X  G ) | / 2 of F re ( G ) and also which is precisely the inverse of the averag e degree of Therefore, the bits/edge rate is at most: loga rithm, and obtain  X  The upp er bound is proved.

Since e ach vertex u of G app ears in at least one position in the Eulerian d ata structure, we use the first position of u in L as the identifier for the vertex. Therefore, for an out-neighb or/in-neighb or query on vertex u , we have to return the positions of the first app earances of all out-neighb ors/in-neighb ors of u . Fetching the local i nformation (only two bits) for each p osition takes constant t ime. Reading the pointer takes O (log | V ( G ) | ) t ime (t he nu mber of bits for each pointer). Since the length of the li nked li st of positions for a vertex u is  X  log ( deg ( u ))  X  in the MP 1 li nearization of G , traversing o ver the li nked li st t akes O ( deg ( u ) log time. By traversing the li nked li st of u we can retrieve the positions of all neighb ors of u . However, for a neigh-bor v of u , the retrieved p osition may not be the first ap-pearance of v . Therefore, for each retrieved n eighb or v , we have to traverse the li nked li st for v to g et t he first ap-pearance. So, answering a n out-neighb or/in-neighb or query takes O (log ( | V ( G ) | ) P u  X  N
As a baseli ne for r epresenting a g raph G with sub -li near in-neighb or and out-neighb or queries, we can u se 2  X  log 2 | V ( G ) |  X  bits to encode an edge. For social networks in practice, i t is reasonable to a ss ume that t he averag e degree increases loga rithmaticall y with respect t o the nu mber of nodes in the graph . Therefore, asymptoticall y (i. e., ass um-ing the nu mber of nodes app roa ches infin ity) t he Eulerian data structure uses half of the nu mber of bits that t he base-li ne schema uses du e to the foll owing equation. Table 1: Comparison of compress ion u sing the Eu-lerian d ata structure against t he baseli ne schema.
Table 1 compares our method and the baseli ne schema for a nu mber of combinations of  X  d and | V ( G ) | . Clearly, the larger and the sparser the graph , the less bits the Eulerian data structure uses. Real li fe social networks are often large and sparse. Thu s, the Eulerian d ata structure is capable of compress ing social networks.

To the best of our knowledge, the Eulerian d ata structure is the first schema that all ows answering both out-neighb or and in-neighb or queries in sub li near time, and p rovides a nontrivial theoretical upp er bound on the nu mber of bits per edge. The upp er bound given b y Theorem 1 is for arbitrary graph s, i nclud ing totall y rand om graph s. We know that for some sub class es of graph s the information theoretic lower bound is  X  log N  X  bits per edge. Therefore, from a theoretical point of view our upp er bound is not very far away from this information theoretic lower bound , at least asymptoticall y close.

The real world n etworks in many cases exhibit some kind of locali ty property which can b e used to further improve our method. We will detail our methods in the next section.
A natural extension for the Eulerian d ata structure is to use MP k li nearization instead of MP 1 li nearization. This raises s everal new chall enges. First of all, un li ke MP earization, find ing a n optimal MP k li nearization for k  X  2 is NP-hard in general, since it can b e rega rded as a g enerali za-tion of the minimum band width p roblem [11 ]. How can we get a  X  X oo d X  MP k li nearization without much cost? Second , given an MP k li nearization, we nee d to store 2 k bits as the local i nformation for each p osition i to record whether ( i, j ) and ( j, i ) are e dges in the graph for | i  X  j |  X  k . The amoun t of local i nformation is considerable. Hence, storing the local information efficiently is important. To a dd ress the above iss ues, we e xtend our method to tackle two subp roblems: MP k li nearizing a g raph and encoding the local i nformation for each p osition of the MP k li nearization.

In this s ection, we first motivate the e xtension. Then, we discuss the tradeoff. Finall y, we present t he heuristics and algo rithms.
The most commonly used measure for locali ty in social networks is averag e clustering coefficient. In social networks, the nu mber of vertices with a small degree is much more than the nu mber vertices with a large degree . Consequently, av-erag e clustering coefficient usuall y has a bias toward the ver-tices with small degree s. Therefore, we consider the measure Gcc , Global clustering coefficient, as well.

Roughly speaking, Gcc measures the probabili ty that there is an edge betwee n two vertices when they have a com-mon n eighb or. Consider a social network with a large Gcc value. Supp ose vertices u, v, w and t are four consecutive vertices in an MP k li nearization, and there are e dges be-twee n u and v , v and w , as well as w and t . There is a goo d chance that u and w are conn ected, since both h ave v as a neighb or. Moreover, i f u and w are conn ected, using the same argument aga in, there is a goo d chance that u and t are also conn ected. Depend ing o n h ow strong the locali ty of the network is, i t does make sense to kee p more bits for u specifying weather { u, w } , { w, u } , { u, t } and { t, u } belong to E (  X  G ) or not.
There is a tradeoff betwee n the length of li nearization aga inst t he amoun t of local i nformation. The tradeoff highly depend s on the structure of the graph . Intuitively, for a large sparse graph where e ach vertex has the same out degree , and the destinations of the out-edges are picked rand omly, increasing k would n ot influ ence the length of the li neariza-tion significantly. However, for a large rand om dense graph G where the e xistence of an edge from every node to a n-other is ind epend ently determined b y a probabili ty of 50 %, increasing k up to | V ( G ) | , the nu mber of vertices, i s actuall y beneficial.
 Exa mple 8. Figures 2(c) and (d) encod e g raph G 2 in Figure 2(a) using an MP 1 linearization and a n MP 2 lin-earization, respec tive ly. Using the MP 1 linearization, we nee d to use 2 bits to store the local information for each po sition. Since the MP 1 linearization ha s 18 po sitions, we nee d to use 5 bits for each po inter. In total we nee d 18  X  (5 + 2) = 126 bits, app roximately 6 . 63 bits per edge on ave rage .

Using the MP 2 linearization, we nee d to use 4 bits to store the local information for each po sition. Since it ha s 10 po si-tions, we nee d to use 4 bits for each po inter. In total it uses 10  X  (4+4) = 80 bits, app roximately 4 . 21 bits per edge . The saving of using the MP 2 linearization is s ubstantial.
Can we save more b y moving from MP 2 to MP 3 lineariza-tion? The length o f an MP k linearization for any k cann ot be less tha t t he numbe r of ve rtice s in the g raph . G 9 edge s. Therefore, i n the be st case of using an MP earization, we ha ve 9 po sitions. For each po sition we ha ve to use 6 bits to store the local information and 4 bits for the po inter. Thus, using an MP 3 linearization n ee ds to use at least 9  X  (6 + 4) = 90 bits. Using MP 3 linearization cann ot save , compa ring to using the MP 2 linearization.
To ensure that we can h and le large social networks, we use a straightforward gree dy heuristic for li nearizing a g raph . The algo rithm is s hown in Algo rithm 1. We start with a rand om vertex. At each step we app end to the li st t he vertex that has the largest nu mber of edges with the last k nodes in the li st. We remove these e dges from the graph and iterate un til no edge is left. If none of the last k vertices in the li st have a neighb or, then we pick a rand om node with n on-zero degree and continu e from there.

Using 2 k bits we can encode the local i nformation for each position. A practical problem of the gree dy li nearization heuristic is that, as we are removing the e dges of the graph , the graph b ecomes s parser and sparser. Thu s, having a fixed k all the time is not a goo d idea since the rear part of the li nearization may have very few new edges to encode. To be adaptive, we use a relaxed version of the li nearization n otion. We start with a relatively large value of k (say 20 ) and watch
Name Description | V | | E | Acc Gcc Fre web-Goog le Web grpah from Goog le 875713 5105039 0.604 0.055 0.306 web-Stanford Web graph of Stanford.edu 281903 2312497 0.610 0.096 0.276 Algo rithm 1 Find an MP K li nearization of G Inpu t: K , redu cing factor RF (0  X  RF  X  1), density Outpu t: Linearization L of G Description: 1: i nitiali ze L to a n empty li st 2: whil e | E ( G ) |  X  1 do 3: l et u be a rand om node with n onzero degree 4: app end u to L 5: /* let X be the set of the last K vertices in L */ 6: whil e X has at least one neighb or in V ( G )  X  X do 7: l et v be the node which h as the most nu mber of 8: remove all edges betwee n v and vertices in X 9: edgecount + = deg old ( v )  X  deg new ( v ) 10 : app end v to L 11 : if Length(L)%1000 == 0 then 12 : if edgecount/ 2  X  K  X  1000 &lt; DT then 13 : K = K  X  RF 14 : end if 15 : edgecount = 0 16 : end if 17 : end whil e 18 : end whil e the averag e local density for the recent positions in the li st (t he last 1000 positions as s hown in Algo rithm 1). Once it drops below a certain d ensity threshold DT , we redu ce k by multiplying it t o a predefin ed redu cing factor RF .
We choo se to use a simple heuristic for li nearization and encode the local i nformation. Our pu rpose is to examine the feasibili ty of the framework of using MP k li nearization for compress ing social networks. Our method leaves s pace for further improvement which is the sub ject for future work.
To the best of our knowledge, there is no a ny existing social network compress ion method which can answer out-neighb or and in-neighb or queries in sub li near time. How-ever, the e xisting methods which can answer out-neighb or queries can b e made comparable to o urs in fun ctionali ty by encoding a g iven graph G and also its transpose G T .
We used the data sets from the SNA P project ( Stan-ford Network Analysis Packag e, http://snap.stanford. edu/data/ ). The data sets in the SNA P project are orga -nized in d ifferent catego ries. From each catego ry we chose the data sets with the small est and the largest Gcc values, respectively, i n order to test t he e ffect of our method with respect t o social networks of different degree s of locali ty. Those data sets are from very different domains, such as social networks, web graph s, pee r-to-pee r networks, coll ab-orative networks, citation n etworks, and co-pu rchasing net-works. Table 2 provides the statistics of these networks and short descriptions.
 We implemented our algo rithms using C++ , on top of the SNA P li brary which is pub li cly avail able at http://snap. stanford.edu/ . We used a heterog eneous li nu x based clus-ter to run most of the e xperiments. To report t he runn ing time, we selected a sub sets of our experiments and ran them on a core(TM)2 Duo 2 .66 GHz li nu x system with 2GB of main memory.

Our method h as three parameters: Redu cing Factor (RF), (Starting) neighb orhoo d size (K) and Density Threshold (DT). The last t wo parameters are more important t han the first one, since they have direct control on the li nearization generated. Therefore, we condu cted an extensive e xperi-mental stud y on d ifferent values of these two parameters for each n etwork in our coll ection. Particularly we are inter-ested in the tradeoff betwee n the length of the li nearization and the neighb orhoo d size.

We measured the compress ion p erformance using the bits/edge rate, as the previous s tud ies did. In add ition, we also report some other performance statistics s uch as query process ing time.

Another interesting tradeoff in our method is betwee n the out-neighb or query process ing time and in-neighb or query process ing time. An implementation d ecision is how to store the local i nformation for each p osition. There are two o p-tions. In the first option, for each p osition in the Eulerian data structure, we can u se the first k bits to record the out-edges to the previous k vertices in the li nearization li st, and use the next k bits to record the out-edges to the next k vertices in the li st. In the second option, we can u se the 2 k bits to record b oth the out-edges and in-edges betwee n the curr ent position and the next k positions.

The first option b iases on the out-neighb or queries. To a n-(K, redu cing factor) (10 , 1) (10 , 0.9) (15 , 0.9) (20 , 0.9) (30 , 0.9) ca-HepPh 5.24 5.09 4.76 4.63 5.00 4.59 4.57 5.20 4.65 4.53 5.51 4.79 4.69 poo r locali ty measures ( Gcc and F re ) swer an in-neighb or query about a vertex u , we have to scan the k positions preceding a nd foll owing every occ urr ence of u in the li nearization li st. We implemented the second op-tion in our experiments which d oes not bias on any specific types of neighb or queries. Table 3 summarizes the results about compress ion rate. Whil e the performance of our method varies on d ifferent data sets, the interesting o bservation h ere is the strong neg-ative corr elation b etwee n the bits/edge rate and the value of locali ty measures. The averag e degree of the network see ms important, too . In p articular, F re and Gcc are larger in Amazon0302 than in Amazon0312 , bu t t he performance of our method is bett er on Amazon0312 . We beli eve that t his is du e to the higher averag e degree in Amazon0312 than Amazon0302 .

It is interesting to loo k at t he difference betwee n d ata sets email -Enron and email -EuAll from the same catego ry. Data set email -Enron h as one of the best bits/edge rates and email -EuAll has one of the worst. We think this may be a foo tprint of the difference in commun ication p att erns in indu stry and in academia.

The results clearly shows that our method takes advantag e of the locali ty properties of the social networks. Our best result for the LiveJournal data set is 13 . 91 bits/edge, whil e the best result of BV scheme for the same data set is 14 . 308 (reported in [8]). Please note that BV scheme supp orts only the out-neighb orhoo d queries. To a nswer both out-neighb or and in-neighb or queries, BV schema nee ds 2  X  14 . 308 bits per edge, ass uming that encoding the transpose of the graph has app roximately the same rate. Moreover, our method is flexible for incremental upd ates. We only nee d to encode the incremental sub graph . BV schema does not all ow sub li near upd ates.
We report t he query process ing time for two types of queries. An adjacency q uery checks whether a query edge ( u, v )  X  E . A neighb or query searches for all out-neighb ors and in-neighb ors of a query v ertex u .

We used K = 20 , RF = 0 . 25 a nd DT = 0 . 9 a s the default values for the parameters. Table 4 reports the averag e acc ess dataset comp. SNA P comp. SNA P amazon0302 800 750 951 72 amazon0312 1170 790 1753 46 ca-Cond Mat 390 420 777 30 ca-HepPh 520 400 1849 19 cit-HepPh 1300 480 2745 28 cit-Patents 1400 930 1842 91 email -Enron 620 500 5539 31 email -EuAll 530 670 21518 148 p2p-Gnu tell a08 640 320 1663 34 p2p-Gnu tell a24 600 320 1488 50 soc-LiveJournal1 3050 1130 9734 49 soc-Slashd ot0902 1380 610 7884 35 web-Goog le 810 830 4110 66 web-Stand ford 890 810 39939 49 Table 4: The average acc ess time per edge for pro-cess ing adjacency q ueries and (in+out) neighb or queries. time for the adjacency q ueries performed on the compress ed graph s (comp.) and on the original graph s (SNA P) using the SNA P implementation of the graph d ata structure. We ran 1 milli on adjacency q ueries and 1 milli on n eighb orhoo d queries, and n ormali zed the time by the nu mber of edges that t hose queries returned. The time is in n ano second .
Our method spend s up to 3 times more time to a nswer an adjacency q uery than that on the original graph . In most cases, extra cost in our method is very minor. For neighb or queries, the query answering time depend s on the e fficiency of the li nearization. One vertex and one e dge may app ear multiple times in a li nearization. The more repli cates, the longer the query answering time.
We divide the bits/edge rate in our method into two parts the bits/edge rate e ncoding local i nformation, and that en-coding the points. The total bits/edge rate is s imply the sum of the two. Figure 3: The trade off betwee n the bits/edge rate of local i nformation and that of pointers on three data sets: ca-HepPh, p2p-Gnu tell a24 , and soc-Slashd ot0902 . ( K = 20 , RF = 0 . 9 ) Figure 4: The trade off betwee n the bits/edge rate of local i nformation and that of pointers on three data sets: ca-HepPh, p2p-Gnu tell a24 , and soc-Slashd ot0902 . ( DT = 0 . 25 and RF = 0 . 9 )
We stud ied the tradeoff betwee n the local bits/edge rate and that of the points when we varied the parameters of our method. Limited b y space, we only report here the tradeoff for two parameters: the density threshold ( DT ) and the starting wind ow size ( K ). We chose three data sets: ca-HepPh which h as the best compress ion rate, p2p-Gnu tell a24 which h as the worse compress ion rate, and soc-Slashd ot0902 which h as about t he averag e compress ion rate.

In the first experiment, we varied DT = 0 . 15 to 0 . 45 with step 0 . 05 , and fi xed the other two parameters K = 20 a nd RF = 0 . 9. Figure 3 shows the local i nformation b its/edge rate and the total bits/edge rate. Clearly, the compress ion rate is insensitive to parameter DT . Therefore, sett ing the parameter is not a big problem.

In the second experiment, we fixed DT = 0 . 25 a nd RF = 0 . 9, and varied K from 1 to 30 . Figure 4 shows the results. Increasing k leads to bett er compress ion rates on the ca-HepPh and S oc-Slashd ot0902 data sets. However, when k is 5 o r larger, i ncreasing k does not ga in b ig a dvantag e. Therefore, sett ing k to a value betwee n 5 a nd 10 is a goo d experience choice.
In this paper, we tackled the problem of compress ing so-cial networks in a neighb or query friend ly way. We de-veloped an effective social network compress ion app roa ch achieved b y a novel Eulerian d ata structure using multi-position li nearizations of directed graph s. Importantly, our method comes with a nontrivial theoretical bound on the compress ion rate. To the best of our knowledge, our ap-proa ch is the first t hat can answer both out-neighb or and in-neighb or queries in sub li near time. An extensive e mpir-ical stud y on more than a dozen b enchmark real data sets justifies the e ffectiveness of our method.

The e ncourag ing results in this s tud y sugg est several i n-teresting future directions. First, i t is interesting to explore app roximation methods for MP k li nearization for k &gt; 1. Second , i t is interesting to explore e ffective methods to de-termine a goo d value of k for MP k li nearization compress ion of social networks. Last, our heuristic algo rithm is s imple. It leaves s pace for further improvement in b oth the compres-sion rate and the compress ion run time.
