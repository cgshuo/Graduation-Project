 Similarity search has been extensively st udied in the recent decades. It often includes the familiar query types in terms of nearness, such as range query, k-nearest neigh-bor query ( k -NN) [3, 6, 7, 11, 15, 18], reverse nearest neighbor query (RNN) [1, 10, 16, 17, 19], and so on. On the other hand, the opposite query types  X   X  X urthest X  ver-sions in terms of farness, such as k-furthest neighbor query ( k -FN) and reverse furthest neighbor query (RFN) are lack of concentrative investiga-tions. In this paper, we are interested in the RFN query.
 Here, an RFN query is to retrieve the objects in an object set O , whose furthest neighbor is the query q . For instance, as shown in Fig. 1, given the object set O and the query ob-ject q , then the answer to the RFN of q is { o 3 ,o 4 } .Simply, the processing computes all the pairs of distances between q and o i ( o i  X  O ). As illustrated by the dotted lines, object o 3 holds the furthest distance to q than other objects in O thus is included in the answer set. o 4 is an answer as the same reason.

Regarding the applications of RFN, as pointed out by the scientists of operation re-location of a new facility (rubbish dumps, chemical plants, super market, police station, ing the problem of competitive facility location is still an attractive open problem [8]. Facing such research mission, efficient processing of RFN query must become signifi-cantly helpful. For simplicity, we highlight a real world example of competitive facility location problem as follows.
 Application. Consider to open a new store for a convenience store franchise chain, such as 7-Eleven, Lawson, FamilyMart, etc.. It is one of the important factors to re-duce the influence (competition) to the exis ting ones. Suppose that there are several cations of existing ones ( O = { o 1 ,o 2 ,  X  X  X  ,o n } ) are known. Under the consideration of competition, it is better to choose the location that is far from the existing ones in number as many as possible. It means that most of the existing stores take the chosen candidate as their furthest neighbor, thus the influence can be maximally reduced (i.e., arg max q i  X  Q {| answers to q i sRFN |} ).

In such kind of applications that take into account the evaluation criterion in terms of farness but not nearness, the RFN query plays an important role to help to make decisions. Nevertheless, due to the differe nt distance properties between farness and nearness, the existing approaches concerning nearness cannot be employed to solve the corresponding problems directly. This implicates that specialized new algorithms should be exploited to handle the RFN query.

However, to the best of our knowledge, throughout the recent decades, there are few discussions concentrating on the query type of RFN. Yao et al. [20] are the first who fully identified the RFN query and proposed several algorithms to handle the query processing, such as the so-called  X  X rogressive furthest cell (PFC) X  and  X  X onvex hull furthest cell (CHFC) X  algorithms. The both algorithms adopt R-tree index, and use furthest Voronoi cell (fvc) to determine whether the objects o  X  O are q  X  X  RFN. In spite of that their algorithms are reported much e fficient than brute-force search (BFS), they still need time consuming construction of dynamic convex hull and the furthest Voronoi cell w.r.t query q on the fly. Against these drawbacks, the state-of-the-art method is proposed in our previous work [12]. The so-called  X  X IV X  algorithm processes the RFN query in a new workflow that consists of filtering and refinement phases, utilizing the efficient properties derived from triangular inequality based on the representative pivots. However, for an arbitrary query without any location constraint, the PIV algorithm is not always powerful due to the unnecessary cost for filtering.

Motivating us to further accelerate the RFN query processing on the fly, in this paper, we introduce our new findings on the filtering techniques, that adapt for arbitrary query and make the filtering cost dramatically d ecrease. Our findings and the main contribu-tions of this work are summarized as follows. 1. We first analyze and clarify the cases when the PIV algorithm is inefficient. 3. We discuss the complexity of the proposed algorithm, and perform extensive ex-The remainder of the paper is organized as follows. Section 2 surveys the related work, then preliminary knowledge used in this work is described in Section 3. Then we intro-duce the details of our new findings in Section 4, including the safe area, the mathemat-ical proof, the algorithm and the complexity analysis. The experimental evaluations are presented in Section 5. Finally, Section 6 comes to conclude this work and goes into perspective of the future work. The query type of reverse furthest neighbor (RFN) was first slightly mentioned in [10], when the authors mainly discussed the reverse nearest neighbor (RNN) query in their work. However, throughout the past decades, there was few work focusing on the RFN query, until the recent work [20] appeared that is the work most closely related to ours.
In [20], Yao et al. originally defined the query type of RFN, and proposed the pro-gressive furthest cell (PFC) algorithm and the convex hull furthest cell (CHFC) algo-rithm to handle RFN query. Both adopt R-tree index, and use the furthest Voronoi cell (fvc) to determine whether the points o  X  O are q  X  X  RFN. The fvc ( q,O ) is to define a convex polygon w.r.t the query q in the given space of dataset O . To compute the is separated into two subspaces, the fvc ( q,O ) takes the intersection of all subspaces far away from the query q .The fvc ( q,O ) strictly limits the answer set if and only if the point o  X  fvc ( q,O ) . Straightforwardly, the authors proposed the PFC algorithm to compute fvc ( q,O ) with the R-tree for each given query q on the fly. The authors also pointed out that the post-processing of PFC algorithm is expensive, so that they de-signed the faster one (CHFC) by utilizing the important property of convex hull. Instead of computing the fvc ( q,O ) over the whole dataset, the CHFC algorithm constructs the dynamic convex hull C O on the merged dataset O  X  X  q } , computes the fvc ( q,O ) only based on C O , and then performs a containment query on R-tree index to retrieve the points contained in the fvc ( q,O ) as answers to q  X  X  RFN. Hence, the CHFC algorithm outperforms the PFC, without expensive post-processing.

Although the CHFC algorithm was reported much efficient than brute-force search (BFS) and PFC, it still needs time consuming construction of convex hull ( C O )andthe the state-of-the-art approach was proposed in our previous work [12]. The approach independently pre-computes the static convex hull C O of dataset O without considering the dynamic construction by merging q into dataset O , and selects the vertices of C O as representative pivot set S piv for the utilization of filtering. The pairwise distances between  X  p  X  S piv and  X  o  X  O are pre-computed and stored into an metric index, among them, the maximum distance w.r.t each o is recorded as well. A so-called  X  X IV X  algorithm was proposed to handle the RFN query in a new workflow that consists of filtering and refinement phases. The filtering phase is utilizing the efficient properties derived from triangular inequality based on the representative pivots and the metric index. After the high ratio filtering, only a few candidates remain and the refinement phase examines the real distance to confirm if a candidate is an answer to q  X  X  RFN. The PIV algorithm was reported outperforming all the related ones.

However, we found that the PIV algorithm is not always efficient in any cases. Sim-ply, issue an arbitrary query q in any location, when q is far enough from the whole dataset O , any filtering and refinement become unnecessary because it is obvious that all objects in O are answers to q  X  X  RFN. While indeed, measuring such  X  X ow far is enough X  is not easy to predict. Motivated by this, we are aiming at figuring out such  X  X ar enough X  boundary (say, safe area in this work), and designing a novel algorithm to further accelerate the query processing on the fly. The details of our new approach are described in the following sections. Since this work departures from our previous one [12], the necessary preliminaries furthest neighbor (RFN) query as follows . Without loss of generality, we assume that the distance measure is on the 2D Euclidean space in this paper, yet indeed, it is not function.
 Definition 1 (RFN). Given an object set O and a query q , the answer to q  X  X  reverse fur-Based on [12], the proposed PIV al-gorithm utilizes one theorem and two lemmas for filtering as follows. The-orem 1 essentially tells that only if q is on the boundary of, or outside the convex hull C O ,the RFN ( q ) may be found. Otherwise, no answer can be found if q inside C O . Lemma 1 in-dicates if such an object o satisfies the upper bound c ondition (Eq. 1), o should be discarded as it has no chance to appear in the answer set of RFN ( q ) . Oppo-sitely, Lemma 2 guarantees such an object o that satisfies the lower bound condition (Eq. 2), safely included into RFN ( q ) . As prerequisites of the two lemmas, the vertices of C O are selected as a pivot set S piv , pairwise distances dist ( o, p i ) for o  X  O and p  X  S addition, dist ( p i ,q ) (i.e.,  X  in Fig. 2) can be quickly computed on the fly. then the answer set of RFN ( q ) is empty.
 Lemma 1 (Upper bound).  X  o  X  O ,if o satisfies Eq. 1, o can be excluded from RFN ( q ) . Lemma 2 (Lower bound).  X  o  X  O ,if o satisfies Eq. 2, o is safely included into RFN ( q ) . As we mentioned before, the PIV algorithm is not always efficient for an arbitrary query q that is without constraint of location. Therefore, in this section, we first exhibit the evidence to analyze the inefficiency of PIV algorithm. Based on the analysis, we present the details to figure out a non-trivial safe area guaranteed by strict mathematical proof. Subsequently, an adapted algorithm, named PIV + , is designed to enhance the query processing, and its algorithmic complexity is discussed as well. 4.1 Inefficiency of PIV For an arbitrary query q , its location can be considered in three cases. 1) When q is located inside the convex hull C O of dataset O , the query processing terminates im-mediately according to Theorem 1, because it is guaranteed that there is no answer to RFN ( q ) .2)If q is located outside C O , filtering and refinement processing involving in algorithm PIV should be executed (e.g., in Fig. 3 w.r.t q ). 3) Suppose that q is issued considerably apart from C O , say  X  X ar enough X  here, it is possible to return the whole dataset O as RFN ( q ) , as soon as q  X  X  location exceeds a certain boundary. As depicted in Fig. 3 w.r.t q locating  X  X ar enough X , at this moment, we do not know the shape of the exact boundary. Thus, we conjecture that there would be a boundary that maybe look like an arc as imagining to be in bold (and red color) in Fig. 3. If our conjecture concerning such boundary is computable, we could efficiently answer RFN ( q ) without filtering or refinement in this case.
Anyway, the PIV algorithm must be inefficient for such a query that exceeds the boundary. So to confirm the (in)efficiency, we performed an experiment (details in Sec-launch the PIV algorithm on a uniform dataset O  X  [0 , 1] 2 having 10,000 points. As the result demonstrated in Fig. 4, the filtering cost of PIV algorithm does not decrease even though q is very far from O . Theoretically, when q.x &gt; 1+ should be naturally returned as answer to RFN ( q ) thus no filtering cost needs. It means that the trend of the curve should drop down asymptotic to zero when q.x exceeds the threshold value, looking like the curve depicted in dotted line and labelled by  X  X IV (ideal) X . 4.2 Construction of Safe Area In order to identify the boundary, the necessary definitions are depicted in Fig. 5. They are presented as follows.
 Definition 2 (Diameter of convex hull). In a dataset O , and given its convex hull C O , the diameter of C O is the maximal distance between any two vertices on the convex hull, which is denoted by d = max { dist ( u, v ) | u, v  X  C O } . As shown in Fig. 5, the dashed line inside the con-vex hull C O w.r.t dataset O denotes the diameter d of C
O . From the definition, d is the maximal one among all the pairwise distances between any two vertices on the convex hull C O . Meanwhile, according to the con-clusion in [4], the diameter of convex hull is also the diameter of the whole dataset . It is natural to know that d is also the maximal one of the pairwise distances in dataset O . It is an important property to quickly an-swer RFN ( q ) . For a given query q and  X  o  X  O ,if | oq | &gt;d is satisfied, the whole dataset O can be safely included as answers to RFN ( q ) . Along this clue, we attempt to construct a safe area which guarantees that tion, vertex circle, in the following.
 Definition 3 (Vertex circle). For a given convex hull C O , a circle is called  X  X ertex by vc ( p ) .
 The dashed circle drawn in Fig. 5 denotes the vertex circle vc ( p ) w.r.t the specified vertex p on C O . We then employ the vertex circle and other geometric elements to define a non-trivial safe area by its constructing steps as follows.
 Definition 4 (Safe area). Given a dataset O and its convex hull C O , for a specified  X  Find p  X  X  two adjacent vertices u, v on convex hull C O .  X  Draw vertex circle vc ( p ) centered at the vertex p .  X  Draw two tangent lines touching vc ( p ) , paralleling to up, vp , respectively.  X  Draw two perpendicular bisectors of up, vp , respectively.
 p of C O , and with  X  ( p ) as well.
 For instance in Fig. 5, the semi-closure area apart from the dataset, which is separated by the (red) bold boundary, denotes the safe area  X  ( p ) w.r.t p . By utilizing such safe area, we have a non-trivial finding concluded in Theorem 2.
 Theorem 2. For an arbitrary query q outside C O ,if q locates inside the  X  X afe area X   X  ( p ) w. r. t p  X  C O (not on the boundary), then RFN ( q )= O .
 Proof. Given q , then its nearest convex hull vertex, p , is determined. Hence q can only locate in either of the two areas in the following. 1. q apart from the arc of vc ( p ) (Fig. 6). 2. q apart from one of the two tangent lines (Fig. 7). During the proof, we import three assistant symbols,  X ,  X  1 , X  2 ,inFig.6and7.InTheo-Case 1 Apparently,  X  opq  X   X  upq  X   X  upt 2 =90  X  . This means that  X  opq is the largest angle in opq , hence the edge oq across from it is also the largest one in the triangle. This leads to | oq | , which means q is the farthest neighbor of o . This is to say that the whole dataset O becomes the answer to RFN ( q ) .
 Case 2 between the two parallel lines t 1 t 2 and up ,is d ,then | AB | X | t 2 p | = d . Hence, we have Similar to the discussion in Case 1, this leads to the conclusion that all objects in O are t t 4 , is similar.
 In addition, the safe area  X  ( p ) w.r.t p is a semi-closure and irregular boundary, which makes it not easy to express in a simple mathematical form. Instead, for the simplicity of computation, we adopt the combination of regular shapes to examine whether q is inside  X  ( p ) or not. For instance, the rectangles R u and R v (in Fig. 6) can be computed respectively. Subsequently, the judgeme nt can be accomplished by testing the following boolean condition, | pq | &gt;d  X  q R u  X  q R v .Ifitistrue, q must be inside  X  ( p ) , otherwise not. 4.3 The Algorithm PIV + Based on theoretical guarantee presente d in Section 4.2, we design an adapted algo-rithm (shortly named PIV + ) to speed up the RFN query processing. In Algorithm 1, we can easily pre-compute the safe area  X  ( O ) (Eq. 3) w.r.t dataset O , by iterating all the vertices on the convex hull C O and then taking their union. When an arbitrary query q dataset O as answer to RFN ( q ) immediately (line 4). Othe rwise, call the algorithm PIV to retrieve answers (line 6). For examining q  X   X  ( p ) , we also design a function (named InsideOmega) based on the discussions in Section 4.2.
 Algorithm 1. PIV + (Query q ,Pivots S piv , Dataset O ) Algorithmic Complexity: Concerning the complexity of algorithm PIV + , in the best case, it only costs O ( m ) for seeking the nearest vertex to q on C O . As the fact, m = Function 1. InsideOmega (Query q ,Safearea  X  ( p ) , Diameter d ) | C N = | O | . Although in the worst case, the complexity of PIV + reaches the same order of magnitude as PIV. Generally speaking, for an arbitrary query q on a limitless space, the more probabilities entering the safe area q has, the more efficient PIV + is than PIV. The corresponding experiment results in Fig. 9 and 10 are also positively confirming this complexity analysis. In this section, we report the extensive results of our experimental evaluations. All the experiments are executed on an Intel-based computer and Linux OS. The CPU is In-tel(R) Xeon (R) 2.83 GHz and the amount of main memory is 16.0GB. The programs are implemented in C++ language, using the open-source libraries: Spatial Index Li-brary 1 and CGAL Library 2 . For taking into account IOs, the page size is set to 4KB. In order to make the comparison fair, we use the same datasets as used in [12, 20]. dataset in Fig. 8. The synthetic datasets include Uniform distribution (UN), Correlated Bivariate (CB), and Random-Cluster distribution (RC). The real dataset is obtained from the digital chart of the world server 3 . The real dataset (Map) is merged from 3 kinds of 2-D point data defining the road networks for California (CA) and its interest points, San Francisco (SF) and USA (US), totally 476,587 points. All the datasets are normalized to the space S =[0 ,L 0 ] 2 ,L 0 = 100000 . Then we randomly select dif-ferent sizes of sub datasets: 10K, 50K, 100K, 200K, 300K, and 400K, as input to the programs. To guarantee an arbitrary query could appear (1) inside the convex hull C O , (2) outside but not far from C O , and (3)  X  X ar enough X  from C O , we randomly generate reported on the average of 100 queries. For the performance measurement, our proposed algorithm (PIV + ) is compared with the other two algorithms (PIV, and CHFC). 5.1 Effectiveness of PIV + Firstly, we reproduced the drawback of PIV algorithm. As mentioned in Section 4.1, Fig. 4, we fix a uniform distribution dataset containing 10K objects, and vary the loca-tion of q from inside of convex hull C O to  X  X ar enough X . We then run the PIV + and PIV algorithms for comparison and present the result in Fig. 4. As q.x increase, the ideal  X  X IV (ideal) X . When q.x &lt; 1 , q is inside the convex hull C O thus the algorithm needs nearly zero cost, so is the case when q.x exceeds 1+ the range, the PIV algorithm needs extra cost to perform filtering. However, the curve denoting the real performance of PIV, is still keeping the similar trend. In contrast, the proposed PIV + algorithm is consistent with our expectation, running to the same trend of the curve  X  X IV (ideal) X . This expre ssly confirms the effectiveness of the PIV + algorithm that overcame the drawback of PIV.
To respond to the complexity analy-sis mentioned in Section 4.3, we count the size of pivot set ( m ) and the size of dataset ( N ). The results are presented in Fig. 9, (a) referring to the absolute car-dinality m versus N and (b) concerning the ratio of m/N versus N . Fig. 10a in-dicates that m does not have any linear nor logarithmic increase with N ,and m appears to be stable on different datasets. Fig. 9b further tells that m is relatively much smaller than N , and their ratios are less than 1.00% in our experiments.
Besides, we conduct the experiment to examine how the filtering cost is influenced by the probability, of which the query q enters the safe area  X  . For this purpose, we vary the range of the space S where the 100 queries are randomly generated from. N to 200K. By this setting, the probability of q entering  X  increases as L enlarges. As shown in Fig. 10, the results of comparing PIV + with PIV based on four different datasets exhibit similar trends of the filtering cost. It can be clearly confirmed that the filtering cost of PIV + dramatically drops down when L exceeds a certain threshold. That is where the case q entering  X  happens. Moreover, the filtering cost continues to decrease as the increase of the probability of q entering  X  , and to asymptotically trend towards the little cost O ( m ) for seeking the nearest vertex to q on C O that is the best case mentioned in Section 4.3. 5.2 Efficiency and Scalability of PIV + Since we have observed the influence of filtering cost by changing the query set as afore-algorithm only in terms of filtering cost comparing with PIV. The results on four differ-ent datasets are illustrated in Fig. 11, which implicate that the PIV + algorithm speeds up approximate 2 times than PIV. competitor to PIV + . We change different sizes of four datasets to test the efficiency and scalability using the same settings as above. As the results reported in Fig. 12 and 13, the PIV + algorithm outperforms the others in all aspects. For the total CPU cost, no matter on synthetic or real datasets, the PIV + algorithm performs the best, approximate 2 times faster than PIV and over 10 times fa ster than CHFC. In terms of I/O cost, the PIV + algorithm also exhibits similar better trend than the competitors. Concerning the aspect of scalability, more exactly th e stability, our proposed algorithms PIV + and PIV perform better than CHFC by observing the trends of the curves in Fig. 13 which is in logarithmic scale. Approximately, our algorithms are more stable and scalable than CHFC in one order of magnitude. Conclusion. In this paper, we introduced our new finding of the safe area  X  that guar-antees without filtering cost when query q  X   X  . We also designed an efficient algorithm PIV + to adapt for arbitrary RFN query, for which the previous algorithm PIV does not always perform efficiently. The effectiveness, efficiency and scalability of our approach was confirmed by extensive experiments.
 Future Work. Extending this work to process RFN queries on multi-dimensional spaces with more discussions and additional experiments must be considerable plans. To fur-ther shrink the safe area and make it optimal, and to make its shape more regular for the simplicity of geometric computation should be another directions as well. Moreover, we are planning to index the pivot set by existing methods to reduce the cost for checking the safe area, and also to develop a search system integrated with RFN queries. Acknowledgment. This research has been supported in part by the Grant-in-Aid for Scientific Research from JSPS (#21240005).

